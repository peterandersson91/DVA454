
Lab6.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         000031cc  80002028  80002028  00002428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  80005200  80005200  00005600  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  80005400  80005400  00005800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       00000150  80005418  80005418  00005818  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  8 .ctors        00000008  00000008  80005568  00005c08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .dtors        00000008  00000010  80005570  00005c10  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .jcr          00000004  00000018  80005578  00005c18  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got          00000000  0000001c  8000557c  00005c1c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         0000050c  0000001c  8000557c  00005c1c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .balign       00000000  00000528  80005a88  00006128  2**0
                  ALLOC
 14 .bss          00000288  00000528  00000528  00000000  2**2
                  ALLOC
 15 .heap         0000e850  000007b0  000007b0  00000000  2**0
                  ALLOC
 16 .comment      00000030  00000000  00000000  00006128  2**0
                  CONTENTS, READONLY
 17 .debug_aranges 00000a70  00000000  00000000  00006158  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_pubnames 000014f2  00000000  00000000  00006bc8  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_info   0001312f  00000000  00000000  000080ba  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_abbrev 00002952  00000000  00000000  0001b1e9  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_line   000095d9  00000000  00000000  0001db3b  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_frame  00001c4c  00000000  00000000  00027114  2**2
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_str    00003644  00000000  00000000  00028d60  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_loc    00003108  00000000  00000000  0002c3a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_macinfo 00b3cffc  00000000  00000000  0002f4ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 27 .debug_ranges 00000998  00000000  00000000  00b6c4a8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	20 28       	sub	r8,2

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

8000200c <_init>:
8000200c:	eb cd 40 40 	pushm	r6,lr
80002010:	48 26       	lddpc	r6,80002018 <_init+0xc>
80002012:	1e 26       	rsub	r6,pc
80002014:	c0 48       	rjmp	8000201c <_init+0x10>
80002016:	d7 03       	nop
80002018:	80 00       	ld.sh	r0,r0[0x0]
8000201a:	1f f6       	ld.ub	r6,pc[0x7]
8000201c:	c5 2c       	rcall	800020c0 <frame_dummy>
8000201e:	e0 a0 18 e1 	rcall	800051e0 <__do_global_ctors_aux>
80002022:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002028 <_stext>:
80002028:	30 07       	mov	r7,0
8000202a:	e0 7a 00 00 	mov	r10,65536
8000202e:	5b fa       	cp.w	r10,-1
80002030:	f4 0d 17 10 	movne	sp,r10
80002034:	fe cb ca cc 	sub	r11,pc,-13620
80002038:	30 8c       	mov	r12,8
8000203a:	18 3b       	cp.w	r11,r12
8000203c:	c0 70       	breq	8000204a <_stext+0x22>
8000203e:	e0 6a 05 28 	mov	r10,1320
80002042:	b7 09       	ld.d	r8,r11++
80002044:	b9 28       	st.d	r12++,r8
80002046:	14 3c       	cp.w	r12,r10
80002048:	cf d5       	brlt	80002042 <_stext+0x1a>
8000204a:	e0 6a 07 b0 	mov	r10,1968
8000204e:	e0 6c 05 28 	mov	r12,1320
80002052:	30 08       	mov	r8,0
80002054:	30 09       	mov	r9,0
80002056:	b9 28       	st.d	r12++,r8
80002058:	14 3c       	cp.w	r12,r10
8000205a:	cf e5       	brlt	80002056 <_stext+0x2e>
8000205c:	e0 a0 07 7a 	rcall	80002f50 <_init_startup>
80002060:	fe cc cc 60 	sub	r12,pc,-13216
80002064:	e0 a0 13 b4 	rcall	800047cc <atexit>
80002068:	cd 2f       	rcall	8000200c <_init>
8000206a:	1a 9c       	mov	r12,sp
8000206c:	30 0b       	mov	r11,0
8000206e:	e0 a0 16 c7 	rcall	80004dfc <_init_argv>
80002072:	5b fc       	cp.w	r12,-1
80002074:	f9 bc 00 00 	moveq	r12,0
80002078:	f9 ba 00 00 	moveq	r10,0
8000207c:	14 1d       	sub	sp,r10
8000207e:	c8 dd       	rcall	80002398 <main>
80002080:	e0 a0 13 ae 	rcall	800047dc <exit>

80002084 <__do_global_dtors_aux>:
80002084:	d4 21       	pushm	r4-r7,lr
80002086:	e0 68 05 28 	mov	r8,1320
8000208a:	11 89       	ld.ub	r9,r8[0x0]
8000208c:	30 08       	mov	r8,0
8000208e:	f0 09 18 00 	cp.b	r9,r8
80002092:	c1 61       	brne	800020be <__do_global_dtors_aux+0x3a>
80002094:	31 08       	mov	r8,16
80002096:	31 46       	mov	r6,20
80002098:	10 95       	mov	r5,r8
8000209a:	10 16       	sub	r6,r8
8000209c:	e0 67 05 2c 	mov	r7,1324
800020a0:	a3 46       	asr	r6,0x2
800020a2:	20 16       	sub	r6,1
800020a4:	c0 68       	rjmp	800020b0 <__do_global_dtors_aux+0x2c>
800020a6:	2f f8       	sub	r8,-1
800020a8:	8f 08       	st.w	r7[0x0],r8
800020aa:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020ae:	5d 18       	icall	r8
800020b0:	6e 08       	ld.w	r8,r7[0x0]
800020b2:	0c 38       	cp.w	r8,r6
800020b4:	cf 93       	brcs	800020a6 <__do_global_dtors_aux+0x22>
800020b6:	30 19       	mov	r9,1
800020b8:	e0 68 05 28 	mov	r8,1320
800020bc:	b0 89       	st.b	r8[0x0],r9
800020be:	d8 22       	popm	r4-r7,pc

800020c0 <frame_dummy>:
800020c0:	d4 01       	pushm	lr
800020c2:	31 8c       	mov	r12,24
800020c4:	78 08       	ld.w	r8,r12[0x0]
800020c6:	58 08       	cp.w	r8,0
800020c8:	c0 50       	breq	800020d2 <frame_dummy+0x12>
800020ca:	48 38       	lddpc	r8,800020d4 <frame_dummy+0x14>
800020cc:	58 08       	cp.w	r8,0
800020ce:	c0 20       	breq	800020d2 <frame_dummy+0x12>
800020d0:	5d 18       	icall	r8
800020d2:	d8 02       	popm	pc
800020d4:	00 00       	add	r0,r0
	...

800020d8 <initLED>:
#include "LED.h"

void initLED (void)
{
800020d8:	eb cd 40 80 	pushm	r7,lr
800020dc:	1a 97       	mov	r7,sp
800020de:	20 1d       	sub	sp,4
	/*
	* First make access to the GPIO port registers
	* shorter to type , just for our convenience
	*/
	volatile avr32_gpio_port_t * led0_port;
	led0_port = &AVR32_GPIO.port[LED0_PORT];
800020e0:	fe 78 11 00 	mov	r8,-61184
800020e4:	ef 48 ff fc 	st.w	r7[-4],r8
	/*
	* Choose GPIO peripheral function ,
	* by writing a 1 to gpers , GPIO Enable Register Set
	*/
	led0_port->gpers = LED0_BIT_VALUE;
800020e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800020ec:	fc 19 08 00 	movh	r9,0x800
800020f0:	91 19       	st.w	r8[0x4],r9
	led0_port->gpers = LED1_BIT_VALUE;
800020f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800020f6:	fc 19 10 00 	movh	r9,0x1000
800020fa:	91 19       	st.w	r8[0x4],r9
	led0_port->gpers = LED2_BIT_VALUE;
800020fc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002100:	fc 19 20 00 	movh	r9,0x2000
80002104:	91 19       	st.w	r8[0x4],r9
	/*
	* Set the output value register to 1 in order to
	* turn the LED off (1= off , 0= on in this case ) ,
	* by writing a 1 to ovrs , Output Value Register Set
	*/
	led0_port->ovrs = LED0_BIT_VALUE;
80002106:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000210a:	fc 19 08 00 	movh	r9,0x800
8000210e:	f1 49 00 54 	st.w	r8[84],r9
	led0_port->ovrs = LED1_BIT_VALUE;
80002112:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002116:	fc 19 10 00 	movh	r9,0x1000
8000211a:	f1 49 00 54 	st.w	r8[84],r9
	led0_port->ovrs = LED2_BIT_VALUE;
8000211e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002122:	fc 19 20 00 	movh	r9,0x2000
80002126:	f1 49 00 54 	st.w	r8[84],r9
	/*
	* Set the output enable register ,
	* by writing a 1 to oders , Output Drive Enable
	* Register Set
	*/
	led0_port->oders = LED0_BIT_VALUE;
8000212a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000212e:	fc 19 08 00 	movh	r9,0x800
80002132:	f1 49 00 44 	st.w	r8[68],r9
	led0_port->oders = LED1_BIT_VALUE;
80002136:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000213a:	fc 19 10 00 	movh	r9,0x1000
8000213e:	f1 49 00 44 	st.w	r8[68],r9
	led0_port->oders = LED2_BIT_VALUE;
80002142:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002146:	fc 19 20 00 	movh	r9,0x2000
8000214a:	f1 49 00 44 	st.w	r8[68],r9
}
8000214e:	2f fd       	sub	sp,-4
80002150:	e3 cd 80 80 	ldm	sp++,r7,pc

80002154 <onLED>:
{
	AVR32_GPIO.port[LED0_PORT].ovrt = ledNr;
}

void onLED(int ledNr)
{
80002154:	eb cd 40 80 	pushm	r7,lr
80002158:	1a 97       	mov	r7,sp
8000215a:	20 1d       	sub	sp,4
8000215c:	ef 4c ff fc 	st.w	r7[-4],r12
	AVR32_GPIO.port[LED0_PORT].ovrc = ledNr;
80002160:	fe 78 10 00 	mov	r8,-61440
80002164:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002168:	f1 49 01 58 	st.w	r8[344],r9
}
8000216c:	2f fd       	sub	sp,-4
8000216e:	e3 cd 80 80 	ldm	sp++,r7,pc

80002172 <offLED>:

void offLED(int ledNr)
{
80002172:	eb cd 40 80 	pushm	r7,lr
80002176:	1a 97       	mov	r7,sp
80002178:	20 1d       	sub	sp,4
8000217a:	ef 4c ff fc 	st.w	r7[-4],r12
	AVR32_GPIO.port[LED0_PORT].ovrs = ledNr;
8000217e:	fe 78 10 00 	mov	r8,-61440
80002182:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002186:	f1 49 01 54 	st.w	r8[340],r9
8000218a:	2f fd       	sub	sp,-4
8000218c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002190:	76 50       	ld.w	r0,r11[0x14]
80002192:	72 6f       	ld.w	pc,r9[0x18]
80002194:	64 75       	ld.w	r5,r2[0x1c]
80002196:	63 65       	ld.w	r5,r1[0x58]
80002198:	72 00       	ld.w	r0,r9[0x0]
8000219a:	00 00       	add	r0,r0
8000219c:	76 43       	ld.w	r3,r11[0x10]
8000219e:	6f 6e       	ld.w	lr,r7[0x58]
800021a0:	73 75       	ld.w	r5,r9[0x5c]
800021a2:	6d 65       	ld.w	r5,r6[0x58]
800021a4:	72 00       	ld.w	r0,r9[0x0]
	...

800021a8 <init_usart>:
		cycles--;
	}
}

void init_usart ( void )
{
800021a8:	eb cd 40 80 	pushm	r7,lr
800021ac:	1a 97       	mov	r7,sp
		. charlength = 8,
		. paritytype = USART_NO_PARITY ,
		. stopbits = USART_1_STOPBIT ,
		. channelmode = USART_NORMAL_CHMODE
	};
	pm_switch_to_osc0 (& AVR32_PM , FOSC0 , OSC0_STARTUP );
800021ae:	30 3a       	mov	r10,3
800021b0:	e0 6b 1b 00 	mov	r11,6912
800021b4:	ea 1b 00 b7 	orh	r11,0xb7
800021b8:	fe 7c 0c 00 	mov	r12,-62464
800021bc:	f0 1f 00 0f 	mcall	800021f8 <init_usart+0x50>
	gpio_enable_module ( USART_SERIAL_GPIO_MAP , 2);
800021c0:	30 2b       	mov	r11,2
800021c2:	48 fc       	lddpc	r12,800021fc <init_usart+0x54>
800021c4:	f0 1f 00 0f 	mcall	80002200 <init_usart+0x58>
	gpio_enable_module ( USART_DEBUG_GPIO_MAP , 2);
800021c8:	30 2b       	mov	r11,2
800021ca:	48 fc       	lddpc	r12,80002204 <init_usart+0x5c>
800021cc:	f0 1f 00 0d 	mcall	80002200 <init_usart+0x58>
	usart_init_rs232 ( serialPORT_USART , & USART_OPTIONS , FOSC0 );
800021d0:	e0 6a 1b 00 	mov	r10,6912
800021d4:	ea 1a 00 b7 	orh	r10,0xb7
800021d8:	48 cb       	lddpc	r11,80002208 <init_usart+0x60>
800021da:	fe 7c 18 00 	mov	r12,-59392
800021de:	f0 1f 00 0c 	mcall	8000220c <init_usart+0x64>
	usart_init_rs232 ( configDBG_USART , & USART_OPTIONS , FOSC0 );
800021e2:	e0 6a 1b 00 	mov	r10,6912
800021e6:	ea 1a 00 b7 	orh	r10,0xb7
800021ea:	48 8b       	lddpc	r11,80002208 <init_usart+0x60>
800021ec:	fe 7c 18 00 	mov	r12,-59392
800021f0:	f0 1f 00 07 	mcall	8000220c <init_usart+0x64>
}
800021f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800021f8:	80 00       	ld.sh	r0,r0[0x0]
800021fa:	29 74       	sub	r4,-105
800021fc:	80 00       	ld.sh	r0,r0[0x0]
800021fe:	54 18       	stdsp	sp[0x104],r8
80002200:	80 00       	ld.sh	r0,r0[0x0]
80002202:	24 54       	sub	r4,69
80002204:	80 00       	ld.sh	r0,r0[0x0]
80002206:	54 28       	stdsp	sp[0x108],r8
80002208:	80 00       	ld.sh	r0,r0[0x0]
8000220a:	54 38       	stdsp	sp[0x10c],r8
8000220c:	80 00       	ld.sh	r0,r0[0x0]
8000220e:	2b 24       	sub	r4,-78

80002210 <vProducer>:

void vProducer(void *pvParameters)
{	
80002210:	eb cd 40 80 	pushm	r7,lr
80002214:	1a 97       	mov	r7,sp
80002216:	20 dd       	sub	sp,52
80002218:	ef 4c ff cc 	st.w	r7[-52],r12
	portTickType xLastWakeTime;
	const portTickType xFreq = TASK_DELAY_MS(1000);
8000221c:	e0 68 03 e8 	mov	r8,1000
80002220:	ef 48 ff f8 	st.w	r7[-8],r8
	
	xLastWakeTime = xTaskGetTickCount();
80002224:	f0 1f 00 2a 	mcall	800022cc <vProducer+0xbc>
80002228:	18 98       	mov	r8,r12
8000222a:	ef 48 ff f4 	st.w	r7[-12],r8
	
	struct msg message;
	message.id = 0;
8000222e:	30 08       	mov	r8,0
80002230:	ef 48 ff e0 	st.w	r7[-32],r8
	//message.data = 0;
	message.timestamp = 0;
80002234:	30 08       	mov	r8,0
80002236:	ef 48 ff f0 	st.w	r7[-16],r8
	
	struct msg *pMesg = &message;
8000223a:	ee c8 00 20 	sub	r8,r7,32
8000223e:	ef 48 ff dc 	st.w	r7[-36],r8
	
	char data[DATALEN] = "hej";
80002242:	30 08       	mov	r8,0
80002244:	e0 69 6a 00 	mov	r9,27136
80002248:	ea 19 68 65 	orh	r9,0x6865
8000224c:	ee e9 ff d0 	st.d	r7[-48],r8
80002250:	30 08       	mov	r8,0
80002252:	ef 58 ff d8 	st.h	r7[-40],r8
	int i = byteCount;
80002256:	49 f8       	lddpc	r8,800022d0 <vProducer+0xc0>
80002258:	70 08       	ld.w	r8,r8[0x0]
8000225a:	ef 48 ff fc 	st.w	r7[-4],r8
	
	onLED(LED0_BIT_VALUE);
8000225e:	fc 1c 08 00 	movh	r12,0x800
80002262:	f0 1f 00 1d 	mcall	800022d4 <vProducer+0xc4>
80002266:	c0 28       	rjmp	8000226a <vProducer+0x5a>
		{
			vTaskResume(xHandleConsumer);
			onLED(LED1_BIT_VALUE);
		}
		
	}
80002268:	d7 03       	nop
	
	onLED(LED0_BIT_VALUE);
	
	while(1)
	{
		if(byteCount == BUFFER_SIZE)
8000226a:	49 a8       	lddpc	r8,800022d0 <vProducer+0xc0>
8000226c:	70 08       	ld.w	r8,r8[0x0]
8000226e:	58 a8       	cp.w	r8,10
80002270:	c0 81       	brne	80002280 <vProducer+0x70>
		{
			offLED(LED0_BIT_VALUE);
80002272:	fc 1c 08 00 	movh	r12,0x800
80002276:	f0 1f 00 19 	mcall	800022d8 <vProducer+0xc8>
			vTaskSuspend(NULL);	
8000227a:	30 0c       	mov	r12,0
8000227c:	f0 1f 00 18 	mcall	800022dc <vProducer+0xcc>
		}
		
		strcpy(pMesg->data, data);
80002280:	ee f8 ff dc 	ld.w	r8,r7[-36]
80002284:	2f c8       	sub	r8,-4
80002286:	ee c9 00 30 	sub	r9,r7,48
8000228a:	12 9b       	mov	r11,r9
8000228c:	10 9c       	mov	r12,r8
8000228e:	f0 1f 00 15 	mcall	800022e0 <vProducer+0xd0>
		
		xQueueSendToBack(xQHandle, &pMesg, (portTickType)10);
80002292:	49 58       	lddpc	r8,800022e4 <vProducer+0xd4>
80002294:	70 08       	ld.w	r8,r8[0x0]
80002296:	ee cb 00 24 	sub	r11,r7,36
8000229a:	30 09       	mov	r9,0
8000229c:	30 aa       	mov	r10,10
8000229e:	10 9c       	mov	r12,r8
800022a0:	f0 1f 00 12 	mcall	800022e8 <vProducer+0xd8>
		
		byteCount++;
800022a4:	48 b8       	lddpc	r8,800022d0 <vProducer+0xc0>
800022a6:	70 08       	ld.w	r8,r8[0x0]
800022a8:	f0 c9 ff ff 	sub	r9,r8,-1
800022ac:	48 98       	lddpc	r8,800022d0 <vProducer+0xc0>
800022ae:	91 09       	st.w	r8[0x0],r9
		
		if(byteCount == 1)
800022b0:	48 88       	lddpc	r8,800022d0 <vProducer+0xc0>
800022b2:	70 08       	ld.w	r8,r8[0x0]
800022b4:	58 18       	cp.w	r8,1
800022b6:	cd 91       	brne	80002268 <vProducer+0x58>
		{
			vTaskResume(xHandleConsumer);
800022b8:	48 d8       	lddpc	r8,800022ec <vProducer+0xdc>
800022ba:	70 08       	ld.w	r8,r8[0x0]
800022bc:	10 9c       	mov	r12,r8
800022be:	f0 1f 00 0d 	mcall	800022f0 <vProducer+0xe0>
			onLED(LED1_BIT_VALUE);
800022c2:	fc 1c 10 00 	movh	r12,0x1000
800022c6:	f0 1f 00 04 	mcall	800022d4 <vProducer+0xc4>
		}
		
	}
800022ca:	cd 0b       	rjmp	8000226a <vProducer+0x5a>
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	40 0c       	lddsp	r12,sp[0x0]
800022d0:	00 00       	add	r0,r0
800022d2:	05 30       	ld.ub	r0,r2++
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	21 54       	sub	r4,21
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	21 72       	sub	r2,23
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	3c 88       	mov	r8,-56
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	4d c8       	lddpc	r8,80002450 <main+0xb8>
800022e4:	00 00       	add	r0,r0
800022e6:	07 94       	ld.ub	r4,r3[0x1]
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	35 14       	mov	r4,81
800022ec:	00 00       	add	r0,r0
800022ee:	07 98       	ld.ub	r8,r3[0x1]
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	3d a0       	mov	r0,-38

800022f4 <vConsumer>:
}

void vConsumer( void *pvParameters )
{
800022f4:	eb cd 40 80 	pushm	r7,lr
800022f8:	1a 97       	mov	r7,sp
800022fa:	20 5d       	sub	sp,20
800022fc:	ef 4c ff ec 	st.w	r7[-20],r12
	portTickType xLastWakeTime;
	const portTickType xFreq = TASK_DELAY_MS(10000);
80002300:	e0 68 27 10 	mov	r8,10000
80002304:	ef 48 ff fc 	st.w	r7[-4],r8
	volatile portTickType elapsed;
	
	struct msg *pMesg;
	
	onLED(LED1_BIT_VALUE);
80002308:	fc 1c 10 00 	movh	r12,0x1000
8000230c:	f0 1f 00 1a 	mcall	80002374 <vConsumer+0x80>
80002310:	c0 28       	rjmp	80002314 <vConsumer+0x20>
		if(byteCount == BUFFER_SIZE - 1)
		{
			vTaskResume(xHandleProducer);
			onLED(LED0_BIT_VALUE);
		}
	}
80002312:	d7 03       	nop
	
	onLED(LED1_BIT_VALUE);
	
	while(1)
	{
		if(byteCount == 0)
80002314:	49 98       	lddpc	r8,80002378 <vConsumer+0x84>
80002316:	70 08       	ld.w	r8,r8[0x0]
80002318:	58 08       	cp.w	r8,0
8000231a:	c0 81       	brne	8000232a <vConsumer+0x36>
		{
			offLED(LED1_BIT_VALUE);
8000231c:	fc 1c 10 00 	movh	r12,0x1000
80002320:	f0 1f 00 17 	mcall	8000237c <vConsumer+0x88>
			vTaskSuspend(NULL);
80002324:	30 0c       	mov	r12,0
80002326:	f0 1f 00 17 	mcall	80002380 <vConsumer+0x8c>
		}
			
		xQueueReceive(xQHandle, &pMesg, (portTickType)10);
8000232a:	49 78       	lddpc	r8,80002384 <vConsumer+0x90>
8000232c:	70 08       	ld.w	r8,r8[0x0]
8000232e:	ee cb 00 10 	sub	r11,r7,16
80002332:	30 09       	mov	r9,0
80002334:	30 aa       	mov	r10,10
80002336:	10 9c       	mov	r12,r8
80002338:	f0 1f 00 14 	mcall	80002388 <vConsumer+0x94>
		usart_write_line(serialPORT_USART, pMesg->data);
8000233c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002340:	2f c8       	sub	r8,-4
80002342:	10 9b       	mov	r11,r8
80002344:	fe 7c 18 00 	mov	r12,-59392
80002348:	f0 1f 00 11 	mcall	8000238c <vConsumer+0x98>
		
		byteCount--;
8000234c:	48 b8       	lddpc	r8,80002378 <vConsumer+0x84>
8000234e:	70 08       	ld.w	r8,r8[0x0]
80002350:	f0 c9 00 01 	sub	r9,r8,1
80002354:	48 98       	lddpc	r8,80002378 <vConsumer+0x84>
80002356:	91 09       	st.w	r8[0x0],r9
		
		if(byteCount == BUFFER_SIZE - 1)
80002358:	48 88       	lddpc	r8,80002378 <vConsumer+0x84>
8000235a:	70 08       	ld.w	r8,r8[0x0]
8000235c:	58 98       	cp.w	r8,9
8000235e:	cd a1       	brne	80002312 <vConsumer+0x1e>
		{
			vTaskResume(xHandleProducer);
80002360:	48 c8       	lddpc	r8,80002390 <vConsumer+0x9c>
80002362:	70 08       	ld.w	r8,r8[0x0]
80002364:	10 9c       	mov	r12,r8
80002366:	f0 1f 00 0c 	mcall	80002394 <vConsumer+0xa0>
			onLED(LED0_BIT_VALUE);
8000236a:	fc 1c 08 00 	movh	r12,0x800
8000236e:	f0 1f 00 02 	mcall	80002374 <vConsumer+0x80>
		}
	}
80002372:	cd 1b       	rjmp	80002314 <vConsumer+0x20>
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	21 54       	sub	r4,21
80002378:	00 00       	add	r0,r0
8000237a:	05 30       	ld.ub	r0,r2++
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	21 72       	sub	r2,23
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	3c 88       	mov	r8,-56
80002384:	00 00       	add	r0,r0
80002386:	07 94       	ld.ub	r4,r3[0x1]
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	36 7c       	mov	r12,103
8000238c:	80 00       	ld.sh	r0,r0[0x0]
8000238e:	2d 2c       	sub	r12,-46
80002390:	00 00       	add	r0,r0
80002392:	07 9c       	ld.ub	r12,r3[0x1]
80002394:	80 00       	ld.sh	r0,r0[0x0]
80002396:	3d a0       	mov	r0,-38

80002398 <main>:
}

int main(void)
{
80002398:	eb cd 40 80 	pushm	r7,lr
8000239c:	1a 97       	mov	r7,sp
	initLED();
8000239e:	f0 1f 00 20 	mcall	8000241c <main+0x84>
	init_usart();
800023a2:	f0 1f 00 20 	mcall	80002420 <main+0x88>

	static unsigned char ucParameterToPass ;
	
	vSemaphoreCreateBinary(xSemaphore);
800023a6:	30 0b       	mov	r11,0
800023a8:	30 1c       	mov	r12,1
800023aa:	f0 1f 00 1f 	mcall	80002424 <main+0x8c>
800023ae:	18 99       	mov	r9,r12
800023b0:	49 e8       	lddpc	r8,80002428 <main+0x90>
800023b2:	91 09       	st.w	r8[0x0],r9
800023b4:	49 d8       	lddpc	r8,80002428 <main+0x90>
800023b6:	70 08       	ld.w	r8,r8[0x0]
800023b8:	58 08       	cp.w	r8,0
800023ba:	c0 90       	breq	800023cc <main+0x34>
800023bc:	49 b8       	lddpc	r8,80002428 <main+0x90>
800023be:	70 08       	ld.w	r8,r8[0x0]
800023c0:	30 09       	mov	r9,0
800023c2:	30 0a       	mov	r10,0
800023c4:	30 0b       	mov	r11,0
800023c6:	10 9c       	mov	r12,r8
800023c8:	f0 1f 00 19 	mcall	8000242c <main+0x94>
	
	xQHandle = xQueueCreate(10, sizeof(struct msg*));
800023cc:	30 4b       	mov	r11,4
800023ce:	30 ac       	mov	r12,10
800023d0:	f0 1f 00 15 	mcall	80002424 <main+0x8c>
800023d4:	18 99       	mov	r9,r12
800023d6:	49 78       	lddpc	r8,80002430 <main+0x98>
800023d8:	91 09       	st.w	r8[0x0],r9
		//ERROR!
	}
	
	
	// Create the task , store the handle .
	xTaskCreate(	vProducer,
800023da:	49 7b       	lddpc	r11,80002434 <main+0x9c>
800023dc:	30 08       	mov	r8,0
800023de:	1a d8       	st.w	--sp,r8
800023e0:	30 08       	mov	r8,0
800023e2:	1a d8       	st.w	--sp,r8
800023e4:	49 58       	lddpc	r8,80002438 <main+0xa0>
800023e6:	1a d8       	st.w	--sp,r8
800023e8:	30 18       	mov	r8,1
800023ea:	30 09       	mov	r9,0
800023ec:	e0 6a 01 00 	mov	r10,256
800023f0:	49 3c       	lddpc	r12,8000243c <main+0xa4>
800023f2:	f0 1f 00 14 	mcall	80002440 <main+0xa8>
800023f6:	2f dd       	sub	sp,-12
					"vProducer",
					configMINIMAL_STACK_SIZE,
					NULL,
					1,
					&xHandleProducer);
	xTaskCreate(	vConsumer, "vConsumer", configMINIMAL_STACK_SIZE, NULL, 1, &xHandleConsumer);
800023f8:	49 3b       	lddpc	r11,80002444 <main+0xac>
800023fa:	30 08       	mov	r8,0
800023fc:	1a d8       	st.w	--sp,r8
800023fe:	30 08       	mov	r8,0
80002400:	1a d8       	st.w	--sp,r8
80002402:	49 28       	lddpc	r8,80002448 <main+0xb0>
80002404:	1a d8       	st.w	--sp,r8
80002406:	30 18       	mov	r8,1
80002408:	30 09       	mov	r9,0
8000240a:	e0 6a 01 00 	mov	r10,256
8000240e:	49 0c       	lddpc	r12,8000244c <main+0xb4>
80002410:	f0 1f 00 0c 	mcall	80002440 <main+0xa8>
80002414:	2f dd       	sub	sp,-12
	
	
	
	vTaskStartScheduler();
80002416:	f0 1f 00 0f 	mcall	80002450 <main+0xb8>

	
	for( ;; )
	{
		
	}
8000241a:	c0 08       	rjmp	8000241a <main+0x82>
8000241c:	80 00       	ld.sh	r0,r0[0x0]
8000241e:	20 d8       	sub	r8,13
80002420:	80 00       	ld.sh	r0,r0[0x0]
80002422:	21 a8       	sub	r8,26
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	33 fc       	mov	r12,63
80002428:	00 00       	add	r0,r0
8000242a:	07 a0       	ld.ub	r0,r3[0x2]
8000242c:	80 00       	ld.sh	r0,r0[0x0]
8000242e:	35 14       	mov	r4,81
80002430:	00 00       	add	r0,r0
80002432:	07 94       	ld.ub	r4,r3[0x1]
80002434:	80 00       	ld.sh	r0,r0[0x0]
80002436:	21 90       	sub	r0,25
80002438:	00 00       	add	r0,r0
8000243a:	07 9c       	ld.ub	r12,r3[0x1]
8000243c:	80 00       	ld.sh	r0,r0[0x0]
8000243e:	22 10       	sub	r0,33
80002440:	80 00       	ld.sh	r0,r0[0x0]
80002442:	3a c0       	mov	r0,-84
80002444:	80 00       	ld.sh	r0,r0[0x0]
80002446:	21 9c       	sub	r12,25
80002448:	00 00       	add	r0,r0
8000244a:	07 98       	ld.ub	r8,r3[0x1]
8000244c:	80 00       	ld.sh	r0,r0[0x0]
8000244e:	22 f4       	sub	r4,47
80002450:	80 00       	ld.sh	r0,r0[0x0]
80002452:	3e 64       	mov	r4,-26

80002454 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80002454:	eb cd 40 80 	pushm	r7,lr
80002458:	1a 97       	mov	r7,sp
8000245a:	20 4d       	sub	sp,16
8000245c:	ef 4c ff f4 	st.w	r7[-12],r12
80002460:	ef 4b ff f0 	st.w	r7[-16],r11
	uint32_t status = GPIO_SUCCESS;
80002464:	30 08       	mov	r8,0
80002466:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t i;

	for (i = 0; i < size; i++) {
8000246a:	30 08       	mov	r8,0
8000246c:	ef 48 ff fc 	st.w	r7[-4],r8
80002470:	c1 c8       	rjmp	800024a8 <gpio_enable_module+0x54>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80002472:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002476:	70 19       	ld.w	r9,r8[0x4]
80002478:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000247c:	70 08       	ld.w	r8,r8[0x0]
8000247e:	12 9b       	mov	r11,r9
80002480:	10 9c       	mov	r12,r8
80002482:	f0 1f 00 10 	mcall	800024c0 <gpio_enable_module+0x6c>
80002486:	18 98       	mov	r8,r12
80002488:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000248c:	f3 e8 10 08 	or	r8,r9,r8
80002490:	ef 48 ff f8 	st.w	r7[-8],r8
		gpiomap++;
80002494:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002498:	2f 88       	sub	r8,-8
8000249a:	ef 48 ff f4 	st.w	r7[-12],r8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000249e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800024a2:	2f f8       	sub	r8,-1
800024a4:	ef 48 ff fc 	st.w	r7[-4],r8
800024a8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800024ac:	ee f8 ff f0 	ld.w	r8,r7[-16]
800024b0:	10 39       	cp.w	r9,r8
800024b2:	ce 03       	brcs	80002472 <gpio_enable_module+0x1e>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
800024b4:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800024b8:	10 9c       	mov	r12,r8
800024ba:	2f cd       	sub	sp,-16
800024bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	24 c4       	sub	r4,76

800024c4 <gpio_enable_module_pin>:
 * \param function The pin function.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
800024c4:	eb cd 40 80 	pushm	r7,lr
800024c8:	1a 97       	mov	r7,sp
800024ca:	20 3d       	sub	sp,12
800024cc:	ef 4c ff f8 	st.w	r7[-8],r12
800024d0:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800024d4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800024d8:	a5 98       	lsr	r8,0x5
800024da:	a9 68       	lsl	r8,0x8
800024dc:	e0 28 f0 00 	sub	r8,61440
800024e0:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Enable the correct function. */
	switch (function) {
800024e4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800024e8:	58 18       	cp.w	r8,1
800024ea:	c1 e0       	breq	80002526 <gpio_enable_module_pin+0x62>
800024ec:	c0 63       	brcs	800024f8 <gpio_enable_module_pin+0x34>
800024ee:	58 28       	cp.w	r8,2
800024f0:	c3 20       	breq	80002554 <gpio_enable_module_pin+0x90>
800024f2:	58 38       	cp.w	r8,3
800024f4:	c4 70       	breq	80002582 <gpio_enable_module_pin+0xbe>
800024f6:	c5 d8       	rjmp	800025b0 <gpio_enable_module_pin+0xec>
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800024f8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800024fc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002500:	30 19       	mov	r9,1
80002502:	f2 08 09 48 	lsl	r8,r9,r8
80002506:	10 99       	mov	r9,r8
80002508:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000250c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000250e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002512:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002516:	30 19       	mov	r9,1
80002518:	f2 08 09 48 	lsl	r8,r9,r8
8000251c:	10 99       	mov	r9,r8
8000251e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002522:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002524:	c4 88       	rjmp	800025b4 <gpio_enable_module_pin+0xf0>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80002526:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000252a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000252e:	30 19       	mov	r9,1
80002530:	f2 08 09 48 	lsl	r8,r9,r8
80002534:	10 99       	mov	r9,r8
80002536:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000253a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000253c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002540:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002544:	30 19       	mov	r9,1
80002546:	f2 08 09 48 	lsl	r8,r9,r8
8000254a:	10 99       	mov	r9,r8
8000254c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002550:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002552:	c3 18       	rjmp	800025b4 <gpio_enable_module_pin+0xf0>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80002554:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002558:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000255c:	30 19       	mov	r9,1
8000255e:	f2 08 09 48 	lsl	r8,r9,r8
80002562:	10 99       	mov	r9,r8
80002564:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002568:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000256a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000256e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002572:	30 19       	mov	r9,1
80002574:	f2 08 09 48 	lsl	r8,r9,r8
80002578:	10 99       	mov	r9,r8
8000257a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000257e:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002580:	c1 a8       	rjmp	800025b4 <gpio_enable_module_pin+0xf0>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80002582:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002586:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000258a:	30 19       	mov	r9,1
8000258c:	f2 08 09 48 	lsl	r8,r9,r8
80002590:	10 99       	mov	r9,r8
80002592:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002596:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002598:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000259c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800025a0:	30 19       	mov	r9,1
800025a2:	f2 08 09 48 	lsl	r8,r9,r8
800025a6:	10 99       	mov	r9,r8
800025a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800025ac:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800025ae:	c0 38       	rjmp	800025b4 <gpio_enable_module_pin+0xf0>
		gpio_port->pmr2s = 1 << (pin & 0x1F);
		break;
#endif

	default:
		return GPIO_INVALID_ARGUMENT;
800025b0:	30 18       	mov	r8,1
800025b2:	c0 d8       	rjmp	800025cc <gpio_enable_module_pin+0x108>
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800025b4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800025b8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800025bc:	30 19       	mov	r9,1
800025be:	f2 08 09 48 	lsl	r8,r9,r8
800025c2:	10 99       	mov	r9,r8
800025c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800025c8:	91 29       	st.w	r8[0x8],r9

	return GPIO_SUCCESS;
800025ca:	30 08       	mov	r8,0
}
800025cc:	10 9c       	mov	r12,r8
800025ce:	2f dd       	sub	sp,-12
800025d0:	e3 cd 80 80 	ldm	sp++,r7,pc

800025d4 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800025d4:	eb cd 40 80 	pushm	r7,lr
800025d8:	1a 97       	mov	r7,sp
	// Catch unregistered interrupts.
	while (true);
800025da:	c0 08       	rjmp	800025da <_unhandled_interrupt+0x6>

800025dc <_get_interrupt_handler>:
 *
 * \return Interrupt handler to execute.
 */
__int_handler _get_interrupt_handler(uint32_t int_level);
__int_handler _get_interrupt_handler(uint32_t int_level)
{
800025dc:	eb cd 40 80 	pushm	r7,lr
800025e0:	1a 97       	mov	r7,sp
800025e2:	20 3d       	sub	sp,12
800025e4:	ef 4c ff f4 	st.w	r7[-12],r12
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800025e8:	fe 78 08 00 	mov	r8,-63488
800025ec:	ee f9 ff f4 	ld.w	r9,r7[-12]
800025f0:	f2 09 11 03 	rsub	r9,r9,3
800025f4:	28 09       	sub	r9,-128
800025f6:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800025fa:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800025fe:	fe 78 08 00 	mov	r8,-63488
80002602:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002606:	2c 09       	sub	r9,-64
80002608:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
8000260c:	ef 48 ff fc 	st.w	r7[-4],r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002610:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002614:	58 08       	cp.w	r8,0
80002616:	c1 30       	breq	8000263c <_get_interrupt_handler+0x60>
		? _int_handler_table[int_grp]._int_line_handler_table[32
80002618:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000261c:	48 b8       	lddpc	r8,80002648 <_get_interrupt_handler+0x6c>
8000261e:	a1 79       	lsl	r9,0x1
80002620:	2f f9       	sub	r9,-1
80002622:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80002626:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000262a:	f0 08 12 00 	clz	r8,r8
8000262e:	f0 08 11 1f 	rsub	r8,r8,31
			- clz(int_req) - 1]
80002632:	a3 68       	lsl	r8,0x2
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
80002634:	f2 08 00 08 	add	r8,r9,r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002638:	70 08       	ld.w	r8,r8[0x0]
8000263a:	c0 28       	rjmp	8000263e <_get_interrupt_handler+0x62>
8000263c:	30 08       	mov	r8,0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000263e:	10 9c       	mov	r12,r8
80002640:	2f dd       	sub	sp,-12
80002642:	e3 cd 80 80 	ldm	sp++,r7,pc
80002646:	00 00       	add	r0,r0
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	54 44       	stdsp	sp[0x110],r4

8000264c <INTC_init_evba>:
 * \internal
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
8000264c:	eb cd 40 80 	pushm	r7,lr
80002650:	1a 97       	mov	r7,sp
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80002652:	48 38       	lddpc	r8,8000265c <INTC_init_evba+0x10>
80002654:	e3 b8 00 01 	mtsr	0x4,r8
}
80002658:	e3 cd 80 80 	ldm	sp++,r7,pc
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	52 00       	stdsp	sp[0x80],r0

80002660 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80002660:	eb cd 40 80 	pushm	r7,lr
80002664:	1a 97       	mov	r7,sp
80002666:	20 2d       	sub	sp,8
	uint32_t int_grp, int_req;

	INTC_init_evba();
80002668:	f0 1f 00 1f 	mcall	800026e4 <INTC_init_interrupts+0x84>

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
8000266c:	30 08       	mov	r8,0
8000266e:	ef 48 ff f8 	st.w	r7[-8],r8
80002672:	c3 18       	rjmp	800026d4 <INTC_init_interrupts+0x74>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80002674:	30 08       	mov	r8,0
80002676:	ef 48 ff fc 	st.w	r7[-4],r8
8000267a:	c1 48       	rjmp	800026a2 <INTC_init_interrupts+0x42>
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
8000267c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002680:	49 a8       	lddpc	r8,800026e8 <INTC_init_interrupts+0x88>
80002682:	a1 79       	lsl	r9,0x1
80002684:	2f f9       	sub	r9,-1
80002686:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
8000268a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000268e:	a3 68       	lsl	r8,0x2
80002690:	f2 08 00 08 	add	r8,r9,r8
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80002694:	49 69       	lddpc	r9,800026ec <INTC_init_interrupts+0x8c>
80002696:	91 09       	st.w	r8[0x0],r9
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80002698:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000269c:	2f f8       	sub	r8,-1
8000269e:	ef 48 ff fc 	st.w	r7[-4],r8
	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
800026a2:	ee f9 ff f8 	ld.w	r9,r7[-8]
800026a6:	49 18       	lddpc	r8,800026e8 <INTC_init_interrupts+0x88>
800026a8:	f0 09 03 39 	ld.w	r9,r8[r9<<0x3]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800026ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800026b0:	10 39       	cp.w	r9,r8
800026b2:	fe 9b ff e5 	brhi	8000267c <INTC_init_interrupts+0x1c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800026b6:	fe 78 08 00 	mov	r8,-63488
800026ba:	ee f9 ff f8 	ld.w	r9,r7[-8]
800026be:	48 db       	lddpc	r11,800026f0 <INTC_init_interrupts+0x90>
800026c0:	48 da       	lddpc	r10,800026f4 <INTC_init_interrupts+0x94>
800026c2:	f6 0a 01 0a 	sub	r10,r11,r10
800026c6:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800026ca:	ee f8 ff f8 	ld.w	r8,r7[-8]
800026ce:	2f f8       	sub	r8,-1
800026d0:	ef 48 ff f8 	st.w	r7[-8],r8
800026d4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800026d8:	59 38       	cp.w	r8,19
800026da:	fe 98 ff cd 	brls	80002674 <INTC_init_interrupts+0x14>
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	}
}
800026de:	2f ed       	sub	sp,-8
800026e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800026e4:	80 00       	ld.sh	r0,r0[0x0]
800026e6:	26 4c       	sub	r12,100
800026e8:	80 00       	ld.sh	r0,r0[0x0]
800026ea:	54 44       	stdsp	sp[0x110],r4
800026ec:	80 00       	ld.sh	r0,r0[0x0]
800026ee:	25 d4       	sub	r4,93
800026f0:	80 00       	ld.sh	r0,r0[0x0]
800026f2:	53 04       	stdsp	sp[0xc0],r4
800026f4:	80 00       	ld.sh	r0,r0[0x0]
800026f6:	52 00       	stdsp	sp[0x80],r0

800026f8 <INTC_register_interrupt>:
 *          be effective.
 *
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
800026f8:	eb cd 40 80 	pushm	r7,lr
800026fc:	1a 97       	mov	r7,sp
800026fe:	20 4d       	sub	sp,16
80002700:	ef 4c ff f8 	st.w	r7[-8],r12
80002704:	ef 4b ff f4 	st.w	r7[-12],r11
80002708:	ef 4a ff f0 	st.w	r7[-16],r10
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000270c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002710:	a5 98       	lsr	r8,0x5
80002712:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80002716:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000271a:	4a 78       	lddpc	r8,800027b4 <INTC_register_interrupt+0xbc>
8000271c:	a1 79       	lsl	r9,0x1
8000271e:	2f f9       	sub	r9,-1
80002720:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80002724:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002728:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000272c:	a3 68       	lsl	r8,0x2
8000272e:	f2 08 00 08 	add	r8,r9,r8
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80002732:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002736:	91 09       	st.w	r8[0x0],r9
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80002738:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000273c:	58 08       	cp.w	r8,0
8000273e:	c0 c1       	brne	80002756 <INTC_register_interrupt+0x5e>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002740:	fe 78 08 00 	mov	r8,-63488
80002744:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002748:	49 cb       	lddpc	r11,800027b8 <INTC_register_interrupt+0xc0>
8000274a:	49 da       	lddpc	r10,800027bc <INTC_register_interrupt+0xc4>
8000274c:	f6 0a 01 0a 	sub	r10,r11,r10
80002750:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80002754:	c2 d8       	rjmp	800027ae <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT1) {
80002756:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000275a:	58 18       	cp.w	r8,1
8000275c:	c0 d1       	brne	80002776 <INTC_register_interrupt+0x7e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000275e:	fe 78 08 00 	mov	r8,-63488
80002762:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002766:	49 7b       	lddpc	r11,800027c0 <INTC_register_interrupt+0xc8>
80002768:	49 5a       	lddpc	r10,800027bc <INTC_register_interrupt+0xc4>
8000276a:	f6 0a 01 0a 	sub	r10,r11,r10
8000276e:	bf aa       	sbr	r10,0x1e
80002770:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80002774:	c1 d8       	rjmp	800027ae <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT2) {
80002776:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000277a:	58 28       	cp.w	r8,2
8000277c:	c0 d1       	brne	80002796 <INTC_register_interrupt+0x9e>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000277e:	fe 78 08 00 	mov	r8,-63488
80002782:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002786:	49 0b       	lddpc	r11,800027c4 <INTC_register_interrupt+0xcc>
80002788:	48 da       	lddpc	r10,800027bc <INTC_register_interrupt+0xc4>
8000278a:	f6 0a 01 0a 	sub	r10,r11,r10
8000278e:	bf ba       	sbr	r10,0x1f
80002790:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80002794:	c0 d8       	rjmp	800027ae <INTC_register_interrupt+0xb6>
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80002796:	fe 78 08 00 	mov	r8,-63488
8000279a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000279e:	48 bb       	lddpc	r11,800027c8 <INTC_register_interrupt+0xd0>
800027a0:	48 7a       	lddpc	r10,800027bc <INTC_register_interrupt+0xc4>
800027a2:	f6 0a 01 0a 	sub	r10,r11,r10
800027a6:	ea 1a c0 00 	orh	r10,0xc000
800027aa:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	}
}
800027ae:	2f cd       	sub	sp,-16
800027b0:	e3 cd 80 80 	ldm	sp++,r7,pc
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	54 44       	stdsp	sp[0x110],r4
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	53 04       	stdsp	sp[0xc0],r4
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	52 00       	stdsp	sp[0x80],r0
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	53 12       	stdsp	sp[0xc4],r2
800027c4:	80 00       	ld.sh	r0,r0[0x0]
800027c6:	53 20       	stdsp	sp[0xc8],r0
800027c8:	80 00       	ld.sh	r0,r0[0x0]
800027ca:	53 2e       	stdsp	sp[0xc8],lr

800027cc <pm_set_osc0_mode>:
 *
 * \param pm Base address of the Power Manager (i.e. &AVR32_PM).
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
800027cc:	eb cd 40 80 	pushm	r7,lr
800027d0:	1a 97       	mov	r7,sp
800027d2:	20 3d       	sub	sp,12
800027d4:	ef 4c ff f8 	st.w	r7[-8],r12
800027d8:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800027dc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027e0:	70 a8       	ld.w	r8,r8[0x28]
800027e2:	30 09       	mov	r9,0
800027e4:	ef 49 ff fc 	st.w	r7[-4],r9
800027e8:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800027ec:	ee f8 ff f4 	ld.w	r8,r7[-12]
800027f0:	5c 58       	castu.b	r8
800027f2:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800027f6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800027fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800027fe:	f1 d9 d0 03 	bfins	r8,r9,0x0,0x3
80002802:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002806:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000280a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000280e:	91 a9       	st.w	r8[0x28],r9
}
80002810:	2f dd       	sub	sp,-12
80002812:	e3 cd 80 80 	ldm	sp++,r7,pc
80002816:	d7 03       	nop

80002818 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80002818:	eb cd 40 80 	pushm	r7,lr
8000281c:	1a 97       	mov	r7,sp
8000281e:	20 2d       	sub	sp,8
80002820:	ef 4c ff fc 	st.w	r7[-4],r12
80002824:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80002828:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000282c:	ec 58 bb 9f 	cp.w	r8,899999
80002830:	e0 88 00 1a 	brls	80002864 <pm_enable_osc0_crystal+0x4c>
80002834:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002838:	e0 69 c6 bf 	mov	r9,50879
8000283c:	ea 19 00 2d 	orh	r9,0x2d
80002840:	12 38       	cp.w	r8,r9
80002842:	e0 88 00 0f 	brls	80002860 <pm_enable_osc0_crystal+0x48>
80002846:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000284a:	e0 69 11 ff 	mov	r9,4607
8000284e:	ea 19 00 7a 	orh	r9,0x7a
80002852:	12 38       	cp.w	r8,r9
80002854:	e0 8b 00 04 	brhi	8000285c <pm_enable_osc0_crystal+0x44>
80002858:	30 68       	mov	r8,6
8000285a:	c0 28       	rjmp	8000285e <pm_enable_osc0_crystal+0x46>
8000285c:	30 78       	mov	r8,7
8000285e:	c0 28       	rjmp	80002862 <pm_enable_osc0_crystal+0x4a>
80002860:	30 58       	mov	r8,5
80002862:	c0 28       	rjmp	80002866 <pm_enable_osc0_crystal+0x4e>
80002864:	30 48       	mov	r8,4
80002866:	10 9b       	mov	r11,r8
80002868:	ee fc ff fc 	ld.w	r12,r7[-4]
8000286c:	f0 1f 00 03 	mcall	80002878 <pm_enable_osc0_crystal+0x60>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80002870:	2f ed       	sub	sp,-8
80002872:	e3 cd 80 80 	ldm	sp++,r7,pc
80002876:	00 00       	add	r0,r0
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	27 cc       	sub	r12,124

8000287c <pm_enable_clk0>:


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
8000287c:	eb cd 40 80 	pushm	r7,lr
80002880:	1a 97       	mov	r7,sp
80002882:	20 2d       	sub	sp,8
80002884:	ef 4c ff fc 	st.w	r7[-4],r12
80002888:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_enable_clk0_no_wait(pm, startup);
8000288c:	ee fb ff f8 	ld.w	r11,r7[-8]
80002890:	ee fc ff fc 	ld.w	r12,r7[-4]
80002894:	f0 1f 00 05 	mcall	800028a8 <pm_enable_clk0+0x2c>
  pm_wait_for_clk0_ready(pm);
80002898:	ee fc ff fc 	ld.w	r12,r7[-4]
8000289c:	f0 1f 00 04 	mcall	800028ac <pm_enable_clk0+0x30>
}
800028a0:	2f ed       	sub	sp,-8
800028a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800028a6:	00 00       	add	r0,r0
800028a8:	80 00       	ld.sh	r0,r0[0x0]
800028aa:	28 b0       	sub	r0,-117
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	29 0a       	sub	r10,-112

800028b0 <pm_enable_clk0_no_wait>:
  pm->mcctrl &= ~AVR32_PM_MCCTRL_OSC0EN_MASK;
}


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
800028b0:	eb cd 40 80 	pushm	r7,lr
800028b4:	1a 97       	mov	r7,sp
800028b6:	20 3d       	sub	sp,12
800028b8:	ef 4c ff f8 	st.w	r7[-8],r12
800028bc:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800028c0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800028c4:	70 a8       	ld.w	r8,r8[0x28]
800028c6:	30 09       	mov	r9,0
800028c8:	ef 49 ff fc 	st.w	r7[-4],r9
800028cc:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800028d0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800028d4:	5c 58       	castu.b	r8
800028d6:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800028da:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800028de:	ee f8 ff fc 	ld.w	r8,r7[-4]
800028e2:	f1 d9 d1 03 	bfins	r8,r9,0x8,0x3
800028e6:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800028ea:	ee f9 ff fc 	ld.w	r9,r7[-4]
800028ee:	ee f8 ff f8 	ld.w	r8,r7[-8]
800028f2:	91 a9       	st.w	r8[0x28],r9

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800028f4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800028f8:	70 08       	ld.w	r8,r8[0x0]
800028fa:	10 99       	mov	r9,r8
800028fc:	a3 a9       	sbr	r9,0x2
800028fe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002902:	91 09       	st.w	r8[0x0],r9
}
80002904:	2f dd       	sub	sp,-12
80002906:	e3 cd 80 80 	ldm	sp++,r7,pc

8000290a <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
8000290a:	eb cd 40 80 	pushm	r7,lr
8000290e:	1a 97       	mov	r7,sp
80002910:	20 1d       	sub	sp,4
80002912:	ef 4c ff fc 	st.w	r7[-4],r12
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80002916:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000291a:	71 58       	ld.w	r8,r8[0x54]
8000291c:	e2 18 00 80 	andl	r8,0x80,COH
80002920:	cf b0       	breq	80002916 <pm_wait_for_clk0_ready+0xc>
}
80002922:	2f fd       	sub	sp,-4
80002924:	e3 cd 80 80 	ldm	sp++,r7,pc

80002928 <pm_switch_to_clock>:
  return u_avr32_pm_mcctrl.MCCTRL.mcsel;
}


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
80002928:	eb cd 40 80 	pushm	r7,lr
8000292c:	1a 97       	mov	r7,sp
8000292e:	20 3d       	sub	sp,12
80002930:	ef 4c ff f8 	st.w	r7[-8],r12
80002934:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80002938:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000293c:	70 08       	ld.w	r8,r8[0x0]
8000293e:	30 09       	mov	r9,0
80002940:	ef 49 ff fc 	st.w	r7[-4],r9
80002944:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80002948:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000294c:	5c 58       	castu.b	r8
8000294e:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002952:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80002956:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000295a:	f1 d9 d0 02 	bfins	r8,r9,0x0,0x2
8000295e:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80002962:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002966:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000296a:	91 09       	st.w	r8[0x0],r9
}
8000296c:	2f dd       	sub	sp,-12
8000296e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002972:	d7 03       	nop

80002974 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80002974:	eb cd 40 80 	pushm	r7,lr
80002978:	1a 97       	mov	r7,sp
8000297a:	20 3d       	sub	sp,12
8000297c:	ef 4c ff fc 	st.w	r7[-4],r12
80002980:	ef 4b ff f8 	st.w	r7[-8],r11
80002984:	ef 4a ff f4 	st.w	r7[-12],r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80002988:	ee fb ff f8 	ld.w	r11,r7[-8]
8000298c:	ee fc ff fc 	ld.w	r12,r7[-4]
80002990:	f0 1f 00 08 	mcall	800029b0 <pm_switch_to_osc0+0x3c>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80002994:	ee fb ff f4 	ld.w	r11,r7[-12]
80002998:	ee fc ff fc 	ld.w	r12,r7[-4]
8000299c:	f0 1f 00 06 	mcall	800029b4 <pm_switch_to_osc0+0x40>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800029a0:	30 1b       	mov	r11,1
800029a2:	ee fc ff fc 	ld.w	r12,r7[-4]
800029a6:	f0 1f 00 05 	mcall	800029b8 <pm_switch_to_osc0+0x44>
}
800029aa:	2f dd       	sub	sp,-12
800029ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	28 18       	sub	r8,-127
800029b4:	80 00       	ld.sh	r0,r0[0x0]
800029b6:	28 7c       	sub	r12,-121
800029b8:	80 00       	ld.sh	r0,r0[0x0]
800029ba:	29 28       	sub	r8,-110

800029bc <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
800029bc:	eb cd 40 80 	pushm	r7,lr
800029c0:	1a 97       	mov	r7,sp
800029c2:	20 1d       	sub	sp,4
800029c4:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
800029c8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800029cc:	e6 18 00 01 	andh	r8,0x1,COH
800029d0:	5f 08       	sreq	r8
800029d2:	5c 58       	castu.b	r8
}
800029d4:	10 9c       	mov	r12,r8
800029d6:	2f fd       	sub	sp,-4
800029d8:	e3 cd 80 80 	ldm	sp++,r7,pc

800029dc <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800029dc:	eb cd 40 80 	pushm	r7,lr
800029e0:	1a 97       	mov	r7,sp
800029e2:	20 7d       	sub	sp,28
800029e4:	ef 4c ff ec 	st.w	r7[-20],r12
800029e8:	ef 4b ff e8 	st.w	r7[-24],r11
800029ec:	ef 4a ff e4 	st.w	r7[-28],r10
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800029f0:	ee f8 ff e8 	ld.w	r8,r7[-24]
800029f4:	f0 09 15 04 	lsl	r9,r8,0x4
800029f8:	ee f8 ff e4 	ld.w	r8,r7[-28]
800029fc:	10 39       	cp.w	r9,r8
800029fe:	e0 8b 00 04 	brhi	80002a06 <usart_set_async_baudrate+0x2a>
80002a02:	31 08       	mov	r8,16
80002a04:	c0 28       	rjmp	80002a08 <usart_set_async_baudrate+0x2c>
80002a06:	30 88       	mov	r8,8
80002a08:	ef 48 ff f0 	st.w	r7[-16],r8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80002a0c:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002a10:	f0 09 15 03 	lsl	r9,r8,0x3
80002a14:	ee fa ff f0 	ld.w	r10,r7[-16]
80002a18:	ee f8 ff e8 	ld.w	r8,r7[-24]
80002a1c:	f4 08 02 48 	mul	r8,r10,r8
80002a20:	a1 98       	lsr	r8,0x1
80002a22:	f2 08 00 08 	add	r8,r9,r8
80002a26:	ee fa ff f0 	ld.w	r10,r7[-16]
80002a2a:	ee f9 ff e8 	ld.w	r9,r7[-24]
80002a2e:	f4 09 02 49 	mul	r9,r10,r9
80002a32:	f0 09 0d 08 	divu	r8,r8,r9
80002a36:	ef 48 ff f4 	st.w	r7[-12],r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80002a3a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002a3e:	a3 98       	lsr	r8,0x3
80002a40:	ef 48 ff f8 	st.w	r7[-8],r8
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);
80002a44:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002a48:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80002a4c:	ef 48 ff fc 	st.w	r7[-4],r8

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80002a50:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a54:	58 08       	cp.w	r8,0
80002a56:	c0 70       	breq	80002a64 <usart_set_async_baudrate+0x88>
80002a58:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a5c:	e0 48 ff ff 	cp.w	r8,65535
80002a60:	e0 88 00 04 	brls	80002a68 <usart_set_async_baudrate+0x8c>
    return USART_INVALID_INPUT;
80002a64:	30 18       	mov	r8,1
80002a66:	c2 08       	rjmp	80002aa6 <usart_set_async_baudrate+0xca>

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80002a68:	ee f8 ff ec 	ld.w	r8,r7[-20]
80002a6c:	70 18       	ld.w	r8,r8[0x4]
80002a6e:	10 99       	mov	r9,r8
80002a70:	e4 19 ff f7 	andh	r9,0xfff7
80002a74:	e0 19 fe cf 	andl	r9,0xfecf
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80002a78:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002a7c:	59 08       	cp.w	r8,16
80002a7e:	c0 40       	breq	80002a86 <usart_set_async_baudrate+0xaa>
80002a80:	e8 68 00 00 	mov	r8,524288
80002a84:	c0 28       	rjmp	80002a88 <usart_set_async_baudrate+0xac>
80002a86:	30 08       	mov	r8,0
80002a88:	10 49       	or	r9,r8
80002a8a:	ee f8 ff ec 	ld.w	r8,r7[-20]
80002a8e:	91 19       	st.w	r8[0x4],r9
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
                fp << AVR32_USART_BRGR_FP_OFFSET;
80002a90:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a94:	f0 09 15 10 	lsl	r9,r8,0x10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80002a98:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a9c:	10 49       	or	r9,r8
80002a9e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80002aa2:	91 89       	st.w	r8[0x20],r9
                fp << AVR32_USART_BRGR_FP_OFFSET;

  return USART_SUCCESS;
80002aa4:	30 08       	mov	r8,0
}
80002aa6:	10 9c       	mov	r12,r8
80002aa8:	2f 9d       	sub	sp,-28
80002aaa:	e3 cd 80 80 	ldm	sp++,r7,pc
80002aae:	d7 03       	nop

80002ab0 <usart_reset>:
 */
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
80002ab0:	eb cd 40 80 	pushm	r7,lr
80002ab4:	1a 97       	mov	r7,sp
80002ab6:	20 2d       	sub	sp,8
80002ab8:	ef 4c ff f8 	st.w	r7[-8],r12
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80002abc:	e1 b8 00 00 	mfsr	r8,0x0
80002ac0:	10 9c       	mov	r12,r8
80002ac2:	f0 1f 00 18 	mcall	80002b20 <usart_reset+0x70>
80002ac6:	18 98       	mov	r8,r12
80002ac8:	ef 68 ff ff 	st.b	r7[-1],r8

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80002acc:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80002ad0:	30 08       	mov	r8,0
80002ad2:	f0 09 18 00 	cp.b	r9,r8
80002ad6:	c0 20       	breq	80002ada <usart_reset+0x2a>
80002ad8:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80002ada:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ade:	3f f9       	mov	r9,-1
80002ae0:	91 39       	st.w	r8[0xc],r9
  usart->csr;
80002ae2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ae6:	70 58       	ld.w	r8,r8[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80002ae8:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80002aec:	30 08       	mov	r8,0
80002aee:	f0 09 18 00 	cp.b	r9,r8
80002af2:	c0 20       	breq	80002af6 <usart_reset+0x46>
80002af4:	d5 03       	csrf	0x10

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80002af6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002afa:	30 09       	mov	r9,0
80002afc:	91 19       	st.w	r8[0x4],r9
  usart->rtor = 0;
80002afe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b02:	30 09       	mov	r9,0
80002b04:	91 99       	st.w	r8[0x24],r9
  usart->ttgr = 0;
80002b06:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b0a:	30 09       	mov	r9,0
80002b0c:	91 a9       	st.w	r8[0x28],r9

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80002b0e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b12:	ea 69 61 0c 	mov	r9,680204
80002b16:	91 09       	st.w	r8[0x0],r9
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80002b18:	2f ed       	sub	sp,-8
80002b1a:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b1e:	00 00       	add	r0,r0
80002b20:	80 00       	ld.sh	r0,r0[0x0]
80002b22:	29 bc       	sub	r12,-101

80002b24 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80002b24:	eb cd 40 80 	pushm	r7,lr
80002b28:	1a 97       	mov	r7,sp
80002b2a:	20 3d       	sub	sp,12
80002b2c:	ef 4c ff fc 	st.w	r7[-4],r12
80002b30:	ef 4b ff f8 	st.w	r7[-8],r11
80002b34:	ef 4a ff f4 	st.w	r7[-12],r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80002b38:	ee fc ff fc 	ld.w	r12,r7[-4]
80002b3c:	f0 1f 00 54 	mcall	80002c8c <usart_init_rs232+0x168>

  // Check input values.
  if (!opt || // Null pointer.
80002b40:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b44:	58 08       	cp.w	r8,0
80002b46:	c3 90       	breq	80002bb8 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80002b48:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b4c:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002b4e:	30 48       	mov	r8,4
80002b50:	f0 09 18 00 	cp.b	r9,r8
80002b54:	e0 88 00 32 	brls	80002bb8 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80002b58:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b5c:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002b5e:	30 98       	mov	r8,9
80002b60:	f0 09 18 00 	cp.b	r9,r8
80002b64:	e0 8b 00 2a 	brhi	80002bb8 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80002b68:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b6c:	11 d9       	ld.ub	r9,r8[0x5]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002b6e:	30 78       	mov	r8,7
80002b70:	f0 09 18 00 	cp.b	r9,r8
80002b74:	e0 8b 00 22 	brhi	80002bb8 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
80002b78:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b7c:	90 39       	ld.sh	r9,r8[0x6]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002b7e:	e0 68 01 01 	mov	r8,257
80002b82:	f0 09 19 00 	cp.h	r9,r8
80002b86:	e0 8b 00 19 	brhi	80002bb8 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
80002b8a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b8e:	f1 39 00 08 	ld.ub	r9,r8[8]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002b92:	30 38       	mov	r8,3
80002b94:	f0 09 18 00 	cp.b	r9,r8
80002b98:	e0 8b 00 10 	brhi	80002bb8 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80002b9c:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002ba0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ba4:	70 08       	ld.w	r8,r8[0x0]
80002ba6:	12 9a       	mov	r10,r9
80002ba8:	10 9b       	mov	r11,r8
80002baa:	ee fc ff fc 	ld.w	r12,r7[-4]
80002bae:	f0 1f 00 39 	mcall	80002c90 <usart_init_rs232+0x16c>
80002bb2:	18 98       	mov	r8,r12
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002bb4:	58 18       	cp.w	r8,1
80002bb6:	c0 31       	brne	80002bbc <usart_init_rs232+0x98>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;
80002bb8:	30 18       	mov	r8,1
80002bba:	c6 48       	rjmp	80002c82 <usart_init_rs232+0x15e>

  if (opt->charlength == 9)
80002bbc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bc0:	11 c9       	ld.ub	r9,r8[0x4]
80002bc2:	30 98       	mov	r8,9
80002bc4:	f0 09 18 00 	cp.b	r9,r8
80002bc8:	c0 a1       	brne	80002bdc <usart_init_rs232+0xb8>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80002bca:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002bce:	70 18       	ld.w	r8,r8[0x4]
80002bd0:	10 99       	mov	r9,r8
80002bd2:	b1 b9       	sbr	r9,0x11
80002bd4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002bd8:	91 19       	st.w	r8[0x4],r9
80002bda:	c0 d8       	rjmp	80002bf4 <usart_init_rs232+0xd0>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80002bdc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002be0:	70 19       	ld.w	r9,r8[0x4]
80002be2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002be6:	11 c8       	ld.ub	r8,r8[0x4]
80002be8:	20 58       	sub	r8,5
80002bea:	a7 68       	lsl	r8,0x6
80002bec:	10 49       	or	r9,r8
80002bee:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002bf2:	91 19       	st.w	r8[0x4],r9
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80002bf4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002bf8:	70 19       	ld.w	r9,r8[0x4]
80002bfa:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bfe:	11 d8       	ld.ub	r8,r8[0x5]
80002c00:	f0 0a 15 09 	lsl	r10,r8,0x9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;
80002c04:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c08:	f1 38 00 08 	ld.ub	r8,r8[8]
80002c0c:	af 68       	lsl	r8,0xe
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80002c0e:	f5 e8 10 08 	or	r8,r10,r8
80002c12:	10 49       	or	r9,r8
80002c14:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c18:	91 19       	st.w	r8[0x4],r9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80002c1a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c1e:	90 39       	ld.sh	r9,r8[0x6]
80002c20:	30 28       	mov	r8,2
80002c22:	f0 09 19 00 	cp.h	r9,r8
80002c26:	e0 88 00 14 	brls	80002c4e <usart_init_rs232+0x12a>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80002c2a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c2e:	70 18       	ld.w	r8,r8[0x4]
80002c30:	10 99       	mov	r9,r8
80002c32:	ad b9       	sbr	r9,0xd
80002c34:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c38:	91 19       	st.w	r8[0x4],r9
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80002c3a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c3e:	90 38       	ld.sh	r8,r8[0x6]
80002c40:	5c 78       	castu.h	r8
80002c42:	20 28       	sub	r8,2
80002c44:	10 99       	mov	r9,r8
80002c46:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c4a:	91 a9       	st.w	r8[0x28],r9
80002c4c:	c0 d8       	rjmp	80002c66 <usart_init_rs232+0x142>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80002c4e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c52:	70 19       	ld.w	r9,r8[0x4]
80002c54:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c58:	90 38       	ld.sh	r8,r8[0x6]
80002c5a:	5c 78       	castu.h	r8
80002c5c:	ad 68       	lsl	r8,0xc
80002c5e:	10 49       	or	r9,r8
80002c60:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c64:	91 19       	st.w	r8[0x4],r9

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80002c66:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c6a:	70 18       	ld.w	r8,r8[0x4]
80002c6c:	10 99       	mov	r9,r8
80002c6e:	e0 19 ff f0 	andl	r9,0xfff0
80002c72:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c76:	91 19       	st.w	r8[0x4],r9
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80002c78:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c7c:	35 09       	mov	r9,80
80002c7e:	91 09       	st.w	r8[0x0],r9
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80002c80:	30 08       	mov	r8,0
}
80002c82:	10 9c       	mov	r12,r8
80002c84:	2f dd       	sub	sp,-12
80002c86:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c8a:	00 00       	add	r0,r0
80002c8c:	80 00       	ld.sh	r0,r0[0x0]
80002c8e:	2a b0       	sub	r0,-85
80002c90:	80 00       	ld.sh	r0,r0[0x0]
80002c92:	29 dc       	sub	r12,-99

80002c94 <usart_write_char>:
  return USART_SUCCESS;
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
80002c94:	eb cd 40 80 	pushm	r7,lr
80002c98:	1a 97       	mov	r7,sp
80002c9a:	20 3d       	sub	sp,12
80002c9c:	ef 4c ff f8 	st.w	r7[-8],r12
80002ca0:	ef 4b ff f4 	st.w	r7[-12],r11
80002ca4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ca8:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80002cac:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002cb0:	70 58       	ld.w	r8,r8[0x14]
80002cb2:	e2 18 00 02 	andl	r8,0x2,COH
80002cb6:	5f 18       	srne	r8
  if (usart_tx_ready(usart))
80002cb8:	58 08       	cp.w	r8,0
80002cba:	c0 a0       	breq	80002cce <usart_write_char+0x3a>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80002cbc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002cc0:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80002cc4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002cc8:	91 79       	st.w	r8[0x1c],r9
    return USART_SUCCESS;
80002cca:	30 08       	mov	r8,0
80002ccc:	c0 28       	rjmp	80002cd0 <usart_write_char+0x3c>
  }
  else
    return USART_TX_BUSY;
80002cce:	30 28       	mov	r8,2
}
80002cd0:	10 9c       	mov	r12,r8
80002cd2:	2f dd       	sub	sp,-12
80002cd4:	e3 cd 80 80 	ldm	sp++,r7,pc

80002cd8 <usart_putchar>:


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80002cd8:	eb cd 40 80 	pushm	r7,lr
80002cdc:	1a 97       	mov	r7,sp
80002cde:	20 3d       	sub	sp,12
80002ce0:	ef 4c ff f8 	st.w	r7[-8],r12
80002ce4:	ef 4b ff f4 	st.w	r7[-12],r11
  int timeout = USART_DEFAULT_TIMEOUT;
80002ce8:	e0 68 27 10 	mov	r8,10000
80002cec:	ef 48 ff fc 	st.w	r7[-4],r8

  do
  {
    if (!timeout--) return USART_FAILURE;
80002cf0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002cf4:	58 08       	cp.w	r8,0
80002cf6:	5f 08       	sreq	r8
80002cf8:	5c 58       	castu.b	r8
80002cfa:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002cfe:	20 19       	sub	r9,1
80002d00:	ef 49 ff fc 	st.w	r7[-4],r9
80002d04:	58 08       	cp.w	r8,0
80002d06:	c0 30       	breq	80002d0c <usart_putchar+0x34>
80002d08:	3f f8       	mov	r8,-1
80002d0a:	c0 b8       	rjmp	80002d20 <usart_putchar+0x48>
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80002d0c:	ee fb ff f4 	ld.w	r11,r7[-12]
80002d10:	ee fc ff f8 	ld.w	r12,r7[-8]
80002d14:	f0 1f 00 05 	mcall	80002d28 <usart_putchar+0x50>
80002d18:	18 98       	mov	r8,r12
80002d1a:	58 08       	cp.w	r8,0
80002d1c:	ce a1       	brne	80002cf0 <usart_putchar+0x18>

  return USART_SUCCESS;
80002d1e:	30 08       	mov	r8,0
}
80002d20:	10 9c       	mov	r12,r8
80002d22:	2f dd       	sub	sp,-12
80002d24:	e3 cd 80 80 	ldm	sp++,r7,pc
80002d28:	80 00       	ld.sh	r0,r0[0x0]
80002d2a:	2c 94       	sub	r4,-55

80002d2c <usart_write_line>:
  return c;
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80002d2c:	eb cd 40 80 	pushm	r7,lr
80002d30:	1a 97       	mov	r7,sp
80002d32:	20 2d       	sub	sp,8
80002d34:	ef 4c ff fc 	st.w	r7[-4],r12
80002d38:	ef 4b ff f8 	st.w	r7[-8],r11
  while (*string != '\0')
80002d3c:	c0 e8       	rjmp	80002d58 <usart_write_line+0x2c>
    usart_putchar(usart, *string++);
80002d3e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d42:	11 88       	ld.ub	r8,r8[0x0]
80002d44:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002d48:	2f f9       	sub	r9,-1
80002d4a:	ef 49 ff f8 	st.w	r7[-8],r9
80002d4e:	10 9b       	mov	r11,r8
80002d50:	ee fc ff fc 	ld.w	r12,r7[-4]
80002d54:	f0 1f 00 05 	mcall	80002d68 <usart_write_line+0x3c>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80002d58:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d5c:	11 88       	ld.ub	r8,r8[0x0]
80002d5e:	58 08       	cp.w	r8,0
80002d60:	ce f1       	brne	80002d3e <usart_write_line+0x12>
    usart_putchar(usart, *string++);
}
80002d62:	2f ed       	sub	sp,-8
80002d64:	e3 cd 80 80 	ldm	sp++,r7,pc
80002d68:	80 00       	ld.sh	r0,r0[0x0]
80002d6a:	2c d8       	sub	r8,-51

80002d6c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
80002d6c:	eb cd 40 80 	pushm	r7,lr
80002d70:	1a 97       	mov	r7,sp
80002d72:	20 1d       	sub	sp,4
80002d74:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80002d78:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d7c:	2f 88       	sub	r8,-8
80002d7e:	10 99       	mov	r9,r8
80002d80:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d84:	91 19       	st.w	r8[0x4],r9

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80002d86:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d8a:	3f f9       	mov	r9,-1
80002d8c:	91 29       	st.w	r8[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80002d8e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d92:	2f 88       	sub	r8,-8
80002d94:	10 99       	mov	r9,r8
80002d96:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d9a:	91 39       	st.w	r8[0xc],r9
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80002d9c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002da0:	2f 88       	sub	r8,-8
80002da2:	10 99       	mov	r9,r8
80002da4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002da8:	91 49       	st.w	r8[0x10],r9

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80002daa:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002dae:	30 09       	mov	r9,0
80002db0:	91 09       	st.w	r8[0x0],r9
}
80002db2:	2f fd       	sub	sp,-4
80002db4:	e3 cd 80 80 	ldm	sp++,r7,pc

80002db8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
80002db8:	eb cd 40 80 	pushm	r7,lr
80002dbc:	1a 97       	mov	r7,sp
80002dbe:	20 1d       	sub	sp,4
80002dc0:	ef 4c ff fc 	st.w	r7[-4],r12
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80002dc4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002dc8:	30 09       	mov	r9,0
80002dca:	91 49       	st.w	r8[0x10],r9
}
80002dcc:	2f fd       	sub	sp,-4
80002dce:	e3 cd 80 80 	ldm	sp++,r7,pc

80002dd2 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
80002dd2:	eb cd 40 80 	pushm	r7,lr
80002dd6:	1a 97       	mov	r7,sp
80002dd8:	20 3d       	sub	sp,12
80002dda:	ef 4c ff f8 	st.w	r7[-8],r12
80002dde:	ef 4b ff f4 	st.w	r7[-12],r11

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80002de2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002de6:	70 18       	ld.w	r8,r8[0x4]
80002de8:	ef 48 ff fc 	st.w	r7[-4],r8

	pxNewListItem->pxNext = pxIndex->pxNext;
80002dec:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002df0:	70 19       	ld.w	r9,r8[0x4]
80002df2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002df6:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80002df8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dfc:	70 19       	ld.w	r9,r8[0x4]
80002dfe:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002e02:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80002e04:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e08:	70 18       	ld.w	r8,r8[0x4]
80002e0a:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002e0e:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80002e10:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002e14:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e18:	91 19       	st.w	r8[0x4],r9
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80002e1a:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002e1e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e22:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80002e24:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002e28:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002e2c:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80002e2e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e32:	70 08       	ld.w	r8,r8[0x0]
80002e34:	f0 c9 ff ff 	sub	r9,r8,-1
80002e38:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e3c:	91 09       	st.w	r8[0x0],r9
}
80002e3e:	2f dd       	sub	sp,-12
80002e40:	e3 cd 80 80 	ldm	sp++,r7,pc

80002e44 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
80002e44:	eb cd 40 80 	pushm	r7,lr
80002e48:	1a 97       	mov	r7,sp
80002e4a:	20 4d       	sub	sp,16
80002e4c:	ef 4c ff f4 	st.w	r7[-12],r12
80002e50:	ef 4b ff f0 	st.w	r7[-16],r11
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80002e54:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002e58:	70 08       	ld.w	r8,r8[0x0]
80002e5a:	ef 48 ff fc 	st.w	r7[-4],r8
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80002e5e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e62:	5b f8       	cp.w	r8,-1
80002e64:	c0 71       	brne	80002e72 <vListInsert+0x2e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80002e66:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002e6a:	70 48       	ld.w	r8,r8[0x10]
80002e6c:	ef 48 ff f8 	st.w	r7[-8],r8
80002e70:	c1 58       	rjmp	80002e9a <vListInsert+0x56>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80002e72:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002e76:	2f 88       	sub	r8,-8
80002e78:	ef 48 ff f8 	st.w	r7[-8],r8
80002e7c:	c0 68       	rjmp	80002e88 <vListInsert+0x44>
80002e7e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e82:	70 18       	ld.w	r8,r8[0x4]
80002e84:	ef 48 ff f8 	st.w	r7[-8],r8
80002e88:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e8c:	70 18       	ld.w	r8,r8[0x4]
80002e8e:	70 09       	ld.w	r9,r8[0x0]
80002e90:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e94:	10 39       	cp.w	r9,r8
80002e96:	fe 98 ff f4 	brls	80002e7e <vListInsert+0x3a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80002e9a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e9e:	70 19       	ld.w	r9,r8[0x4]
80002ea0:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ea4:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80002ea6:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002eaa:	70 18       	ld.w	r8,r8[0x4]
80002eac:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002eb0:	91 29       	st.w	r8[0x8],r9
	pxNewListItem->pxPrevious = pxIterator;
80002eb2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002eb6:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002eba:	91 29       	st.w	r8[0x8],r9
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80002ebc:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002ec0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ec4:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80002ec6:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002eca:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002ece:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80002ed0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002ed4:	70 08       	ld.w	r8,r8[0x0]
80002ed6:	f0 c9 ff ff 	sub	r9,r8,-1
80002eda:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002ede:	91 09       	st.w	r8[0x0],r9
}
80002ee0:	2f cd       	sub	sp,-16
80002ee2:	e3 cd 80 80 	ldm	sp++,r7,pc

80002ee6 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
80002ee6:	eb cd 40 80 	pushm	r7,lr
80002eea:	1a 97       	mov	r7,sp
80002eec:	20 2d       	sub	sp,8
80002eee:	ef 4c ff f8 	st.w	r7[-8],r12
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80002ef2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ef6:	70 18       	ld.w	r8,r8[0x4]
80002ef8:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002efc:	72 29       	ld.w	r9,r9[0x8]
80002efe:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80002f00:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002f04:	70 28       	ld.w	r8,r8[0x8]
80002f06:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002f0a:	72 19       	ld.w	r9,r9[0x4]
80002f0c:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80002f0e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002f12:	70 48       	ld.w	r8,r8[0x10]
80002f14:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80002f18:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002f1c:	70 19       	ld.w	r9,r8[0x4]
80002f1e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002f22:	10 39       	cp.w	r9,r8
80002f24:	c0 71       	brne	80002f32 <vListRemove+0x4c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80002f26:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002f2a:	70 29       	ld.w	r9,r8[0x8]
80002f2c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002f30:	91 19       	st.w	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80002f32:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002f36:	30 09       	mov	r9,0
80002f38:	91 49       	st.w	r8[0x10],r9
	( pxList->uxNumberOfItems )--;
80002f3a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002f3e:	70 08       	ld.w	r8,r8[0x0]
80002f40:	f0 c9 00 01 	sub	r9,r8,1
80002f44:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002f48:	91 09       	st.w	r8[0x0],r9
}
80002f4a:	2f ed       	sub	sp,-8
80002f4c:	e3 cd 80 80 	ldm	sp++,r7,pc

80002f50 <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80002f50:	eb cd 40 80 	pushm	r7,lr
80002f54:	1a 97       	mov	r7,sp
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
80002f56:	48 e8       	lddpc	r8,80002f8c <_init_startup+0x3c>
80002f58:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
80002f5c:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
80002f5e:	f0 1f 00 0d 	mcall	80002f90 <_init_startup+0x40>
			.channelmode = USART_NORMAL_CHMODE
		};

		/* Initialize the USART used for the debug trace with the configured parameters. */
		extern volatile avr32_usart_t *volatile stdio_usart_base;
		stdio_usart_base = configDBG_USART;
80002f62:	48 d8       	lddpc	r8,80002f94 <_init_startup+0x44>
80002f64:	fe 79 18 00 	mov	r9,-59392
80002f68:	91 09       	st.w	r8[0x0],r9
		gpio_enable_module( DBG_USART_GPIO_MAP,
80002f6a:	30 2b       	mov	r11,2
80002f6c:	48 bc       	lddpc	r12,80002f98 <_init_startup+0x48>
80002f6e:	f0 1f 00 0c 	mcall	80002f9c <_init_startup+0x4c>
		                    sizeof( DBG_USART_GPIO_MAP ) / sizeof( DBG_USART_GPIO_MAP[0] ) );
		usart_init_rs232(configDBG_USART, &DBG_USART_OPTIONS, configPBA_CLOCK_HZ);
80002f72:	e0 6a 1b 00 	mov	r10,6912
80002f76:	ea 1a 00 b7 	orh	r10,0xb7
80002f7a:	48 ab       	lddpc	r11,80002fa0 <_init_startup+0x50>
80002f7c:	fe 7c 18 00 	mov	r12,-59392
80002f80:	f0 1f 00 09 	mcall	80002fa4 <_init_startup+0x54>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
80002f84:	30 18       	mov	r8,1
}
80002f86:	10 9c       	mov	r12,r8
80002f88:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f8c:	80 00       	ld.sh	r0,r0[0x0]
80002f8e:	52 00       	stdsp	sp[0x80],r0
80002f90:	80 00       	ld.sh	r0,r0[0x0]
80002f92:	26 60       	sub	r0,102
80002f94:	00 00       	add	r0,r0
80002f96:	07 a4       	ld.ub	r4,r3[0x2]
80002f98:	80 00       	ld.sh	r0,r0[0x0]
80002f9a:	54 e4       	stdsp	sp[0x138],r4
80002f9c:	80 00       	ld.sh	r0,r0[0x0]
80002f9e:	24 54       	sub	r4,69
80002fa0:	80 00       	ld.sh	r0,r0[0x0]
80002fa2:	54 f4       	stdsp	sp[0x13c],r4
80002fa4:	80 00       	ld.sh	r0,r0[0x0]
80002fa6:	2b 24       	sub	r4,-78

80002fa8 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80002fa8:	eb cd 40 80 	pushm	r7,lr
80002fac:	1a 97       	mov	r7,sp
80002fae:	20 1d       	sub	sp,4
80002fb0:	ef 4c ff fc 	st.w	r7[-4],r12
	vTaskSuspendAll();
80002fb4:	f0 1f 00 03 	mcall	80002fc0 <__malloc_lock+0x18>
}
80002fb8:	2f fd       	sub	sp,-4
80002fba:	e3 cd 80 80 	ldm	sp++,r7,pc
80002fbe:	00 00       	add	r0,r0
80002fc0:	80 00       	ld.sh	r0,r0[0x0]
80002fc2:	3e c8       	mov	r8,-20

80002fc4 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80002fc4:	eb cd 40 80 	pushm	r7,lr
80002fc8:	1a 97       	mov	r7,sp
80002fca:	20 1d       	sub	sp,4
80002fcc:	ef 4c ff fc 	st.w	r7[-4],r12
	xTaskResumeAll();
80002fd0:	f0 1f 00 03 	mcall	80002fdc <__malloc_unlock+0x18>
}
80002fd4:	2f fd       	sub	sp,-4
80002fd6:	e3 cd 80 80 	ldm	sp++,r7,pc
80002fda:	00 00       	add	r0,r0
80002fdc:	80 00       	ld.sh	r0,r0[0x0]
80002fde:	3e e4       	mov	r4,-18

80002fe0 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80002fe0:	eb cd 00 ff 	pushm	r0-r7
80002fe4:	e0 68 00 1c 	mov	r8,28
80002fe8:	ea 18 00 00 	orh	r8,0x0
80002fec:	70 00       	ld.w	r0,r8[0x0]
80002fee:	1a d0       	st.w	--sp,r0
80002ff0:	7a 90       	ld.w	r0,sp[0x24]
80002ff2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80002ff6:	58 10       	cp.w	r0,1
80002ff8:	e0 8b 00 08 	brhi	80003008 <LABEL_INT_SKIP_SAVE_CONTEXT_234>
80002ffc:	e0 68 06 20 	mov	r8,1568
80003000:	ea 18 00 00 	orh	r8,0x0
80003004:	70 00       	ld.w	r0,r8[0x0]
80003006:	81 0d       	st.w	r0[0x0],sp

80003008 <LABEL_INT_SKIP_SAVE_CONTEXT_234>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80003008:	f0 1f 00 12 	mcall	80003050 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
8000300c:	f0 1f 00 12 	mcall	80003054 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
		vTaskIncrementTick();
80003010:	f0 1f 00 12 	mcall	80003058 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x1c>
	portEXIT_CRITICAL();
80003014:	f0 1f 00 12 	mcall	8000305c <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80003018:	7a 90       	ld.w	r0,sp[0x24]
8000301a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000301e:	58 10       	cp.w	r0,1
80003020:	e0 8b 00 0e 	brhi	8000303c <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
80003024:	f0 1f 00 0c 	mcall	80003054 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
80003028:	f0 1f 00 0e 	mcall	80003060 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x24>
8000302c:	f0 1f 00 0c 	mcall	8000305c <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>
80003030:	e0 68 06 20 	mov	r8,1568
80003034:	ea 18 00 00 	orh	r8,0x0
80003038:	70 00       	ld.w	r0,r8[0x0]
8000303a:	60 0d       	ld.w	sp,r0[0x0]

8000303c <LABEL_INT_SKIP_RESTORE_CONTEXT_251>:
8000303c:	1b 00       	ld.w	r0,sp++
8000303e:	e0 68 00 1c 	mov	r8,28
80003042:	ea 18 00 00 	orh	r8,0x0
80003046:	91 00       	st.w	r8[0x0],r0
80003048:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000304c:	d6 03       	rete
8000304e:	00 00       	add	r0,r0
80003050:	80 00       	ld.sh	r0,r0[0x0]
80003052:	33 4c       	mov	r12,52
80003054:	80 00       	ld.sh	r0,r0[0x0]
80003056:	30 fc       	mov	r12,15
80003058:	80 00       	ld.sh	r0,r0[0x0]
8000305a:	40 3c       	lddsp	r12,sp[0xc]
8000305c:	80 00       	ld.sh	r0,r0[0x0]
8000305e:	31 18       	mov	r8,17
80003060:	80 00       	ld.sh	r0,r0[0x0]
80003062:	41 9c       	lddsp	r12,sp[0x64]

80003064 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80003064:	20 6d       	sub	sp,24
80003066:	eb cd 00 ff 	pushm	r0-r7
8000306a:	fa c7 ff c0 	sub	r7,sp,-64
8000306e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80003072:	ef 40 ff e0 	st.w	r7[-32],r0
80003076:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000307a:	ef 40 ff e4 	st.w	r7[-28],r0
8000307e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80003082:	e0 68 00 1c 	mov	r8,28
80003086:	ea 18 00 00 	orh	r8,0x0
8000308a:	70 00       	ld.w	r0,r8[0x0]
8000308c:	1a d0       	st.w	--sp,r0
8000308e:	f0 1f 00 1a 	mcall	800030f4 <LABEL_RET_SCALL_260+0x14>
80003092:	e0 68 06 20 	mov	r8,1568
80003096:	ea 18 00 00 	orh	r8,0x0
8000309a:	70 00       	ld.w	r0,r8[0x0]
8000309c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
8000309e:	f0 1f 00 17 	mcall	800030f8 <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
800030a2:	e0 68 06 20 	mov	r8,1568
800030a6:	ea 18 00 00 	orh	r8,0x0
800030aa:	70 00       	ld.w	r0,r8[0x0]
800030ac:	60 0d       	ld.w	sp,r0[0x0]
800030ae:	1b 00       	ld.w	r0,sp++
800030b0:	e0 68 00 1c 	mov	r8,28
800030b4:	ea 18 00 00 	orh	r8,0x0
800030b8:	91 00       	st.w	r8[0x0],r0
800030ba:	fa c7 ff d8 	sub	r7,sp,-40
800030be:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800030c2:	ee f0 ff e0 	ld.w	r0,r7[-32]
800030c6:	e0 61 00 1c 	mov	r1,28
800030ca:	ea 11 00 00 	orh	r1,0x0
800030ce:	62 02       	ld.w	r2,r1[0x0]
800030d0:	58 02       	cp.w	r2,0
800030d2:	c0 70       	breq	800030e0 <LABEL_RET_SCALL_260>
800030d4:	e4 c2 00 01 	sub	r2,r2,1
800030d8:	83 02       	st.w	r1[0x0],r2
800030da:	58 02       	cp.w	r2,0
800030dc:	c0 21       	brne	800030e0 <LABEL_RET_SCALL_260>
800030de:	b1 c0       	cbr	r0,0x10

800030e0 <LABEL_RET_SCALL_260>:
800030e0:	ef 40 ff f8 	st.w	r7[-8],r0
800030e4:	ee f0 ff e4 	ld.w	r0,r7[-28]
800030e8:	ef 40 ff fc 	st.w	r7[-4],r0
800030ec:	e3 cd 00 ff 	ldm	sp++,r0-r7
800030f0:	2f ad       	sub	sp,-24
800030f2:	d6 13       	rets
800030f4:	80 00       	ld.sh	r0,r0[0x0]
800030f6:	30 fc       	mov	r12,15
800030f8:	80 00       	ld.sh	r0,r0[0x0]
800030fa:	41 9c       	lddsp	r12,sp[0x64]

800030fc <vPortEnterCritical>:
/* The code generated by the GCC compiler uses the stack in different ways at
different optimisation levels.  The interrupt flags can therefore not always
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
800030fc:	eb cd 40 80 	pushm	r7,lr
80003100:	1a 97       	mov	r7,sp
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80003102:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80003104:	48 48       	lddpc	r8,80003114 <vPortEnterCritical+0x18>
80003106:	70 08       	ld.w	r8,r8[0x0]
80003108:	f0 c9 ff ff 	sub	r9,r8,-1
8000310c:	48 28       	lddpc	r8,80003114 <vPortEnterCritical+0x18>
8000310e:	91 09       	st.w	r8[0x0],r9
}
80003110:	e3 cd 80 80 	ldm	sp++,r7,pc
80003114:	00 00       	add	r0,r0
80003116:	00 1c       	sub	r12,r0

80003118 <vPortExitCritical>:
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
80003118:	eb cd 40 80 	pushm	r7,lr
8000311c:	1a 97       	mov	r7,sp
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
8000311e:	48 98       	lddpc	r8,80003140 <vPortExitCritical+0x28>
80003120:	70 08       	ld.w	r8,r8[0x0]
80003122:	58 08       	cp.w	r8,0
80003124:	c0 c0       	breq	8000313c <vPortExitCritical+0x24>
	{
		ulCriticalNesting--;
80003126:	48 78       	lddpc	r8,80003140 <vPortExitCritical+0x28>
80003128:	70 08       	ld.w	r8,r8[0x0]
8000312a:	f0 c9 00 01 	sub	r9,r8,1
8000312e:	48 58       	lddpc	r8,80003140 <vPortExitCritical+0x28>
80003130:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80003132:	48 48       	lddpc	r8,80003140 <vPortExitCritical+0x28>
80003134:	70 08       	ld.w	r8,r8[0x0]
80003136:	58 08       	cp.w	r8,0
80003138:	c0 21       	brne	8000313c <vPortExitCritical+0x24>
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000313a:	d5 03       	csrf	0x10
		}
	}
}
8000313c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003140:	00 00       	add	r0,r0
80003142:	00 1c       	sub	r12,r0

80003144 <pxPortInitialiseStack>:
 * portSAVE_CONTEXT had been called.
 *
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
80003144:	eb cd 40 80 	pushm	r7,lr
80003148:	1a 97       	mov	r7,sp
8000314a:	20 3d       	sub	sp,12
8000314c:	ef 4c ff fc 	st.w	r7[-4],r12
80003150:	ef 4b ff f8 	st.w	r7[-8],r11
80003154:	ef 4a ff f4 	st.w	r7[-12],r10
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
80003158:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000315c:	20 48       	sub	r8,4
8000315e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80003162:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003166:	e0 69 08 08 	mov	r9,2056
8000316a:	ea 19 08 08 	orh	r9,0x808
8000316e:	91 09       	st.w	r8[0x0],r9
80003170:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003174:	20 48       	sub	r8,4
80003176:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000317a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000317e:	e0 69 09 09 	mov	r9,2313
80003182:	ea 19 09 09 	orh	r9,0x909
80003186:	91 09       	st.w	r8[0x0],r9
80003188:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000318c:	20 48       	sub	r8,4
8000318e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80003192:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003196:	e0 69 0a 0a 	mov	r9,2570
8000319a:	ea 19 0a 0a 	orh	r9,0xa0a
8000319e:	91 09       	st.w	r8[0x0],r9
800031a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031a4:	20 48       	sub	r8,4
800031a6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800031aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031ae:	e0 69 0b 0b 	mov	r9,2827
800031b2:	ea 19 0b 0b 	orh	r9,0xb0b
800031b6:	91 09       	st.w	r8[0x0],r9
800031b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031bc:	20 48       	sub	r8,4
800031be:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800031c2:	ee f9 ff f4 	ld.w	r9,r7[-12]
800031c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031ca:	91 09       	st.w	r8[0x0],r9
800031cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031d0:	20 48       	sub	r8,4
800031d2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800031d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031da:	e0 69 be ef 	mov	r9,48879
800031de:	ea 19 de ad 	orh	r9,0xdead
800031e2:	91 09       	st.w	r8[0x0],r9
800031e4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031e8:	20 48       	sub	r8,4
800031ea:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
800031ee:	ee f9 ff f8 	ld.w	r9,r7[-8]
800031f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031f6:	91 09       	st.w	r8[0x0],r9
800031f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031fc:	20 48       	sub	r8,4
800031fe:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80003202:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003206:	fc 19 00 40 	movh	r9,0x40
8000320a:	91 09       	st.w	r8[0x0],r9
8000320c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003210:	20 48       	sub	r8,4
80003212:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80003216:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000321a:	e0 69 00 ff 	mov	r9,255
8000321e:	ea 19 ff 00 	orh	r9,0xff00
80003222:	91 09       	st.w	r8[0x0],r9
80003224:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003228:	20 48       	sub	r8,4
8000322a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
8000322e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003232:	e0 69 01 01 	mov	r9,257
80003236:	ea 19 01 01 	orh	r9,0x101
8000323a:	91 09       	st.w	r8[0x0],r9
8000323c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003240:	20 48       	sub	r8,4
80003242:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80003246:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000324a:	e0 69 02 02 	mov	r9,514
8000324e:	ea 19 02 02 	orh	r9,0x202
80003252:	91 09       	st.w	r8[0x0],r9
80003254:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003258:	20 48       	sub	r8,4
8000325a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
8000325e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003262:	e0 69 03 03 	mov	r9,771
80003266:	ea 19 03 03 	orh	r9,0x303
8000326a:	91 09       	st.w	r8[0x0],r9
8000326c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003270:	20 48       	sub	r8,4
80003272:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80003276:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000327a:	e0 69 04 04 	mov	r9,1028
8000327e:	ea 19 04 04 	orh	r9,0x404
80003282:	91 09       	st.w	r8[0x0],r9
80003284:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003288:	20 48       	sub	r8,4
8000328a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
8000328e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003292:	e0 69 05 05 	mov	r9,1285
80003296:	ea 19 05 05 	orh	r9,0x505
8000329a:	91 09       	st.w	r8[0x0],r9
8000329c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032a0:	20 48       	sub	r8,4
800032a2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800032a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032aa:	e0 69 06 06 	mov	r9,1542
800032ae:	ea 19 06 06 	orh	r9,0x606
800032b2:	91 09       	st.w	r8[0x0],r9
800032b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032b8:	20 48       	sub	r8,4
800032ba:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800032be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032c2:	e0 69 07 07 	mov	r9,1799
800032c6:	ea 19 07 07 	orh	r9,0x707
800032ca:	91 09       	st.w	r8[0x0],r9
800032cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032d0:	20 48       	sub	r8,4
800032d2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800032d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032da:	30 09       	mov	r9,0
800032dc:	91 09       	st.w	r8[0x0],r9

	return pxTopOfStack;
800032de:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800032e2:	10 9c       	mov	r12,r8
800032e4:	2f dd       	sub	sp,-12
800032e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800032ea:	d7 03       	nop

800032ec <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
800032ec:	eb cd 40 80 	pushm	r7,lr
800032f0:	1a 97       	mov	r7,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
800032f2:	f0 1f 00 10 	mcall	80003330 <xPortStartScheduler+0x44>

	/* Start the first task. */
	portRESTORE_CONTEXT();
800032f6:	e0 68 06 20 	mov	r8,1568
800032fa:	ea 18 00 00 	orh	r8,0x0
800032fe:	70 00       	ld.w	r0,r8[0x0]
80003300:	60 0d       	ld.w	sp,r0[0x0]
80003302:	1b 00       	ld.w	r0,sp++
80003304:	e0 68 00 1c 	mov	r8,28
80003308:	ea 18 00 00 	orh	r8,0x0
8000330c:	91 00       	st.w	r8[0x0],r0
8000330e:	e3 cd 00 ff 	ldm	sp++,r0-r7
80003312:	2f ed       	sub	sp,-8
80003314:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80003318:	fa f0 ff e0 	ld.w	r0,sp[-32]
8000331c:	e3 b0 00 00 	mtsr	0x0,r0
80003320:	fa f0 ff dc 	ld.w	r0,sp[-36]
80003324:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
80003328:	30 08       	mov	r8,0
}
8000332a:	10 9c       	mov	r12,r8
8000332c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003330:	80 00       	ld.sh	r0,r0[0x0]
80003332:	33 60       	mov	r0,54

80003334 <prvScheduleFirstTick>:

/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
80003334:	eb cd 40 80 	pushm	r7,lr
80003338:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
8000333a:	e0 68 2e e0 	mov	r8,12000
8000333e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80003342:	30 08       	mov	r8,0
80003344:	e3 b8 00 42 	mtsr	0x108,r8
	}
80003348:	e3 cd 80 80 	ldm	sp++,r7,pc

8000334c <prvClearCcInt>:

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
8000334c:	eb cd 40 80 	pushm	r7,lr
80003350:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80003352:	e1 b8 00 43 	mfsr	r8,0x10c
80003356:	e3 b8 00 43 	mtsr	0x10c,r8
	}
8000335a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000335e:	d7 03       	nop

80003360 <prvSetupTimerInterrupt>:
#endif
/*-----------------------------------------------------------*/

/* Setup the timer to generate the tick interrupts. */
static void prvSetupTimerInterrupt(void)
{
80003360:	eb cd 40 80 	pushm	r7,lr
80003364:	1a 97       	mov	r7,sp
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80003366:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80003368:	30 0a       	mov	r10,0
8000336a:	30 0b       	mov	r11,0
8000336c:	48 4c       	lddpc	r12,8000337c <prvSetupTimerInterrupt+0x1c>
8000336e:	f0 1f 00 05 	mcall	80003380 <prvSetupTimerInterrupt+0x20>
		prvScheduleFirstTick();
80003372:	f0 1f 00 05 	mcall	80003384 <prvSetupTimerInterrupt+0x24>
	}
	#endif
}
80003376:	e3 cd 80 80 	ldm	sp++,r7,pc
8000337a:	00 00       	add	r0,r0
8000337c:	80 00       	ld.sh	r0,r0[0x0]
8000337e:	2f e0       	sub	r0,-2
80003380:	80 00       	ld.sh	r0,r0[0x0]
80003382:	26 f8       	sub	r8,111
80003384:	80 00       	ld.sh	r0,r0[0x0]
80003386:	33 34       	mov	r4,51

80003388 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80003388:	eb cd 40 80 	pushm	r7,lr
8000338c:	1a 97       	mov	r7,sp
8000338e:	20 2d       	sub	sp,8
80003390:	ef 4c ff f8 	st.w	r7[-8],r12
void *pvReturn;

	vTaskSuspendAll();
80003394:	f0 1f 00 09 	mcall	800033b8 <pvPortMalloc+0x30>
	{
		pvReturn = malloc( xWantedSize );
80003398:	ee fc ff f8 	ld.w	r12,r7[-8]
8000339c:	f0 1f 00 08 	mcall	800033bc <pvPortMalloc+0x34>
800033a0:	18 98       	mov	r8,r12
800033a2:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	xTaskResumeAll();
800033a6:	f0 1f 00 07 	mcall	800033c0 <pvPortMalloc+0x38>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
800033aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800033ae:	10 9c       	mov	r12,r8
800033b0:	2f ed       	sub	sp,-8
800033b2:	e3 cd 80 80 	ldm	sp++,r7,pc
800033b6:	00 00       	add	r0,r0
800033b8:	80 00       	ld.sh	r0,r0[0x0]
800033ba:	3e c8       	mov	r8,-20
800033bc:	80 00       	ld.sh	r0,r0[0x0]
800033be:	48 0c       	lddpc	r12,800033bc <pvPortMalloc+0x34>
800033c0:	80 00       	ld.sh	r0,r0[0x0]
800033c2:	3e e4       	mov	r4,-18

800033c4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800033c4:	eb cd 40 80 	pushm	r7,lr
800033c8:	1a 97       	mov	r7,sp
800033ca:	20 1d       	sub	sp,4
800033cc:	ef 4c ff fc 	st.w	r7[-4],r12
	if( pv )
800033d0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033d4:	58 08       	cp.w	r8,0
800033d6:	c0 90       	breq	800033e8 <vPortFree+0x24>
	{
		vTaskSuspendAll();
800033d8:	f0 1f 00 06 	mcall	800033f0 <vPortFree+0x2c>
		{
			free( pv );
800033dc:	ee fc ff fc 	ld.w	r12,r7[-4]
800033e0:	f0 1f 00 05 	mcall	800033f4 <vPortFree+0x30>
		}
		xTaskResumeAll();
800033e4:	f0 1f 00 05 	mcall	800033f8 <vPortFree+0x34>
	}
}
800033e8:	2f fd       	sub	sp,-4
800033ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800033ee:	00 00       	add	r0,r0
800033f0:	80 00       	ld.sh	r0,r0[0x0]
800033f2:	3e c8       	mov	r8,-20
800033f4:	80 00       	ld.sh	r0,r0[0x0]
800033f6:	47 fc       	lddsp	r12,sp[0x1fc]
800033f8:	80 00       	ld.sh	r0,r0[0x0]
800033fa:	3e e4       	mov	r4,-18

800033fc <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800033fc:	eb cd 40 80 	pushm	r7,lr
80003400:	1a 97       	mov	r7,sp
80003402:	20 5d       	sub	sp,20
80003404:	ef 4c ff f0 	st.w	r7[-16],r12
80003408:	ef 4b ff ec 	st.w	r7[-20],r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
8000340c:	30 08       	mov	r8,0
8000340e:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80003412:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003416:	58 08       	cp.w	r8,0
80003418:	c7 20       	breq	800034fc <xQueueCreate+0x100>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000341a:	34 cc       	mov	r12,76
8000341c:	f0 1f 00 3b 	mcall	80003508 <xQueueCreate+0x10c>
80003420:	18 98       	mov	r8,r12
80003422:	ef 48 ff f4 	st.w	r7[-12],r8
		if( pxNewQueue != NULL )
80003426:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000342a:	58 08       	cp.w	r8,0
8000342c:	c6 80       	breq	800034fc <xQueueCreate+0x100>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000342e:	ee f9 ff f0 	ld.w	r9,r7[-16]
80003432:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003436:	f2 08 02 48 	mul	r8,r9,r8
8000343a:	2f f8       	sub	r8,-1
8000343c:	ef 48 ff f8 	st.w	r7[-8],r8

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80003440:	ee fc ff f8 	ld.w	r12,r7[-8]
80003444:	f0 1f 00 31 	mcall	80003508 <xQueueCreate+0x10c>
80003448:	18 98       	mov	r8,r12
8000344a:	10 99       	mov	r9,r8
8000344c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003450:	91 09       	st.w	r8[0x0],r9
			if( pxNewQueue->pcHead != NULL )
80003452:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003456:	70 08       	ld.w	r8,r8[0x0]
80003458:	58 08       	cp.w	r8,0
8000345a:	c4 d0       	breq	800034f4 <xQueueCreate+0xf8>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000345c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003460:	70 09       	ld.w	r9,r8[0x0]
80003462:	ee fa ff f0 	ld.w	r10,r7[-16]
80003466:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000346a:	f4 08 02 48 	mul	r8,r10,r8
8000346e:	10 09       	add	r9,r8
80003470:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003474:	91 19       	st.w	r8[0x4],r9
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80003476:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000347a:	30 09       	mov	r9,0
8000347c:	91 e9       	st.w	r8[0x38],r9
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000347e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003482:	70 09       	ld.w	r9,r8[0x0]
80003484:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003488:	91 29       	st.w	r8[0x8],r9
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000348a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000348e:	70 09       	ld.w	r9,r8[0x0]
80003490:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003494:	f0 ca 00 01 	sub	r10,r8,1
80003498:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000349c:	f4 08 02 48 	mul	r8,r10,r8
800034a0:	10 09       	add	r9,r8
800034a2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800034a6:	91 39       	st.w	r8[0xc],r9
				pxNewQueue->uxLength = uxQueueLength;
800034a8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800034ac:	ee f9 ff f0 	ld.w	r9,r7[-16]
800034b0:	91 f9       	st.w	r8[0x3c],r9
				pxNewQueue->uxItemSize = uxItemSize;
800034b2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800034b6:	ee f9 ff ec 	ld.w	r9,r7[-20]
800034ba:	f1 49 00 40 	st.w	r8[64],r9
				pxNewQueue->xRxLock = queueUNLOCKED;
800034be:	ee f8 ff f4 	ld.w	r8,r7[-12]
800034c2:	3f f9       	mov	r9,-1
800034c4:	f1 49 00 44 	st.w	r8[68],r9
				pxNewQueue->xTxLock = queueUNLOCKED;
800034c8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800034cc:	3f f9       	mov	r9,-1
800034ce:	f1 49 00 48 	st.w	r8[72],r9

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800034d2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800034d6:	2f 08       	sub	r8,-16
800034d8:	10 9c       	mov	r12,r8
800034da:	f0 1f 00 0d 	mcall	8000350c <xQueueCreate+0x110>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800034de:	ee f8 ff f4 	ld.w	r8,r7[-12]
800034e2:	2d c8       	sub	r8,-36
800034e4:	10 9c       	mov	r12,r8
800034e6:	f0 1f 00 0a 	mcall	8000350c <xQueueCreate+0x110>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
800034ea:	ee f8 ff f4 	ld.w	r8,r7[-12]
800034ee:	ef 48 ff fc 	st.w	r7[-4],r8
800034f2:	c0 58       	rjmp	800034fc <xQueueCreate+0x100>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800034f4:	ee fc ff f4 	ld.w	r12,r7[-12]
800034f8:	f0 1f 00 06 	mcall	80003510 <xQueueCreate+0x114>
		}
	}

	configASSERT( xReturn );

	return xReturn;
800034fc:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80003500:	10 9c       	mov	r12,r8
80003502:	2f bd       	sub	sp,-20
80003504:	e3 cd 80 80 	ldm	sp++,r7,pc
80003508:	80 00       	ld.sh	r0,r0[0x0]
8000350a:	33 88       	mov	r8,56
8000350c:	80 00       	ld.sh	r0,r0[0x0]
8000350e:	2d 6c       	sub	r12,-42
80003510:	80 00       	ld.sh	r0,r0[0x0]
80003512:	33 c4       	mov	r4,60

80003514 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80003514:	eb cd 40 80 	pushm	r7,lr
80003518:	1a 97       	mov	r7,sp
8000351a:	20 7d       	sub	sp,28
8000351c:	ef 4c ff f0 	st.w	r7[-16],r12
80003520:	ef 4b ff ec 	st.w	r7[-20],r11
80003524:	ef 4a ff e8 	st.w	r7[-24],r10
80003528:	ef 49 ff e4 	st.w	r7[-28],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
8000352c:	30 08       	mov	r8,0
8000352e:	ef 48 ff fc 	st.w	r7[-4],r8
80003532:	c0 28       	rjmp	80003536 <xQueueGenericSend+0x22>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80003534:	d7 03       	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80003536:	f0 1f 00 47 	mcall	80003650 <xQueueGenericSend+0x13c>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000353a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000353e:	70 e9       	ld.w	r9,r8[0x38]
80003540:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003544:	70 f8       	ld.w	r8,r8[0x3c]
80003546:	10 39       	cp.w	r9,r8
80003548:	c1 c2       	brcc	80003580 <xQueueGenericSend+0x6c>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000354a:	ee fa ff e4 	ld.w	r10,r7[-28]
8000354e:	ee fb ff ec 	ld.w	r11,r7[-20]
80003552:	ee fc ff f0 	ld.w	r12,r7[-16]
80003556:	f0 1f 00 40 	mcall	80003654 <xQueueGenericSend+0x140>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000355a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000355e:	70 98       	ld.w	r8,r8[0x24]
80003560:	58 08       	cp.w	r8,0
80003562:	c0 b0       	breq	80003578 <xQueueGenericSend+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80003564:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003568:	2d c8       	sub	r8,-36
8000356a:	10 9c       	mov	r12,r8
8000356c:	f0 1f 00 3b 	mcall	80003658 <xQueueGenericSend+0x144>
80003570:	18 98       	mov	r8,r12
80003572:	58 18       	cp.w	r8,1
80003574:	c0 21       	brne	80003578 <xQueueGenericSend+0x64>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80003576:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80003578:	f0 1f 00 39 	mcall	8000365c <xQueueGenericSend+0x148>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000357c:	30 18       	mov	r8,1
8000357e:	c6 58       	rjmp	80003648 <xQueueGenericSend+0x134>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80003580:	ee f8 ff e8 	ld.w	r8,r7[-24]
80003584:	58 08       	cp.w	r8,0
80003586:	c0 51       	brne	80003590 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80003588:	f0 1f 00 35 	mcall	8000365c <xQueueGenericSend+0x148>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000358c:	30 08       	mov	r8,0
8000358e:	c5 d8       	rjmp	80003648 <xQueueGenericSend+0x134>
				}
				else if( xEntryTimeSet == pdFALSE )
80003590:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003594:	58 08       	cp.w	r8,0
80003596:	c0 91       	brne	800035a8 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80003598:	ee c8 00 0c 	sub	r8,r7,12
8000359c:	10 9c       	mov	r12,r8
8000359e:	f0 1f 00 31 	mcall	80003660 <xQueueGenericSend+0x14c>
					xEntryTimeSet = pdTRUE;
800035a2:	30 18       	mov	r8,1
800035a4:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}
		}
		taskEXIT_CRITICAL();
800035a8:	f0 1f 00 2d 	mcall	8000365c <xQueueGenericSend+0x148>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800035ac:	f0 1f 00 2e 	mcall	80003664 <xQueueGenericSend+0x150>
		prvLockQueue( pxQueue );
800035b0:	f0 1f 00 28 	mcall	80003650 <xQueueGenericSend+0x13c>
800035b4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035b8:	71 18       	ld.w	r8,r8[0x44]
800035ba:	5b f8       	cp.w	r8,-1
800035bc:	c0 61       	brne	800035c8 <xQueueGenericSend+0xb4>
800035be:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035c2:	30 09       	mov	r9,0
800035c4:	f1 49 00 44 	st.w	r8[68],r9
800035c8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035cc:	71 28       	ld.w	r8,r8[0x48]
800035ce:	5b f8       	cp.w	r8,-1
800035d0:	c0 61       	brne	800035dc <xQueueGenericSend+0xc8>
800035d2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035d6:	30 09       	mov	r9,0
800035d8:	f1 49 00 48 	st.w	r8[72],r9
800035dc:	f0 1f 00 20 	mcall	8000365c <xQueueGenericSend+0x148>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800035e0:	ee c9 00 18 	sub	r9,r7,24
800035e4:	ee c8 00 0c 	sub	r8,r7,12
800035e8:	12 9b       	mov	r11,r9
800035ea:	10 9c       	mov	r12,r8
800035ec:	f0 1f 00 1f 	mcall	80003668 <xQueueGenericSend+0x154>
800035f0:	18 98       	mov	r8,r12
800035f2:	58 08       	cp.w	r8,0
800035f4:	c2 31       	brne	8000363a <xQueueGenericSend+0x126>
		{
			if( prvIsQueueFull( pxQueue ) )
800035f6:	ee fc ff f0 	ld.w	r12,r7[-16]
800035fa:	f0 1f 00 1d 	mcall	8000366c <xQueueGenericSend+0x158>
800035fe:	18 98       	mov	r8,r12
80003600:	58 08       	cp.w	r8,0
80003602:	c1 50       	breq	8000362c <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80003604:	ee f9 ff e8 	ld.w	r9,r7[-24]
80003608:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000360c:	2f 08       	sub	r8,-16
8000360e:	12 9b       	mov	r11,r9
80003610:	10 9c       	mov	r12,r8
80003612:	f0 1f 00 18 	mcall	80003670 <xQueueGenericSend+0x15c>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80003616:	ee fc ff f0 	ld.w	r12,r7[-16]
8000361a:	f0 1f 00 17 	mcall	80003674 <xQueueGenericSend+0x160>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
8000361e:	f0 1f 00 17 	mcall	80003678 <xQueueGenericSend+0x164>
80003622:	18 98       	mov	r8,r12
80003624:	58 08       	cp.w	r8,0
80003626:	c8 71       	brne	80003534 <xQueueGenericSend+0x20>
				{
					portYIELD_WITHIN_API();
80003628:	d7 33       	scall
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
8000362a:	c8 6b       	rjmp	80003536 <xQueueGenericSend+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000362c:	ee fc ff f0 	ld.w	r12,r7[-16]
80003630:	f0 1f 00 11 	mcall	80003674 <xQueueGenericSend+0x160>
				( void ) xTaskResumeAll();
80003634:	f0 1f 00 11 	mcall	80003678 <xQueueGenericSend+0x164>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80003638:	c7 fb       	rjmp	80003536 <xQueueGenericSend+0x22>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000363a:	ee fc ff f0 	ld.w	r12,r7[-16]
8000363e:	f0 1f 00 0e 	mcall	80003674 <xQueueGenericSend+0x160>
			( void ) xTaskResumeAll();
80003642:	f0 1f 00 0e 	mcall	80003678 <xQueueGenericSend+0x164>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
80003646:	30 08       	mov	r8,0
		}
	}
}
80003648:	10 9c       	mov	r12,r8
8000364a:	2f 9d       	sub	sp,-28
8000364c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003650:	80 00       	ld.sh	r0,r0[0x0]
80003652:	30 fc       	mov	r12,15
80003654:	80 00       	ld.sh	r0,r0[0x0]
80003656:	38 28       	mov	r8,-126
80003658:	80 00       	ld.sh	r0,r0[0x0]
8000365a:	42 cc       	lddsp	r12,sp[0xb0]
8000365c:	80 00       	ld.sh	r0,r0[0x0]
8000365e:	31 18       	mov	r8,17
80003660:	80 00       	ld.sh	r0,r0[0x0]
80003662:	43 9c       	lddsp	r12,sp[0xe4]
80003664:	80 00       	ld.sh	r0,r0[0x0]
80003666:	3e c8       	mov	r8,-20
80003668:	80 00       	ld.sh	r0,r0[0x0]
8000366a:	43 cc       	lddsp	r12,sp[0xf0]
8000366c:	80 00       	ld.sh	r0,r0[0x0]
8000366e:	3a 7c       	mov	r12,-89
80003670:	80 00       	ld.sh	r0,r0[0x0]
80003672:	42 4c       	lddsp	r12,sp[0x90]
80003674:	80 00       	ld.sh	r0,r0[0x0]
80003676:	39 74       	mov	r4,-105
80003678:	80 00       	ld.sh	r0,r0[0x0]
8000367a:	3e e4       	mov	r4,-18

8000367c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
8000367c:	eb cd 40 80 	pushm	r7,lr
80003680:	1a 97       	mov	r7,sp
80003682:	20 8d       	sub	sp,32
80003684:	ef 4c ff ec 	st.w	r7[-20],r12
80003688:	ef 4b ff e8 	st.w	r7[-24],r11
8000368c:	ef 4a ff e4 	st.w	r7[-28],r10
80003690:	ef 49 ff e0 	st.w	r7[-32],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
80003694:	30 08       	mov	r8,0
80003696:	ef 48 ff f8 	st.w	r7[-8],r8
8000369a:	c0 28       	rjmp	8000369e <xQueueGenericReceive+0x22>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
8000369c:	d7 03       	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8000369e:	f0 1f 00 58 	mcall	800037fc <xQueueGenericReceive+0x180>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800036a2:	ee f8 ff ec 	ld.w	r8,r7[-20]
800036a6:	70 e8       	ld.w	r8,r8[0x38]
800036a8:	58 08       	cp.w	r8,0
800036aa:	c4 00       	breq	8000372a <xQueueGenericReceive+0xae>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800036ac:	ee f8 ff ec 	ld.w	r8,r7[-20]
800036b0:	70 38       	ld.w	r8,r8[0xc]
800036b2:	ef 48 ff fc 	st.w	r7[-4],r8

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800036b6:	ee fb ff e8 	ld.w	r11,r7[-24]
800036ba:	ee fc ff ec 	ld.w	r12,r7[-20]
800036be:	f0 1f 00 51 	mcall	80003800 <xQueueGenericReceive+0x184>

				if( xJustPeeking == pdFALSE )
800036c2:	ee f8 ff e0 	ld.w	r8,r7[-32]
800036c6:	58 08       	cp.w	r8,0
800036c8:	c1 91       	brne	800036fa <xQueueGenericReceive+0x7e>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800036ca:	ee f8 ff ec 	ld.w	r8,r7[-20]
800036ce:	70 e8       	ld.w	r8,r8[0x38]
800036d0:	f0 c9 00 01 	sub	r9,r8,1
800036d4:	ee f8 ff ec 	ld.w	r8,r7[-20]
800036d8:	91 e9       	st.w	r8[0x38],r9
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800036da:	ee f8 ff ec 	ld.w	r8,r7[-20]
800036de:	70 48       	ld.w	r8,r8[0x10]
800036e0:	58 08       	cp.w	r8,0
800036e2:	c2 00       	breq	80003722 <xQueueGenericReceive+0xa6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800036e4:	ee f8 ff ec 	ld.w	r8,r7[-20]
800036e8:	2f 08       	sub	r8,-16
800036ea:	10 9c       	mov	r12,r8
800036ec:	f0 1f 00 46 	mcall	80003804 <xQueueGenericReceive+0x188>
800036f0:	18 98       	mov	r8,r12
800036f2:	58 18       	cp.w	r8,1
800036f4:	c1 71       	brne	80003722 <xQueueGenericReceive+0xa6>
						{
							portYIELD_WITHIN_API();
800036f6:	d7 33       	scall
800036f8:	c1 58       	rjmp	80003722 <xQueueGenericReceive+0xa6>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800036fa:	ee f8 ff ec 	ld.w	r8,r7[-20]
800036fe:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003702:	91 39       	st.w	r8[0xc],r9

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80003704:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003708:	70 98       	ld.w	r8,r8[0x24]
8000370a:	58 08       	cp.w	r8,0
8000370c:	c0 b0       	breq	80003722 <xQueueGenericReceive+0xa6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000370e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003712:	2d c8       	sub	r8,-36
80003714:	10 9c       	mov	r12,r8
80003716:	f0 1f 00 3c 	mcall	80003804 <xQueueGenericReceive+0x188>
8000371a:	18 98       	mov	r8,r12
8000371c:	58 08       	cp.w	r8,0
8000371e:	c0 20       	breq	80003722 <xQueueGenericReceive+0xa6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80003720:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80003722:	f0 1f 00 3a 	mcall	80003808 <xQueueGenericReceive+0x18c>
				return pdPASS;
80003726:	30 18       	mov	r8,1
80003728:	c6 68       	rjmp	800037f4 <xQueueGenericReceive+0x178>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000372a:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000372e:	58 08       	cp.w	r8,0
80003730:	c0 51       	brne	8000373a <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80003732:	f0 1f 00 36 	mcall	80003808 <xQueueGenericReceive+0x18c>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80003736:	30 08       	mov	r8,0
80003738:	c5 e8       	rjmp	800037f4 <xQueueGenericReceive+0x178>
				}
				else if( xEntryTimeSet == pdFALSE )
8000373a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000373e:	58 08       	cp.w	r8,0
80003740:	c0 91       	brne	80003752 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80003742:	ee c8 00 10 	sub	r8,r7,16
80003746:	10 9c       	mov	r12,r8
80003748:	f0 1f 00 31 	mcall	8000380c <xQueueGenericReceive+0x190>
					xEntryTimeSet = pdTRUE;
8000374c:	30 18       	mov	r8,1
8000374e:	ef 48 ff f8 	st.w	r7[-8],r8
				}
			}
		}
		taskEXIT_CRITICAL();
80003752:	f0 1f 00 2e 	mcall	80003808 <xQueueGenericReceive+0x18c>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80003756:	f0 1f 00 2f 	mcall	80003810 <xQueueGenericReceive+0x194>
		prvLockQueue( pxQueue );
8000375a:	f0 1f 00 29 	mcall	800037fc <xQueueGenericReceive+0x180>
8000375e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003762:	71 18       	ld.w	r8,r8[0x44]
80003764:	5b f8       	cp.w	r8,-1
80003766:	c0 61       	brne	80003772 <xQueueGenericReceive+0xf6>
80003768:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000376c:	30 09       	mov	r9,0
8000376e:	f1 49 00 44 	st.w	r8[68],r9
80003772:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003776:	71 28       	ld.w	r8,r8[0x48]
80003778:	5b f8       	cp.w	r8,-1
8000377a:	c0 61       	brne	80003786 <xQueueGenericReceive+0x10a>
8000377c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003780:	30 09       	mov	r9,0
80003782:	f1 49 00 48 	st.w	r8[72],r9
80003786:	f0 1f 00 21 	mcall	80003808 <xQueueGenericReceive+0x18c>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000378a:	ee c9 00 1c 	sub	r9,r7,28
8000378e:	ee c8 00 10 	sub	r8,r7,16
80003792:	12 9b       	mov	r11,r9
80003794:	10 9c       	mov	r12,r8
80003796:	f0 1f 00 20 	mcall	80003814 <xQueueGenericReceive+0x198>
8000379a:	18 98       	mov	r8,r12
8000379c:	58 08       	cp.w	r8,0
8000379e:	c2 41       	brne	800037e6 <xQueueGenericReceive+0x16a>
		{
			if( prvIsQueueEmpty( pxQueue ) )
800037a0:	ee fc ff ec 	ld.w	r12,r7[-20]
800037a4:	f0 1f 00 1d 	mcall	80003818 <xQueueGenericReceive+0x19c>
800037a8:	18 98       	mov	r8,r12
800037aa:	58 08       	cp.w	r8,0
800037ac:	c1 60       	breq	800037d8 <xQueueGenericReceive+0x15c>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800037ae:	ee f9 ff e4 	ld.w	r9,r7[-28]
800037b2:	ee f8 ff ec 	ld.w	r8,r7[-20]
800037b6:	2d c8       	sub	r8,-36
800037b8:	12 9b       	mov	r11,r9
800037ba:	10 9c       	mov	r12,r8
800037bc:	f0 1f 00 18 	mcall	8000381c <xQueueGenericReceive+0x1a0>
				prvUnlockQueue( pxQueue );
800037c0:	ee fc ff ec 	ld.w	r12,r7[-20]
800037c4:	f0 1f 00 17 	mcall	80003820 <xQueueGenericReceive+0x1a4>
				if( !xTaskResumeAll() )
800037c8:	f0 1f 00 17 	mcall	80003824 <xQueueGenericReceive+0x1a8>
800037cc:	18 98       	mov	r8,r12
800037ce:	58 08       	cp.w	r8,0
800037d0:	fe 91 ff 66 	brne	8000369c <xQueueGenericReceive+0x20>
				{
					portYIELD_WITHIN_API();
800037d4:	d7 33       	scall
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800037d6:	c6 4b       	rjmp	8000369e <xQueueGenericReceive+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800037d8:	ee fc ff ec 	ld.w	r12,r7[-20]
800037dc:	f0 1f 00 11 	mcall	80003820 <xQueueGenericReceive+0x1a4>
				( void ) xTaskResumeAll();
800037e0:	f0 1f 00 11 	mcall	80003824 <xQueueGenericReceive+0x1a8>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800037e4:	c5 db       	rjmp	8000369e <xQueueGenericReceive+0x22>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800037e6:	ee fc ff ec 	ld.w	r12,r7[-20]
800037ea:	f0 1f 00 0e 	mcall	80003820 <xQueueGenericReceive+0x1a4>
			( void ) xTaskResumeAll();
800037ee:	f0 1f 00 0e 	mcall	80003824 <xQueueGenericReceive+0x1a8>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
800037f2:	30 08       	mov	r8,0
		}
	}
}
800037f4:	10 9c       	mov	r12,r8
800037f6:	2f 8d       	sub	sp,-32
800037f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800037fc:	80 00       	ld.sh	r0,r0[0x0]
800037fe:	30 fc       	mov	r12,15
80003800:	80 00       	ld.sh	r0,r0[0x0]
80003802:	39 08       	mov	r8,-112
80003804:	80 00       	ld.sh	r0,r0[0x0]
80003806:	42 cc       	lddsp	r12,sp[0xb0]
80003808:	80 00       	ld.sh	r0,r0[0x0]
8000380a:	31 18       	mov	r8,17
8000380c:	80 00       	ld.sh	r0,r0[0x0]
8000380e:	43 9c       	lddsp	r12,sp[0xe4]
80003810:	80 00       	ld.sh	r0,r0[0x0]
80003812:	3e c8       	mov	r8,-20
80003814:	80 00       	ld.sh	r0,r0[0x0]
80003816:	43 cc       	lddsp	r12,sp[0xf0]
80003818:	80 00       	ld.sh	r0,r0[0x0]
8000381a:	3a 44       	mov	r4,-92
8000381c:	80 00       	ld.sh	r0,r0[0x0]
8000381e:	42 4c       	lddsp	r12,sp[0x90]
80003820:	80 00       	ld.sh	r0,r0[0x0]
80003822:	39 74       	mov	r4,-105
80003824:	80 00       	ld.sh	r0,r0[0x0]
80003826:	3e e4       	mov	r4,-18

80003828 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80003828:	eb cd 40 80 	pushm	r7,lr
8000382c:	1a 97       	mov	r7,sp
8000382e:	20 3d       	sub	sp,12
80003830:	ef 4c ff fc 	st.w	r7[-4],r12
80003834:	ef 4b ff f8 	st.w	r7[-8],r11
80003838:	ef 4a ff f4 	st.w	r7[-12],r10
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000383c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003840:	71 08       	ld.w	r8,r8[0x40]
80003842:	58 08       	cp.w	r8,0
80003844:	c5 40       	breq	800038ec <prvCopyDataToQueue+0xc4>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80003846:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000384a:	58 08       	cp.w	r8,0
8000384c:	c2 61       	brne	80003898 <prvCopyDataToQueue+0x70>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000384e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003852:	71 09       	ld.w	r9,r8[0x40]
80003854:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003858:	70 28       	ld.w	r8,r8[0x8]
8000385a:	12 9a       	mov	r10,r9
8000385c:	ee fb ff f8 	ld.w	r11,r7[-8]
80003860:	10 9c       	mov	r12,r8
80003862:	f0 1f 00 29 	mcall	80003904 <prvCopyDataToQueue+0xdc>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80003866:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000386a:	70 29       	ld.w	r9,r8[0x8]
8000386c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003870:	71 08       	ld.w	r8,r8[0x40]
80003872:	10 09       	add	r9,r8
80003874:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003878:	91 29       	st.w	r8[0x8],r9
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000387a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000387e:	70 29       	ld.w	r9,r8[0x8]
80003880:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003884:	70 18       	ld.w	r8,r8[0x4]
80003886:	10 39       	cp.w	r9,r8
80003888:	c3 23       	brcs	800038ec <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000388a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000388e:	70 09       	ld.w	r9,r8[0x0]
80003890:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003894:	91 29       	st.w	r8[0x8],r9
80003896:	c2 b8       	rjmp	800038ec <prvCopyDataToQueue+0xc4>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80003898:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000389c:	71 09       	ld.w	r9,r8[0x40]
8000389e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038a2:	70 38       	ld.w	r8,r8[0xc]
800038a4:	12 9a       	mov	r10,r9
800038a6:	ee fb ff f8 	ld.w	r11,r7[-8]
800038aa:	10 9c       	mov	r12,r8
800038ac:	f0 1f 00 16 	mcall	80003904 <prvCopyDataToQueue+0xdc>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800038b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038b4:	70 39       	ld.w	r9,r8[0xc]
800038b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038ba:	71 08       	ld.w	r8,r8[0x40]
800038bc:	5c 38       	neg	r8
800038be:	10 09       	add	r9,r8
800038c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038c4:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800038c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038ca:	70 39       	ld.w	r9,r8[0xc]
800038cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038d0:	70 08       	ld.w	r8,r8[0x0]
800038d2:	10 39       	cp.w	r9,r8
800038d4:	c0 c2       	brcc	800038ec <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800038d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038da:	70 19       	ld.w	r9,r8[0x4]
800038dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038e0:	71 08       	ld.w	r8,r8[0x40]
800038e2:	5c 38       	neg	r8
800038e4:	10 09       	add	r9,r8
800038e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038ea:	91 39       	st.w	r8[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800038ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038f0:	70 e8       	ld.w	r8,r8[0x38]
800038f2:	f0 c9 ff ff 	sub	r9,r8,-1
800038f6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038fa:	91 e9       	st.w	r8[0x38],r9
}
800038fc:	2f dd       	sub	sp,-12
800038fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80003902:	00 00       	add	r0,r0
80003904:	80 00       	ld.sh	r0,r0[0x0]
80003906:	4c 50       	lddpc	r0,80003a18 <prvUnlockQueue+0xa4>

80003908 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80003908:	eb cd 40 80 	pushm	r7,lr
8000390c:	1a 97       	mov	r7,sp
8000390e:	20 2d       	sub	sp,8
80003910:	ef 4c ff fc 	st.w	r7[-4],r12
80003914:	ef 4b ff f8 	st.w	r7[-8],r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80003918:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000391c:	70 08       	ld.w	r8,r8[0x0]
8000391e:	58 08       	cp.w	r8,0
80003920:	c2 50       	breq	8000396a <prvCopyDataFromQueue+0x62>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80003922:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003926:	70 39       	ld.w	r9,r8[0xc]
80003928:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000392c:	71 08       	ld.w	r8,r8[0x40]
8000392e:	10 09       	add	r9,r8
80003930:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003934:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80003936:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000393a:	70 39       	ld.w	r9,r8[0xc]
8000393c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003940:	70 18       	ld.w	r8,r8[0x4]
80003942:	10 39       	cp.w	r9,r8
80003944:	c0 73       	brcs	80003952 <prvCopyDataFromQueue+0x4a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80003946:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000394a:	70 09       	ld.w	r9,r8[0x0]
8000394c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003950:	91 39       	st.w	r8[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80003952:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003956:	71 09       	ld.w	r9,r8[0x40]
80003958:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000395c:	70 38       	ld.w	r8,r8[0xc]
8000395e:	12 9a       	mov	r10,r9
80003960:	10 9b       	mov	r11,r8
80003962:	ee fc ff f8 	ld.w	r12,r7[-8]
80003966:	f0 1f 00 03 	mcall	80003970 <prvCopyDataFromQueue+0x68>
	}
}
8000396a:	2f ed       	sub	sp,-8
8000396c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003970:	80 00       	ld.sh	r0,r0[0x0]
80003972:	4c 50       	lddpc	r0,80003a84 <prvIsQueueFull+0x8>

80003974 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80003974:	eb cd 40 80 	pushm	r7,lr
80003978:	1a 97       	mov	r7,sp
8000397a:	20 1d       	sub	sp,4
8000397c:	ef 4c ff fc 	st.w	r7[-4],r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80003980:	f0 1f 00 2d 	mcall	80003a34 <prvUnlockQueue+0xc0>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80003984:	c1 a8       	rjmp	800039b8 <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80003986:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000398a:	70 98       	ld.w	r8,r8[0x24]
8000398c:	58 08       	cp.w	r8,0
8000398e:	c1 c0       	breq	800039c6 <prvUnlockQueue+0x52>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80003990:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003994:	2d c8       	sub	r8,-36
80003996:	10 9c       	mov	r12,r8
80003998:	f0 1f 00 28 	mcall	80003a38 <prvUnlockQueue+0xc4>
8000399c:	18 98       	mov	r8,r12
8000399e:	58 08       	cp.w	r8,0
800039a0:	c0 30       	breq	800039a6 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800039a2:	f0 1f 00 27 	mcall	80003a3c <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xTxLock );
800039a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039aa:	71 28       	ld.w	r8,r8[0x48]
800039ac:	f0 c9 00 01 	sub	r9,r8,1
800039b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039b4:	f1 49 00 48 	st.w	r8[72],r9
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800039b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039bc:	71 28       	ld.w	r8,r8[0x48]
800039be:	58 08       	cp.w	r8,0
800039c0:	fe 99 ff e3 	brgt	80003986 <prvUnlockQueue+0x12>
800039c4:	c0 28       	rjmp	800039c8 <prvUnlockQueue+0x54>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
800039c6:	d7 03       	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800039c8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039cc:	3f f9       	mov	r9,-1
800039ce:	f1 49 00 48 	st.w	r8[72],r9
	}
	taskEXIT_CRITICAL();
800039d2:	f0 1f 00 1c 	mcall	80003a40 <prvUnlockQueue+0xcc>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800039d6:	f0 1f 00 18 	mcall	80003a34 <prvUnlockQueue+0xc0>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800039da:	c1 a8       	rjmp	80003a0e <prvUnlockQueue+0x9a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800039dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039e0:	70 48       	ld.w	r8,r8[0x10]
800039e2:	58 08       	cp.w	r8,0
800039e4:	c1 c0       	breq	80003a1c <prvUnlockQueue+0xa8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800039e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039ea:	2f 08       	sub	r8,-16
800039ec:	10 9c       	mov	r12,r8
800039ee:	f0 1f 00 13 	mcall	80003a38 <prvUnlockQueue+0xc4>
800039f2:	18 98       	mov	r8,r12
800039f4:	58 08       	cp.w	r8,0
800039f6:	c0 30       	breq	800039fc <prvUnlockQueue+0x88>
				{
					vTaskMissedYield();
800039f8:	f0 1f 00 11 	mcall	80003a3c <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xRxLock );
800039fc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a00:	71 18       	ld.w	r8,r8[0x44]
80003a02:	f0 c9 00 01 	sub	r9,r8,1
80003a06:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a0a:	f1 49 00 44 	st.w	r8[68],r9
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80003a0e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a12:	71 18       	ld.w	r8,r8[0x44]
80003a14:	58 08       	cp.w	r8,0
80003a16:	fe 99 ff e3 	brgt	800039dc <prvUnlockQueue+0x68>
80003a1a:	c0 28       	rjmp	80003a1e <prvUnlockQueue+0xaa>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
80003a1c:	d7 03       	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80003a1e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a22:	3f f9       	mov	r9,-1
80003a24:	f1 49 00 44 	st.w	r8[68],r9
	}
	taskEXIT_CRITICAL();
80003a28:	f0 1f 00 06 	mcall	80003a40 <prvUnlockQueue+0xcc>
}
80003a2c:	2f fd       	sub	sp,-4
80003a2e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003a32:	00 00       	add	r0,r0
80003a34:	80 00       	ld.sh	r0,r0[0x0]
80003a36:	30 fc       	mov	r12,15
80003a38:	80 00       	ld.sh	r0,r0[0x0]
80003a3a:	42 cc       	lddsp	r12,sp[0xb0]
80003a3c:	80 00       	ld.sh	r0,r0[0x0]
80003a3e:	44 84       	lddsp	r4,sp[0x120]
80003a40:	80 00       	ld.sh	r0,r0[0x0]
80003a42:	31 18       	mov	r8,17

80003a44 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
80003a44:	eb cd 40 80 	pushm	r7,lr
80003a48:	1a 97       	mov	r7,sp
80003a4a:	20 2d       	sub	sp,8
80003a4c:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80003a50:	f0 1f 00 09 	mcall	80003a74 <prvIsQueueEmpty+0x30>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80003a54:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003a58:	70 e8       	ld.w	r8,r8[0x38]
80003a5a:	58 08       	cp.w	r8,0
80003a5c:	5f 08       	sreq	r8
80003a5e:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80003a62:	f0 1f 00 06 	mcall	80003a78 <prvIsQueueEmpty+0x34>

	return xReturn;
80003a66:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80003a6a:	10 9c       	mov	r12,r8
80003a6c:	2f ed       	sub	sp,-8
80003a6e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003a72:	00 00       	add	r0,r0
80003a74:	80 00       	ld.sh	r0,r0[0x0]
80003a76:	30 fc       	mov	r12,15
80003a78:	80 00       	ld.sh	r0,r0[0x0]
80003a7a:	31 18       	mov	r8,17

80003a7c <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
80003a7c:	eb cd 40 80 	pushm	r7,lr
80003a80:	1a 97       	mov	r7,sp
80003a82:	20 2d       	sub	sp,8
80003a84:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80003a88:	f0 1f 00 0a 	mcall	80003ab0 <prvIsQueueFull+0x34>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80003a8c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003a90:	70 e9       	ld.w	r9,r8[0x38]
80003a92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003a96:	70 f8       	ld.w	r8,r8[0x3c]
80003a98:	10 39       	cp.w	r9,r8
80003a9a:	5f 08       	sreq	r8
80003a9c:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80003aa0:	f0 1f 00 05 	mcall	80003ab4 <prvIsQueueFull+0x38>

	return xReturn;
80003aa4:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80003aa8:	10 9c       	mov	r12,r8
80003aaa:	2f ed       	sub	sp,-8
80003aac:	e3 cd 80 80 	ldm	sp++,r7,pc
80003ab0:	80 00       	ld.sh	r0,r0[0x0]
80003ab2:	30 fc       	mov	r12,15
80003ab4:	80 00       	ld.sh	r0,r0[0x0]
80003ab6:	31 18       	mov	r8,17
80003ab8:	49 44       	lddpc	r4,80003b08 <xTaskGenericCreate+0x48>
80003aba:	4c 45       	lddpc	r5,80003bc8 <xTaskGenericCreate+0x108>
80003abc:	00 00       	add	r0,r0
	...

80003ac0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80003ac0:	eb cd 40 c0 	pushm	r6-r7,lr
80003ac4:	1a 97       	mov	r7,sp
80003ac6:	20 8d       	sub	sp,32
80003ac8:	ee c6 ff f4 	sub	r6,r7,-12
80003acc:	ef 4c ff f0 	st.w	r7[-16],r12
80003ad0:	ef 4b ff ec 	st.w	r7[-20],r11
80003ad4:	ef 49 ff e4 	st.w	r7[-28],r9
80003ad8:	ef 48 ff e0 	st.w	r7[-32],r8
80003adc:	14 98       	mov	r8,r10
80003ade:	ef 58 ff e8 	st.h	r7[-24],r8
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
80003ae2:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80003ae6:	6c 1b       	ld.w	r11,r6[0x4]
80003ae8:	10 9c       	mov	r12,r8
80003aea:	f0 1f 00 5a 	mcall	80003c50 <xTaskGenericCreate+0x190>
80003aee:	18 98       	mov	r8,r12
80003af0:	ef 48 ff f8 	st.w	r7[-8],r8

	if( pxNewTCB != NULL )
80003af4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003af8:	58 08       	cp.w	r8,0
80003afa:	e0 80 00 92 	breq	80003c1e <xTaskGenericCreate+0x15e>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
80003afe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003b02:	70 c9       	ld.w	r9,r8[0x30]
80003b04:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80003b08:	20 18       	sub	r8,1
80003b0a:	a3 68       	lsl	r8,0x2
80003b0c:	f2 08 00 08 	add	r8,r9,r8
80003b10:	ef 48 ff fc 	st.w	r7[-4],r8
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80003b14:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b18:	e0 18 ff fc 	andl	r8,0xfffc
80003b1c:	ef 48 ff fc 	st.w	r7[-4],r8
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
80003b20:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80003b24:	6c 29       	ld.w	r9,r6[0x8]
80003b26:	ee fa ff e0 	ld.w	r10,r7[-32]
80003b2a:	ee fb ff ec 	ld.w	r11,r7[-20]
80003b2e:	ee fc ff f8 	ld.w	r12,r7[-8]
80003b32:	f0 1f 00 49 	mcall	80003c54 <xTaskGenericCreate+0x194>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80003b36:	ee fa ff e4 	ld.w	r10,r7[-28]
80003b3a:	ee fb ff f0 	ld.w	r11,r7[-16]
80003b3e:	ee fc ff fc 	ld.w	r12,r7[-4]
80003b42:	f0 1f 00 46 	mcall	80003c58 <xTaskGenericCreate+0x198>
80003b46:	18 98       	mov	r8,r12
80003b48:	10 99       	mov	r9,r8
80003b4a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003b4e:	91 09       	st.w	r8[0x0],r9
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
80003b50:	6c 08       	ld.w	r8,r6[0x0]
80003b52:	58 08       	cp.w	r8,0
80003b54:	c0 50       	breq	80003b5e <xTaskGenericCreate+0x9e>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80003b56:	6c 08       	ld.w	r8,r6[0x0]
80003b58:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003b5c:	91 09       	st.w	r8[0x0],r9
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80003b5e:	f0 1f 00 40 	mcall	80003c5c <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
80003b62:	4c 08       	lddpc	r8,80003c60 <xTaskGenericCreate+0x1a0>
80003b64:	70 08       	ld.w	r8,r8[0x0]
80003b66:	f0 c9 ff ff 	sub	r9,r8,-1
80003b6a:	4b e8       	lddpc	r8,80003c60 <xTaskGenericCreate+0x1a0>
80003b6c:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80003b6e:	4b e8       	lddpc	r8,80003c64 <xTaskGenericCreate+0x1a4>
80003b70:	70 08       	ld.w	r8,r8[0x0]
80003b72:	58 08       	cp.w	r8,0
80003b74:	c0 c1       	brne	80003b8c <xTaskGenericCreate+0xcc>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80003b76:	4b c8       	lddpc	r8,80003c64 <xTaskGenericCreate+0x1a4>
80003b78:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003b7c:	91 09       	st.w	r8[0x0],r9

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80003b7e:	4b 98       	lddpc	r8,80003c60 <xTaskGenericCreate+0x1a0>
80003b80:	70 08       	ld.w	r8,r8[0x0]
80003b82:	58 18       	cp.w	r8,1
80003b84:	c1 41       	brne	80003bac <xTaskGenericCreate+0xec>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
80003b86:	f0 1f 00 39 	mcall	80003c68 <xTaskGenericCreate+0x1a8>
80003b8a:	c1 18       	rjmp	80003bac <xTaskGenericCreate+0xec>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80003b8c:	4b 88       	lddpc	r8,80003c6c <xTaskGenericCreate+0x1ac>
80003b8e:	70 08       	ld.w	r8,r8[0x0]
80003b90:	58 08       	cp.w	r8,0
80003b92:	c0 d1       	brne	80003bac <xTaskGenericCreate+0xec>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80003b94:	4b 48       	lddpc	r8,80003c64 <xTaskGenericCreate+0x1a4>
80003b96:	70 08       	ld.w	r8,r8[0x0]
80003b98:	70 b9       	ld.w	r9,r8[0x2c]
80003b9a:	ee f8 ff e0 	ld.w	r8,r7[-32]
80003b9e:	10 39       	cp.w	r9,r8
80003ba0:	e0 8b 00 06 	brhi	80003bac <xTaskGenericCreate+0xec>
					{
						pxCurrentTCB = pxNewTCB;
80003ba4:	4b 08       	lddpc	r8,80003c64 <xTaskGenericCreate+0x1a4>
80003ba6:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003baa:	91 09       	st.w	r8[0x0],r9
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80003bac:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003bb0:	70 b9       	ld.w	r9,r8[0x2c]
80003bb2:	4b 08       	lddpc	r8,80003c70 <xTaskGenericCreate+0x1b0>
80003bb4:	70 08       	ld.w	r8,r8[0x0]
80003bb6:	10 39       	cp.w	r9,r8
80003bb8:	e0 88 00 07 	brls	80003bc6 <xTaskGenericCreate+0x106>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80003bbc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003bc0:	70 b9       	ld.w	r9,r8[0x2c]
80003bc2:	4a c8       	lddpc	r8,80003c70 <xTaskGenericCreate+0x1b0>
80003bc4:	91 09       	st.w	r8[0x0],r9
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80003bc6:	4a c8       	lddpc	r8,80003c74 <xTaskGenericCreate+0x1b4>
80003bc8:	70 08       	ld.w	r8,r8[0x0]
80003bca:	f0 c9 ff ff 	sub	r9,r8,-1
80003bce:	4a a8       	lddpc	r8,80003c74 <xTaskGenericCreate+0x1b4>
80003bd0:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80003bd2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003bd6:	70 b9       	ld.w	r9,r8[0x2c]
80003bd8:	4a 88       	lddpc	r8,80003c78 <xTaskGenericCreate+0x1b8>
80003bda:	70 08       	ld.w	r8,r8[0x0]
80003bdc:	10 39       	cp.w	r9,r8
80003bde:	e0 88 00 07 	brls	80003bec <xTaskGenericCreate+0x12c>
80003be2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003be6:	70 b9       	ld.w	r9,r8[0x2c]
80003be8:	4a 48       	lddpc	r8,80003c78 <xTaskGenericCreate+0x1b8>
80003bea:	91 09       	st.w	r8[0x0],r9
80003bec:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003bf0:	f0 ca ff fc 	sub	r10,r8,-4
80003bf4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003bf8:	70 b9       	ld.w	r9,r8[0x2c]
80003bfa:	12 98       	mov	r8,r9
80003bfc:	a3 68       	lsl	r8,0x2
80003bfe:	12 08       	add	r8,r9
80003c00:	a3 68       	lsl	r8,0x2
80003c02:	10 99       	mov	r9,r8
80003c04:	49 e8       	lddpc	r8,80003c7c <xTaskGenericCreate+0x1bc>
80003c06:	f2 08 00 08 	add	r8,r9,r8
80003c0a:	14 9b       	mov	r11,r10
80003c0c:	10 9c       	mov	r12,r8
80003c0e:	f0 1f 00 1d 	mcall	80003c80 <xTaskGenericCreate+0x1c0>

			xReturn = pdPASS;
80003c12:	30 18       	mov	r8,1
80003c14:	ef 48 ff f4 	st.w	r7[-12],r8
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80003c18:	f0 1f 00 1b 	mcall	80003c84 <xTaskGenericCreate+0x1c4>
80003c1c:	c0 48       	rjmp	80003c24 <xTaskGenericCreate+0x164>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
80003c1e:	3f f8       	mov	r8,-1
80003c20:	ef 48 ff f4 	st.w	r7[-12],r8
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
80003c24:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003c28:	58 18       	cp.w	r8,1
80003c2a:	c0 d1       	brne	80003c44 <xTaskGenericCreate+0x184>
	{
		if( xSchedulerRunning != pdFALSE )
80003c2c:	49 08       	lddpc	r8,80003c6c <xTaskGenericCreate+0x1ac>
80003c2e:	70 08       	ld.w	r8,r8[0x0]
80003c30:	58 08       	cp.w	r8,0
80003c32:	c0 90       	breq	80003c44 <xTaskGenericCreate+0x184>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80003c34:	48 c8       	lddpc	r8,80003c64 <xTaskGenericCreate+0x1a4>
80003c36:	70 08       	ld.w	r8,r8[0x0]
80003c38:	70 b9       	ld.w	r9,r8[0x2c]
80003c3a:	ee f8 ff e0 	ld.w	r8,r7[-32]
80003c3e:	10 39       	cp.w	r9,r8
80003c40:	c0 22       	brcc	80003c44 <xTaskGenericCreate+0x184>
			{
				portYIELD_WITHIN_API();
80003c42:	d7 33       	scall
			}
		}
	}

	return xReturn;
80003c44:	ee f8 ff f4 	ld.w	r8,r7[-12]
}
80003c48:	10 9c       	mov	r12,r8
80003c4a:	2f 8d       	sub	sp,-32
80003c4c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003c50:	80 00       	ld.sh	r0,r0[0x0]
80003c52:	47 0c       	lddsp	r12,sp[0x1c0]
80003c54:	80 00       	ld.sh	r0,r0[0x0]
80003c56:	44 c4       	lddsp	r4,sp[0x130]
80003c58:	80 00       	ld.sh	r0,r0[0x0]
80003c5a:	31 44       	mov	r4,20
80003c5c:	80 00       	ld.sh	r0,r0[0x0]
80003c5e:	30 fc       	mov	r12,15
80003c60:	00 00       	add	r0,r0
80003c62:	07 34       	ld.ub	r4,r3++
80003c64:	00 00       	add	r0,r0
80003c66:	06 20       	rsub	r0,r3
80003c68:	80 00       	ld.sh	r0,r0[0x0]
80003c6a:	45 60       	lddsp	r0,sp[0x158]
80003c6c:	00 00       	add	r0,r0
80003c6e:	07 44       	ld.w	r4,--r3
80003c70:	00 00       	add	r0,r0
80003c72:	07 3c       	ld.ub	r12,r3++
80003c74:	00 00       	add	r0,r0
80003c76:	07 58       	ld.sh	r8,--r3
80003c78:	00 00       	add	r0,r0
80003c7a:	07 40       	ld.w	r0,--r3
80003c7c:	00 00       	add	r0,r0
80003c7e:	06 24       	rsub	r4,r3
80003c80:	80 00       	ld.sh	r0,r0[0x0]
80003c82:	2d d2       	sub	r2,-35
80003c84:	80 00       	ld.sh	r0,r0[0x0]
80003c86:	31 18       	mov	r8,17

80003c88 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
80003c88:	eb cd 40 80 	pushm	r7,lr
80003c8c:	1a 97       	mov	r7,sp
80003c8e:	20 2d       	sub	sp,8
80003c90:	ef 4c ff f8 	st.w	r7[-8],r12
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
80003c94:	f0 1f 00 24 	mcall	80003d24 <vTaskSuspend+0x9c>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
80003c98:	4a 48       	lddpc	r8,80003d28 <vTaskSuspend+0xa0>
80003c9a:	70 08       	ld.w	r8,r8[0x0]
80003c9c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003ca0:	10 39       	cp.w	r9,r8
80003ca2:	c0 41       	brne	80003caa <vTaskSuspend+0x22>
			{
				pxTaskToSuspend = NULL;
80003ca4:	30 08       	mov	r8,0
80003ca6:	ef 48 ff f8 	st.w	r7[-8],r8
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
80003caa:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003cae:	58 08       	cp.w	r8,0
80003cb0:	c0 41       	brne	80003cb8 <vTaskSuspend+0x30>
80003cb2:	49 e8       	lddpc	r8,80003d28 <vTaskSuspend+0xa0>
80003cb4:	70 08       	ld.w	r8,r8[0x0]
80003cb6:	c0 38       	rjmp	80003cbc <vTaskSuspend+0x34>
80003cb8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003cbc:	ef 48 ff fc 	st.w	r7[-4],r8

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
80003cc0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003cc4:	2f c8       	sub	r8,-4
80003cc6:	10 9c       	mov	r12,r8
80003cc8:	f0 1f 00 19 	mcall	80003d2c <vTaskSuspend+0xa4>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
80003ccc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003cd0:	70 a8       	ld.w	r8,r8[0x28]
80003cd2:	58 08       	cp.w	r8,0
80003cd4:	c0 70       	breq	80003ce2 <vTaskSuspend+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
80003cd6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003cda:	2e 88       	sub	r8,-24
80003cdc:	10 9c       	mov	r12,r8
80003cde:	f0 1f 00 14 	mcall	80003d2c <vTaskSuspend+0xa4>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
80003ce2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ce6:	2f c8       	sub	r8,-4
80003ce8:	10 9b       	mov	r11,r8
80003cea:	49 2c       	lddpc	r12,80003d30 <vTaskSuspend+0xa8>
80003cec:	f0 1f 00 12 	mcall	80003d34 <vTaskSuspend+0xac>
		}
		taskEXIT_CRITICAL();
80003cf0:	f0 1f 00 12 	mcall	80003d38 <vTaskSuspend+0xb0>

		if( ( void * ) pxTaskToSuspend == NULL )
80003cf4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003cf8:	58 08       	cp.w	r8,0
80003cfa:	c1 11       	brne	80003d1c <vTaskSuspend+0x94>
		{
			if( xSchedulerRunning != pdFALSE )
80003cfc:	49 08       	lddpc	r8,80003d3c <vTaskSuspend+0xb4>
80003cfe:	70 08       	ld.w	r8,r8[0x0]
80003d00:	58 08       	cp.w	r8,0
80003d02:	c0 30       	breq	80003d08 <vTaskSuspend+0x80>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
80003d04:	d7 33       	scall
80003d06:	c0 b8       	rjmp	80003d1c <vTaskSuspend+0x94>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1U )
80003d08:	48 e8       	lddpc	r8,80003d40 <vTaskSuspend+0xb8>
80003d0a:	70 08       	ld.w	r8,r8[0x0]
80003d0c:	58 18       	cp.w	r8,1
80003d0e:	c0 51       	brne	80003d18 <vTaskSuspend+0x90>
				{
					/* No other tasks are defined, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
80003d10:	48 68       	lddpc	r8,80003d28 <vTaskSuspend+0xa0>
80003d12:	30 09       	mov	r9,0
80003d14:	91 09       	st.w	r8[0x0],r9
80003d16:	c0 38       	rjmp	80003d1c <vTaskSuspend+0x94>
				}
				else
				{
					vTaskSwitchContext();
80003d18:	f0 1f 00 0b 	mcall	80003d44 <vTaskSuspend+0xbc>
				}
			}
		}
	}
80003d1c:	2f ed       	sub	sp,-8
80003d1e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d22:	00 00       	add	r0,r0
80003d24:	80 00       	ld.sh	r0,r0[0x0]
80003d26:	30 fc       	mov	r12,15
80003d28:	00 00       	add	r0,r0
80003d2a:	06 20       	rsub	r0,r3
80003d2c:	80 00       	ld.sh	r0,r0[0x0]
80003d2e:	2e e6       	sub	r6,-18
80003d30:	00 00       	add	r0,r0
80003d32:	07 20       	ld.uh	r0,r3++
80003d34:	80 00       	ld.sh	r0,r0[0x0]
80003d36:	2d d2       	sub	r2,-35
80003d38:	80 00       	ld.sh	r0,r0[0x0]
80003d3a:	31 18       	mov	r8,17
80003d3c:	00 00       	add	r0,r0
80003d3e:	07 44       	ld.w	r4,--r3
80003d40:	00 00       	add	r0,r0
80003d42:	07 34       	ld.ub	r4,r3++
80003d44:	80 00       	ld.sh	r0,r0[0x0]
80003d46:	41 9c       	lddsp	r12,sp[0x64]

80003d48 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
80003d48:	eb cd 40 80 	pushm	r7,lr
80003d4c:	1a 97       	mov	r7,sp
80003d4e:	20 3d       	sub	sp,12
80003d50:	ef 4c ff f4 	st.w	r7[-12],r12
	portBASE_TYPE xReturn = pdFALSE;
80003d54:	30 08       	mov	r8,0
80003d56:	ef 48 ff f8 	st.w	r7[-8],r8
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
80003d5a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003d5e:	ef 48 ff fc 	st.w	r7[-4],r8
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
80003d62:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d66:	70 59       	ld.w	r9,r8[0x14]
80003d68:	48 c8       	lddpc	r8,80003d98 <xTaskIsTaskSuspended+0x50>
80003d6a:	10 39       	cp.w	r9,r8
80003d6c:	c0 f1       	brne	80003d8a <xTaskIsTaskSuspended+0x42>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
80003d6e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d72:	70 a9       	ld.w	r9,r8[0x28]
80003d74:	48 a8       	lddpc	r8,80003d9c <xTaskIsTaskSuspended+0x54>
80003d76:	10 39       	cp.w	r9,r8
80003d78:	c0 90       	breq	80003d8a <xTaskIsTaskSuspended+0x42>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
80003d7a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d7e:	70 a8       	ld.w	r8,r8[0x28]
80003d80:	58 08       	cp.w	r8,0
80003d82:	c0 41       	brne	80003d8a <xTaskIsTaskSuspended+0x42>
				{
					xReturn = pdTRUE;
80003d84:	30 18       	mov	r8,1
80003d86:	ef 48 ff f8 	st.w	r7[-8],r8
				}
			}
		}

		return xReturn;
80003d8a:	ee f8 ff f8 	ld.w	r8,r7[-8]
	}
80003d8e:	10 9c       	mov	r12,r8
80003d90:	2f dd       	sub	sp,-12
80003d92:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d96:	00 00       	add	r0,r0
80003d98:	00 00       	add	r0,r0
80003d9a:	07 20       	ld.uh	r0,r3++
80003d9c:	00 00       	add	r0,r0
80003d9e:	06 f4       	st.b	--r3,r4

80003da0 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
80003da0:	eb cd 40 80 	pushm	r7,lr
80003da4:	1a 97       	mov	r7,sp
80003da6:	20 2d       	sub	sp,8
80003da8:	ef 4c ff f8 	st.w	r7[-8],r12
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
80003dac:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003db0:	ef 48 ff fc 	st.w	r7[-4],r8

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
80003db4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003db8:	58 08       	cp.w	r8,0
80003dba:	c4 10       	breq	80003e3c <vTaskResume+0x9c>
80003dbc:	4a 28       	lddpc	r8,80003e44 <vTaskResume+0xa4>
80003dbe:	70 08       	ld.w	r8,r8[0x0]
80003dc0:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003dc4:	10 39       	cp.w	r9,r8
80003dc6:	c3 b0       	breq	80003e3c <vTaskResume+0x9c>
		{
			taskENTER_CRITICAL();
80003dc8:	f0 1f 00 20 	mcall	80003e48 <vTaskResume+0xa8>
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
80003dcc:	ee fc ff fc 	ld.w	r12,r7[-4]
80003dd0:	f0 1f 00 1f 	mcall	80003e4c <vTaskResume+0xac>
80003dd4:	18 98       	mov	r8,r12
80003dd6:	58 18       	cp.w	r8,1
80003dd8:	c3 01       	brne	80003e38 <vTaskResume+0x98>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
80003dda:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003dde:	2f c8       	sub	r8,-4
80003de0:	10 9c       	mov	r12,r8
80003de2:	f0 1f 00 1c 	mcall	80003e50 <vTaskResume+0xb0>
					prvAddTaskToReadyQueue( pxTCB );
80003de6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003dea:	70 b9       	ld.w	r9,r8[0x2c]
80003dec:	49 a8       	lddpc	r8,80003e54 <vTaskResume+0xb4>
80003dee:	70 08       	ld.w	r8,r8[0x0]
80003df0:	10 39       	cp.w	r9,r8
80003df2:	e0 88 00 07 	brls	80003e00 <vTaskResume+0x60>
80003df6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003dfa:	70 b9       	ld.w	r9,r8[0x2c]
80003dfc:	49 68       	lddpc	r8,80003e54 <vTaskResume+0xb4>
80003dfe:	91 09       	st.w	r8[0x0],r9
80003e00:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e04:	f0 ca ff fc 	sub	r10,r8,-4
80003e08:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e0c:	70 b9       	ld.w	r9,r8[0x2c]
80003e0e:	12 98       	mov	r8,r9
80003e10:	a3 68       	lsl	r8,0x2
80003e12:	12 08       	add	r8,r9
80003e14:	a3 68       	lsl	r8,0x2
80003e16:	10 99       	mov	r9,r8
80003e18:	49 08       	lddpc	r8,80003e58 <vTaskResume+0xb8>
80003e1a:	f2 08 00 08 	add	r8,r9,r8
80003e1e:	14 9b       	mov	r11,r10
80003e20:	10 9c       	mov	r12,r8
80003e22:	f0 1f 00 0f 	mcall	80003e5c <vTaskResume+0xbc>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80003e26:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e2a:	70 b9       	ld.w	r9,r8[0x2c]
80003e2c:	48 68       	lddpc	r8,80003e44 <vTaskResume+0xa4>
80003e2e:	70 08       	ld.w	r8,r8[0x0]
80003e30:	70 b8       	ld.w	r8,r8[0x2c]
80003e32:	10 39       	cp.w	r9,r8
80003e34:	c0 23       	brcs	80003e38 <vTaskResume+0x98>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
80003e36:	d7 33       	scall
					}
				}
			}
			taskEXIT_CRITICAL();
80003e38:	f0 1f 00 0a 	mcall	80003e60 <vTaskResume+0xc0>
		}
	}
80003e3c:	2f ed       	sub	sp,-8
80003e3e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e42:	00 00       	add	r0,r0
80003e44:	00 00       	add	r0,r0
80003e46:	06 20       	rsub	r0,r3
80003e48:	80 00       	ld.sh	r0,r0[0x0]
80003e4a:	30 fc       	mov	r12,15
80003e4c:	80 00       	ld.sh	r0,r0[0x0]
80003e4e:	3d 48       	mov	r8,-44
80003e50:	80 00       	ld.sh	r0,r0[0x0]
80003e52:	2e e6       	sub	r6,-18
80003e54:	00 00       	add	r0,r0
80003e56:	07 40       	ld.w	r0,--r3
80003e58:	00 00       	add	r0,r0
80003e5a:	06 24       	rsub	r4,r3
80003e5c:	80 00       	ld.sh	r0,r0[0x0]
80003e5e:	2d d2       	sub	r2,-35
80003e60:	80 00       	ld.sh	r0,r0[0x0]
80003e62:	31 18       	mov	r8,17

80003e64 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80003e64:	eb cd 40 80 	pushm	r7,lr
80003e68:	1a 97       	mov	r7,sp
80003e6a:	20 1d       	sub	sp,4
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80003e6c:	49 1b       	lddpc	r11,80003eb0 <vTaskStartScheduler+0x4c>
80003e6e:	30 08       	mov	r8,0
80003e70:	1a d8       	st.w	--sp,r8
80003e72:	30 08       	mov	r8,0
80003e74:	1a d8       	st.w	--sp,r8
80003e76:	30 08       	mov	r8,0
80003e78:	1a d8       	st.w	--sp,r8
80003e7a:	30 08       	mov	r8,0
80003e7c:	30 09       	mov	r9,0
80003e7e:	e0 6a 01 00 	mov	r10,256
80003e82:	48 dc       	lddpc	r12,80003eb4 <vTaskStartScheduler+0x50>
80003e84:	f0 1f 00 0d 	mcall	80003eb8 <vTaskStartScheduler+0x54>
80003e88:	2f dd       	sub	sp,-12
80003e8a:	18 98       	mov	r8,r12
80003e8c:	ef 48 ff fc 	st.w	r7[-4],r8
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80003e90:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e94:	58 18       	cp.w	r8,1
80003e96:	c0 a1       	brne	80003eaa <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80003e98:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80003e9a:	48 98       	lddpc	r8,80003ebc <vTaskStartScheduler+0x58>
80003e9c:	30 19       	mov	r9,1
80003e9e:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80003ea0:	48 88       	lddpc	r8,80003ec0 <vTaskStartScheduler+0x5c>
80003ea2:	30 09       	mov	r9,0
80003ea4:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80003ea6:	f0 1f 00 08 	mcall	80003ec4 <vTaskStartScheduler+0x60>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
80003eaa:	2f fd       	sub	sp,-4
80003eac:	e3 cd 80 80 	ldm	sp++,r7,pc
80003eb0:	80 00       	ld.sh	r0,r0[0x0]
80003eb2:	3a b8       	mov	r8,-85
80003eb4:	80 00       	ld.sh	r0,r0[0x0]
80003eb6:	44 98       	lddsp	r8,sp[0x124]
80003eb8:	80 00       	ld.sh	r0,r0[0x0]
80003eba:	3a c0       	mov	r0,-84
80003ebc:	00 00       	add	r0,r0
80003ebe:	07 44       	ld.w	r4,--r3
80003ec0:	00 00       	add	r0,r0
80003ec2:	07 38       	ld.ub	r8,r3++
80003ec4:	80 00       	ld.sh	r0,r0[0x0]
80003ec6:	32 ec       	mov	r12,46

80003ec8 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
80003ec8:	eb cd 40 80 	pushm	r7,lr
80003ecc:	1a 97       	mov	r7,sp
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80003ece:	48 58       	lddpc	r8,80003ee0 <vTaskSuspendAll+0x18>
80003ed0:	70 08       	ld.w	r8,r8[0x0]
80003ed2:	f0 c9 ff ff 	sub	r9,r8,-1
80003ed6:	48 38       	lddpc	r8,80003ee0 <vTaskSuspendAll+0x18>
80003ed8:	91 09       	st.w	r8[0x0],r9
}
80003eda:	e3 cd 80 80 	ldm	sp++,r7,pc
80003ede:	00 00       	add	r0,r0
80003ee0:	00 00       	add	r0,r0
80003ee2:	07 48       	ld.w	r8,--r3

80003ee4 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80003ee4:	eb cd 40 c0 	pushm	r6-r7,lr
80003ee8:	1a 97       	mov	r7,sp
80003eea:	20 2d       	sub	sp,8
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
80003eec:	30 08       	mov	r8,0
80003eee:	ef 48 ff f8 	st.w	r7[-8],r8
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80003ef2:	f0 1f 00 3a 	mcall	80003fd8 <xTaskResumeAll+0xf4>
	{
		--uxSchedulerSuspended;
80003ef6:	4b a8       	lddpc	r8,80003fdc <xTaskResumeAll+0xf8>
80003ef8:	70 08       	ld.w	r8,r8[0x0]
80003efa:	f0 c9 00 01 	sub	r9,r8,1
80003efe:	4b 88       	lddpc	r8,80003fdc <xTaskResumeAll+0xf8>
80003f00:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80003f02:	4b 78       	lddpc	r8,80003fdc <xTaskResumeAll+0xf8>
80003f04:	70 08       	ld.w	r8,r8[0x0]
80003f06:	58 08       	cp.w	r8,0
80003f08:	c5 f1       	brne	80003fc6 <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80003f0a:	4b 68       	lddpc	r8,80003fe0 <xTaskResumeAll+0xfc>
80003f0c:	70 08       	ld.w	r8,r8[0x0]
80003f0e:	58 08       	cp.w	r8,0
80003f10:	c5 b0       	breq	80003fc6 <xTaskResumeAll+0xe2>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
80003f12:	30 08       	mov	r8,0
80003f14:	ef 48 ff fc 	st.w	r7[-4],r8

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80003f18:	c3 08       	rjmp	80003f78 <xTaskResumeAll+0x94>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80003f1a:	4b 38       	lddpc	r8,80003fe4 <xTaskResumeAll+0x100>
80003f1c:	70 38       	ld.w	r8,r8[0xc]
80003f1e:	70 38       	ld.w	r8,r8[0xc]
80003f20:	10 96       	mov	r6,r8
					vListRemove( &( pxTCB->xEventListItem ) );
80003f22:	ec c8 ff e8 	sub	r8,r6,-24
80003f26:	10 9c       	mov	r12,r8
80003f28:	f0 1f 00 30 	mcall	80003fe8 <xTaskResumeAll+0x104>
					vListRemove( &( pxTCB->xGenericListItem ) );
80003f2c:	ec c8 ff fc 	sub	r8,r6,-4
80003f30:	10 9c       	mov	r12,r8
80003f32:	f0 1f 00 2e 	mcall	80003fe8 <xTaskResumeAll+0x104>
					prvAddTaskToReadyQueue( pxTCB );
80003f36:	6c b9       	ld.w	r9,r6[0x2c]
80003f38:	4a d8       	lddpc	r8,80003fec <xTaskResumeAll+0x108>
80003f3a:	70 08       	ld.w	r8,r8[0x0]
80003f3c:	10 39       	cp.w	r9,r8
80003f3e:	e0 88 00 05 	brls	80003f48 <xTaskResumeAll+0x64>
80003f42:	6c b9       	ld.w	r9,r6[0x2c]
80003f44:	4a a8       	lddpc	r8,80003fec <xTaskResumeAll+0x108>
80003f46:	91 09       	st.w	r8[0x0],r9
80003f48:	ec ca ff fc 	sub	r10,r6,-4
80003f4c:	6c b9       	ld.w	r9,r6[0x2c]
80003f4e:	12 98       	mov	r8,r9
80003f50:	a3 68       	lsl	r8,0x2
80003f52:	12 08       	add	r8,r9
80003f54:	a3 68       	lsl	r8,0x2
80003f56:	10 99       	mov	r9,r8
80003f58:	4a 68       	lddpc	r8,80003ff0 <xTaskResumeAll+0x10c>
80003f5a:	f2 08 00 08 	add	r8,r9,r8
80003f5e:	14 9b       	mov	r11,r10
80003f60:	10 9c       	mov	r12,r8
80003f62:	f0 1f 00 25 	mcall	80003ff4 <xTaskResumeAll+0x110>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80003f66:	6c b9       	ld.w	r9,r6[0x2c]
80003f68:	4a 48       	lddpc	r8,80003ff8 <xTaskResumeAll+0x114>
80003f6a:	70 08       	ld.w	r8,r8[0x0]
80003f6c:	70 b8       	ld.w	r8,r8[0x2c]
80003f6e:	10 39       	cp.w	r9,r8
80003f70:	c0 43       	brcs	80003f78 <xTaskResumeAll+0x94>
					{
						xYieldRequired = pdTRUE;
80003f72:	30 18       	mov	r8,1
80003f74:	ef 48 ff fc 	st.w	r7[-4],r8
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80003f78:	49 b8       	lddpc	r8,80003fe4 <xTaskResumeAll+0x100>
80003f7a:	70 08       	ld.w	r8,r8[0x0]
80003f7c:	58 08       	cp.w	r8,0
80003f7e:	cc e1       	brne	80003f1a <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80003f80:	49 f8       	lddpc	r8,80003ffc <xTaskResumeAll+0x118>
80003f82:	70 08       	ld.w	r8,r8[0x0]
80003f84:	58 08       	cp.w	r8,0
80003f86:	c1 10       	breq	80003fa8 <xTaskResumeAll+0xc4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80003f88:	c0 98       	rjmp	80003f9a <xTaskResumeAll+0xb6>
					{
						vTaskIncrementTick();
80003f8a:	f0 1f 00 1e 	mcall	80004000 <xTaskResumeAll+0x11c>
						--uxMissedTicks;
80003f8e:	49 c8       	lddpc	r8,80003ffc <xTaskResumeAll+0x118>
80003f90:	70 08       	ld.w	r8,r8[0x0]
80003f92:	f0 c9 00 01 	sub	r9,r8,1
80003f96:	49 a8       	lddpc	r8,80003ffc <xTaskResumeAll+0x118>
80003f98:	91 09       	st.w	r8[0x0],r9
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80003f9a:	49 98       	lddpc	r8,80003ffc <xTaskResumeAll+0x118>
80003f9c:	70 08       	ld.w	r8,r8[0x0]
80003f9e:	58 08       	cp.w	r8,0
80003fa0:	cf 51       	brne	80003f8a <xTaskResumeAll+0xa6>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
80003fa2:	30 18       	mov	r8,1
80003fa4:	ef 48 ff fc 	st.w	r7[-4],r8
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80003fa8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003fac:	58 18       	cp.w	r8,1
80003fae:	c0 50       	breq	80003fb8 <xTaskResumeAll+0xd4>
80003fb0:	49 58       	lddpc	r8,80004004 <xTaskResumeAll+0x120>
80003fb2:	70 08       	ld.w	r8,r8[0x0]
80003fb4:	58 18       	cp.w	r8,1
80003fb6:	c0 81       	brne	80003fc6 <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
80003fb8:	30 18       	mov	r8,1
80003fba:	ef 48 ff f8 	st.w	r7[-8],r8
					xMissedYield = pdFALSE;
80003fbe:	49 28       	lddpc	r8,80004004 <xTaskResumeAll+0x120>
80003fc0:	30 09       	mov	r9,0
80003fc2:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80003fc4:	d7 33       	scall
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80003fc6:	f0 1f 00 11 	mcall	80004008 <xTaskResumeAll+0x124>

	return xAlreadyYielded;
80003fca:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80003fce:	10 9c       	mov	r12,r8
80003fd0:	2f ed       	sub	sp,-8
80003fd2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003fd6:	00 00       	add	r0,r0
80003fd8:	80 00       	ld.sh	r0,r0[0x0]
80003fda:	30 fc       	mov	r12,15
80003fdc:	00 00       	add	r0,r0
80003fde:	07 48       	ld.w	r8,--r3
80003fe0:	00 00       	add	r0,r0
80003fe2:	07 34       	ld.ub	r4,r3++
80003fe4:	00 00       	add	r0,r0
80003fe6:	06 f4       	st.b	--r3,r4
80003fe8:	80 00       	ld.sh	r0,r0[0x0]
80003fea:	2e e6       	sub	r6,-18
80003fec:	00 00       	add	r0,r0
80003fee:	07 40       	ld.w	r0,--r3
80003ff0:	00 00       	add	r0,r0
80003ff2:	06 24       	rsub	r4,r3
80003ff4:	80 00       	ld.sh	r0,r0[0x0]
80003ff6:	2d d2       	sub	r2,-35
80003ff8:	00 00       	add	r0,r0
80003ffa:	06 20       	rsub	r0,r3
80003ffc:	00 00       	add	r0,r0
80003ffe:	07 4c       	ld.w	r12,--r3
80004000:	80 00       	ld.sh	r0,r0[0x0]
80004002:	40 3c       	lddsp	r12,sp[0xc]
80004004:	00 00       	add	r0,r0
80004006:	07 50       	ld.sh	r0,--r3
80004008:	80 00       	ld.sh	r0,r0[0x0]
8000400a:	31 18       	mov	r8,17

8000400c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
8000400c:	eb cd 40 80 	pushm	r7,lr
80004010:	1a 97       	mov	r7,sp
80004012:	20 1d       	sub	sp,4
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80004014:	f0 1f 00 07 	mcall	80004030 <xTaskGetTickCount+0x24>
	{
		xTicks = xTickCount;
80004018:	48 78       	lddpc	r8,80004034 <xTaskGetTickCount+0x28>
8000401a:	70 08       	ld.w	r8,r8[0x0]
8000401c:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	taskEXIT_CRITICAL();
80004020:	f0 1f 00 06 	mcall	80004038 <xTaskGetTickCount+0x2c>

	return xTicks;
80004024:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80004028:	10 9c       	mov	r12,r8
8000402a:	2f fd       	sub	sp,-4
8000402c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004030:	80 00       	ld.sh	r0,r0[0x0]
80004032:	30 fc       	mov	r12,15
80004034:	00 00       	add	r0,r0
80004036:	07 38       	ld.ub	r8,r3++
80004038:	80 00       	ld.sh	r0,r0[0x0]
8000403a:	31 18       	mov	r8,17

8000403c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
8000403c:	eb cd 40 80 	pushm	r7,lr
80004040:	1a 97       	mov	r7,sp
80004042:	20 3d       	sub	sp,12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80004044:	4c b8       	lddpc	r8,80004170 <vTaskIncrementTick+0x134>
80004046:	70 08       	ld.w	r8,r8[0x0]
80004048:	58 08       	cp.w	r8,0
8000404a:	e0 81 00 89 	brne	8000415c <vTaskIncrementTick+0x120>
	{
		++xTickCount;
8000404e:	4c a8       	lddpc	r8,80004174 <vTaskIncrementTick+0x138>
80004050:	70 08       	ld.w	r8,r8[0x0]
80004052:	f0 c9 ff ff 	sub	r9,r8,-1
80004056:	4c 88       	lddpc	r8,80004174 <vTaskIncrementTick+0x138>
80004058:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000405a:	4c 78       	lddpc	r8,80004174 <vTaskIncrementTick+0x138>
8000405c:	70 08       	ld.w	r8,r8[0x0]
8000405e:	58 08       	cp.w	r8,0
80004060:	c2 71       	brne	800040ae <vTaskIncrementTick+0x72>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80004062:	4c 68       	lddpc	r8,80004178 <vTaskIncrementTick+0x13c>
80004064:	70 08       	ld.w	r8,r8[0x0]
80004066:	ef 48 ff f8 	st.w	r7[-8],r8
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000406a:	4c 58       	lddpc	r8,8000417c <vTaskIncrementTick+0x140>
8000406c:	70 09       	ld.w	r9,r8[0x0]
8000406e:	4c 38       	lddpc	r8,80004178 <vTaskIncrementTick+0x13c>
80004070:	91 09       	st.w	r8[0x0],r9
			pxOverflowDelayedTaskList = pxTemp;
80004072:	4c 38       	lddpc	r8,8000417c <vTaskIncrementTick+0x140>
80004074:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004078:	91 09       	st.w	r8[0x0],r9
			xNumOfOverflows++;
8000407a:	4c 28       	lddpc	r8,80004180 <vTaskIncrementTick+0x144>
8000407c:	70 08       	ld.w	r8,r8[0x0]
8000407e:	f0 c9 ff ff 	sub	r9,r8,-1
80004082:	4c 08       	lddpc	r8,80004180 <vTaskIncrementTick+0x144>
80004084:	91 09       	st.w	r8[0x0],r9

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80004086:	4b d8       	lddpc	r8,80004178 <vTaskIncrementTick+0x13c>
80004088:	70 08       	ld.w	r8,r8[0x0]
8000408a:	70 08       	ld.w	r8,r8[0x0]
8000408c:	58 08       	cp.w	r8,0
8000408e:	c0 51       	brne	80004098 <vTaskIncrementTick+0x5c>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80004090:	4b d8       	lddpc	r8,80004184 <vTaskIncrementTick+0x148>
80004092:	3f f9       	mov	r9,-1
80004094:	91 09       	st.w	r8[0x0],r9
80004096:	c0 c8       	rjmp	800040ae <vTaskIncrementTick+0x72>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80004098:	4b 88       	lddpc	r8,80004178 <vTaskIncrementTick+0x13c>
8000409a:	70 08       	ld.w	r8,r8[0x0]
8000409c:	70 38       	ld.w	r8,r8[0xc]
8000409e:	70 38       	ld.w	r8,r8[0xc]
800040a0:	ef 48 ff f4 	st.w	r7[-12],r8
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800040a4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800040a8:	70 19       	ld.w	r9,r8[0x4]
800040aa:	4b 78       	lddpc	r8,80004184 <vTaskIncrementTick+0x148>
800040ac:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800040ae:	4b 28       	lddpc	r8,80004174 <vTaskIncrementTick+0x138>
800040b0:	70 09       	ld.w	r9,r8[0x0]
800040b2:	4b 58       	lddpc	r8,80004184 <vTaskIncrementTick+0x148>
800040b4:	70 08       	ld.w	r8,r8[0x0]
800040b6:	10 39       	cp.w	r9,r8
800040b8:	c5 83       	brcs	80004168 <vTaskIncrementTick+0x12c>
800040ba:	4b 08       	lddpc	r8,80004178 <vTaskIncrementTick+0x13c>
800040bc:	70 08       	ld.w	r8,r8[0x0]
800040be:	70 08       	ld.w	r8,r8[0x0]
800040c0:	58 08       	cp.w	r8,0
800040c2:	c0 51       	brne	800040cc <vTaskIncrementTick+0x90>
800040c4:	4b 08       	lddpc	r8,80004184 <vTaskIncrementTick+0x148>
800040c6:	3f f9       	mov	r9,-1
800040c8:	91 09       	st.w	r8[0x0],r9
800040ca:	c4 f8       	rjmp	80004168 <vTaskIncrementTick+0x12c>
800040cc:	4a b8       	lddpc	r8,80004178 <vTaskIncrementTick+0x13c>
800040ce:	70 08       	ld.w	r8,r8[0x0]
800040d0:	70 38       	ld.w	r8,r8[0xc]
800040d2:	70 38       	ld.w	r8,r8[0xc]
800040d4:	ef 48 ff f4 	st.w	r7[-12],r8
800040d8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800040dc:	70 18       	ld.w	r8,r8[0x4]
800040de:	ef 48 ff fc 	st.w	r7[-4],r8
800040e2:	4a 58       	lddpc	r8,80004174 <vTaskIncrementTick+0x138>
800040e4:	70 09       	ld.w	r9,r8[0x0]
800040e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800040ea:	10 39       	cp.w	r9,r8
800040ec:	c0 62       	brcc	800040f8 <vTaskIncrementTick+0xbc>
800040ee:	4a 68       	lddpc	r8,80004184 <vTaskIncrementTick+0x148>
800040f0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800040f4:	91 09       	st.w	r8[0x0],r9
800040f6:	c3 98       	rjmp	80004168 <vTaskIncrementTick+0x12c>
800040f8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800040fc:	2f c8       	sub	r8,-4
800040fe:	10 9c       	mov	r12,r8
80004100:	f0 1f 00 22 	mcall	80004188 <vTaskIncrementTick+0x14c>
80004104:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004108:	70 a8       	ld.w	r8,r8[0x28]
8000410a:	58 08       	cp.w	r8,0
8000410c:	c0 70       	breq	8000411a <vTaskIncrementTick+0xde>
8000410e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004112:	2e 88       	sub	r8,-24
80004114:	10 9c       	mov	r12,r8
80004116:	f0 1f 00 1d 	mcall	80004188 <vTaskIncrementTick+0x14c>
8000411a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000411e:	70 b9       	ld.w	r9,r8[0x2c]
80004120:	49 b8       	lddpc	r8,8000418c <vTaskIncrementTick+0x150>
80004122:	70 08       	ld.w	r8,r8[0x0]
80004124:	10 39       	cp.w	r9,r8
80004126:	e0 88 00 07 	brls	80004134 <vTaskIncrementTick+0xf8>
8000412a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000412e:	70 b9       	ld.w	r9,r8[0x2c]
80004130:	49 78       	lddpc	r8,8000418c <vTaskIncrementTick+0x150>
80004132:	91 09       	st.w	r8[0x0],r9
80004134:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004138:	f0 ca ff fc 	sub	r10,r8,-4
8000413c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004140:	70 b9       	ld.w	r9,r8[0x2c]
80004142:	12 98       	mov	r8,r9
80004144:	a3 68       	lsl	r8,0x2
80004146:	12 08       	add	r8,r9
80004148:	a3 68       	lsl	r8,0x2
8000414a:	10 99       	mov	r9,r8
8000414c:	49 18       	lddpc	r8,80004190 <vTaskIncrementTick+0x154>
8000414e:	f2 08 00 08 	add	r8,r9,r8
80004152:	14 9b       	mov	r11,r10
80004154:	10 9c       	mov	r12,r8
80004156:	f0 1f 00 10 	mcall	80004194 <vTaskIncrementTick+0x158>
8000415a:	cb 0b       	rjmp	800040ba <vTaskIncrementTick+0x7e>
	}
	else
	{
		++uxMissedTicks;
8000415c:	48 f8       	lddpc	r8,80004198 <vTaskIncrementTick+0x15c>
8000415e:	70 08       	ld.w	r8,r8[0x0]
80004160:	f0 c9 ff ff 	sub	r9,r8,-1
80004164:	48 d8       	lddpc	r8,80004198 <vTaskIncrementTick+0x15c>
80004166:	91 09       	st.w	r8[0x0],r9
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
80004168:	2f dd       	sub	sp,-12
8000416a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000416e:	00 00       	add	r0,r0
80004170:	00 00       	add	r0,r0
80004172:	07 48       	ld.w	r8,--r3
80004174:	00 00       	add	r0,r0
80004176:	07 38       	ld.ub	r8,r3++
80004178:	00 00       	add	r0,r0
8000417a:	06 ec       	st.h	--r3,r12
8000417c:	00 00       	add	r0,r0
8000417e:	06 f0       	st.b	--r3,r0
80004180:	00 00       	add	r0,r0
80004182:	07 54       	ld.sh	r4,--r3
80004184:	00 00       	add	r0,r0
80004186:	00 20       	rsub	r0,r0
80004188:	80 00       	ld.sh	r0,r0[0x0]
8000418a:	2e e6       	sub	r6,-18
8000418c:	00 00       	add	r0,r0
8000418e:	07 40       	ld.w	r0,--r3
80004190:	00 00       	add	r0,r0
80004192:	06 24       	rsub	r4,r3
80004194:	80 00       	ld.sh	r0,r0[0x0]
80004196:	2d d2       	sub	r2,-35
80004198:	00 00       	add	r0,r0
8000419a:	07 4c       	ld.w	r12,--r3

8000419c <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
8000419c:	eb cd 40 80 	pushm	r7,lr
800041a0:	1a 97       	mov	r7,sp
800041a2:	20 1d       	sub	sp,4
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800041a4:	4a 58       	lddpc	r8,80004238 <vTaskSwitchContext+0x9c>
800041a6:	70 08       	ld.w	r8,r8[0x0]
800041a8:	58 08       	cp.w	r8,0
800041aa:	c0 c0       	breq	800041c2 <vTaskSwitchContext+0x26>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800041ac:	4a 48       	lddpc	r8,8000423c <vTaskSwitchContext+0xa0>
800041ae:	30 19       	mov	r9,1
800041b0:	91 09       	st.w	r8[0x0],r9
800041b2:	c3 f8       	rjmp	80004230 <vTaskSwitchContext+0x94>

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800041b4:	4a 38       	lddpc	r8,80004240 <vTaskSwitchContext+0xa4>
800041b6:	70 08       	ld.w	r8,r8[0x0]
800041b8:	f0 c9 00 01 	sub	r9,r8,1
800041bc:	4a 18       	lddpc	r8,80004240 <vTaskSwitchContext+0xa4>
800041be:	91 09       	st.w	r8[0x0],r9
800041c0:	c0 28       	rjmp	800041c4 <vTaskSwitchContext+0x28>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800041c2:	d7 03       	nop
800041c4:	49 f8       	lddpc	r8,80004240 <vTaskSwitchContext+0xa4>
800041c6:	70 09       	ld.w	r9,r8[0x0]
800041c8:	12 98       	mov	r8,r9
800041ca:	a3 68       	lsl	r8,0x2
800041cc:	12 08       	add	r8,r9
800041ce:	a3 68       	lsl	r8,0x2
800041d0:	10 99       	mov	r9,r8
800041d2:	49 d8       	lddpc	r8,80004244 <vTaskSwitchContext+0xa8>
800041d4:	f2 08 00 08 	add	r8,r9,r8
800041d8:	70 08       	ld.w	r8,r8[0x0]
800041da:	58 08       	cp.w	r8,0
800041dc:	ce c0       	breq	800041b4 <vTaskSwitchContext+0x18>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800041de:	49 98       	lddpc	r8,80004240 <vTaskSwitchContext+0xa4>
800041e0:	70 09       	ld.w	r9,r8[0x0]
800041e2:	12 98       	mov	r8,r9
800041e4:	a3 68       	lsl	r8,0x2
800041e6:	12 08       	add	r8,r9
800041e8:	a3 68       	lsl	r8,0x2
800041ea:	10 99       	mov	r9,r8
800041ec:	49 68       	lddpc	r8,80004244 <vTaskSwitchContext+0xa8>
800041ee:	f2 08 00 08 	add	r8,r9,r8
800041f2:	ef 48 ff fc 	st.w	r7[-4],r8
800041f6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800041fa:	70 18       	ld.w	r8,r8[0x4]
800041fc:	70 19       	ld.w	r9,r8[0x4]
800041fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004202:	91 19       	st.w	r8[0x4],r9
80004204:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004208:	70 19       	ld.w	r9,r8[0x4]
8000420a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000420e:	2f 88       	sub	r8,-8
80004210:	10 39       	cp.w	r9,r8
80004212:	c0 81       	brne	80004222 <vTaskSwitchContext+0x86>
80004214:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004218:	70 18       	ld.w	r8,r8[0x4]
8000421a:	70 19       	ld.w	r9,r8[0x4]
8000421c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004220:	91 19       	st.w	r8[0x4],r9
80004222:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004226:	70 18       	ld.w	r8,r8[0x4]
80004228:	70 38       	ld.w	r8,r8[0xc]
8000422a:	10 99       	mov	r9,r8
8000422c:	48 78       	lddpc	r8,80004248 <vTaskSwitchContext+0xac>
8000422e:	91 09       	st.w	r8[0x0],r9

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
80004230:	2f fd       	sub	sp,-4
80004232:	e3 cd 80 80 	ldm	sp++,r7,pc
80004236:	00 00       	add	r0,r0
80004238:	00 00       	add	r0,r0
8000423a:	07 48       	ld.w	r8,--r3
8000423c:	00 00       	add	r0,r0
8000423e:	07 50       	ld.sh	r0,--r3
80004240:	00 00       	add	r0,r0
80004242:	07 40       	ld.w	r0,--r3
80004244:	00 00       	add	r0,r0
80004246:	06 24       	rsub	r4,r3
80004248:	00 00       	add	r0,r0
8000424a:	06 20       	rsub	r0,r3

8000424c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
8000424c:	eb cd 40 80 	pushm	r7,lr
80004250:	1a 97       	mov	r7,sp
80004252:	20 3d       	sub	sp,12
80004254:	ef 4c ff f8 	st.w	r7[-8],r12
80004258:	ef 4b ff f4 	st.w	r7[-12],r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
8000425c:	49 58       	lddpc	r8,800042b0 <vTaskPlaceOnEventList+0x64>
8000425e:	70 08       	ld.w	r8,r8[0x0]
80004260:	2e 88       	sub	r8,-24
80004262:	10 9b       	mov	r11,r8
80004264:	ee fc ff f8 	ld.w	r12,r7[-8]
80004268:	f0 1f 00 13 	mcall	800042b4 <vTaskPlaceOnEventList+0x68>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000426c:	49 18       	lddpc	r8,800042b0 <vTaskPlaceOnEventList+0x64>
8000426e:	70 08       	ld.w	r8,r8[0x0]
80004270:	2f c8       	sub	r8,-4
80004272:	10 9c       	mov	r12,r8
80004274:	f0 1f 00 11 	mcall	800042b8 <vTaskPlaceOnEventList+0x6c>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80004278:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000427c:	5b f8       	cp.w	r8,-1
8000427e:	c0 91       	brne	80004290 <vTaskPlaceOnEventList+0x44>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004280:	48 c8       	lddpc	r8,800042b0 <vTaskPlaceOnEventList+0x64>
80004282:	70 08       	ld.w	r8,r8[0x0]
80004284:	2f c8       	sub	r8,-4
80004286:	10 9b       	mov	r11,r8
80004288:	48 dc       	lddpc	r12,800042bc <vTaskPlaceOnEventList+0x70>
8000428a:	f0 1f 00 0e 	mcall	800042c0 <vTaskPlaceOnEventList+0x74>
8000428e:	c0 d8       	rjmp	800042a8 <vTaskPlaceOnEventList+0x5c>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80004290:	48 d8       	lddpc	r8,800042c4 <vTaskPlaceOnEventList+0x78>
80004292:	70 09       	ld.w	r9,r8[0x0]
80004294:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004298:	f2 08 00 08 	add	r8,r9,r8
8000429c:	ef 48 ff fc 	st.w	r7[-4],r8
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800042a0:	ee fc ff fc 	ld.w	r12,r7[-4]
800042a4:	f0 1f 00 09 	mcall	800042c8 <vTaskPlaceOnEventList+0x7c>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
800042a8:	2f dd       	sub	sp,-12
800042aa:	e3 cd 80 80 	ldm	sp++,r7,pc
800042ae:	00 00       	add	r0,r0
800042b0:	00 00       	add	r0,r0
800042b2:	06 20       	rsub	r0,r3
800042b4:	80 00       	ld.sh	r0,r0[0x0]
800042b6:	2e 44       	sub	r4,-28
800042b8:	80 00       	ld.sh	r0,r0[0x0]
800042ba:	2e e6       	sub	r6,-18
800042bc:	00 00       	add	r0,r0
800042be:	07 20       	ld.uh	r0,r3++
800042c0:	80 00       	ld.sh	r0,r0[0x0]
800042c2:	2d d2       	sub	r2,-35
800042c4:	00 00       	add	r0,r0
800042c6:	07 38       	ld.ub	r8,r3++
800042c8:	80 00       	ld.sh	r0,r0[0x0]
800042ca:	46 8c       	lddsp	r12,sp[0x1a0]

800042cc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800042cc:	eb cd 40 80 	pushm	r7,lr
800042d0:	1a 97       	mov	r7,sp
800042d2:	20 3d       	sub	sp,12
800042d4:	ef 4c ff f4 	st.w	r7[-12],r12
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800042d8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800042dc:	70 38       	ld.w	r8,r8[0xc]
800042de:	70 38       	ld.w	r8,r8[0xc]
800042e0:	ef 48 ff f8 	st.w	r7[-8],r8
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800042e4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042e8:	2e 88       	sub	r8,-24
800042ea:	10 9c       	mov	r12,r8
800042ec:	f0 1f 00 25 	mcall	80004380 <xTaskRemoveFromEventList+0xb4>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800042f0:	4a 58       	lddpc	r8,80004384 <xTaskRemoveFromEventList+0xb8>
800042f2:	70 08       	ld.w	r8,r8[0x0]
800042f4:	58 08       	cp.w	r8,0
800042f6:	c2 81       	brne	80004346 <xTaskRemoveFromEventList+0x7a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800042f8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042fc:	2f c8       	sub	r8,-4
800042fe:	10 9c       	mov	r12,r8
80004300:	f0 1f 00 20 	mcall	80004380 <xTaskRemoveFromEventList+0xb4>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80004304:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004308:	70 b9       	ld.w	r9,r8[0x2c]
8000430a:	4a 08       	lddpc	r8,80004388 <xTaskRemoveFromEventList+0xbc>
8000430c:	70 08       	ld.w	r8,r8[0x0]
8000430e:	10 39       	cp.w	r9,r8
80004310:	e0 88 00 07 	brls	8000431e <xTaskRemoveFromEventList+0x52>
80004314:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004318:	70 b9       	ld.w	r9,r8[0x2c]
8000431a:	49 c8       	lddpc	r8,80004388 <xTaskRemoveFromEventList+0xbc>
8000431c:	91 09       	st.w	r8[0x0],r9
8000431e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004322:	f0 ca ff fc 	sub	r10,r8,-4
80004326:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000432a:	70 b9       	ld.w	r9,r8[0x2c]
8000432c:	12 98       	mov	r8,r9
8000432e:	a3 68       	lsl	r8,0x2
80004330:	12 08       	add	r8,r9
80004332:	a3 68       	lsl	r8,0x2
80004334:	10 99       	mov	r9,r8
80004336:	49 68       	lddpc	r8,8000438c <xTaskRemoveFromEventList+0xc0>
80004338:	f2 08 00 08 	add	r8,r9,r8
8000433c:	14 9b       	mov	r11,r10
8000433e:	10 9c       	mov	r12,r8
80004340:	f0 1f 00 14 	mcall	80004390 <xTaskRemoveFromEventList+0xc4>
80004344:	c0 88       	rjmp	80004354 <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80004346:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000434a:	2e 88       	sub	r8,-24
8000434c:	10 9b       	mov	r11,r8
8000434e:	49 2c       	lddpc	r12,80004394 <xTaskRemoveFromEventList+0xc8>
80004350:	f0 1f 00 10 	mcall	80004390 <xTaskRemoveFromEventList+0xc4>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80004354:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004358:	70 b9       	ld.w	r9,r8[0x2c]
8000435a:	49 08       	lddpc	r8,80004398 <xTaskRemoveFromEventList+0xcc>
8000435c:	70 08       	ld.w	r8,r8[0x0]
8000435e:	70 b8       	ld.w	r8,r8[0x2c]
80004360:	10 39       	cp.w	r9,r8
80004362:	c0 53       	brcs	8000436c <xTaskRemoveFromEventList+0xa0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
80004364:	30 18       	mov	r8,1
80004366:	ef 48 ff fc 	st.w	r7[-4],r8
8000436a:	c0 48       	rjmp	80004372 <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		xReturn = pdFALSE;
8000436c:	30 08       	mov	r8,0
8000436e:	ef 48 ff fc 	st.w	r7[-4],r8
	}

	return xReturn;
80004372:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80004376:	10 9c       	mov	r12,r8
80004378:	2f dd       	sub	sp,-12
8000437a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000437e:	00 00       	add	r0,r0
80004380:	80 00       	ld.sh	r0,r0[0x0]
80004382:	2e e6       	sub	r6,-18
80004384:	00 00       	add	r0,r0
80004386:	07 48       	ld.w	r8,--r3
80004388:	00 00       	add	r0,r0
8000438a:	07 40       	ld.w	r0,--r3
8000438c:	00 00       	add	r0,r0
8000438e:	06 24       	rsub	r4,r3
80004390:	80 00       	ld.sh	r0,r0[0x0]
80004392:	2d d2       	sub	r2,-35
80004394:	00 00       	add	r0,r0
80004396:	06 f4       	st.b	--r3,r4
80004398:	00 00       	add	r0,r0
8000439a:	06 20       	rsub	r0,r3

8000439c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
8000439c:	eb cd 40 80 	pushm	r7,lr
800043a0:	1a 97       	mov	r7,sp
800043a2:	20 1d       	sub	sp,4
800043a4:	ef 4c ff fc 	st.w	r7[-4],r12
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800043a8:	48 78       	lddpc	r8,800043c4 <vTaskSetTimeOutState+0x28>
800043aa:	70 09       	ld.w	r9,r8[0x0]
800043ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043b0:	91 09       	st.w	r8[0x0],r9
	pxTimeOut->xTimeOnEntering = xTickCount;
800043b2:	48 68       	lddpc	r8,800043c8 <vTaskSetTimeOutState+0x2c>
800043b4:	70 09       	ld.w	r9,r8[0x0]
800043b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043ba:	91 19       	st.w	r8[0x4],r9
}
800043bc:	2f fd       	sub	sp,-4
800043be:	e3 cd 80 80 	ldm	sp++,r7,pc
800043c2:	00 00       	add	r0,r0
800043c4:	00 00       	add	r0,r0
800043c6:	07 54       	ld.sh	r4,--r3
800043c8:	00 00       	add	r0,r0
800043ca:	07 38       	ld.ub	r8,r3++

800043cc <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800043cc:	eb cd 40 80 	pushm	r7,lr
800043d0:	1a 97       	mov	r7,sp
800043d2:	20 3d       	sub	sp,12
800043d4:	ef 4c ff f8 	st.w	r7[-8],r12
800043d8:	ef 4b ff f4 	st.w	r7[-12],r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800043dc:	f0 1f 00 25 	mcall	80004470 <xTaskCheckForTimeOut+0xa4>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800043e0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800043e4:	70 08       	ld.w	r8,r8[0x0]
800043e6:	5b f8       	cp.w	r8,-1
800043e8:	c0 51       	brne	800043f2 <xTaskCheckForTimeOut+0x26>
			{
				xReturn = pdFALSE;
800043ea:	30 08       	mov	r8,0
800043ec:	ef 48 ff fc 	st.w	r7[-4],r8
800043f0:	c3 88       	rjmp	80004460 <xTaskCheckForTimeOut+0x94>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800043f2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800043f6:	70 09       	ld.w	r9,r8[0x0]
800043f8:	49 f8       	lddpc	r8,80004474 <xTaskCheckForTimeOut+0xa8>
800043fa:	70 08       	ld.w	r8,r8[0x0]
800043fc:	10 39       	cp.w	r9,r8
800043fe:	c0 d0       	breq	80004418 <xTaskCheckForTimeOut+0x4c>
80004400:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004404:	70 19       	ld.w	r9,r8[0x4]
80004406:	49 d8       	lddpc	r8,80004478 <xTaskCheckForTimeOut+0xac>
80004408:	70 08       	ld.w	r8,r8[0x0]
8000440a:	10 39       	cp.w	r9,r8
8000440c:	e0 8b 00 06 	brhi	80004418 <xTaskCheckForTimeOut+0x4c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
80004410:	30 18       	mov	r8,1
80004412:	ef 48 ff fc 	st.w	r7[-4],r8
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80004416:	c2 58       	rjmp	80004460 <xTaskCheckForTimeOut+0x94>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80004418:	49 88       	lddpc	r8,80004478 <xTaskCheckForTimeOut+0xac>
8000441a:	70 09       	ld.w	r9,r8[0x0]
8000441c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004420:	70 18       	ld.w	r8,r8[0x4]
80004422:	10 19       	sub	r9,r8
80004424:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004428:	70 08       	ld.w	r8,r8[0x0]
8000442a:	10 39       	cp.w	r9,r8
8000442c:	c1 72       	brcc	8000445a <xTaskCheckForTimeOut+0x8e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000442e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004432:	70 09       	ld.w	r9,r8[0x0]
80004434:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004438:	70 1a       	ld.w	r10,r8[0x4]
8000443a:	49 08       	lddpc	r8,80004478 <xTaskCheckForTimeOut+0xac>
8000443c:	70 08       	ld.w	r8,r8[0x0]
8000443e:	f4 08 01 08 	sub	r8,r10,r8
80004442:	10 09       	add	r9,r8
80004444:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004448:	91 09       	st.w	r8[0x0],r9
			vTaskSetTimeOutState( pxTimeOut );
8000444a:	ee fc ff f8 	ld.w	r12,r7[-8]
8000444e:	f0 1f 00 0c 	mcall	8000447c <xTaskCheckForTimeOut+0xb0>
			xReturn = pdFALSE;
80004452:	30 08       	mov	r8,0
80004454:	ef 48 ff fc 	st.w	r7[-4],r8
80004458:	c0 48       	rjmp	80004460 <xTaskCheckForTimeOut+0x94>
		}
		else
		{
			xReturn = pdTRUE;
8000445a:	30 18       	mov	r8,1
8000445c:	ef 48 ff fc 	st.w	r7[-4],r8
		}
	}
	taskEXIT_CRITICAL();
80004460:	f0 1f 00 08 	mcall	80004480 <xTaskCheckForTimeOut+0xb4>

	return xReturn;
80004464:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80004468:	10 9c       	mov	r12,r8
8000446a:	2f dd       	sub	sp,-12
8000446c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004470:	80 00       	ld.sh	r0,r0[0x0]
80004472:	30 fc       	mov	r12,15
80004474:	00 00       	add	r0,r0
80004476:	07 54       	ld.sh	r4,--r3
80004478:	00 00       	add	r0,r0
8000447a:	07 38       	ld.ub	r8,r3++
8000447c:	80 00       	ld.sh	r0,r0[0x0]
8000447e:	43 9c       	lddsp	r12,sp[0xe4]
80004480:	80 00       	ld.sh	r0,r0[0x0]
80004482:	31 18       	mov	r8,17

80004484 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
80004484:	eb cd 40 80 	pushm	r7,lr
80004488:	1a 97       	mov	r7,sp
	xMissedYield = pdTRUE;
8000448a:	48 38       	lddpc	r8,80004494 <vTaskMissedYield+0x10>
8000448c:	30 19       	mov	r9,1
8000448e:	91 09       	st.w	r8[0x0],r9
}
80004490:	e3 cd 80 80 	ldm	sp++,r7,pc
80004494:	00 00       	add	r0,r0
80004496:	07 50       	ld.sh	r0,--r3

80004498 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80004498:	eb cd 40 80 	pushm	r7,lr
8000449c:	1a 97       	mov	r7,sp
8000449e:	20 1d       	sub	sp,4
800044a0:	ef 4c ff fc 	st.w	r7[-4],r12
800044a4:	c0 28       	rjmp	800044a8 <prvIdleTask+0x10>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
800044a6:	d7 03       	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
800044a8:	f0 1f 00 05 	mcall	800044bc <prvIdleTask+0x24>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800044ac:	48 58       	lddpc	r8,800044c0 <prvIdleTask+0x28>
800044ae:	70 08       	ld.w	r8,r8[0x0]
800044b0:	58 18       	cp.w	r8,1
800044b2:	fe 98 ff fa 	brls	800044a6 <prvIdleTask+0xe>
			{
				taskYIELD();
800044b6:	d7 33       	scall
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
800044b8:	cf 8b       	rjmp	800044a8 <prvIdleTask+0x10>
800044ba:	00 00       	add	r0,r0
800044bc:	80 00       	ld.sh	r0,r0[0x0]
800044be:	45 f4       	lddsp	r4,sp[0x17c]
800044c0:	00 00       	add	r0,r0
800044c2:	06 24       	rsub	r4,r3

800044c4 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
800044c4:	eb cd 40 80 	pushm	r7,lr
800044c8:	1a 97       	mov	r7,sp
800044ca:	20 5d       	sub	sp,20
800044cc:	ef 4c ff fc 	st.w	r7[-4],r12
800044d0:	ef 4b ff f8 	st.w	r7[-8],r11
800044d4:	ef 4a ff f4 	st.w	r7[-12],r10
800044d8:	ef 49 ff f0 	st.w	r7[-16],r9
800044dc:	ef 58 ff ec 	st.h	r7[-20],r8
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800044e0:	ee f9 ff f8 	ld.w	r9,r7[-8]
800044e4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800044e8:	2c c8       	sub	r8,-52
800044ea:	31 0a       	mov	r10,16
800044ec:	12 9b       	mov	r11,r9
800044ee:	10 9c       	mov	r12,r8
800044f0:	f0 1f 00 1a 	mcall	80004558 <prvInitialiseTCBVariables+0x94>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800044f4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800044f8:	30 08       	mov	r8,0
800044fa:	f3 68 00 43 	st.b	r9[67],r8

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
800044fe:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004502:	58 78       	cp.w	r8,7
80004504:	e0 88 00 05 	brls	8000450e <prvInitialiseTCBVariables+0x4a>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
80004508:	30 78       	mov	r8,7
8000450a:	ef 48 ff f4 	st.w	r7[-12],r8
	}

	pxTCB->uxPriority = uxPriority;
8000450e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004512:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004516:	91 b9       	st.w	r8[0x2c],r9
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80004518:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000451c:	2f c8       	sub	r8,-4
8000451e:	10 9c       	mov	r12,r8
80004520:	f0 1f 00 0f 	mcall	8000455c <prvInitialiseTCBVariables+0x98>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80004524:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004528:	2e 88       	sub	r8,-24
8000452a:	10 9c       	mov	r12,r8
8000452c:	f0 1f 00 0c 	mcall	8000455c <prvInitialiseTCBVariables+0x98>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80004530:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004534:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004538:	91 49       	st.w	r8[0x10],r9

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
8000453a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000453e:	f0 09 11 08 	rsub	r9,r8,8
80004542:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004546:	91 69       	st.w	r8[0x18],r9
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80004548:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000454c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004550:	91 99       	st.w	r8[0x24],r9
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
80004552:	2f bd       	sub	sp,-20
80004554:	e3 cd 80 80 	ldm	sp++,r7,pc
80004558:	80 00       	ld.sh	r0,r0[0x0]
8000455a:	4d dc       	lddpc	r12,800046cc <prvAddCurrentTaskToDelayedList+0x40>
8000455c:	80 00       	ld.sh	r0,r0[0x0]
8000455e:	2d b8       	sub	r8,-37

80004560 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
80004560:	eb cd 40 80 	pushm	r7,lr
80004564:	1a 97       	mov	r7,sp
80004566:	20 1d       	sub	sp,4
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80004568:	30 08       	mov	r8,0
8000456a:	ef 48 ff fc 	st.w	r7[-4],r8
8000456e:	c1 38       	rjmp	80004594 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80004570:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004574:	12 98       	mov	r8,r9
80004576:	a3 68       	lsl	r8,0x2
80004578:	12 08       	add	r8,r9
8000457a:	a3 68       	lsl	r8,0x2
8000457c:	10 99       	mov	r9,r8
8000457e:	49 58       	lddpc	r8,800045d0 <prvInitialiseTaskLists+0x70>
80004580:	f2 08 00 08 	add	r8,r9,r8
80004584:	10 9c       	mov	r12,r8
80004586:	f0 1f 00 14 	mcall	800045d4 <prvInitialiseTaskLists+0x74>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
8000458a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000458e:	2f f8       	sub	r8,-1
80004590:	ef 48 ff fc 	st.w	r7[-4],r8
80004594:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004598:	58 78       	cp.w	r8,7
8000459a:	fe 98 ff eb 	brls	80004570 <prvInitialiseTaskLists+0x10>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
8000459e:	48 fc       	lddpc	r12,800045d8 <prvInitialiseTaskLists+0x78>
800045a0:	f0 1f 00 0d 	mcall	800045d4 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800045a4:	48 ec       	lddpc	r12,800045dc <prvInitialiseTaskLists+0x7c>
800045a6:	f0 1f 00 0c 	mcall	800045d4 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xPendingReadyList );
800045aa:	48 ec       	lddpc	r12,800045e0 <prvInitialiseTaskLists+0x80>
800045ac:	f0 1f 00 0a 	mcall	800045d4 <prvInitialiseTaskLists+0x74>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800045b0:	48 dc       	lddpc	r12,800045e4 <prvInitialiseTaskLists+0x84>
800045b2:	f0 1f 00 09 	mcall	800045d4 <prvInitialiseTaskLists+0x74>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800045b6:	48 dc       	lddpc	r12,800045e8 <prvInitialiseTaskLists+0x88>
800045b8:	f0 1f 00 07 	mcall	800045d4 <prvInitialiseTaskLists+0x74>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800045bc:	48 c8       	lddpc	r8,800045ec <prvInitialiseTaskLists+0x8c>
800045be:	48 79       	lddpc	r9,800045d8 <prvInitialiseTaskLists+0x78>
800045c0:	91 09       	st.w	r8[0x0],r9
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800045c2:	48 c8       	lddpc	r8,800045f0 <prvInitialiseTaskLists+0x90>
800045c4:	48 69       	lddpc	r9,800045dc <prvInitialiseTaskLists+0x7c>
800045c6:	91 09       	st.w	r8[0x0],r9
}
800045c8:	2f fd       	sub	sp,-4
800045ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800045ce:	00 00       	add	r0,r0
800045d0:	00 00       	add	r0,r0
800045d2:	06 24       	rsub	r4,r3
800045d4:	80 00       	ld.sh	r0,r0[0x0]
800045d6:	2d 6c       	sub	r12,-42
800045d8:	00 00       	add	r0,r0
800045da:	06 c4       	st.b	r3++,r4
800045dc:	00 00       	add	r0,r0
800045de:	06 d8       	st.w	--r3,r8
800045e0:	00 00       	add	r0,r0
800045e2:	06 f4       	st.b	--r3,r4
800045e4:	00 00       	add	r0,r0
800045e6:	07 08       	ld.w	r8,r3++
800045e8:	00 00       	add	r0,r0
800045ea:	07 20       	ld.uh	r0,r3++
800045ec:	00 00       	add	r0,r0
800045ee:	06 ec       	st.h	--r3,r12
800045f0:	00 00       	add	r0,r0
800045f2:	06 f0       	st.b	--r3,r0

800045f4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
800045f4:	eb cd 40 80 	pushm	r7,lr
800045f8:	1a 97       	mov	r7,sp
800045fa:	20 2d       	sub	sp,8
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800045fc:	49 b8       	lddpc	r8,80004668 <prvCheckTasksWaitingTermination+0x74>
800045fe:	70 08       	ld.w	r8,r8[0x0]
80004600:	58 08       	cp.w	r8,0
80004602:	c2 f0       	breq	80004660 <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
80004604:	f0 1f 00 1a 	mcall	8000466c <prvCheckTasksWaitingTermination+0x78>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80004608:	49 a8       	lddpc	r8,80004670 <prvCheckTasksWaitingTermination+0x7c>
8000460a:	70 08       	ld.w	r8,r8[0x0]
8000460c:	58 08       	cp.w	r8,0
8000460e:	5f 08       	sreq	r8
80004610:	ef 48 ff f8 	st.w	r7[-8],r8
			xTaskResumeAll();
80004614:	f0 1f 00 18 	mcall	80004674 <prvCheckTasksWaitingTermination+0x80>

			if( xListIsEmpty == pdFALSE )
80004618:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000461c:	58 08       	cp.w	r8,0
8000461e:	c2 11       	brne	80004660 <prvCheckTasksWaitingTermination+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80004620:	f0 1f 00 16 	mcall	80004678 <prvCheckTasksWaitingTermination+0x84>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80004624:	49 38       	lddpc	r8,80004670 <prvCheckTasksWaitingTermination+0x7c>
80004626:	2f 88       	sub	r8,-8
80004628:	70 18       	ld.w	r8,r8[0x4]
8000462a:	70 38       	ld.w	r8,r8[0xc]
8000462c:	ef 48 ff fc 	st.w	r7[-4],r8
					vListRemove( &( pxTCB->xGenericListItem ) );
80004630:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004634:	2f c8       	sub	r8,-4
80004636:	10 9c       	mov	r12,r8
80004638:	f0 1f 00 11 	mcall	8000467c <prvCheckTasksWaitingTermination+0x88>
					--uxCurrentNumberOfTasks;
8000463c:	49 18       	lddpc	r8,80004680 <prvCheckTasksWaitingTermination+0x8c>
8000463e:	70 08       	ld.w	r8,r8[0x0]
80004640:	f0 c9 00 01 	sub	r9,r8,1
80004644:	48 f8       	lddpc	r8,80004680 <prvCheckTasksWaitingTermination+0x8c>
80004646:	91 09       	st.w	r8[0x0],r9
					--uxTasksDeleted;
80004648:	48 88       	lddpc	r8,80004668 <prvCheckTasksWaitingTermination+0x74>
8000464a:	70 08       	ld.w	r8,r8[0x0]
8000464c:	f0 c9 00 01 	sub	r9,r8,1
80004650:	48 68       	lddpc	r8,80004668 <prvCheckTasksWaitingTermination+0x74>
80004652:	91 09       	st.w	r8[0x0],r9
				}
				taskEXIT_CRITICAL();
80004654:	f0 1f 00 0c 	mcall	80004684 <prvCheckTasksWaitingTermination+0x90>

				prvDeleteTCB( pxTCB );
80004658:	ee fc ff fc 	ld.w	r12,r7[-4]
8000465c:	f0 1f 00 0b 	mcall	80004688 <prvCheckTasksWaitingTermination+0x94>
			}
		}
	}
	#endif
}
80004660:	2f ed       	sub	sp,-8
80004662:	e3 cd 80 80 	ldm	sp++,r7,pc
80004666:	00 00       	add	r0,r0
80004668:	00 00       	add	r0,r0
8000466a:	07 1c       	ld.sh	r12,r3++
8000466c:	80 00       	ld.sh	r0,r0[0x0]
8000466e:	3e c8       	mov	r8,-20
80004670:	00 00       	add	r0,r0
80004672:	07 08       	ld.w	r8,r3++
80004674:	80 00       	ld.sh	r0,r0[0x0]
80004676:	3e e4       	mov	r4,-18
80004678:	80 00       	ld.sh	r0,r0[0x0]
8000467a:	30 fc       	mov	r12,15
8000467c:	80 00       	ld.sh	r0,r0[0x0]
8000467e:	2e e6       	sub	r6,-18
80004680:	00 00       	add	r0,r0
80004682:	07 34       	ld.ub	r4,r3++
80004684:	80 00       	ld.sh	r0,r0[0x0]
80004686:	31 18       	mov	r8,17
80004688:	80 00       	ld.sh	r0,r0[0x0]
8000468a:	47 a0       	lddsp	r0,sp[0x1e8]

8000468c <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
8000468c:	eb cd 40 80 	pushm	r7,lr
80004690:	1a 97       	mov	r7,sp
80004692:	20 1d       	sub	sp,4
80004694:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80004698:	49 78       	lddpc	r8,800046f4 <prvAddCurrentTaskToDelayedList+0x68>
8000469a:	70 08       	ld.w	r8,r8[0x0]
8000469c:	ee f9 ff fc 	ld.w	r9,r7[-4]
800046a0:	91 19       	st.w	r8[0x4],r9

	if( xTimeToWake < xTickCount )
800046a2:	49 68       	lddpc	r8,800046f8 <prvAddCurrentTaskToDelayedList+0x6c>
800046a4:	70 08       	ld.w	r8,r8[0x0]
800046a6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800046aa:	10 39       	cp.w	r9,r8
800046ac:	c0 c2       	brcc	800046c4 <prvAddCurrentTaskToDelayedList+0x38>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800046ae:	49 28       	lddpc	r8,800046f4 <prvAddCurrentTaskToDelayedList+0x68>
800046b0:	70 08       	ld.w	r8,r8[0x0]
800046b2:	f0 c9 ff fc 	sub	r9,r8,-4
800046b6:	49 28       	lddpc	r8,800046fc <prvAddCurrentTaskToDelayedList+0x70>
800046b8:	70 08       	ld.w	r8,r8[0x0]
800046ba:	12 9b       	mov	r11,r9
800046bc:	10 9c       	mov	r12,r8
800046be:	f0 1f 00 11 	mcall	80004700 <prvAddCurrentTaskToDelayedList+0x74>
800046c2:	c1 58       	rjmp	800046ec <prvAddCurrentTaskToDelayedList+0x60>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800046c4:	48 c8       	lddpc	r8,800046f4 <prvAddCurrentTaskToDelayedList+0x68>
800046c6:	70 08       	ld.w	r8,r8[0x0]
800046c8:	f0 c9 ff fc 	sub	r9,r8,-4
800046cc:	48 e8       	lddpc	r8,80004704 <prvAddCurrentTaskToDelayedList+0x78>
800046ce:	70 08       	ld.w	r8,r8[0x0]
800046d0:	12 9b       	mov	r11,r9
800046d2:	10 9c       	mov	r12,r8
800046d4:	f0 1f 00 0b 	mcall	80004700 <prvAddCurrentTaskToDelayedList+0x74>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800046d8:	48 c8       	lddpc	r8,80004708 <prvAddCurrentTaskToDelayedList+0x7c>
800046da:	70 08       	ld.w	r8,r8[0x0]
800046dc:	ee f9 ff fc 	ld.w	r9,r7[-4]
800046e0:	10 39       	cp.w	r9,r8
800046e2:	c0 52       	brcc	800046ec <prvAddCurrentTaskToDelayedList+0x60>
		{
			xNextTaskUnblockTime = xTimeToWake;
800046e4:	48 98       	lddpc	r8,80004708 <prvAddCurrentTaskToDelayedList+0x7c>
800046e6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800046ea:	91 09       	st.w	r8[0x0],r9
		}
	}
}
800046ec:	2f fd       	sub	sp,-4
800046ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800046f2:	00 00       	add	r0,r0
800046f4:	00 00       	add	r0,r0
800046f6:	06 20       	rsub	r0,r3
800046f8:	00 00       	add	r0,r0
800046fa:	07 38       	ld.ub	r8,r3++
800046fc:	00 00       	add	r0,r0
800046fe:	06 f0       	st.b	--r3,r0
80004700:	80 00       	ld.sh	r0,r0[0x0]
80004702:	2e 44       	sub	r4,-28
80004704:	00 00       	add	r0,r0
80004706:	06 ec       	st.h	--r3,r12
80004708:	00 00       	add	r0,r0
8000470a:	00 20       	rsub	r0,r0

8000470c <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
8000470c:	eb cd 40 80 	pushm	r7,lr
80004710:	1a 97       	mov	r7,sp
80004712:	20 3d       	sub	sp,12
80004714:	18 98       	mov	r8,r12
80004716:	ef 4b ff f4 	st.w	r7[-12],r11
8000471a:	ef 58 ff f8 	st.h	r7[-8],r8
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
8000471e:	34 4c       	mov	r12,68
80004720:	f0 1f 00 1d 	mcall	80004794 <prvAllocateTCBAndStack+0x88>
80004724:	18 98       	mov	r8,r12
80004726:	ef 48 ff fc 	st.w	r7[-4],r8

	if( pxNewTCB != NULL )
8000472a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000472e:	58 08       	cp.w	r8,0
80004730:	c2 c0       	breq	80004788 <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80004732:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004736:	58 08       	cp.w	r8,0
80004738:	c0 91       	brne	8000474a <prvAllocateTCBAndStack+0x3e>
8000473a:	ef 18 ff f8 	ld.uh	r8,r7[-8]
8000473e:	a3 68       	lsl	r8,0x2
80004740:	10 9c       	mov	r12,r8
80004742:	f0 1f 00 15 	mcall	80004794 <prvAllocateTCBAndStack+0x88>
80004746:	18 98       	mov	r8,r12
80004748:	c0 38       	rjmp	8000474e <prvAllocateTCBAndStack+0x42>
8000474a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000474e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004752:	93 c8       	st.w	r9[0x30],r8

		if( pxNewTCB->pxStack == NULL )
80004754:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004758:	70 c8       	ld.w	r8,r8[0x30]
8000475a:	58 08       	cp.w	r8,0
8000475c:	c0 91       	brne	8000476e <prvAllocateTCBAndStack+0x62>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
8000475e:	ee fc ff fc 	ld.w	r12,r7[-4]
80004762:	f0 1f 00 0e 	mcall	80004798 <prvAllocateTCBAndStack+0x8c>
			pxNewTCB = NULL;
80004766:	30 08       	mov	r8,0
80004768:	ef 48 ff fc 	st.w	r7[-4],r8
8000476c:	c0 e8       	rjmp	80004788 <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
8000476e:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80004772:	f0 09 15 02 	lsl	r9,r8,0x2
80004776:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000477a:	70 c8       	ld.w	r8,r8[0x30]
8000477c:	12 9a       	mov	r10,r9
8000477e:	e0 6b 00 a5 	mov	r11,165
80004782:	10 9c       	mov	r12,r8
80004784:	f0 1f 00 06 	mcall	8000479c <prvAllocateTCBAndStack+0x90>
		}
	}

	return pxNewTCB;
80004788:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000478c:	10 9c       	mov	r12,r8
8000478e:	2f dd       	sub	sp,-12
80004790:	e3 cd 80 80 	ldm	sp++,r7,pc
80004794:	80 00       	ld.sh	r0,r0[0x0]
80004796:	33 88       	mov	r8,56
80004798:	80 00       	ld.sh	r0,r0[0x0]
8000479a:	33 c4       	mov	r4,60
8000479c:	80 00       	ld.sh	r0,r0[0x0]
8000479e:	4d 98       	lddpc	r8,80004900 <_malloc_r+0xe4>

800047a0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
800047a0:	eb cd 40 80 	pushm	r7,lr
800047a4:	1a 97       	mov	r7,sp
800047a6:	20 1d       	sub	sp,4
800047a8:	ef 4c ff fc 	st.w	r7[-4],r12
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800047ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800047b0:	70 c8       	ld.w	r8,r8[0x30]
800047b2:	10 9c       	mov	r12,r8
800047b4:	f0 1f 00 05 	mcall	800047c8 <prvDeleteTCB+0x28>
		vPortFree( pxTCB );
800047b8:	ee fc ff fc 	ld.w	r12,r7[-4]
800047bc:	f0 1f 00 03 	mcall	800047c8 <prvDeleteTCB+0x28>
	}
800047c0:	2f fd       	sub	sp,-4
800047c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800047c6:	00 00       	add	r0,r0
800047c8:	80 00       	ld.sh	r0,r0[0x0]
800047ca:	33 c4       	mov	r4,60

800047cc <atexit>:
800047cc:	d4 01       	pushm	lr
800047ce:	30 09       	mov	r9,0
800047d0:	18 9b       	mov	r11,r12
800047d2:	12 9a       	mov	r10,r9
800047d4:	12 9c       	mov	r12,r9
800047d6:	e0 a0 03 39 	rcall	80004e48 <__register_exitproc>
800047da:	d8 02       	popm	pc

800047dc <exit>:
800047dc:	d4 21       	pushm	r4-r7,lr
800047de:	30 0b       	mov	r11,0
800047e0:	18 97       	mov	r7,r12
800047e2:	e0 a0 03 85 	rcall	80004eec <__call_exitprocs>
800047e6:	fe c8 f2 e2 	sub	r8,pc,-3358
800047ea:	70 0c       	ld.w	r12,r8[0x0]
800047ec:	78 a8       	ld.w	r8,r12[0x28]
800047ee:	58 08       	cp.w	r8,0
800047f0:	c0 20       	breq	800047f4 <exit+0x18>
800047f2:	5d 18       	icall	r8
800047f4:	0e 9c       	mov	r12,r7
800047f6:	e0 a0 03 08 	rcall	80004e06 <_exit>
800047fa:	d7 03       	nop

800047fc <free>:
800047fc:	d4 01       	pushm	lr
800047fe:	e0 68 01 14 	mov	r8,276
80004802:	18 9b       	mov	r11,r12
80004804:	70 0c       	ld.w	r12,r8[0x0]
80004806:	e0 a0 04 27 	rcall	80005054 <_free_r>
8000480a:	d8 02       	popm	pc

8000480c <malloc>:
8000480c:	d4 01       	pushm	lr
8000480e:	e0 68 01 14 	mov	r8,276
80004812:	18 9b       	mov	r11,r12
80004814:	70 0c       	ld.w	r12,r8[0x0]
80004816:	c0 3c       	rcall	8000481c <_malloc_r>
80004818:	d8 02       	popm	pc
8000481a:	d7 03       	nop

8000481c <_malloc_r>:
8000481c:	d4 31       	pushm	r0-r7,lr
8000481e:	f6 c8 ff f5 	sub	r8,r11,-11
80004822:	18 95       	mov	r5,r12
80004824:	10 97       	mov	r7,r8
80004826:	e0 17 ff f8 	andl	r7,0xfff8
8000482a:	59 68       	cp.w	r8,22
8000482c:	f9 b7 08 10 	movls	r7,16
80004830:	16 37       	cp.w	r7,r11
80004832:	5f 38       	srlo	r8
80004834:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80004838:	c0 50       	breq	80004842 <_malloc_r+0x26>
8000483a:	30 c8       	mov	r8,12
8000483c:	99 38       	st.w	r12[0xc],r8
8000483e:	e0 8f 01 f8 	bral	80004c2e <_malloc_r+0x412>
80004842:	fe b0 f3 b3 	rcall	80002fa8 <__malloc_lock>
80004846:	e0 47 01 f7 	cp.w	r7,503
8000484a:	e0 8b 00 1d 	brhi	80004884 <_malloc_r+0x68>
8000484e:	ee 03 16 03 	lsr	r3,r7,0x3
80004852:	e0 68 01 18 	mov	r8,280
80004856:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000485a:	70 36       	ld.w	r6,r8[0xc]
8000485c:	10 36       	cp.w	r6,r8
8000485e:	c0 61       	brne	8000486a <_malloc_r+0x4e>
80004860:	ec c8 ff f8 	sub	r8,r6,-8
80004864:	70 36       	ld.w	r6,r8[0xc]
80004866:	10 36       	cp.w	r6,r8
80004868:	c0 c0       	breq	80004880 <_malloc_r+0x64>
8000486a:	6c 18       	ld.w	r8,r6[0x4]
8000486c:	e0 18 ff fc 	andl	r8,0xfffc
80004870:	6c 3a       	ld.w	r10,r6[0xc]
80004872:	ec 08 00 09 	add	r9,r6,r8
80004876:	0a 9c       	mov	r12,r5
80004878:	6c 28       	ld.w	r8,r6[0x8]
8000487a:	95 28       	st.w	r10[0x8],r8
8000487c:	91 3a       	st.w	r8[0xc],r10
8000487e:	c4 78       	rjmp	8000490c <_malloc_r+0xf0>
80004880:	2f e3       	sub	r3,-2
80004882:	c4 d8       	rjmp	8000491c <_malloc_r+0x100>
80004884:	ee 03 16 09 	lsr	r3,r7,0x9
80004888:	c0 41       	brne	80004890 <_malloc_r+0x74>
8000488a:	ee 03 16 03 	lsr	r3,r7,0x3
8000488e:	c2 68       	rjmp	800048da <_malloc_r+0xbe>
80004890:	58 43       	cp.w	r3,4
80004892:	e0 8b 00 06 	brhi	8000489e <_malloc_r+0x82>
80004896:	ee 03 16 06 	lsr	r3,r7,0x6
8000489a:	2c 83       	sub	r3,-56
8000489c:	c1 f8       	rjmp	800048da <_malloc_r+0xbe>
8000489e:	59 43       	cp.w	r3,20
800048a0:	e0 8b 00 04 	brhi	800048a8 <_malloc_r+0x8c>
800048a4:	2a 53       	sub	r3,-91
800048a6:	c1 a8       	rjmp	800048da <_malloc_r+0xbe>
800048a8:	e0 43 00 54 	cp.w	r3,84
800048ac:	e0 8b 00 06 	brhi	800048b8 <_malloc_r+0x9c>
800048b0:	ee 03 16 0c 	lsr	r3,r7,0xc
800048b4:	29 23       	sub	r3,-110
800048b6:	c1 28       	rjmp	800048da <_malloc_r+0xbe>
800048b8:	e0 43 01 54 	cp.w	r3,340
800048bc:	e0 8b 00 06 	brhi	800048c8 <_malloc_r+0xac>
800048c0:	ee 03 16 0f 	lsr	r3,r7,0xf
800048c4:	28 93       	sub	r3,-119
800048c6:	c0 a8       	rjmp	800048da <_malloc_r+0xbe>
800048c8:	e0 43 05 54 	cp.w	r3,1364
800048cc:	e0 88 00 04 	brls	800048d4 <_malloc_r+0xb8>
800048d0:	37 e3       	mov	r3,126
800048d2:	c0 48       	rjmp	800048da <_malloc_r+0xbe>
800048d4:	ee 03 16 12 	lsr	r3,r7,0x12
800048d8:	28 43       	sub	r3,-124
800048da:	e0 6a 01 18 	mov	r10,280
800048de:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800048e2:	74 36       	ld.w	r6,r10[0xc]
800048e4:	c1 98       	rjmp	80004916 <_malloc_r+0xfa>
800048e6:	6c 19       	ld.w	r9,r6[0x4]
800048e8:	e0 19 ff fc 	andl	r9,0xfffc
800048ec:	f2 07 01 0b 	sub	r11,r9,r7
800048f0:	58 fb       	cp.w	r11,15
800048f2:	e0 8a 00 04 	brle	800048fa <_malloc_r+0xde>
800048f6:	20 13       	sub	r3,1
800048f8:	c1 18       	rjmp	8000491a <_malloc_r+0xfe>
800048fa:	6c 38       	ld.w	r8,r6[0xc]
800048fc:	58 0b       	cp.w	r11,0
800048fe:	c0 b5       	brlt	80004914 <_malloc_r+0xf8>
80004900:	6c 2a       	ld.w	r10,r6[0x8]
80004902:	ec 09 00 09 	add	r9,r6,r9
80004906:	0a 9c       	mov	r12,r5
80004908:	91 2a       	st.w	r8[0x8],r10
8000490a:	95 38       	st.w	r10[0xc],r8
8000490c:	72 18       	ld.w	r8,r9[0x4]
8000490e:	a1 a8       	sbr	r8,0x0
80004910:	93 18       	st.w	r9[0x4],r8
80004912:	cb c8       	rjmp	80004a8a <_malloc_r+0x26e>
80004914:	10 96       	mov	r6,r8
80004916:	14 36       	cp.w	r6,r10
80004918:	ce 71       	brne	800048e6 <_malloc_r+0xca>
8000491a:	2f f3       	sub	r3,-1
8000491c:	e0 6a 01 18 	mov	r10,280
80004920:	f4 cc ff f8 	sub	r12,r10,-8
80004924:	78 26       	ld.w	r6,r12[0x8]
80004926:	18 36       	cp.w	r6,r12
80004928:	c6 c0       	breq	80004a00 <_malloc_r+0x1e4>
8000492a:	6c 19       	ld.w	r9,r6[0x4]
8000492c:	e0 19 ff fc 	andl	r9,0xfffc
80004930:	f2 07 01 08 	sub	r8,r9,r7
80004934:	58 f8       	cp.w	r8,15
80004936:	e0 89 00 8f 	brgt	80004a54 <_malloc_r+0x238>
8000493a:	99 3c       	st.w	r12[0xc],r12
8000493c:	99 2c       	st.w	r12[0x8],r12
8000493e:	58 08       	cp.w	r8,0
80004940:	c0 55       	brlt	8000494a <_malloc_r+0x12e>
80004942:	ec 09 00 09 	add	r9,r6,r9
80004946:	0a 9c       	mov	r12,r5
80004948:	ce 2b       	rjmp	8000490c <_malloc_r+0xf0>
8000494a:	e0 49 01 ff 	cp.w	r9,511
8000494e:	e0 8b 00 13 	brhi	80004974 <_malloc_r+0x158>
80004952:	a3 99       	lsr	r9,0x3
80004954:	f4 09 00 38 	add	r8,r10,r9<<0x3
80004958:	70 2b       	ld.w	r11,r8[0x8]
8000495a:	8d 38       	st.w	r6[0xc],r8
8000495c:	8d 2b       	st.w	r6[0x8],r11
8000495e:	97 36       	st.w	r11[0xc],r6
80004960:	91 26       	st.w	r8[0x8],r6
80004962:	a3 49       	asr	r9,0x2
80004964:	74 18       	ld.w	r8,r10[0x4]
80004966:	30 1b       	mov	r11,1
80004968:	f6 09 09 49 	lsl	r9,r11,r9
8000496c:	f1 e9 10 09 	or	r9,r8,r9
80004970:	95 19       	st.w	r10[0x4],r9
80004972:	c4 78       	rjmp	80004a00 <_malloc_r+0x1e4>
80004974:	f2 0a 16 09 	lsr	r10,r9,0x9
80004978:	58 4a       	cp.w	r10,4
8000497a:	e0 8b 00 07 	brhi	80004988 <_malloc_r+0x16c>
8000497e:	f2 0a 16 06 	lsr	r10,r9,0x6
80004982:	2c 8a       	sub	r10,-56
80004984:	c2 08       	rjmp	800049c4 <_malloc_r+0x1a8>
80004986:	d7 03       	nop
80004988:	59 4a       	cp.w	r10,20
8000498a:	e0 8b 00 04 	brhi	80004992 <_malloc_r+0x176>
8000498e:	2a 5a       	sub	r10,-91
80004990:	c1 a8       	rjmp	800049c4 <_malloc_r+0x1a8>
80004992:	e0 4a 00 54 	cp.w	r10,84
80004996:	e0 8b 00 06 	brhi	800049a2 <_malloc_r+0x186>
8000499a:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000499e:	29 2a       	sub	r10,-110
800049a0:	c1 28       	rjmp	800049c4 <_malloc_r+0x1a8>
800049a2:	e0 4a 01 54 	cp.w	r10,340
800049a6:	e0 8b 00 06 	brhi	800049b2 <_malloc_r+0x196>
800049aa:	f2 0a 16 0f 	lsr	r10,r9,0xf
800049ae:	28 9a       	sub	r10,-119
800049b0:	c0 a8       	rjmp	800049c4 <_malloc_r+0x1a8>
800049b2:	e0 4a 05 54 	cp.w	r10,1364
800049b6:	e0 88 00 04 	brls	800049be <_malloc_r+0x1a2>
800049ba:	37 ea       	mov	r10,126
800049bc:	c0 48       	rjmp	800049c4 <_malloc_r+0x1a8>
800049be:	f2 0a 16 12 	lsr	r10,r9,0x12
800049c2:	28 4a       	sub	r10,-124
800049c4:	e0 6b 01 18 	mov	r11,280
800049c8:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800049cc:	68 28       	ld.w	r8,r4[0x8]
800049ce:	08 38       	cp.w	r8,r4
800049d0:	c0 e1       	brne	800049ec <_malloc_r+0x1d0>
800049d2:	76 19       	ld.w	r9,r11[0x4]
800049d4:	a3 4a       	asr	r10,0x2
800049d6:	30 1e       	mov	lr,1
800049d8:	fc 0a 09 4a 	lsl	r10,lr,r10
800049dc:	f3 ea 10 0a 	or	r10,r9,r10
800049e0:	10 99       	mov	r9,r8
800049e2:	97 1a       	st.w	r11[0x4],r10
800049e4:	c0 a8       	rjmp	800049f8 <_malloc_r+0x1dc>
800049e6:	70 28       	ld.w	r8,r8[0x8]
800049e8:	08 38       	cp.w	r8,r4
800049ea:	c0 60       	breq	800049f6 <_malloc_r+0x1da>
800049ec:	70 1a       	ld.w	r10,r8[0x4]
800049ee:	e0 1a ff fc 	andl	r10,0xfffc
800049f2:	14 39       	cp.w	r9,r10
800049f4:	cf 93       	brcs	800049e6 <_malloc_r+0x1ca>
800049f6:	70 39       	ld.w	r9,r8[0xc]
800049f8:	8d 39       	st.w	r6[0xc],r9
800049fa:	8d 28       	st.w	r6[0x8],r8
800049fc:	91 36       	st.w	r8[0xc],r6
800049fe:	93 26       	st.w	r9[0x8],r6
80004a00:	e6 08 14 02 	asr	r8,r3,0x2
80004a04:	30 1b       	mov	r11,1
80004a06:	e0 64 01 18 	mov	r4,280
80004a0a:	f6 08 09 4b 	lsl	r11,r11,r8
80004a0e:	68 18       	ld.w	r8,r4[0x4]
80004a10:	10 3b       	cp.w	r11,r8
80004a12:	e0 8b 00 6b 	brhi	80004ae8 <_malloc_r+0x2cc>
80004a16:	f7 e8 00 09 	and	r9,r11,r8
80004a1a:	c0 b1       	brne	80004a30 <_malloc_r+0x214>
80004a1c:	e0 13 ff fc 	andl	r3,0xfffc
80004a20:	a1 7b       	lsl	r11,0x1
80004a22:	2f c3       	sub	r3,-4
80004a24:	c0 38       	rjmp	80004a2a <_malloc_r+0x20e>
80004a26:	2f c3       	sub	r3,-4
80004a28:	a1 7b       	lsl	r11,0x1
80004a2a:	f7 e8 00 09 	and	r9,r11,r8
80004a2e:	cf c0       	breq	80004a26 <_malloc_r+0x20a>
80004a30:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80004a34:	06 92       	mov	r2,r3
80004a36:	1c 91       	mov	r1,lr
80004a38:	62 36       	ld.w	r6,r1[0xc]
80004a3a:	c2 e8       	rjmp	80004a96 <_malloc_r+0x27a>
80004a3c:	6c 1a       	ld.w	r10,r6[0x4]
80004a3e:	e0 1a ff fc 	andl	r10,0xfffc
80004a42:	f4 07 01 08 	sub	r8,r10,r7
80004a46:	58 f8       	cp.w	r8,15
80004a48:	e0 8a 00 15 	brle	80004a72 <_malloc_r+0x256>
80004a4c:	6c 3a       	ld.w	r10,r6[0xc]
80004a4e:	6c 29       	ld.w	r9,r6[0x8]
80004a50:	95 29       	st.w	r10[0x8],r9
80004a52:	93 3a       	st.w	r9[0xc],r10
80004a54:	0e 99       	mov	r9,r7
80004a56:	ec 07 00 07 	add	r7,r6,r7
80004a5a:	a1 a9       	sbr	r9,0x0
80004a5c:	99 37       	st.w	r12[0xc],r7
80004a5e:	99 27       	st.w	r12[0x8],r7
80004a60:	8d 19       	st.w	r6[0x4],r9
80004a62:	ee 08 09 08 	st.w	r7[r8],r8
80004a66:	8f 2c       	st.w	r7[0x8],r12
80004a68:	8f 3c       	st.w	r7[0xc],r12
80004a6a:	a1 a8       	sbr	r8,0x0
80004a6c:	0a 9c       	mov	r12,r5
80004a6e:	8f 18       	st.w	r7[0x4],r8
80004a70:	c0 d8       	rjmp	80004a8a <_malloc_r+0x26e>
80004a72:	6c 39       	ld.w	r9,r6[0xc]
80004a74:	58 08       	cp.w	r8,0
80004a76:	c0 f5       	brlt	80004a94 <_malloc_r+0x278>
80004a78:	ec 0a 00 0a 	add	r10,r6,r10
80004a7c:	74 18       	ld.w	r8,r10[0x4]
80004a7e:	a1 a8       	sbr	r8,0x0
80004a80:	0a 9c       	mov	r12,r5
80004a82:	95 18       	st.w	r10[0x4],r8
80004a84:	6c 28       	ld.w	r8,r6[0x8]
80004a86:	93 28       	st.w	r9[0x8],r8
80004a88:	91 39       	st.w	r8[0xc],r9
80004a8a:	fe b0 f2 9d 	rcall	80002fc4 <__malloc_unlock>
80004a8e:	ec cc ff f8 	sub	r12,r6,-8
80004a92:	d8 32       	popm	r0-r7,pc
80004a94:	12 96       	mov	r6,r9
80004a96:	02 36       	cp.w	r6,r1
80004a98:	cd 21       	brne	80004a3c <_malloc_r+0x220>
80004a9a:	2f f2       	sub	r2,-1
80004a9c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80004aa0:	c0 30       	breq	80004aa6 <_malloc_r+0x28a>
80004aa2:	2f 81       	sub	r1,-8
80004aa4:	cc ab       	rjmp	80004a38 <_malloc_r+0x21c>
80004aa6:	1c 98       	mov	r8,lr
80004aa8:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80004aac:	c0 81       	brne	80004abc <_malloc_r+0x2a0>
80004aae:	68 19       	ld.w	r9,r4[0x4]
80004ab0:	f6 08 11 ff 	rsub	r8,r11,-1
80004ab4:	f3 e8 00 08 	and	r8,r9,r8
80004ab8:	89 18       	st.w	r4[0x4],r8
80004aba:	c0 78       	rjmp	80004ac8 <_malloc_r+0x2ac>
80004abc:	f0 c9 00 08 	sub	r9,r8,8
80004ac0:	20 13       	sub	r3,1
80004ac2:	70 08       	ld.w	r8,r8[0x0]
80004ac4:	12 38       	cp.w	r8,r9
80004ac6:	cf 10       	breq	80004aa8 <_malloc_r+0x28c>
80004ac8:	a1 7b       	lsl	r11,0x1
80004aca:	68 18       	ld.w	r8,r4[0x4]
80004acc:	10 3b       	cp.w	r11,r8
80004ace:	e0 8b 00 0d 	brhi	80004ae8 <_malloc_r+0x2cc>
80004ad2:	58 0b       	cp.w	r11,0
80004ad4:	c0 a0       	breq	80004ae8 <_malloc_r+0x2cc>
80004ad6:	04 93       	mov	r3,r2
80004ad8:	c0 38       	rjmp	80004ade <_malloc_r+0x2c2>
80004ada:	2f c3       	sub	r3,-4
80004adc:	a1 7b       	lsl	r11,0x1
80004ade:	f7 e8 00 09 	and	r9,r11,r8
80004ae2:	ca 71       	brne	80004a30 <_malloc_r+0x214>
80004ae4:	cf bb       	rjmp	80004ada <_malloc_r+0x2be>
80004ae6:	d7 03       	nop
80004ae8:	68 23       	ld.w	r3,r4[0x8]
80004aea:	66 12       	ld.w	r2,r3[0x4]
80004aec:	e0 12 ff fc 	andl	r2,0xfffc
80004af0:	0e 32       	cp.w	r2,r7
80004af2:	5f 39       	srlo	r9
80004af4:	e4 07 01 08 	sub	r8,r2,r7
80004af8:	58 f8       	cp.w	r8,15
80004afa:	5f aa       	srle	r10
80004afc:	f5 e9 10 09 	or	r9,r10,r9
80004b00:	e0 80 00 98 	breq	80004c30 <_malloc_r+0x414>
80004b04:	e0 68 07 64 	mov	r8,1892
80004b08:	70 01       	ld.w	r1,r8[0x0]
80004b0a:	e0 68 05 24 	mov	r8,1316
80004b0e:	2f 01       	sub	r1,-16
80004b10:	70 08       	ld.w	r8,r8[0x0]
80004b12:	0e 01       	add	r1,r7
80004b14:	5b f8       	cp.w	r8,-1
80004b16:	c0 40       	breq	80004b1e <_malloc_r+0x302>
80004b18:	28 11       	sub	r1,-127
80004b1a:	e0 11 ff 80 	andl	r1,0xff80
80004b1e:	02 9b       	mov	r11,r1
80004b20:	0a 9c       	mov	r12,r5
80004b22:	c4 3d       	rcall	80004da8 <_sbrk_r>
80004b24:	18 96       	mov	r6,r12
80004b26:	5b fc       	cp.w	r12,-1
80004b28:	c7 40       	breq	80004c10 <_malloc_r+0x3f4>
80004b2a:	e6 02 00 08 	add	r8,r3,r2
80004b2e:	10 3c       	cp.w	r12,r8
80004b30:	c0 32       	brcc	80004b36 <_malloc_r+0x31a>
80004b32:	08 33       	cp.w	r3,r4
80004b34:	c6 e1       	brne	80004c10 <_malloc_r+0x3f4>
80004b36:	e0 6a 07 68 	mov	r10,1896
80004b3a:	74 09       	ld.w	r9,r10[0x0]
80004b3c:	e2 09 00 09 	add	r9,r1,r9
80004b40:	95 09       	st.w	r10[0x0],r9
80004b42:	10 36       	cp.w	r6,r8
80004b44:	c0 a1       	brne	80004b58 <_malloc_r+0x33c>
80004b46:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80004b4a:	c0 71       	brne	80004b58 <_malloc_r+0x33c>
80004b4c:	e2 02 00 02 	add	r2,r1,r2
80004b50:	68 28       	ld.w	r8,r4[0x8]
80004b52:	a1 a2       	sbr	r2,0x0
80004b54:	91 12       	st.w	r8[0x4],r2
80004b56:	c4 e8       	rjmp	80004bf2 <_malloc_r+0x3d6>
80004b58:	e0 6a 05 24 	mov	r10,1316
80004b5c:	74 0b       	ld.w	r11,r10[0x0]
80004b5e:	5b fb       	cp.w	r11,-1
80004b60:	c0 31       	brne	80004b66 <_malloc_r+0x34a>
80004b62:	95 06       	st.w	r10[0x0],r6
80004b64:	c0 78       	rjmp	80004b72 <_malloc_r+0x356>
80004b66:	ec 09 00 09 	add	r9,r6,r9
80004b6a:	e0 6a 07 68 	mov	r10,1896
80004b6e:	10 19       	sub	r9,r8
80004b70:	95 09       	st.w	r10[0x0],r9
80004b72:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80004b76:	f0 09 11 08 	rsub	r9,r8,8
80004b7a:	58 08       	cp.w	r8,0
80004b7c:	f2 08 17 10 	movne	r8,r9
80004b80:	ed d8 e1 06 	addne	r6,r6,r8
80004b84:	28 08       	sub	r8,-128
80004b86:	ec 01 00 01 	add	r1,r6,r1
80004b8a:	0a 9c       	mov	r12,r5
80004b8c:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80004b90:	f0 01 01 01 	sub	r1,r8,r1
80004b94:	02 9b       	mov	r11,r1
80004b96:	c0 9d       	rcall	80004da8 <_sbrk_r>
80004b98:	e0 68 07 68 	mov	r8,1896
80004b9c:	5b fc       	cp.w	r12,-1
80004b9e:	ec 0c 17 00 	moveq	r12,r6
80004ba2:	f9 b1 00 00 	moveq	r1,0
80004ba6:	70 09       	ld.w	r9,r8[0x0]
80004ba8:	0c 1c       	sub	r12,r6
80004baa:	89 26       	st.w	r4[0x8],r6
80004bac:	02 0c       	add	r12,r1
80004bae:	12 01       	add	r1,r9
80004bb0:	a1 ac       	sbr	r12,0x0
80004bb2:	91 01       	st.w	r8[0x0],r1
80004bb4:	8d 1c       	st.w	r6[0x4],r12
80004bb6:	08 33       	cp.w	r3,r4
80004bb8:	c1 d0       	breq	80004bf2 <_malloc_r+0x3d6>
80004bba:	58 f2       	cp.w	r2,15
80004bbc:	e0 8b 00 05 	brhi	80004bc6 <_malloc_r+0x3aa>
80004bc0:	30 18       	mov	r8,1
80004bc2:	8d 18       	st.w	r6[0x4],r8
80004bc4:	c2 68       	rjmp	80004c10 <_malloc_r+0x3f4>
80004bc6:	30 59       	mov	r9,5
80004bc8:	20 c2       	sub	r2,12
80004bca:	e0 12 ff f8 	andl	r2,0xfff8
80004bce:	e6 02 00 08 	add	r8,r3,r2
80004bd2:	91 29       	st.w	r8[0x8],r9
80004bd4:	91 19       	st.w	r8[0x4],r9
80004bd6:	66 18       	ld.w	r8,r3[0x4]
80004bd8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004bdc:	e5 e8 10 08 	or	r8,r2,r8
80004be0:	87 18       	st.w	r3[0x4],r8
80004be2:	58 f2       	cp.w	r2,15
80004be4:	e0 88 00 07 	brls	80004bf2 <_malloc_r+0x3d6>
80004be8:	e6 cb ff f8 	sub	r11,r3,-8
80004bec:	0a 9c       	mov	r12,r5
80004bee:	e0 a0 02 33 	rcall	80005054 <_free_r>
80004bf2:	e0 69 07 60 	mov	r9,1888
80004bf6:	72 0a       	ld.w	r10,r9[0x0]
80004bf8:	e0 68 07 68 	mov	r8,1896
80004bfc:	70 08       	ld.w	r8,r8[0x0]
80004bfe:	14 38       	cp.w	r8,r10
80004c00:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80004c04:	e0 69 07 5c 	mov	r9,1884
80004c08:	72 0a       	ld.w	r10,r9[0x0]
80004c0a:	14 38       	cp.w	r8,r10
80004c0c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80004c10:	68 28       	ld.w	r8,r4[0x8]
80004c12:	70 18       	ld.w	r8,r8[0x4]
80004c14:	e0 18 ff fc 	andl	r8,0xfffc
80004c18:	0e 38       	cp.w	r8,r7
80004c1a:	5f 39       	srlo	r9
80004c1c:	0e 18       	sub	r8,r7
80004c1e:	58 f8       	cp.w	r8,15
80004c20:	5f aa       	srle	r10
80004c22:	f5 e9 10 09 	or	r9,r10,r9
80004c26:	c0 50       	breq	80004c30 <_malloc_r+0x414>
80004c28:	0a 9c       	mov	r12,r5
80004c2a:	fe b0 f1 cd 	rcall	80002fc4 <__malloc_unlock>
80004c2e:	d8 3a       	popm	r0-r7,pc,r12=0
80004c30:	68 26       	ld.w	r6,r4[0x8]
80004c32:	a1 a8       	sbr	r8,0x0
80004c34:	0e 99       	mov	r9,r7
80004c36:	a1 a9       	sbr	r9,0x0
80004c38:	8d 19       	st.w	r6[0x4],r9
80004c3a:	ec 07 00 07 	add	r7,r6,r7
80004c3e:	0a 9c       	mov	r12,r5
80004c40:	89 27       	st.w	r4[0x8],r7
80004c42:	8f 18       	st.w	r7[0x4],r8
80004c44:	fe b0 f1 c0 	rcall	80002fc4 <__malloc_unlock>
80004c48:	ec cc ff f8 	sub	r12,r6,-8
80004c4c:	d8 32       	popm	r0-r7,pc
80004c4e:	d7 03       	nop

80004c50 <memcpy>:
80004c50:	58 8a       	cp.w	r10,8
80004c52:	c2 f5       	brlt	80004cb0 <memcpy+0x60>
80004c54:	f9 eb 10 09 	or	r9,r12,r11
80004c58:	e2 19 00 03 	andl	r9,0x3,COH
80004c5c:	e0 81 00 97 	brne	80004d8a <memcpy+0x13a>
80004c60:	e0 4a 00 20 	cp.w	r10,32
80004c64:	c3 b4       	brge	80004cda <memcpy+0x8a>
80004c66:	f4 08 14 02 	asr	r8,r10,0x2
80004c6a:	f0 09 11 08 	rsub	r9,r8,8
80004c6e:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80004c72:	76 69       	ld.w	r9,r11[0x18]
80004c74:	99 69       	st.w	r12[0x18],r9
80004c76:	76 59       	ld.w	r9,r11[0x14]
80004c78:	99 59       	st.w	r12[0x14],r9
80004c7a:	76 49       	ld.w	r9,r11[0x10]
80004c7c:	99 49       	st.w	r12[0x10],r9
80004c7e:	76 39       	ld.w	r9,r11[0xc]
80004c80:	99 39       	st.w	r12[0xc],r9
80004c82:	76 29       	ld.w	r9,r11[0x8]
80004c84:	99 29       	st.w	r12[0x8],r9
80004c86:	76 19       	ld.w	r9,r11[0x4]
80004c88:	99 19       	st.w	r12[0x4],r9
80004c8a:	76 09       	ld.w	r9,r11[0x0]
80004c8c:	99 09       	st.w	r12[0x0],r9
80004c8e:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80004c92:	f8 08 00 28 	add	r8,r12,r8<<0x2
80004c96:	e0 1a 00 03 	andl	r10,0x3
80004c9a:	f4 0a 11 04 	rsub	r10,r10,4
80004c9e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80004ca2:	17 a9       	ld.ub	r9,r11[0x2]
80004ca4:	b0 a9       	st.b	r8[0x2],r9
80004ca6:	17 99       	ld.ub	r9,r11[0x1]
80004ca8:	b0 99       	st.b	r8[0x1],r9
80004caa:	17 89       	ld.ub	r9,r11[0x0]
80004cac:	b0 89       	st.b	r8[0x0],r9
80004cae:	5e fc       	retal	r12
80004cb0:	f4 0a 11 09 	rsub	r10,r10,9
80004cb4:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80004cb8:	17 f9       	ld.ub	r9,r11[0x7]
80004cba:	b8 f9       	st.b	r12[0x7],r9
80004cbc:	17 e9       	ld.ub	r9,r11[0x6]
80004cbe:	b8 e9       	st.b	r12[0x6],r9
80004cc0:	17 d9       	ld.ub	r9,r11[0x5]
80004cc2:	b8 d9       	st.b	r12[0x5],r9
80004cc4:	17 c9       	ld.ub	r9,r11[0x4]
80004cc6:	b8 c9       	st.b	r12[0x4],r9
80004cc8:	17 b9       	ld.ub	r9,r11[0x3]
80004cca:	b8 b9       	st.b	r12[0x3],r9
80004ccc:	17 a9       	ld.ub	r9,r11[0x2]
80004cce:	b8 a9       	st.b	r12[0x2],r9
80004cd0:	17 99       	ld.ub	r9,r11[0x1]
80004cd2:	b8 99       	st.b	r12[0x1],r9
80004cd4:	17 89       	ld.ub	r9,r11[0x0]
80004cd6:	b8 89       	st.b	r12[0x0],r9
80004cd8:	5e fc       	retal	r12
80004cda:	eb cd 40 c0 	pushm	r6-r7,lr
80004cde:	18 99       	mov	r9,r12
80004ce0:	22 0a       	sub	r10,32
80004ce2:	b7 07       	ld.d	r6,r11++
80004ce4:	b3 26       	st.d	r9++,r6
80004ce6:	b7 07       	ld.d	r6,r11++
80004ce8:	b3 26       	st.d	r9++,r6
80004cea:	b7 07       	ld.d	r6,r11++
80004cec:	b3 26       	st.d	r9++,r6
80004cee:	b7 07       	ld.d	r6,r11++
80004cf0:	b3 26       	st.d	r9++,r6
80004cf2:	22 0a       	sub	r10,32
80004cf4:	cf 74       	brge	80004ce2 <memcpy+0x92>
80004cf6:	2f 0a       	sub	r10,-16
80004cf8:	c0 65       	brlt	80004d04 <memcpy+0xb4>
80004cfa:	b7 07       	ld.d	r6,r11++
80004cfc:	b3 26       	st.d	r9++,r6
80004cfe:	b7 07       	ld.d	r6,r11++
80004d00:	b3 26       	st.d	r9++,r6
80004d02:	21 0a       	sub	r10,16
80004d04:	5c 3a       	neg	r10
80004d06:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80004d0a:	d7 03       	nop
80004d0c:	d7 03       	nop
80004d0e:	f7 36 00 0e 	ld.ub	r6,r11[14]
80004d12:	f3 66 00 0e 	st.b	r9[14],r6
80004d16:	f7 36 00 0d 	ld.ub	r6,r11[13]
80004d1a:	f3 66 00 0d 	st.b	r9[13],r6
80004d1e:	f7 36 00 0c 	ld.ub	r6,r11[12]
80004d22:	f3 66 00 0c 	st.b	r9[12],r6
80004d26:	f7 36 00 0b 	ld.ub	r6,r11[11]
80004d2a:	f3 66 00 0b 	st.b	r9[11],r6
80004d2e:	f7 36 00 0a 	ld.ub	r6,r11[10]
80004d32:	f3 66 00 0a 	st.b	r9[10],r6
80004d36:	f7 36 00 09 	ld.ub	r6,r11[9]
80004d3a:	f3 66 00 09 	st.b	r9[9],r6
80004d3e:	f7 36 00 08 	ld.ub	r6,r11[8]
80004d42:	f3 66 00 08 	st.b	r9[8],r6
80004d46:	f7 36 00 07 	ld.ub	r6,r11[7]
80004d4a:	f3 66 00 07 	st.b	r9[7],r6
80004d4e:	f7 36 00 06 	ld.ub	r6,r11[6]
80004d52:	f3 66 00 06 	st.b	r9[6],r6
80004d56:	f7 36 00 05 	ld.ub	r6,r11[5]
80004d5a:	f3 66 00 05 	st.b	r9[5],r6
80004d5e:	f7 36 00 04 	ld.ub	r6,r11[4]
80004d62:	f3 66 00 04 	st.b	r9[4],r6
80004d66:	f7 36 00 03 	ld.ub	r6,r11[3]
80004d6a:	f3 66 00 03 	st.b	r9[3],r6
80004d6e:	f7 36 00 02 	ld.ub	r6,r11[2]
80004d72:	f3 66 00 02 	st.b	r9[2],r6
80004d76:	f7 36 00 01 	ld.ub	r6,r11[1]
80004d7a:	f3 66 00 01 	st.b	r9[1],r6
80004d7e:	f7 36 00 00 	ld.ub	r6,r11[0]
80004d82:	f3 66 00 00 	st.b	r9[0],r6
80004d86:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d8a:	20 1a       	sub	r10,1
80004d8c:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80004d90:	f8 0a 0b 09 	st.b	r12[r10],r9
80004d94:	cf b1       	brne	80004d8a <memcpy+0x13a>
80004d96:	5e fc       	retal	r12

80004d98 <memset>:
80004d98:	18 98       	mov	r8,r12
80004d9a:	c0 38       	rjmp	80004da0 <memset+0x8>
80004d9c:	10 cb       	st.b	r8++,r11
80004d9e:	20 1a       	sub	r10,1
80004da0:	58 0a       	cp.w	r10,0
80004da2:	cf d1       	brne	80004d9c <memset+0x4>
80004da4:	5e fc       	retal	r12
80004da6:	d7 03       	nop

80004da8 <_sbrk_r>:
80004da8:	d4 21       	pushm	r4-r7,lr
80004daa:	30 08       	mov	r8,0
80004dac:	18 97       	mov	r7,r12
80004dae:	e0 66 07 a8 	mov	r6,1960
80004db2:	16 9c       	mov	r12,r11
80004db4:	8d 08       	st.w	r6[0x0],r8
80004db6:	c2 dc       	rcall	80004e10 <_sbrk>
80004db8:	5b fc       	cp.w	r12,-1
80004dba:	c0 51       	brne	80004dc4 <_sbrk_r+0x1c>
80004dbc:	6c 08       	ld.w	r8,r6[0x0]
80004dbe:	58 08       	cp.w	r8,0
80004dc0:	ef f8 1a 03 	st.wne	r7[0xc],r8
80004dc4:	d8 22       	popm	r4-r7,pc
80004dc6:	d7 03       	nop

80004dc8 <strcpy>:
80004dc8:	30 08       	mov	r8,0
80004dca:	f6 08 07 09 	ld.ub	r9,r11[r8]
80004dce:	f8 08 0b 09 	st.b	r12[r8],r9
80004dd2:	2f f8       	sub	r8,-1
80004dd4:	58 09       	cp.w	r9,0
80004dd6:	cf a1       	brne	80004dca <strcpy+0x2>
80004dd8:	5e fc       	retal	r12
80004dda:	d7 03       	nop

80004ddc <strncpy>:
80004ddc:	30 08       	mov	r8,0
80004dde:	10 3a       	cp.w	r10,r8
80004de0:	5e 0c       	reteq	r12
80004de2:	f6 08 07 09 	ld.ub	r9,r11[r8]
80004de6:	f8 08 0b 09 	st.b	r12[r8],r9
80004dea:	2f f8       	sub	r8,-1
80004dec:	58 09       	cp.w	r9,0
80004dee:	cf 81       	brne	80004dde <strncpy+0x2>
80004df0:	10 3a       	cp.w	r10,r8
80004df2:	5e 0c       	reteq	r12
80004df4:	f8 08 0b 09 	st.b	r12[r8],r9
80004df8:	2f f8       	sub	r8,-1
80004dfa:	cf bb       	rjmp	80004df0 <strncpy+0x14>

80004dfc <_init_argv>:
80004dfc:	30 e8       	mov	r8,14
80004dfe:	d6 73       	breakpoint
80004e00:	3f fc       	mov	r12,-1
80004e02:	35 8b       	mov	r11,88
80004e04:	5e fc       	retal	r12

80004e06 <_exit>:
80004e06:	30 d8       	mov	r8,13
80004e08:	d6 73       	breakpoint
80004e0a:	3f fc       	mov	r12,-1
80004e0c:	35 8b       	mov	r11,88
80004e0e:	c0 08       	rjmp	80004e0e <_exit+0x8>

80004e10 <_sbrk>:
80004e10:	d4 01       	pushm	lr
80004e12:	e0 68 07 90 	mov	r8,1936
80004e16:	70 09       	ld.w	r9,r8[0x0]
80004e18:	58 09       	cp.w	r9,0
80004e1a:	c0 41       	brne	80004e22 <_sbrk+0x12>
80004e1c:	e0 69 07 b0 	mov	r9,1968
80004e20:	91 09       	st.w	r8[0x0],r9
80004e22:	e0 69 07 90 	mov	r9,1936
80004e26:	e0 6a f0 00 	mov	r10,61440
80004e2a:	72 08       	ld.w	r8,r9[0x0]
80004e2c:	f0 0c 00 0c 	add	r12,r8,r12
80004e30:	14 3c       	cp.w	r12,r10
80004e32:	e0 8b 00 04 	brhi	80004e3a <_sbrk+0x2a>
80004e36:	93 0c       	st.w	r9[0x0],r12
80004e38:	c0 58       	rjmp	80004e42 <_sbrk+0x32>
80004e3a:	cb fc       	rcall	80004fb8 <__errno>
80004e3c:	30 c8       	mov	r8,12
80004e3e:	99 08       	st.w	r12[0x0],r8
80004e40:	3f f8       	mov	r8,-1
80004e42:	10 9c       	mov	r12,r8
80004e44:	d8 02       	popm	pc
80004e46:	d7 03       	nop

80004e48 <__register_exitproc>:
80004e48:	d4 31       	pushm	r0-r7,lr
80004e4a:	fe c8 f9 46 	sub	r8,pc,-1722
80004e4e:	70 03       	ld.w	r3,r8[0x0]
80004e50:	67 24       	ld.w	r4,r3[0x48]
80004e52:	e6 c8 ff b4 	sub	r8,r3,-76
80004e56:	58 04       	cp.w	r4,0
80004e58:	f0 04 17 00 	moveq	r4,r8
80004e5c:	e7 f4 0a 12 	st.weq	r3[0x48],r4
80004e60:	18 97       	mov	r7,r12
80004e62:	16 96       	mov	r6,r11
80004e64:	14 95       	mov	r5,r10
80004e66:	12 92       	mov	r2,r9
80004e68:	68 18       	ld.w	r8,r4[0x4]
80004e6a:	59 f8       	cp.w	r8,31
80004e6c:	e0 8a 00 0e 	brle	80004e88 <__register_exitproc+0x40>
80004e70:	e0 6c 00 8c 	mov	r12,140
80004e74:	fe b0 fc cc 	rcall	8000480c <malloc>
80004e78:	18 94       	mov	r4,r12
80004e7a:	c3 80       	breq	80004eea <__register_exitproc+0xa2>
80004e7c:	67 28       	ld.w	r8,r3[0x48]
80004e7e:	99 08       	st.w	r12[0x0],r8
80004e80:	e7 4c 00 48 	st.w	r3[72],r12
80004e84:	30 08       	mov	r8,0
80004e86:	99 18       	st.w	r12[0x4],r8
80004e88:	58 07       	cp.w	r7,0
80004e8a:	c2 70       	breq	80004ed8 <__register_exitproc+0x90>
80004e8c:	e8 fc 00 88 	ld.w	r12,r4[136]
80004e90:	58 0c       	cp.w	r12,0
80004e92:	c0 d1       	brne	80004eac <__register_exitproc+0x64>
80004e94:	e0 6c 01 08 	mov	r12,264
80004e98:	fe b0 fc ba 	rcall	8000480c <malloc>
80004e9c:	c2 70       	breq	80004eea <__register_exitproc+0xa2>
80004e9e:	30 08       	mov	r8,0
80004ea0:	e9 4c 00 88 	st.w	r4[136],r12
80004ea4:	f9 48 01 04 	st.w	r12[260],r8
80004ea8:	f9 48 01 00 	st.w	r12[256],r8
80004eac:	68 18       	ld.w	r8,r4[0x4]
80004eae:	f0 c9 ff e0 	sub	r9,r8,-32
80004eb2:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
80004eb6:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
80004eba:	30 1a       	mov	r10,1
80004ebc:	f8 f9 01 00 	ld.w	r9,r12[256]
80004ec0:	f4 08 09 48 	lsl	r8,r10,r8
80004ec4:	10 49       	or	r9,r8
80004ec6:	f9 49 01 00 	st.w	r12[256],r9
80004eca:	58 27       	cp.w	r7,2
80004ecc:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
80004ed0:	f3 d8 e0 38 	oreq	r8,r9,r8
80004ed4:	f9 f8 0a 41 	st.weq	r12[0x104],r8
80004ed8:	68 18       	ld.w	r8,r4[0x4]
80004eda:	30 0c       	mov	r12,0
80004edc:	f0 c9 ff ff 	sub	r9,r8,-1
80004ee0:	2f e8       	sub	r8,-2
80004ee2:	89 19       	st.w	r4[0x4],r9
80004ee4:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
80004ee8:	d8 32       	popm	r0-r7,pc
80004eea:	dc 3a       	popm	r0-r7,pc,r12=-1

80004eec <__call_exitprocs>:
80004eec:	d4 31       	pushm	r0-r7,lr
80004eee:	20 3d       	sub	sp,12
80004ef0:	fe c8 f9 ec 	sub	r8,pc,-1556
80004ef4:	50 2c       	stdsp	sp[0x8],r12
80004ef6:	70 08       	ld.w	r8,r8[0x0]
80004ef8:	16 91       	mov	r1,r11
80004efa:	50 08       	stdsp	sp[0x0],r8
80004efc:	2b 88       	sub	r8,-72
80004efe:	50 18       	stdsp	sp[0x4],r8
80004f00:	40 0a       	lddsp	r10,sp[0x0]
80004f02:	40 14       	lddsp	r4,sp[0x4]
80004f04:	75 27       	ld.w	r7,r10[0x48]
80004f06:	c5 58       	rjmp	80004fb0 <__call_exitprocs+0xc4>
80004f08:	6e 15       	ld.w	r5,r7[0x4]
80004f0a:	ee f6 00 88 	ld.w	r6,r7[136]
80004f0e:	ea c2 ff ff 	sub	r2,r5,-1
80004f12:	20 15       	sub	r5,1
80004f14:	ee 02 00 22 	add	r2,r7,r2<<0x2
80004f18:	ec 05 00 23 	add	r3,r6,r5<<0x2
80004f1c:	c3 58       	rjmp	80004f86 <__call_exitprocs+0x9a>
80004f1e:	58 01       	cp.w	r1,0
80004f20:	c0 70       	breq	80004f2e <__call_exitprocs+0x42>
80004f22:	58 06       	cp.w	r6,0
80004f24:	c2 e0       	breq	80004f80 <__call_exitprocs+0x94>
80004f26:	e6 f8 00 80 	ld.w	r8,r3[128]
80004f2a:	02 38       	cp.w	r8,r1
80004f2c:	c2 a1       	brne	80004f80 <__call_exitprocs+0x94>
80004f2e:	6e 19       	ld.w	r9,r7[0x4]
80004f30:	64 08       	ld.w	r8,r2[0x0]
80004f32:	20 19       	sub	r9,1
80004f34:	12 35       	cp.w	r5,r9
80004f36:	ef f5 0a 01 	st.weq	r7[0x4],r5
80004f3a:	f9 b9 01 00 	movne	r9,0
80004f3e:	e5 f9 1a 00 	st.wne	r2[0x0],r9
80004f42:	58 08       	cp.w	r8,0
80004f44:	c1 e0       	breq	80004f80 <__call_exitprocs+0x94>
80004f46:	6e 10       	ld.w	r0,r7[0x4]
80004f48:	58 06       	cp.w	r6,0
80004f4a:	c0 90       	breq	80004f5c <__call_exitprocs+0x70>
80004f4c:	30 1a       	mov	r10,1
80004f4e:	f4 05 09 49 	lsl	r9,r10,r5
80004f52:	ec fa 01 00 	ld.w	r10,r6[256]
80004f56:	f3 ea 00 0a 	and	r10,r9,r10
80004f5a:	c0 31       	brne	80004f60 <__call_exitprocs+0x74>
80004f5c:	5d 18       	icall	r8
80004f5e:	c0 b8       	rjmp	80004f74 <__call_exitprocs+0x88>
80004f60:	ec fa 01 04 	ld.w	r10,r6[260]
80004f64:	66 0b       	ld.w	r11,r3[0x0]
80004f66:	14 69       	and	r9,r10
80004f68:	c0 41       	brne	80004f70 <__call_exitprocs+0x84>
80004f6a:	40 2c       	lddsp	r12,sp[0x8]
80004f6c:	5d 18       	icall	r8
80004f6e:	c0 38       	rjmp	80004f74 <__call_exitprocs+0x88>
80004f70:	16 9c       	mov	r12,r11
80004f72:	5d 18       	icall	r8
80004f74:	6e 18       	ld.w	r8,r7[0x4]
80004f76:	10 30       	cp.w	r0,r8
80004f78:	cc 41       	brne	80004f00 <__call_exitprocs+0x14>
80004f7a:	68 08       	ld.w	r8,r4[0x0]
80004f7c:	0e 38       	cp.w	r8,r7
80004f7e:	cc 11       	brne	80004f00 <__call_exitprocs+0x14>
80004f80:	20 15       	sub	r5,1
80004f82:	20 43       	sub	r3,4
80004f84:	20 42       	sub	r2,4
80004f86:	58 05       	cp.w	r5,0
80004f88:	cc b4       	brge	80004f1e <__call_exitprocs+0x32>
80004f8a:	6e 18       	ld.w	r8,r7[0x4]
80004f8c:	58 08       	cp.w	r8,0
80004f8e:	c0 f1       	brne	80004fac <__call_exitprocs+0xc0>
80004f90:	6e 08       	ld.w	r8,r7[0x0]
80004f92:	58 08       	cp.w	r8,0
80004f94:	c0 c0       	breq	80004fac <__call_exitprocs+0xc0>
80004f96:	89 08       	st.w	r4[0x0],r8
80004f98:	58 06       	cp.w	r6,0
80004f9a:	c0 40       	breq	80004fa2 <__call_exitprocs+0xb6>
80004f9c:	0c 9c       	mov	r12,r6
80004f9e:	fe b0 fc 2f 	rcall	800047fc <free>
80004fa2:	0e 9c       	mov	r12,r7
80004fa4:	fe b0 fc 2c 	rcall	800047fc <free>
80004fa8:	68 07       	ld.w	r7,r4[0x0]
80004faa:	c0 38       	rjmp	80004fb0 <__call_exitprocs+0xc4>
80004fac:	0e 94       	mov	r4,r7
80004fae:	6e 07       	ld.w	r7,r7[0x0]
80004fb0:	58 07       	cp.w	r7,0
80004fb2:	ca b1       	brne	80004f08 <__call_exitprocs+0x1c>
80004fb4:	2f dd       	sub	sp,-12
80004fb6:	d8 32       	popm	r0-r7,pc

80004fb8 <__errno>:
80004fb8:	e0 68 01 14 	mov	r8,276
80004fbc:	70 0c       	ld.w	r12,r8[0x0]
80004fbe:	2f 4c       	sub	r12,-12
80004fc0:	5e fc       	retal	r12
80004fc2:	d7 03       	nop

80004fc4 <_malloc_trim_r>:
80004fc4:	d4 21       	pushm	r4-r7,lr
80004fc6:	16 95       	mov	r5,r11
80004fc8:	18 97       	mov	r7,r12
80004fca:	fe b0 ef ef 	rcall	80002fa8 <__malloc_lock>
80004fce:	e0 64 01 18 	mov	r4,280
80004fd2:	68 28       	ld.w	r8,r4[0x8]
80004fd4:	70 16       	ld.w	r6,r8[0x4]
80004fd6:	e0 16 ff fc 	andl	r6,0xfffc
80004fda:	ec c8 ff 91 	sub	r8,r6,-111
80004fde:	f0 05 01 05 	sub	r5,r8,r5
80004fe2:	e0 15 ff 80 	andl	r5,0xff80
80004fe6:	ea c5 00 80 	sub	r5,r5,128
80004fea:	e0 45 00 7f 	cp.w	r5,127
80004fee:	e0 8a 00 22 	brle	80005032 <_malloc_trim_r+0x6e>
80004ff2:	30 0b       	mov	r11,0
80004ff4:	0e 9c       	mov	r12,r7
80004ff6:	cd 9e       	rcall	80004da8 <_sbrk_r>
80004ff8:	68 28       	ld.w	r8,r4[0x8]
80004ffa:	0c 08       	add	r8,r6
80004ffc:	10 3c       	cp.w	r12,r8
80004ffe:	c1 a1       	brne	80005032 <_malloc_trim_r+0x6e>
80005000:	ea 0b 11 00 	rsub	r11,r5,0
80005004:	0e 9c       	mov	r12,r7
80005006:	cd 1e       	rcall	80004da8 <_sbrk_r>
80005008:	5b fc       	cp.w	r12,-1
8000500a:	c1 81       	brne	8000503a <_malloc_trim_r+0x76>
8000500c:	30 0b       	mov	r11,0
8000500e:	0e 9c       	mov	r12,r7
80005010:	cc ce       	rcall	80004da8 <_sbrk_r>
80005012:	68 28       	ld.w	r8,r4[0x8]
80005014:	f8 08 01 09 	sub	r9,r12,r8
80005018:	58 f9       	cp.w	r9,15
8000501a:	e0 8a 00 0c 	brle	80005032 <_malloc_trim_r+0x6e>
8000501e:	a1 a9       	sbr	r9,0x0
80005020:	91 19       	st.w	r8[0x4],r9
80005022:	e0 68 05 24 	mov	r8,1316
80005026:	70 09       	ld.w	r9,r8[0x0]
80005028:	e0 68 07 68 	mov	r8,1896
8000502c:	f8 09 01 09 	sub	r9,r12,r9
80005030:	91 09       	st.w	r8[0x0],r9
80005032:	0e 9c       	mov	r12,r7
80005034:	fe b0 ef c8 	rcall	80002fc4 <__malloc_unlock>
80005038:	d8 2a       	popm	r4-r7,pc,r12=0
8000503a:	68 28       	ld.w	r8,r4[0x8]
8000503c:	0a 16       	sub	r6,r5
8000503e:	a1 a6       	sbr	r6,0x0
80005040:	91 16       	st.w	r8[0x4],r6
80005042:	e0 68 07 68 	mov	r8,1896
80005046:	70 09       	ld.w	r9,r8[0x0]
80005048:	0a 19       	sub	r9,r5
8000504a:	0e 9c       	mov	r12,r7
8000504c:	91 09       	st.w	r8[0x0],r9
8000504e:	fe b0 ef bb 	rcall	80002fc4 <__malloc_unlock>
80005052:	da 2a       	popm	r4-r7,pc,r12=1

80005054 <_free_r>:
80005054:	d4 21       	pushm	r4-r7,lr
80005056:	16 96       	mov	r6,r11
80005058:	18 97       	mov	r7,r12
8000505a:	58 0b       	cp.w	r11,0
8000505c:	e0 80 00 c0 	breq	800051dc <_free_r+0x188>
80005060:	fe b0 ef a4 	rcall	80002fa8 <__malloc_lock>
80005064:	20 86       	sub	r6,8
80005066:	e0 6a 01 18 	mov	r10,280
8000506a:	6c 18       	ld.w	r8,r6[0x4]
8000506c:	74 2e       	ld.w	lr,r10[0x8]
8000506e:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80005072:	a1 c8       	cbr	r8,0x0
80005074:	ec 08 00 09 	add	r9,r6,r8
80005078:	72 1b       	ld.w	r11,r9[0x4]
8000507a:	e0 1b ff fc 	andl	r11,0xfffc
8000507e:	1c 39       	cp.w	r9,lr
80005080:	c1 e1       	brne	800050bc <_free_r+0x68>
80005082:	f6 08 00 08 	add	r8,r11,r8
80005086:	58 0c       	cp.w	r12,0
80005088:	c0 81       	brne	80005098 <_free_r+0x44>
8000508a:	6c 09       	ld.w	r9,r6[0x0]
8000508c:	12 16       	sub	r6,r9
8000508e:	12 08       	add	r8,r9
80005090:	6c 3b       	ld.w	r11,r6[0xc]
80005092:	6c 29       	ld.w	r9,r6[0x8]
80005094:	97 29       	st.w	r11[0x8],r9
80005096:	93 3b       	st.w	r9[0xc],r11
80005098:	10 99       	mov	r9,r8
8000509a:	95 26       	st.w	r10[0x8],r6
8000509c:	a1 a9       	sbr	r9,0x0
8000509e:	8d 19       	st.w	r6[0x4],r9
800050a0:	e0 69 05 20 	mov	r9,1312
800050a4:	72 09       	ld.w	r9,r9[0x0]
800050a6:	12 38       	cp.w	r8,r9
800050a8:	c0 63       	brcs	800050b4 <_free_r+0x60>
800050aa:	e0 68 07 64 	mov	r8,1892
800050ae:	0e 9c       	mov	r12,r7
800050b0:	70 0b       	ld.w	r11,r8[0x0]
800050b2:	c8 9f       	rcall	80004fc4 <_malloc_trim_r>
800050b4:	0e 9c       	mov	r12,r7
800050b6:	fe b0 ef 87 	rcall	80002fc4 <__malloc_unlock>
800050ba:	d8 22       	popm	r4-r7,pc
800050bc:	93 1b       	st.w	r9[0x4],r11
800050be:	58 0c       	cp.w	r12,0
800050c0:	c0 30       	breq	800050c6 <_free_r+0x72>
800050c2:	30 0c       	mov	r12,0
800050c4:	c1 08       	rjmp	800050e4 <_free_r+0x90>
800050c6:	6c 0e       	ld.w	lr,r6[0x0]
800050c8:	f4 c5 ff f8 	sub	r5,r10,-8
800050cc:	1c 16       	sub	r6,lr
800050ce:	1c 08       	add	r8,lr
800050d0:	6c 2e       	ld.w	lr,r6[0x8]
800050d2:	0a 3e       	cp.w	lr,r5
800050d4:	f9 bc 00 01 	moveq	r12,1
800050d8:	ed f5 10 03 	ld.wne	r5,r6[0xc]
800050dc:	eb fe 1a 02 	st.wne	r5[0x8],lr
800050e0:	fd f5 1a 03 	st.wne	lr[0xc],r5
800050e4:	f2 0b 00 0e 	add	lr,r9,r11
800050e8:	7c 1e       	ld.w	lr,lr[0x4]
800050ea:	ed be 00 00 	bld	lr,0x0
800050ee:	c1 40       	breq	80005116 <_free_r+0xc2>
800050f0:	16 08       	add	r8,r11
800050f2:	58 0c       	cp.w	r12,0
800050f4:	c0 d1       	brne	8000510e <_free_r+0xba>
800050f6:	e0 6e 01 18 	mov	lr,280
800050fa:	72 2b       	ld.w	r11,r9[0x8]
800050fc:	2f 8e       	sub	lr,-8
800050fe:	1c 3b       	cp.w	r11,lr
80005100:	c0 71       	brne	8000510e <_free_r+0xba>
80005102:	97 36       	st.w	r11[0xc],r6
80005104:	97 26       	st.w	r11[0x8],r6
80005106:	8d 2b       	st.w	r6[0x8],r11
80005108:	8d 3b       	st.w	r6[0xc],r11
8000510a:	30 1c       	mov	r12,1
8000510c:	c0 58       	rjmp	80005116 <_free_r+0xc2>
8000510e:	72 2b       	ld.w	r11,r9[0x8]
80005110:	72 39       	ld.w	r9,r9[0xc]
80005112:	93 2b       	st.w	r9[0x8],r11
80005114:	97 39       	st.w	r11[0xc],r9
80005116:	10 99       	mov	r9,r8
80005118:	ec 08 09 08 	st.w	r6[r8],r8
8000511c:	a1 a9       	sbr	r9,0x0
8000511e:	8d 19       	st.w	r6[0x4],r9
80005120:	58 0c       	cp.w	r12,0
80005122:	c5 a1       	brne	800051d6 <_free_r+0x182>
80005124:	e0 48 01 ff 	cp.w	r8,511
80005128:	e0 8b 00 13 	brhi	8000514e <_free_r+0xfa>
8000512c:	a3 98       	lsr	r8,0x3
8000512e:	f4 08 00 39 	add	r9,r10,r8<<0x3
80005132:	72 2b       	ld.w	r11,r9[0x8]
80005134:	8d 39       	st.w	r6[0xc],r9
80005136:	8d 2b       	st.w	r6[0x8],r11
80005138:	97 36       	st.w	r11[0xc],r6
8000513a:	93 26       	st.w	r9[0x8],r6
8000513c:	a3 48       	asr	r8,0x2
8000513e:	74 19       	ld.w	r9,r10[0x4]
80005140:	30 1b       	mov	r11,1
80005142:	f6 08 09 48 	lsl	r8,r11,r8
80005146:	f3 e8 10 08 	or	r8,r9,r8
8000514a:	95 18       	st.w	r10[0x4],r8
8000514c:	c4 58       	rjmp	800051d6 <_free_r+0x182>
8000514e:	f0 0b 16 09 	lsr	r11,r8,0x9
80005152:	58 4b       	cp.w	r11,4
80005154:	e0 8b 00 06 	brhi	80005160 <_free_r+0x10c>
80005158:	f0 0b 16 06 	lsr	r11,r8,0x6
8000515c:	2c 8b       	sub	r11,-56
8000515e:	c2 08       	rjmp	8000519e <_free_r+0x14a>
80005160:	59 4b       	cp.w	r11,20
80005162:	e0 8b 00 04 	brhi	8000516a <_free_r+0x116>
80005166:	2a 5b       	sub	r11,-91
80005168:	c1 b8       	rjmp	8000519e <_free_r+0x14a>
8000516a:	e0 4b 00 54 	cp.w	r11,84
8000516e:	e0 8b 00 06 	brhi	8000517a <_free_r+0x126>
80005172:	f0 0b 16 0c 	lsr	r11,r8,0xc
80005176:	29 2b       	sub	r11,-110
80005178:	c1 38       	rjmp	8000519e <_free_r+0x14a>
8000517a:	e0 4b 01 54 	cp.w	r11,340
8000517e:	e0 8b 00 06 	brhi	8000518a <_free_r+0x136>
80005182:	f0 0b 16 0f 	lsr	r11,r8,0xf
80005186:	28 9b       	sub	r11,-119
80005188:	c0 b8       	rjmp	8000519e <_free_r+0x14a>
8000518a:	e0 4b 05 54 	cp.w	r11,1364
8000518e:	e0 88 00 05 	brls	80005198 <_free_r+0x144>
80005192:	37 eb       	mov	r11,126
80005194:	c0 58       	rjmp	8000519e <_free_r+0x14a>
80005196:	d7 03       	nop
80005198:	f0 0b 16 12 	lsr	r11,r8,0x12
8000519c:	28 4b       	sub	r11,-124
8000519e:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
800051a2:	78 29       	ld.w	r9,r12[0x8]
800051a4:	18 39       	cp.w	r9,r12
800051a6:	c0 e1       	brne	800051c2 <_free_r+0x16e>
800051a8:	74 18       	ld.w	r8,r10[0x4]
800051aa:	a3 4b       	asr	r11,0x2
800051ac:	30 1c       	mov	r12,1
800051ae:	f8 0b 09 4b 	lsl	r11,r12,r11
800051b2:	f1 eb 10 0b 	or	r11,r8,r11
800051b6:	12 98       	mov	r8,r9
800051b8:	95 1b       	st.w	r10[0x4],r11
800051ba:	c0 a8       	rjmp	800051ce <_free_r+0x17a>
800051bc:	72 29       	ld.w	r9,r9[0x8]
800051be:	18 39       	cp.w	r9,r12
800051c0:	c0 60       	breq	800051cc <_free_r+0x178>
800051c2:	72 1a       	ld.w	r10,r9[0x4]
800051c4:	e0 1a ff fc 	andl	r10,0xfffc
800051c8:	14 38       	cp.w	r8,r10
800051ca:	cf 93       	brcs	800051bc <_free_r+0x168>
800051cc:	72 38       	ld.w	r8,r9[0xc]
800051ce:	8d 38       	st.w	r6[0xc],r8
800051d0:	8d 29       	st.w	r6[0x8],r9
800051d2:	93 36       	st.w	r9[0xc],r6
800051d4:	91 26       	st.w	r8[0x8],r6
800051d6:	0e 9c       	mov	r12,r7
800051d8:	fe b0 ee f6 	rcall	80002fc4 <__malloc_unlock>
800051dc:	d8 22       	popm	r4-r7,pc
800051de:	d7 03       	nop

800051e0 <__do_global_ctors_aux>:
800051e0:	d4 21       	pushm	r4-r7,lr
800051e2:	30 c7       	mov	r7,12
800051e4:	c0 28       	rjmp	800051e8 <__do_global_ctors_aux+0x8>
800051e6:	5d 18       	icall	r8
800051e8:	20 47       	sub	r7,4
800051ea:	6e 08       	ld.w	r8,r7[0x0]
800051ec:	5b f8       	cp.w	r8,-1
800051ee:	cf c1       	brne	800051e6 <__do_global_ctors_aux+0x6>
800051f0:	d8 22       	popm	r4-r7,pc
800051f2:	d7 03       	nop

Disassembly of section .exception:

80005200 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80005200:	c0 08       	rjmp	80005200 <_evba>
	...

80005204 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80005204:	c0 08       	rjmp	80005204 <_handle_TLB_Multiple_Hit>
	...

80005208 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80005208:	c0 08       	rjmp	80005208 <_handle_Bus_Error_Data_Fetch>
	...

8000520c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000520c:	c0 08       	rjmp	8000520c <_handle_Bus_Error_Instruction_Fetch>
	...

80005210 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80005210:	c0 08       	rjmp	80005210 <_handle_NMI>
	...

80005214 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80005214:	c0 08       	rjmp	80005214 <_handle_Instruction_Address>
	...

80005218 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80005218:	c0 08       	rjmp	80005218 <_handle_ITLB_Protection>
	...

8000521c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000521c:	c0 08       	rjmp	8000521c <_handle_Breakpoint>
	...

80005220 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80005220:	c0 08       	rjmp	80005220 <_handle_Illegal_Opcode>
	...

80005224 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80005224:	c0 08       	rjmp	80005224 <_handle_Unimplemented_Instruction>
	...

80005228 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80005228:	c0 08       	rjmp	80005228 <_handle_Privilege_Violation>
	...

8000522c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000522c:	c0 08       	rjmp	8000522c <_handle_Floating_Point>
	...

80005230 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
80005230:	c0 08       	rjmp	80005230 <_handle_Coprocessor_Absent>
	...

80005234 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80005234:	c0 08       	rjmp	80005234 <_handle_Data_Address_Read>
	...

80005238 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80005238:	c0 08       	rjmp	80005238 <_handle_Data_Address_Write>
	...

8000523c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000523c:	c0 08       	rjmp	8000523c <_handle_DTLB_Protection_Read>
	...

80005240 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80005240:	c0 08       	rjmp	80005240 <_handle_DTLB_Protection_Write>
	...

80005244 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80005244:	c0 08       	rjmp	80005244 <_handle_DTLB_Modified>
	...

80005250 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80005250:	c0 08       	rjmp	80005250 <_handle_ITLB_Miss>
	...

80005260 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80005260:	c0 08       	rjmp	80005260 <_handle_DTLB_Miss_Read>
	...

80005270 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80005270:	c0 08       	rjmp	80005270 <_handle_DTLB_Miss_Write>
	...

80005300 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80005300:	fe cf 22 9c 	sub	pc,pc,8860

80005304 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80005304:	30 0c       	mov	r12,0
80005306:	fe b0 e9 6b 	rcall	800025dc <_get_interrupt_handler>
8000530a:	58 0c       	cp.w	r12,0
8000530c:	f8 0f 17 10 	movne	pc,r12
80005310:	d6 03       	rete

80005312 <_int1>:
80005312:	30 1c       	mov	r12,1
80005314:	fe b0 e9 64 	rcall	800025dc <_get_interrupt_handler>
80005318:	58 0c       	cp.w	r12,0
8000531a:	f8 0f 17 10 	movne	pc,r12
8000531e:	d6 03       	rete

80005320 <_int2>:
80005320:	30 2c       	mov	r12,2
80005322:	fe b0 e9 5d 	rcall	800025dc <_get_interrupt_handler>
80005326:	58 0c       	cp.w	r12,0
80005328:	f8 0f 17 10 	movne	pc,r12
8000532c:	d6 03       	rete

8000532e <_int3>:
8000532e:	30 3c       	mov	r12,3
80005330:	fe b0 e9 56 	rcall	800025dc <_get_interrupt_handler>
80005334:	58 0c       	cp.w	r12,0
80005336:	f8 0f 17 10 	movne	pc,r12
8000533a:	d6 03       	rete
8000533c:	d7 03       	nop
8000533e:	d7 03       	nop
80005340:	d7 03       	nop
80005342:	d7 03       	nop
80005344:	d7 03       	nop
80005346:	d7 03       	nop
80005348:	d7 03       	nop
8000534a:	d7 03       	nop
8000534c:	d7 03       	nop
8000534e:	d7 03       	nop
80005350:	d7 03       	nop
80005352:	d7 03       	nop
80005354:	d7 03       	nop
80005356:	d7 03       	nop
80005358:	d7 03       	nop
8000535a:	d7 03       	nop
8000535c:	d7 03       	nop
8000535e:	d7 03       	nop
80005360:	d7 03       	nop
80005362:	d7 03       	nop
80005364:	d7 03       	nop
80005366:	d7 03       	nop
80005368:	d7 03       	nop
8000536a:	d7 03       	nop
8000536c:	d7 03       	nop
8000536e:	d7 03       	nop
80005370:	d7 03       	nop
80005372:	d7 03       	nop
80005374:	d7 03       	nop
80005376:	d7 03       	nop
80005378:	d7 03       	nop
8000537a:	d7 03       	nop
8000537c:	d7 03       	nop
8000537e:	d7 03       	nop
80005380:	d7 03       	nop
80005382:	d7 03       	nop
80005384:	d7 03       	nop
80005386:	d7 03       	nop
80005388:	d7 03       	nop
8000538a:	d7 03       	nop
8000538c:	d7 03       	nop
8000538e:	d7 03       	nop
80005390:	d7 03       	nop
80005392:	d7 03       	nop
80005394:	d7 03       	nop
80005396:	d7 03       	nop
80005398:	d7 03       	nop
8000539a:	d7 03       	nop
8000539c:	d7 03       	nop
8000539e:	d7 03       	nop
800053a0:	d7 03       	nop
800053a2:	d7 03       	nop
800053a4:	d7 03       	nop
800053a6:	d7 03       	nop
800053a8:	d7 03       	nop
800053aa:	d7 03       	nop
800053ac:	d7 03       	nop
800053ae:	d7 03       	nop
800053b0:	d7 03       	nop
800053b2:	d7 03       	nop
800053b4:	d7 03       	nop
800053b6:	d7 03       	nop
800053b8:	d7 03       	nop
800053ba:	d7 03       	nop
800053bc:	d7 03       	nop
800053be:	d7 03       	nop
800053c0:	d7 03       	nop
800053c2:	d7 03       	nop
800053c4:	d7 03       	nop
800053c6:	d7 03       	nop
800053c8:	d7 03       	nop
800053ca:	d7 03       	nop
800053cc:	d7 03       	nop
800053ce:	d7 03       	nop
800053d0:	d7 03       	nop
800053d2:	d7 03       	nop
800053d4:	d7 03       	nop
800053d6:	d7 03       	nop
800053d8:	d7 03       	nop
800053da:	d7 03       	nop
800053dc:	d7 03       	nop
800053de:	d7 03       	nop
800053e0:	d7 03       	nop
800053e2:	d7 03       	nop
800053e4:	d7 03       	nop
800053e6:	d7 03       	nop
800053e8:	d7 03       	nop
800053ea:	d7 03       	nop
800053ec:	d7 03       	nop
800053ee:	d7 03       	nop
800053f0:	d7 03       	nop
800053f2:	d7 03       	nop
800053f4:	d7 03       	nop
800053f6:	d7 03       	nop
800053f8:	d7 03       	nop
800053fa:	d7 03       	nop
800053fc:	d7 03       	nop
800053fe:	d7 03       	nop

Disassembly of section .fini:

80005400 <_fini>:
80005400:	eb cd 40 40 	pushm	r6,lr
80005404:	48 26       	lddpc	r6,8000540c <_fini+0xc>
80005406:	1e 26       	rsub	r6,pc
80005408:	c0 48       	rjmp	80005410 <_fini+0x10>
8000540a:	d7 03       	nop
8000540c:	80 00       	ld.sh	r0,r0[0x0]
8000540e:	53 ea       	stdsp	sp[0xf8],r10
80005410:	fe b0 e6 3a 	rcall	80002084 <__do_global_dtors_aux>
80005414:	e3 cd 80 40 	ldm	sp++,r6,pc
