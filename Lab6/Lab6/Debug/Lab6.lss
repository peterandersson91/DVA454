
Lab6.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         00002ed8  80002028  80002028  00002428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  80005000  80005000  00005400  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  80005200  80005200  00005600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       00000150  80005218  80005218  00005618  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  8 .ctors        00000008  00000008  80005368  00005808  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .dtors        00000008  00000010  80005370  00005810  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .jcr          00000004  00000018  80005378  00005818  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got          00000000  0000001c  8000537c  0000581c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         0000050c  0000001c  8000537c  0000581c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .balign       00000000  00000528  80005888  00005d28  2**0
                  ALLOC
 14 .bss          00000278  00000528  00000528  00000000  2**2
                  ALLOC
 15 .heap         0000e860  000007a0  000007a0  00000000  2**0
                  ALLOC
 16 .comment      00000030  00000000  00000000  00005d28  2**0
                  CONTENTS, READONLY
 17 .debug_aranges 00000a48  00000000  00000000  00005d58  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_pubnames 00001494  00000000  00000000  000067a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_info   00013027  00000000  00000000  00007c34  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_abbrev 000028dc  00000000  00000000  0001ac5b  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_line   0000942e  00000000  00000000  0001d537  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_frame  00001c10  00000000  00000000  00026968  2**2
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_str    00003563  00000000  00000000  00028578  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_loc    000030dd  00000000  00000000  0002badb  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_macinfo 00b3c2bb  00000000  00000000  0002ebb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 27 .debug_ranges 00000978  00000000  00000000  00b6ae73  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	20 28       	sub	r8,2

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

8000200c <_init>:
8000200c:	eb cd 40 40 	pushm	r6,lr
80002010:	48 26       	lddpc	r6,80002018 <_init+0xc>
80002012:	1e 26       	rsub	r6,pc
80002014:	c0 48       	rjmp	8000201c <_init+0x10>
80002016:	d7 03       	nop
80002018:	80 00       	ld.sh	r0,r0[0x0]
8000201a:	1f f6       	ld.ub	r6,pc[0x7]
8000201c:	c5 2c       	rcall	800020c0 <frame_dummy>
8000201e:	e0 a0 17 67 	rcall	80004eec <__do_global_ctors_aux>
80002022:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002028 <_stext>:
80002028:	30 07       	mov	r7,0
8000202a:	e0 7a 00 00 	mov	r10,65536
8000202e:	5b fa       	cp.w	r10,-1
80002030:	f4 0d 17 10 	movne	sp,r10
80002034:	fe cb cc cc 	sub	r11,pc,-13108
80002038:	30 8c       	mov	r12,8
8000203a:	18 3b       	cp.w	r11,r12
8000203c:	c0 70       	breq	8000204a <_stext+0x22>
8000203e:	e0 6a 05 28 	mov	r10,1320
80002042:	b7 09       	ld.d	r8,r11++
80002044:	b9 28       	st.d	r12++,r8
80002046:	14 3c       	cp.w	r12,r10
80002048:	cf d5       	brlt	80002042 <_stext+0x1a>
8000204a:	e0 6a 07 a0 	mov	r10,1952
8000204e:	e0 6c 05 28 	mov	r12,1320
80002052:	30 08       	mov	r8,0
80002054:	30 09       	mov	r9,0
80002056:	b9 28       	st.d	r12++,r8
80002058:	14 3c       	cp.w	r12,r10
8000205a:	cf e5       	brlt	80002056 <_stext+0x2e>
8000205c:	e0 a0 06 f8 	rcall	80002e4c <_init_startup>
80002060:	fe cc ce 60 	sub	r12,pc,-12704
80002064:	e0 a0 12 44 	rcall	800044ec <atexit>
80002068:	cd 2f       	rcall	8000200c <_init>
8000206a:	1a 9c       	mov	r12,sp
8000206c:	30 0b       	mov	r11,0
8000206e:	e0 a0 15 4d 	rcall	80004b08 <_init_argv>
80002072:	5b fc       	cp.w	r12,-1
80002074:	f9 bc 00 00 	moveq	r12,0
80002078:	f9 ba 00 00 	moveq	r10,0
8000207c:	14 1d       	sub	sp,r10
8000207e:	c0 dd       	rcall	80002298 <main>
80002080:	e0 a0 12 3e 	rcall	800044fc <exit>

80002084 <__do_global_dtors_aux>:
80002084:	d4 21       	pushm	r4-r7,lr
80002086:	e0 68 05 28 	mov	r8,1320
8000208a:	11 89       	ld.ub	r9,r8[0x0]
8000208c:	30 08       	mov	r8,0
8000208e:	f0 09 18 00 	cp.b	r9,r8
80002092:	c1 61       	brne	800020be <__do_global_dtors_aux+0x3a>
80002094:	31 08       	mov	r8,16
80002096:	31 46       	mov	r6,20
80002098:	10 95       	mov	r5,r8
8000209a:	10 16       	sub	r6,r8
8000209c:	e0 67 05 2c 	mov	r7,1324
800020a0:	a3 46       	asr	r6,0x2
800020a2:	20 16       	sub	r6,1
800020a4:	c0 68       	rjmp	800020b0 <__do_global_dtors_aux+0x2c>
800020a6:	2f f8       	sub	r8,-1
800020a8:	8f 08       	st.w	r7[0x0],r8
800020aa:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020ae:	5d 18       	icall	r8
800020b0:	6e 08       	ld.w	r8,r7[0x0]
800020b2:	0c 38       	cp.w	r8,r6
800020b4:	cf 93       	brcs	800020a6 <__do_global_dtors_aux+0x22>
800020b6:	30 19       	mov	r9,1
800020b8:	e0 68 05 28 	mov	r8,1320
800020bc:	b0 89       	st.b	r8[0x0],r9
800020be:	d8 22       	popm	r4-r7,pc

800020c0 <frame_dummy>:
800020c0:	d4 01       	pushm	lr
800020c2:	31 8c       	mov	r12,24
800020c4:	78 08       	ld.w	r8,r12[0x0]
800020c6:	58 08       	cp.w	r8,0
800020c8:	c0 50       	breq	800020d2 <frame_dummy+0x12>
800020ca:	48 38       	lddpc	r8,800020d4 <frame_dummy+0x14>
800020cc:	58 08       	cp.w	r8,0
800020ce:	c0 20       	breq	800020d2 <frame_dummy+0x12>
800020d0:	5d 18       	icall	r8
800020d2:	d8 02       	popm	pc
800020d4:	00 00       	add	r0,r0
	...

800020d8 <initLED>:
#include "LED.h"

void initLED (void)
{
800020d8:	eb cd 40 80 	pushm	r7,lr
800020dc:	1a 97       	mov	r7,sp
800020de:	20 1d       	sub	sp,4
	/*
	* First make access to the GPIO port registers
	* shorter to type , just for our convenience
	*/
	volatile avr32_gpio_port_t * led0_port;
	led0_port = &AVR32_GPIO.port[LED0_PORT];
800020e0:	fe 78 11 00 	mov	r8,-61184
800020e4:	ef 48 ff fc 	st.w	r7[-4],r8
	/*
	* Choose GPIO peripheral function ,
	* by writing a 1 to gpers , GPIO Enable Register Set
	*/
	led0_port->gpers = LED0_BIT_VALUE;
800020e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800020ec:	fc 19 08 00 	movh	r9,0x800
800020f0:	91 19       	st.w	r8[0x4],r9
	led0_port->gpers = LED1_BIT_VALUE;
800020f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800020f6:	fc 19 10 00 	movh	r9,0x1000
800020fa:	91 19       	st.w	r8[0x4],r9
	led0_port->gpers = LED2_BIT_VALUE;
800020fc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002100:	fc 19 20 00 	movh	r9,0x2000
80002104:	91 19       	st.w	r8[0x4],r9
	/*
	* Set the output value register to 1 in order to
	* turn the LED off (1= off , 0= on in this case ) ,
	* by writing a 1 to ovrs , Output Value Register Set
	*/
	led0_port->ovrs = LED0_BIT_VALUE;
80002106:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000210a:	fc 19 08 00 	movh	r9,0x800
8000210e:	f1 49 00 54 	st.w	r8[84],r9
	led0_port->ovrs = LED1_BIT_VALUE;
80002112:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002116:	fc 19 10 00 	movh	r9,0x1000
8000211a:	f1 49 00 54 	st.w	r8[84],r9
	led0_port->ovrs = LED2_BIT_VALUE;
8000211e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002122:	fc 19 20 00 	movh	r9,0x2000
80002126:	f1 49 00 54 	st.w	r8[84],r9
	/*
	* Set the output enable register ,
	* by writing a 1 to oders , Output Drive Enable
	* Register Set
	*/
	led0_port->oders = LED0_BIT_VALUE;
8000212a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000212e:	fc 19 08 00 	movh	r9,0x800
80002132:	f1 49 00 44 	st.w	r8[68],r9
	led0_port->oders = LED1_BIT_VALUE;
80002136:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000213a:	fc 19 10 00 	movh	r9,0x1000
8000213e:	f1 49 00 44 	st.w	r8[68],r9
	led0_port->oders = LED2_BIT_VALUE;
80002142:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002146:	fc 19 20 00 	movh	r9,0x2000
8000214a:	f1 49 00 44 	st.w	r8[68],r9
}
8000214e:	2f fd       	sub	sp,-4
80002150:	e3 cd 80 80 	ldm	sp++,r7,pc
80002154:	76 50       	ld.w	r0,r11[0x14]
80002156:	72 6f       	ld.w	pc,r9[0x18]
80002158:	64 75       	ld.w	r5,r2[0x1c]
8000215a:	63 65       	ld.w	r5,r1[0x58]
8000215c:	72 00       	ld.w	r0,r9[0x0]
8000215e:	00 00       	add	r0,r0
80002160:	76 43       	ld.w	r3,r11[0x10]
80002162:	6f 6e       	ld.w	lr,r7[0x58]
80002164:	73 75       	ld.w	r5,r9[0x5c]
80002166:	6d 65       	ld.w	r5,r6[0x58]
80002168:	72 00       	ld.w	r0,r9[0x0]
	...

8000216c <init_usart>:
		cycles--;
	}
}

void init_usart ( void )
{
8000216c:	eb cd 40 80 	pushm	r7,lr
80002170:	1a 97       	mov	r7,sp
		. charlength = 8,
		. paritytype = USART_NO_PARITY ,
		. stopbits = USART_1_STOPBIT ,
		. channelmode = USART_NORMAL_CHMODE
	};
	pm_switch_to_osc0 (& AVR32_PM , FOSC0 , OSC0_STARTUP );
80002172:	30 3a       	mov	r10,3
80002174:	e0 6b 1b 00 	mov	r11,6912
80002178:	ea 1b 00 b7 	orh	r11,0xb7
8000217c:	fe 7c 0c 00 	mov	r12,-62464
80002180:	f0 1f 00 0f 	mcall	800021bc <init_usart+0x50>
	gpio_enable_module ( USART_SERIAL_GPIO_MAP , 2);
80002184:	30 2b       	mov	r11,2
80002186:	48 fc       	lddpc	r12,800021c0 <init_usart+0x54>
80002188:	f0 1f 00 0f 	mcall	800021c4 <init_usart+0x58>
	gpio_enable_module ( USART_DEBUG_GPIO_MAP , 2);
8000218c:	30 2b       	mov	r11,2
8000218e:	48 fc       	lddpc	r12,800021c8 <init_usart+0x5c>
80002190:	f0 1f 00 0d 	mcall	800021c4 <init_usart+0x58>
	usart_init_rs232 ( serialPORT_USART , & USART_OPTIONS , FOSC0 );
80002194:	e0 6a 1b 00 	mov	r10,6912
80002198:	ea 1a 00 b7 	orh	r10,0xb7
8000219c:	48 cb       	lddpc	r11,800021cc <init_usart+0x60>
8000219e:	fe 7c 18 00 	mov	r12,-59392
800021a2:	f0 1f 00 0c 	mcall	800021d0 <init_usart+0x64>
	usart_init_rs232 ( configDBG_USART , & USART_OPTIONS , FOSC0 );
800021a6:	e0 6a 1b 00 	mov	r10,6912
800021aa:	ea 1a 00 b7 	orh	r10,0xb7
800021ae:	48 8b       	lddpc	r11,800021cc <init_usart+0x60>
800021b0:	fe 7c 18 00 	mov	r12,-59392
800021b4:	f0 1f 00 07 	mcall	800021d0 <init_usart+0x64>
}
800021b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800021bc:	80 00       	ld.sh	r0,r0[0x0]
800021be:	28 70       	sub	r0,-121
800021c0:	80 00       	ld.sh	r0,r0[0x0]
800021c2:	52 18       	stdsp	sp[0x84],r8
800021c4:	80 00       	ld.sh	r0,r0[0x0]
800021c6:	23 50       	sub	r0,53
800021c8:	80 00       	ld.sh	r0,r0[0x0]
800021ca:	52 28       	stdsp	sp[0x88],r8
800021cc:	80 00       	ld.sh	r0,r0[0x0]
800021ce:	52 38       	stdsp	sp[0x8c],r8
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	2a 20       	sub	r0,-94

800021d4 <vProducer>:

void vProducer(void *pvParameters)
{	
800021d4:	eb cd 40 80 	pushm	r7,lr
800021d8:	1a 97       	mov	r7,sp
800021da:	20 8d       	sub	sp,32
800021dc:	ef 4c ff e0 	st.w	r7[-32],r12
	portTickType xLastWakeTime;
	const portTickType xFreq = TASK_DELAY_MS(1000);
800021e0:	e0 68 03 e8 	mov	r8,1000
800021e4:	ef 48 ff f8 	st.w	r7[-8],r8
	
	xLastWakeTime = xTaskGetTickCount();
800021e8:	f0 1f 00 14 	mcall	80002238 <vProducer+0x64>
800021ec:	18 98       	mov	r8,r12
800021ee:	ef 48 ff f4 	st.w	r7[-12],r8
	
	struct msg message;
	message.id = 0;
800021f2:	30 08       	mov	r8,0
800021f4:	ef 48 ff e8 	st.w	r7[-24],r8
	message.data = 0;
800021f8:	30 08       	mov	r8,0
800021fa:	ef 48 ff ec 	st.w	r7[-20],r8
	message.timestamp = 0;
800021fe:	30 08       	mov	r8,0
80002200:	ef 48 ff f0 	st.w	r7[-16],r8
	
	struct msg *pMesg = &message;
80002204:	ee c8 00 18 	sub	r8,r7,24
80002208:	ef 48 ff e4 	st.w	r7[-28],r8
	
	int i = 0;
8000220c:	30 08       	mov	r8,0
8000220e:	ef 48 ff fc 	st.w	r7[-4],r8
	
	while(1)
	{
		pMesg->data = 98;
80002212:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002216:	36 29       	mov	r9,98
80002218:	91 19       	st.w	r8[0x4],r9
		
		xQueueSendToBack(xQHandle, &pMesg, (portTickType)10);
8000221a:	48 98       	lddpc	r8,8000223c <vProducer+0x68>
8000221c:	70 08       	ld.w	r8,r8[0x0]
8000221e:	ee cb 00 1c 	sub	r11,r7,28
80002222:	30 09       	mov	r9,0
80002224:	30 aa       	mov	r10,10
80002226:	10 9c       	mov	r12,r8
80002228:	f0 1f 00 06 	mcall	80002240 <vProducer+0x6c>
		
		i++;
8000222c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002230:	2f f8       	sub	r8,-1
80002232:	ef 48 ff fc 	st.w	r7[-4],r8
		
		
	}
80002236:	ce eb       	rjmp	80002212 <vProducer+0x3e>
80002238:	80 00       	ld.sh	r0,r0[0x0]
8000223a:	3d 2c       	mov	r12,-46
8000223c:	00 00       	add	r0,r0
8000223e:	07 90       	ld.ub	r0,r3[0x1]
80002240:	80 00       	ld.sh	r0,r0[0x0]
80002242:	34 10       	mov	r0,65

80002244 <vConsumer>:
}

void vConsumer( void *pvParameters )
{
80002244:	eb cd 40 80 	pushm	r7,lr
80002248:	1a 97       	mov	r7,sp
8000224a:	20 7d       	sub	sp,28
8000224c:	ef 4c ff e4 	st.w	r7[-28],r12
	portTickType xLastWakeTime;
	const portTickType xFreq = TASK_DELAY_MS(10000);
80002250:	e0 68 27 10 	mov	r8,10000
80002254:	ef 48 ff f8 	st.w	r7[-8],r8
	volatile portTickType elapsed;
	
	struct msg *pMesg;
	
	char h = 97;
80002258:	36 18       	mov	r8,97
8000225a:	ef 68 ff ff 	st.b	r7[-1],r8
	char g[1];
	
	while(1)
	{
		xQueueReceive(xQHandle, &pMesg, (portTickType)10);
8000225e:	48 c8       	lddpc	r8,8000228c <vConsumer+0x48>
80002260:	70 08       	ld.w	r8,r8[0x0]
80002262:	ee cb 00 14 	sub	r11,r7,20
80002266:	30 09       	mov	r9,0
80002268:	30 aa       	mov	r10,10
8000226a:	10 9c       	mov	r12,r8
8000226c:	f0 1f 00 09 	mcall	80002290 <vConsumer+0x4c>
		g[0] = pMesg->data;
80002270:	ee f8 ff ec 	ld.w	r8,r7[-20]
80002274:	70 18       	ld.w	r8,r8[0x4]
80002276:	5c 58       	castu.b	r8
80002278:	ef 68 ff e8 	st.b	r7[-24],r8
		
		usart_write_line(serialPORT_USART, g);
8000227c:	ee c8 00 18 	sub	r8,r7,24
80002280:	10 9b       	mov	r11,r8
80002282:	fe 7c 18 00 	mov	r12,-59392
80002286:	f0 1f 00 04 	mcall	80002294 <vConsumer+0x50>
	}
8000228a:	ce ab       	rjmp	8000225e <vConsumer+0x1a>
8000228c:	00 00       	add	r0,r0
8000228e:	07 90       	ld.ub	r0,r3[0x1]
80002290:	80 00       	ld.sh	r0,r0[0x0]
80002292:	35 78       	mov	r8,87
80002294:	80 00       	ld.sh	r0,r0[0x0]
80002296:	2c 28       	sub	r8,-62

80002298 <main>:
}

int main(void)
{
80002298:	eb cd 40 80 	pushm	r7,lr
8000229c:	1a 97       	mov	r7,sp
8000229e:	20 1d       	sub	sp,4
	initLED();
800022a0:	f0 1f 00 20 	mcall	80002320 <main+0x88>
	init_usart();
800022a4:	f0 1f 00 20 	mcall	80002324 <main+0x8c>

	static unsigned char ucParameterToPass ;
	xTaskHandle xHandle1;
	
	vSemaphoreCreateBinary(xSemaphore);
800022a8:	30 0b       	mov	r11,0
800022aa:	30 1c       	mov	r12,1
800022ac:	f0 1f 00 1f 	mcall	80002328 <main+0x90>
800022b0:	18 99       	mov	r9,r12
800022b2:	49 f8       	lddpc	r8,8000232c <main+0x94>
800022b4:	91 09       	st.w	r8[0x0],r9
800022b6:	49 e8       	lddpc	r8,8000232c <main+0x94>
800022b8:	70 08       	ld.w	r8,r8[0x0]
800022ba:	58 08       	cp.w	r8,0
800022bc:	c0 90       	breq	800022ce <main+0x36>
800022be:	49 c8       	lddpc	r8,8000232c <main+0x94>
800022c0:	70 08       	ld.w	r8,r8[0x0]
800022c2:	30 09       	mov	r9,0
800022c4:	30 0a       	mov	r10,0
800022c6:	30 0b       	mov	r11,0
800022c8:	10 9c       	mov	r12,r8
800022ca:	f0 1f 00 1a 	mcall	80002330 <main+0x98>
	
	xQHandle = xQueueCreate(10, sizeof(struct msg*));
800022ce:	30 4b       	mov	r11,4
800022d0:	30 ac       	mov	r12,10
800022d2:	f0 1f 00 16 	mcall	80002328 <main+0x90>
800022d6:	18 99       	mov	r9,r12
800022d8:	49 78       	lddpc	r8,80002334 <main+0x9c>
800022da:	91 09       	st.w	r8[0x0],r9
	{
		//ERROR!
	}
		
	// Create the task , store the handle .
	xTaskCreate(	vProducer,
800022dc:	49 7b       	lddpc	r11,80002338 <main+0xa0>
800022de:	30 08       	mov	r8,0
800022e0:	1a d8       	st.w	--sp,r8
800022e2:	30 08       	mov	r8,0
800022e4:	1a d8       	st.w	--sp,r8
800022e6:	30 08       	mov	r8,0
800022e8:	1a d8       	st.w	--sp,r8
800022ea:	30 18       	mov	r8,1
800022ec:	30 09       	mov	r9,0
800022ee:	e0 6a 01 00 	mov	r10,256
800022f2:	49 3c       	lddpc	r12,8000233c <main+0xa4>
800022f4:	f0 1f 00 13 	mcall	80002340 <main+0xa8>
800022f8:	2f dd       	sub	sp,-12
					configMINIMAL_STACK_SIZE,
					NULL,
					1,
					NULL);
	
	xTaskCreate(	vConsumer, "vConsumer", configMINIMAL_STACK_SIZE, NULL, 1, NULL);
800022fa:	49 3b       	lddpc	r11,80002344 <main+0xac>
800022fc:	30 08       	mov	r8,0
800022fe:	1a d8       	st.w	--sp,r8
80002300:	30 08       	mov	r8,0
80002302:	1a d8       	st.w	--sp,r8
80002304:	30 08       	mov	r8,0
80002306:	1a d8       	st.w	--sp,r8
80002308:	30 18       	mov	r8,1
8000230a:	30 09       	mov	r9,0
8000230c:	e0 6a 01 00 	mov	r10,256
80002310:	48 ec       	lddpc	r12,80002348 <main+0xb0>
80002312:	f0 1f 00 0c 	mcall	80002340 <main+0xa8>
80002316:	2f dd       	sub	sp,-12
	
	vTaskStartScheduler();
80002318:	f0 1f 00 0d 	mcall	8000234c <main+0xb4>

	
	for( ;; )
	{
		
	}
8000231c:	c0 08       	rjmp	8000231c <main+0x84>
8000231e:	00 00       	add	r0,r0
80002320:	80 00       	ld.sh	r0,r0[0x0]
80002322:	20 d8       	sub	r8,13
80002324:	80 00       	ld.sh	r0,r0[0x0]
80002326:	21 6c       	sub	r12,22
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	32 f8       	mov	r8,47
8000232c:	00 00       	add	r0,r0
8000232e:	07 94       	ld.ub	r4,r3[0x1]
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	34 10       	mov	r0,65
80002334:	00 00       	add	r0,r0
80002336:	07 90       	ld.ub	r0,r3[0x1]
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	21 54       	sub	r4,21
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	21 d4       	sub	r4,29
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	39 bc       	mov	r12,-101
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	21 60       	sub	r0,22
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	22 44       	sub	r4,36
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	3b 84       	mov	r4,-72

80002350 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80002350:	eb cd 40 80 	pushm	r7,lr
80002354:	1a 97       	mov	r7,sp
80002356:	20 4d       	sub	sp,16
80002358:	ef 4c ff f4 	st.w	r7[-12],r12
8000235c:	ef 4b ff f0 	st.w	r7[-16],r11
	uint32_t status = GPIO_SUCCESS;
80002360:	30 08       	mov	r8,0
80002362:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t i;

	for (i = 0; i < size; i++) {
80002366:	30 08       	mov	r8,0
80002368:	ef 48 ff fc 	st.w	r7[-4],r8
8000236c:	c1 c8       	rjmp	800023a4 <gpio_enable_module+0x54>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000236e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002372:	70 19       	ld.w	r9,r8[0x4]
80002374:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002378:	70 08       	ld.w	r8,r8[0x0]
8000237a:	12 9b       	mov	r11,r9
8000237c:	10 9c       	mov	r12,r8
8000237e:	f0 1f 00 10 	mcall	800023bc <gpio_enable_module+0x6c>
80002382:	18 98       	mov	r8,r12
80002384:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002388:	f3 e8 10 08 	or	r8,r9,r8
8000238c:	ef 48 ff f8 	st.w	r7[-8],r8
		gpiomap++;
80002390:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002394:	2f 88       	sub	r8,-8
80002396:	ef 48 ff f4 	st.w	r7[-12],r8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000239a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000239e:	2f f8       	sub	r8,-1
800023a0:	ef 48 ff fc 	st.w	r7[-4],r8
800023a4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800023a8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800023ac:	10 39       	cp.w	r9,r8
800023ae:	ce 03       	brcs	8000236e <gpio_enable_module+0x1e>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
800023b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800023b4:	10 9c       	mov	r12,r8
800023b6:	2f cd       	sub	sp,-16
800023b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	23 c0       	sub	r0,60

800023c0 <gpio_enable_module_pin>:
 * \param function The pin function.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
800023c0:	eb cd 40 80 	pushm	r7,lr
800023c4:	1a 97       	mov	r7,sp
800023c6:	20 3d       	sub	sp,12
800023c8:	ef 4c ff f8 	st.w	r7[-8],r12
800023cc:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800023d0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800023d4:	a5 98       	lsr	r8,0x5
800023d6:	a9 68       	lsl	r8,0x8
800023d8:	e0 28 f0 00 	sub	r8,61440
800023dc:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Enable the correct function. */
	switch (function) {
800023e0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800023e4:	58 18       	cp.w	r8,1
800023e6:	c1 e0       	breq	80002422 <gpio_enable_module_pin+0x62>
800023e8:	c0 63       	brcs	800023f4 <gpio_enable_module_pin+0x34>
800023ea:	58 28       	cp.w	r8,2
800023ec:	c3 20       	breq	80002450 <gpio_enable_module_pin+0x90>
800023ee:	58 38       	cp.w	r8,3
800023f0:	c4 70       	breq	8000247e <gpio_enable_module_pin+0xbe>
800023f2:	c5 d8       	rjmp	800024ac <gpio_enable_module_pin+0xec>
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800023f4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800023f8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800023fc:	30 19       	mov	r9,1
800023fe:	f2 08 09 48 	lsl	r8,r9,r8
80002402:	10 99       	mov	r9,r8
80002404:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002408:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000240a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000240e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002412:	30 19       	mov	r9,1
80002414:	f2 08 09 48 	lsl	r8,r9,r8
80002418:	10 99       	mov	r9,r8
8000241a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000241e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002420:	c4 88       	rjmp	800024b0 <gpio_enable_module_pin+0xf0>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80002422:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002426:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000242a:	30 19       	mov	r9,1
8000242c:	f2 08 09 48 	lsl	r8,r9,r8
80002430:	10 99       	mov	r9,r8
80002432:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002436:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80002438:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000243c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002440:	30 19       	mov	r9,1
80002442:	f2 08 09 48 	lsl	r8,r9,r8
80002446:	10 99       	mov	r9,r8
80002448:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000244c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000244e:	c3 18       	rjmp	800024b0 <gpio_enable_module_pin+0xf0>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80002450:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002454:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002458:	30 19       	mov	r9,1
8000245a:	f2 08 09 48 	lsl	r8,r9,r8
8000245e:	10 99       	mov	r9,r8
80002460:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002464:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002466:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000246a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000246e:	30 19       	mov	r9,1
80002470:	f2 08 09 48 	lsl	r8,r9,r8
80002474:	10 99       	mov	r9,r8
80002476:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000247a:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000247c:	c1 a8       	rjmp	800024b0 <gpio_enable_module_pin+0xf0>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000247e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002482:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002486:	30 19       	mov	r9,1
80002488:	f2 08 09 48 	lsl	r8,r9,r8
8000248c:	10 99       	mov	r9,r8
8000248e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002492:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002494:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002498:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000249c:	30 19       	mov	r9,1
8000249e:	f2 08 09 48 	lsl	r8,r9,r8
800024a2:	10 99       	mov	r9,r8
800024a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800024a8:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800024aa:	c0 38       	rjmp	800024b0 <gpio_enable_module_pin+0xf0>
		gpio_port->pmr2s = 1 << (pin & 0x1F);
		break;
#endif

	default:
		return GPIO_INVALID_ARGUMENT;
800024ac:	30 18       	mov	r8,1
800024ae:	c0 d8       	rjmp	800024c8 <gpio_enable_module_pin+0x108>
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800024b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800024b4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800024b8:	30 19       	mov	r9,1
800024ba:	f2 08 09 48 	lsl	r8,r9,r8
800024be:	10 99       	mov	r9,r8
800024c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800024c4:	91 29       	st.w	r8[0x8],r9

	return GPIO_SUCCESS;
800024c6:	30 08       	mov	r8,0
}
800024c8:	10 9c       	mov	r12,r8
800024ca:	2f dd       	sub	sp,-12
800024cc:	e3 cd 80 80 	ldm	sp++,r7,pc

800024d0 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800024d0:	eb cd 40 80 	pushm	r7,lr
800024d4:	1a 97       	mov	r7,sp
	// Catch unregistered interrupts.
	while (true);
800024d6:	c0 08       	rjmp	800024d6 <_unhandled_interrupt+0x6>

800024d8 <_get_interrupt_handler>:
 *
 * \return Interrupt handler to execute.
 */
__int_handler _get_interrupt_handler(uint32_t int_level);
__int_handler _get_interrupt_handler(uint32_t int_level)
{
800024d8:	eb cd 40 80 	pushm	r7,lr
800024dc:	1a 97       	mov	r7,sp
800024de:	20 3d       	sub	sp,12
800024e0:	ef 4c ff f4 	st.w	r7[-12],r12
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800024e4:	fe 78 08 00 	mov	r8,-63488
800024e8:	ee f9 ff f4 	ld.w	r9,r7[-12]
800024ec:	f2 09 11 03 	rsub	r9,r9,3
800024f0:	28 09       	sub	r9,-128
800024f2:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800024f6:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800024fa:	fe 78 08 00 	mov	r8,-63488
800024fe:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002502:	2c 09       	sub	r9,-64
80002504:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80002508:	ef 48 ff fc 	st.w	r7[-4],r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000250c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002510:	58 08       	cp.w	r8,0
80002512:	c1 30       	breq	80002538 <_get_interrupt_handler+0x60>
		? _int_handler_table[int_grp]._int_line_handler_table[32
80002514:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002518:	48 b8       	lddpc	r8,80002544 <_get_interrupt_handler+0x6c>
8000251a:	a1 79       	lsl	r9,0x1
8000251c:	2f f9       	sub	r9,-1
8000251e:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80002522:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002526:	f0 08 12 00 	clz	r8,r8
8000252a:	f0 08 11 1f 	rsub	r8,r8,31
			- clz(int_req) - 1]
8000252e:	a3 68       	lsl	r8,0x2
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
80002530:	f2 08 00 08 	add	r8,r9,r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002534:	70 08       	ld.w	r8,r8[0x0]
80002536:	c0 28       	rjmp	8000253a <_get_interrupt_handler+0x62>
80002538:	30 08       	mov	r8,0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000253a:	10 9c       	mov	r12,r8
8000253c:	2f dd       	sub	sp,-12
8000253e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002542:	00 00       	add	r0,r0
80002544:	80 00       	ld.sh	r0,r0[0x0]
80002546:	52 44       	stdsp	sp[0x90],r4

80002548 <INTC_init_evba>:
 * \internal
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
80002548:	eb cd 40 80 	pushm	r7,lr
8000254c:	1a 97       	mov	r7,sp
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000254e:	48 38       	lddpc	r8,80002558 <INTC_init_evba+0x10>
80002550:	e3 b8 00 01 	mtsr	0x4,r8
}
80002554:	e3 cd 80 80 	ldm	sp++,r7,pc
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	50 00       	stdsp	sp[0x0],r0

8000255c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
8000255c:	eb cd 40 80 	pushm	r7,lr
80002560:	1a 97       	mov	r7,sp
80002562:	20 2d       	sub	sp,8
	uint32_t int_grp, int_req;

	INTC_init_evba();
80002564:	f0 1f 00 1f 	mcall	800025e0 <INTC_init_interrupts+0x84>

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80002568:	30 08       	mov	r8,0
8000256a:	ef 48 ff f8 	st.w	r7[-8],r8
8000256e:	c3 18       	rjmp	800025d0 <INTC_init_interrupts+0x74>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80002570:	30 08       	mov	r8,0
80002572:	ef 48 ff fc 	st.w	r7[-4],r8
80002576:	c1 48       	rjmp	8000259e <INTC_init_interrupts+0x42>
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80002578:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000257c:	49 a8       	lddpc	r8,800025e4 <INTC_init_interrupts+0x88>
8000257e:	a1 79       	lsl	r9,0x1
80002580:	2f f9       	sub	r9,-1
80002582:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80002586:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000258a:	a3 68       	lsl	r8,0x2
8000258c:	f2 08 00 08 	add	r8,r9,r8
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80002590:	49 69       	lddpc	r9,800025e8 <INTC_init_interrupts+0x8c>
80002592:	91 09       	st.w	r8[0x0],r9
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80002594:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002598:	2f f8       	sub	r8,-1
8000259a:	ef 48 ff fc 	st.w	r7[-4],r8
	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
8000259e:	ee f9 ff f8 	ld.w	r9,r7[-8]
800025a2:	49 18       	lddpc	r8,800025e4 <INTC_init_interrupts+0x88>
800025a4:	f0 09 03 39 	ld.w	r9,r8[r9<<0x3]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800025a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800025ac:	10 39       	cp.w	r9,r8
800025ae:	fe 9b ff e5 	brhi	80002578 <INTC_init_interrupts+0x1c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800025b2:	fe 78 08 00 	mov	r8,-63488
800025b6:	ee f9 ff f8 	ld.w	r9,r7[-8]
800025ba:	48 db       	lddpc	r11,800025ec <INTC_init_interrupts+0x90>
800025bc:	48 da       	lddpc	r10,800025f0 <INTC_init_interrupts+0x94>
800025be:	f6 0a 01 0a 	sub	r10,r11,r10
800025c2:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800025c6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800025ca:	2f f8       	sub	r8,-1
800025cc:	ef 48 ff f8 	st.w	r7[-8],r8
800025d0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800025d4:	59 38       	cp.w	r8,19
800025d6:	fe 98 ff cd 	brls	80002570 <INTC_init_interrupts+0x14>
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	}
}
800025da:	2f ed       	sub	sp,-8
800025dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800025e0:	80 00       	ld.sh	r0,r0[0x0]
800025e2:	25 48       	sub	r8,84
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	52 44       	stdsp	sp[0x90],r4
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	24 d0       	sub	r0,77
800025ec:	80 00       	ld.sh	r0,r0[0x0]
800025ee:	51 04       	stdsp	sp[0x40],r4
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	50 00       	stdsp	sp[0x0],r0

800025f4 <INTC_register_interrupt>:
 *          be effective.
 *
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
800025f4:	eb cd 40 80 	pushm	r7,lr
800025f8:	1a 97       	mov	r7,sp
800025fa:	20 4d       	sub	sp,16
800025fc:	ef 4c ff f8 	st.w	r7[-8],r12
80002600:	ef 4b ff f4 	st.w	r7[-12],r11
80002604:	ef 4a ff f0 	st.w	r7[-16],r10
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80002608:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000260c:	a5 98       	lsr	r8,0x5
8000260e:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80002612:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002616:	4a 78       	lddpc	r8,800026b0 <INTC_register_interrupt+0xbc>
80002618:	a1 79       	lsl	r9,0x1
8000261a:	2f f9       	sub	r9,-1
8000261c:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80002620:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002624:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002628:	a3 68       	lsl	r8,0x2
8000262a:	f2 08 00 08 	add	r8,r9,r8
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000262e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002632:	91 09       	st.w	r8[0x0],r9
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80002634:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002638:	58 08       	cp.w	r8,0
8000263a:	c0 c1       	brne	80002652 <INTC_register_interrupt+0x5e>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000263c:	fe 78 08 00 	mov	r8,-63488
80002640:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002644:	49 cb       	lddpc	r11,800026b4 <INTC_register_interrupt+0xc0>
80002646:	49 da       	lddpc	r10,800026b8 <INTC_register_interrupt+0xc4>
80002648:	f6 0a 01 0a 	sub	r10,r11,r10
8000264c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80002650:	c2 d8       	rjmp	800026aa <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT1) {
80002652:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002656:	58 18       	cp.w	r8,1
80002658:	c0 d1       	brne	80002672 <INTC_register_interrupt+0x7e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000265a:	fe 78 08 00 	mov	r8,-63488
8000265e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002662:	49 7b       	lddpc	r11,800026bc <INTC_register_interrupt+0xc8>
80002664:	49 5a       	lddpc	r10,800026b8 <INTC_register_interrupt+0xc4>
80002666:	f6 0a 01 0a 	sub	r10,r11,r10
8000266a:	bf aa       	sbr	r10,0x1e
8000266c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80002670:	c1 d8       	rjmp	800026aa <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT2) {
80002672:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002676:	58 28       	cp.w	r8,2
80002678:	c0 d1       	brne	80002692 <INTC_register_interrupt+0x9e>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000267a:	fe 78 08 00 	mov	r8,-63488
8000267e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002682:	49 0b       	lddpc	r11,800026c0 <INTC_register_interrupt+0xcc>
80002684:	48 da       	lddpc	r10,800026b8 <INTC_register_interrupt+0xc4>
80002686:	f6 0a 01 0a 	sub	r10,r11,r10
8000268a:	bf ba       	sbr	r10,0x1f
8000268c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80002690:	c0 d8       	rjmp	800026aa <INTC_register_interrupt+0xb6>
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80002692:	fe 78 08 00 	mov	r8,-63488
80002696:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000269a:	48 bb       	lddpc	r11,800026c4 <INTC_register_interrupt+0xd0>
8000269c:	48 7a       	lddpc	r10,800026b8 <INTC_register_interrupt+0xc4>
8000269e:	f6 0a 01 0a 	sub	r10,r11,r10
800026a2:	ea 1a c0 00 	orh	r10,0xc000
800026a6:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	}
}
800026aa:	2f cd       	sub	sp,-16
800026ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800026b0:	80 00       	ld.sh	r0,r0[0x0]
800026b2:	52 44       	stdsp	sp[0x90],r4
800026b4:	80 00       	ld.sh	r0,r0[0x0]
800026b6:	51 04       	stdsp	sp[0x40],r4
800026b8:	80 00       	ld.sh	r0,r0[0x0]
800026ba:	50 00       	stdsp	sp[0x0],r0
800026bc:	80 00       	ld.sh	r0,r0[0x0]
800026be:	51 12       	stdsp	sp[0x44],r2
800026c0:	80 00       	ld.sh	r0,r0[0x0]
800026c2:	51 20       	stdsp	sp[0x48],r0
800026c4:	80 00       	ld.sh	r0,r0[0x0]
800026c6:	51 2e       	stdsp	sp[0x48],lr

800026c8 <pm_set_osc0_mode>:
 *
 * \param pm Base address of the Power Manager (i.e. &AVR32_PM).
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
800026c8:	eb cd 40 80 	pushm	r7,lr
800026cc:	1a 97       	mov	r7,sp
800026ce:	20 3d       	sub	sp,12
800026d0:	ef 4c ff f8 	st.w	r7[-8],r12
800026d4:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800026d8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800026dc:	70 a8       	ld.w	r8,r8[0x28]
800026de:	30 09       	mov	r9,0
800026e0:	ef 49 ff fc 	st.w	r7[-4],r9
800026e4:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800026e8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800026ec:	5c 58       	castu.b	r8
800026ee:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800026f2:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800026f6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800026fa:	f1 d9 d0 03 	bfins	r8,r9,0x0,0x3
800026fe:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002702:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002706:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000270a:	91 a9       	st.w	r8[0x28],r9
}
8000270c:	2f dd       	sub	sp,-12
8000270e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002712:	d7 03       	nop

80002714 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80002714:	eb cd 40 80 	pushm	r7,lr
80002718:	1a 97       	mov	r7,sp
8000271a:	20 2d       	sub	sp,8
8000271c:	ef 4c ff fc 	st.w	r7[-4],r12
80002720:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80002724:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002728:	ec 58 bb 9f 	cp.w	r8,899999
8000272c:	e0 88 00 1a 	brls	80002760 <pm_enable_osc0_crystal+0x4c>
80002730:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002734:	e0 69 c6 bf 	mov	r9,50879
80002738:	ea 19 00 2d 	orh	r9,0x2d
8000273c:	12 38       	cp.w	r8,r9
8000273e:	e0 88 00 0f 	brls	8000275c <pm_enable_osc0_crystal+0x48>
80002742:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002746:	e0 69 11 ff 	mov	r9,4607
8000274a:	ea 19 00 7a 	orh	r9,0x7a
8000274e:	12 38       	cp.w	r8,r9
80002750:	e0 8b 00 04 	brhi	80002758 <pm_enable_osc0_crystal+0x44>
80002754:	30 68       	mov	r8,6
80002756:	c0 28       	rjmp	8000275a <pm_enable_osc0_crystal+0x46>
80002758:	30 78       	mov	r8,7
8000275a:	c0 28       	rjmp	8000275e <pm_enable_osc0_crystal+0x4a>
8000275c:	30 58       	mov	r8,5
8000275e:	c0 28       	rjmp	80002762 <pm_enable_osc0_crystal+0x4e>
80002760:	30 48       	mov	r8,4
80002762:	10 9b       	mov	r11,r8
80002764:	ee fc ff fc 	ld.w	r12,r7[-4]
80002768:	f0 1f 00 03 	mcall	80002774 <pm_enable_osc0_crystal+0x60>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000276c:	2f ed       	sub	sp,-8
8000276e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002772:	00 00       	add	r0,r0
80002774:	80 00       	ld.sh	r0,r0[0x0]
80002776:	26 c8       	sub	r8,108

80002778 <pm_enable_clk0>:


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80002778:	eb cd 40 80 	pushm	r7,lr
8000277c:	1a 97       	mov	r7,sp
8000277e:	20 2d       	sub	sp,8
80002780:	ef 4c ff fc 	st.w	r7[-4],r12
80002784:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_enable_clk0_no_wait(pm, startup);
80002788:	ee fb ff f8 	ld.w	r11,r7[-8]
8000278c:	ee fc ff fc 	ld.w	r12,r7[-4]
80002790:	f0 1f 00 05 	mcall	800027a4 <pm_enable_clk0+0x2c>
  pm_wait_for_clk0_ready(pm);
80002794:	ee fc ff fc 	ld.w	r12,r7[-4]
80002798:	f0 1f 00 04 	mcall	800027a8 <pm_enable_clk0+0x30>
}
8000279c:	2f ed       	sub	sp,-8
8000279e:	e3 cd 80 80 	ldm	sp++,r7,pc
800027a2:	00 00       	add	r0,r0
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	27 ac       	sub	r12,122
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	28 06       	sub	r6,-128

800027ac <pm_enable_clk0_no_wait>:
  pm->mcctrl &= ~AVR32_PM_MCCTRL_OSC0EN_MASK;
}


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
800027ac:	eb cd 40 80 	pushm	r7,lr
800027b0:	1a 97       	mov	r7,sp
800027b2:	20 3d       	sub	sp,12
800027b4:	ef 4c ff f8 	st.w	r7[-8],r12
800027b8:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800027bc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027c0:	70 a8       	ld.w	r8,r8[0x28]
800027c2:	30 09       	mov	r9,0
800027c4:	ef 49 ff fc 	st.w	r7[-4],r9
800027c8:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800027cc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800027d0:	5c 58       	castu.b	r8
800027d2:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800027d6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800027da:	ee f8 ff fc 	ld.w	r8,r7[-4]
800027de:	f1 d9 d1 03 	bfins	r8,r9,0x8,0x3
800027e2:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800027e6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800027ea:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027ee:	91 a9       	st.w	r8[0x28],r9

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800027f0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027f4:	70 08       	ld.w	r8,r8[0x0]
800027f6:	10 99       	mov	r9,r8
800027f8:	a3 a9       	sbr	r9,0x2
800027fa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027fe:	91 09       	st.w	r8[0x0],r9
}
80002800:	2f dd       	sub	sp,-12
80002802:	e3 cd 80 80 	ldm	sp++,r7,pc

80002806 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
80002806:	eb cd 40 80 	pushm	r7,lr
8000280a:	1a 97       	mov	r7,sp
8000280c:	20 1d       	sub	sp,4
8000280e:	ef 4c ff fc 	st.w	r7[-4],r12
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80002812:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002816:	71 58       	ld.w	r8,r8[0x54]
80002818:	e2 18 00 80 	andl	r8,0x80,COH
8000281c:	cf b0       	breq	80002812 <pm_wait_for_clk0_ready+0xc>
}
8000281e:	2f fd       	sub	sp,-4
80002820:	e3 cd 80 80 	ldm	sp++,r7,pc

80002824 <pm_switch_to_clock>:
  return u_avr32_pm_mcctrl.MCCTRL.mcsel;
}


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
80002824:	eb cd 40 80 	pushm	r7,lr
80002828:	1a 97       	mov	r7,sp
8000282a:	20 3d       	sub	sp,12
8000282c:	ef 4c ff f8 	st.w	r7[-8],r12
80002830:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80002834:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002838:	70 08       	ld.w	r8,r8[0x0]
8000283a:	30 09       	mov	r9,0
8000283c:	ef 49 ff fc 	st.w	r7[-4],r9
80002840:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80002844:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002848:	5c 58       	castu.b	r8
8000284a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000284e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80002852:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002856:	f1 d9 d0 02 	bfins	r8,r9,0x0,0x2
8000285a:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000285e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002862:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002866:	91 09       	st.w	r8[0x0],r9
}
80002868:	2f dd       	sub	sp,-12
8000286a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000286e:	d7 03       	nop

80002870 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80002870:	eb cd 40 80 	pushm	r7,lr
80002874:	1a 97       	mov	r7,sp
80002876:	20 3d       	sub	sp,12
80002878:	ef 4c ff fc 	st.w	r7[-4],r12
8000287c:	ef 4b ff f8 	st.w	r7[-8],r11
80002880:	ef 4a ff f4 	st.w	r7[-12],r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80002884:	ee fb ff f8 	ld.w	r11,r7[-8]
80002888:	ee fc ff fc 	ld.w	r12,r7[-4]
8000288c:	f0 1f 00 08 	mcall	800028ac <pm_switch_to_osc0+0x3c>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80002890:	ee fb ff f4 	ld.w	r11,r7[-12]
80002894:	ee fc ff fc 	ld.w	r12,r7[-4]
80002898:	f0 1f 00 06 	mcall	800028b0 <pm_switch_to_osc0+0x40>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
8000289c:	30 1b       	mov	r11,1
8000289e:	ee fc ff fc 	ld.w	r12,r7[-4]
800028a2:	f0 1f 00 05 	mcall	800028b4 <pm_switch_to_osc0+0x44>
}
800028a6:	2f dd       	sub	sp,-12
800028a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	27 14       	sub	r4,113
800028b0:	80 00       	ld.sh	r0,r0[0x0]
800028b2:	27 78       	sub	r8,119
800028b4:	80 00       	ld.sh	r0,r0[0x0]
800028b6:	28 24       	sub	r4,-126

800028b8 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
800028b8:	eb cd 40 80 	pushm	r7,lr
800028bc:	1a 97       	mov	r7,sp
800028be:	20 1d       	sub	sp,4
800028c0:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
800028c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800028c8:	e6 18 00 01 	andh	r8,0x1,COH
800028cc:	5f 08       	sreq	r8
800028ce:	5c 58       	castu.b	r8
}
800028d0:	10 9c       	mov	r12,r8
800028d2:	2f fd       	sub	sp,-4
800028d4:	e3 cd 80 80 	ldm	sp++,r7,pc

800028d8 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800028d8:	eb cd 40 80 	pushm	r7,lr
800028dc:	1a 97       	mov	r7,sp
800028de:	20 7d       	sub	sp,28
800028e0:	ef 4c ff ec 	st.w	r7[-20],r12
800028e4:	ef 4b ff e8 	st.w	r7[-24],r11
800028e8:	ef 4a ff e4 	st.w	r7[-28],r10
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800028ec:	ee f8 ff e8 	ld.w	r8,r7[-24]
800028f0:	f0 09 15 04 	lsl	r9,r8,0x4
800028f4:	ee f8 ff e4 	ld.w	r8,r7[-28]
800028f8:	10 39       	cp.w	r9,r8
800028fa:	e0 8b 00 04 	brhi	80002902 <usart_set_async_baudrate+0x2a>
800028fe:	31 08       	mov	r8,16
80002900:	c0 28       	rjmp	80002904 <usart_set_async_baudrate+0x2c>
80002902:	30 88       	mov	r8,8
80002904:	ef 48 ff f0 	st.w	r7[-16],r8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80002908:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000290c:	f0 09 15 03 	lsl	r9,r8,0x3
80002910:	ee fa ff f0 	ld.w	r10,r7[-16]
80002914:	ee f8 ff e8 	ld.w	r8,r7[-24]
80002918:	f4 08 02 48 	mul	r8,r10,r8
8000291c:	a1 98       	lsr	r8,0x1
8000291e:	f2 08 00 08 	add	r8,r9,r8
80002922:	ee fa ff f0 	ld.w	r10,r7[-16]
80002926:	ee f9 ff e8 	ld.w	r9,r7[-24]
8000292a:	f4 09 02 49 	mul	r9,r10,r9
8000292e:	f0 09 0d 08 	divu	r8,r8,r9
80002932:	ef 48 ff f4 	st.w	r7[-12],r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80002936:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000293a:	a3 98       	lsr	r8,0x3
8000293c:	ef 48 ff f8 	st.w	r7[-8],r8
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);
80002940:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002944:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80002948:	ef 48 ff fc 	st.w	r7[-4],r8

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
8000294c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002950:	58 08       	cp.w	r8,0
80002952:	c0 70       	breq	80002960 <usart_set_async_baudrate+0x88>
80002954:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002958:	e0 48 ff ff 	cp.w	r8,65535
8000295c:	e0 88 00 04 	brls	80002964 <usart_set_async_baudrate+0x8c>
    return USART_INVALID_INPUT;
80002960:	30 18       	mov	r8,1
80002962:	c2 08       	rjmp	800029a2 <usart_set_async_baudrate+0xca>

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80002964:	ee f8 ff ec 	ld.w	r8,r7[-20]
80002968:	70 18       	ld.w	r8,r8[0x4]
8000296a:	10 99       	mov	r9,r8
8000296c:	e4 19 ff f7 	andh	r9,0xfff7
80002970:	e0 19 fe cf 	andl	r9,0xfecf
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80002974:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002978:	59 08       	cp.w	r8,16
8000297a:	c0 40       	breq	80002982 <usart_set_async_baudrate+0xaa>
8000297c:	e8 68 00 00 	mov	r8,524288
80002980:	c0 28       	rjmp	80002984 <usart_set_async_baudrate+0xac>
80002982:	30 08       	mov	r8,0
80002984:	10 49       	or	r9,r8
80002986:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000298a:	91 19       	st.w	r8[0x4],r9
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
                fp << AVR32_USART_BRGR_FP_OFFSET;
8000298c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002990:	f0 09 15 10 	lsl	r9,r8,0x10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80002994:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002998:	10 49       	or	r9,r8
8000299a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000299e:	91 89       	st.w	r8[0x20],r9
                fp << AVR32_USART_BRGR_FP_OFFSET;

  return USART_SUCCESS;
800029a0:	30 08       	mov	r8,0
}
800029a2:	10 9c       	mov	r12,r8
800029a4:	2f 9d       	sub	sp,-28
800029a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800029aa:	d7 03       	nop

800029ac <usart_reset>:
 */
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
800029ac:	eb cd 40 80 	pushm	r7,lr
800029b0:	1a 97       	mov	r7,sp
800029b2:	20 2d       	sub	sp,8
800029b4:	ef 4c ff f8 	st.w	r7[-8],r12
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800029b8:	e1 b8 00 00 	mfsr	r8,0x0
800029bc:	10 9c       	mov	r12,r8
800029be:	f0 1f 00 18 	mcall	80002a1c <usart_reset+0x70>
800029c2:	18 98       	mov	r8,r12
800029c4:	ef 68 ff ff 	st.b	r7[-1],r8

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800029c8:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800029cc:	30 08       	mov	r8,0
800029ce:	f0 09 18 00 	cp.b	r9,r8
800029d2:	c0 20       	breq	800029d6 <usart_reset+0x2a>
800029d4:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800029d6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800029da:	3f f9       	mov	r9,-1
800029dc:	91 39       	st.w	r8[0xc],r9
  usart->csr;
800029de:	ee f8 ff f8 	ld.w	r8,r7[-8]
800029e2:	70 58       	ld.w	r8,r8[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800029e4:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800029e8:	30 08       	mov	r8,0
800029ea:	f0 09 18 00 	cp.b	r9,r8
800029ee:	c0 20       	breq	800029f2 <usart_reset+0x46>
800029f0:	d5 03       	csrf	0x10

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800029f2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800029f6:	30 09       	mov	r9,0
800029f8:	91 19       	st.w	r8[0x4],r9
  usart->rtor = 0;
800029fa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800029fe:	30 09       	mov	r9,0
80002a00:	91 99       	st.w	r8[0x24],r9
  usart->ttgr = 0;
80002a02:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a06:	30 09       	mov	r9,0
80002a08:	91 a9       	st.w	r8[0x28],r9

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80002a0a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a0e:	ea 69 61 0c 	mov	r9,680204
80002a12:	91 09       	st.w	r8[0x0],r9
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80002a14:	2f ed       	sub	sp,-8
80002a16:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a1a:	00 00       	add	r0,r0
80002a1c:	80 00       	ld.sh	r0,r0[0x0]
80002a1e:	28 b8       	sub	r8,-117

80002a20 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80002a20:	eb cd 40 80 	pushm	r7,lr
80002a24:	1a 97       	mov	r7,sp
80002a26:	20 3d       	sub	sp,12
80002a28:	ef 4c ff fc 	st.w	r7[-4],r12
80002a2c:	ef 4b ff f8 	st.w	r7[-8],r11
80002a30:	ef 4a ff f4 	st.w	r7[-12],r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80002a34:	ee fc ff fc 	ld.w	r12,r7[-4]
80002a38:	f0 1f 00 54 	mcall	80002b88 <usart_init_rs232+0x168>

  // Check input values.
  if (!opt || // Null pointer.
80002a3c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a40:	58 08       	cp.w	r8,0
80002a42:	c3 90       	breq	80002ab4 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80002a44:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a48:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002a4a:	30 48       	mov	r8,4
80002a4c:	f0 09 18 00 	cp.b	r9,r8
80002a50:	e0 88 00 32 	brls	80002ab4 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80002a54:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a58:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002a5a:	30 98       	mov	r8,9
80002a5c:	f0 09 18 00 	cp.b	r9,r8
80002a60:	e0 8b 00 2a 	brhi	80002ab4 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80002a64:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a68:	11 d9       	ld.ub	r9,r8[0x5]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002a6a:	30 78       	mov	r8,7
80002a6c:	f0 09 18 00 	cp.b	r9,r8
80002a70:	e0 8b 00 22 	brhi	80002ab4 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
80002a74:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a78:	90 39       	ld.sh	r9,r8[0x6]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002a7a:	e0 68 01 01 	mov	r8,257
80002a7e:	f0 09 19 00 	cp.h	r9,r8
80002a82:	e0 8b 00 19 	brhi	80002ab4 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
80002a86:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a8a:	f1 39 00 08 	ld.ub	r9,r8[8]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002a8e:	30 38       	mov	r8,3
80002a90:	f0 09 18 00 	cp.b	r9,r8
80002a94:	e0 8b 00 10 	brhi	80002ab4 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80002a98:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002a9c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002aa0:	70 08       	ld.w	r8,r8[0x0]
80002aa2:	12 9a       	mov	r10,r9
80002aa4:	10 9b       	mov	r11,r8
80002aa6:	ee fc ff fc 	ld.w	r12,r7[-4]
80002aaa:	f0 1f 00 39 	mcall	80002b8c <usart_init_rs232+0x16c>
80002aae:	18 98       	mov	r8,r12
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002ab0:	58 18       	cp.w	r8,1
80002ab2:	c0 31       	brne	80002ab8 <usart_init_rs232+0x98>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;
80002ab4:	30 18       	mov	r8,1
80002ab6:	c6 48       	rjmp	80002b7e <usart_init_rs232+0x15e>

  if (opt->charlength == 9)
80002ab8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002abc:	11 c9       	ld.ub	r9,r8[0x4]
80002abe:	30 98       	mov	r8,9
80002ac0:	f0 09 18 00 	cp.b	r9,r8
80002ac4:	c0 a1       	brne	80002ad8 <usart_init_rs232+0xb8>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80002ac6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002aca:	70 18       	ld.w	r8,r8[0x4]
80002acc:	10 99       	mov	r9,r8
80002ace:	b1 b9       	sbr	r9,0x11
80002ad0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ad4:	91 19       	st.w	r8[0x4],r9
80002ad6:	c0 d8       	rjmp	80002af0 <usart_init_rs232+0xd0>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80002ad8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002adc:	70 19       	ld.w	r9,r8[0x4]
80002ade:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ae2:	11 c8       	ld.ub	r8,r8[0x4]
80002ae4:	20 58       	sub	r8,5
80002ae6:	a7 68       	lsl	r8,0x6
80002ae8:	10 49       	or	r9,r8
80002aea:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002aee:	91 19       	st.w	r8[0x4],r9
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80002af0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002af4:	70 19       	ld.w	r9,r8[0x4]
80002af6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002afa:	11 d8       	ld.ub	r8,r8[0x5]
80002afc:	f0 0a 15 09 	lsl	r10,r8,0x9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;
80002b00:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b04:	f1 38 00 08 	ld.ub	r8,r8[8]
80002b08:	af 68       	lsl	r8,0xe
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80002b0a:	f5 e8 10 08 	or	r8,r10,r8
80002b0e:	10 49       	or	r9,r8
80002b10:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b14:	91 19       	st.w	r8[0x4],r9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80002b16:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b1a:	90 39       	ld.sh	r9,r8[0x6]
80002b1c:	30 28       	mov	r8,2
80002b1e:	f0 09 19 00 	cp.h	r9,r8
80002b22:	e0 88 00 14 	brls	80002b4a <usart_init_rs232+0x12a>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80002b26:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b2a:	70 18       	ld.w	r8,r8[0x4]
80002b2c:	10 99       	mov	r9,r8
80002b2e:	ad b9       	sbr	r9,0xd
80002b30:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b34:	91 19       	st.w	r8[0x4],r9
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80002b36:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b3a:	90 38       	ld.sh	r8,r8[0x6]
80002b3c:	5c 78       	castu.h	r8
80002b3e:	20 28       	sub	r8,2
80002b40:	10 99       	mov	r9,r8
80002b42:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b46:	91 a9       	st.w	r8[0x28],r9
80002b48:	c0 d8       	rjmp	80002b62 <usart_init_rs232+0x142>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80002b4a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b4e:	70 19       	ld.w	r9,r8[0x4]
80002b50:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b54:	90 38       	ld.sh	r8,r8[0x6]
80002b56:	5c 78       	castu.h	r8
80002b58:	ad 68       	lsl	r8,0xc
80002b5a:	10 49       	or	r9,r8
80002b5c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b60:	91 19       	st.w	r8[0x4],r9

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80002b62:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b66:	70 18       	ld.w	r8,r8[0x4]
80002b68:	10 99       	mov	r9,r8
80002b6a:	e0 19 ff f0 	andl	r9,0xfff0
80002b6e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b72:	91 19       	st.w	r8[0x4],r9
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80002b74:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b78:	35 09       	mov	r9,80
80002b7a:	91 09       	st.w	r8[0x0],r9
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80002b7c:	30 08       	mov	r8,0
}
80002b7e:	10 9c       	mov	r12,r8
80002b80:	2f dd       	sub	sp,-12
80002b82:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b86:	00 00       	add	r0,r0
80002b88:	80 00       	ld.sh	r0,r0[0x0]
80002b8a:	29 ac       	sub	r12,-102
80002b8c:	80 00       	ld.sh	r0,r0[0x0]
80002b8e:	28 d8       	sub	r8,-115

80002b90 <usart_write_char>:
  return USART_SUCCESS;
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
80002b90:	eb cd 40 80 	pushm	r7,lr
80002b94:	1a 97       	mov	r7,sp
80002b96:	20 3d       	sub	sp,12
80002b98:	ef 4c ff f8 	st.w	r7[-8],r12
80002b9c:	ef 4b ff f4 	st.w	r7[-12],r11
80002ba0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ba4:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80002ba8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002bac:	70 58       	ld.w	r8,r8[0x14]
80002bae:	e2 18 00 02 	andl	r8,0x2,COH
80002bb2:	5f 18       	srne	r8
  if (usart_tx_ready(usart))
80002bb4:	58 08       	cp.w	r8,0
80002bb6:	c0 a0       	breq	80002bca <usart_write_char+0x3a>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80002bb8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002bbc:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80002bc0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bc4:	91 79       	st.w	r8[0x1c],r9
    return USART_SUCCESS;
80002bc6:	30 08       	mov	r8,0
80002bc8:	c0 28       	rjmp	80002bcc <usart_write_char+0x3c>
  }
  else
    return USART_TX_BUSY;
80002bca:	30 28       	mov	r8,2
}
80002bcc:	10 9c       	mov	r12,r8
80002bce:	2f dd       	sub	sp,-12
80002bd0:	e3 cd 80 80 	ldm	sp++,r7,pc

80002bd4 <usart_putchar>:


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80002bd4:	eb cd 40 80 	pushm	r7,lr
80002bd8:	1a 97       	mov	r7,sp
80002bda:	20 3d       	sub	sp,12
80002bdc:	ef 4c ff f8 	st.w	r7[-8],r12
80002be0:	ef 4b ff f4 	st.w	r7[-12],r11
  int timeout = USART_DEFAULT_TIMEOUT;
80002be4:	e0 68 27 10 	mov	r8,10000
80002be8:	ef 48 ff fc 	st.w	r7[-4],r8

  do
  {
    if (!timeout--) return USART_FAILURE;
80002bec:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002bf0:	58 08       	cp.w	r8,0
80002bf2:	5f 08       	sreq	r8
80002bf4:	5c 58       	castu.b	r8
80002bf6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002bfa:	20 19       	sub	r9,1
80002bfc:	ef 49 ff fc 	st.w	r7[-4],r9
80002c00:	58 08       	cp.w	r8,0
80002c02:	c0 30       	breq	80002c08 <usart_putchar+0x34>
80002c04:	3f f8       	mov	r8,-1
80002c06:	c0 b8       	rjmp	80002c1c <usart_putchar+0x48>
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80002c08:	ee fb ff f4 	ld.w	r11,r7[-12]
80002c0c:	ee fc ff f8 	ld.w	r12,r7[-8]
80002c10:	f0 1f 00 05 	mcall	80002c24 <usart_putchar+0x50>
80002c14:	18 98       	mov	r8,r12
80002c16:	58 08       	cp.w	r8,0
80002c18:	ce a1       	brne	80002bec <usart_putchar+0x18>

  return USART_SUCCESS;
80002c1a:	30 08       	mov	r8,0
}
80002c1c:	10 9c       	mov	r12,r8
80002c1e:	2f dd       	sub	sp,-12
80002c20:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c24:	80 00       	ld.sh	r0,r0[0x0]
80002c26:	2b 90       	sub	r0,-71

80002c28 <usart_write_line>:
  return c;
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80002c28:	eb cd 40 80 	pushm	r7,lr
80002c2c:	1a 97       	mov	r7,sp
80002c2e:	20 2d       	sub	sp,8
80002c30:	ef 4c ff fc 	st.w	r7[-4],r12
80002c34:	ef 4b ff f8 	st.w	r7[-8],r11
  while (*string != '\0')
80002c38:	c0 e8       	rjmp	80002c54 <usart_write_line+0x2c>
    usart_putchar(usart, *string++);
80002c3a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c3e:	11 88       	ld.ub	r8,r8[0x0]
80002c40:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002c44:	2f f9       	sub	r9,-1
80002c46:	ef 49 ff f8 	st.w	r7[-8],r9
80002c4a:	10 9b       	mov	r11,r8
80002c4c:	ee fc ff fc 	ld.w	r12,r7[-4]
80002c50:	f0 1f 00 05 	mcall	80002c64 <usart_write_line+0x3c>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80002c54:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c58:	11 88       	ld.ub	r8,r8[0x0]
80002c5a:	58 08       	cp.w	r8,0
80002c5c:	ce f1       	brne	80002c3a <usart_write_line+0x12>
    usart_putchar(usart, *string++);
}
80002c5e:	2f ed       	sub	sp,-8
80002c60:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c64:	80 00       	ld.sh	r0,r0[0x0]
80002c66:	2b d4       	sub	r4,-67

80002c68 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
80002c68:	eb cd 40 80 	pushm	r7,lr
80002c6c:	1a 97       	mov	r7,sp
80002c6e:	20 1d       	sub	sp,4
80002c70:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80002c74:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c78:	2f 88       	sub	r8,-8
80002c7a:	10 99       	mov	r9,r8
80002c7c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c80:	91 19       	st.w	r8[0x4],r9

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80002c82:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c86:	3f f9       	mov	r9,-1
80002c88:	91 29       	st.w	r8[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80002c8a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c8e:	2f 88       	sub	r8,-8
80002c90:	10 99       	mov	r9,r8
80002c92:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c96:	91 39       	st.w	r8[0xc],r9
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80002c98:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c9c:	2f 88       	sub	r8,-8
80002c9e:	10 99       	mov	r9,r8
80002ca0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ca4:	91 49       	st.w	r8[0x10],r9

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80002ca6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002caa:	30 09       	mov	r9,0
80002cac:	91 09       	st.w	r8[0x0],r9
}
80002cae:	2f fd       	sub	sp,-4
80002cb0:	e3 cd 80 80 	ldm	sp++,r7,pc

80002cb4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
80002cb4:	eb cd 40 80 	pushm	r7,lr
80002cb8:	1a 97       	mov	r7,sp
80002cba:	20 1d       	sub	sp,4
80002cbc:	ef 4c ff fc 	st.w	r7[-4],r12
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80002cc0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002cc4:	30 09       	mov	r9,0
80002cc6:	91 49       	st.w	r8[0x10],r9
}
80002cc8:	2f fd       	sub	sp,-4
80002cca:	e3 cd 80 80 	ldm	sp++,r7,pc

80002cce <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
80002cce:	eb cd 40 80 	pushm	r7,lr
80002cd2:	1a 97       	mov	r7,sp
80002cd4:	20 3d       	sub	sp,12
80002cd6:	ef 4c ff f8 	st.w	r7[-8],r12
80002cda:	ef 4b ff f4 	st.w	r7[-12],r11

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80002cde:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ce2:	70 18       	ld.w	r8,r8[0x4]
80002ce4:	ef 48 ff fc 	st.w	r7[-4],r8

	pxNewListItem->pxNext = pxIndex->pxNext;
80002ce8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002cec:	70 19       	ld.w	r9,r8[0x4]
80002cee:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002cf2:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80002cf4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002cf8:	70 19       	ld.w	r9,r8[0x4]
80002cfa:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002cfe:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80002d00:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d04:	70 18       	ld.w	r8,r8[0x4]
80002d06:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002d0a:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80002d0c:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002d10:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d14:	91 19       	st.w	r8[0x4],r9
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80002d16:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002d1a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d1e:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80002d20:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002d24:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002d28:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80002d2a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d2e:	70 08       	ld.w	r8,r8[0x0]
80002d30:	f0 c9 ff ff 	sub	r9,r8,-1
80002d34:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d38:	91 09       	st.w	r8[0x0],r9
}
80002d3a:	2f dd       	sub	sp,-12
80002d3c:	e3 cd 80 80 	ldm	sp++,r7,pc

80002d40 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
80002d40:	eb cd 40 80 	pushm	r7,lr
80002d44:	1a 97       	mov	r7,sp
80002d46:	20 4d       	sub	sp,16
80002d48:	ef 4c ff f4 	st.w	r7[-12],r12
80002d4c:	ef 4b ff f0 	st.w	r7[-16],r11
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80002d50:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d54:	70 08       	ld.w	r8,r8[0x0]
80002d56:	ef 48 ff fc 	st.w	r7[-4],r8
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80002d5a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d5e:	5b f8       	cp.w	r8,-1
80002d60:	c0 71       	brne	80002d6e <vListInsert+0x2e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80002d62:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002d66:	70 48       	ld.w	r8,r8[0x10]
80002d68:	ef 48 ff f8 	st.w	r7[-8],r8
80002d6c:	c1 58       	rjmp	80002d96 <vListInsert+0x56>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80002d6e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002d72:	2f 88       	sub	r8,-8
80002d74:	ef 48 ff f8 	st.w	r7[-8],r8
80002d78:	c0 68       	rjmp	80002d84 <vListInsert+0x44>
80002d7a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d7e:	70 18       	ld.w	r8,r8[0x4]
80002d80:	ef 48 ff f8 	st.w	r7[-8],r8
80002d84:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d88:	70 18       	ld.w	r8,r8[0x4]
80002d8a:	70 09       	ld.w	r9,r8[0x0]
80002d8c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d90:	10 39       	cp.w	r9,r8
80002d92:	fe 98 ff f4 	brls	80002d7a <vListInsert+0x3a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80002d96:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d9a:	70 19       	ld.w	r9,r8[0x4]
80002d9c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002da0:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80002da2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002da6:	70 18       	ld.w	r8,r8[0x4]
80002da8:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002dac:	91 29       	st.w	r8[0x8],r9
	pxNewListItem->pxPrevious = pxIterator;
80002dae:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002db2:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002db6:	91 29       	st.w	r8[0x8],r9
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80002db8:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002dbc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dc0:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80002dc2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002dc6:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002dca:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80002dcc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002dd0:	70 08       	ld.w	r8,r8[0x0]
80002dd2:	f0 c9 ff ff 	sub	r9,r8,-1
80002dd6:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002dda:	91 09       	st.w	r8[0x0],r9
}
80002ddc:	2f cd       	sub	sp,-16
80002dde:	e3 cd 80 80 	ldm	sp++,r7,pc

80002de2 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
80002de2:	eb cd 40 80 	pushm	r7,lr
80002de6:	1a 97       	mov	r7,sp
80002de8:	20 2d       	sub	sp,8
80002dea:	ef 4c ff f8 	st.w	r7[-8],r12
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80002dee:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002df2:	70 18       	ld.w	r8,r8[0x4]
80002df4:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002df8:	72 29       	ld.w	r9,r9[0x8]
80002dfa:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80002dfc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e00:	70 28       	ld.w	r8,r8[0x8]
80002e02:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002e06:	72 19       	ld.w	r9,r9[0x4]
80002e08:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80002e0a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e0e:	70 48       	ld.w	r8,r8[0x10]
80002e10:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80002e14:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e18:	70 19       	ld.w	r9,r8[0x4]
80002e1a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e1e:	10 39       	cp.w	r9,r8
80002e20:	c0 71       	brne	80002e2e <vListRemove+0x4c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80002e22:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e26:	70 29       	ld.w	r9,r8[0x8]
80002e28:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e2c:	91 19       	st.w	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80002e2e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e32:	30 09       	mov	r9,0
80002e34:	91 49       	st.w	r8[0x10],r9
	( pxList->uxNumberOfItems )--;
80002e36:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e3a:	70 08       	ld.w	r8,r8[0x0]
80002e3c:	f0 c9 00 01 	sub	r9,r8,1
80002e40:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e44:	91 09       	st.w	r8[0x0],r9
}
80002e46:	2f ed       	sub	sp,-8
80002e48:	e3 cd 80 80 	ldm	sp++,r7,pc

80002e4c <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80002e4c:	eb cd 40 80 	pushm	r7,lr
80002e50:	1a 97       	mov	r7,sp
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
80002e52:	48 e8       	lddpc	r8,80002e88 <_init_startup+0x3c>
80002e54:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
80002e58:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
80002e5a:	f0 1f 00 0d 	mcall	80002e8c <_init_startup+0x40>
			.channelmode = USART_NORMAL_CHMODE
		};

		/* Initialize the USART used for the debug trace with the configured parameters. */
		extern volatile avr32_usart_t *volatile stdio_usart_base;
		stdio_usart_base = configDBG_USART;
80002e5e:	48 d8       	lddpc	r8,80002e90 <_init_startup+0x44>
80002e60:	fe 79 18 00 	mov	r9,-59392
80002e64:	91 09       	st.w	r8[0x0],r9
		gpio_enable_module( DBG_USART_GPIO_MAP,
80002e66:	30 2b       	mov	r11,2
80002e68:	48 bc       	lddpc	r12,80002e94 <_init_startup+0x48>
80002e6a:	f0 1f 00 0c 	mcall	80002e98 <_init_startup+0x4c>
		                    sizeof( DBG_USART_GPIO_MAP ) / sizeof( DBG_USART_GPIO_MAP[0] ) );
		usart_init_rs232(configDBG_USART, &DBG_USART_OPTIONS, configPBA_CLOCK_HZ);
80002e6e:	e0 6a 1b 00 	mov	r10,6912
80002e72:	ea 1a 00 b7 	orh	r10,0xb7
80002e76:	48 ab       	lddpc	r11,80002e9c <_init_startup+0x50>
80002e78:	fe 7c 18 00 	mov	r12,-59392
80002e7c:	f0 1f 00 09 	mcall	80002ea0 <_init_startup+0x54>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
80002e80:	30 18       	mov	r8,1
}
80002e82:	10 9c       	mov	r12,r8
80002e84:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e88:	80 00       	ld.sh	r0,r0[0x0]
80002e8a:	50 00       	stdsp	sp[0x0],r0
80002e8c:	80 00       	ld.sh	r0,r0[0x0]
80002e8e:	25 5c       	sub	r12,85
80002e90:	00 00       	add	r0,r0
80002e92:	07 98       	ld.ub	r8,r3[0x1]
80002e94:	80 00       	ld.sh	r0,r0[0x0]
80002e96:	52 e4       	stdsp	sp[0xb8],r4
80002e98:	80 00       	ld.sh	r0,r0[0x0]
80002e9a:	23 50       	sub	r0,53
80002e9c:	80 00       	ld.sh	r0,r0[0x0]
80002e9e:	52 f4       	stdsp	sp[0xbc],r4
80002ea0:	80 00       	ld.sh	r0,r0[0x0]
80002ea2:	2a 20       	sub	r0,-94

80002ea4 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80002ea4:	eb cd 40 80 	pushm	r7,lr
80002ea8:	1a 97       	mov	r7,sp
80002eaa:	20 1d       	sub	sp,4
80002eac:	ef 4c ff fc 	st.w	r7[-4],r12
	vTaskSuspendAll();
80002eb0:	f0 1f 00 03 	mcall	80002ebc <__malloc_lock+0x18>
}
80002eb4:	2f fd       	sub	sp,-4
80002eb6:	e3 cd 80 80 	ldm	sp++,r7,pc
80002eba:	00 00       	add	r0,r0
80002ebc:	80 00       	ld.sh	r0,r0[0x0]
80002ebe:	3b e8       	mov	r8,-66

80002ec0 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80002ec0:	eb cd 40 80 	pushm	r7,lr
80002ec4:	1a 97       	mov	r7,sp
80002ec6:	20 1d       	sub	sp,4
80002ec8:	ef 4c ff fc 	st.w	r7[-4],r12
	xTaskResumeAll();
80002ecc:	f0 1f 00 03 	mcall	80002ed8 <__malloc_unlock+0x18>
}
80002ed0:	2f fd       	sub	sp,-4
80002ed2:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ed6:	00 00       	add	r0,r0
80002ed8:	80 00       	ld.sh	r0,r0[0x0]
80002eda:	3c 04       	mov	r4,-64

80002edc <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80002edc:	eb cd 00 ff 	pushm	r0-r7
80002ee0:	e0 68 00 1c 	mov	r8,28
80002ee4:	ea 18 00 00 	orh	r8,0x0
80002ee8:	70 00       	ld.w	r0,r8[0x0]
80002eea:	1a d0       	st.w	--sp,r0
80002eec:	7a 90       	ld.w	r0,sp[0x24]
80002eee:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80002ef2:	58 10       	cp.w	r0,1
80002ef4:	e0 8b 00 08 	brhi	80002f04 <LABEL_INT_SKIP_SAVE_CONTEXT_234>
80002ef8:	e0 68 06 1c 	mov	r8,1564
80002efc:	ea 18 00 00 	orh	r8,0x0
80002f00:	70 00       	ld.w	r0,r8[0x0]
80002f02:	81 0d       	st.w	r0[0x0],sp

80002f04 <LABEL_INT_SKIP_SAVE_CONTEXT_234>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80002f04:	f0 1f 00 12 	mcall	80002f4c <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80002f08:	f0 1f 00 12 	mcall	80002f50 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
		vTaskIncrementTick();
80002f0c:	f0 1f 00 12 	mcall	80002f54 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x1c>
	portEXIT_CRITICAL();
80002f10:	f0 1f 00 12 	mcall	80002f58 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80002f14:	7a 90       	ld.w	r0,sp[0x24]
80002f16:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80002f1a:	58 10       	cp.w	r0,1
80002f1c:	e0 8b 00 0e 	brhi	80002f38 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
80002f20:	f0 1f 00 0c 	mcall	80002f50 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
80002f24:	f0 1f 00 0e 	mcall	80002f5c <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x24>
80002f28:	f0 1f 00 0c 	mcall	80002f58 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>
80002f2c:	e0 68 06 1c 	mov	r8,1564
80002f30:	ea 18 00 00 	orh	r8,0x0
80002f34:	70 00       	ld.w	r0,r8[0x0]
80002f36:	60 0d       	ld.w	sp,r0[0x0]

80002f38 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>:
80002f38:	1b 00       	ld.w	r0,sp++
80002f3a:	e0 68 00 1c 	mov	r8,28
80002f3e:	ea 18 00 00 	orh	r8,0x0
80002f42:	91 00       	st.w	r8[0x0],r0
80002f44:	e3 cd 00 ff 	ldm	sp++,r0-r7
80002f48:	d6 03       	rete
80002f4a:	00 00       	add	r0,r0
80002f4c:	80 00       	ld.sh	r0,r0[0x0]
80002f4e:	32 48       	mov	r8,36
80002f50:	80 00       	ld.sh	r0,r0[0x0]
80002f52:	2f f8       	sub	r8,-1
80002f54:	80 00       	ld.sh	r0,r0[0x0]
80002f56:	3d 5c       	mov	r12,-43
80002f58:	80 00       	ld.sh	r0,r0[0x0]
80002f5a:	30 14       	mov	r4,1
80002f5c:	80 00       	ld.sh	r0,r0[0x0]
80002f5e:	3e bc       	mov	r12,-21

80002f60 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80002f60:	20 6d       	sub	sp,24
80002f62:	eb cd 00 ff 	pushm	r0-r7
80002f66:	fa c7 ff c0 	sub	r7,sp,-64
80002f6a:	ee f0 ff f8 	ld.w	r0,r7[-8]
80002f6e:	ef 40 ff e0 	st.w	r7[-32],r0
80002f72:	ee f0 ff fc 	ld.w	r0,r7[-4]
80002f76:	ef 40 ff e4 	st.w	r7[-28],r0
80002f7a:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80002f7e:	e0 68 00 1c 	mov	r8,28
80002f82:	ea 18 00 00 	orh	r8,0x0
80002f86:	70 00       	ld.w	r0,r8[0x0]
80002f88:	1a d0       	st.w	--sp,r0
80002f8a:	f0 1f 00 1a 	mcall	80002ff0 <LABEL_RET_SCALL_260+0x14>
80002f8e:	e0 68 06 1c 	mov	r8,1564
80002f92:	ea 18 00 00 	orh	r8,0x0
80002f96:	70 00       	ld.w	r0,r8[0x0]
80002f98:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80002f9a:	f0 1f 00 17 	mcall	80002ff4 <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
80002f9e:	e0 68 06 1c 	mov	r8,1564
80002fa2:	ea 18 00 00 	orh	r8,0x0
80002fa6:	70 00       	ld.w	r0,r8[0x0]
80002fa8:	60 0d       	ld.w	sp,r0[0x0]
80002faa:	1b 00       	ld.w	r0,sp++
80002fac:	e0 68 00 1c 	mov	r8,28
80002fb0:	ea 18 00 00 	orh	r8,0x0
80002fb4:	91 00       	st.w	r8[0x0],r0
80002fb6:	fa c7 ff d8 	sub	r7,sp,-40
80002fba:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80002fbe:	ee f0 ff e0 	ld.w	r0,r7[-32]
80002fc2:	e0 61 00 1c 	mov	r1,28
80002fc6:	ea 11 00 00 	orh	r1,0x0
80002fca:	62 02       	ld.w	r2,r1[0x0]
80002fcc:	58 02       	cp.w	r2,0
80002fce:	c0 70       	breq	80002fdc <LABEL_RET_SCALL_260>
80002fd0:	e4 c2 00 01 	sub	r2,r2,1
80002fd4:	83 02       	st.w	r1[0x0],r2
80002fd6:	58 02       	cp.w	r2,0
80002fd8:	c0 21       	brne	80002fdc <LABEL_RET_SCALL_260>
80002fda:	b1 c0       	cbr	r0,0x10

80002fdc <LABEL_RET_SCALL_260>:
80002fdc:	ef 40 ff f8 	st.w	r7[-8],r0
80002fe0:	ee f0 ff e4 	ld.w	r0,r7[-28]
80002fe4:	ef 40 ff fc 	st.w	r7[-4],r0
80002fe8:	e3 cd 00 ff 	ldm	sp++,r0-r7
80002fec:	2f ad       	sub	sp,-24
80002fee:	d6 13       	rets
80002ff0:	80 00       	ld.sh	r0,r0[0x0]
80002ff2:	2f f8       	sub	r8,-1
80002ff4:	80 00       	ld.sh	r0,r0[0x0]
80002ff6:	3e bc       	mov	r12,-21

80002ff8 <vPortEnterCritical>:
/* The code generated by the GCC compiler uses the stack in different ways at
different optimisation levels.  The interrupt flags can therefore not always
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
80002ff8:	eb cd 40 80 	pushm	r7,lr
80002ffc:	1a 97       	mov	r7,sp
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80002ffe:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80003000:	48 48       	lddpc	r8,80003010 <vPortEnterCritical+0x18>
80003002:	70 08       	ld.w	r8,r8[0x0]
80003004:	f0 c9 ff ff 	sub	r9,r8,-1
80003008:	48 28       	lddpc	r8,80003010 <vPortEnterCritical+0x18>
8000300a:	91 09       	st.w	r8[0x0],r9
}
8000300c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003010:	00 00       	add	r0,r0
80003012:	00 1c       	sub	r12,r0

80003014 <vPortExitCritical>:
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
80003014:	eb cd 40 80 	pushm	r7,lr
80003018:	1a 97       	mov	r7,sp
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
8000301a:	48 98       	lddpc	r8,8000303c <vPortExitCritical+0x28>
8000301c:	70 08       	ld.w	r8,r8[0x0]
8000301e:	58 08       	cp.w	r8,0
80003020:	c0 c0       	breq	80003038 <vPortExitCritical+0x24>
	{
		ulCriticalNesting--;
80003022:	48 78       	lddpc	r8,8000303c <vPortExitCritical+0x28>
80003024:	70 08       	ld.w	r8,r8[0x0]
80003026:	f0 c9 00 01 	sub	r9,r8,1
8000302a:	48 58       	lddpc	r8,8000303c <vPortExitCritical+0x28>
8000302c:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
8000302e:	48 48       	lddpc	r8,8000303c <vPortExitCritical+0x28>
80003030:	70 08       	ld.w	r8,r8[0x0]
80003032:	58 08       	cp.w	r8,0
80003034:	c0 21       	brne	80003038 <vPortExitCritical+0x24>
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80003036:	d5 03       	csrf	0x10
		}
	}
}
80003038:	e3 cd 80 80 	ldm	sp++,r7,pc
8000303c:	00 00       	add	r0,r0
8000303e:	00 1c       	sub	r12,r0

80003040 <pxPortInitialiseStack>:
 * portSAVE_CONTEXT had been called.
 *
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
80003040:	eb cd 40 80 	pushm	r7,lr
80003044:	1a 97       	mov	r7,sp
80003046:	20 3d       	sub	sp,12
80003048:	ef 4c ff fc 	st.w	r7[-4],r12
8000304c:	ef 4b ff f8 	st.w	r7[-8],r11
80003050:	ef 4a ff f4 	st.w	r7[-12],r10
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
80003054:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003058:	20 48       	sub	r8,4
8000305a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
8000305e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003062:	e0 69 08 08 	mov	r9,2056
80003066:	ea 19 08 08 	orh	r9,0x808
8000306a:	91 09       	st.w	r8[0x0],r9
8000306c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003070:	20 48       	sub	r8,4
80003072:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80003076:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000307a:	e0 69 09 09 	mov	r9,2313
8000307e:	ea 19 09 09 	orh	r9,0x909
80003082:	91 09       	st.w	r8[0x0],r9
80003084:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003088:	20 48       	sub	r8,4
8000308a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
8000308e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003092:	e0 69 0a 0a 	mov	r9,2570
80003096:	ea 19 0a 0a 	orh	r9,0xa0a
8000309a:	91 09       	st.w	r8[0x0],r9
8000309c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030a0:	20 48       	sub	r8,4
800030a2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800030a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030aa:	e0 69 0b 0b 	mov	r9,2827
800030ae:	ea 19 0b 0b 	orh	r9,0xb0b
800030b2:	91 09       	st.w	r8[0x0],r9
800030b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030b8:	20 48       	sub	r8,4
800030ba:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800030be:	ee f9 ff f4 	ld.w	r9,r7[-12]
800030c2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030c6:	91 09       	st.w	r8[0x0],r9
800030c8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030cc:	20 48       	sub	r8,4
800030ce:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800030d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030d6:	e0 69 be ef 	mov	r9,48879
800030da:	ea 19 de ad 	orh	r9,0xdead
800030de:	91 09       	st.w	r8[0x0],r9
800030e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030e4:	20 48       	sub	r8,4
800030e6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
800030ea:	ee f9 ff f8 	ld.w	r9,r7[-8]
800030ee:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030f2:	91 09       	st.w	r8[0x0],r9
800030f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030f8:	20 48       	sub	r8,4
800030fa:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800030fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003102:	fc 19 00 40 	movh	r9,0x40
80003106:	91 09       	st.w	r8[0x0],r9
80003108:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000310c:	20 48       	sub	r8,4
8000310e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80003112:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003116:	e0 69 00 ff 	mov	r9,255
8000311a:	ea 19 ff 00 	orh	r9,0xff00
8000311e:	91 09       	st.w	r8[0x0],r9
80003120:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003124:	20 48       	sub	r8,4
80003126:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
8000312a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000312e:	e0 69 01 01 	mov	r9,257
80003132:	ea 19 01 01 	orh	r9,0x101
80003136:	91 09       	st.w	r8[0x0],r9
80003138:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000313c:	20 48       	sub	r8,4
8000313e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80003142:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003146:	e0 69 02 02 	mov	r9,514
8000314a:	ea 19 02 02 	orh	r9,0x202
8000314e:	91 09       	st.w	r8[0x0],r9
80003150:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003154:	20 48       	sub	r8,4
80003156:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
8000315a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000315e:	e0 69 03 03 	mov	r9,771
80003162:	ea 19 03 03 	orh	r9,0x303
80003166:	91 09       	st.w	r8[0x0],r9
80003168:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000316c:	20 48       	sub	r8,4
8000316e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80003172:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003176:	e0 69 04 04 	mov	r9,1028
8000317a:	ea 19 04 04 	orh	r9,0x404
8000317e:	91 09       	st.w	r8[0x0],r9
80003180:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003184:	20 48       	sub	r8,4
80003186:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
8000318a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000318e:	e0 69 05 05 	mov	r9,1285
80003192:	ea 19 05 05 	orh	r9,0x505
80003196:	91 09       	st.w	r8[0x0],r9
80003198:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000319c:	20 48       	sub	r8,4
8000319e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800031a2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031a6:	e0 69 06 06 	mov	r9,1542
800031aa:	ea 19 06 06 	orh	r9,0x606
800031ae:	91 09       	st.w	r8[0x0],r9
800031b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031b4:	20 48       	sub	r8,4
800031b6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800031ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031be:	e0 69 07 07 	mov	r9,1799
800031c2:	ea 19 07 07 	orh	r9,0x707
800031c6:	91 09       	st.w	r8[0x0],r9
800031c8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031cc:	20 48       	sub	r8,4
800031ce:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800031d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031d6:	30 09       	mov	r9,0
800031d8:	91 09       	st.w	r8[0x0],r9

	return pxTopOfStack;
800031da:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800031de:	10 9c       	mov	r12,r8
800031e0:	2f dd       	sub	sp,-12
800031e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800031e6:	d7 03       	nop

800031e8 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
800031e8:	eb cd 40 80 	pushm	r7,lr
800031ec:	1a 97       	mov	r7,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
800031ee:	f0 1f 00 10 	mcall	8000322c <xPortStartScheduler+0x44>

	/* Start the first task. */
	portRESTORE_CONTEXT();
800031f2:	e0 68 06 1c 	mov	r8,1564
800031f6:	ea 18 00 00 	orh	r8,0x0
800031fa:	70 00       	ld.w	r0,r8[0x0]
800031fc:	60 0d       	ld.w	sp,r0[0x0]
800031fe:	1b 00       	ld.w	r0,sp++
80003200:	e0 68 00 1c 	mov	r8,28
80003204:	ea 18 00 00 	orh	r8,0x0
80003208:	91 00       	st.w	r8[0x0],r0
8000320a:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000320e:	2f ed       	sub	sp,-8
80003210:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80003214:	fa f0 ff e0 	ld.w	r0,sp[-32]
80003218:	e3 b0 00 00 	mtsr	0x0,r0
8000321c:	fa f0 ff dc 	ld.w	r0,sp[-36]
80003220:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
80003224:	30 08       	mov	r8,0
}
80003226:	10 9c       	mov	r12,r8
80003228:	e3 cd 80 80 	ldm	sp++,r7,pc
8000322c:	80 00       	ld.sh	r0,r0[0x0]
8000322e:	32 5c       	mov	r12,37

80003230 <prvScheduleFirstTick>:

/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
80003230:	eb cd 40 80 	pushm	r7,lr
80003234:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
80003236:	e0 68 2e e0 	mov	r8,12000
8000323a:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
8000323e:	30 08       	mov	r8,0
80003240:	e3 b8 00 42 	mtsr	0x108,r8
	}
80003244:	e3 cd 80 80 	ldm	sp++,r7,pc

80003248 <prvClearCcInt>:

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
80003248:	eb cd 40 80 	pushm	r7,lr
8000324c:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
8000324e:	e1 b8 00 43 	mfsr	r8,0x10c
80003252:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80003256:	e3 cd 80 80 	ldm	sp++,r7,pc
8000325a:	d7 03       	nop

8000325c <prvSetupTimerInterrupt>:
#endif
/*-----------------------------------------------------------*/

/* Setup the timer to generate the tick interrupts. */
static void prvSetupTimerInterrupt(void)
{
8000325c:	eb cd 40 80 	pushm	r7,lr
80003260:	1a 97       	mov	r7,sp
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80003262:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80003264:	30 0a       	mov	r10,0
80003266:	30 0b       	mov	r11,0
80003268:	48 4c       	lddpc	r12,80003278 <prvSetupTimerInterrupt+0x1c>
8000326a:	f0 1f 00 05 	mcall	8000327c <prvSetupTimerInterrupt+0x20>
		prvScheduleFirstTick();
8000326e:	f0 1f 00 05 	mcall	80003280 <prvSetupTimerInterrupt+0x24>
	}
	#endif
}
80003272:	e3 cd 80 80 	ldm	sp++,r7,pc
80003276:	00 00       	add	r0,r0
80003278:	80 00       	ld.sh	r0,r0[0x0]
8000327a:	2e dc       	sub	r12,-19
8000327c:	80 00       	ld.sh	r0,r0[0x0]
8000327e:	25 f4       	sub	r4,95
80003280:	80 00       	ld.sh	r0,r0[0x0]
80003282:	32 30       	mov	r0,35

80003284 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80003284:	eb cd 40 80 	pushm	r7,lr
80003288:	1a 97       	mov	r7,sp
8000328a:	20 2d       	sub	sp,8
8000328c:	ef 4c ff f8 	st.w	r7[-8],r12
void *pvReturn;

	vTaskSuspendAll();
80003290:	f0 1f 00 09 	mcall	800032b4 <pvPortMalloc+0x30>
	{
		pvReturn = malloc( xWantedSize );
80003294:	ee fc ff f8 	ld.w	r12,r7[-8]
80003298:	f0 1f 00 08 	mcall	800032b8 <pvPortMalloc+0x34>
8000329c:	18 98       	mov	r8,r12
8000329e:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	xTaskResumeAll();
800032a2:	f0 1f 00 07 	mcall	800032bc <pvPortMalloc+0x38>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
800032a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800032aa:	10 9c       	mov	r12,r8
800032ac:	2f ed       	sub	sp,-8
800032ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800032b2:	00 00       	add	r0,r0
800032b4:	80 00       	ld.sh	r0,r0[0x0]
800032b6:	3b e8       	mov	r8,-66
800032b8:	80 00       	ld.sh	r0,r0[0x0]
800032ba:	45 2c       	lddsp	r12,sp[0x148]
800032bc:	80 00       	ld.sh	r0,r0[0x0]
800032be:	3c 04       	mov	r4,-64

800032c0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800032c0:	eb cd 40 80 	pushm	r7,lr
800032c4:	1a 97       	mov	r7,sp
800032c6:	20 1d       	sub	sp,4
800032c8:	ef 4c ff fc 	st.w	r7[-4],r12
	if( pv )
800032cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032d0:	58 08       	cp.w	r8,0
800032d2:	c0 90       	breq	800032e4 <vPortFree+0x24>
	{
		vTaskSuspendAll();
800032d4:	f0 1f 00 06 	mcall	800032ec <vPortFree+0x2c>
		{
			free( pv );
800032d8:	ee fc ff fc 	ld.w	r12,r7[-4]
800032dc:	f0 1f 00 05 	mcall	800032f0 <vPortFree+0x30>
		}
		xTaskResumeAll();
800032e0:	f0 1f 00 05 	mcall	800032f4 <vPortFree+0x34>
	}
}
800032e4:	2f fd       	sub	sp,-4
800032e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800032ea:	00 00       	add	r0,r0
800032ec:	80 00       	ld.sh	r0,r0[0x0]
800032ee:	3b e8       	mov	r8,-66
800032f0:	80 00       	ld.sh	r0,r0[0x0]
800032f2:	45 1c       	lddsp	r12,sp[0x144]
800032f4:	80 00       	ld.sh	r0,r0[0x0]
800032f6:	3c 04       	mov	r4,-64

800032f8 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800032f8:	eb cd 40 80 	pushm	r7,lr
800032fc:	1a 97       	mov	r7,sp
800032fe:	20 5d       	sub	sp,20
80003300:	ef 4c ff f0 	st.w	r7[-16],r12
80003304:	ef 4b ff ec 	st.w	r7[-20],r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
80003308:	30 08       	mov	r8,0
8000330a:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000330e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003312:	58 08       	cp.w	r8,0
80003314:	c7 20       	breq	800033f8 <xQueueCreate+0x100>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80003316:	34 cc       	mov	r12,76
80003318:	f0 1f 00 3b 	mcall	80003404 <xQueueCreate+0x10c>
8000331c:	18 98       	mov	r8,r12
8000331e:	ef 48 ff f4 	st.w	r7[-12],r8
		if( pxNewQueue != NULL )
80003322:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003326:	58 08       	cp.w	r8,0
80003328:	c6 80       	breq	800033f8 <xQueueCreate+0x100>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000332a:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000332e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003332:	f2 08 02 48 	mul	r8,r9,r8
80003336:	2f f8       	sub	r8,-1
80003338:	ef 48 ff f8 	st.w	r7[-8],r8

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
8000333c:	ee fc ff f8 	ld.w	r12,r7[-8]
80003340:	f0 1f 00 31 	mcall	80003404 <xQueueCreate+0x10c>
80003344:	18 98       	mov	r8,r12
80003346:	10 99       	mov	r9,r8
80003348:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000334c:	91 09       	st.w	r8[0x0],r9
			if( pxNewQueue->pcHead != NULL )
8000334e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003352:	70 08       	ld.w	r8,r8[0x0]
80003354:	58 08       	cp.w	r8,0
80003356:	c4 d0       	breq	800033f0 <xQueueCreate+0xf8>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80003358:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000335c:	70 09       	ld.w	r9,r8[0x0]
8000335e:	ee fa ff f0 	ld.w	r10,r7[-16]
80003362:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003366:	f4 08 02 48 	mul	r8,r10,r8
8000336a:	10 09       	add	r9,r8
8000336c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003370:	91 19       	st.w	r8[0x4],r9
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80003372:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003376:	30 09       	mov	r9,0
80003378:	91 e9       	st.w	r8[0x38],r9
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000337a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000337e:	70 09       	ld.w	r9,r8[0x0]
80003380:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003384:	91 29       	st.w	r8[0x8],r9
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80003386:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000338a:	70 09       	ld.w	r9,r8[0x0]
8000338c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003390:	f0 ca 00 01 	sub	r10,r8,1
80003394:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003398:	f4 08 02 48 	mul	r8,r10,r8
8000339c:	10 09       	add	r9,r8
8000339e:	ee f8 ff f4 	ld.w	r8,r7[-12]
800033a2:	91 39       	st.w	r8[0xc],r9
				pxNewQueue->uxLength = uxQueueLength;
800033a4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800033a8:	ee f9 ff f0 	ld.w	r9,r7[-16]
800033ac:	91 f9       	st.w	r8[0x3c],r9
				pxNewQueue->uxItemSize = uxItemSize;
800033ae:	ee f8 ff f4 	ld.w	r8,r7[-12]
800033b2:	ee f9 ff ec 	ld.w	r9,r7[-20]
800033b6:	f1 49 00 40 	st.w	r8[64],r9
				pxNewQueue->xRxLock = queueUNLOCKED;
800033ba:	ee f8 ff f4 	ld.w	r8,r7[-12]
800033be:	3f f9       	mov	r9,-1
800033c0:	f1 49 00 44 	st.w	r8[68],r9
				pxNewQueue->xTxLock = queueUNLOCKED;
800033c4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800033c8:	3f f9       	mov	r9,-1
800033ca:	f1 49 00 48 	st.w	r8[72],r9

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800033ce:	ee f8 ff f4 	ld.w	r8,r7[-12]
800033d2:	2f 08       	sub	r8,-16
800033d4:	10 9c       	mov	r12,r8
800033d6:	f0 1f 00 0d 	mcall	80003408 <xQueueCreate+0x110>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800033da:	ee f8 ff f4 	ld.w	r8,r7[-12]
800033de:	2d c8       	sub	r8,-36
800033e0:	10 9c       	mov	r12,r8
800033e2:	f0 1f 00 0a 	mcall	80003408 <xQueueCreate+0x110>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
800033e6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800033ea:	ef 48 ff fc 	st.w	r7[-4],r8
800033ee:	c0 58       	rjmp	800033f8 <xQueueCreate+0x100>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800033f0:	ee fc ff f4 	ld.w	r12,r7[-12]
800033f4:	f0 1f 00 06 	mcall	8000340c <xQueueCreate+0x114>
		}
	}

	configASSERT( xReturn );

	return xReturn;
800033f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800033fc:	10 9c       	mov	r12,r8
800033fe:	2f bd       	sub	sp,-20
80003400:	e3 cd 80 80 	ldm	sp++,r7,pc
80003404:	80 00       	ld.sh	r0,r0[0x0]
80003406:	32 84       	mov	r4,40
80003408:	80 00       	ld.sh	r0,r0[0x0]
8000340a:	2c 68       	sub	r8,-58
8000340c:	80 00       	ld.sh	r0,r0[0x0]
8000340e:	32 c0       	mov	r0,44

80003410 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80003410:	eb cd 40 80 	pushm	r7,lr
80003414:	1a 97       	mov	r7,sp
80003416:	20 7d       	sub	sp,28
80003418:	ef 4c ff f0 	st.w	r7[-16],r12
8000341c:	ef 4b ff ec 	st.w	r7[-20],r11
80003420:	ef 4a ff e8 	st.w	r7[-24],r10
80003424:	ef 49 ff e4 	st.w	r7[-28],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
80003428:	30 08       	mov	r8,0
8000342a:	ef 48 ff fc 	st.w	r7[-4],r8
8000342e:	c0 28       	rjmp	80003432 <xQueueGenericSend+0x22>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80003430:	d7 03       	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80003432:	f0 1f 00 47 	mcall	8000354c <xQueueGenericSend+0x13c>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80003436:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000343a:	70 e9       	ld.w	r9,r8[0x38]
8000343c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003440:	70 f8       	ld.w	r8,r8[0x3c]
80003442:	10 39       	cp.w	r9,r8
80003444:	c1 c2       	brcc	8000347c <xQueueGenericSend+0x6c>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80003446:	ee fa ff e4 	ld.w	r10,r7[-28]
8000344a:	ee fb ff ec 	ld.w	r11,r7[-20]
8000344e:	ee fc ff f0 	ld.w	r12,r7[-16]
80003452:	f0 1f 00 40 	mcall	80003550 <xQueueGenericSend+0x140>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80003456:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000345a:	70 98       	ld.w	r8,r8[0x24]
8000345c:	58 08       	cp.w	r8,0
8000345e:	c0 b0       	breq	80003474 <xQueueGenericSend+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80003460:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003464:	2d c8       	sub	r8,-36
80003466:	10 9c       	mov	r12,r8
80003468:	f0 1f 00 3b 	mcall	80003554 <xQueueGenericSend+0x144>
8000346c:	18 98       	mov	r8,r12
8000346e:	58 18       	cp.w	r8,1
80003470:	c0 21       	brne	80003474 <xQueueGenericSend+0x64>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80003472:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80003474:	f0 1f 00 39 	mcall	80003558 <xQueueGenericSend+0x148>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80003478:	30 18       	mov	r8,1
8000347a:	c6 58       	rjmp	80003544 <xQueueGenericSend+0x134>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000347c:	ee f8 ff e8 	ld.w	r8,r7[-24]
80003480:	58 08       	cp.w	r8,0
80003482:	c0 51       	brne	8000348c <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80003484:	f0 1f 00 35 	mcall	80003558 <xQueueGenericSend+0x148>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80003488:	30 08       	mov	r8,0
8000348a:	c5 d8       	rjmp	80003544 <xQueueGenericSend+0x134>
				}
				else if( xEntryTimeSet == pdFALSE )
8000348c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003490:	58 08       	cp.w	r8,0
80003492:	c0 91       	brne	800034a4 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80003494:	ee c8 00 0c 	sub	r8,r7,12
80003498:	10 9c       	mov	r12,r8
8000349a:	f0 1f 00 31 	mcall	8000355c <xQueueGenericSend+0x14c>
					xEntryTimeSet = pdTRUE;
8000349e:	30 18       	mov	r8,1
800034a0:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}
		}
		taskEXIT_CRITICAL();
800034a4:	f0 1f 00 2d 	mcall	80003558 <xQueueGenericSend+0x148>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800034a8:	f0 1f 00 2e 	mcall	80003560 <xQueueGenericSend+0x150>
		prvLockQueue( pxQueue );
800034ac:	f0 1f 00 28 	mcall	8000354c <xQueueGenericSend+0x13c>
800034b0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800034b4:	71 18       	ld.w	r8,r8[0x44]
800034b6:	5b f8       	cp.w	r8,-1
800034b8:	c0 61       	brne	800034c4 <xQueueGenericSend+0xb4>
800034ba:	ee f8 ff f0 	ld.w	r8,r7[-16]
800034be:	30 09       	mov	r9,0
800034c0:	f1 49 00 44 	st.w	r8[68],r9
800034c4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800034c8:	71 28       	ld.w	r8,r8[0x48]
800034ca:	5b f8       	cp.w	r8,-1
800034cc:	c0 61       	brne	800034d8 <xQueueGenericSend+0xc8>
800034ce:	ee f8 ff f0 	ld.w	r8,r7[-16]
800034d2:	30 09       	mov	r9,0
800034d4:	f1 49 00 48 	st.w	r8[72],r9
800034d8:	f0 1f 00 20 	mcall	80003558 <xQueueGenericSend+0x148>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800034dc:	ee c9 00 18 	sub	r9,r7,24
800034e0:	ee c8 00 0c 	sub	r8,r7,12
800034e4:	12 9b       	mov	r11,r9
800034e6:	10 9c       	mov	r12,r8
800034e8:	f0 1f 00 1f 	mcall	80003564 <xQueueGenericSend+0x154>
800034ec:	18 98       	mov	r8,r12
800034ee:	58 08       	cp.w	r8,0
800034f0:	c2 31       	brne	80003536 <xQueueGenericSend+0x126>
		{
			if( prvIsQueueFull( pxQueue ) )
800034f2:	ee fc ff f0 	ld.w	r12,r7[-16]
800034f6:	f0 1f 00 1d 	mcall	80003568 <xQueueGenericSend+0x158>
800034fa:	18 98       	mov	r8,r12
800034fc:	58 08       	cp.w	r8,0
800034fe:	c1 50       	breq	80003528 <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80003500:	ee f9 ff e8 	ld.w	r9,r7[-24]
80003504:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003508:	2f 08       	sub	r8,-16
8000350a:	12 9b       	mov	r11,r9
8000350c:	10 9c       	mov	r12,r8
8000350e:	f0 1f 00 18 	mcall	8000356c <xQueueGenericSend+0x15c>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80003512:	ee fc ff f0 	ld.w	r12,r7[-16]
80003516:	f0 1f 00 17 	mcall	80003570 <xQueueGenericSend+0x160>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
8000351a:	f0 1f 00 17 	mcall	80003574 <xQueueGenericSend+0x164>
8000351e:	18 98       	mov	r8,r12
80003520:	58 08       	cp.w	r8,0
80003522:	c8 71       	brne	80003430 <xQueueGenericSend+0x20>
				{
					portYIELD_WITHIN_API();
80003524:	d7 33       	scall
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80003526:	c8 6b       	rjmp	80003432 <xQueueGenericSend+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80003528:	ee fc ff f0 	ld.w	r12,r7[-16]
8000352c:	f0 1f 00 11 	mcall	80003570 <xQueueGenericSend+0x160>
				( void ) xTaskResumeAll();
80003530:	f0 1f 00 11 	mcall	80003574 <xQueueGenericSend+0x164>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80003534:	c7 fb       	rjmp	80003432 <xQueueGenericSend+0x22>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80003536:	ee fc ff f0 	ld.w	r12,r7[-16]
8000353a:	f0 1f 00 0e 	mcall	80003570 <xQueueGenericSend+0x160>
			( void ) xTaskResumeAll();
8000353e:	f0 1f 00 0e 	mcall	80003574 <xQueueGenericSend+0x164>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
80003542:	30 08       	mov	r8,0
		}
	}
}
80003544:	10 9c       	mov	r12,r8
80003546:	2f 9d       	sub	sp,-28
80003548:	e3 cd 80 80 	ldm	sp++,r7,pc
8000354c:	80 00       	ld.sh	r0,r0[0x0]
8000354e:	2f f8       	sub	r8,-1
80003550:	80 00       	ld.sh	r0,r0[0x0]
80003552:	37 24       	mov	r4,114
80003554:	80 00       	ld.sh	r0,r0[0x0]
80003556:	3f ec       	mov	r12,-2
80003558:	80 00       	ld.sh	r0,r0[0x0]
8000355a:	30 14       	mov	r4,1
8000355c:	80 00       	ld.sh	r0,r0[0x0]
8000355e:	40 bc       	lddsp	r12,sp[0x2c]
80003560:	80 00       	ld.sh	r0,r0[0x0]
80003562:	3b e8       	mov	r8,-66
80003564:	80 00       	ld.sh	r0,r0[0x0]
80003566:	40 ec       	lddsp	r12,sp[0x38]
80003568:	80 00       	ld.sh	r0,r0[0x0]
8000356a:	39 78       	mov	r8,-105
8000356c:	80 00       	ld.sh	r0,r0[0x0]
8000356e:	3f 6c       	mov	r12,-10
80003570:	80 00       	ld.sh	r0,r0[0x0]
80003572:	38 70       	mov	r0,-121
80003574:	80 00       	ld.sh	r0,r0[0x0]
80003576:	3c 04       	mov	r4,-64

80003578 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80003578:	eb cd 40 80 	pushm	r7,lr
8000357c:	1a 97       	mov	r7,sp
8000357e:	20 8d       	sub	sp,32
80003580:	ef 4c ff ec 	st.w	r7[-20],r12
80003584:	ef 4b ff e8 	st.w	r7[-24],r11
80003588:	ef 4a ff e4 	st.w	r7[-28],r10
8000358c:	ef 49 ff e0 	st.w	r7[-32],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
80003590:	30 08       	mov	r8,0
80003592:	ef 48 ff f8 	st.w	r7[-8],r8
80003596:	c0 28       	rjmp	8000359a <xQueueGenericReceive+0x22>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
80003598:	d7 03       	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8000359a:	f0 1f 00 58 	mcall	800036f8 <xQueueGenericReceive+0x180>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000359e:	ee f8 ff ec 	ld.w	r8,r7[-20]
800035a2:	70 e8       	ld.w	r8,r8[0x38]
800035a4:	58 08       	cp.w	r8,0
800035a6:	c4 00       	breq	80003626 <xQueueGenericReceive+0xae>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800035a8:	ee f8 ff ec 	ld.w	r8,r7[-20]
800035ac:	70 38       	ld.w	r8,r8[0xc]
800035ae:	ef 48 ff fc 	st.w	r7[-4],r8

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800035b2:	ee fb ff e8 	ld.w	r11,r7[-24]
800035b6:	ee fc ff ec 	ld.w	r12,r7[-20]
800035ba:	f0 1f 00 51 	mcall	800036fc <xQueueGenericReceive+0x184>

				if( xJustPeeking == pdFALSE )
800035be:	ee f8 ff e0 	ld.w	r8,r7[-32]
800035c2:	58 08       	cp.w	r8,0
800035c4:	c1 91       	brne	800035f6 <xQueueGenericReceive+0x7e>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800035c6:	ee f8 ff ec 	ld.w	r8,r7[-20]
800035ca:	70 e8       	ld.w	r8,r8[0x38]
800035cc:	f0 c9 00 01 	sub	r9,r8,1
800035d0:	ee f8 ff ec 	ld.w	r8,r7[-20]
800035d4:	91 e9       	st.w	r8[0x38],r9
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800035d6:	ee f8 ff ec 	ld.w	r8,r7[-20]
800035da:	70 48       	ld.w	r8,r8[0x10]
800035dc:	58 08       	cp.w	r8,0
800035de:	c2 00       	breq	8000361e <xQueueGenericReceive+0xa6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800035e0:	ee f8 ff ec 	ld.w	r8,r7[-20]
800035e4:	2f 08       	sub	r8,-16
800035e6:	10 9c       	mov	r12,r8
800035e8:	f0 1f 00 46 	mcall	80003700 <xQueueGenericReceive+0x188>
800035ec:	18 98       	mov	r8,r12
800035ee:	58 18       	cp.w	r8,1
800035f0:	c1 71       	brne	8000361e <xQueueGenericReceive+0xa6>
						{
							portYIELD_WITHIN_API();
800035f2:	d7 33       	scall
800035f4:	c1 58       	rjmp	8000361e <xQueueGenericReceive+0xa6>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800035f6:	ee f8 ff ec 	ld.w	r8,r7[-20]
800035fa:	ee f9 ff fc 	ld.w	r9,r7[-4]
800035fe:	91 39       	st.w	r8[0xc],r9

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80003600:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003604:	70 98       	ld.w	r8,r8[0x24]
80003606:	58 08       	cp.w	r8,0
80003608:	c0 b0       	breq	8000361e <xQueueGenericReceive+0xa6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000360a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000360e:	2d c8       	sub	r8,-36
80003610:	10 9c       	mov	r12,r8
80003612:	f0 1f 00 3c 	mcall	80003700 <xQueueGenericReceive+0x188>
80003616:	18 98       	mov	r8,r12
80003618:	58 08       	cp.w	r8,0
8000361a:	c0 20       	breq	8000361e <xQueueGenericReceive+0xa6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
8000361c:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
8000361e:	f0 1f 00 3a 	mcall	80003704 <xQueueGenericReceive+0x18c>
				return pdPASS;
80003622:	30 18       	mov	r8,1
80003624:	c6 68       	rjmp	800036f0 <xQueueGenericReceive+0x178>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80003626:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000362a:	58 08       	cp.w	r8,0
8000362c:	c0 51       	brne	80003636 <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000362e:	f0 1f 00 36 	mcall	80003704 <xQueueGenericReceive+0x18c>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80003632:	30 08       	mov	r8,0
80003634:	c5 e8       	rjmp	800036f0 <xQueueGenericReceive+0x178>
				}
				else if( xEntryTimeSet == pdFALSE )
80003636:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000363a:	58 08       	cp.w	r8,0
8000363c:	c0 91       	brne	8000364e <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000363e:	ee c8 00 10 	sub	r8,r7,16
80003642:	10 9c       	mov	r12,r8
80003644:	f0 1f 00 31 	mcall	80003708 <xQueueGenericReceive+0x190>
					xEntryTimeSet = pdTRUE;
80003648:	30 18       	mov	r8,1
8000364a:	ef 48 ff f8 	st.w	r7[-8],r8
				}
			}
		}
		taskEXIT_CRITICAL();
8000364e:	f0 1f 00 2e 	mcall	80003704 <xQueueGenericReceive+0x18c>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80003652:	f0 1f 00 2f 	mcall	8000370c <xQueueGenericReceive+0x194>
		prvLockQueue( pxQueue );
80003656:	f0 1f 00 29 	mcall	800036f8 <xQueueGenericReceive+0x180>
8000365a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000365e:	71 18       	ld.w	r8,r8[0x44]
80003660:	5b f8       	cp.w	r8,-1
80003662:	c0 61       	brne	8000366e <xQueueGenericReceive+0xf6>
80003664:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003668:	30 09       	mov	r9,0
8000366a:	f1 49 00 44 	st.w	r8[68],r9
8000366e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003672:	71 28       	ld.w	r8,r8[0x48]
80003674:	5b f8       	cp.w	r8,-1
80003676:	c0 61       	brne	80003682 <xQueueGenericReceive+0x10a>
80003678:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000367c:	30 09       	mov	r9,0
8000367e:	f1 49 00 48 	st.w	r8[72],r9
80003682:	f0 1f 00 21 	mcall	80003704 <xQueueGenericReceive+0x18c>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80003686:	ee c9 00 1c 	sub	r9,r7,28
8000368a:	ee c8 00 10 	sub	r8,r7,16
8000368e:	12 9b       	mov	r11,r9
80003690:	10 9c       	mov	r12,r8
80003692:	f0 1f 00 20 	mcall	80003710 <xQueueGenericReceive+0x198>
80003696:	18 98       	mov	r8,r12
80003698:	58 08       	cp.w	r8,0
8000369a:	c2 41       	brne	800036e2 <xQueueGenericReceive+0x16a>
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000369c:	ee fc ff ec 	ld.w	r12,r7[-20]
800036a0:	f0 1f 00 1d 	mcall	80003714 <xQueueGenericReceive+0x19c>
800036a4:	18 98       	mov	r8,r12
800036a6:	58 08       	cp.w	r8,0
800036a8:	c1 60       	breq	800036d4 <xQueueGenericReceive+0x15c>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800036aa:	ee f9 ff e4 	ld.w	r9,r7[-28]
800036ae:	ee f8 ff ec 	ld.w	r8,r7[-20]
800036b2:	2d c8       	sub	r8,-36
800036b4:	12 9b       	mov	r11,r9
800036b6:	10 9c       	mov	r12,r8
800036b8:	f0 1f 00 18 	mcall	80003718 <xQueueGenericReceive+0x1a0>
				prvUnlockQueue( pxQueue );
800036bc:	ee fc ff ec 	ld.w	r12,r7[-20]
800036c0:	f0 1f 00 17 	mcall	8000371c <xQueueGenericReceive+0x1a4>
				if( !xTaskResumeAll() )
800036c4:	f0 1f 00 17 	mcall	80003720 <xQueueGenericReceive+0x1a8>
800036c8:	18 98       	mov	r8,r12
800036ca:	58 08       	cp.w	r8,0
800036cc:	fe 91 ff 66 	brne	80003598 <xQueueGenericReceive+0x20>
				{
					portYIELD_WITHIN_API();
800036d0:	d7 33       	scall
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800036d2:	c6 4b       	rjmp	8000359a <xQueueGenericReceive+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800036d4:	ee fc ff ec 	ld.w	r12,r7[-20]
800036d8:	f0 1f 00 11 	mcall	8000371c <xQueueGenericReceive+0x1a4>
				( void ) xTaskResumeAll();
800036dc:	f0 1f 00 11 	mcall	80003720 <xQueueGenericReceive+0x1a8>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800036e0:	c5 db       	rjmp	8000359a <xQueueGenericReceive+0x22>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800036e2:	ee fc ff ec 	ld.w	r12,r7[-20]
800036e6:	f0 1f 00 0e 	mcall	8000371c <xQueueGenericReceive+0x1a4>
			( void ) xTaskResumeAll();
800036ea:	f0 1f 00 0e 	mcall	80003720 <xQueueGenericReceive+0x1a8>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
800036ee:	30 08       	mov	r8,0
		}
	}
}
800036f0:	10 9c       	mov	r12,r8
800036f2:	2f 8d       	sub	sp,-32
800036f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800036f8:	80 00       	ld.sh	r0,r0[0x0]
800036fa:	2f f8       	sub	r8,-1
800036fc:	80 00       	ld.sh	r0,r0[0x0]
800036fe:	38 04       	mov	r4,-128
80003700:	80 00       	ld.sh	r0,r0[0x0]
80003702:	3f ec       	mov	r12,-2
80003704:	80 00       	ld.sh	r0,r0[0x0]
80003706:	30 14       	mov	r4,1
80003708:	80 00       	ld.sh	r0,r0[0x0]
8000370a:	40 bc       	lddsp	r12,sp[0x2c]
8000370c:	80 00       	ld.sh	r0,r0[0x0]
8000370e:	3b e8       	mov	r8,-66
80003710:	80 00       	ld.sh	r0,r0[0x0]
80003712:	40 ec       	lddsp	r12,sp[0x38]
80003714:	80 00       	ld.sh	r0,r0[0x0]
80003716:	39 40       	mov	r0,-108
80003718:	80 00       	ld.sh	r0,r0[0x0]
8000371a:	3f 6c       	mov	r12,-10
8000371c:	80 00       	ld.sh	r0,r0[0x0]
8000371e:	38 70       	mov	r0,-121
80003720:	80 00       	ld.sh	r0,r0[0x0]
80003722:	3c 04       	mov	r4,-64

80003724 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80003724:	eb cd 40 80 	pushm	r7,lr
80003728:	1a 97       	mov	r7,sp
8000372a:	20 3d       	sub	sp,12
8000372c:	ef 4c ff fc 	st.w	r7[-4],r12
80003730:	ef 4b ff f8 	st.w	r7[-8],r11
80003734:	ef 4a ff f4 	st.w	r7[-12],r10
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80003738:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000373c:	71 08       	ld.w	r8,r8[0x40]
8000373e:	58 08       	cp.w	r8,0
80003740:	c5 40       	breq	800037e8 <prvCopyDataToQueue+0xc4>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80003742:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003746:	58 08       	cp.w	r8,0
80003748:	c2 61       	brne	80003794 <prvCopyDataToQueue+0x70>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000374a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000374e:	71 09       	ld.w	r9,r8[0x40]
80003750:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003754:	70 28       	ld.w	r8,r8[0x8]
80003756:	12 9a       	mov	r10,r9
80003758:	ee fb ff f8 	ld.w	r11,r7[-8]
8000375c:	10 9c       	mov	r12,r8
8000375e:	f0 1f 00 29 	mcall	80003800 <prvCopyDataToQueue+0xdc>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80003762:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003766:	70 29       	ld.w	r9,r8[0x8]
80003768:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000376c:	71 08       	ld.w	r8,r8[0x40]
8000376e:	10 09       	add	r9,r8
80003770:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003774:	91 29       	st.w	r8[0x8],r9
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80003776:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000377a:	70 29       	ld.w	r9,r8[0x8]
8000377c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003780:	70 18       	ld.w	r8,r8[0x4]
80003782:	10 39       	cp.w	r9,r8
80003784:	c3 23       	brcs	800037e8 <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80003786:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000378a:	70 09       	ld.w	r9,r8[0x0]
8000378c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003790:	91 29       	st.w	r8[0x8],r9
80003792:	c2 b8       	rjmp	800037e8 <prvCopyDataToQueue+0xc4>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80003794:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003798:	71 09       	ld.w	r9,r8[0x40]
8000379a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000379e:	70 38       	ld.w	r8,r8[0xc]
800037a0:	12 9a       	mov	r10,r9
800037a2:	ee fb ff f8 	ld.w	r11,r7[-8]
800037a6:	10 9c       	mov	r12,r8
800037a8:	f0 1f 00 16 	mcall	80003800 <prvCopyDataToQueue+0xdc>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800037ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800037b0:	70 39       	ld.w	r9,r8[0xc]
800037b2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800037b6:	71 08       	ld.w	r8,r8[0x40]
800037b8:	5c 38       	neg	r8
800037ba:	10 09       	add	r9,r8
800037bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800037c0:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800037c2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800037c6:	70 39       	ld.w	r9,r8[0xc]
800037c8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800037cc:	70 08       	ld.w	r8,r8[0x0]
800037ce:	10 39       	cp.w	r9,r8
800037d0:	c0 c2       	brcc	800037e8 <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800037d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800037d6:	70 19       	ld.w	r9,r8[0x4]
800037d8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800037dc:	71 08       	ld.w	r8,r8[0x40]
800037de:	5c 38       	neg	r8
800037e0:	10 09       	add	r9,r8
800037e2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800037e6:	91 39       	st.w	r8[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800037e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800037ec:	70 e8       	ld.w	r8,r8[0x38]
800037ee:	f0 c9 ff ff 	sub	r9,r8,-1
800037f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800037f6:	91 e9       	st.w	r8[0x38],r9
}
800037f8:	2f dd       	sub	sp,-12
800037fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800037fe:	00 00       	add	r0,r0
80003800:	80 00       	ld.sh	r0,r0[0x0]
80003802:	49 70       	lddpc	r0,8000385c <prvCopyDataFromQueue+0x58>

80003804 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80003804:	eb cd 40 80 	pushm	r7,lr
80003808:	1a 97       	mov	r7,sp
8000380a:	20 2d       	sub	sp,8
8000380c:	ef 4c ff fc 	st.w	r7[-4],r12
80003810:	ef 4b ff f8 	st.w	r7[-8],r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80003814:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003818:	70 08       	ld.w	r8,r8[0x0]
8000381a:	58 08       	cp.w	r8,0
8000381c:	c2 50       	breq	80003866 <prvCopyDataFromQueue+0x62>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000381e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003822:	70 39       	ld.w	r9,r8[0xc]
80003824:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003828:	71 08       	ld.w	r8,r8[0x40]
8000382a:	10 09       	add	r9,r8
8000382c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003830:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80003832:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003836:	70 39       	ld.w	r9,r8[0xc]
80003838:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000383c:	70 18       	ld.w	r8,r8[0x4]
8000383e:	10 39       	cp.w	r9,r8
80003840:	c0 73       	brcs	8000384e <prvCopyDataFromQueue+0x4a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80003842:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003846:	70 09       	ld.w	r9,r8[0x0]
80003848:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000384c:	91 39       	st.w	r8[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
8000384e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003852:	71 09       	ld.w	r9,r8[0x40]
80003854:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003858:	70 38       	ld.w	r8,r8[0xc]
8000385a:	12 9a       	mov	r10,r9
8000385c:	10 9b       	mov	r11,r8
8000385e:	ee fc ff f8 	ld.w	r12,r7[-8]
80003862:	f0 1f 00 03 	mcall	8000386c <prvCopyDataFromQueue+0x68>
	}
}
80003866:	2f ed       	sub	sp,-8
80003868:	e3 cd 80 80 	ldm	sp++,r7,pc
8000386c:	80 00       	ld.sh	r0,r0[0x0]
8000386e:	49 70       	lddpc	r0,800038c8 <prvUnlockQueue+0x58>

80003870 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80003870:	eb cd 40 80 	pushm	r7,lr
80003874:	1a 97       	mov	r7,sp
80003876:	20 1d       	sub	sp,4
80003878:	ef 4c ff fc 	st.w	r7[-4],r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000387c:	f0 1f 00 2d 	mcall	80003930 <prvUnlockQueue+0xc0>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80003880:	c1 a8       	rjmp	800038b4 <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80003882:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003886:	70 98       	ld.w	r8,r8[0x24]
80003888:	58 08       	cp.w	r8,0
8000388a:	c1 c0       	breq	800038c2 <prvUnlockQueue+0x52>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000388c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003890:	2d c8       	sub	r8,-36
80003892:	10 9c       	mov	r12,r8
80003894:	f0 1f 00 28 	mcall	80003934 <prvUnlockQueue+0xc4>
80003898:	18 98       	mov	r8,r12
8000389a:	58 08       	cp.w	r8,0
8000389c:	c0 30       	breq	800038a2 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
8000389e:	f0 1f 00 27 	mcall	80003938 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xTxLock );
800038a2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038a6:	71 28       	ld.w	r8,r8[0x48]
800038a8:	f0 c9 00 01 	sub	r9,r8,1
800038ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038b0:	f1 49 00 48 	st.w	r8[72],r9
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800038b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038b8:	71 28       	ld.w	r8,r8[0x48]
800038ba:	58 08       	cp.w	r8,0
800038bc:	fe 99 ff e3 	brgt	80003882 <prvUnlockQueue+0x12>
800038c0:	c0 28       	rjmp	800038c4 <prvUnlockQueue+0x54>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
800038c2:	d7 03       	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800038c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038c8:	3f f9       	mov	r9,-1
800038ca:	f1 49 00 48 	st.w	r8[72],r9
	}
	taskEXIT_CRITICAL();
800038ce:	f0 1f 00 1c 	mcall	8000393c <prvUnlockQueue+0xcc>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800038d2:	f0 1f 00 18 	mcall	80003930 <prvUnlockQueue+0xc0>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800038d6:	c1 a8       	rjmp	8000390a <prvUnlockQueue+0x9a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800038d8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038dc:	70 48       	ld.w	r8,r8[0x10]
800038de:	58 08       	cp.w	r8,0
800038e0:	c1 c0       	breq	80003918 <prvUnlockQueue+0xa8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800038e2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038e6:	2f 08       	sub	r8,-16
800038e8:	10 9c       	mov	r12,r8
800038ea:	f0 1f 00 13 	mcall	80003934 <prvUnlockQueue+0xc4>
800038ee:	18 98       	mov	r8,r12
800038f0:	58 08       	cp.w	r8,0
800038f2:	c0 30       	breq	800038f8 <prvUnlockQueue+0x88>
				{
					vTaskMissedYield();
800038f4:	f0 1f 00 11 	mcall	80003938 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xRxLock );
800038f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038fc:	71 18       	ld.w	r8,r8[0x44]
800038fe:	f0 c9 00 01 	sub	r9,r8,1
80003902:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003906:	f1 49 00 44 	st.w	r8[68],r9
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000390a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000390e:	71 18       	ld.w	r8,r8[0x44]
80003910:	58 08       	cp.w	r8,0
80003912:	fe 99 ff e3 	brgt	800038d8 <prvUnlockQueue+0x68>
80003916:	c0 28       	rjmp	8000391a <prvUnlockQueue+0xaa>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
80003918:	d7 03       	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
8000391a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000391e:	3f f9       	mov	r9,-1
80003920:	f1 49 00 44 	st.w	r8[68],r9
	}
	taskEXIT_CRITICAL();
80003924:	f0 1f 00 06 	mcall	8000393c <prvUnlockQueue+0xcc>
}
80003928:	2f fd       	sub	sp,-4
8000392a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000392e:	00 00       	add	r0,r0
80003930:	80 00       	ld.sh	r0,r0[0x0]
80003932:	2f f8       	sub	r8,-1
80003934:	80 00       	ld.sh	r0,r0[0x0]
80003936:	3f ec       	mov	r12,-2
80003938:	80 00       	ld.sh	r0,r0[0x0]
8000393a:	41 a4       	lddsp	r4,sp[0x68]
8000393c:	80 00       	ld.sh	r0,r0[0x0]
8000393e:	30 14       	mov	r4,1

80003940 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
80003940:	eb cd 40 80 	pushm	r7,lr
80003944:	1a 97       	mov	r7,sp
80003946:	20 2d       	sub	sp,8
80003948:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000394c:	f0 1f 00 09 	mcall	80003970 <prvIsQueueEmpty+0x30>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80003950:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003954:	70 e8       	ld.w	r8,r8[0x38]
80003956:	58 08       	cp.w	r8,0
80003958:	5f 08       	sreq	r8
8000395a:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
8000395e:	f0 1f 00 06 	mcall	80003974 <prvIsQueueEmpty+0x34>

	return xReturn;
80003962:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80003966:	10 9c       	mov	r12,r8
80003968:	2f ed       	sub	sp,-8
8000396a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000396e:	00 00       	add	r0,r0
80003970:	80 00       	ld.sh	r0,r0[0x0]
80003972:	2f f8       	sub	r8,-1
80003974:	80 00       	ld.sh	r0,r0[0x0]
80003976:	30 14       	mov	r4,1

80003978 <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
80003978:	eb cd 40 80 	pushm	r7,lr
8000397c:	1a 97       	mov	r7,sp
8000397e:	20 2d       	sub	sp,8
80003980:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80003984:	f0 1f 00 0a 	mcall	800039ac <prvIsQueueFull+0x34>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80003988:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000398c:	70 e9       	ld.w	r9,r8[0x38]
8000398e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003992:	70 f8       	ld.w	r8,r8[0x3c]
80003994:	10 39       	cp.w	r9,r8
80003996:	5f 08       	sreq	r8
80003998:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
8000399c:	f0 1f 00 05 	mcall	800039b0 <prvIsQueueFull+0x38>

	return xReturn;
800039a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800039a4:	10 9c       	mov	r12,r8
800039a6:	2f ed       	sub	sp,-8
800039a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800039ac:	80 00       	ld.sh	r0,r0[0x0]
800039ae:	2f f8       	sub	r8,-1
800039b0:	80 00       	ld.sh	r0,r0[0x0]
800039b2:	30 14       	mov	r4,1
800039b4:	49 44       	lddpc	r4,80003a04 <xTaskGenericCreate+0x48>
800039b6:	4c 45       	lddpc	r5,80003ac4 <xTaskGenericCreate+0x108>
800039b8:	00 00       	add	r0,r0
	...

800039bc <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800039bc:	eb cd 40 c0 	pushm	r6-r7,lr
800039c0:	1a 97       	mov	r7,sp
800039c2:	20 8d       	sub	sp,32
800039c4:	ee c6 ff f4 	sub	r6,r7,-12
800039c8:	ef 4c ff f0 	st.w	r7[-16],r12
800039cc:	ef 4b ff ec 	st.w	r7[-20],r11
800039d0:	ef 49 ff e4 	st.w	r7[-28],r9
800039d4:	ef 48 ff e0 	st.w	r7[-32],r8
800039d8:	14 98       	mov	r8,r10
800039da:	ef 58 ff e8 	st.h	r7[-24],r8
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
800039de:	ef 18 ff e8 	ld.uh	r8,r7[-24]
800039e2:	6c 1b       	ld.w	r11,r6[0x4]
800039e4:	10 9c       	mov	r12,r8
800039e6:	f0 1f 00 5a 	mcall	80003b4c <xTaskGenericCreate+0x190>
800039ea:	18 98       	mov	r8,r12
800039ec:	ef 48 ff f8 	st.w	r7[-8],r8

	if( pxNewTCB != NULL )
800039f0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800039f4:	58 08       	cp.w	r8,0
800039f6:	e0 80 00 92 	breq	80003b1a <xTaskGenericCreate+0x15e>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
800039fa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800039fe:	70 c9       	ld.w	r9,r8[0x30]
80003a00:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80003a04:	20 18       	sub	r8,1
80003a06:	a3 68       	lsl	r8,0x2
80003a08:	f2 08 00 08 	add	r8,r9,r8
80003a0c:	ef 48 ff fc 	st.w	r7[-4],r8
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80003a10:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a14:	e0 18 ff fc 	andl	r8,0xfffc
80003a18:	ef 48 ff fc 	st.w	r7[-4],r8
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
80003a1c:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80003a20:	6c 29       	ld.w	r9,r6[0x8]
80003a22:	ee fa ff e0 	ld.w	r10,r7[-32]
80003a26:	ee fb ff ec 	ld.w	r11,r7[-20]
80003a2a:	ee fc ff f8 	ld.w	r12,r7[-8]
80003a2e:	f0 1f 00 49 	mcall	80003b50 <xTaskGenericCreate+0x194>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80003a32:	ee fa ff e4 	ld.w	r10,r7[-28]
80003a36:	ee fb ff f0 	ld.w	r11,r7[-16]
80003a3a:	ee fc ff fc 	ld.w	r12,r7[-4]
80003a3e:	f0 1f 00 46 	mcall	80003b54 <xTaskGenericCreate+0x198>
80003a42:	18 98       	mov	r8,r12
80003a44:	10 99       	mov	r9,r8
80003a46:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003a4a:	91 09       	st.w	r8[0x0],r9
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
80003a4c:	6c 08       	ld.w	r8,r6[0x0]
80003a4e:	58 08       	cp.w	r8,0
80003a50:	c0 50       	breq	80003a5a <xTaskGenericCreate+0x9e>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80003a52:	6c 08       	ld.w	r8,r6[0x0]
80003a54:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003a58:	91 09       	st.w	r8[0x0],r9
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80003a5a:	f0 1f 00 40 	mcall	80003b58 <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
80003a5e:	4c 08       	lddpc	r8,80003b5c <xTaskGenericCreate+0x1a0>
80003a60:	70 08       	ld.w	r8,r8[0x0]
80003a62:	f0 c9 ff ff 	sub	r9,r8,-1
80003a66:	4b e8       	lddpc	r8,80003b5c <xTaskGenericCreate+0x1a0>
80003a68:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80003a6a:	4b e8       	lddpc	r8,80003b60 <xTaskGenericCreate+0x1a4>
80003a6c:	70 08       	ld.w	r8,r8[0x0]
80003a6e:	58 08       	cp.w	r8,0
80003a70:	c0 c1       	brne	80003a88 <xTaskGenericCreate+0xcc>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80003a72:	4b c8       	lddpc	r8,80003b60 <xTaskGenericCreate+0x1a4>
80003a74:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003a78:	91 09       	st.w	r8[0x0],r9

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80003a7a:	4b 98       	lddpc	r8,80003b5c <xTaskGenericCreate+0x1a0>
80003a7c:	70 08       	ld.w	r8,r8[0x0]
80003a7e:	58 18       	cp.w	r8,1
80003a80:	c1 41       	brne	80003aa8 <xTaskGenericCreate+0xec>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
80003a82:	f0 1f 00 39 	mcall	80003b64 <xTaskGenericCreate+0x1a8>
80003a86:	c1 18       	rjmp	80003aa8 <xTaskGenericCreate+0xec>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80003a88:	4b 88       	lddpc	r8,80003b68 <xTaskGenericCreate+0x1ac>
80003a8a:	70 08       	ld.w	r8,r8[0x0]
80003a8c:	58 08       	cp.w	r8,0
80003a8e:	c0 d1       	brne	80003aa8 <xTaskGenericCreate+0xec>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80003a90:	4b 48       	lddpc	r8,80003b60 <xTaskGenericCreate+0x1a4>
80003a92:	70 08       	ld.w	r8,r8[0x0]
80003a94:	70 b9       	ld.w	r9,r8[0x2c]
80003a96:	ee f8 ff e0 	ld.w	r8,r7[-32]
80003a9a:	10 39       	cp.w	r9,r8
80003a9c:	e0 8b 00 06 	brhi	80003aa8 <xTaskGenericCreate+0xec>
					{
						pxCurrentTCB = pxNewTCB;
80003aa0:	4b 08       	lddpc	r8,80003b60 <xTaskGenericCreate+0x1a4>
80003aa2:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003aa6:	91 09       	st.w	r8[0x0],r9
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80003aa8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003aac:	70 b9       	ld.w	r9,r8[0x2c]
80003aae:	4b 08       	lddpc	r8,80003b6c <xTaskGenericCreate+0x1b0>
80003ab0:	70 08       	ld.w	r8,r8[0x0]
80003ab2:	10 39       	cp.w	r9,r8
80003ab4:	e0 88 00 07 	brls	80003ac2 <xTaskGenericCreate+0x106>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80003ab8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003abc:	70 b9       	ld.w	r9,r8[0x2c]
80003abe:	4a c8       	lddpc	r8,80003b6c <xTaskGenericCreate+0x1b0>
80003ac0:	91 09       	st.w	r8[0x0],r9
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80003ac2:	4a c8       	lddpc	r8,80003b70 <xTaskGenericCreate+0x1b4>
80003ac4:	70 08       	ld.w	r8,r8[0x0]
80003ac6:	f0 c9 ff ff 	sub	r9,r8,-1
80003aca:	4a a8       	lddpc	r8,80003b70 <xTaskGenericCreate+0x1b4>
80003acc:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80003ace:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003ad2:	70 b9       	ld.w	r9,r8[0x2c]
80003ad4:	4a 88       	lddpc	r8,80003b74 <xTaskGenericCreate+0x1b8>
80003ad6:	70 08       	ld.w	r8,r8[0x0]
80003ad8:	10 39       	cp.w	r9,r8
80003ada:	e0 88 00 07 	brls	80003ae8 <xTaskGenericCreate+0x12c>
80003ade:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003ae2:	70 b9       	ld.w	r9,r8[0x2c]
80003ae4:	4a 48       	lddpc	r8,80003b74 <xTaskGenericCreate+0x1b8>
80003ae6:	91 09       	st.w	r8[0x0],r9
80003ae8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003aec:	f0 ca ff fc 	sub	r10,r8,-4
80003af0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003af4:	70 b9       	ld.w	r9,r8[0x2c]
80003af6:	12 98       	mov	r8,r9
80003af8:	a3 68       	lsl	r8,0x2
80003afa:	12 08       	add	r8,r9
80003afc:	a3 68       	lsl	r8,0x2
80003afe:	10 99       	mov	r9,r8
80003b00:	49 e8       	lddpc	r8,80003b78 <xTaskGenericCreate+0x1bc>
80003b02:	f2 08 00 08 	add	r8,r9,r8
80003b06:	14 9b       	mov	r11,r10
80003b08:	10 9c       	mov	r12,r8
80003b0a:	f0 1f 00 1d 	mcall	80003b7c <xTaskGenericCreate+0x1c0>

			xReturn = pdPASS;
80003b0e:	30 18       	mov	r8,1
80003b10:	ef 48 ff f4 	st.w	r7[-12],r8
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80003b14:	f0 1f 00 1b 	mcall	80003b80 <xTaskGenericCreate+0x1c4>
80003b18:	c0 48       	rjmp	80003b20 <xTaskGenericCreate+0x164>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
80003b1a:	3f f8       	mov	r8,-1
80003b1c:	ef 48 ff f4 	st.w	r7[-12],r8
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
80003b20:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003b24:	58 18       	cp.w	r8,1
80003b26:	c0 d1       	brne	80003b40 <xTaskGenericCreate+0x184>
	{
		if( xSchedulerRunning != pdFALSE )
80003b28:	49 08       	lddpc	r8,80003b68 <xTaskGenericCreate+0x1ac>
80003b2a:	70 08       	ld.w	r8,r8[0x0]
80003b2c:	58 08       	cp.w	r8,0
80003b2e:	c0 90       	breq	80003b40 <xTaskGenericCreate+0x184>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80003b30:	48 c8       	lddpc	r8,80003b60 <xTaskGenericCreate+0x1a4>
80003b32:	70 08       	ld.w	r8,r8[0x0]
80003b34:	70 b9       	ld.w	r9,r8[0x2c]
80003b36:	ee f8 ff e0 	ld.w	r8,r7[-32]
80003b3a:	10 39       	cp.w	r9,r8
80003b3c:	c0 22       	brcc	80003b40 <xTaskGenericCreate+0x184>
			{
				portYIELD_WITHIN_API();
80003b3e:	d7 33       	scall
			}
		}
	}

	return xReturn;
80003b40:	ee f8 ff f4 	ld.w	r8,r7[-12]
}
80003b44:	10 9c       	mov	r12,r8
80003b46:	2f 8d       	sub	sp,-32
80003b48:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003b4c:	80 00       	ld.sh	r0,r0[0x0]
80003b4e:	44 2c       	lddsp	r12,sp[0x108]
80003b50:	80 00       	ld.sh	r0,r0[0x0]
80003b52:	41 e4       	lddsp	r4,sp[0x78]
80003b54:	80 00       	ld.sh	r0,r0[0x0]
80003b56:	30 40       	mov	r0,4
80003b58:	80 00       	ld.sh	r0,r0[0x0]
80003b5a:	2f f8       	sub	r8,-1
80003b5c:	00 00       	add	r0,r0
80003b5e:	07 30       	ld.ub	r0,r3++
80003b60:	00 00       	add	r0,r0
80003b62:	06 1c       	sub	r12,r3
80003b64:	80 00       	ld.sh	r0,r0[0x0]
80003b66:	42 80       	lddsp	r0,sp[0xa0]
80003b68:	00 00       	add	r0,r0
80003b6a:	07 40       	ld.w	r0,--r3
80003b6c:	00 00       	add	r0,r0
80003b6e:	07 38       	ld.ub	r8,r3++
80003b70:	00 00       	add	r0,r0
80003b72:	07 54       	ld.sh	r4,--r3
80003b74:	00 00       	add	r0,r0
80003b76:	07 3c       	ld.ub	r12,r3++
80003b78:	00 00       	add	r0,r0
80003b7a:	06 20       	rsub	r0,r3
80003b7c:	80 00       	ld.sh	r0,r0[0x0]
80003b7e:	2c ce       	sub	lr,-52
80003b80:	80 00       	ld.sh	r0,r0[0x0]
80003b82:	30 14       	mov	r4,1

80003b84 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80003b84:	eb cd 40 80 	pushm	r7,lr
80003b88:	1a 97       	mov	r7,sp
80003b8a:	20 1d       	sub	sp,4
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80003b8c:	49 1b       	lddpc	r11,80003bd0 <vTaskStartScheduler+0x4c>
80003b8e:	30 08       	mov	r8,0
80003b90:	1a d8       	st.w	--sp,r8
80003b92:	30 08       	mov	r8,0
80003b94:	1a d8       	st.w	--sp,r8
80003b96:	30 08       	mov	r8,0
80003b98:	1a d8       	st.w	--sp,r8
80003b9a:	30 08       	mov	r8,0
80003b9c:	30 09       	mov	r9,0
80003b9e:	e0 6a 01 00 	mov	r10,256
80003ba2:	48 dc       	lddpc	r12,80003bd4 <vTaskStartScheduler+0x50>
80003ba4:	f0 1f 00 0d 	mcall	80003bd8 <vTaskStartScheduler+0x54>
80003ba8:	2f dd       	sub	sp,-12
80003baa:	18 98       	mov	r8,r12
80003bac:	ef 48 ff fc 	st.w	r7[-4],r8
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80003bb0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003bb4:	58 18       	cp.w	r8,1
80003bb6:	c0 a1       	brne	80003bca <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80003bb8:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80003bba:	48 98       	lddpc	r8,80003bdc <vTaskStartScheduler+0x58>
80003bbc:	30 19       	mov	r9,1
80003bbe:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80003bc0:	48 88       	lddpc	r8,80003be0 <vTaskStartScheduler+0x5c>
80003bc2:	30 09       	mov	r9,0
80003bc4:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80003bc6:	f0 1f 00 08 	mcall	80003be4 <vTaskStartScheduler+0x60>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
80003bca:	2f fd       	sub	sp,-4
80003bcc:	e3 cd 80 80 	ldm	sp++,r7,pc
80003bd0:	80 00       	ld.sh	r0,r0[0x0]
80003bd2:	39 b4       	mov	r4,-101
80003bd4:	80 00       	ld.sh	r0,r0[0x0]
80003bd6:	41 b8       	lddsp	r8,sp[0x6c]
80003bd8:	80 00       	ld.sh	r0,r0[0x0]
80003bda:	39 bc       	mov	r12,-101
80003bdc:	00 00       	add	r0,r0
80003bde:	07 40       	ld.w	r0,--r3
80003be0:	00 00       	add	r0,r0
80003be2:	07 34       	ld.ub	r4,r3++
80003be4:	80 00       	ld.sh	r0,r0[0x0]
80003be6:	31 e8       	mov	r8,30

80003be8 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
80003be8:	eb cd 40 80 	pushm	r7,lr
80003bec:	1a 97       	mov	r7,sp
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80003bee:	48 58       	lddpc	r8,80003c00 <vTaskSuspendAll+0x18>
80003bf0:	70 08       	ld.w	r8,r8[0x0]
80003bf2:	f0 c9 ff ff 	sub	r9,r8,-1
80003bf6:	48 38       	lddpc	r8,80003c00 <vTaskSuspendAll+0x18>
80003bf8:	91 09       	st.w	r8[0x0],r9
}
80003bfa:	e3 cd 80 80 	ldm	sp++,r7,pc
80003bfe:	00 00       	add	r0,r0
80003c00:	00 00       	add	r0,r0
80003c02:	07 44       	ld.w	r4,--r3

80003c04 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80003c04:	eb cd 40 c0 	pushm	r6-r7,lr
80003c08:	1a 97       	mov	r7,sp
80003c0a:	20 2d       	sub	sp,8
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
80003c0c:	30 08       	mov	r8,0
80003c0e:	ef 48 ff f8 	st.w	r7[-8],r8
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80003c12:	f0 1f 00 3a 	mcall	80003cf8 <xTaskResumeAll+0xf4>
	{
		--uxSchedulerSuspended;
80003c16:	4b a8       	lddpc	r8,80003cfc <xTaskResumeAll+0xf8>
80003c18:	70 08       	ld.w	r8,r8[0x0]
80003c1a:	f0 c9 00 01 	sub	r9,r8,1
80003c1e:	4b 88       	lddpc	r8,80003cfc <xTaskResumeAll+0xf8>
80003c20:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80003c22:	4b 78       	lddpc	r8,80003cfc <xTaskResumeAll+0xf8>
80003c24:	70 08       	ld.w	r8,r8[0x0]
80003c26:	58 08       	cp.w	r8,0
80003c28:	c5 f1       	brne	80003ce6 <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80003c2a:	4b 68       	lddpc	r8,80003d00 <xTaskResumeAll+0xfc>
80003c2c:	70 08       	ld.w	r8,r8[0x0]
80003c2e:	58 08       	cp.w	r8,0
80003c30:	c5 b0       	breq	80003ce6 <xTaskResumeAll+0xe2>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
80003c32:	30 08       	mov	r8,0
80003c34:	ef 48 ff fc 	st.w	r7[-4],r8

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80003c38:	c3 08       	rjmp	80003c98 <xTaskResumeAll+0x94>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80003c3a:	4b 38       	lddpc	r8,80003d04 <xTaskResumeAll+0x100>
80003c3c:	70 38       	ld.w	r8,r8[0xc]
80003c3e:	70 38       	ld.w	r8,r8[0xc]
80003c40:	10 96       	mov	r6,r8
					vListRemove( &( pxTCB->xEventListItem ) );
80003c42:	ec c8 ff e8 	sub	r8,r6,-24
80003c46:	10 9c       	mov	r12,r8
80003c48:	f0 1f 00 30 	mcall	80003d08 <xTaskResumeAll+0x104>
					vListRemove( &( pxTCB->xGenericListItem ) );
80003c4c:	ec c8 ff fc 	sub	r8,r6,-4
80003c50:	10 9c       	mov	r12,r8
80003c52:	f0 1f 00 2e 	mcall	80003d08 <xTaskResumeAll+0x104>
					prvAddTaskToReadyQueue( pxTCB );
80003c56:	6c b9       	ld.w	r9,r6[0x2c]
80003c58:	4a d8       	lddpc	r8,80003d0c <xTaskResumeAll+0x108>
80003c5a:	70 08       	ld.w	r8,r8[0x0]
80003c5c:	10 39       	cp.w	r9,r8
80003c5e:	e0 88 00 05 	brls	80003c68 <xTaskResumeAll+0x64>
80003c62:	6c b9       	ld.w	r9,r6[0x2c]
80003c64:	4a a8       	lddpc	r8,80003d0c <xTaskResumeAll+0x108>
80003c66:	91 09       	st.w	r8[0x0],r9
80003c68:	ec ca ff fc 	sub	r10,r6,-4
80003c6c:	6c b9       	ld.w	r9,r6[0x2c]
80003c6e:	12 98       	mov	r8,r9
80003c70:	a3 68       	lsl	r8,0x2
80003c72:	12 08       	add	r8,r9
80003c74:	a3 68       	lsl	r8,0x2
80003c76:	10 99       	mov	r9,r8
80003c78:	4a 68       	lddpc	r8,80003d10 <xTaskResumeAll+0x10c>
80003c7a:	f2 08 00 08 	add	r8,r9,r8
80003c7e:	14 9b       	mov	r11,r10
80003c80:	10 9c       	mov	r12,r8
80003c82:	f0 1f 00 25 	mcall	80003d14 <xTaskResumeAll+0x110>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80003c86:	6c b9       	ld.w	r9,r6[0x2c]
80003c88:	4a 48       	lddpc	r8,80003d18 <xTaskResumeAll+0x114>
80003c8a:	70 08       	ld.w	r8,r8[0x0]
80003c8c:	70 b8       	ld.w	r8,r8[0x2c]
80003c8e:	10 39       	cp.w	r9,r8
80003c90:	c0 43       	brcs	80003c98 <xTaskResumeAll+0x94>
					{
						xYieldRequired = pdTRUE;
80003c92:	30 18       	mov	r8,1
80003c94:	ef 48 ff fc 	st.w	r7[-4],r8
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80003c98:	49 b8       	lddpc	r8,80003d04 <xTaskResumeAll+0x100>
80003c9a:	70 08       	ld.w	r8,r8[0x0]
80003c9c:	58 08       	cp.w	r8,0
80003c9e:	cc e1       	brne	80003c3a <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80003ca0:	49 f8       	lddpc	r8,80003d1c <xTaskResumeAll+0x118>
80003ca2:	70 08       	ld.w	r8,r8[0x0]
80003ca4:	58 08       	cp.w	r8,0
80003ca6:	c1 10       	breq	80003cc8 <xTaskResumeAll+0xc4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80003ca8:	c0 98       	rjmp	80003cba <xTaskResumeAll+0xb6>
					{
						vTaskIncrementTick();
80003caa:	f0 1f 00 1e 	mcall	80003d20 <xTaskResumeAll+0x11c>
						--uxMissedTicks;
80003cae:	49 c8       	lddpc	r8,80003d1c <xTaskResumeAll+0x118>
80003cb0:	70 08       	ld.w	r8,r8[0x0]
80003cb2:	f0 c9 00 01 	sub	r9,r8,1
80003cb6:	49 a8       	lddpc	r8,80003d1c <xTaskResumeAll+0x118>
80003cb8:	91 09       	st.w	r8[0x0],r9
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80003cba:	49 98       	lddpc	r8,80003d1c <xTaskResumeAll+0x118>
80003cbc:	70 08       	ld.w	r8,r8[0x0]
80003cbe:	58 08       	cp.w	r8,0
80003cc0:	cf 51       	brne	80003caa <xTaskResumeAll+0xa6>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
80003cc2:	30 18       	mov	r8,1
80003cc4:	ef 48 ff fc 	st.w	r7[-4],r8
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80003cc8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ccc:	58 18       	cp.w	r8,1
80003cce:	c0 50       	breq	80003cd8 <xTaskResumeAll+0xd4>
80003cd0:	49 58       	lddpc	r8,80003d24 <xTaskResumeAll+0x120>
80003cd2:	70 08       	ld.w	r8,r8[0x0]
80003cd4:	58 18       	cp.w	r8,1
80003cd6:	c0 81       	brne	80003ce6 <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
80003cd8:	30 18       	mov	r8,1
80003cda:	ef 48 ff f8 	st.w	r7[-8],r8
					xMissedYield = pdFALSE;
80003cde:	49 28       	lddpc	r8,80003d24 <xTaskResumeAll+0x120>
80003ce0:	30 09       	mov	r9,0
80003ce2:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80003ce4:	d7 33       	scall
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80003ce6:	f0 1f 00 11 	mcall	80003d28 <xTaskResumeAll+0x124>

	return xAlreadyYielded;
80003cea:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80003cee:	10 9c       	mov	r12,r8
80003cf0:	2f ed       	sub	sp,-8
80003cf2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003cf6:	00 00       	add	r0,r0
80003cf8:	80 00       	ld.sh	r0,r0[0x0]
80003cfa:	2f f8       	sub	r8,-1
80003cfc:	00 00       	add	r0,r0
80003cfe:	07 44       	ld.w	r4,--r3
80003d00:	00 00       	add	r0,r0
80003d02:	07 30       	ld.ub	r0,r3++
80003d04:	00 00       	add	r0,r0
80003d06:	06 f0       	st.b	--r3,r0
80003d08:	80 00       	ld.sh	r0,r0[0x0]
80003d0a:	2d e2       	sub	r2,-34
80003d0c:	00 00       	add	r0,r0
80003d0e:	07 3c       	ld.ub	r12,r3++
80003d10:	00 00       	add	r0,r0
80003d12:	06 20       	rsub	r0,r3
80003d14:	80 00       	ld.sh	r0,r0[0x0]
80003d16:	2c ce       	sub	lr,-52
80003d18:	00 00       	add	r0,r0
80003d1a:	06 1c       	sub	r12,r3
80003d1c:	00 00       	add	r0,r0
80003d1e:	07 48       	ld.w	r8,--r3
80003d20:	80 00       	ld.sh	r0,r0[0x0]
80003d22:	3d 5c       	mov	r12,-43
80003d24:	00 00       	add	r0,r0
80003d26:	07 4c       	ld.w	r12,--r3
80003d28:	80 00       	ld.sh	r0,r0[0x0]
80003d2a:	30 14       	mov	r4,1

80003d2c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80003d2c:	eb cd 40 80 	pushm	r7,lr
80003d30:	1a 97       	mov	r7,sp
80003d32:	20 1d       	sub	sp,4
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80003d34:	f0 1f 00 07 	mcall	80003d50 <xTaskGetTickCount+0x24>
	{
		xTicks = xTickCount;
80003d38:	48 78       	lddpc	r8,80003d54 <xTaskGetTickCount+0x28>
80003d3a:	70 08       	ld.w	r8,r8[0x0]
80003d3c:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	taskEXIT_CRITICAL();
80003d40:	f0 1f 00 06 	mcall	80003d58 <xTaskGetTickCount+0x2c>

	return xTicks;
80003d44:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80003d48:	10 9c       	mov	r12,r8
80003d4a:	2f fd       	sub	sp,-4
80003d4c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d50:	80 00       	ld.sh	r0,r0[0x0]
80003d52:	2f f8       	sub	r8,-1
80003d54:	00 00       	add	r0,r0
80003d56:	07 34       	ld.ub	r4,r3++
80003d58:	80 00       	ld.sh	r0,r0[0x0]
80003d5a:	30 14       	mov	r4,1

80003d5c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80003d5c:	eb cd 40 80 	pushm	r7,lr
80003d60:	1a 97       	mov	r7,sp
80003d62:	20 3d       	sub	sp,12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80003d64:	4c b8       	lddpc	r8,80003e90 <vTaskIncrementTick+0x134>
80003d66:	70 08       	ld.w	r8,r8[0x0]
80003d68:	58 08       	cp.w	r8,0
80003d6a:	e0 81 00 89 	brne	80003e7c <vTaskIncrementTick+0x120>
	{
		++xTickCount;
80003d6e:	4c a8       	lddpc	r8,80003e94 <vTaskIncrementTick+0x138>
80003d70:	70 08       	ld.w	r8,r8[0x0]
80003d72:	f0 c9 ff ff 	sub	r9,r8,-1
80003d76:	4c 88       	lddpc	r8,80003e94 <vTaskIncrementTick+0x138>
80003d78:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80003d7a:	4c 78       	lddpc	r8,80003e94 <vTaskIncrementTick+0x138>
80003d7c:	70 08       	ld.w	r8,r8[0x0]
80003d7e:	58 08       	cp.w	r8,0
80003d80:	c2 71       	brne	80003dce <vTaskIncrementTick+0x72>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80003d82:	4c 68       	lddpc	r8,80003e98 <vTaskIncrementTick+0x13c>
80003d84:	70 08       	ld.w	r8,r8[0x0]
80003d86:	ef 48 ff f8 	st.w	r7[-8],r8
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80003d8a:	4c 58       	lddpc	r8,80003e9c <vTaskIncrementTick+0x140>
80003d8c:	70 09       	ld.w	r9,r8[0x0]
80003d8e:	4c 38       	lddpc	r8,80003e98 <vTaskIncrementTick+0x13c>
80003d90:	91 09       	st.w	r8[0x0],r9
			pxOverflowDelayedTaskList = pxTemp;
80003d92:	4c 38       	lddpc	r8,80003e9c <vTaskIncrementTick+0x140>
80003d94:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003d98:	91 09       	st.w	r8[0x0],r9
			xNumOfOverflows++;
80003d9a:	4c 28       	lddpc	r8,80003ea0 <vTaskIncrementTick+0x144>
80003d9c:	70 08       	ld.w	r8,r8[0x0]
80003d9e:	f0 c9 ff ff 	sub	r9,r8,-1
80003da2:	4c 08       	lddpc	r8,80003ea0 <vTaskIncrementTick+0x144>
80003da4:	91 09       	st.w	r8[0x0],r9

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80003da6:	4b d8       	lddpc	r8,80003e98 <vTaskIncrementTick+0x13c>
80003da8:	70 08       	ld.w	r8,r8[0x0]
80003daa:	70 08       	ld.w	r8,r8[0x0]
80003dac:	58 08       	cp.w	r8,0
80003dae:	c0 51       	brne	80003db8 <vTaskIncrementTick+0x5c>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80003db0:	4b d8       	lddpc	r8,80003ea4 <vTaskIncrementTick+0x148>
80003db2:	3f f9       	mov	r9,-1
80003db4:	91 09       	st.w	r8[0x0],r9
80003db6:	c0 c8       	rjmp	80003dce <vTaskIncrementTick+0x72>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80003db8:	4b 88       	lddpc	r8,80003e98 <vTaskIncrementTick+0x13c>
80003dba:	70 08       	ld.w	r8,r8[0x0]
80003dbc:	70 38       	ld.w	r8,r8[0xc]
80003dbe:	70 38       	ld.w	r8,r8[0xc]
80003dc0:	ef 48 ff f4 	st.w	r7[-12],r8
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80003dc4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003dc8:	70 19       	ld.w	r9,r8[0x4]
80003dca:	4b 78       	lddpc	r8,80003ea4 <vTaskIncrementTick+0x148>
80003dcc:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80003dce:	4b 28       	lddpc	r8,80003e94 <vTaskIncrementTick+0x138>
80003dd0:	70 09       	ld.w	r9,r8[0x0]
80003dd2:	4b 58       	lddpc	r8,80003ea4 <vTaskIncrementTick+0x148>
80003dd4:	70 08       	ld.w	r8,r8[0x0]
80003dd6:	10 39       	cp.w	r9,r8
80003dd8:	c5 83       	brcs	80003e88 <vTaskIncrementTick+0x12c>
80003dda:	4b 08       	lddpc	r8,80003e98 <vTaskIncrementTick+0x13c>
80003ddc:	70 08       	ld.w	r8,r8[0x0]
80003dde:	70 08       	ld.w	r8,r8[0x0]
80003de0:	58 08       	cp.w	r8,0
80003de2:	c0 51       	brne	80003dec <vTaskIncrementTick+0x90>
80003de4:	4b 08       	lddpc	r8,80003ea4 <vTaskIncrementTick+0x148>
80003de6:	3f f9       	mov	r9,-1
80003de8:	91 09       	st.w	r8[0x0],r9
80003dea:	c4 f8       	rjmp	80003e88 <vTaskIncrementTick+0x12c>
80003dec:	4a b8       	lddpc	r8,80003e98 <vTaskIncrementTick+0x13c>
80003dee:	70 08       	ld.w	r8,r8[0x0]
80003df0:	70 38       	ld.w	r8,r8[0xc]
80003df2:	70 38       	ld.w	r8,r8[0xc]
80003df4:	ef 48 ff f4 	st.w	r7[-12],r8
80003df8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003dfc:	70 18       	ld.w	r8,r8[0x4]
80003dfe:	ef 48 ff fc 	st.w	r7[-4],r8
80003e02:	4a 58       	lddpc	r8,80003e94 <vTaskIncrementTick+0x138>
80003e04:	70 09       	ld.w	r9,r8[0x0]
80003e06:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e0a:	10 39       	cp.w	r9,r8
80003e0c:	c0 62       	brcc	80003e18 <vTaskIncrementTick+0xbc>
80003e0e:	4a 68       	lddpc	r8,80003ea4 <vTaskIncrementTick+0x148>
80003e10:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003e14:	91 09       	st.w	r8[0x0],r9
80003e16:	c3 98       	rjmp	80003e88 <vTaskIncrementTick+0x12c>
80003e18:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003e1c:	2f c8       	sub	r8,-4
80003e1e:	10 9c       	mov	r12,r8
80003e20:	f0 1f 00 22 	mcall	80003ea8 <vTaskIncrementTick+0x14c>
80003e24:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003e28:	70 a8       	ld.w	r8,r8[0x28]
80003e2a:	58 08       	cp.w	r8,0
80003e2c:	c0 70       	breq	80003e3a <vTaskIncrementTick+0xde>
80003e2e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003e32:	2e 88       	sub	r8,-24
80003e34:	10 9c       	mov	r12,r8
80003e36:	f0 1f 00 1d 	mcall	80003ea8 <vTaskIncrementTick+0x14c>
80003e3a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003e3e:	70 b9       	ld.w	r9,r8[0x2c]
80003e40:	49 b8       	lddpc	r8,80003eac <vTaskIncrementTick+0x150>
80003e42:	70 08       	ld.w	r8,r8[0x0]
80003e44:	10 39       	cp.w	r9,r8
80003e46:	e0 88 00 07 	brls	80003e54 <vTaskIncrementTick+0xf8>
80003e4a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003e4e:	70 b9       	ld.w	r9,r8[0x2c]
80003e50:	49 78       	lddpc	r8,80003eac <vTaskIncrementTick+0x150>
80003e52:	91 09       	st.w	r8[0x0],r9
80003e54:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003e58:	f0 ca ff fc 	sub	r10,r8,-4
80003e5c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003e60:	70 b9       	ld.w	r9,r8[0x2c]
80003e62:	12 98       	mov	r8,r9
80003e64:	a3 68       	lsl	r8,0x2
80003e66:	12 08       	add	r8,r9
80003e68:	a3 68       	lsl	r8,0x2
80003e6a:	10 99       	mov	r9,r8
80003e6c:	49 18       	lddpc	r8,80003eb0 <vTaskIncrementTick+0x154>
80003e6e:	f2 08 00 08 	add	r8,r9,r8
80003e72:	14 9b       	mov	r11,r10
80003e74:	10 9c       	mov	r12,r8
80003e76:	f0 1f 00 10 	mcall	80003eb4 <vTaskIncrementTick+0x158>
80003e7a:	cb 0b       	rjmp	80003dda <vTaskIncrementTick+0x7e>
	}
	else
	{
		++uxMissedTicks;
80003e7c:	48 f8       	lddpc	r8,80003eb8 <vTaskIncrementTick+0x15c>
80003e7e:	70 08       	ld.w	r8,r8[0x0]
80003e80:	f0 c9 ff ff 	sub	r9,r8,-1
80003e84:	48 d8       	lddpc	r8,80003eb8 <vTaskIncrementTick+0x15c>
80003e86:	91 09       	st.w	r8[0x0],r9
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
80003e88:	2f dd       	sub	sp,-12
80003e8a:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e8e:	00 00       	add	r0,r0
80003e90:	00 00       	add	r0,r0
80003e92:	07 44       	ld.w	r4,--r3
80003e94:	00 00       	add	r0,r0
80003e96:	07 34       	ld.ub	r4,r3++
80003e98:	00 00       	add	r0,r0
80003e9a:	06 e8       	st.h	--r3,r8
80003e9c:	00 00       	add	r0,r0
80003e9e:	06 ec       	st.h	--r3,r12
80003ea0:	00 00       	add	r0,r0
80003ea2:	07 50       	ld.sh	r0,--r3
80003ea4:	00 00       	add	r0,r0
80003ea6:	00 20       	rsub	r0,r0
80003ea8:	80 00       	ld.sh	r0,r0[0x0]
80003eaa:	2d e2       	sub	r2,-34
80003eac:	00 00       	add	r0,r0
80003eae:	07 3c       	ld.ub	r12,r3++
80003eb0:	00 00       	add	r0,r0
80003eb2:	06 20       	rsub	r0,r3
80003eb4:	80 00       	ld.sh	r0,r0[0x0]
80003eb6:	2c ce       	sub	lr,-52
80003eb8:	00 00       	add	r0,r0
80003eba:	07 48       	ld.w	r8,--r3

80003ebc <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
80003ebc:	eb cd 40 80 	pushm	r7,lr
80003ec0:	1a 97       	mov	r7,sp
80003ec2:	20 1d       	sub	sp,4
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80003ec4:	4a 58       	lddpc	r8,80003f58 <vTaskSwitchContext+0x9c>
80003ec6:	70 08       	ld.w	r8,r8[0x0]
80003ec8:	58 08       	cp.w	r8,0
80003eca:	c0 c0       	breq	80003ee2 <vTaskSwitchContext+0x26>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80003ecc:	4a 48       	lddpc	r8,80003f5c <vTaskSwitchContext+0xa0>
80003ece:	30 19       	mov	r9,1
80003ed0:	91 09       	st.w	r8[0x0],r9
80003ed2:	c3 f8       	rjmp	80003f50 <vTaskSwitchContext+0x94>

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80003ed4:	4a 38       	lddpc	r8,80003f60 <vTaskSwitchContext+0xa4>
80003ed6:	70 08       	ld.w	r8,r8[0x0]
80003ed8:	f0 c9 00 01 	sub	r9,r8,1
80003edc:	4a 18       	lddpc	r8,80003f60 <vTaskSwitchContext+0xa4>
80003ede:	91 09       	st.w	r8[0x0],r9
80003ee0:	c0 28       	rjmp	80003ee4 <vTaskSwitchContext+0x28>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80003ee2:	d7 03       	nop
80003ee4:	49 f8       	lddpc	r8,80003f60 <vTaskSwitchContext+0xa4>
80003ee6:	70 09       	ld.w	r9,r8[0x0]
80003ee8:	12 98       	mov	r8,r9
80003eea:	a3 68       	lsl	r8,0x2
80003eec:	12 08       	add	r8,r9
80003eee:	a3 68       	lsl	r8,0x2
80003ef0:	10 99       	mov	r9,r8
80003ef2:	49 d8       	lddpc	r8,80003f64 <vTaskSwitchContext+0xa8>
80003ef4:	f2 08 00 08 	add	r8,r9,r8
80003ef8:	70 08       	ld.w	r8,r8[0x0]
80003efa:	58 08       	cp.w	r8,0
80003efc:	ce c0       	breq	80003ed4 <vTaskSwitchContext+0x18>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80003efe:	49 98       	lddpc	r8,80003f60 <vTaskSwitchContext+0xa4>
80003f00:	70 09       	ld.w	r9,r8[0x0]
80003f02:	12 98       	mov	r8,r9
80003f04:	a3 68       	lsl	r8,0x2
80003f06:	12 08       	add	r8,r9
80003f08:	a3 68       	lsl	r8,0x2
80003f0a:	10 99       	mov	r9,r8
80003f0c:	49 68       	lddpc	r8,80003f64 <vTaskSwitchContext+0xa8>
80003f0e:	f2 08 00 08 	add	r8,r9,r8
80003f12:	ef 48 ff fc 	st.w	r7[-4],r8
80003f16:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f1a:	70 18       	ld.w	r8,r8[0x4]
80003f1c:	70 19       	ld.w	r9,r8[0x4]
80003f1e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f22:	91 19       	st.w	r8[0x4],r9
80003f24:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f28:	70 19       	ld.w	r9,r8[0x4]
80003f2a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f2e:	2f 88       	sub	r8,-8
80003f30:	10 39       	cp.w	r9,r8
80003f32:	c0 81       	brne	80003f42 <vTaskSwitchContext+0x86>
80003f34:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f38:	70 18       	ld.w	r8,r8[0x4]
80003f3a:	70 19       	ld.w	r9,r8[0x4]
80003f3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f40:	91 19       	st.w	r8[0x4],r9
80003f42:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f46:	70 18       	ld.w	r8,r8[0x4]
80003f48:	70 38       	ld.w	r8,r8[0xc]
80003f4a:	10 99       	mov	r9,r8
80003f4c:	48 78       	lddpc	r8,80003f68 <vTaskSwitchContext+0xac>
80003f4e:	91 09       	st.w	r8[0x0],r9

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
80003f50:	2f fd       	sub	sp,-4
80003f52:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f56:	00 00       	add	r0,r0
80003f58:	00 00       	add	r0,r0
80003f5a:	07 44       	ld.w	r4,--r3
80003f5c:	00 00       	add	r0,r0
80003f5e:	07 4c       	ld.w	r12,--r3
80003f60:	00 00       	add	r0,r0
80003f62:	07 3c       	ld.ub	r12,r3++
80003f64:	00 00       	add	r0,r0
80003f66:	06 20       	rsub	r0,r3
80003f68:	00 00       	add	r0,r0
80003f6a:	06 1c       	sub	r12,r3

80003f6c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80003f6c:	eb cd 40 80 	pushm	r7,lr
80003f70:	1a 97       	mov	r7,sp
80003f72:	20 3d       	sub	sp,12
80003f74:	ef 4c ff f8 	st.w	r7[-8],r12
80003f78:	ef 4b ff f4 	st.w	r7[-12],r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80003f7c:	49 58       	lddpc	r8,80003fd0 <vTaskPlaceOnEventList+0x64>
80003f7e:	70 08       	ld.w	r8,r8[0x0]
80003f80:	2e 88       	sub	r8,-24
80003f82:	10 9b       	mov	r11,r8
80003f84:	ee fc ff f8 	ld.w	r12,r7[-8]
80003f88:	f0 1f 00 13 	mcall	80003fd4 <vTaskPlaceOnEventList+0x68>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80003f8c:	49 18       	lddpc	r8,80003fd0 <vTaskPlaceOnEventList+0x64>
80003f8e:	70 08       	ld.w	r8,r8[0x0]
80003f90:	2f c8       	sub	r8,-4
80003f92:	10 9c       	mov	r12,r8
80003f94:	f0 1f 00 11 	mcall	80003fd8 <vTaskPlaceOnEventList+0x6c>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80003f98:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003f9c:	5b f8       	cp.w	r8,-1
80003f9e:	c0 91       	brne	80003fb0 <vTaskPlaceOnEventList+0x44>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80003fa0:	48 c8       	lddpc	r8,80003fd0 <vTaskPlaceOnEventList+0x64>
80003fa2:	70 08       	ld.w	r8,r8[0x0]
80003fa4:	2f c8       	sub	r8,-4
80003fa6:	10 9b       	mov	r11,r8
80003fa8:	48 dc       	lddpc	r12,80003fdc <vTaskPlaceOnEventList+0x70>
80003faa:	f0 1f 00 0e 	mcall	80003fe0 <vTaskPlaceOnEventList+0x74>
80003fae:	c0 d8       	rjmp	80003fc8 <vTaskPlaceOnEventList+0x5c>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80003fb0:	48 d8       	lddpc	r8,80003fe4 <vTaskPlaceOnEventList+0x78>
80003fb2:	70 09       	ld.w	r9,r8[0x0]
80003fb4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003fb8:	f2 08 00 08 	add	r8,r9,r8
80003fbc:	ef 48 ff fc 	st.w	r7[-4],r8
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80003fc0:	ee fc ff fc 	ld.w	r12,r7[-4]
80003fc4:	f0 1f 00 09 	mcall	80003fe8 <vTaskPlaceOnEventList+0x7c>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
80003fc8:	2f dd       	sub	sp,-12
80003fca:	e3 cd 80 80 	ldm	sp++,r7,pc
80003fce:	00 00       	add	r0,r0
80003fd0:	00 00       	add	r0,r0
80003fd2:	06 1c       	sub	r12,r3
80003fd4:	80 00       	ld.sh	r0,r0[0x0]
80003fd6:	2d 40       	sub	r0,-44
80003fd8:	80 00       	ld.sh	r0,r0[0x0]
80003fda:	2d e2       	sub	r2,-34
80003fdc:	00 00       	add	r0,r0
80003fde:	07 1c       	ld.sh	r12,r3++
80003fe0:	80 00       	ld.sh	r0,r0[0x0]
80003fe2:	2c ce       	sub	lr,-52
80003fe4:	00 00       	add	r0,r0
80003fe6:	07 34       	ld.ub	r4,r3++
80003fe8:	80 00       	ld.sh	r0,r0[0x0]
80003fea:	43 ac       	lddsp	r12,sp[0xe8]

80003fec <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80003fec:	eb cd 40 80 	pushm	r7,lr
80003ff0:	1a 97       	mov	r7,sp
80003ff2:	20 3d       	sub	sp,12
80003ff4:	ef 4c ff f4 	st.w	r7[-12],r12
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80003ff8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003ffc:	70 38       	ld.w	r8,r8[0xc]
80003ffe:	70 38       	ld.w	r8,r8[0xc]
80004000:	ef 48 ff f8 	st.w	r7[-8],r8
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80004004:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004008:	2e 88       	sub	r8,-24
8000400a:	10 9c       	mov	r12,r8
8000400c:	f0 1f 00 25 	mcall	800040a0 <xTaskRemoveFromEventList+0xb4>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80004010:	4a 58       	lddpc	r8,800040a4 <xTaskRemoveFromEventList+0xb8>
80004012:	70 08       	ld.w	r8,r8[0x0]
80004014:	58 08       	cp.w	r8,0
80004016:	c2 81       	brne	80004066 <xTaskRemoveFromEventList+0x7a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80004018:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000401c:	2f c8       	sub	r8,-4
8000401e:	10 9c       	mov	r12,r8
80004020:	f0 1f 00 20 	mcall	800040a0 <xTaskRemoveFromEventList+0xb4>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80004024:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004028:	70 b9       	ld.w	r9,r8[0x2c]
8000402a:	4a 08       	lddpc	r8,800040a8 <xTaskRemoveFromEventList+0xbc>
8000402c:	70 08       	ld.w	r8,r8[0x0]
8000402e:	10 39       	cp.w	r9,r8
80004030:	e0 88 00 07 	brls	8000403e <xTaskRemoveFromEventList+0x52>
80004034:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004038:	70 b9       	ld.w	r9,r8[0x2c]
8000403a:	49 c8       	lddpc	r8,800040a8 <xTaskRemoveFromEventList+0xbc>
8000403c:	91 09       	st.w	r8[0x0],r9
8000403e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004042:	f0 ca ff fc 	sub	r10,r8,-4
80004046:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000404a:	70 b9       	ld.w	r9,r8[0x2c]
8000404c:	12 98       	mov	r8,r9
8000404e:	a3 68       	lsl	r8,0x2
80004050:	12 08       	add	r8,r9
80004052:	a3 68       	lsl	r8,0x2
80004054:	10 99       	mov	r9,r8
80004056:	49 68       	lddpc	r8,800040ac <xTaskRemoveFromEventList+0xc0>
80004058:	f2 08 00 08 	add	r8,r9,r8
8000405c:	14 9b       	mov	r11,r10
8000405e:	10 9c       	mov	r12,r8
80004060:	f0 1f 00 14 	mcall	800040b0 <xTaskRemoveFromEventList+0xc4>
80004064:	c0 88       	rjmp	80004074 <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80004066:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000406a:	2e 88       	sub	r8,-24
8000406c:	10 9b       	mov	r11,r8
8000406e:	49 2c       	lddpc	r12,800040b4 <xTaskRemoveFromEventList+0xc8>
80004070:	f0 1f 00 10 	mcall	800040b0 <xTaskRemoveFromEventList+0xc4>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80004074:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004078:	70 b9       	ld.w	r9,r8[0x2c]
8000407a:	49 08       	lddpc	r8,800040b8 <xTaskRemoveFromEventList+0xcc>
8000407c:	70 08       	ld.w	r8,r8[0x0]
8000407e:	70 b8       	ld.w	r8,r8[0x2c]
80004080:	10 39       	cp.w	r9,r8
80004082:	c0 53       	brcs	8000408c <xTaskRemoveFromEventList+0xa0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
80004084:	30 18       	mov	r8,1
80004086:	ef 48 ff fc 	st.w	r7[-4],r8
8000408a:	c0 48       	rjmp	80004092 <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		xReturn = pdFALSE;
8000408c:	30 08       	mov	r8,0
8000408e:	ef 48 ff fc 	st.w	r7[-4],r8
	}

	return xReturn;
80004092:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80004096:	10 9c       	mov	r12,r8
80004098:	2f dd       	sub	sp,-12
8000409a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000409e:	00 00       	add	r0,r0
800040a0:	80 00       	ld.sh	r0,r0[0x0]
800040a2:	2d e2       	sub	r2,-34
800040a4:	00 00       	add	r0,r0
800040a6:	07 44       	ld.w	r4,--r3
800040a8:	00 00       	add	r0,r0
800040aa:	07 3c       	ld.ub	r12,r3++
800040ac:	00 00       	add	r0,r0
800040ae:	06 20       	rsub	r0,r3
800040b0:	80 00       	ld.sh	r0,r0[0x0]
800040b2:	2c ce       	sub	lr,-52
800040b4:	00 00       	add	r0,r0
800040b6:	06 f0       	st.b	--r3,r0
800040b8:	00 00       	add	r0,r0
800040ba:	06 1c       	sub	r12,r3

800040bc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
800040bc:	eb cd 40 80 	pushm	r7,lr
800040c0:	1a 97       	mov	r7,sp
800040c2:	20 1d       	sub	sp,4
800040c4:	ef 4c ff fc 	st.w	r7[-4],r12
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800040c8:	48 78       	lddpc	r8,800040e4 <vTaskSetTimeOutState+0x28>
800040ca:	70 09       	ld.w	r9,r8[0x0]
800040cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800040d0:	91 09       	st.w	r8[0x0],r9
	pxTimeOut->xTimeOnEntering = xTickCount;
800040d2:	48 68       	lddpc	r8,800040e8 <vTaskSetTimeOutState+0x2c>
800040d4:	70 09       	ld.w	r9,r8[0x0]
800040d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800040da:	91 19       	st.w	r8[0x4],r9
}
800040dc:	2f fd       	sub	sp,-4
800040de:	e3 cd 80 80 	ldm	sp++,r7,pc
800040e2:	00 00       	add	r0,r0
800040e4:	00 00       	add	r0,r0
800040e6:	07 50       	ld.sh	r0,--r3
800040e8:	00 00       	add	r0,r0
800040ea:	07 34       	ld.ub	r4,r3++

800040ec <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800040ec:	eb cd 40 80 	pushm	r7,lr
800040f0:	1a 97       	mov	r7,sp
800040f2:	20 3d       	sub	sp,12
800040f4:	ef 4c ff f8 	st.w	r7[-8],r12
800040f8:	ef 4b ff f4 	st.w	r7[-12],r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800040fc:	f0 1f 00 25 	mcall	80004190 <xTaskCheckForTimeOut+0xa4>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80004100:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004104:	70 08       	ld.w	r8,r8[0x0]
80004106:	5b f8       	cp.w	r8,-1
80004108:	c0 51       	brne	80004112 <xTaskCheckForTimeOut+0x26>
			{
				xReturn = pdFALSE;
8000410a:	30 08       	mov	r8,0
8000410c:	ef 48 ff fc 	st.w	r7[-4],r8
80004110:	c3 88       	rjmp	80004180 <xTaskCheckForTimeOut+0x94>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80004112:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004116:	70 09       	ld.w	r9,r8[0x0]
80004118:	49 f8       	lddpc	r8,80004194 <xTaskCheckForTimeOut+0xa8>
8000411a:	70 08       	ld.w	r8,r8[0x0]
8000411c:	10 39       	cp.w	r9,r8
8000411e:	c0 d0       	breq	80004138 <xTaskCheckForTimeOut+0x4c>
80004120:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004124:	70 19       	ld.w	r9,r8[0x4]
80004126:	49 d8       	lddpc	r8,80004198 <xTaskCheckForTimeOut+0xac>
80004128:	70 08       	ld.w	r8,r8[0x0]
8000412a:	10 39       	cp.w	r9,r8
8000412c:	e0 8b 00 06 	brhi	80004138 <xTaskCheckForTimeOut+0x4c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
80004130:	30 18       	mov	r8,1
80004132:	ef 48 ff fc 	st.w	r7[-4],r8
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80004136:	c2 58       	rjmp	80004180 <xTaskCheckForTimeOut+0x94>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80004138:	49 88       	lddpc	r8,80004198 <xTaskCheckForTimeOut+0xac>
8000413a:	70 09       	ld.w	r9,r8[0x0]
8000413c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004140:	70 18       	ld.w	r8,r8[0x4]
80004142:	10 19       	sub	r9,r8
80004144:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004148:	70 08       	ld.w	r8,r8[0x0]
8000414a:	10 39       	cp.w	r9,r8
8000414c:	c1 72       	brcc	8000417a <xTaskCheckForTimeOut+0x8e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000414e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004152:	70 09       	ld.w	r9,r8[0x0]
80004154:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004158:	70 1a       	ld.w	r10,r8[0x4]
8000415a:	49 08       	lddpc	r8,80004198 <xTaskCheckForTimeOut+0xac>
8000415c:	70 08       	ld.w	r8,r8[0x0]
8000415e:	f4 08 01 08 	sub	r8,r10,r8
80004162:	10 09       	add	r9,r8
80004164:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004168:	91 09       	st.w	r8[0x0],r9
			vTaskSetTimeOutState( pxTimeOut );
8000416a:	ee fc ff f8 	ld.w	r12,r7[-8]
8000416e:	f0 1f 00 0c 	mcall	8000419c <xTaskCheckForTimeOut+0xb0>
			xReturn = pdFALSE;
80004172:	30 08       	mov	r8,0
80004174:	ef 48 ff fc 	st.w	r7[-4],r8
80004178:	c0 48       	rjmp	80004180 <xTaskCheckForTimeOut+0x94>
		}
		else
		{
			xReturn = pdTRUE;
8000417a:	30 18       	mov	r8,1
8000417c:	ef 48 ff fc 	st.w	r7[-4],r8
		}
	}
	taskEXIT_CRITICAL();
80004180:	f0 1f 00 08 	mcall	800041a0 <xTaskCheckForTimeOut+0xb4>

	return xReturn;
80004184:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80004188:	10 9c       	mov	r12,r8
8000418a:	2f dd       	sub	sp,-12
8000418c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004190:	80 00       	ld.sh	r0,r0[0x0]
80004192:	2f f8       	sub	r8,-1
80004194:	00 00       	add	r0,r0
80004196:	07 50       	ld.sh	r0,--r3
80004198:	00 00       	add	r0,r0
8000419a:	07 34       	ld.ub	r4,r3++
8000419c:	80 00       	ld.sh	r0,r0[0x0]
8000419e:	40 bc       	lddsp	r12,sp[0x2c]
800041a0:	80 00       	ld.sh	r0,r0[0x0]
800041a2:	30 14       	mov	r4,1

800041a4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
800041a4:	eb cd 40 80 	pushm	r7,lr
800041a8:	1a 97       	mov	r7,sp
	xMissedYield = pdTRUE;
800041aa:	48 38       	lddpc	r8,800041b4 <vTaskMissedYield+0x10>
800041ac:	30 19       	mov	r9,1
800041ae:	91 09       	st.w	r8[0x0],r9
}
800041b0:	e3 cd 80 80 	ldm	sp++,r7,pc
800041b4:	00 00       	add	r0,r0
800041b6:	07 4c       	ld.w	r12,--r3

800041b8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800041b8:	eb cd 40 80 	pushm	r7,lr
800041bc:	1a 97       	mov	r7,sp
800041be:	20 1d       	sub	sp,4
800041c0:	ef 4c ff fc 	st.w	r7[-4],r12
800041c4:	c0 28       	rjmp	800041c8 <prvIdleTask+0x10>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
800041c6:	d7 03       	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
800041c8:	f0 1f 00 05 	mcall	800041dc <prvIdleTask+0x24>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800041cc:	48 58       	lddpc	r8,800041e0 <prvIdleTask+0x28>
800041ce:	70 08       	ld.w	r8,r8[0x0]
800041d0:	58 18       	cp.w	r8,1
800041d2:	fe 98 ff fa 	brls	800041c6 <prvIdleTask+0xe>
			{
				taskYIELD();
800041d6:	d7 33       	scall
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
800041d8:	cf 8b       	rjmp	800041c8 <prvIdleTask+0x10>
800041da:	00 00       	add	r0,r0
800041dc:	80 00       	ld.sh	r0,r0[0x0]
800041de:	43 14       	lddsp	r4,sp[0xc4]
800041e0:	00 00       	add	r0,r0
800041e2:	06 20       	rsub	r0,r3

800041e4 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
800041e4:	eb cd 40 80 	pushm	r7,lr
800041e8:	1a 97       	mov	r7,sp
800041ea:	20 5d       	sub	sp,20
800041ec:	ef 4c ff fc 	st.w	r7[-4],r12
800041f0:	ef 4b ff f8 	st.w	r7[-8],r11
800041f4:	ef 4a ff f4 	st.w	r7[-12],r10
800041f8:	ef 49 ff f0 	st.w	r7[-16],r9
800041fc:	ef 58 ff ec 	st.h	r7[-20],r8
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80004200:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004204:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004208:	2c c8       	sub	r8,-52
8000420a:	31 0a       	mov	r10,16
8000420c:	12 9b       	mov	r11,r9
8000420e:	10 9c       	mov	r12,r8
80004210:	f0 1f 00 1a 	mcall	80004278 <prvInitialiseTCBVariables+0x94>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80004214:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004218:	30 08       	mov	r8,0
8000421a:	f3 68 00 43 	st.b	r9[67],r8

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
8000421e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004222:	58 78       	cp.w	r8,7
80004224:	e0 88 00 05 	brls	8000422e <prvInitialiseTCBVariables+0x4a>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
80004228:	30 78       	mov	r8,7
8000422a:	ef 48 ff f4 	st.w	r7[-12],r8
	}

	pxTCB->uxPriority = uxPriority;
8000422e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004232:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004236:	91 b9       	st.w	r8[0x2c],r9
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80004238:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000423c:	2f c8       	sub	r8,-4
8000423e:	10 9c       	mov	r12,r8
80004240:	f0 1f 00 0f 	mcall	8000427c <prvInitialiseTCBVariables+0x98>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80004244:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004248:	2e 88       	sub	r8,-24
8000424a:	10 9c       	mov	r12,r8
8000424c:	f0 1f 00 0c 	mcall	8000427c <prvInitialiseTCBVariables+0x98>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80004250:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004254:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004258:	91 49       	st.w	r8[0x10],r9

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
8000425a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000425e:	f0 09 11 08 	rsub	r9,r8,8
80004262:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004266:	91 69       	st.w	r8[0x18],r9
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80004268:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000426c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004270:	91 99       	st.w	r8[0x24],r9
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
80004272:	2f bd       	sub	sp,-20
80004274:	e3 cd 80 80 	ldm	sp++,r7,pc
80004278:	80 00       	ld.sh	r0,r0[0x0]
8000427a:	4a e8       	lddpc	r8,80004330 <prvCheckTasksWaitingTermination+0x1c>
8000427c:	80 00       	ld.sh	r0,r0[0x0]
8000427e:	2c b4       	sub	r4,-53

80004280 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
80004280:	eb cd 40 80 	pushm	r7,lr
80004284:	1a 97       	mov	r7,sp
80004286:	20 1d       	sub	sp,4
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80004288:	30 08       	mov	r8,0
8000428a:	ef 48 ff fc 	st.w	r7[-4],r8
8000428e:	c1 38       	rjmp	800042b4 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80004290:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004294:	12 98       	mov	r8,r9
80004296:	a3 68       	lsl	r8,0x2
80004298:	12 08       	add	r8,r9
8000429a:	a3 68       	lsl	r8,0x2
8000429c:	10 99       	mov	r9,r8
8000429e:	49 58       	lddpc	r8,800042f0 <prvInitialiseTaskLists+0x70>
800042a0:	f2 08 00 08 	add	r8,r9,r8
800042a4:	10 9c       	mov	r12,r8
800042a6:	f0 1f 00 14 	mcall	800042f4 <prvInitialiseTaskLists+0x74>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800042aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042ae:	2f f8       	sub	r8,-1
800042b0:	ef 48 ff fc 	st.w	r7[-4],r8
800042b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042b8:	58 78       	cp.w	r8,7
800042ba:	fe 98 ff eb 	brls	80004290 <prvInitialiseTaskLists+0x10>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
800042be:	48 fc       	lddpc	r12,800042f8 <prvInitialiseTaskLists+0x78>
800042c0:	f0 1f 00 0d 	mcall	800042f4 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800042c4:	48 ec       	lddpc	r12,800042fc <prvInitialiseTaskLists+0x7c>
800042c6:	f0 1f 00 0c 	mcall	800042f4 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xPendingReadyList );
800042ca:	48 ec       	lddpc	r12,80004300 <prvInitialiseTaskLists+0x80>
800042cc:	f0 1f 00 0a 	mcall	800042f4 <prvInitialiseTaskLists+0x74>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800042d0:	48 dc       	lddpc	r12,80004304 <prvInitialiseTaskLists+0x84>
800042d2:	f0 1f 00 09 	mcall	800042f4 <prvInitialiseTaskLists+0x74>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800042d6:	48 dc       	lddpc	r12,80004308 <prvInitialiseTaskLists+0x88>
800042d8:	f0 1f 00 07 	mcall	800042f4 <prvInitialiseTaskLists+0x74>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800042dc:	48 c8       	lddpc	r8,8000430c <prvInitialiseTaskLists+0x8c>
800042de:	48 79       	lddpc	r9,800042f8 <prvInitialiseTaskLists+0x78>
800042e0:	91 09       	st.w	r8[0x0],r9
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800042e2:	48 c8       	lddpc	r8,80004310 <prvInitialiseTaskLists+0x90>
800042e4:	48 69       	lddpc	r9,800042fc <prvInitialiseTaskLists+0x7c>
800042e6:	91 09       	st.w	r8[0x0],r9
}
800042e8:	2f fd       	sub	sp,-4
800042ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800042ee:	00 00       	add	r0,r0
800042f0:	00 00       	add	r0,r0
800042f2:	06 20       	rsub	r0,r3
800042f4:	80 00       	ld.sh	r0,r0[0x0]
800042f6:	2c 68       	sub	r8,-58
800042f8:	00 00       	add	r0,r0
800042fa:	06 c0       	st.b	r3++,r0
800042fc:	00 00       	add	r0,r0
800042fe:	06 d4       	st.w	--r3,r4
80004300:	00 00       	add	r0,r0
80004302:	06 f0       	st.b	--r3,r0
80004304:	00 00       	add	r0,r0
80004306:	07 04       	ld.w	r4,r3++
80004308:	00 00       	add	r0,r0
8000430a:	07 1c       	ld.sh	r12,r3++
8000430c:	00 00       	add	r0,r0
8000430e:	06 e8       	st.h	--r3,r8
80004310:	00 00       	add	r0,r0
80004312:	06 ec       	st.h	--r3,r12

80004314 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
80004314:	eb cd 40 80 	pushm	r7,lr
80004318:	1a 97       	mov	r7,sp
8000431a:	20 2d       	sub	sp,8
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
8000431c:	49 b8       	lddpc	r8,80004388 <prvCheckTasksWaitingTermination+0x74>
8000431e:	70 08       	ld.w	r8,r8[0x0]
80004320:	58 08       	cp.w	r8,0
80004322:	c2 f0       	breq	80004380 <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
80004324:	f0 1f 00 1a 	mcall	8000438c <prvCheckTasksWaitingTermination+0x78>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80004328:	49 a8       	lddpc	r8,80004390 <prvCheckTasksWaitingTermination+0x7c>
8000432a:	70 08       	ld.w	r8,r8[0x0]
8000432c:	58 08       	cp.w	r8,0
8000432e:	5f 08       	sreq	r8
80004330:	ef 48 ff f8 	st.w	r7[-8],r8
			xTaskResumeAll();
80004334:	f0 1f 00 18 	mcall	80004394 <prvCheckTasksWaitingTermination+0x80>

			if( xListIsEmpty == pdFALSE )
80004338:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000433c:	58 08       	cp.w	r8,0
8000433e:	c2 11       	brne	80004380 <prvCheckTasksWaitingTermination+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80004340:	f0 1f 00 16 	mcall	80004398 <prvCheckTasksWaitingTermination+0x84>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80004344:	49 38       	lddpc	r8,80004390 <prvCheckTasksWaitingTermination+0x7c>
80004346:	2f 88       	sub	r8,-8
80004348:	70 18       	ld.w	r8,r8[0x4]
8000434a:	70 38       	ld.w	r8,r8[0xc]
8000434c:	ef 48 ff fc 	st.w	r7[-4],r8
					vListRemove( &( pxTCB->xGenericListItem ) );
80004350:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004354:	2f c8       	sub	r8,-4
80004356:	10 9c       	mov	r12,r8
80004358:	f0 1f 00 11 	mcall	8000439c <prvCheckTasksWaitingTermination+0x88>
					--uxCurrentNumberOfTasks;
8000435c:	49 18       	lddpc	r8,800043a0 <prvCheckTasksWaitingTermination+0x8c>
8000435e:	70 08       	ld.w	r8,r8[0x0]
80004360:	f0 c9 00 01 	sub	r9,r8,1
80004364:	48 f8       	lddpc	r8,800043a0 <prvCheckTasksWaitingTermination+0x8c>
80004366:	91 09       	st.w	r8[0x0],r9
					--uxTasksDeleted;
80004368:	48 88       	lddpc	r8,80004388 <prvCheckTasksWaitingTermination+0x74>
8000436a:	70 08       	ld.w	r8,r8[0x0]
8000436c:	f0 c9 00 01 	sub	r9,r8,1
80004370:	48 68       	lddpc	r8,80004388 <prvCheckTasksWaitingTermination+0x74>
80004372:	91 09       	st.w	r8[0x0],r9
				}
				taskEXIT_CRITICAL();
80004374:	f0 1f 00 0c 	mcall	800043a4 <prvCheckTasksWaitingTermination+0x90>

				prvDeleteTCB( pxTCB );
80004378:	ee fc ff fc 	ld.w	r12,r7[-4]
8000437c:	f0 1f 00 0b 	mcall	800043a8 <prvCheckTasksWaitingTermination+0x94>
			}
		}
	}
	#endif
}
80004380:	2f ed       	sub	sp,-8
80004382:	e3 cd 80 80 	ldm	sp++,r7,pc
80004386:	00 00       	add	r0,r0
80004388:	00 00       	add	r0,r0
8000438a:	07 18       	ld.sh	r8,r3++
8000438c:	80 00       	ld.sh	r0,r0[0x0]
8000438e:	3b e8       	mov	r8,-66
80004390:	00 00       	add	r0,r0
80004392:	07 04       	ld.w	r4,r3++
80004394:	80 00       	ld.sh	r0,r0[0x0]
80004396:	3c 04       	mov	r4,-64
80004398:	80 00       	ld.sh	r0,r0[0x0]
8000439a:	2f f8       	sub	r8,-1
8000439c:	80 00       	ld.sh	r0,r0[0x0]
8000439e:	2d e2       	sub	r2,-34
800043a0:	00 00       	add	r0,r0
800043a2:	07 30       	ld.ub	r0,r3++
800043a4:	80 00       	ld.sh	r0,r0[0x0]
800043a6:	30 14       	mov	r4,1
800043a8:	80 00       	ld.sh	r0,r0[0x0]
800043aa:	44 c0       	lddsp	r0,sp[0x130]

800043ac <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800043ac:	eb cd 40 80 	pushm	r7,lr
800043b0:	1a 97       	mov	r7,sp
800043b2:	20 1d       	sub	sp,4
800043b4:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800043b8:	49 78       	lddpc	r8,80004414 <prvAddCurrentTaskToDelayedList+0x68>
800043ba:	70 08       	ld.w	r8,r8[0x0]
800043bc:	ee f9 ff fc 	ld.w	r9,r7[-4]
800043c0:	91 19       	st.w	r8[0x4],r9

	if( xTimeToWake < xTickCount )
800043c2:	49 68       	lddpc	r8,80004418 <prvAddCurrentTaskToDelayedList+0x6c>
800043c4:	70 08       	ld.w	r8,r8[0x0]
800043c6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800043ca:	10 39       	cp.w	r9,r8
800043cc:	c0 c2       	brcc	800043e4 <prvAddCurrentTaskToDelayedList+0x38>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800043ce:	49 28       	lddpc	r8,80004414 <prvAddCurrentTaskToDelayedList+0x68>
800043d0:	70 08       	ld.w	r8,r8[0x0]
800043d2:	f0 c9 ff fc 	sub	r9,r8,-4
800043d6:	49 28       	lddpc	r8,8000441c <prvAddCurrentTaskToDelayedList+0x70>
800043d8:	70 08       	ld.w	r8,r8[0x0]
800043da:	12 9b       	mov	r11,r9
800043dc:	10 9c       	mov	r12,r8
800043de:	f0 1f 00 11 	mcall	80004420 <prvAddCurrentTaskToDelayedList+0x74>
800043e2:	c1 58       	rjmp	8000440c <prvAddCurrentTaskToDelayedList+0x60>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800043e4:	48 c8       	lddpc	r8,80004414 <prvAddCurrentTaskToDelayedList+0x68>
800043e6:	70 08       	ld.w	r8,r8[0x0]
800043e8:	f0 c9 ff fc 	sub	r9,r8,-4
800043ec:	48 e8       	lddpc	r8,80004424 <prvAddCurrentTaskToDelayedList+0x78>
800043ee:	70 08       	ld.w	r8,r8[0x0]
800043f0:	12 9b       	mov	r11,r9
800043f2:	10 9c       	mov	r12,r8
800043f4:	f0 1f 00 0b 	mcall	80004420 <prvAddCurrentTaskToDelayedList+0x74>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800043f8:	48 c8       	lddpc	r8,80004428 <prvAddCurrentTaskToDelayedList+0x7c>
800043fa:	70 08       	ld.w	r8,r8[0x0]
800043fc:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004400:	10 39       	cp.w	r9,r8
80004402:	c0 52       	brcc	8000440c <prvAddCurrentTaskToDelayedList+0x60>
		{
			xNextTaskUnblockTime = xTimeToWake;
80004404:	48 98       	lddpc	r8,80004428 <prvAddCurrentTaskToDelayedList+0x7c>
80004406:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000440a:	91 09       	st.w	r8[0x0],r9
		}
	}
}
8000440c:	2f fd       	sub	sp,-4
8000440e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004412:	00 00       	add	r0,r0
80004414:	00 00       	add	r0,r0
80004416:	06 1c       	sub	r12,r3
80004418:	00 00       	add	r0,r0
8000441a:	07 34       	ld.ub	r4,r3++
8000441c:	00 00       	add	r0,r0
8000441e:	06 ec       	st.h	--r3,r12
80004420:	80 00       	ld.sh	r0,r0[0x0]
80004422:	2d 40       	sub	r0,-44
80004424:	00 00       	add	r0,r0
80004426:	06 e8       	st.h	--r3,r8
80004428:	00 00       	add	r0,r0
8000442a:	00 20       	rsub	r0,r0

8000442c <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
8000442c:	eb cd 40 80 	pushm	r7,lr
80004430:	1a 97       	mov	r7,sp
80004432:	20 3d       	sub	sp,12
80004434:	18 98       	mov	r8,r12
80004436:	ef 4b ff f4 	st.w	r7[-12],r11
8000443a:	ef 58 ff f8 	st.h	r7[-8],r8
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
8000443e:	34 4c       	mov	r12,68
80004440:	f0 1f 00 1d 	mcall	800044b4 <prvAllocateTCBAndStack+0x88>
80004444:	18 98       	mov	r8,r12
80004446:	ef 48 ff fc 	st.w	r7[-4],r8

	if( pxNewTCB != NULL )
8000444a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000444e:	58 08       	cp.w	r8,0
80004450:	c2 c0       	breq	800044a8 <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80004452:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004456:	58 08       	cp.w	r8,0
80004458:	c0 91       	brne	8000446a <prvAllocateTCBAndStack+0x3e>
8000445a:	ef 18 ff f8 	ld.uh	r8,r7[-8]
8000445e:	a3 68       	lsl	r8,0x2
80004460:	10 9c       	mov	r12,r8
80004462:	f0 1f 00 15 	mcall	800044b4 <prvAllocateTCBAndStack+0x88>
80004466:	18 98       	mov	r8,r12
80004468:	c0 38       	rjmp	8000446e <prvAllocateTCBAndStack+0x42>
8000446a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000446e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004472:	93 c8       	st.w	r9[0x30],r8

		if( pxNewTCB->pxStack == NULL )
80004474:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004478:	70 c8       	ld.w	r8,r8[0x30]
8000447a:	58 08       	cp.w	r8,0
8000447c:	c0 91       	brne	8000448e <prvAllocateTCBAndStack+0x62>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
8000447e:	ee fc ff fc 	ld.w	r12,r7[-4]
80004482:	f0 1f 00 0e 	mcall	800044b8 <prvAllocateTCBAndStack+0x8c>
			pxNewTCB = NULL;
80004486:	30 08       	mov	r8,0
80004488:	ef 48 ff fc 	st.w	r7[-4],r8
8000448c:	c0 e8       	rjmp	800044a8 <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
8000448e:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80004492:	f0 09 15 02 	lsl	r9,r8,0x2
80004496:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000449a:	70 c8       	ld.w	r8,r8[0x30]
8000449c:	12 9a       	mov	r10,r9
8000449e:	e0 6b 00 a5 	mov	r11,165
800044a2:	10 9c       	mov	r12,r8
800044a4:	f0 1f 00 06 	mcall	800044bc <prvAllocateTCBAndStack+0x90>
		}
	}

	return pxNewTCB;
800044a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800044ac:	10 9c       	mov	r12,r8
800044ae:	2f dd       	sub	sp,-12
800044b0:	e3 cd 80 80 	ldm	sp++,r7,pc
800044b4:	80 00       	ld.sh	r0,r0[0x0]
800044b6:	32 84       	mov	r4,40
800044b8:	80 00       	ld.sh	r0,r0[0x0]
800044ba:	32 c0       	mov	r0,44
800044bc:	80 00       	ld.sh	r0,r0[0x0]
800044be:	4a b8       	lddpc	r8,80004568 <_malloc_r+0x2c>

800044c0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
800044c0:	eb cd 40 80 	pushm	r7,lr
800044c4:	1a 97       	mov	r7,sp
800044c6:	20 1d       	sub	sp,4
800044c8:	ef 4c ff fc 	st.w	r7[-4],r12
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800044cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800044d0:	70 c8       	ld.w	r8,r8[0x30]
800044d2:	10 9c       	mov	r12,r8
800044d4:	f0 1f 00 05 	mcall	800044e8 <prvDeleteTCB+0x28>
		vPortFree( pxTCB );
800044d8:	ee fc ff fc 	ld.w	r12,r7[-4]
800044dc:	f0 1f 00 03 	mcall	800044e8 <prvDeleteTCB+0x28>
	}
800044e0:	2f fd       	sub	sp,-4
800044e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800044e6:	00 00       	add	r0,r0
800044e8:	80 00       	ld.sh	r0,r0[0x0]
800044ea:	32 c0       	mov	r0,44

800044ec <atexit>:
800044ec:	d4 01       	pushm	lr
800044ee:	30 09       	mov	r9,0
800044f0:	18 9b       	mov	r11,r12
800044f2:	12 9a       	mov	r10,r9
800044f4:	12 9c       	mov	r12,r9
800044f6:	e0 a0 03 2f 	rcall	80004b54 <__register_exitproc>
800044fa:	d8 02       	popm	pc

800044fc <exit>:
800044fc:	d4 21       	pushm	r4-r7,lr
800044fe:	30 0b       	mov	r11,0
80004500:	18 97       	mov	r7,r12
80004502:	e0 a0 03 7b 	rcall	80004bf8 <__call_exitprocs>
80004506:	fe c8 f2 02 	sub	r8,pc,-3582
8000450a:	70 0c       	ld.w	r12,r8[0x0]
8000450c:	78 a8       	ld.w	r8,r12[0x28]
8000450e:	58 08       	cp.w	r8,0
80004510:	c0 20       	breq	80004514 <exit+0x18>
80004512:	5d 18       	icall	r8
80004514:	0e 9c       	mov	r12,r7
80004516:	e0 a0 02 fe 	rcall	80004b12 <_exit>
8000451a:	d7 03       	nop

8000451c <free>:
8000451c:	d4 01       	pushm	lr
8000451e:	e0 68 01 14 	mov	r8,276
80004522:	18 9b       	mov	r11,r12
80004524:	70 0c       	ld.w	r12,r8[0x0]
80004526:	e0 a0 04 1d 	rcall	80004d60 <_free_r>
8000452a:	d8 02       	popm	pc

8000452c <malloc>:
8000452c:	d4 01       	pushm	lr
8000452e:	e0 68 01 14 	mov	r8,276
80004532:	18 9b       	mov	r11,r12
80004534:	70 0c       	ld.w	r12,r8[0x0]
80004536:	c0 3c       	rcall	8000453c <_malloc_r>
80004538:	d8 02       	popm	pc
8000453a:	d7 03       	nop

8000453c <_malloc_r>:
8000453c:	d4 31       	pushm	r0-r7,lr
8000453e:	f6 c8 ff f5 	sub	r8,r11,-11
80004542:	18 95       	mov	r5,r12
80004544:	10 97       	mov	r7,r8
80004546:	e0 17 ff f8 	andl	r7,0xfff8
8000454a:	59 68       	cp.w	r8,22
8000454c:	f9 b7 08 10 	movls	r7,16
80004550:	16 37       	cp.w	r7,r11
80004552:	5f 38       	srlo	r8
80004554:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80004558:	c0 50       	breq	80004562 <_malloc_r+0x26>
8000455a:	30 c8       	mov	r8,12
8000455c:	99 38       	st.w	r12[0xc],r8
8000455e:	e0 8f 01 f8 	bral	8000494e <_malloc_r+0x412>
80004562:	fe b0 f4 a1 	rcall	80002ea4 <__malloc_lock>
80004566:	e0 47 01 f7 	cp.w	r7,503
8000456a:	e0 8b 00 1d 	brhi	800045a4 <_malloc_r+0x68>
8000456e:	ee 03 16 03 	lsr	r3,r7,0x3
80004572:	e0 68 01 18 	mov	r8,280
80004576:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000457a:	70 36       	ld.w	r6,r8[0xc]
8000457c:	10 36       	cp.w	r6,r8
8000457e:	c0 61       	brne	8000458a <_malloc_r+0x4e>
80004580:	ec c8 ff f8 	sub	r8,r6,-8
80004584:	70 36       	ld.w	r6,r8[0xc]
80004586:	10 36       	cp.w	r6,r8
80004588:	c0 c0       	breq	800045a0 <_malloc_r+0x64>
8000458a:	6c 18       	ld.w	r8,r6[0x4]
8000458c:	e0 18 ff fc 	andl	r8,0xfffc
80004590:	6c 3a       	ld.w	r10,r6[0xc]
80004592:	ec 08 00 09 	add	r9,r6,r8
80004596:	0a 9c       	mov	r12,r5
80004598:	6c 28       	ld.w	r8,r6[0x8]
8000459a:	95 28       	st.w	r10[0x8],r8
8000459c:	91 3a       	st.w	r8[0xc],r10
8000459e:	c4 78       	rjmp	8000462c <_malloc_r+0xf0>
800045a0:	2f e3       	sub	r3,-2
800045a2:	c4 d8       	rjmp	8000463c <_malloc_r+0x100>
800045a4:	ee 03 16 09 	lsr	r3,r7,0x9
800045a8:	c0 41       	brne	800045b0 <_malloc_r+0x74>
800045aa:	ee 03 16 03 	lsr	r3,r7,0x3
800045ae:	c2 68       	rjmp	800045fa <_malloc_r+0xbe>
800045b0:	58 43       	cp.w	r3,4
800045b2:	e0 8b 00 06 	brhi	800045be <_malloc_r+0x82>
800045b6:	ee 03 16 06 	lsr	r3,r7,0x6
800045ba:	2c 83       	sub	r3,-56
800045bc:	c1 f8       	rjmp	800045fa <_malloc_r+0xbe>
800045be:	59 43       	cp.w	r3,20
800045c0:	e0 8b 00 04 	brhi	800045c8 <_malloc_r+0x8c>
800045c4:	2a 53       	sub	r3,-91
800045c6:	c1 a8       	rjmp	800045fa <_malloc_r+0xbe>
800045c8:	e0 43 00 54 	cp.w	r3,84
800045cc:	e0 8b 00 06 	brhi	800045d8 <_malloc_r+0x9c>
800045d0:	ee 03 16 0c 	lsr	r3,r7,0xc
800045d4:	29 23       	sub	r3,-110
800045d6:	c1 28       	rjmp	800045fa <_malloc_r+0xbe>
800045d8:	e0 43 01 54 	cp.w	r3,340
800045dc:	e0 8b 00 06 	brhi	800045e8 <_malloc_r+0xac>
800045e0:	ee 03 16 0f 	lsr	r3,r7,0xf
800045e4:	28 93       	sub	r3,-119
800045e6:	c0 a8       	rjmp	800045fa <_malloc_r+0xbe>
800045e8:	e0 43 05 54 	cp.w	r3,1364
800045ec:	e0 88 00 04 	brls	800045f4 <_malloc_r+0xb8>
800045f0:	37 e3       	mov	r3,126
800045f2:	c0 48       	rjmp	800045fa <_malloc_r+0xbe>
800045f4:	ee 03 16 12 	lsr	r3,r7,0x12
800045f8:	28 43       	sub	r3,-124
800045fa:	e0 6a 01 18 	mov	r10,280
800045fe:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80004602:	74 36       	ld.w	r6,r10[0xc]
80004604:	c1 98       	rjmp	80004636 <_malloc_r+0xfa>
80004606:	6c 19       	ld.w	r9,r6[0x4]
80004608:	e0 19 ff fc 	andl	r9,0xfffc
8000460c:	f2 07 01 0b 	sub	r11,r9,r7
80004610:	58 fb       	cp.w	r11,15
80004612:	e0 8a 00 04 	brle	8000461a <_malloc_r+0xde>
80004616:	20 13       	sub	r3,1
80004618:	c1 18       	rjmp	8000463a <_malloc_r+0xfe>
8000461a:	6c 38       	ld.w	r8,r6[0xc]
8000461c:	58 0b       	cp.w	r11,0
8000461e:	c0 b5       	brlt	80004634 <_malloc_r+0xf8>
80004620:	6c 2a       	ld.w	r10,r6[0x8]
80004622:	ec 09 00 09 	add	r9,r6,r9
80004626:	0a 9c       	mov	r12,r5
80004628:	91 2a       	st.w	r8[0x8],r10
8000462a:	95 38       	st.w	r10[0xc],r8
8000462c:	72 18       	ld.w	r8,r9[0x4]
8000462e:	a1 a8       	sbr	r8,0x0
80004630:	93 18       	st.w	r9[0x4],r8
80004632:	cb c8       	rjmp	800047aa <_malloc_r+0x26e>
80004634:	10 96       	mov	r6,r8
80004636:	14 36       	cp.w	r6,r10
80004638:	ce 71       	brne	80004606 <_malloc_r+0xca>
8000463a:	2f f3       	sub	r3,-1
8000463c:	e0 6a 01 18 	mov	r10,280
80004640:	f4 cc ff f8 	sub	r12,r10,-8
80004644:	78 26       	ld.w	r6,r12[0x8]
80004646:	18 36       	cp.w	r6,r12
80004648:	c6 c0       	breq	80004720 <_malloc_r+0x1e4>
8000464a:	6c 19       	ld.w	r9,r6[0x4]
8000464c:	e0 19 ff fc 	andl	r9,0xfffc
80004650:	f2 07 01 08 	sub	r8,r9,r7
80004654:	58 f8       	cp.w	r8,15
80004656:	e0 89 00 8f 	brgt	80004774 <_malloc_r+0x238>
8000465a:	99 3c       	st.w	r12[0xc],r12
8000465c:	99 2c       	st.w	r12[0x8],r12
8000465e:	58 08       	cp.w	r8,0
80004660:	c0 55       	brlt	8000466a <_malloc_r+0x12e>
80004662:	ec 09 00 09 	add	r9,r6,r9
80004666:	0a 9c       	mov	r12,r5
80004668:	ce 2b       	rjmp	8000462c <_malloc_r+0xf0>
8000466a:	e0 49 01 ff 	cp.w	r9,511
8000466e:	e0 8b 00 13 	brhi	80004694 <_malloc_r+0x158>
80004672:	a3 99       	lsr	r9,0x3
80004674:	f4 09 00 38 	add	r8,r10,r9<<0x3
80004678:	70 2b       	ld.w	r11,r8[0x8]
8000467a:	8d 38       	st.w	r6[0xc],r8
8000467c:	8d 2b       	st.w	r6[0x8],r11
8000467e:	97 36       	st.w	r11[0xc],r6
80004680:	91 26       	st.w	r8[0x8],r6
80004682:	a3 49       	asr	r9,0x2
80004684:	74 18       	ld.w	r8,r10[0x4]
80004686:	30 1b       	mov	r11,1
80004688:	f6 09 09 49 	lsl	r9,r11,r9
8000468c:	f1 e9 10 09 	or	r9,r8,r9
80004690:	95 19       	st.w	r10[0x4],r9
80004692:	c4 78       	rjmp	80004720 <_malloc_r+0x1e4>
80004694:	f2 0a 16 09 	lsr	r10,r9,0x9
80004698:	58 4a       	cp.w	r10,4
8000469a:	e0 8b 00 07 	brhi	800046a8 <_malloc_r+0x16c>
8000469e:	f2 0a 16 06 	lsr	r10,r9,0x6
800046a2:	2c 8a       	sub	r10,-56
800046a4:	c2 08       	rjmp	800046e4 <_malloc_r+0x1a8>
800046a6:	d7 03       	nop
800046a8:	59 4a       	cp.w	r10,20
800046aa:	e0 8b 00 04 	brhi	800046b2 <_malloc_r+0x176>
800046ae:	2a 5a       	sub	r10,-91
800046b0:	c1 a8       	rjmp	800046e4 <_malloc_r+0x1a8>
800046b2:	e0 4a 00 54 	cp.w	r10,84
800046b6:	e0 8b 00 06 	brhi	800046c2 <_malloc_r+0x186>
800046ba:	f2 0a 16 0c 	lsr	r10,r9,0xc
800046be:	29 2a       	sub	r10,-110
800046c0:	c1 28       	rjmp	800046e4 <_malloc_r+0x1a8>
800046c2:	e0 4a 01 54 	cp.w	r10,340
800046c6:	e0 8b 00 06 	brhi	800046d2 <_malloc_r+0x196>
800046ca:	f2 0a 16 0f 	lsr	r10,r9,0xf
800046ce:	28 9a       	sub	r10,-119
800046d0:	c0 a8       	rjmp	800046e4 <_malloc_r+0x1a8>
800046d2:	e0 4a 05 54 	cp.w	r10,1364
800046d6:	e0 88 00 04 	brls	800046de <_malloc_r+0x1a2>
800046da:	37 ea       	mov	r10,126
800046dc:	c0 48       	rjmp	800046e4 <_malloc_r+0x1a8>
800046de:	f2 0a 16 12 	lsr	r10,r9,0x12
800046e2:	28 4a       	sub	r10,-124
800046e4:	e0 6b 01 18 	mov	r11,280
800046e8:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800046ec:	68 28       	ld.w	r8,r4[0x8]
800046ee:	08 38       	cp.w	r8,r4
800046f0:	c0 e1       	brne	8000470c <_malloc_r+0x1d0>
800046f2:	76 19       	ld.w	r9,r11[0x4]
800046f4:	a3 4a       	asr	r10,0x2
800046f6:	30 1e       	mov	lr,1
800046f8:	fc 0a 09 4a 	lsl	r10,lr,r10
800046fc:	f3 ea 10 0a 	or	r10,r9,r10
80004700:	10 99       	mov	r9,r8
80004702:	97 1a       	st.w	r11[0x4],r10
80004704:	c0 a8       	rjmp	80004718 <_malloc_r+0x1dc>
80004706:	70 28       	ld.w	r8,r8[0x8]
80004708:	08 38       	cp.w	r8,r4
8000470a:	c0 60       	breq	80004716 <_malloc_r+0x1da>
8000470c:	70 1a       	ld.w	r10,r8[0x4]
8000470e:	e0 1a ff fc 	andl	r10,0xfffc
80004712:	14 39       	cp.w	r9,r10
80004714:	cf 93       	brcs	80004706 <_malloc_r+0x1ca>
80004716:	70 39       	ld.w	r9,r8[0xc]
80004718:	8d 39       	st.w	r6[0xc],r9
8000471a:	8d 28       	st.w	r6[0x8],r8
8000471c:	91 36       	st.w	r8[0xc],r6
8000471e:	93 26       	st.w	r9[0x8],r6
80004720:	e6 08 14 02 	asr	r8,r3,0x2
80004724:	30 1b       	mov	r11,1
80004726:	e0 64 01 18 	mov	r4,280
8000472a:	f6 08 09 4b 	lsl	r11,r11,r8
8000472e:	68 18       	ld.w	r8,r4[0x4]
80004730:	10 3b       	cp.w	r11,r8
80004732:	e0 8b 00 6b 	brhi	80004808 <_malloc_r+0x2cc>
80004736:	f7 e8 00 09 	and	r9,r11,r8
8000473a:	c0 b1       	brne	80004750 <_malloc_r+0x214>
8000473c:	e0 13 ff fc 	andl	r3,0xfffc
80004740:	a1 7b       	lsl	r11,0x1
80004742:	2f c3       	sub	r3,-4
80004744:	c0 38       	rjmp	8000474a <_malloc_r+0x20e>
80004746:	2f c3       	sub	r3,-4
80004748:	a1 7b       	lsl	r11,0x1
8000474a:	f7 e8 00 09 	and	r9,r11,r8
8000474e:	cf c0       	breq	80004746 <_malloc_r+0x20a>
80004750:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80004754:	06 92       	mov	r2,r3
80004756:	1c 91       	mov	r1,lr
80004758:	62 36       	ld.w	r6,r1[0xc]
8000475a:	c2 e8       	rjmp	800047b6 <_malloc_r+0x27a>
8000475c:	6c 1a       	ld.w	r10,r6[0x4]
8000475e:	e0 1a ff fc 	andl	r10,0xfffc
80004762:	f4 07 01 08 	sub	r8,r10,r7
80004766:	58 f8       	cp.w	r8,15
80004768:	e0 8a 00 15 	brle	80004792 <_malloc_r+0x256>
8000476c:	6c 3a       	ld.w	r10,r6[0xc]
8000476e:	6c 29       	ld.w	r9,r6[0x8]
80004770:	95 29       	st.w	r10[0x8],r9
80004772:	93 3a       	st.w	r9[0xc],r10
80004774:	0e 99       	mov	r9,r7
80004776:	ec 07 00 07 	add	r7,r6,r7
8000477a:	a1 a9       	sbr	r9,0x0
8000477c:	99 37       	st.w	r12[0xc],r7
8000477e:	99 27       	st.w	r12[0x8],r7
80004780:	8d 19       	st.w	r6[0x4],r9
80004782:	ee 08 09 08 	st.w	r7[r8],r8
80004786:	8f 2c       	st.w	r7[0x8],r12
80004788:	8f 3c       	st.w	r7[0xc],r12
8000478a:	a1 a8       	sbr	r8,0x0
8000478c:	0a 9c       	mov	r12,r5
8000478e:	8f 18       	st.w	r7[0x4],r8
80004790:	c0 d8       	rjmp	800047aa <_malloc_r+0x26e>
80004792:	6c 39       	ld.w	r9,r6[0xc]
80004794:	58 08       	cp.w	r8,0
80004796:	c0 f5       	brlt	800047b4 <_malloc_r+0x278>
80004798:	ec 0a 00 0a 	add	r10,r6,r10
8000479c:	74 18       	ld.w	r8,r10[0x4]
8000479e:	a1 a8       	sbr	r8,0x0
800047a0:	0a 9c       	mov	r12,r5
800047a2:	95 18       	st.w	r10[0x4],r8
800047a4:	6c 28       	ld.w	r8,r6[0x8]
800047a6:	93 28       	st.w	r9[0x8],r8
800047a8:	91 39       	st.w	r8[0xc],r9
800047aa:	fe b0 f3 8b 	rcall	80002ec0 <__malloc_unlock>
800047ae:	ec cc ff f8 	sub	r12,r6,-8
800047b2:	d8 32       	popm	r0-r7,pc
800047b4:	12 96       	mov	r6,r9
800047b6:	02 36       	cp.w	r6,r1
800047b8:	cd 21       	brne	8000475c <_malloc_r+0x220>
800047ba:	2f f2       	sub	r2,-1
800047bc:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800047c0:	c0 30       	breq	800047c6 <_malloc_r+0x28a>
800047c2:	2f 81       	sub	r1,-8
800047c4:	cc ab       	rjmp	80004758 <_malloc_r+0x21c>
800047c6:	1c 98       	mov	r8,lr
800047c8:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800047cc:	c0 81       	brne	800047dc <_malloc_r+0x2a0>
800047ce:	68 19       	ld.w	r9,r4[0x4]
800047d0:	f6 08 11 ff 	rsub	r8,r11,-1
800047d4:	f3 e8 00 08 	and	r8,r9,r8
800047d8:	89 18       	st.w	r4[0x4],r8
800047da:	c0 78       	rjmp	800047e8 <_malloc_r+0x2ac>
800047dc:	f0 c9 00 08 	sub	r9,r8,8
800047e0:	20 13       	sub	r3,1
800047e2:	70 08       	ld.w	r8,r8[0x0]
800047e4:	12 38       	cp.w	r8,r9
800047e6:	cf 10       	breq	800047c8 <_malloc_r+0x28c>
800047e8:	a1 7b       	lsl	r11,0x1
800047ea:	68 18       	ld.w	r8,r4[0x4]
800047ec:	10 3b       	cp.w	r11,r8
800047ee:	e0 8b 00 0d 	brhi	80004808 <_malloc_r+0x2cc>
800047f2:	58 0b       	cp.w	r11,0
800047f4:	c0 a0       	breq	80004808 <_malloc_r+0x2cc>
800047f6:	04 93       	mov	r3,r2
800047f8:	c0 38       	rjmp	800047fe <_malloc_r+0x2c2>
800047fa:	2f c3       	sub	r3,-4
800047fc:	a1 7b       	lsl	r11,0x1
800047fe:	f7 e8 00 09 	and	r9,r11,r8
80004802:	ca 71       	brne	80004750 <_malloc_r+0x214>
80004804:	cf bb       	rjmp	800047fa <_malloc_r+0x2be>
80004806:	d7 03       	nop
80004808:	68 23       	ld.w	r3,r4[0x8]
8000480a:	66 12       	ld.w	r2,r3[0x4]
8000480c:	e0 12 ff fc 	andl	r2,0xfffc
80004810:	0e 32       	cp.w	r2,r7
80004812:	5f 39       	srlo	r9
80004814:	e4 07 01 08 	sub	r8,r2,r7
80004818:	58 f8       	cp.w	r8,15
8000481a:	5f aa       	srle	r10
8000481c:	f5 e9 10 09 	or	r9,r10,r9
80004820:	e0 80 00 98 	breq	80004950 <_malloc_r+0x414>
80004824:	e0 68 07 60 	mov	r8,1888
80004828:	70 01       	ld.w	r1,r8[0x0]
8000482a:	e0 68 05 24 	mov	r8,1316
8000482e:	2f 01       	sub	r1,-16
80004830:	70 08       	ld.w	r8,r8[0x0]
80004832:	0e 01       	add	r1,r7
80004834:	5b f8       	cp.w	r8,-1
80004836:	c0 40       	breq	8000483e <_malloc_r+0x302>
80004838:	28 11       	sub	r1,-127
8000483a:	e0 11 ff 80 	andl	r1,0xff80
8000483e:	02 9b       	mov	r11,r1
80004840:	0a 9c       	mov	r12,r5
80004842:	c4 3d       	rcall	80004ac8 <_sbrk_r>
80004844:	18 96       	mov	r6,r12
80004846:	5b fc       	cp.w	r12,-1
80004848:	c7 40       	breq	80004930 <_malloc_r+0x3f4>
8000484a:	e6 02 00 08 	add	r8,r3,r2
8000484e:	10 3c       	cp.w	r12,r8
80004850:	c0 32       	brcc	80004856 <_malloc_r+0x31a>
80004852:	08 33       	cp.w	r3,r4
80004854:	c6 e1       	brne	80004930 <_malloc_r+0x3f4>
80004856:	e0 6a 07 64 	mov	r10,1892
8000485a:	74 09       	ld.w	r9,r10[0x0]
8000485c:	e2 09 00 09 	add	r9,r1,r9
80004860:	95 09       	st.w	r10[0x0],r9
80004862:	10 36       	cp.w	r6,r8
80004864:	c0 a1       	brne	80004878 <_malloc_r+0x33c>
80004866:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000486a:	c0 71       	brne	80004878 <_malloc_r+0x33c>
8000486c:	e2 02 00 02 	add	r2,r1,r2
80004870:	68 28       	ld.w	r8,r4[0x8]
80004872:	a1 a2       	sbr	r2,0x0
80004874:	91 12       	st.w	r8[0x4],r2
80004876:	c4 e8       	rjmp	80004912 <_malloc_r+0x3d6>
80004878:	e0 6a 05 24 	mov	r10,1316
8000487c:	74 0b       	ld.w	r11,r10[0x0]
8000487e:	5b fb       	cp.w	r11,-1
80004880:	c0 31       	brne	80004886 <_malloc_r+0x34a>
80004882:	95 06       	st.w	r10[0x0],r6
80004884:	c0 78       	rjmp	80004892 <_malloc_r+0x356>
80004886:	ec 09 00 09 	add	r9,r6,r9
8000488a:	e0 6a 07 64 	mov	r10,1892
8000488e:	10 19       	sub	r9,r8
80004890:	95 09       	st.w	r10[0x0],r9
80004892:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80004896:	f0 09 11 08 	rsub	r9,r8,8
8000489a:	58 08       	cp.w	r8,0
8000489c:	f2 08 17 10 	movne	r8,r9
800048a0:	ed d8 e1 06 	addne	r6,r6,r8
800048a4:	28 08       	sub	r8,-128
800048a6:	ec 01 00 01 	add	r1,r6,r1
800048aa:	0a 9c       	mov	r12,r5
800048ac:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800048b0:	f0 01 01 01 	sub	r1,r8,r1
800048b4:	02 9b       	mov	r11,r1
800048b6:	c0 9d       	rcall	80004ac8 <_sbrk_r>
800048b8:	e0 68 07 64 	mov	r8,1892
800048bc:	5b fc       	cp.w	r12,-1
800048be:	ec 0c 17 00 	moveq	r12,r6
800048c2:	f9 b1 00 00 	moveq	r1,0
800048c6:	70 09       	ld.w	r9,r8[0x0]
800048c8:	0c 1c       	sub	r12,r6
800048ca:	89 26       	st.w	r4[0x8],r6
800048cc:	02 0c       	add	r12,r1
800048ce:	12 01       	add	r1,r9
800048d0:	a1 ac       	sbr	r12,0x0
800048d2:	91 01       	st.w	r8[0x0],r1
800048d4:	8d 1c       	st.w	r6[0x4],r12
800048d6:	08 33       	cp.w	r3,r4
800048d8:	c1 d0       	breq	80004912 <_malloc_r+0x3d6>
800048da:	58 f2       	cp.w	r2,15
800048dc:	e0 8b 00 05 	brhi	800048e6 <_malloc_r+0x3aa>
800048e0:	30 18       	mov	r8,1
800048e2:	8d 18       	st.w	r6[0x4],r8
800048e4:	c2 68       	rjmp	80004930 <_malloc_r+0x3f4>
800048e6:	30 59       	mov	r9,5
800048e8:	20 c2       	sub	r2,12
800048ea:	e0 12 ff f8 	andl	r2,0xfff8
800048ee:	e6 02 00 08 	add	r8,r3,r2
800048f2:	91 29       	st.w	r8[0x8],r9
800048f4:	91 19       	st.w	r8[0x4],r9
800048f6:	66 18       	ld.w	r8,r3[0x4]
800048f8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800048fc:	e5 e8 10 08 	or	r8,r2,r8
80004900:	87 18       	st.w	r3[0x4],r8
80004902:	58 f2       	cp.w	r2,15
80004904:	e0 88 00 07 	brls	80004912 <_malloc_r+0x3d6>
80004908:	e6 cb ff f8 	sub	r11,r3,-8
8000490c:	0a 9c       	mov	r12,r5
8000490e:	e0 a0 02 29 	rcall	80004d60 <_free_r>
80004912:	e0 69 07 5c 	mov	r9,1884
80004916:	72 0a       	ld.w	r10,r9[0x0]
80004918:	e0 68 07 64 	mov	r8,1892
8000491c:	70 08       	ld.w	r8,r8[0x0]
8000491e:	14 38       	cp.w	r8,r10
80004920:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80004924:	e0 69 07 58 	mov	r9,1880
80004928:	72 0a       	ld.w	r10,r9[0x0]
8000492a:	14 38       	cp.w	r8,r10
8000492c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80004930:	68 28       	ld.w	r8,r4[0x8]
80004932:	70 18       	ld.w	r8,r8[0x4]
80004934:	e0 18 ff fc 	andl	r8,0xfffc
80004938:	0e 38       	cp.w	r8,r7
8000493a:	5f 39       	srlo	r9
8000493c:	0e 18       	sub	r8,r7
8000493e:	58 f8       	cp.w	r8,15
80004940:	5f aa       	srle	r10
80004942:	f5 e9 10 09 	or	r9,r10,r9
80004946:	c0 50       	breq	80004950 <_malloc_r+0x414>
80004948:	0a 9c       	mov	r12,r5
8000494a:	fe b0 f2 bb 	rcall	80002ec0 <__malloc_unlock>
8000494e:	d8 3a       	popm	r0-r7,pc,r12=0
80004950:	68 26       	ld.w	r6,r4[0x8]
80004952:	a1 a8       	sbr	r8,0x0
80004954:	0e 99       	mov	r9,r7
80004956:	a1 a9       	sbr	r9,0x0
80004958:	8d 19       	st.w	r6[0x4],r9
8000495a:	ec 07 00 07 	add	r7,r6,r7
8000495e:	0a 9c       	mov	r12,r5
80004960:	89 27       	st.w	r4[0x8],r7
80004962:	8f 18       	st.w	r7[0x4],r8
80004964:	fe b0 f2 ae 	rcall	80002ec0 <__malloc_unlock>
80004968:	ec cc ff f8 	sub	r12,r6,-8
8000496c:	d8 32       	popm	r0-r7,pc
8000496e:	d7 03       	nop

80004970 <memcpy>:
80004970:	58 8a       	cp.w	r10,8
80004972:	c2 f5       	brlt	800049d0 <memcpy+0x60>
80004974:	f9 eb 10 09 	or	r9,r12,r11
80004978:	e2 19 00 03 	andl	r9,0x3,COH
8000497c:	e0 81 00 97 	brne	80004aaa <memcpy+0x13a>
80004980:	e0 4a 00 20 	cp.w	r10,32
80004984:	c3 b4       	brge	800049fa <memcpy+0x8a>
80004986:	f4 08 14 02 	asr	r8,r10,0x2
8000498a:	f0 09 11 08 	rsub	r9,r8,8
8000498e:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80004992:	76 69       	ld.w	r9,r11[0x18]
80004994:	99 69       	st.w	r12[0x18],r9
80004996:	76 59       	ld.w	r9,r11[0x14]
80004998:	99 59       	st.w	r12[0x14],r9
8000499a:	76 49       	ld.w	r9,r11[0x10]
8000499c:	99 49       	st.w	r12[0x10],r9
8000499e:	76 39       	ld.w	r9,r11[0xc]
800049a0:	99 39       	st.w	r12[0xc],r9
800049a2:	76 29       	ld.w	r9,r11[0x8]
800049a4:	99 29       	st.w	r12[0x8],r9
800049a6:	76 19       	ld.w	r9,r11[0x4]
800049a8:	99 19       	st.w	r12[0x4],r9
800049aa:	76 09       	ld.w	r9,r11[0x0]
800049ac:	99 09       	st.w	r12[0x0],r9
800049ae:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800049b2:	f8 08 00 28 	add	r8,r12,r8<<0x2
800049b6:	e0 1a 00 03 	andl	r10,0x3
800049ba:	f4 0a 11 04 	rsub	r10,r10,4
800049be:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800049c2:	17 a9       	ld.ub	r9,r11[0x2]
800049c4:	b0 a9       	st.b	r8[0x2],r9
800049c6:	17 99       	ld.ub	r9,r11[0x1]
800049c8:	b0 99       	st.b	r8[0x1],r9
800049ca:	17 89       	ld.ub	r9,r11[0x0]
800049cc:	b0 89       	st.b	r8[0x0],r9
800049ce:	5e fc       	retal	r12
800049d0:	f4 0a 11 09 	rsub	r10,r10,9
800049d4:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800049d8:	17 f9       	ld.ub	r9,r11[0x7]
800049da:	b8 f9       	st.b	r12[0x7],r9
800049dc:	17 e9       	ld.ub	r9,r11[0x6]
800049de:	b8 e9       	st.b	r12[0x6],r9
800049e0:	17 d9       	ld.ub	r9,r11[0x5]
800049e2:	b8 d9       	st.b	r12[0x5],r9
800049e4:	17 c9       	ld.ub	r9,r11[0x4]
800049e6:	b8 c9       	st.b	r12[0x4],r9
800049e8:	17 b9       	ld.ub	r9,r11[0x3]
800049ea:	b8 b9       	st.b	r12[0x3],r9
800049ec:	17 a9       	ld.ub	r9,r11[0x2]
800049ee:	b8 a9       	st.b	r12[0x2],r9
800049f0:	17 99       	ld.ub	r9,r11[0x1]
800049f2:	b8 99       	st.b	r12[0x1],r9
800049f4:	17 89       	ld.ub	r9,r11[0x0]
800049f6:	b8 89       	st.b	r12[0x0],r9
800049f8:	5e fc       	retal	r12
800049fa:	eb cd 40 c0 	pushm	r6-r7,lr
800049fe:	18 99       	mov	r9,r12
80004a00:	22 0a       	sub	r10,32
80004a02:	b7 07       	ld.d	r6,r11++
80004a04:	b3 26       	st.d	r9++,r6
80004a06:	b7 07       	ld.d	r6,r11++
80004a08:	b3 26       	st.d	r9++,r6
80004a0a:	b7 07       	ld.d	r6,r11++
80004a0c:	b3 26       	st.d	r9++,r6
80004a0e:	b7 07       	ld.d	r6,r11++
80004a10:	b3 26       	st.d	r9++,r6
80004a12:	22 0a       	sub	r10,32
80004a14:	cf 74       	brge	80004a02 <memcpy+0x92>
80004a16:	2f 0a       	sub	r10,-16
80004a18:	c0 65       	brlt	80004a24 <memcpy+0xb4>
80004a1a:	b7 07       	ld.d	r6,r11++
80004a1c:	b3 26       	st.d	r9++,r6
80004a1e:	b7 07       	ld.d	r6,r11++
80004a20:	b3 26       	st.d	r9++,r6
80004a22:	21 0a       	sub	r10,16
80004a24:	5c 3a       	neg	r10
80004a26:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80004a2a:	d7 03       	nop
80004a2c:	d7 03       	nop
80004a2e:	f7 36 00 0e 	ld.ub	r6,r11[14]
80004a32:	f3 66 00 0e 	st.b	r9[14],r6
80004a36:	f7 36 00 0d 	ld.ub	r6,r11[13]
80004a3a:	f3 66 00 0d 	st.b	r9[13],r6
80004a3e:	f7 36 00 0c 	ld.ub	r6,r11[12]
80004a42:	f3 66 00 0c 	st.b	r9[12],r6
80004a46:	f7 36 00 0b 	ld.ub	r6,r11[11]
80004a4a:	f3 66 00 0b 	st.b	r9[11],r6
80004a4e:	f7 36 00 0a 	ld.ub	r6,r11[10]
80004a52:	f3 66 00 0a 	st.b	r9[10],r6
80004a56:	f7 36 00 09 	ld.ub	r6,r11[9]
80004a5a:	f3 66 00 09 	st.b	r9[9],r6
80004a5e:	f7 36 00 08 	ld.ub	r6,r11[8]
80004a62:	f3 66 00 08 	st.b	r9[8],r6
80004a66:	f7 36 00 07 	ld.ub	r6,r11[7]
80004a6a:	f3 66 00 07 	st.b	r9[7],r6
80004a6e:	f7 36 00 06 	ld.ub	r6,r11[6]
80004a72:	f3 66 00 06 	st.b	r9[6],r6
80004a76:	f7 36 00 05 	ld.ub	r6,r11[5]
80004a7a:	f3 66 00 05 	st.b	r9[5],r6
80004a7e:	f7 36 00 04 	ld.ub	r6,r11[4]
80004a82:	f3 66 00 04 	st.b	r9[4],r6
80004a86:	f7 36 00 03 	ld.ub	r6,r11[3]
80004a8a:	f3 66 00 03 	st.b	r9[3],r6
80004a8e:	f7 36 00 02 	ld.ub	r6,r11[2]
80004a92:	f3 66 00 02 	st.b	r9[2],r6
80004a96:	f7 36 00 01 	ld.ub	r6,r11[1]
80004a9a:	f3 66 00 01 	st.b	r9[1],r6
80004a9e:	f7 36 00 00 	ld.ub	r6,r11[0]
80004aa2:	f3 66 00 00 	st.b	r9[0],r6
80004aa6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004aaa:	20 1a       	sub	r10,1
80004aac:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80004ab0:	f8 0a 0b 09 	st.b	r12[r10],r9
80004ab4:	cf b1       	brne	80004aaa <memcpy+0x13a>
80004ab6:	5e fc       	retal	r12

80004ab8 <memset>:
80004ab8:	18 98       	mov	r8,r12
80004aba:	c0 38       	rjmp	80004ac0 <memset+0x8>
80004abc:	10 cb       	st.b	r8++,r11
80004abe:	20 1a       	sub	r10,1
80004ac0:	58 0a       	cp.w	r10,0
80004ac2:	cf d1       	brne	80004abc <memset+0x4>
80004ac4:	5e fc       	retal	r12
80004ac6:	d7 03       	nop

80004ac8 <_sbrk_r>:
80004ac8:	d4 21       	pushm	r4-r7,lr
80004aca:	30 08       	mov	r8,0
80004acc:	18 97       	mov	r7,r12
80004ace:	e0 66 07 9c 	mov	r6,1948
80004ad2:	16 9c       	mov	r12,r11
80004ad4:	8d 08       	st.w	r6[0x0],r8
80004ad6:	c2 3c       	rcall	80004b1c <_sbrk>
80004ad8:	5b fc       	cp.w	r12,-1
80004ada:	c0 51       	brne	80004ae4 <_sbrk_r+0x1c>
80004adc:	6c 08       	ld.w	r8,r6[0x0]
80004ade:	58 08       	cp.w	r8,0
80004ae0:	ef f8 1a 03 	st.wne	r7[0xc],r8
80004ae4:	d8 22       	popm	r4-r7,pc
80004ae6:	d7 03       	nop

80004ae8 <strncpy>:
80004ae8:	30 08       	mov	r8,0
80004aea:	10 3a       	cp.w	r10,r8
80004aec:	5e 0c       	reteq	r12
80004aee:	f6 08 07 09 	ld.ub	r9,r11[r8]
80004af2:	f8 08 0b 09 	st.b	r12[r8],r9
80004af6:	2f f8       	sub	r8,-1
80004af8:	58 09       	cp.w	r9,0
80004afa:	cf 81       	brne	80004aea <strncpy+0x2>
80004afc:	10 3a       	cp.w	r10,r8
80004afe:	5e 0c       	reteq	r12
80004b00:	f8 08 0b 09 	st.b	r12[r8],r9
80004b04:	2f f8       	sub	r8,-1
80004b06:	cf bb       	rjmp	80004afc <strncpy+0x14>

80004b08 <_init_argv>:
80004b08:	30 e8       	mov	r8,14
80004b0a:	d6 73       	breakpoint
80004b0c:	3f fc       	mov	r12,-1
80004b0e:	35 8b       	mov	r11,88
80004b10:	5e fc       	retal	r12

80004b12 <_exit>:
80004b12:	30 d8       	mov	r8,13
80004b14:	d6 73       	breakpoint
80004b16:	3f fc       	mov	r12,-1
80004b18:	35 8b       	mov	r11,88
80004b1a:	c0 08       	rjmp	80004b1a <_exit+0x8>

80004b1c <_sbrk>:
80004b1c:	d4 01       	pushm	lr
80004b1e:	e0 68 07 8c 	mov	r8,1932
80004b22:	70 09       	ld.w	r9,r8[0x0]
80004b24:	58 09       	cp.w	r9,0
80004b26:	c0 41       	brne	80004b2e <_sbrk+0x12>
80004b28:	e0 69 07 a0 	mov	r9,1952
80004b2c:	91 09       	st.w	r8[0x0],r9
80004b2e:	e0 69 07 8c 	mov	r9,1932
80004b32:	e0 6a f0 00 	mov	r10,61440
80004b36:	72 08       	ld.w	r8,r9[0x0]
80004b38:	f0 0c 00 0c 	add	r12,r8,r12
80004b3c:	14 3c       	cp.w	r12,r10
80004b3e:	e0 8b 00 04 	brhi	80004b46 <_sbrk+0x2a>
80004b42:	93 0c       	st.w	r9[0x0],r12
80004b44:	c0 58       	rjmp	80004b4e <_sbrk+0x32>
80004b46:	cb fc       	rcall	80004cc4 <__errno>
80004b48:	30 c8       	mov	r8,12
80004b4a:	99 08       	st.w	r12[0x0],r8
80004b4c:	3f f8       	mov	r8,-1
80004b4e:	10 9c       	mov	r12,r8
80004b50:	d8 02       	popm	pc
80004b52:	d7 03       	nop

80004b54 <__register_exitproc>:
80004b54:	d4 31       	pushm	r0-r7,lr
80004b56:	fe c8 f8 52 	sub	r8,pc,-1966
80004b5a:	70 03       	ld.w	r3,r8[0x0]
80004b5c:	67 24       	ld.w	r4,r3[0x48]
80004b5e:	e6 c8 ff b4 	sub	r8,r3,-76
80004b62:	58 04       	cp.w	r4,0
80004b64:	f0 04 17 00 	moveq	r4,r8
80004b68:	e7 f4 0a 12 	st.weq	r3[0x48],r4
80004b6c:	18 97       	mov	r7,r12
80004b6e:	16 96       	mov	r6,r11
80004b70:	14 95       	mov	r5,r10
80004b72:	12 92       	mov	r2,r9
80004b74:	68 18       	ld.w	r8,r4[0x4]
80004b76:	59 f8       	cp.w	r8,31
80004b78:	e0 8a 00 0e 	brle	80004b94 <__register_exitproc+0x40>
80004b7c:	e0 6c 00 8c 	mov	r12,140
80004b80:	fe b0 fc d6 	rcall	8000452c <malloc>
80004b84:	18 94       	mov	r4,r12
80004b86:	c3 80       	breq	80004bf6 <__register_exitproc+0xa2>
80004b88:	67 28       	ld.w	r8,r3[0x48]
80004b8a:	99 08       	st.w	r12[0x0],r8
80004b8c:	e7 4c 00 48 	st.w	r3[72],r12
80004b90:	30 08       	mov	r8,0
80004b92:	99 18       	st.w	r12[0x4],r8
80004b94:	58 07       	cp.w	r7,0
80004b96:	c2 70       	breq	80004be4 <__register_exitproc+0x90>
80004b98:	e8 fc 00 88 	ld.w	r12,r4[136]
80004b9c:	58 0c       	cp.w	r12,0
80004b9e:	c0 d1       	brne	80004bb8 <__register_exitproc+0x64>
80004ba0:	e0 6c 01 08 	mov	r12,264
80004ba4:	fe b0 fc c4 	rcall	8000452c <malloc>
80004ba8:	c2 70       	breq	80004bf6 <__register_exitproc+0xa2>
80004baa:	30 08       	mov	r8,0
80004bac:	e9 4c 00 88 	st.w	r4[136],r12
80004bb0:	f9 48 01 04 	st.w	r12[260],r8
80004bb4:	f9 48 01 00 	st.w	r12[256],r8
80004bb8:	68 18       	ld.w	r8,r4[0x4]
80004bba:	f0 c9 ff e0 	sub	r9,r8,-32
80004bbe:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
80004bc2:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
80004bc6:	30 1a       	mov	r10,1
80004bc8:	f8 f9 01 00 	ld.w	r9,r12[256]
80004bcc:	f4 08 09 48 	lsl	r8,r10,r8
80004bd0:	10 49       	or	r9,r8
80004bd2:	f9 49 01 00 	st.w	r12[256],r9
80004bd6:	58 27       	cp.w	r7,2
80004bd8:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
80004bdc:	f3 d8 e0 38 	oreq	r8,r9,r8
80004be0:	f9 f8 0a 41 	st.weq	r12[0x104],r8
80004be4:	68 18       	ld.w	r8,r4[0x4]
80004be6:	30 0c       	mov	r12,0
80004be8:	f0 c9 ff ff 	sub	r9,r8,-1
80004bec:	2f e8       	sub	r8,-2
80004bee:	89 19       	st.w	r4[0x4],r9
80004bf0:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
80004bf4:	d8 32       	popm	r0-r7,pc
80004bf6:	dc 3a       	popm	r0-r7,pc,r12=-1

80004bf8 <__call_exitprocs>:
80004bf8:	d4 31       	pushm	r0-r7,lr
80004bfa:	20 3d       	sub	sp,12
80004bfc:	fe c8 f8 f8 	sub	r8,pc,-1800
80004c00:	50 2c       	stdsp	sp[0x8],r12
80004c02:	70 08       	ld.w	r8,r8[0x0]
80004c04:	16 91       	mov	r1,r11
80004c06:	50 08       	stdsp	sp[0x0],r8
80004c08:	2b 88       	sub	r8,-72
80004c0a:	50 18       	stdsp	sp[0x4],r8
80004c0c:	40 0a       	lddsp	r10,sp[0x0]
80004c0e:	40 14       	lddsp	r4,sp[0x4]
80004c10:	75 27       	ld.w	r7,r10[0x48]
80004c12:	c5 58       	rjmp	80004cbc <__call_exitprocs+0xc4>
80004c14:	6e 15       	ld.w	r5,r7[0x4]
80004c16:	ee f6 00 88 	ld.w	r6,r7[136]
80004c1a:	ea c2 ff ff 	sub	r2,r5,-1
80004c1e:	20 15       	sub	r5,1
80004c20:	ee 02 00 22 	add	r2,r7,r2<<0x2
80004c24:	ec 05 00 23 	add	r3,r6,r5<<0x2
80004c28:	c3 58       	rjmp	80004c92 <__call_exitprocs+0x9a>
80004c2a:	58 01       	cp.w	r1,0
80004c2c:	c0 70       	breq	80004c3a <__call_exitprocs+0x42>
80004c2e:	58 06       	cp.w	r6,0
80004c30:	c2 e0       	breq	80004c8c <__call_exitprocs+0x94>
80004c32:	e6 f8 00 80 	ld.w	r8,r3[128]
80004c36:	02 38       	cp.w	r8,r1
80004c38:	c2 a1       	brne	80004c8c <__call_exitprocs+0x94>
80004c3a:	6e 19       	ld.w	r9,r7[0x4]
80004c3c:	64 08       	ld.w	r8,r2[0x0]
80004c3e:	20 19       	sub	r9,1
80004c40:	12 35       	cp.w	r5,r9
80004c42:	ef f5 0a 01 	st.weq	r7[0x4],r5
80004c46:	f9 b9 01 00 	movne	r9,0
80004c4a:	e5 f9 1a 00 	st.wne	r2[0x0],r9
80004c4e:	58 08       	cp.w	r8,0
80004c50:	c1 e0       	breq	80004c8c <__call_exitprocs+0x94>
80004c52:	6e 10       	ld.w	r0,r7[0x4]
80004c54:	58 06       	cp.w	r6,0
80004c56:	c0 90       	breq	80004c68 <__call_exitprocs+0x70>
80004c58:	30 1a       	mov	r10,1
80004c5a:	f4 05 09 49 	lsl	r9,r10,r5
80004c5e:	ec fa 01 00 	ld.w	r10,r6[256]
80004c62:	f3 ea 00 0a 	and	r10,r9,r10
80004c66:	c0 31       	brne	80004c6c <__call_exitprocs+0x74>
80004c68:	5d 18       	icall	r8
80004c6a:	c0 b8       	rjmp	80004c80 <__call_exitprocs+0x88>
80004c6c:	ec fa 01 04 	ld.w	r10,r6[260]
80004c70:	66 0b       	ld.w	r11,r3[0x0]
80004c72:	14 69       	and	r9,r10
80004c74:	c0 41       	brne	80004c7c <__call_exitprocs+0x84>
80004c76:	40 2c       	lddsp	r12,sp[0x8]
80004c78:	5d 18       	icall	r8
80004c7a:	c0 38       	rjmp	80004c80 <__call_exitprocs+0x88>
80004c7c:	16 9c       	mov	r12,r11
80004c7e:	5d 18       	icall	r8
80004c80:	6e 18       	ld.w	r8,r7[0x4]
80004c82:	10 30       	cp.w	r0,r8
80004c84:	cc 41       	brne	80004c0c <__call_exitprocs+0x14>
80004c86:	68 08       	ld.w	r8,r4[0x0]
80004c88:	0e 38       	cp.w	r8,r7
80004c8a:	cc 11       	brne	80004c0c <__call_exitprocs+0x14>
80004c8c:	20 15       	sub	r5,1
80004c8e:	20 43       	sub	r3,4
80004c90:	20 42       	sub	r2,4
80004c92:	58 05       	cp.w	r5,0
80004c94:	cc b4       	brge	80004c2a <__call_exitprocs+0x32>
80004c96:	6e 18       	ld.w	r8,r7[0x4]
80004c98:	58 08       	cp.w	r8,0
80004c9a:	c0 f1       	brne	80004cb8 <__call_exitprocs+0xc0>
80004c9c:	6e 08       	ld.w	r8,r7[0x0]
80004c9e:	58 08       	cp.w	r8,0
80004ca0:	c0 c0       	breq	80004cb8 <__call_exitprocs+0xc0>
80004ca2:	89 08       	st.w	r4[0x0],r8
80004ca4:	58 06       	cp.w	r6,0
80004ca6:	c0 40       	breq	80004cae <__call_exitprocs+0xb6>
80004ca8:	0c 9c       	mov	r12,r6
80004caa:	fe b0 fc 39 	rcall	8000451c <free>
80004cae:	0e 9c       	mov	r12,r7
80004cb0:	fe b0 fc 36 	rcall	8000451c <free>
80004cb4:	68 07       	ld.w	r7,r4[0x0]
80004cb6:	c0 38       	rjmp	80004cbc <__call_exitprocs+0xc4>
80004cb8:	0e 94       	mov	r4,r7
80004cba:	6e 07       	ld.w	r7,r7[0x0]
80004cbc:	58 07       	cp.w	r7,0
80004cbe:	ca b1       	brne	80004c14 <__call_exitprocs+0x1c>
80004cc0:	2f dd       	sub	sp,-12
80004cc2:	d8 32       	popm	r0-r7,pc

80004cc4 <__errno>:
80004cc4:	e0 68 01 14 	mov	r8,276
80004cc8:	70 0c       	ld.w	r12,r8[0x0]
80004cca:	2f 4c       	sub	r12,-12
80004ccc:	5e fc       	retal	r12
80004cce:	d7 03       	nop

80004cd0 <_malloc_trim_r>:
80004cd0:	d4 21       	pushm	r4-r7,lr
80004cd2:	16 95       	mov	r5,r11
80004cd4:	18 97       	mov	r7,r12
80004cd6:	fe b0 f0 e7 	rcall	80002ea4 <__malloc_lock>
80004cda:	e0 64 01 18 	mov	r4,280
80004cde:	68 28       	ld.w	r8,r4[0x8]
80004ce0:	70 16       	ld.w	r6,r8[0x4]
80004ce2:	e0 16 ff fc 	andl	r6,0xfffc
80004ce6:	ec c8 ff 91 	sub	r8,r6,-111
80004cea:	f0 05 01 05 	sub	r5,r8,r5
80004cee:	e0 15 ff 80 	andl	r5,0xff80
80004cf2:	ea c5 00 80 	sub	r5,r5,128
80004cf6:	e0 45 00 7f 	cp.w	r5,127
80004cfa:	e0 8a 00 22 	brle	80004d3e <_malloc_trim_r+0x6e>
80004cfe:	30 0b       	mov	r11,0
80004d00:	0e 9c       	mov	r12,r7
80004d02:	ce 3e       	rcall	80004ac8 <_sbrk_r>
80004d04:	68 28       	ld.w	r8,r4[0x8]
80004d06:	0c 08       	add	r8,r6
80004d08:	10 3c       	cp.w	r12,r8
80004d0a:	c1 a1       	brne	80004d3e <_malloc_trim_r+0x6e>
80004d0c:	ea 0b 11 00 	rsub	r11,r5,0
80004d10:	0e 9c       	mov	r12,r7
80004d12:	cd be       	rcall	80004ac8 <_sbrk_r>
80004d14:	5b fc       	cp.w	r12,-1
80004d16:	c1 81       	brne	80004d46 <_malloc_trim_r+0x76>
80004d18:	30 0b       	mov	r11,0
80004d1a:	0e 9c       	mov	r12,r7
80004d1c:	cd 6e       	rcall	80004ac8 <_sbrk_r>
80004d1e:	68 28       	ld.w	r8,r4[0x8]
80004d20:	f8 08 01 09 	sub	r9,r12,r8
80004d24:	58 f9       	cp.w	r9,15
80004d26:	e0 8a 00 0c 	brle	80004d3e <_malloc_trim_r+0x6e>
80004d2a:	a1 a9       	sbr	r9,0x0
80004d2c:	91 19       	st.w	r8[0x4],r9
80004d2e:	e0 68 05 24 	mov	r8,1316
80004d32:	70 09       	ld.w	r9,r8[0x0]
80004d34:	e0 68 07 64 	mov	r8,1892
80004d38:	f8 09 01 09 	sub	r9,r12,r9
80004d3c:	91 09       	st.w	r8[0x0],r9
80004d3e:	0e 9c       	mov	r12,r7
80004d40:	fe b0 f0 c0 	rcall	80002ec0 <__malloc_unlock>
80004d44:	d8 2a       	popm	r4-r7,pc,r12=0
80004d46:	68 28       	ld.w	r8,r4[0x8]
80004d48:	0a 16       	sub	r6,r5
80004d4a:	a1 a6       	sbr	r6,0x0
80004d4c:	91 16       	st.w	r8[0x4],r6
80004d4e:	e0 68 07 64 	mov	r8,1892
80004d52:	70 09       	ld.w	r9,r8[0x0]
80004d54:	0a 19       	sub	r9,r5
80004d56:	0e 9c       	mov	r12,r7
80004d58:	91 09       	st.w	r8[0x0],r9
80004d5a:	fe b0 f0 b3 	rcall	80002ec0 <__malloc_unlock>
80004d5e:	da 2a       	popm	r4-r7,pc,r12=1

80004d60 <_free_r>:
80004d60:	d4 21       	pushm	r4-r7,lr
80004d62:	16 96       	mov	r6,r11
80004d64:	18 97       	mov	r7,r12
80004d66:	58 0b       	cp.w	r11,0
80004d68:	e0 80 00 c0 	breq	80004ee8 <_free_r+0x188>
80004d6c:	fe b0 f0 9c 	rcall	80002ea4 <__malloc_lock>
80004d70:	20 86       	sub	r6,8
80004d72:	e0 6a 01 18 	mov	r10,280
80004d76:	6c 18       	ld.w	r8,r6[0x4]
80004d78:	74 2e       	ld.w	lr,r10[0x8]
80004d7a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004d7e:	a1 c8       	cbr	r8,0x0
80004d80:	ec 08 00 09 	add	r9,r6,r8
80004d84:	72 1b       	ld.w	r11,r9[0x4]
80004d86:	e0 1b ff fc 	andl	r11,0xfffc
80004d8a:	1c 39       	cp.w	r9,lr
80004d8c:	c1 e1       	brne	80004dc8 <_free_r+0x68>
80004d8e:	f6 08 00 08 	add	r8,r11,r8
80004d92:	58 0c       	cp.w	r12,0
80004d94:	c0 81       	brne	80004da4 <_free_r+0x44>
80004d96:	6c 09       	ld.w	r9,r6[0x0]
80004d98:	12 16       	sub	r6,r9
80004d9a:	12 08       	add	r8,r9
80004d9c:	6c 3b       	ld.w	r11,r6[0xc]
80004d9e:	6c 29       	ld.w	r9,r6[0x8]
80004da0:	97 29       	st.w	r11[0x8],r9
80004da2:	93 3b       	st.w	r9[0xc],r11
80004da4:	10 99       	mov	r9,r8
80004da6:	95 26       	st.w	r10[0x8],r6
80004da8:	a1 a9       	sbr	r9,0x0
80004daa:	8d 19       	st.w	r6[0x4],r9
80004dac:	e0 69 05 20 	mov	r9,1312
80004db0:	72 09       	ld.w	r9,r9[0x0]
80004db2:	12 38       	cp.w	r8,r9
80004db4:	c0 63       	brcs	80004dc0 <_free_r+0x60>
80004db6:	e0 68 07 60 	mov	r8,1888
80004dba:	0e 9c       	mov	r12,r7
80004dbc:	70 0b       	ld.w	r11,r8[0x0]
80004dbe:	c8 9f       	rcall	80004cd0 <_malloc_trim_r>
80004dc0:	0e 9c       	mov	r12,r7
80004dc2:	fe b0 f0 7f 	rcall	80002ec0 <__malloc_unlock>
80004dc6:	d8 22       	popm	r4-r7,pc
80004dc8:	93 1b       	st.w	r9[0x4],r11
80004dca:	58 0c       	cp.w	r12,0
80004dcc:	c0 30       	breq	80004dd2 <_free_r+0x72>
80004dce:	30 0c       	mov	r12,0
80004dd0:	c1 08       	rjmp	80004df0 <_free_r+0x90>
80004dd2:	6c 0e       	ld.w	lr,r6[0x0]
80004dd4:	f4 c5 ff f8 	sub	r5,r10,-8
80004dd8:	1c 16       	sub	r6,lr
80004dda:	1c 08       	add	r8,lr
80004ddc:	6c 2e       	ld.w	lr,r6[0x8]
80004dde:	0a 3e       	cp.w	lr,r5
80004de0:	f9 bc 00 01 	moveq	r12,1
80004de4:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80004de8:	eb fe 1a 02 	st.wne	r5[0x8],lr
80004dec:	fd f5 1a 03 	st.wne	lr[0xc],r5
80004df0:	f2 0b 00 0e 	add	lr,r9,r11
80004df4:	7c 1e       	ld.w	lr,lr[0x4]
80004df6:	ed be 00 00 	bld	lr,0x0
80004dfa:	c1 40       	breq	80004e22 <_free_r+0xc2>
80004dfc:	16 08       	add	r8,r11
80004dfe:	58 0c       	cp.w	r12,0
80004e00:	c0 d1       	brne	80004e1a <_free_r+0xba>
80004e02:	e0 6e 01 18 	mov	lr,280
80004e06:	72 2b       	ld.w	r11,r9[0x8]
80004e08:	2f 8e       	sub	lr,-8
80004e0a:	1c 3b       	cp.w	r11,lr
80004e0c:	c0 71       	brne	80004e1a <_free_r+0xba>
80004e0e:	97 36       	st.w	r11[0xc],r6
80004e10:	97 26       	st.w	r11[0x8],r6
80004e12:	8d 2b       	st.w	r6[0x8],r11
80004e14:	8d 3b       	st.w	r6[0xc],r11
80004e16:	30 1c       	mov	r12,1
80004e18:	c0 58       	rjmp	80004e22 <_free_r+0xc2>
80004e1a:	72 2b       	ld.w	r11,r9[0x8]
80004e1c:	72 39       	ld.w	r9,r9[0xc]
80004e1e:	93 2b       	st.w	r9[0x8],r11
80004e20:	97 39       	st.w	r11[0xc],r9
80004e22:	10 99       	mov	r9,r8
80004e24:	ec 08 09 08 	st.w	r6[r8],r8
80004e28:	a1 a9       	sbr	r9,0x0
80004e2a:	8d 19       	st.w	r6[0x4],r9
80004e2c:	58 0c       	cp.w	r12,0
80004e2e:	c5 a1       	brne	80004ee2 <_free_r+0x182>
80004e30:	e0 48 01 ff 	cp.w	r8,511
80004e34:	e0 8b 00 13 	brhi	80004e5a <_free_r+0xfa>
80004e38:	a3 98       	lsr	r8,0x3
80004e3a:	f4 08 00 39 	add	r9,r10,r8<<0x3
80004e3e:	72 2b       	ld.w	r11,r9[0x8]
80004e40:	8d 39       	st.w	r6[0xc],r9
80004e42:	8d 2b       	st.w	r6[0x8],r11
80004e44:	97 36       	st.w	r11[0xc],r6
80004e46:	93 26       	st.w	r9[0x8],r6
80004e48:	a3 48       	asr	r8,0x2
80004e4a:	74 19       	ld.w	r9,r10[0x4]
80004e4c:	30 1b       	mov	r11,1
80004e4e:	f6 08 09 48 	lsl	r8,r11,r8
80004e52:	f3 e8 10 08 	or	r8,r9,r8
80004e56:	95 18       	st.w	r10[0x4],r8
80004e58:	c4 58       	rjmp	80004ee2 <_free_r+0x182>
80004e5a:	f0 0b 16 09 	lsr	r11,r8,0x9
80004e5e:	58 4b       	cp.w	r11,4
80004e60:	e0 8b 00 06 	brhi	80004e6c <_free_r+0x10c>
80004e64:	f0 0b 16 06 	lsr	r11,r8,0x6
80004e68:	2c 8b       	sub	r11,-56
80004e6a:	c2 08       	rjmp	80004eaa <_free_r+0x14a>
80004e6c:	59 4b       	cp.w	r11,20
80004e6e:	e0 8b 00 04 	brhi	80004e76 <_free_r+0x116>
80004e72:	2a 5b       	sub	r11,-91
80004e74:	c1 b8       	rjmp	80004eaa <_free_r+0x14a>
80004e76:	e0 4b 00 54 	cp.w	r11,84
80004e7a:	e0 8b 00 06 	brhi	80004e86 <_free_r+0x126>
80004e7e:	f0 0b 16 0c 	lsr	r11,r8,0xc
80004e82:	29 2b       	sub	r11,-110
80004e84:	c1 38       	rjmp	80004eaa <_free_r+0x14a>
80004e86:	e0 4b 01 54 	cp.w	r11,340
80004e8a:	e0 8b 00 06 	brhi	80004e96 <_free_r+0x136>
80004e8e:	f0 0b 16 0f 	lsr	r11,r8,0xf
80004e92:	28 9b       	sub	r11,-119
80004e94:	c0 b8       	rjmp	80004eaa <_free_r+0x14a>
80004e96:	e0 4b 05 54 	cp.w	r11,1364
80004e9a:	e0 88 00 05 	brls	80004ea4 <_free_r+0x144>
80004e9e:	37 eb       	mov	r11,126
80004ea0:	c0 58       	rjmp	80004eaa <_free_r+0x14a>
80004ea2:	d7 03       	nop
80004ea4:	f0 0b 16 12 	lsr	r11,r8,0x12
80004ea8:	28 4b       	sub	r11,-124
80004eaa:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80004eae:	78 29       	ld.w	r9,r12[0x8]
80004eb0:	18 39       	cp.w	r9,r12
80004eb2:	c0 e1       	brne	80004ece <_free_r+0x16e>
80004eb4:	74 18       	ld.w	r8,r10[0x4]
80004eb6:	a3 4b       	asr	r11,0x2
80004eb8:	30 1c       	mov	r12,1
80004eba:	f8 0b 09 4b 	lsl	r11,r12,r11
80004ebe:	f1 eb 10 0b 	or	r11,r8,r11
80004ec2:	12 98       	mov	r8,r9
80004ec4:	95 1b       	st.w	r10[0x4],r11
80004ec6:	c0 a8       	rjmp	80004eda <_free_r+0x17a>
80004ec8:	72 29       	ld.w	r9,r9[0x8]
80004eca:	18 39       	cp.w	r9,r12
80004ecc:	c0 60       	breq	80004ed8 <_free_r+0x178>
80004ece:	72 1a       	ld.w	r10,r9[0x4]
80004ed0:	e0 1a ff fc 	andl	r10,0xfffc
80004ed4:	14 38       	cp.w	r8,r10
80004ed6:	cf 93       	brcs	80004ec8 <_free_r+0x168>
80004ed8:	72 38       	ld.w	r8,r9[0xc]
80004eda:	8d 38       	st.w	r6[0xc],r8
80004edc:	8d 29       	st.w	r6[0x8],r9
80004ede:	93 36       	st.w	r9[0xc],r6
80004ee0:	91 26       	st.w	r8[0x8],r6
80004ee2:	0e 9c       	mov	r12,r7
80004ee4:	fe b0 ef ee 	rcall	80002ec0 <__malloc_unlock>
80004ee8:	d8 22       	popm	r4-r7,pc
80004eea:	d7 03       	nop

80004eec <__do_global_ctors_aux>:
80004eec:	d4 21       	pushm	r4-r7,lr
80004eee:	30 c7       	mov	r7,12
80004ef0:	c0 28       	rjmp	80004ef4 <__do_global_ctors_aux+0x8>
80004ef2:	5d 18       	icall	r8
80004ef4:	20 47       	sub	r7,4
80004ef6:	6e 08       	ld.w	r8,r7[0x0]
80004ef8:	5b f8       	cp.w	r8,-1
80004efa:	cf c1       	brne	80004ef2 <__do_global_ctors_aux+0x6>
80004efc:	d8 22       	popm	r4-r7,pc
80004efe:	d7 03       	nop

Disassembly of section .exception:

80005000 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80005000:	c0 08       	rjmp	80005000 <_evba>
	...

80005004 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80005004:	c0 08       	rjmp	80005004 <_handle_TLB_Multiple_Hit>
	...

80005008 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80005008:	c0 08       	rjmp	80005008 <_handle_Bus_Error_Data_Fetch>
	...

8000500c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000500c:	c0 08       	rjmp	8000500c <_handle_Bus_Error_Instruction_Fetch>
	...

80005010 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80005010:	c0 08       	rjmp	80005010 <_handle_NMI>
	...

80005014 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80005014:	c0 08       	rjmp	80005014 <_handle_Instruction_Address>
	...

80005018 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80005018:	c0 08       	rjmp	80005018 <_handle_ITLB_Protection>
	...

8000501c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000501c:	c0 08       	rjmp	8000501c <_handle_Breakpoint>
	...

80005020 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80005020:	c0 08       	rjmp	80005020 <_handle_Illegal_Opcode>
	...

80005024 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80005024:	c0 08       	rjmp	80005024 <_handle_Unimplemented_Instruction>
	...

80005028 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80005028:	c0 08       	rjmp	80005028 <_handle_Privilege_Violation>
	...

8000502c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000502c:	c0 08       	rjmp	8000502c <_handle_Floating_Point>
	...

80005030 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
80005030:	c0 08       	rjmp	80005030 <_handle_Coprocessor_Absent>
	...

80005034 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80005034:	c0 08       	rjmp	80005034 <_handle_Data_Address_Read>
	...

80005038 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80005038:	c0 08       	rjmp	80005038 <_handle_Data_Address_Write>
	...

8000503c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000503c:	c0 08       	rjmp	8000503c <_handle_DTLB_Protection_Read>
	...

80005040 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80005040:	c0 08       	rjmp	80005040 <_handle_DTLB_Protection_Write>
	...

80005044 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80005044:	c0 08       	rjmp	80005044 <_handle_DTLB_Modified>
	...

80005050 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80005050:	c0 08       	rjmp	80005050 <_handle_ITLB_Miss>
	...

80005060 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80005060:	c0 08       	rjmp	80005060 <_handle_DTLB_Miss_Read>
	...

80005070 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80005070:	c0 08       	rjmp	80005070 <_handle_DTLB_Miss_Write>
	...

80005100 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80005100:	fe cf 21 a0 	sub	pc,pc,8608

80005104 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80005104:	30 0c       	mov	r12,0
80005106:	fe b0 e9 e9 	rcall	800024d8 <_get_interrupt_handler>
8000510a:	58 0c       	cp.w	r12,0
8000510c:	f8 0f 17 10 	movne	pc,r12
80005110:	d6 03       	rete

80005112 <_int1>:
80005112:	30 1c       	mov	r12,1
80005114:	fe b0 e9 e2 	rcall	800024d8 <_get_interrupt_handler>
80005118:	58 0c       	cp.w	r12,0
8000511a:	f8 0f 17 10 	movne	pc,r12
8000511e:	d6 03       	rete

80005120 <_int2>:
80005120:	30 2c       	mov	r12,2
80005122:	fe b0 e9 db 	rcall	800024d8 <_get_interrupt_handler>
80005126:	58 0c       	cp.w	r12,0
80005128:	f8 0f 17 10 	movne	pc,r12
8000512c:	d6 03       	rete

8000512e <_int3>:
8000512e:	30 3c       	mov	r12,3
80005130:	fe b0 e9 d4 	rcall	800024d8 <_get_interrupt_handler>
80005134:	58 0c       	cp.w	r12,0
80005136:	f8 0f 17 10 	movne	pc,r12
8000513a:	d6 03       	rete
8000513c:	d7 03       	nop
8000513e:	d7 03       	nop
80005140:	d7 03       	nop
80005142:	d7 03       	nop
80005144:	d7 03       	nop
80005146:	d7 03       	nop
80005148:	d7 03       	nop
8000514a:	d7 03       	nop
8000514c:	d7 03       	nop
8000514e:	d7 03       	nop
80005150:	d7 03       	nop
80005152:	d7 03       	nop
80005154:	d7 03       	nop
80005156:	d7 03       	nop
80005158:	d7 03       	nop
8000515a:	d7 03       	nop
8000515c:	d7 03       	nop
8000515e:	d7 03       	nop
80005160:	d7 03       	nop
80005162:	d7 03       	nop
80005164:	d7 03       	nop
80005166:	d7 03       	nop
80005168:	d7 03       	nop
8000516a:	d7 03       	nop
8000516c:	d7 03       	nop
8000516e:	d7 03       	nop
80005170:	d7 03       	nop
80005172:	d7 03       	nop
80005174:	d7 03       	nop
80005176:	d7 03       	nop
80005178:	d7 03       	nop
8000517a:	d7 03       	nop
8000517c:	d7 03       	nop
8000517e:	d7 03       	nop
80005180:	d7 03       	nop
80005182:	d7 03       	nop
80005184:	d7 03       	nop
80005186:	d7 03       	nop
80005188:	d7 03       	nop
8000518a:	d7 03       	nop
8000518c:	d7 03       	nop
8000518e:	d7 03       	nop
80005190:	d7 03       	nop
80005192:	d7 03       	nop
80005194:	d7 03       	nop
80005196:	d7 03       	nop
80005198:	d7 03       	nop
8000519a:	d7 03       	nop
8000519c:	d7 03       	nop
8000519e:	d7 03       	nop
800051a0:	d7 03       	nop
800051a2:	d7 03       	nop
800051a4:	d7 03       	nop
800051a6:	d7 03       	nop
800051a8:	d7 03       	nop
800051aa:	d7 03       	nop
800051ac:	d7 03       	nop
800051ae:	d7 03       	nop
800051b0:	d7 03       	nop
800051b2:	d7 03       	nop
800051b4:	d7 03       	nop
800051b6:	d7 03       	nop
800051b8:	d7 03       	nop
800051ba:	d7 03       	nop
800051bc:	d7 03       	nop
800051be:	d7 03       	nop
800051c0:	d7 03       	nop
800051c2:	d7 03       	nop
800051c4:	d7 03       	nop
800051c6:	d7 03       	nop
800051c8:	d7 03       	nop
800051ca:	d7 03       	nop
800051cc:	d7 03       	nop
800051ce:	d7 03       	nop
800051d0:	d7 03       	nop
800051d2:	d7 03       	nop
800051d4:	d7 03       	nop
800051d6:	d7 03       	nop
800051d8:	d7 03       	nop
800051da:	d7 03       	nop
800051dc:	d7 03       	nop
800051de:	d7 03       	nop
800051e0:	d7 03       	nop
800051e2:	d7 03       	nop
800051e4:	d7 03       	nop
800051e6:	d7 03       	nop
800051e8:	d7 03       	nop
800051ea:	d7 03       	nop
800051ec:	d7 03       	nop
800051ee:	d7 03       	nop
800051f0:	d7 03       	nop
800051f2:	d7 03       	nop
800051f4:	d7 03       	nop
800051f6:	d7 03       	nop
800051f8:	d7 03       	nop
800051fa:	d7 03       	nop
800051fc:	d7 03       	nop
800051fe:	d7 03       	nop

Disassembly of section .fini:

80005200 <_fini>:
80005200:	eb cd 40 40 	pushm	r6,lr
80005204:	48 26       	lddpc	r6,8000520c <_fini+0xc>
80005206:	1e 26       	rsub	r6,pc
80005208:	c0 48       	rjmp	80005210 <_fini+0x10>
8000520a:	d7 03       	nop
8000520c:	80 00       	ld.sh	r0,r0[0x0]
8000520e:	51 ea       	stdsp	sp[0x78],r10
80005210:	fe b0 e7 3a 	rcall	80002084 <__do_global_dtors_aux>
80005214:	e3 cd 80 40 	ldm	sp++,r6,pc
