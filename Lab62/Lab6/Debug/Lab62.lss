
Lab62.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         0000a200  80002028  80002028  00002428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  8000c400  8000c400  0000c800  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  8000c600  8000c600  0000ca00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       000006a0  8000c618  8000c618  0000ca18  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  8 .ctors        00000008  00000008  8000ccb8  0000d408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .dtors        00000008  00000010  8000ccc0  0000d410  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .jcr          00000004  00000018  8000ccc8  0000d418  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got          00000000  0000001c  8000cccc  0000d41c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         00000510  0000001c  8000cccc  0000d41c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .bss          000002b8  00000548  00000548  00000000  2**2
                  ALLOC
 14 .heap         0000e800  00000800  00000800  00000000  2**0
                  ALLOC
 15 .comment      00000030  00000000  00000000  0000d92c  2**0
                  CONTENTS, READONLY
 16 .debug_aranges 000010b8  00000000  00000000  0000d960  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_pubnames 00001e1e  00000000  00000000  0000ea18  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_info   00027992  00000000  00000000  00010836  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_abbrev 00005cf8  00000000  00000000  000381c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_line   000127d7  00000000  00000000  0003dec0  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_frame  00002d7c  00000000  00000000  00050698  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_str    00005256  00000000  00000000  00053414  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_loc    0000a708  00000000  00000000  0005866a  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_macinfo 010d22c1  00000000  00000000  00062d72  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 26 .debug_ranges 00001118  00000000  00000000  01135033  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	20 28       	sub	r8,2

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

8000200c <_init>:
8000200c:	eb cd 40 40 	pushm	r6,lr
80002010:	48 26       	lddpc	r6,80002018 <_init+0xc>
80002012:	1e 26       	rsub	r6,pc
80002014:	c0 48       	rjmp	8000201c <_init+0x10>
80002016:	d7 03       	nop
80002018:	80 00       	ld.sh	r0,r0[0x0]
8000201a:	1f f6       	ld.ub	r6,pc[0x7]
8000201c:	c5 6c       	rcall	800020c8 <frame_dummy>
8000201e:	e0 a0 50 fb 	rcall	8000c214 <__do_global_ctors_aux>
80002022:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002028 <_stext>:
80002028:	30 07       	mov	r7,0
8000202a:	e0 7a 00 00 	mov	r10,65536
8000202e:	5b fa       	cp.w	r10,-1
80002030:	f4 0d 17 10 	movne	sp,r10
80002034:	49 4b       	lddpc	r11,80002084 <_stext+0x5c>
80002036:	30 8c       	mov	r12,8
80002038:	18 3b       	cp.w	r11,r12
8000203a:	c0 70       	breq	80002048 <_stext+0x20>
8000203c:	e0 6a 05 30 	mov	r10,1328
80002040:	b7 09       	ld.d	r8,r11++
80002042:	b9 28       	st.d	r12++,r8
80002044:	14 3c       	cp.w	r12,r10
80002046:	cf d5       	brlt	80002040 <_stext+0x18>
80002048:	e0 6a 08 00 	mov	r10,2048
8000204c:	e0 6c 05 30 	mov	r12,1328
80002050:	30 08       	mov	r8,0
80002052:	30 09       	mov	r9,0
80002054:	b9 28       	st.d	r12++,r8
80002056:	14 3c       	cp.w	r12,r10
80002058:	cf e5       	brlt	80002054 <_stext+0x2c>
8000205a:	e0 a0 15 d9 	rcall	80004c0c <_init_startup>
8000205e:	48 bc       	lddpc	r12,80002088 <_stext+0x60>
80002060:	e0 a0 24 b2 	rcall	800069c4 <atexit>
80002064:	cd 4f       	rcall	8000200c <_init>
80002066:	1a 9c       	mov	r12,sp
80002068:	30 0b       	mov	r11,0
8000206a:	e0 a0 29 1d 	rcall	800072a4 <_init_argv>
8000206e:	5b fc       	cp.w	r12,-1
80002070:	f9 bc 00 00 	moveq	r12,0
80002074:	f9 ba 00 00 	moveq	r10,0
80002078:	14 1d       	sub	sp,r10
8000207a:	e0 a0 0f 27 	rcall	80003ec8 <main>
8000207e:	e0 a0 24 ab 	rcall	800069d4 <exit>
80002082:	d7 03       	nop
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	cc b8       	rjmp	8000221c <dip204_init+0x114>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	c6 00       	breq	8000214a <dip204_init+0x42>

8000208c <__do_global_dtors_aux>:
8000208c:	d4 21       	pushm	r4-r7,lr
8000208e:	e0 68 05 48 	mov	r8,1352
80002092:	11 89       	ld.ub	r9,r8[0x0]
80002094:	30 08       	mov	r8,0
80002096:	f0 09 18 00 	cp.b	r9,r8
8000209a:	c1 61       	brne	800020c6 <__do_global_dtors_aux+0x3a>
8000209c:	31 08       	mov	r8,16
8000209e:	31 46       	mov	r6,20
800020a0:	10 95       	mov	r5,r8
800020a2:	10 16       	sub	r6,r8
800020a4:	e0 67 05 4c 	mov	r7,1356
800020a8:	a3 46       	asr	r6,0x2
800020aa:	20 16       	sub	r6,1
800020ac:	c0 68       	rjmp	800020b8 <__do_global_dtors_aux+0x2c>
800020ae:	2f f8       	sub	r8,-1
800020b0:	8f 08       	st.w	r7[0x0],r8
800020b2:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020b6:	5d 18       	icall	r8
800020b8:	6e 08       	ld.w	r8,r7[0x0]
800020ba:	0c 38       	cp.w	r8,r6
800020bc:	cf 93       	brcs	800020ae <__do_global_dtors_aux+0x22>
800020be:	30 19       	mov	r9,1
800020c0:	e0 68 05 48 	mov	r8,1352
800020c4:	b0 89       	st.b	r8[0x0],r9
800020c6:	d8 22       	popm	r4-r7,pc

800020c8 <frame_dummy>:
800020c8:	d4 01       	pushm	lr
800020ca:	31 8c       	mov	r12,24
800020cc:	78 08       	ld.w	r8,r12[0x0]
800020ce:	58 08       	cp.w	r8,0
800020d0:	c0 50       	breq	800020da <frame_dummy+0x12>
800020d2:	48 38       	lddpc	r8,800020dc <frame_dummy+0x14>
800020d4:	58 08       	cp.w	r8,0
800020d6:	c0 20       	breq	800020da <frame_dummy+0x12>
800020d8:	5d 18       	icall	r8
800020da:	d8 02       	popm	pc
800020dc:	00 00       	add	r0,r0
	...

800020e0 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern bool sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
800020e0:	eb cd 40 80 	pushm	r7,lr
800020e4:	1a 97       	mov	r7,sp
	}
#endif

	switch (CONFIG_SYSCLK_SOURCE) {
	case SYSCLK_SRC_RCSYS:
		return OSC_SLOW_NOMINAL_HZ;
800020e6:	e0 78 c2 00 	mov	r8,115200

	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
800020ea:	10 9c       	mov	r12,r8
800020ec:	e3 cd 80 80 	ldm	sp++,r7,pc

800020f0 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
800020f0:	eb cd 40 80 	pushm	r7,lr
800020f4:	1a 97       	mov	r7,sp
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_CPU_DIV;
800020f6:	f0 1f 00 04 	mcall	80002104 <sysclk_get_cpu_hz+0x14>
800020fa:	18 98       	mov	r8,r12
}
800020fc:	10 9c       	mov	r12,r8
800020fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002102:	00 00       	add	r0,r0
80002104:	80 00       	ld.sh	r0,r0[0x0]
80002106:	20 e0       	sub	r0,14

80002108 <dip204_init>:


/****************************** global functions *****************************/

void dip204_init(backlight_options option, bool backlight_on)
{
80002108:	eb cd 40 8f 	pushm	r0-r3,r7,lr
8000210c:	1a 97       	mov	r7,sp
8000210e:	fa cd 01 ac 	sub	sp,sp,428
80002112:	ef 4c fe b8 	st.w	r7[-328],r12
80002116:	16 98       	mov	r8,r11
80002118:	ef 68 fe b4 	st.b	r7[-332],r8
  pwm_opt_t pwm_opt;  // pwm option config

  if (option == backlight_PWM)
8000211c:	ee f8 fe b8 	ld.w	r8,r7[-328]
80002120:	58 18       	cp.w	r8,1
80002122:	c6 41       	brne	800021ea <dip204_init+0xe2>
  {
    channel_id = DIP204_PWM_CHANNEL;
80002124:	fe f9 0a 84 	ld.w	r9,pc[2692]
80002128:	30 68       	mov	r8,6
8000212a:	93 08       	st.w	r9[0x0],r8
    gpio_enable_module_pin(DIP204_PWM_PIN, DIP204_PWM_FUNCTION);
8000212c:	30 2b       	mov	r11,2
8000212e:	33 2c       	mov	r12,50
80002130:	f0 1f 02 9f 	mcall	80002bac <dip204_init+0xaa4>

    // PWM controller configuration
    pwm_opt.diva=0;
80002134:	30 08       	mov	r8,0
80002136:	ef 48 ff 14 	st.w	r7[-236],r8
    pwm_opt.divb=0;
8000213a:	30 08       	mov	r8,0
8000213c:	ef 48 ff 10 	st.w	r7[-240],r8
    pwm_opt.prea=0;
80002140:	30 08       	mov	r8,0
80002142:	ef 48 ff 1c 	st.w	r7[-228],r8
    pwm_opt.preb=0;
80002146:	30 08       	mov	r8,0
80002148:	ef 48 ff 18 	st.w	r7[-232],r8

    pwm_init(&pwm_opt);
8000214c:	ee c8 00 f0 	sub	r8,r7,240
80002150:	10 9c       	mov	r12,r8
80002152:	f0 1f 02 98 	mcall	80002bb0 <dip204_init+0xaa8>
    pwm_duty = (backlight_on) ? DIP204_PERIOD_MAX - 1 : 1;
80002156:	ef 39 fe b4 	ld.ub	r9,r7[-332]
8000215a:	30 08       	mov	r8,0
8000215c:	f0 09 18 00 	cp.b	r9,r8
80002160:	c0 30       	breq	80002166 <dip204_init+0x5e>
80002162:	33 18       	mov	r8,49
80002164:	c0 28       	rjmp	80002168 <dip204_init+0x60>
80002166:	30 18       	mov	r8,1
80002168:	fe f9 0a 4c 	ld.w	r9,pc[2636]
8000216c:	b2 08       	st.h	r9[0x0],r8
    pwm_channel.CMR.calg = PWM_MODE_LEFT_ALIGNED;   // channel mode
8000216e:	fe fa 0a 4a 	ld.w	r10,pc[2634]
80002172:	74 08       	ld.w	r8,r10[0x0]
80002174:	30 09       	mov	r9,0
80002176:	f1 d9 d1 01 	bfins	r8,r9,0x8,0x1
8000217a:	95 08       	st.w	r10[0x0],r8
    pwm_channel.CMR.cpol = PWM_POLARITY_LOW;   // channel polarity
8000217c:	fe fa 0a 3c 	ld.w	r10,pc[2620]
80002180:	74 08       	ld.w	r8,r10[0x0]
80002182:	30 09       	mov	r9,0
80002184:	f1 d9 d1 21 	bfins	r8,r9,0x9,0x1
80002188:	95 08       	st.w	r10[0x0],r8
    pwm_channel.CMR.cpd = PWM_UPDATE_PERIOD;   // not used the first time
8000218a:	fe fa 0a 2e 	ld.w	r10,pc[2606]
8000218e:	74 08       	ld.w	r8,r10[0x0]
80002190:	30 19       	mov	r9,1
80002192:	f1 d9 d1 41 	bfins	r8,r9,0xa,0x1
80002196:	95 08       	st.w	r10[0x0],r8
    pwm_channel.CMR.cpre = AVR32_PWM_CPRE_MCK_DIV_256;   // channel prescaler
80002198:	fe fa 0a 20 	ld.w	r10,pc[2592]
8000219c:	74 08       	ld.w	r8,r10[0x0]
8000219e:	30 89       	mov	r9,8
800021a0:	f1 d9 d0 04 	bfins	r8,r9,0x0,0x4
800021a4:	95 08       	st.w	r10[0x0],r8
    pwm_channel.cdty = pwm_duty;  // channel duty cycle, should be < CPRD
800021a6:	fe f8 0a 0e 	ld.w	r8,pc[2574]
800021aa:	90 08       	ld.sh	r8,r8[0x0]
800021ac:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800021b0:	fe f8 0a 08 	ld.w	r8,pc[2568]
800021b4:	91 19       	st.w	r8[0x4],r9
    pwm_channel.cprd = DIP204_PERIOD_MAX;  // channel period
800021b6:	fe f9 0a 02 	ld.w	r9,pc[2562]
800021ba:	33 28       	mov	r8,50
800021bc:	93 28       	st.w	r9[0x8],r8
    pwm_channel.cupd = 0;  // channel update is not used here.
800021be:	fe f9 09 fa 	ld.w	r9,pc[2554]
800021c2:	30 08       	mov	r8,0
800021c4:	93 48       	st.w	r9[0x10],r8

    pwm_channel_init(channel_id, &pwm_channel);
800021c6:	fe f8 09 e2 	ld.w	r8,pc[2530]
800021ca:	70 08       	ld.w	r8,r8[0x0]
800021cc:	fe fb 09 ec 	ld.w	r11,pc[2540]
800021d0:	10 9c       	mov	r12,r8
800021d2:	f0 1f 02 7b 	mcall	80002bbc <dip204_init+0xab4>
    // start PWM
    pwm_start_channels(1 << channel_id);
800021d6:	fe f8 09 d2 	ld.w	r8,pc[2514]
800021da:	70 09       	ld.w	r9,r8[0x0]
800021dc:	30 18       	mov	r8,1
800021de:	f0 09 09 48 	lsl	r8,r8,r9
800021e2:	10 9c       	mov	r12,r8
800021e4:	f0 1f 02 77 	mcall	80002bc0 <dip204_init+0xab8>
800021e8:	c0 e8       	rjmp	80002204 <dip204_init+0xfc>
  }
  else
  {
    if (backlight_on)
800021ea:	ef 39 fe b4 	ld.ub	r9,r7[-332]
800021ee:	30 08       	mov	r8,0
800021f0:	f0 09 18 00 	cp.b	r9,r8
800021f4:	c0 50       	breq	800021fe <dip204_init+0xf6>
    {
      gpio_clr_gpio_pin(DIP204_BACKLIGHT_PIN);
800021f6:	33 2c       	mov	r12,50
800021f8:	f0 1f 02 73 	mcall	80002bc4 <dip204_init+0xabc>
800021fc:	c0 48       	rjmp	80002204 <dip204_init+0xfc>
    }
    else
    {
      gpio_set_gpio_pin(DIP204_BACKLIGHT_PIN);
800021fe:	33 2c       	mov	r12,50
80002200:	f0 1f 02 72 	mcall	80002bc8 <dip204_init+0xac0>
    }
  }
  // delay for power on
  delay_ms(20);
80002204:	f0 1f 02 72 	mcall	80002bcc <dip204_init+0xac4>
80002208:	18 99       	mov	r9,r12
8000220a:	31 48       	mov	r8,20
8000220c:	ef 48 ff 24 	st.w	r7[-220],r8
80002210:	ef 49 ff 20 	st.w	r7[-224],r9
80002214:	ee f8 ff 24 	ld.w	r8,r7[-220]
80002218:	ef 48 ff 2c 	st.w	r7[-212],r8
8000221c:	ee f8 ff 20 	ld.w	r8,r7[-224]
80002220:	ef 48 ff 28 	st.w	r7[-216],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002224:	ee f0 ff 2c 	ld.w	r0,r7[-212]
80002228:	30 01       	mov	r1,0
8000222a:	ee f2 ff 28 	ld.w	r2,r7[-216]
8000222e:	30 03       	mov	r3,0
80002230:	e2 02 02 49 	mul	r9,r1,r2
80002234:	e6 00 02 48 	mul	r8,r3,r0
80002238:	10 09       	add	r9,r8
8000223a:	e0 02 06 4a 	mulu.d	r10,r0,r2
8000223e:	16 09       	add	r9,r11
80002240:	12 9b       	mov	r11,r9
80002242:	e0 68 03 e7 	mov	r8,999
80002246:	30 09       	mov	r9,0
80002248:	10 0a       	add	r10,r8
8000224a:	f6 09 00 4b 	adc	r11,r11,r9
8000224e:	e0 68 03 e8 	mov	r8,1000
80002252:	30 09       	mov	r9,0
80002254:	f0 1f 02 5f 	mcall	80002bd0 <dip204_init+0xac8>
80002258:	14 98       	mov	r8,r10
8000225a:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000225c:	ef 48 ff 34 	st.w	r7[-204],r8
80002260:	ee c8 01 44 	sub	r8,r7,324
80002264:	ef 48 ff 30 	st.w	r7[-208],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002268:	e1 b8 00 42 	mfsr	r8,0x108
8000226c:	10 99       	mov	r9,r8
8000226e:	ee f8 ff 30 	ld.w	r8,r7[-208]
80002272:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002274:	ee f8 ff 30 	ld.w	r8,r7[-208]
80002278:	70 09       	ld.w	r9,r8[0x0]
8000227a:	ee f8 ff 34 	ld.w	r8,r7[-204]
8000227e:	10 09       	add	r9,r8
80002280:	ee f8 ff 30 	ld.w	r8,r7[-208]
80002284:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002286:	ee f9 ff 30 	ld.w	r9,r7[-208]
8000228a:	30 08       	mov	r8,0
8000228c:	f3 68 00 08 	st.b	r9[8],r8
80002290:	ee c8 01 44 	sub	r8,r7,324
80002294:	ef 48 ff 38 	st.w	r7[-200],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002298:	e1 b8 00 42 	mfsr	r8,0x108
8000229c:	ef 48 ff 3c 	st.w	r7[-196],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800022a0:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022a4:	f1 39 00 08 	ld.ub	r9,r8[8]
800022a8:	30 28       	mov	r8,2
800022aa:	f0 09 18 00 	cp.b	r9,r8
800022ae:	c0 31       	brne	800022b4 <dip204_init+0x1ac>
    return false;
800022b0:	30 08       	mov	r8,0
800022b2:	c4 38       	rjmp	80002338 <dip204_init+0x230>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800022b4:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022b8:	f1 39 00 08 	ld.ub	r9,r8[8]
800022bc:	30 18       	mov	r8,1
800022be:	f0 09 18 00 	cp.b	r9,r8
800022c2:	c0 31       	brne	800022c8 <dip204_init+0x1c0>
    return true;
800022c4:	30 18       	mov	r8,1
800022c6:	c3 98       	rjmp	80002338 <dip204_init+0x230>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800022c8:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022cc:	70 09       	ld.w	r9,r8[0x0]
800022ce:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022d2:	70 18       	ld.w	r8,r8[0x4]
800022d4:	10 39       	cp.w	r9,r8
800022d6:	e0 88 00 1a 	brls	8000230a <dip204_init+0x202>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800022da:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022de:	70 09       	ld.w	r9,r8[0x0]
800022e0:	ee f8 ff 3c 	ld.w	r8,r7[-196]
800022e4:	12 38       	cp.w	r8,r9
800022e6:	c1 02       	brcc	80002306 <dip204_init+0x1fe>
800022e8:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022ec:	70 19       	ld.w	r9,r8[0x4]
800022ee:	ee f8 ff 3c 	ld.w	r8,r7[-196]
800022f2:	12 38       	cp.w	r8,r9
800022f4:	e0 88 00 09 	brls	80002306 <dip204_init+0x1fe>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800022f8:	ee f9 ff 38 	ld.w	r9,r7[-200]
800022fc:	30 18       	mov	r8,1
800022fe:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002302:	30 18       	mov	r8,1
80002304:	c1 a8       	rjmp	80002338 <dip204_init+0x230>
    }
    return false;
80002306:	30 08       	mov	r8,0
80002308:	c1 88       	rjmp	80002338 <dip204_init+0x230>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000230a:	ee f8 ff 38 	ld.w	r8,r7[-200]
8000230e:	70 09       	ld.w	r9,r8[0x0]
80002310:	ee f8 ff 3c 	ld.w	r8,r7[-196]
80002314:	12 38       	cp.w	r8,r9
80002316:	c0 93       	brcs	80002328 <dip204_init+0x220>
80002318:	ee f8 ff 38 	ld.w	r8,r7[-200]
8000231c:	70 19       	ld.w	r9,r8[0x4]
8000231e:	ee f8 ff 3c 	ld.w	r8,r7[-196]
80002322:	12 38       	cp.w	r8,r9
80002324:	e0 88 00 09 	brls	80002336 <dip204_init+0x22e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002328:	ee f9 ff 38 	ld.w	r9,r7[-200]
8000232c:	30 18       	mov	r8,1
8000232e:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002332:	30 18       	mov	r8,1
80002334:	c0 28       	rjmp	80002338 <dip204_init+0x230>
    }
    return false;
80002336:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002338:	58 08       	cp.w	r8,0
8000233a:	ca b0       	breq	80002290 <dip204_init+0x188>
  // select the LCD chip
  dip204_select();
8000233c:	f0 1f 02 26 	mcall	80002bd4 <dip204_init+0xacc>
  // Send Command Start Byte
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002340:	e0 6c 00 f8 	mov	r12,248
80002344:	f0 1f 02 25 	mcall	80002bd8 <dip204_init+0xad0>
  // Send "extended Function Set" Command  (RE=1)
  dip204_write_byte(0x34);
80002348:	33 4c       	mov	r12,52
8000234a:	f0 1f 02 24 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
8000234e:	f0 1f 02 20 	mcall	80002bcc <dip204_init+0xac4>
80002352:	18 99       	mov	r9,r12
80002354:	30 18       	mov	r8,1
80002356:	ef 48 ff 44 	st.w	r7[-188],r8
8000235a:	ef 49 ff 40 	st.w	r7[-192],r9
8000235e:	ee f8 ff 44 	ld.w	r8,r7[-188]
80002362:	ef 48 ff 4c 	st.w	r7[-180],r8
80002366:	ee f8 ff 40 	ld.w	r8,r7[-192]
8000236a:	ef 48 ff 48 	st.w	r7[-184],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000236e:	ee fc ff 4c 	ld.w	r12,r7[-180]
80002372:	ef 4c fe 60 	st.w	r7[-416],r12
80002376:	30 0b       	mov	r11,0
80002378:	ef 4b fe 5c 	st.w	r7[-420],r11
8000237c:	ee fa ff 48 	ld.w	r10,r7[-184]
80002380:	ef 4a fe 58 	st.w	r7[-424],r10
80002384:	30 09       	mov	r9,0
80002386:	ef 49 fe 54 	st.w	r7[-428],r9
8000238a:	ee f9 fe 5c 	ld.w	r9,r7[-420]
8000238e:	ee f8 fe 58 	ld.w	r8,r7[-424]
80002392:	b1 39       	mul	r9,r8
80002394:	ee f8 fe 54 	ld.w	r8,r7[-428]
80002398:	ee fc fe 60 	ld.w	r12,r7[-416]
8000239c:	b9 38       	mul	r8,r12
8000239e:	10 09       	add	r9,r8
800023a0:	ee f8 fe 60 	ld.w	r8,r7[-416]
800023a4:	ee fc fe 58 	ld.w	r12,r7[-424]
800023a8:	f0 0c 06 4a 	mulu.d	r10,r8,r12
800023ac:	16 09       	add	r9,r11
800023ae:	12 9b       	mov	r11,r9
800023b0:	e0 68 03 e7 	mov	r8,999
800023b4:	30 09       	mov	r9,0
800023b6:	10 0a       	add	r10,r8
800023b8:	f6 09 00 4b 	adc	r11,r11,r9
800023bc:	e0 68 03 e8 	mov	r8,1000
800023c0:	30 09       	mov	r9,0
800023c2:	f0 1f 02 04 	mcall	80002bd0 <dip204_init+0xac8>
800023c6:	14 98       	mov	r8,r10
800023c8:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
800023ca:	ef 48 ff 54 	st.w	r7[-172],r8
800023ce:	ee c8 01 38 	sub	r8,r7,312
800023d2:	ef 48 ff 50 	st.w	r7[-176],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800023d6:	e1 b8 00 42 	mfsr	r8,0x108
800023da:	10 99       	mov	r9,r8
800023dc:	ee f8 ff 50 	ld.w	r8,r7[-176]
800023e0:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800023e2:	ee f8 ff 50 	ld.w	r8,r7[-176]
800023e6:	70 09       	ld.w	r9,r8[0x0]
800023e8:	ee f8 ff 54 	ld.w	r8,r7[-172]
800023ec:	10 09       	add	r9,r8
800023ee:	ee f8 ff 50 	ld.w	r8,r7[-176]
800023f2:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800023f4:	ee f9 ff 50 	ld.w	r9,r7[-176]
800023f8:	30 08       	mov	r8,0
800023fa:	f3 68 00 08 	st.b	r9[8],r8
800023fe:	ee c8 01 38 	sub	r8,r7,312
80002402:	ef 48 ff 58 	st.w	r7[-168],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002406:	e1 b8 00 42 	mfsr	r8,0x108
8000240a:	ef 48 ff 5c 	st.w	r7[-164],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000240e:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002412:	f1 39 00 08 	ld.ub	r9,r8[8]
80002416:	30 28       	mov	r8,2
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c0 31       	brne	80002422 <dip204_init+0x31a>
    return false;
8000241e:	30 08       	mov	r8,0
80002420:	c4 38       	rjmp	800024a6 <dip204_init+0x39e>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002422:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002426:	f1 39 00 08 	ld.ub	r9,r8[8]
8000242a:	30 18       	mov	r8,1
8000242c:	f0 09 18 00 	cp.b	r9,r8
80002430:	c0 31       	brne	80002436 <dip204_init+0x32e>
    return true;
80002432:	30 18       	mov	r8,1
80002434:	c3 98       	rjmp	800024a6 <dip204_init+0x39e>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002436:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000243a:	70 09       	ld.w	r9,r8[0x0]
8000243c:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002440:	70 18       	ld.w	r8,r8[0x4]
80002442:	10 39       	cp.w	r9,r8
80002444:	e0 88 00 1a 	brls	80002478 <dip204_init+0x370>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002448:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000244c:	70 09       	ld.w	r9,r8[0x0]
8000244e:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002452:	12 38       	cp.w	r8,r9
80002454:	c1 02       	brcc	80002474 <dip204_init+0x36c>
80002456:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000245a:	70 19       	ld.w	r9,r8[0x4]
8000245c:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002460:	12 38       	cp.w	r8,r9
80002462:	e0 88 00 09 	brls	80002474 <dip204_init+0x36c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002466:	ee f9 ff 58 	ld.w	r9,r7[-168]
8000246a:	30 18       	mov	r8,1
8000246c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002470:	30 18       	mov	r8,1
80002472:	c1 a8       	rjmp	800024a6 <dip204_init+0x39e>
    }
    return false;
80002474:	30 08       	mov	r8,0
80002476:	c1 88       	rjmp	800024a6 <dip204_init+0x39e>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002478:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000247c:	70 09       	ld.w	r9,r8[0x0]
8000247e:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002482:	12 38       	cp.w	r8,r9
80002484:	c0 93       	brcs	80002496 <dip204_init+0x38e>
80002486:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000248a:	70 19       	ld.w	r9,r8[0x4]
8000248c:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002490:	12 38       	cp.w	r8,r9
80002492:	e0 88 00 09 	brls	800024a4 <dip204_init+0x39c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002496:	ee f9 ff 58 	ld.w	r9,r7[-168]
8000249a:	30 18       	mov	r8,1
8000249c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800024a0:	30 18       	mov	r8,1
800024a2:	c0 28       	rjmp	800024a6 <dip204_init+0x39e>
    }
    return false;
800024a4:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800024a6:	58 08       	cp.w	r8,0
800024a8:	ca b0       	breq	800023fe <dip204_init+0x2f6>
  // Send "Enter 4-Line Mode" Command
  dip204_write_byte(0x09);
800024aa:	30 9c       	mov	r12,9
800024ac:	f0 1f 01 cb 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
800024b0:	f0 1f 01 c7 	mcall	80002bcc <dip204_init+0xac4>
800024b4:	18 99       	mov	r9,r12
800024b6:	30 18       	mov	r8,1
800024b8:	ef 48 ff 64 	st.w	r7[-156],r8
800024bc:	ef 49 ff 60 	st.w	r7[-160],r9
800024c0:	ee f8 ff 64 	ld.w	r8,r7[-156]
800024c4:	ef 48 ff 6c 	st.w	r7[-148],r8
800024c8:	ee f8 ff 60 	ld.w	r8,r7[-160]
800024cc:	ef 48 ff 68 	st.w	r7[-152],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800024d0:	ee fb ff 6c 	ld.w	r11,r7[-148]
800024d4:	ef 4b fe 70 	st.w	r7[-400],r11
800024d8:	30 0a       	mov	r10,0
800024da:	ef 4a fe 6c 	st.w	r7[-404],r10
800024de:	ee f9 ff 68 	ld.w	r9,r7[-152]
800024e2:	ef 49 fe 68 	st.w	r7[-408],r9
800024e6:	30 08       	mov	r8,0
800024e8:	ef 48 fe 64 	st.w	r7[-412],r8
800024ec:	ee f9 fe 6c 	ld.w	r9,r7[-404]
800024f0:	ee fc fe 68 	ld.w	r12,r7[-408]
800024f4:	b9 39       	mul	r9,r12
800024f6:	ee f8 fe 64 	ld.w	r8,r7[-412]
800024fa:	ee fb fe 70 	ld.w	r11,r7[-400]
800024fe:	b7 38       	mul	r8,r11
80002500:	10 09       	add	r9,r8
80002502:	ee f8 fe 70 	ld.w	r8,r7[-400]
80002506:	ee fc fe 68 	ld.w	r12,r7[-408]
8000250a:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000250e:	16 09       	add	r9,r11
80002510:	12 9b       	mov	r11,r9
80002512:	e0 68 03 e7 	mov	r8,999
80002516:	30 09       	mov	r9,0
80002518:	10 0a       	add	r10,r8
8000251a:	f6 09 00 4b 	adc	r11,r11,r9
8000251e:	e0 68 03 e8 	mov	r8,1000
80002522:	30 09       	mov	r9,0
80002524:	f0 1f 01 ab 	mcall	80002bd0 <dip204_init+0xac8>
80002528:	14 98       	mov	r8,r10
8000252a:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000252c:	ef 48 ff 74 	st.w	r7[-140],r8
80002530:	ee c8 01 2c 	sub	r8,r7,300
80002534:	ef 48 ff 70 	st.w	r7[-144],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002538:	e1 b8 00 42 	mfsr	r8,0x108
8000253c:	10 99       	mov	r9,r8
8000253e:	ee f8 ff 70 	ld.w	r8,r7[-144]
80002542:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002544:	ee f8 ff 70 	ld.w	r8,r7[-144]
80002548:	70 09       	ld.w	r9,r8[0x0]
8000254a:	ee f8 ff 74 	ld.w	r8,r7[-140]
8000254e:	10 09       	add	r9,r8
80002550:	ee f8 ff 70 	ld.w	r8,r7[-144]
80002554:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002556:	ee f9 ff 70 	ld.w	r9,r7[-144]
8000255a:	30 08       	mov	r8,0
8000255c:	f3 68 00 08 	st.b	r9[8],r8
80002560:	ee c8 01 2c 	sub	r8,r7,300
80002564:	ef 48 ff 78 	st.w	r7[-136],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002568:	e1 b8 00 42 	mfsr	r8,0x108
8000256c:	ef 48 ff 7c 	st.w	r7[-132],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002570:	ee f8 ff 78 	ld.w	r8,r7[-136]
80002574:	f1 39 00 08 	ld.ub	r9,r8[8]
80002578:	30 28       	mov	r8,2
8000257a:	f0 09 18 00 	cp.b	r9,r8
8000257e:	c0 31       	brne	80002584 <dip204_init+0x47c>
    return false;
80002580:	30 08       	mov	r8,0
80002582:	c4 38       	rjmp	80002608 <dip204_init+0x500>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002584:	ee f8 ff 78 	ld.w	r8,r7[-136]
80002588:	f1 39 00 08 	ld.ub	r9,r8[8]
8000258c:	30 18       	mov	r8,1
8000258e:	f0 09 18 00 	cp.b	r9,r8
80002592:	c0 31       	brne	80002598 <dip204_init+0x490>
    return true;
80002594:	30 18       	mov	r8,1
80002596:	c3 98       	rjmp	80002608 <dip204_init+0x500>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002598:	ee f8 ff 78 	ld.w	r8,r7[-136]
8000259c:	70 09       	ld.w	r9,r8[0x0]
8000259e:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025a2:	70 18       	ld.w	r8,r8[0x4]
800025a4:	10 39       	cp.w	r9,r8
800025a6:	e0 88 00 1a 	brls	800025da <dip204_init+0x4d2>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800025aa:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025ae:	70 09       	ld.w	r9,r8[0x0]
800025b0:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025b4:	12 38       	cp.w	r8,r9
800025b6:	c1 02       	brcc	800025d6 <dip204_init+0x4ce>
800025b8:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025bc:	70 19       	ld.w	r9,r8[0x4]
800025be:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025c2:	12 38       	cp.w	r8,r9
800025c4:	e0 88 00 09 	brls	800025d6 <dip204_init+0x4ce>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800025c8:	ee f9 ff 78 	ld.w	r9,r7[-136]
800025cc:	30 18       	mov	r8,1
800025ce:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800025d2:	30 18       	mov	r8,1
800025d4:	c1 a8       	rjmp	80002608 <dip204_init+0x500>
    }
    return false;
800025d6:	30 08       	mov	r8,0
800025d8:	c1 88       	rjmp	80002608 <dip204_init+0x500>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800025da:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025de:	70 09       	ld.w	r9,r8[0x0]
800025e0:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025e4:	12 38       	cp.w	r8,r9
800025e6:	c0 93       	brcs	800025f8 <dip204_init+0x4f0>
800025e8:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025ec:	70 19       	ld.w	r9,r8[0x4]
800025ee:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025f2:	12 38       	cp.w	r8,r9
800025f4:	e0 88 00 09 	brls	80002606 <dip204_init+0x4fe>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800025f8:	ee f9 ff 78 	ld.w	r9,r7[-136]
800025fc:	30 18       	mov	r8,1
800025fe:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002602:	30 18       	mov	r8,1
80002604:	c0 28       	rjmp	80002608 <dip204_init+0x500>
    }
    return false;
80002606:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002608:	58 08       	cp.w	r8,0
8000260a:	ca b0       	breq	80002560 <dip204_init+0x458>
  // Send "Function Set" Command (RE=0)
  dip204_write_byte(0x30);
8000260c:	33 0c       	mov	r12,48
8000260e:	f0 1f 01 73 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
80002612:	f0 1f 01 6f 	mcall	80002bcc <dip204_init+0xac4>
80002616:	18 99       	mov	r9,r12
80002618:	30 18       	mov	r8,1
8000261a:	ef 48 ff 84 	st.w	r7[-124],r8
8000261e:	ef 49 ff 80 	st.w	r7[-128],r9
80002622:	ee f8 ff 84 	ld.w	r8,r7[-124]
80002626:	ef 48 ff 8c 	st.w	r7[-116],r8
8000262a:	ee f8 ff 80 	ld.w	r8,r7[-128]
8000262e:	ef 48 ff 88 	st.w	r7[-120],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002632:	ee fb ff 8c 	ld.w	r11,r7[-116]
80002636:	ef 4b fe 80 	st.w	r7[-384],r11
8000263a:	30 0a       	mov	r10,0
8000263c:	ef 4a fe 7c 	st.w	r7[-388],r10
80002640:	ee f9 ff 88 	ld.w	r9,r7[-120]
80002644:	ef 49 fe 78 	st.w	r7[-392],r9
80002648:	30 08       	mov	r8,0
8000264a:	ef 48 fe 74 	st.w	r7[-396],r8
8000264e:	ee f9 fe 7c 	ld.w	r9,r7[-388]
80002652:	ee fc fe 78 	ld.w	r12,r7[-392]
80002656:	b9 39       	mul	r9,r12
80002658:	ee f8 fe 74 	ld.w	r8,r7[-396]
8000265c:	ee fb fe 80 	ld.w	r11,r7[-384]
80002660:	b7 38       	mul	r8,r11
80002662:	10 09       	add	r9,r8
80002664:	ee f8 fe 80 	ld.w	r8,r7[-384]
80002668:	ee fc fe 78 	ld.w	r12,r7[-392]
8000266c:	f0 0c 06 4a 	mulu.d	r10,r8,r12
80002670:	16 09       	add	r9,r11
80002672:	12 9b       	mov	r11,r9
80002674:	e0 68 03 e7 	mov	r8,999
80002678:	30 09       	mov	r9,0
8000267a:	10 0a       	add	r10,r8
8000267c:	f6 09 00 4b 	adc	r11,r11,r9
80002680:	e0 68 03 e8 	mov	r8,1000
80002684:	30 09       	mov	r9,0
80002686:	f0 1f 01 53 	mcall	80002bd0 <dip204_init+0xac8>
8000268a:	14 98       	mov	r8,r10
8000268c:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000268e:	ef 48 ff 94 	st.w	r7[-108],r8
80002692:	ee c8 01 20 	sub	r8,r7,288
80002696:	ef 48 ff 90 	st.w	r7[-112],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000269a:	e1 b8 00 42 	mfsr	r8,0x108
8000269e:	10 99       	mov	r9,r8
800026a0:	ee f8 ff 90 	ld.w	r8,r7[-112]
800026a4:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800026a6:	ee f8 ff 90 	ld.w	r8,r7[-112]
800026aa:	70 09       	ld.w	r9,r8[0x0]
800026ac:	ee f8 ff 94 	ld.w	r8,r7[-108]
800026b0:	10 09       	add	r9,r8
800026b2:	ee f8 ff 90 	ld.w	r8,r7[-112]
800026b6:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800026b8:	ee f9 ff 90 	ld.w	r9,r7[-112]
800026bc:	30 08       	mov	r8,0
800026be:	f3 68 00 08 	st.b	r9[8],r8
800026c2:	ee c8 01 20 	sub	r8,r7,288
800026c6:	ef 48 ff 98 	st.w	r7[-104],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800026ca:	e1 b8 00 42 	mfsr	r8,0x108
800026ce:	ef 48 ff 9c 	st.w	r7[-100],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800026d2:	ee f8 ff 98 	ld.w	r8,r7[-104]
800026d6:	f1 39 00 08 	ld.ub	r9,r8[8]
800026da:	30 28       	mov	r8,2
800026dc:	f0 09 18 00 	cp.b	r9,r8
800026e0:	c0 31       	brne	800026e6 <dip204_init+0x5de>
    return false;
800026e2:	30 08       	mov	r8,0
800026e4:	c4 38       	rjmp	8000276a <dip204_init+0x662>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800026e6:	ee f8 ff 98 	ld.w	r8,r7[-104]
800026ea:	f1 39 00 08 	ld.ub	r9,r8[8]
800026ee:	30 18       	mov	r8,1
800026f0:	f0 09 18 00 	cp.b	r9,r8
800026f4:	c0 31       	brne	800026fa <dip204_init+0x5f2>
    return true;
800026f6:	30 18       	mov	r8,1
800026f8:	c3 98       	rjmp	8000276a <dip204_init+0x662>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800026fa:	ee f8 ff 98 	ld.w	r8,r7[-104]
800026fe:	70 09       	ld.w	r9,r8[0x0]
80002700:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002704:	70 18       	ld.w	r8,r8[0x4]
80002706:	10 39       	cp.w	r9,r8
80002708:	e0 88 00 1a 	brls	8000273c <dip204_init+0x634>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000270c:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002710:	70 08       	ld.w	r8,r8[0x0]
80002712:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002716:	10 39       	cp.w	r9,r8
80002718:	c1 02       	brcc	80002738 <dip204_init+0x630>
8000271a:	ee f8 ff 98 	ld.w	r8,r7[-104]
8000271e:	70 18       	ld.w	r8,r8[0x4]
80002720:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002724:	10 39       	cp.w	r9,r8
80002726:	e0 88 00 09 	brls	80002738 <dip204_init+0x630>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000272a:	ee f9 ff 98 	ld.w	r9,r7[-104]
8000272e:	30 18       	mov	r8,1
80002730:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002734:	30 18       	mov	r8,1
80002736:	c1 a8       	rjmp	8000276a <dip204_init+0x662>
    }
    return false;
80002738:	30 08       	mov	r8,0
8000273a:	c1 88       	rjmp	8000276a <dip204_init+0x662>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000273c:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002740:	70 08       	ld.w	r8,r8[0x0]
80002742:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002746:	10 39       	cp.w	r9,r8
80002748:	c0 93       	brcs	8000275a <dip204_init+0x652>
8000274a:	ee f8 ff 98 	ld.w	r8,r7[-104]
8000274e:	70 18       	ld.w	r8,r8[0x4]
80002750:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002754:	10 39       	cp.w	r9,r8
80002756:	e0 88 00 09 	brls	80002768 <dip204_init+0x660>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000275a:	ee f9 ff 98 	ld.w	r9,r7[-104]
8000275e:	30 18       	mov	r8,1
80002760:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002764:	30 18       	mov	r8,1
80002766:	c0 28       	rjmp	8000276a <dip204_init+0x662>
    }
    return false;
80002768:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
8000276a:	58 08       	cp.w	r8,0
8000276c:	ca b0       	breq	800026c2 <dip204_init+0x5ba>
  // Send "Display On Command: Display On, Cursor On, Blink On"
  dip204_write_byte(0x0F);
8000276e:	30 fc       	mov	r12,15
80002770:	f0 1f 01 1a 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
80002774:	f0 1f 01 16 	mcall	80002bcc <dip204_init+0xac4>
80002778:	18 98       	mov	r8,r12
8000277a:	30 19       	mov	r9,1
8000277c:	ef 49 ff a4 	st.w	r7[-92],r9
80002780:	ef 48 ff a0 	st.w	r7[-96],r8
80002784:	ee f8 ff a4 	ld.w	r8,r7[-92]
80002788:	ef 48 ff ac 	st.w	r7[-84],r8
8000278c:	ee f8 ff a0 	ld.w	r8,r7[-96]
80002790:	ef 48 ff a8 	st.w	r7[-88],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002794:	ee fb ff ac 	ld.w	r11,r7[-84]
80002798:	ef 4b fe 90 	st.w	r7[-368],r11
8000279c:	30 0a       	mov	r10,0
8000279e:	ef 4a fe 8c 	st.w	r7[-372],r10
800027a2:	ee f9 ff a8 	ld.w	r9,r7[-88]
800027a6:	ef 49 fe 88 	st.w	r7[-376],r9
800027aa:	30 08       	mov	r8,0
800027ac:	ef 48 fe 84 	st.w	r7[-380],r8
800027b0:	ee fa fe 8c 	ld.w	r10,r7[-372]
800027b4:	ee fc fe 88 	ld.w	r12,r7[-376]
800027b8:	b9 3a       	mul	r10,r12
800027ba:	ee f8 fe 84 	ld.w	r8,r7[-380]
800027be:	ee fb fe 90 	ld.w	r11,r7[-368]
800027c2:	b7 38       	mul	r8,r11
800027c4:	10 0a       	add	r10,r8
800027c6:	ee fc fe 90 	ld.w	r12,r7[-368]
800027ca:	ee fb fe 88 	ld.w	r11,r7[-376]
800027ce:	f8 0b 06 48 	mulu.d	r8,r12,r11
800027d2:	12 0a       	add	r10,r9
800027d4:	14 99       	mov	r9,r10
800027d6:	e0 6a 03 e7 	mov	r10,999
800027da:	30 0b       	mov	r11,0
800027dc:	f0 0a 00 0a 	add	r10,r8,r10
800027e0:	f2 0b 00 4b 	adc	r11,r9,r11
800027e4:	e0 68 03 e8 	mov	r8,1000
800027e8:	30 09       	mov	r9,0
800027ea:	f0 1f 00 fa 	mcall	80002bd0 <dip204_init+0xac8>
800027ee:	14 98       	mov	r8,r10
800027f0:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
800027f2:	ef 48 ff b4 	st.w	r7[-76],r8
800027f6:	ee c8 01 14 	sub	r8,r7,276
800027fa:	ef 48 ff b0 	st.w	r7[-80],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800027fe:	e1 b8 00 42 	mfsr	r8,0x108
80002802:	10 99       	mov	r9,r8
80002804:	ee f8 ff b0 	ld.w	r8,r7[-80]
80002808:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000280a:	ee f8 ff b0 	ld.w	r8,r7[-80]
8000280e:	70 09       	ld.w	r9,r8[0x0]
80002810:	ee f8 ff b4 	ld.w	r8,r7[-76]
80002814:	10 09       	add	r9,r8
80002816:	ee f8 ff b0 	ld.w	r8,r7[-80]
8000281a:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000281c:	ee f9 ff b0 	ld.w	r9,r7[-80]
80002820:	30 08       	mov	r8,0
80002822:	f3 68 00 08 	st.b	r9[8],r8
80002826:	ee c8 01 14 	sub	r8,r7,276
8000282a:	ef 48 ff b8 	st.w	r7[-72],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000282e:	e1 b8 00 42 	mfsr	r8,0x108
80002832:	ef 48 ff bc 	st.w	r7[-68],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002836:	ee f8 ff b8 	ld.w	r8,r7[-72]
8000283a:	f1 39 00 08 	ld.ub	r9,r8[8]
8000283e:	30 28       	mov	r8,2
80002840:	f0 09 18 00 	cp.b	r9,r8
80002844:	c0 31       	brne	8000284a <dip204_init+0x742>
    return false;
80002846:	30 08       	mov	r8,0
80002848:	c4 38       	rjmp	800028ce <dip204_init+0x7c6>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
8000284a:	ee f8 ff b8 	ld.w	r8,r7[-72]
8000284e:	f1 39 00 08 	ld.ub	r9,r8[8]
80002852:	30 18       	mov	r8,1
80002854:	f0 09 18 00 	cp.b	r9,r8
80002858:	c0 31       	brne	8000285e <dip204_init+0x756>
    return true;
8000285a:	30 18       	mov	r8,1
8000285c:	c3 98       	rjmp	800028ce <dip204_init+0x7c6>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000285e:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002862:	70 09       	ld.w	r9,r8[0x0]
80002864:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002868:	70 18       	ld.w	r8,r8[0x4]
8000286a:	10 39       	cp.w	r9,r8
8000286c:	e0 88 00 1a 	brls	800028a0 <dip204_init+0x798>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002870:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002874:	70 08       	ld.w	r8,r8[0x0]
80002876:	ee f9 ff bc 	ld.w	r9,r7[-68]
8000287a:	10 39       	cp.w	r9,r8
8000287c:	c1 02       	brcc	8000289c <dip204_init+0x794>
8000287e:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002882:	70 18       	ld.w	r8,r8[0x4]
80002884:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002888:	10 39       	cp.w	r9,r8
8000288a:	e0 88 00 09 	brls	8000289c <dip204_init+0x794>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000288e:	ee f9 ff b8 	ld.w	r9,r7[-72]
80002892:	30 18       	mov	r8,1
80002894:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002898:	30 18       	mov	r8,1
8000289a:	c1 a8       	rjmp	800028ce <dip204_init+0x7c6>
    }
    return false;
8000289c:	30 08       	mov	r8,0
8000289e:	c1 88       	rjmp	800028ce <dip204_init+0x7c6>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800028a0:	ee f8 ff b8 	ld.w	r8,r7[-72]
800028a4:	70 08       	ld.w	r8,r8[0x0]
800028a6:	ee f9 ff bc 	ld.w	r9,r7[-68]
800028aa:	10 39       	cp.w	r9,r8
800028ac:	c0 93       	brcs	800028be <dip204_init+0x7b6>
800028ae:	ee f8 ff b8 	ld.w	r8,r7[-72]
800028b2:	70 18       	ld.w	r8,r8[0x4]
800028b4:	ee f9 ff bc 	ld.w	r9,r7[-68]
800028b8:	10 39       	cp.w	r9,r8
800028ba:	e0 88 00 09 	brls	800028cc <dip204_init+0x7c4>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800028be:	ee f9 ff b8 	ld.w	r9,r7[-72]
800028c2:	30 18       	mov	r8,1
800028c4:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800028c8:	30 18       	mov	r8,1
800028ca:	c0 28       	rjmp	800028ce <dip204_init+0x7c6>
    }
    return false;
800028cc:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800028ce:	58 08       	cp.w	r8,0
800028d0:	ca b0       	breq	80002826 <dip204_init+0x71e>
  // Send "Display Clear" Command
  dip204_write_byte(0x01);
800028d2:	30 1c       	mov	r12,1
800028d4:	f0 1f 00 c1 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(5);
800028d8:	f0 1f 00 bd 	mcall	80002bcc <dip204_init+0xac4>
800028dc:	18 98       	mov	r8,r12
800028de:	30 59       	mov	r9,5
800028e0:	ef 49 ff c4 	st.w	r7[-60],r9
800028e4:	ef 48 ff c0 	st.w	r7[-64],r8
800028e8:	ee f8 ff c4 	ld.w	r8,r7[-60]
800028ec:	ef 48 ff cc 	st.w	r7[-52],r8
800028f0:	ee f8 ff c0 	ld.w	r8,r7[-64]
800028f4:	ef 48 ff c8 	st.w	r7[-56],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800028f8:	ee fa ff cc 	ld.w	r10,r7[-52]
800028fc:	ef 4a fe a0 	st.w	r7[-352],r10
80002900:	30 09       	mov	r9,0
80002902:	ef 49 fe 9c 	st.w	r7[-356],r9
80002906:	ee f8 ff c8 	ld.w	r8,r7[-56]
8000290a:	ef 48 fe 98 	st.w	r7[-360],r8
8000290e:	30 0c       	mov	r12,0
80002910:	ef 4c fe 94 	st.w	r7[-364],r12
80002914:	ee fa fe 9c 	ld.w	r10,r7[-356]
80002918:	ee fb fe 98 	ld.w	r11,r7[-360]
8000291c:	b7 3a       	mul	r10,r11
8000291e:	ee f8 fe 94 	ld.w	r8,r7[-364]
80002922:	ee f9 fe a0 	ld.w	r9,r7[-352]
80002926:	b3 38       	mul	r8,r9
80002928:	10 0a       	add	r10,r8
8000292a:	ee fc fe a0 	ld.w	r12,r7[-352]
8000292e:	ee fb fe 98 	ld.w	r11,r7[-360]
80002932:	f8 0b 06 48 	mulu.d	r8,r12,r11
80002936:	12 0a       	add	r10,r9
80002938:	14 99       	mov	r9,r10
8000293a:	e0 6a 03 e7 	mov	r10,999
8000293e:	30 0b       	mov	r11,0
80002940:	f0 0a 00 0a 	add	r10,r8,r10
80002944:	f2 0b 00 4b 	adc	r11,r9,r11
80002948:	e0 68 03 e8 	mov	r8,1000
8000294c:	30 09       	mov	r9,0
8000294e:	f0 1f 00 a1 	mcall	80002bd0 <dip204_init+0xac8>
80002952:	14 98       	mov	r8,r10
80002954:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002956:	ef 48 ff d4 	st.w	r7[-44],r8
8000295a:	ee c8 01 08 	sub	r8,r7,264
8000295e:	ef 48 ff d0 	st.w	r7[-48],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002962:	e1 b8 00 42 	mfsr	r8,0x108
80002966:	10 99       	mov	r9,r8
80002968:	ee f8 ff d0 	ld.w	r8,r7[-48]
8000296c:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000296e:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002972:	70 09       	ld.w	r9,r8[0x0]
80002974:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002978:	10 09       	add	r9,r8
8000297a:	ee f8 ff d0 	ld.w	r8,r7[-48]
8000297e:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002980:	ee f9 ff d0 	ld.w	r9,r7[-48]
80002984:	30 08       	mov	r8,0
80002986:	f3 68 00 08 	st.b	r9[8],r8
8000298a:	ee c8 01 08 	sub	r8,r7,264
8000298e:	ef 48 ff d8 	st.w	r7[-40],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002992:	e1 b8 00 42 	mfsr	r8,0x108
80002996:	ef 48 ff dc 	st.w	r7[-36],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000299a:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000299e:	f1 39 00 08 	ld.ub	r9,r8[8]
800029a2:	30 28       	mov	r8,2
800029a4:	f0 09 18 00 	cp.b	r9,r8
800029a8:	c0 31       	brne	800029ae <dip204_init+0x8a6>
    return false;
800029aa:	30 08       	mov	r8,0
800029ac:	c4 38       	rjmp	80002a32 <dip204_init+0x92a>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800029ae:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029b2:	f1 39 00 08 	ld.ub	r9,r8[8]
800029b6:	30 18       	mov	r8,1
800029b8:	f0 09 18 00 	cp.b	r9,r8
800029bc:	c0 31       	brne	800029c2 <dip204_init+0x8ba>
    return true;
800029be:	30 18       	mov	r8,1
800029c0:	c3 98       	rjmp	80002a32 <dip204_init+0x92a>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800029c2:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029c6:	70 09       	ld.w	r9,r8[0x0]
800029c8:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029cc:	70 18       	ld.w	r8,r8[0x4]
800029ce:	10 39       	cp.w	r9,r8
800029d0:	e0 88 00 1a 	brls	80002a04 <dip204_init+0x8fc>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800029d4:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029d8:	70 08       	ld.w	r8,r8[0x0]
800029da:	ee f9 ff dc 	ld.w	r9,r7[-36]
800029de:	10 39       	cp.w	r9,r8
800029e0:	c1 02       	brcc	80002a00 <dip204_init+0x8f8>
800029e2:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029e6:	70 18       	ld.w	r8,r8[0x4]
800029e8:	ee f9 ff dc 	ld.w	r9,r7[-36]
800029ec:	10 39       	cp.w	r9,r8
800029ee:	e0 88 00 09 	brls	80002a00 <dip204_init+0x8f8>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800029f2:	ee f9 ff d8 	ld.w	r9,r7[-40]
800029f6:	30 18       	mov	r8,1
800029f8:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800029fc:	30 18       	mov	r8,1
800029fe:	c1 a8       	rjmp	80002a32 <dip204_init+0x92a>
    }
    return false;
80002a00:	30 08       	mov	r8,0
80002a02:	c1 88       	rjmp	80002a32 <dip204_init+0x92a>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002a04:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002a08:	70 08       	ld.w	r8,r8[0x0]
80002a0a:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002a0e:	10 39       	cp.w	r9,r8
80002a10:	c0 93       	brcs	80002a22 <dip204_init+0x91a>
80002a12:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002a16:	70 18       	ld.w	r8,r8[0x4]
80002a18:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002a1c:	10 39       	cp.w	r9,r8
80002a1e:	e0 88 00 09 	brls	80002a30 <dip204_init+0x928>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002a22:	ee f9 ff d8 	ld.w	r9,r7[-40]
80002a26:	30 18       	mov	r8,1
80002a28:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002a2c:	30 18       	mov	r8,1
80002a2e:	c0 28       	rjmp	80002a32 <dip204_init+0x92a>
    }
    return false;
80002a30:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002a32:	58 08       	cp.w	r8,0
80002a34:	ca b0       	breq	8000298a <dip204_init+0x882>
  // Send "Entry Mode Set Command: Increment Mode, Entire Shift off"
  dip204_write_byte(0x06);
80002a36:	30 6c       	mov	r12,6
80002a38:	f0 1f 00 68 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
80002a3c:	f0 1f 00 64 	mcall	80002bcc <dip204_init+0xac4>
80002a40:	18 98       	mov	r8,r12
80002a42:	30 19       	mov	r9,1
80002a44:	ef 49 ff e4 	st.w	r7[-28],r9
80002a48:	ef 48 ff e0 	st.w	r7[-32],r8
80002a4c:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002a50:	ef 48 ff ec 	st.w	r7[-20],r8
80002a54:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002a58:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002a5c:	ee fa ff ec 	ld.w	r10,r7[-20]
80002a60:	ef 4a fe b0 	st.w	r7[-336],r10
80002a64:	30 09       	mov	r9,0
80002a66:	ef 49 fe ac 	st.w	r7[-340],r9
80002a6a:	ee f8 ff e8 	ld.w	r8,r7[-24]
80002a6e:	ef 48 fe a8 	st.w	r7[-344],r8
80002a72:	30 0c       	mov	r12,0
80002a74:	ef 4c fe a4 	st.w	r7[-348],r12
80002a78:	ee fa fe ac 	ld.w	r10,r7[-340]
80002a7c:	ee fb fe a8 	ld.w	r11,r7[-344]
80002a80:	b7 3a       	mul	r10,r11
80002a82:	ee f8 fe a4 	ld.w	r8,r7[-348]
80002a86:	ee f9 fe b0 	ld.w	r9,r7[-336]
80002a8a:	b3 38       	mul	r8,r9
80002a8c:	10 0a       	add	r10,r8
80002a8e:	ee fc fe b0 	ld.w	r12,r7[-336]
80002a92:	ee fb fe a8 	ld.w	r11,r7[-344]
80002a96:	f8 0b 06 48 	mulu.d	r8,r12,r11
80002a9a:	12 0a       	add	r10,r9
80002a9c:	14 99       	mov	r9,r10
80002a9e:	e0 6a 03 e7 	mov	r10,999
80002aa2:	30 0b       	mov	r11,0
80002aa4:	f0 0a 00 0a 	add	r10,r8,r10
80002aa8:	f2 0b 00 4b 	adc	r11,r9,r11
80002aac:	e0 68 03 e8 	mov	r8,1000
80002ab0:	30 09       	mov	r9,0
80002ab2:	f0 1f 00 48 	mcall	80002bd0 <dip204_init+0xac8>
80002ab6:	14 98       	mov	r8,r10
80002ab8:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002aba:	ef 48 ff f4 	st.w	r7[-12],r8
80002abe:	ee c8 00 fc 	sub	r8,r7,252
80002ac2:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002ac6:	e1 b8 00 42 	mfsr	r8,0x108
80002aca:	10 99       	mov	r9,r8
80002acc:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ad0:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002ad2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ad6:	70 09       	ld.w	r9,r8[0x0]
80002ad8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002adc:	10 09       	add	r9,r8
80002ade:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ae2:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002ae4:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002ae8:	30 08       	mov	r8,0
80002aea:	f3 68 00 08 	st.b	r9[8],r8
80002aee:	ee c8 00 fc 	sub	r8,r7,252
80002af2:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002af6:	e1 b8 00 42 	mfsr	r8,0x108
80002afa:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002afe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b02:	f1 39 00 08 	ld.ub	r9,r8[8]
80002b06:	30 28       	mov	r8,2
80002b08:	f0 09 18 00 	cp.b	r9,r8
80002b0c:	c0 31       	brne	80002b12 <dip204_init+0xa0a>
    return false;
80002b0e:	30 08       	mov	r8,0
80002b10:	c4 38       	rjmp	80002b96 <dip204_init+0xa8e>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002b12:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b16:	f1 39 00 08 	ld.ub	r9,r8[8]
80002b1a:	30 18       	mov	r8,1
80002b1c:	f0 09 18 00 	cp.b	r9,r8
80002b20:	c0 31       	brne	80002b26 <dip204_init+0xa1e>
    return true;
80002b22:	30 18       	mov	r8,1
80002b24:	c3 98       	rjmp	80002b96 <dip204_init+0xa8e>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002b26:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b2a:	70 09       	ld.w	r9,r8[0x0]
80002b2c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b30:	70 18       	ld.w	r8,r8[0x4]
80002b32:	10 39       	cp.w	r9,r8
80002b34:	e0 88 00 1a 	brls	80002b68 <dip204_init+0xa60>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002b38:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b3c:	70 08       	ld.w	r8,r8[0x0]
80002b3e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b42:	10 39       	cp.w	r9,r8
80002b44:	c1 02       	brcc	80002b64 <dip204_init+0xa5c>
80002b46:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b4a:	70 18       	ld.w	r8,r8[0x4]
80002b4c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b50:	10 39       	cp.w	r9,r8
80002b52:	e0 88 00 09 	brls	80002b64 <dip204_init+0xa5c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002b56:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002b5a:	30 18       	mov	r8,1
80002b5c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002b60:	30 18       	mov	r8,1
80002b62:	c1 a8       	rjmp	80002b96 <dip204_init+0xa8e>
    }
    return false;
80002b64:	30 08       	mov	r8,0
80002b66:	c1 88       	rjmp	80002b96 <dip204_init+0xa8e>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002b68:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b6c:	70 08       	ld.w	r8,r8[0x0]
80002b6e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b72:	10 39       	cp.w	r9,r8
80002b74:	c0 93       	brcs	80002b86 <dip204_init+0xa7e>
80002b76:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b7a:	70 18       	ld.w	r8,r8[0x4]
80002b7c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b80:	10 39       	cp.w	r9,r8
80002b82:	e0 88 00 09 	brls	80002b94 <dip204_init+0xa8c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002b86:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002b8a:	30 18       	mov	r8,1
80002b8c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002b90:	30 18       	mov	r8,1
80002b92:	c0 28       	rjmp	80002b96 <dip204_init+0xa8e>
    }
    return false;
80002b94:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002b96:	58 08       	cp.w	r8,0
80002b98:	ca b0       	breq	80002aee <dip204_init+0x9e6>
  dip204_wait_busy();
80002b9a:	f0 1f 00 11 	mcall	80002bdc <dip204_init+0xad4>
  // unselect chip
  dip204_unselect();
80002b9e:	f0 1f 00 11 	mcall	80002be0 <dip204_init+0xad8>
}
80002ba2:	29 5d       	sub	sp,-428
80002ba4:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
80002ba8:	00 00       	add	r0,r0
80002baa:	00 1c       	sub	r12,r0
80002bac:	80 00       	ld.sh	r0,r0[0x0]
80002bae:	40 58       	lddsp	r8,sp[0x14]
80002bb0:	80 00       	ld.sh	r0,r0[0x0]
80002bb2:	30 c0       	mov	r0,12
80002bb4:	00 00       	add	r0,r0
80002bb6:	05 50       	ld.sh	r0,--r2
80002bb8:	00 00       	add	r0,r0
80002bba:	05 54       	ld.sh	r4,--r2
80002bbc:	80 00       	ld.sh	r0,r0[0x0]
80002bbe:	31 54       	mov	r4,21
80002bc0:	80 00       	ld.sh	r0,r0[0x0]
80002bc2:	31 dc       	mov	r12,29
80002bc4:	80 00       	ld.sh	r0,r0[0x0]
80002bc6:	41 d0       	lddsp	r0,sp[0x74]
80002bc8:	80 00       	ld.sh	r0,r0[0x0]
80002bca:	41 68       	lddsp	r8,sp[0x58]
80002bcc:	80 00       	ld.sh	r0,r0[0x0]
80002bce:	20 f0       	sub	r0,15
80002bd0:	80 00       	ld.sh	r0,r0[0x0]
80002bd2:	67 60       	ld.w	r0,r3[0x58]
80002bd4:	80 00       	ld.sh	r0,r0[0x0]
80002bd6:	2f 50       	sub	r0,-11
80002bd8:	80 00       	ld.sh	r0,r0[0x0]
80002bda:	2f 80       	sub	r0,-8
80002bdc:	80 00       	ld.sh	r0,r0[0x0]
80002bde:	30 64       	mov	r4,6
80002be0:	80 00       	ld.sh	r0,r0[0x0]
80002be2:	2f 68       	sub	r8,-10

80002be4 <dip204_hide_cursor>:
  dip204_unselect();
}


void dip204_hide_cursor(void)
{
80002be4:	eb cd 40 80 	pushm	r7,lr
80002be8:	1a 97       	mov	r7,sp
  /* select the LCD chip */
  dip204_select();
80002bea:	f0 1f 00 08 	mcall	80002c08 <dip204_hide_cursor+0x24>
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002bee:	e0 6c 00 f8 	mov	r12,248
80002bf2:	f0 1f 00 07 	mcall	80002c0c <dip204_hide_cursor+0x28>
  /* Send "Display On Command: Display On, Cursor On, Blink On" */
  dip204_write_byte(0x0C);
80002bf6:	30 cc       	mov	r12,12
80002bf8:	f0 1f 00 05 	mcall	80002c0c <dip204_hide_cursor+0x28>
  dip204_wait_busy();
80002bfc:	f0 1f 00 05 	mcall	80002c10 <dip204_hide_cursor+0x2c>
  /* unselect chip */
  dip204_unselect();
80002c00:	f0 1f 00 05 	mcall	80002c14 <dip204_hide_cursor+0x30>
}
80002c04:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c08:	80 00       	ld.sh	r0,r0[0x0]
80002c0a:	2f 50       	sub	r0,-11
80002c0c:	80 00       	ld.sh	r0,r0[0x0]
80002c0e:	2f 80       	sub	r0,-8
80002c10:	80 00       	ld.sh	r0,r0[0x0]
80002c12:	30 64       	mov	r4,6
80002c14:	80 00       	ld.sh	r0,r0[0x0]
80002c16:	2f 68       	sub	r8,-10

80002c18 <dip204_set_cursor_position>:
  dip204_set_cursor_position(column, line);
}


void dip204_set_cursor_position(unsigned char column, unsigned char line)
{
80002c18:	eb cd 40 80 	pushm	r7,lr
80002c1c:	1a 97       	mov	r7,sp
80002c1e:	20 3d       	sub	sp,12
80002c20:	18 99       	mov	r9,r12
80002c22:	16 98       	mov	r8,r11
80002c24:	ef 69 ff f8 	st.b	r7[-8],r9
80002c28:	ef 68 ff f4 	st.b	r7[-12],r8
  unsigned char address = 0;
80002c2c:	30 08       	mov	r8,0
80002c2e:	ef 68 ff ff 	st.b	r7[-1],r8

  dip204_select();
80002c32:	f0 1f 00 18 	mcall	80002c90 <dip204_set_cursor_position+0x78>
  if ((column <= 20) && (line <= 4))
80002c36:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80002c3a:	31 48       	mov	r8,20
80002c3c:	f0 09 18 00 	cp.b	r9,r8
80002c40:	e0 8b 00 17 	brhi	80002c6e <dip204_set_cursor_position+0x56>
80002c44:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80002c48:	30 48       	mov	r8,4
80002c4a:	f0 09 18 00 	cp.b	r9,r8
80002c4e:	e0 8b 00 10 	brhi	80002c6e <dip204_set_cursor_position+0x56>
  {
    /* Calculate DDRAM address from line and row values */
    address = ( (line-1) * 32 ) + ( column-1 ) + 128;
80002c52:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002c56:	20 18       	sub	r8,1
80002c58:	5c 58       	castu.b	r8
80002c5a:	a5 78       	lsl	r8,0x5
80002c5c:	5c 58       	castu.b	r8
80002c5e:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80002c62:	f2 08 00 08 	add	r8,r9,r8
80002c66:	5c 58       	castu.b	r8
80002c68:	28 18       	sub	r8,-127
80002c6a:	ef 68 ff ff 	st.b	r7[-1],r8
  }
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002c6e:	e0 6c 00 f8 	mov	r12,248
80002c72:	f0 1f 00 09 	mcall	80002c94 <dip204_set_cursor_position+0x7c>
  /* Send Address lower Nibble */
  dip204_write_byte(address);
80002c76:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002c7a:	10 9c       	mov	r12,r8
80002c7c:	f0 1f 00 06 	mcall	80002c94 <dip204_set_cursor_position+0x7c>
  dip204_wait_busy();
80002c80:	f0 1f 00 06 	mcall	80002c98 <dip204_set_cursor_position+0x80>
  dip204_unselect();
80002c84:	f0 1f 00 06 	mcall	80002c9c <dip204_set_cursor_position+0x84>
}
80002c88:	2f dd       	sub	sp,-12
80002c8a:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c8e:	00 00       	add	r0,r0
80002c90:	80 00       	ld.sh	r0,r0[0x0]
80002c92:	2f 50       	sub	r0,-11
80002c94:	80 00       	ld.sh	r0,r0[0x0]
80002c96:	2f 80       	sub	r0,-8
80002c98:	80 00       	ld.sh	r0,r0[0x0]
80002c9a:	30 64       	mov	r4,6
80002c9c:	80 00       	ld.sh	r0,r0[0x0]
80002c9e:	2f 68       	sub	r8,-10

80002ca0 <dip204_clear_display>:


void dip204_clear_display(void)
{
80002ca0:	eb cd 40 8f 	pushm	r0-r3,r7,lr
80002ca4:	1a 97       	mov	r7,sp
80002ca6:	20 bd       	sub	sp,44
  dip204_select();
80002ca8:	f0 1f 00 57 	mcall	80002e04 <dip204_clear_display+0x164>
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002cac:	e0 6c 00 f8 	mov	r12,248
80002cb0:	f0 1f 00 56 	mcall	80002e08 <dip204_clear_display+0x168>
  /* Send Display Clear Command */
  dip204_write_byte(0x01);
80002cb4:	30 1c       	mov	r12,1
80002cb6:	f0 1f 00 55 	mcall	80002e08 <dip204_clear_display+0x168>
  /* Wait for command execution */
  delay_ms(4);
80002cba:	f0 1f 00 55 	mcall	80002e0c <dip204_clear_display+0x16c>
80002cbe:	18 98       	mov	r8,r12
80002cc0:	30 49       	mov	r9,4
80002cc2:	ef 49 ff e4 	st.w	r7[-28],r9
80002cc6:	ef 48 ff e0 	st.w	r7[-32],r8
80002cca:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002cce:	ef 48 ff ec 	st.w	r7[-20],r8
80002cd2:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002cd6:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002cda:	ee f0 ff ec 	ld.w	r0,r7[-20]
80002cde:	30 01       	mov	r1,0
80002ce0:	ee f2 ff e8 	ld.w	r2,r7[-24]
80002ce4:	30 03       	mov	r3,0
80002ce6:	e2 02 02 4a 	mul	r10,r1,r2
80002cea:	e6 00 02 48 	mul	r8,r3,r0
80002cee:	10 0a       	add	r10,r8
80002cf0:	e0 02 06 48 	mulu.d	r8,r0,r2
80002cf4:	12 0a       	add	r10,r9
80002cf6:	14 99       	mov	r9,r10
80002cf8:	e0 6a 03 e7 	mov	r10,999
80002cfc:	30 0b       	mov	r11,0
80002cfe:	f0 0a 00 0a 	add	r10,r8,r10
80002d02:	f2 0b 00 4b 	adc	r11,r9,r11
80002d06:	e0 68 03 e8 	mov	r8,1000
80002d0a:	30 09       	mov	r9,0
80002d0c:	f0 1f 00 41 	mcall	80002e10 <dip204_clear_display+0x170>
80002d10:	14 98       	mov	r8,r10
80002d12:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002d14:	ef 48 ff f4 	st.w	r7[-12],r8
80002d18:	ee c8 00 2c 	sub	r8,r7,44
80002d1c:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002d20:	e1 b8 00 42 	mfsr	r8,0x108
80002d24:	10 99       	mov	r9,r8
80002d26:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d2a:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002d2c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d30:	70 09       	ld.w	r9,r8[0x0]
80002d32:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002d36:	10 09       	add	r9,r8
80002d38:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d3c:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002d3e:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002d42:	30 08       	mov	r8,0
80002d44:	f3 68 00 08 	st.b	r9[8],r8
80002d48:	ee c8 00 2c 	sub	r8,r7,44
80002d4c:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002d50:	e1 b8 00 42 	mfsr	r8,0x108
80002d54:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002d58:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d5c:	f1 39 00 08 	ld.ub	r9,r8[8]
80002d60:	30 28       	mov	r8,2
80002d62:	f0 09 18 00 	cp.b	r9,r8
80002d66:	c0 31       	brne	80002d6c <dip204_clear_display+0xcc>
    return false;
80002d68:	30 08       	mov	r8,0
80002d6a:	c4 38       	rjmp	80002df0 <dip204_clear_display+0x150>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002d6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d70:	f1 39 00 08 	ld.ub	r9,r8[8]
80002d74:	30 18       	mov	r8,1
80002d76:	f0 09 18 00 	cp.b	r9,r8
80002d7a:	c0 31       	brne	80002d80 <dip204_clear_display+0xe0>
    return true;
80002d7c:	30 18       	mov	r8,1
80002d7e:	c3 98       	rjmp	80002df0 <dip204_clear_display+0x150>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002d80:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d84:	70 09       	ld.w	r9,r8[0x0]
80002d86:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d8a:	70 18       	ld.w	r8,r8[0x4]
80002d8c:	10 39       	cp.w	r9,r8
80002d8e:	e0 88 00 1a 	brls	80002dc2 <dip204_clear_display+0x122>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002d92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d96:	70 08       	ld.w	r8,r8[0x0]
80002d98:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002d9c:	10 39       	cp.w	r9,r8
80002d9e:	c1 02       	brcc	80002dbe <dip204_clear_display+0x11e>
80002da0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002da4:	70 18       	ld.w	r8,r8[0x4]
80002da6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002daa:	10 39       	cp.w	r9,r8
80002dac:	e0 88 00 09 	brls	80002dbe <dip204_clear_display+0x11e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002db0:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002db4:	30 18       	mov	r8,1
80002db6:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002dba:	30 18       	mov	r8,1
80002dbc:	c1 a8       	rjmp	80002df0 <dip204_clear_display+0x150>
    }
    return false;
80002dbe:	30 08       	mov	r8,0
80002dc0:	c1 88       	rjmp	80002df0 <dip204_clear_display+0x150>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002dc2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dc6:	70 08       	ld.w	r8,r8[0x0]
80002dc8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002dcc:	10 39       	cp.w	r9,r8
80002dce:	c0 93       	brcs	80002de0 <dip204_clear_display+0x140>
80002dd0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dd4:	70 18       	ld.w	r8,r8[0x4]
80002dd6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002dda:	10 39       	cp.w	r9,r8
80002ddc:	e0 88 00 09 	brls	80002dee <dip204_clear_display+0x14e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002de0:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002de4:	30 18       	mov	r8,1
80002de6:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002dea:	30 18       	mov	r8,1
80002dec:	c0 28       	rjmp	80002df0 <dip204_clear_display+0x150>
    }
    return false;
80002dee:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002df0:	58 08       	cp.w	r8,0
80002df2:	ca b0       	breq	80002d48 <dip204_clear_display+0xa8>
  dip204_wait_busy();
80002df4:	f0 1f 00 08 	mcall	80002e14 <dip204_clear_display+0x174>
  dip204_unselect();
80002df8:	f0 1f 00 08 	mcall	80002e18 <dip204_clear_display+0x178>
}
80002dfc:	2f 5d       	sub	sp,-44
80002dfe:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
80002e02:	00 00       	add	r0,r0
80002e04:	80 00       	ld.sh	r0,r0[0x0]
80002e06:	2f 50       	sub	r0,-11
80002e08:	80 00       	ld.sh	r0,r0[0x0]
80002e0a:	2f 80       	sub	r0,-8
80002e0c:	80 00       	ld.sh	r0,r0[0x0]
80002e0e:	20 f0       	sub	r0,15
80002e10:	80 00       	ld.sh	r0,r0[0x0]
80002e12:	67 60       	ld.w	r0,r3[0x58]
80002e14:	80 00       	ld.sh	r0,r0[0x0]
80002e16:	30 64       	mov	r4,6
80002e18:	80 00       	ld.sh	r0,r0[0x0]
80002e1a:	2f 68       	sub	r8,-10

80002e1c <dip204_write_string>:


void dip204_write_string(const char *string)
{
80002e1c:	eb cd 40 80 	pushm	r7,lr
80002e20:	1a 97       	mov	r7,sp
80002e22:	20 2d       	sub	sp,8
80002e24:	ef 4c ff f8 	st.w	r7[-8],r12
  unsigned char i=0;
80002e28:	30 08       	mov	r8,0
80002e2a:	ef 68 ff ff 	st.b	r7[-1],r8

  dip204_select();
80002e2e:	f0 1f 00 14 	mcall	80002e7c <dip204_write_string+0x60>
  /* for all chars in string */
  while(string[i]!=0)
80002e32:	c1 68       	rjmp	80002e5e <dip204_write_string+0x42>
  {
    /* Send Write Data Start Byte */
    dip204_write_byte(DIP204_WRITE_DATA);
80002e34:	e0 6c 00 fa 	mov	r12,250
80002e38:	f0 1f 00 12 	mcall	80002e80 <dip204_write_string+0x64>
    /* Send byte */
    dip204_write_byte(string[i]);
80002e3c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002e40:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002e44:	f2 08 00 08 	add	r8,r9,r8
80002e48:	11 88       	ld.ub	r8,r8[0x0]
80002e4a:	10 9c       	mov	r12,r8
80002e4c:	f0 1f 00 0d 	mcall	80002e80 <dip204_write_string+0x64>
    /* go to next char */
    i++;
80002e50:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002e54:	2f f8       	sub	r8,-1
80002e56:	ef 68 ff ff 	st.b	r7[-1],r8
    dip204_wait_busy();
80002e5a:	f0 1f 00 0b 	mcall	80002e84 <dip204_write_string+0x68>
{
  unsigned char i=0;

  dip204_select();
  /* for all chars in string */
  while(string[i]!=0)
80002e5e:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002e62:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002e66:	f2 08 00 08 	add	r8,r9,r8
80002e6a:	11 88       	ld.ub	r8,r8[0x0]
80002e6c:	58 08       	cp.w	r8,0
80002e6e:	ce 31       	brne	80002e34 <dip204_write_string+0x18>
    dip204_write_byte(string[i]);
    /* go to next char */
    i++;
    dip204_wait_busy();
  }
  dip204_unselect();
80002e70:	f0 1f 00 06 	mcall	80002e88 <dip204_write_string+0x6c>
}
80002e74:	2f ed       	sub	sp,-8
80002e76:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e7a:	00 00       	add	r0,r0
80002e7c:	80 00       	ld.sh	r0,r0[0x0]
80002e7e:	2f 50       	sub	r0,-11
80002e80:	80 00       	ld.sh	r0,r0[0x0]
80002e82:	2f 80       	sub	r0,-8
80002e84:	80 00       	ld.sh	r0,r0[0x0]
80002e86:	30 64       	mov	r4,6
80002e88:	80 00       	ld.sh	r0,r0[0x0]
80002e8a:	2f 68       	sub	r8,-10

80002e8c <dip204_printf_string>:


void dip204_printf_string(const char *format, ...)
{
80002e8c:	eb cd 40 80 	pushm	r7,lr
80002e90:	1a 97       	mov	r7,sp
80002e92:	20 9d       	sub	sp,36
80002e94:	ee c9 ff f8 	sub	r9,r7,-8
80002e98:	ef 4c ff dc 	st.w	r7[-36],r12
  va_list arg;
  char string[21];
  unsigned char i=0;
80002e9c:	30 08       	mov	r8,0
80002e9e:	ef 68 ff ff 	st.b	r7[-1],r8

  va_start(arg, format);
80002ea2:	f2 c8 00 00 	sub	r8,r9,0
80002ea6:	ef 48 ff f8 	st.w	r7[-8],r8
  i = vsprintf(string, format, arg);
80002eaa:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002eae:	ee c8 00 20 	sub	r8,r7,32
80002eb2:	12 9a       	mov	r10,r9
80002eb4:	ee fb ff dc 	ld.w	r11,r7[-36]
80002eb8:	10 9c       	mov	r12,r8
80002eba:	f0 1f 00 21 	mcall	80002f3c <dip204_printf_string+0xb0>
80002ebe:	18 98       	mov	r8,r12
80002ec0:	ef 68 ff ff 	st.b	r7[-1],r8
  while (i < sizeof(string) - 1) string[i++] = '\0';
80002ec4:	c0 d8       	rjmp	80002ede <dip204_printf_string+0x52>
80002ec6:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002eca:	ee 08 00 09 	add	r9,r7,r8
80002ece:	30 08       	mov	r8,0
80002ed0:	f3 68 ff e0 	st.b	r9[-32],r8
80002ed4:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002ed8:	2f f8       	sub	r8,-1
80002eda:	ef 68 ff ff 	st.b	r7[-1],r8
80002ede:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80002ee2:	31 38       	mov	r8,19
80002ee4:	f0 09 18 00 	cp.b	r9,r8
80002ee8:	fe 98 ff ef 	brls	80002ec6 <dip204_printf_string+0x3a>
  va_end(arg);
  dip204_select();
80002eec:	f0 1f 00 15 	mcall	80002f40 <dip204_printf_string+0xb4>
  /* for all chars in string */
  i = 0;
80002ef0:	30 08       	mov	r8,0
80002ef2:	ef 68 ff ff 	st.b	r7[-1],r8
  while(string[i]!='\0')
80002ef6:	c1 58       	rjmp	80002f20 <dip204_printf_string+0x94>
  {
    /* Send Write Data Start Byte */
    dip204_write_byte(DIP204_WRITE_DATA);
80002ef8:	e0 6c 00 fa 	mov	r12,250
80002efc:	f0 1f 00 12 	mcall	80002f44 <dip204_printf_string+0xb8>
    /* Send byte */
    dip204_write_byte(string[i]);
80002f00:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002f04:	ee 08 00 08 	add	r8,r7,r8
80002f08:	f1 38 ff e0 	ld.ub	r8,r8[-32]
80002f0c:	10 9c       	mov	r12,r8
80002f0e:	f0 1f 00 0e 	mcall	80002f44 <dip204_printf_string+0xb8>
    /* go to next char */
    i++;
80002f12:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002f16:	2f f8       	sub	r8,-1
80002f18:	ef 68 ff ff 	st.b	r7[-1],r8
    dip204_wait_busy();
80002f1c:	f0 1f 00 0b 	mcall	80002f48 <dip204_printf_string+0xbc>
  while (i < sizeof(string) - 1) string[i++] = '\0';
  va_end(arg);
  dip204_select();
  /* for all chars in string */
  i = 0;
  while(string[i]!='\0')
80002f20:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002f24:	ee 08 00 08 	add	r8,r7,r8
80002f28:	f1 38 ff e0 	ld.ub	r8,r8[-32]
80002f2c:	58 08       	cp.w	r8,0
80002f2e:	ce 51       	brne	80002ef8 <dip204_printf_string+0x6c>
    dip204_write_byte(string[i]);
    /* go to next char */
    i++;
    dip204_wait_busy();
  }
  dip204_unselect();
80002f30:	f0 1f 00 07 	mcall	80002f4c <dip204_printf_string+0xc0>
}
80002f34:	2f 7d       	sub	sp,-36
80002f36:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f3a:	00 00       	add	r0,r0
80002f3c:	80 00       	ld.sh	r0,r0[0x0]
80002f3e:	73 bc       	ld.w	r12,r9[0x6c]
80002f40:	80 00       	ld.sh	r0,r0[0x0]
80002f42:	2f 50       	sub	r0,-11
80002f44:	80 00       	ld.sh	r0,r0[0x0]
80002f46:	2f 80       	sub	r0,-8
80002f48:	80 00       	ld.sh	r0,r0[0x0]
80002f4a:	30 64       	mov	r4,6
80002f4c:	80 00       	ld.sh	r0,r0[0x0]
80002f4e:	2f 68       	sub	r8,-10

80002f50 <dip204_select>:

/*! \brief function to select the LCD
 *
 */
static void dip204_select(void)
{
80002f50:	eb cd 40 80 	pushm	r7,lr
80002f54:	1a 97       	mov	r7,sp
  spi_selectChip(DIP204_SPI, DIP204_SPI_NPCS);
80002f56:	30 2b       	mov	r11,2
80002f58:	fe 7c 28 00 	mov	r12,-55296
80002f5c:	f0 1f 00 02 	mcall	80002f64 <dip204_select+0x14>
}
80002f60:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f64:	80 00       	ld.sh	r0,r0[0x0]
80002f66:	33 82       	mov	r2,56

80002f68 <dip204_unselect>:

/*! \brief function to unselect the LCD
 *
 */
static void dip204_unselect(void)
{
80002f68:	eb cd 40 80 	pushm	r7,lr
80002f6c:	1a 97       	mov	r7,sp
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_unselectChip(DIP204_SPI, DIP204_SPI_NPCS);
80002f6e:	30 2b       	mov	r11,2
80002f70:	fe 7c 28 00 	mov	r12,-55296
80002f74:	f0 1f 00 02 	mcall	80002f7c <dip204_unselect+0x14>
  Assert( SPI_OK==spi_status );
}
80002f78:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f7c:	80 00       	ld.sh	r0,r0[0x0]
80002f7e:	34 1a       	mov	r10,65

80002f80 <dip204_write_byte>:
 *
 *  \param  byte  Input. byte to write to the LCD (D7 .. D0)
 *
 */
static void dip204_write_byte(unsigned char byte)
{
80002f80:	eb cd 40 80 	pushm	r7,lr
80002f84:	1a 97       	mov	r7,sp
80002f86:	20 3d       	sub	sp,12
80002f88:	18 98       	mov	r8,r12
80002f8a:	ef 68 ff f4 	st.b	r7[-12],r8
  unsigned char reverse;

  switch (byte)
80002f8e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002f92:	f0 c8 00 f8 	sub	r8,r8,248
80002f96:	58 68       	cp.w	r8,6
80002f98:	e0 8b 00 10 	brhi	80002fb8 <dip204_write_byte+0x38>
80002f9c:	30 19       	mov	r9,1
80002f9e:	f2 08 09 48 	lsl	r8,r9,r8
80002fa2:	e2 18 00 55 	andl	r8,0x55,COH
80002fa6:	c0 90       	breq	80002fb8 <dip204_write_byte+0x38>
    {
      /* send D7 to D0 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, byte);
80002fa8:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002fac:	10 9b       	mov	r11,r8
80002fae:	fe 7c 28 00 	mov	r12,-55296
80002fb2:	f0 1f 00 15 	mcall	80003004 <dip204_write_byte+0x84>
      Assert( SPI_OK==spi_status );
      break;
80002fb6:	c2 48       	rjmp	80002ffe <dip204_write_byte+0x7e>
    }
    /* LSB first for all other data */
    default:
    {
      /* reverse byte */
      reverse = bit_reverse8(byte);
80002fb8:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002fbc:	ef 48 ff fc 	st.w	r7[-4],r8
80002fc0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fc4:	5c 98       	brev	r8
80002fc6:	ef 48 ff fc 	st.w	r7[-4],r8
80002fca:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fce:	b9 88       	lsr	r8,0x18
80002fd0:	ef 68 ff fb 	st.b	r7[-5],r8
      /* send D0 to D3 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, (reverse & 0xF0));
80002fd4:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002fd8:	e2 18 00 f0 	andl	r8,0xf0,COH
80002fdc:	10 9b       	mov	r11,r8
80002fde:	fe 7c 28 00 	mov	r12,-55296
80002fe2:	f0 1f 00 09 	mcall	80003004 <dip204_write_byte+0x84>
      Assert( SPI_OK==spi_status );
      /* send D4 to D7 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, ((reverse << 4) & 0xF0));
80002fe6:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002fea:	a5 68       	lsl	r8,0x4
80002fec:	5c 88       	casts.h	r8
80002fee:	5c 78       	castu.h	r8
80002ff0:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002ff4:	10 9b       	mov	r11,r8
80002ff6:	fe 7c 28 00 	mov	r12,-55296
80002ffa:	f0 1f 00 03 	mcall	80003004 <dip204_write_byte+0x84>
      Assert( SPI_OK==spi_status );
      break;
    }
  }
}
80002ffe:	2f dd       	sub	sp,-12
80003000:	e3 cd 80 80 	ldm	sp++,r7,pc
80003004:	80 00       	ld.sh	r0,r0[0x0]
80003006:	36 22       	mov	r2,98

80003008 <dip204_read_byte>:
 *
 *  \param  byte  Input. byte read from the LCD (D7 .. D0)
 *
 */
static void dip204_read_byte(unsigned char *byte)
{
80003008:	eb cd 40 80 	pushm	r7,lr
8000300c:	1a 97       	mov	r7,sp
8000300e:	20 3d       	sub	sp,12
80003010:	ef 4c ff f4 	st.w	r7[-12],r12
  unsigned short reverse = 0x00;
80003014:	30 08       	mov	r8,0
80003016:	ef 58 ff fa 	st.h	r7[-6],r8

  /* dummy write */
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_write(DIP204_SPI, 0x00);
8000301a:	30 0b       	mov	r11,0
8000301c:	fe 7c 28 00 	mov	r12,-55296
80003020:	f0 1f 00 0f 	mcall	8000305c <dip204_read_byte+0x54>
  Assert( SPI_OK==spi_status );
  /* read RSR register */
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_read(DIP204_SPI, &reverse);
80003024:	ee c8 00 06 	sub	r8,r7,6
80003028:	10 9b       	mov	r11,r8
8000302a:	fe 7c 28 00 	mov	r12,-55296
8000302e:	f0 1f 00 0d 	mcall	80003060 <dip204_read_byte+0x58>
  Assert( SPI_OK==spi_status );
  /* Revert received byte (issued LSB first by the LCD) */
  *byte = bit_reverse8(reverse);
80003032:	ef 08 ff fa 	ld.sh	r8,r7[-6]
80003036:	5c 58       	castu.b	r8
80003038:	ef 48 ff fc 	st.w	r7[-4],r8
8000303c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003040:	5c 98       	brev	r8
80003042:	ef 48 ff fc 	st.w	r7[-4],r8
80003046:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000304a:	b9 88       	lsr	r8,0x18
8000304c:	5c 58       	castu.b	r8
8000304e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003052:	b2 88       	st.b	r9[0x0],r8
}
80003054:	2f dd       	sub	sp,-12
80003056:	e3 cd 80 80 	ldm	sp++,r7,pc
8000305a:	00 00       	add	r0,r0
8000305c:	80 00       	ld.sh	r0,r0[0x0]
8000305e:	36 22       	mov	r2,98
80003060:	80 00       	ld.sh	r0,r0[0x0]
80003062:	36 7a       	mov	r10,103

80003064 <dip204_wait_busy>:

/*! \brief function to wait for LCD becomes not busy
 *
 */
static void dip204_wait_busy(void)
{
80003064:	eb cd 40 80 	pushm	r7,lr
80003068:	1a 97       	mov	r7,sp
8000306a:	20 1d       	sub	sp,4
  unsigned char status = 0x00;
8000306c:	30 08       	mov	r8,0
8000306e:	ef 68 ff ff 	st.b	r7[-1],r8

  /* send read command to LCD */
  dip204_write_byte(DIP204_READ_COMMAND);
80003072:	e0 6c 00 fc 	mov	r12,252
80003076:	f0 1f 00 09 	mcall	80003098 <dip204_wait_busy+0x34>
  /* read next byte */
  do {
  dip204_read_byte(&status);
8000307a:	ee c8 00 01 	sub	r8,r7,1
8000307e:	10 9c       	mov	r12,r8
80003080:	f0 1f 00 07 	mcall	8000309c <dip204_wait_busy+0x38>
  /* keep D7 to know status */
  }while (status & 0x80);
80003084:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003088:	10 99       	mov	r9,r8
8000308a:	30 08       	mov	r8,0
8000308c:	f0 09 18 00 	cp.b	r9,r8
80003090:	cf 55       	brlt	8000307a <dip204_wait_busy+0x16>
}
80003092:	2f fd       	sub	sp,-4
80003094:	e3 cd 80 80 	ldm	sp++,r7,pc
80003098:	80 00       	ld.sh	r0,r0[0x0]
8000309a:	2f 80       	sub	r0,-8
8000309c:	80 00       	ld.sh	r0,r0[0x0]
8000309e:	30 08       	mov	r8,0

800030a0 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
800030a0:	eb cd 40 80 	pushm	r7,lr
800030a4:	1a 97       	mov	r7,sp
800030a6:	20 1d       	sub	sp,4
800030a8:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
800030ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030b0:	e6 18 00 01 	andh	r8,0x1,COH
800030b4:	5f 08       	sreq	r8
800030b6:	5c 58       	castu.b	r8
}
800030b8:	10 9c       	mov	r12,r8
800030ba:	2f fd       	sub	sp,-4
800030bc:	e3 cd 80 80 	ldm	sp++,r7,pc

800030c0 <pwm_init>:
#include "compiler.h"
#include "pwm.h"


int pwm_init(const pwm_opt_t *opt)
{
800030c0:	eb cd 40 80 	pushm	r7,lr
800030c4:	1a 97       	mov	r7,sp
800030c6:	20 3d       	sub	sp,12
800030c8:	ef 4c ff f4 	st.w	r7[-12],r12
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
800030cc:	fe 78 30 00 	mov	r8,-53248
800030d0:	ef 48 ff f8 	st.w	r7[-8],r8
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
800030d4:	e1 b8 00 00 	mfsr	r8,0x0
800030d8:	10 9c       	mov	r12,r8
800030da:	f0 1f 00 1e 	mcall	80003150 <pwm_init+0x90>
800030de:	18 98       	mov	r8,r12
800030e0:	ef 68 ff ff 	st.b	r7[-1],r8

  if (opt == 0 ) // Null pointer.
800030e4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800030e8:	58 08       	cp.w	r8,0
800030ea:	c0 31       	brne	800030f0 <pwm_init+0x30>
    return PWM_INVALID_INPUT;
800030ec:	30 18       	mov	r8,1
800030ee:	c2 c8       	rjmp	80003146 <pwm_init+0x86>

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
800030f0:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800030f4:	30 08       	mov	r8,0
800030f6:	f0 09 18 00 	cp.b	r9,r8
800030fa:	c0 20       	breq	800030fe <pwm_init+0x3e>
800030fc:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
800030fe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003102:	37 f9       	mov	r9,127
80003104:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
80003106:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000310a:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
8000310c:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003110:	30 08       	mov	r8,0
80003112:	f0 09 18 00 	cp.b	r9,r8
80003116:	c0 20       	breq	8000311a <pwm_init+0x5a>
80003118:	d5 03       	csrf	0x10

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
8000311a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000311e:	70 19       	ld.w	r9,r8[0x4]
    ((opt->divb)<<AVR32_PWM_DIVB_OFFSET) |
80003120:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003124:	70 08       	ld.w	r8,r8[0x0]
80003126:	b1 68       	lsl	r8,0x10
80003128:	10 49       	or	r9,r8
    ((opt->prea)<<AVR32_PWM_PREA_OFFSET) |
8000312a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000312e:	70 38       	ld.w	r8,r8[0xc]
80003130:	a9 68       	lsl	r8,0x8
80003132:	10 49       	or	r9,r8
    ((opt->preb)<<AVR32_PWM_PREB_OFFSET)
80003134:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003138:	70 28       	ld.w	r8,r8[0x8]
8000313a:	b9 68       	lsl	r8,0x18
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
8000313c:	10 49       	or	r9,r8
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
8000313e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003142:	91 09       	st.w	r8[0x0],r9
    ((opt->divb)<<AVR32_PWM_DIVB_OFFSET) |
    ((opt->prea)<<AVR32_PWM_PREA_OFFSET) |
    ((opt->preb)<<AVR32_PWM_PREB_OFFSET)
    ;

  return PWM_SUCCESS;
80003144:	30 08       	mov	r8,0
}
80003146:	10 9c       	mov	r12,r8
80003148:	2f dd       	sub	sp,-12
8000314a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000314e:	00 00       	add	r0,r0
80003150:	80 00       	ld.sh	r0,r0[0x0]
80003152:	30 a0       	mov	r0,10

80003154 <pwm_channel_init>:


int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
80003154:	eb cd 40 80 	pushm	r7,lr
80003158:	1a 97       	mov	r7,sp
8000315a:	20 3d       	sub	sp,12
8000315c:	ef 4c ff f8 	st.w	r7[-8],r12
80003160:	ef 4b ff f4 	st.w	r7[-12],r11
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
80003164:	fe 78 30 00 	mov	r8,-53248
80003168:	ef 48 ff fc 	st.w	r7[-4],r8

  if (pwm_channel == 0) // Null pointer.
8000316c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003170:	58 08       	cp.w	r8,0
80003172:	c0 31       	brne	80003178 <pwm_channel_init+0x24>
    return PWM_INVALID_ARGUMENT;
80003174:	30 18       	mov	r8,1
80003176:	c2 f8       	rjmp	800031d4 <pwm_channel_init+0x80>
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
80003178:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000317c:	58 68       	cp.w	r8,6
8000317e:	e0 88 00 04 	brls	80003186 <pwm_channel_init+0x32>
    return PWM_INVALID_INPUT;
80003182:	30 18       	mov	r8,1
80003184:	c2 88       	rjmp	800031d4 <pwm_channel_init+0x80>

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
80003186:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000318a:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000318e:	72 09       	ld.w	r9,r9[0x0]
80003190:	ee fa ff fc 	ld.w	r10,r7[-4]
80003194:	2f 08       	sub	r8,-16
80003196:	a5 78       	lsl	r8,0x5
80003198:	f4 08 00 08 	add	r8,r10,r8
8000319c:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
8000319e:	ee f8 ff f8 	ld.w	r8,r7[-8]
800031a2:	ee f9 ff f4 	ld.w	r9,r7[-12]
800031a6:	72 19       	ld.w	r9,r9[0x4]
800031a8:	ee fa ff fc 	ld.w	r10,r7[-4]
800031ac:	a5 78       	lsl	r8,0x5
800031ae:	f4 08 00 08 	add	r8,r10,r8
800031b2:	f0 c8 fd fc 	sub	r8,r8,-516
800031b6:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
800031b8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800031bc:	ee f9 ff f4 	ld.w	r9,r7[-12]
800031c0:	72 29       	ld.w	r9,r9[0x8]
800031c2:	ee fa ff fc 	ld.w	r10,r7[-4]
800031c6:	a5 78       	lsl	r8,0x5
800031c8:	f4 08 00 08 	add	r8,r10,r8
800031cc:	f0 c8 fd f8 	sub	r8,r8,-520
800031d0:	91 09       	st.w	r8[0x0],r9

  return PWM_SUCCESS;
800031d2:	30 08       	mov	r8,0
}
800031d4:	10 9c       	mov	r12,r8
800031d6:	2f dd       	sub	sp,-12
800031d8:	e3 cd 80 80 	ldm	sp++,r7,pc

800031dc <pwm_start_channels>:


int pwm_start_channels(unsigned long channels_bitmask)
{
800031dc:	eb cd 40 80 	pushm	r7,lr
800031e0:	1a 97       	mov	r7,sp
800031e2:	20 1d       	sub	sp,4
800031e4:	ef 4c ff fc 	st.w	r7[-4],r12
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
800031e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031ec:	e0 18 ff 80 	andl	r8,0xff80
800031f0:	c0 30       	breq	800031f6 <pwm_start_channels+0x1a>
    return PWM_INVALID_INPUT;
800031f2:	30 18       	mov	r8,1
800031f4:	c0 78       	rjmp	80003202 <pwm_start_channels+0x26>

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
800031f6:	fe 78 30 00 	mov	r8,-53248
800031fa:	ee f9 ff fc 	ld.w	r9,r7[-4]
800031fe:	91 19       	st.w	r8[0x4],r9

  return PWM_SUCCESS;
80003200:	30 08       	mov	r8,0
}
80003202:	10 9c       	mov	r12,r8
80003204:	2f fd       	sub	sp,-4
80003206:	e3 cd 80 80 	ldm	sp++,r7,pc

8000320a <getBaudDiv>:
/** The SPI mutex. */
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
8000320a:	eb cd 40 80 	pushm	r7,lr
8000320e:	1a 97       	mov	r7,sp
80003210:	20 3d       	sub	sp,12
80003212:	ef 4c ff f8 	st.w	r7[-8],r12
80003216:	ef 4b ff f4 	st.w	r7[-12],r11
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
8000321a:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000321e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003222:	f2 08 00 08 	add	r8,r9,r8
80003226:	20 18       	sub	r8,1
80003228:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000322c:	f0 09 0d 08 	divu	r8,r8,r9
80003230:	ef 48 ff fc 	st.w	r7[-4],r8

	if (baudDiv <= 0 || baudDiv > 255) {
80003234:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003238:	58 08       	cp.w	r8,0
8000323a:	c0 70       	breq	80003248 <getBaudDiv+0x3e>
8000323c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003240:	e0 48 00 ff 	cp.w	r8,255
80003244:	e0 88 00 04 	brls	8000324c <getBaudDiv+0x42>
		return -1;
80003248:	3f f8       	mov	r8,-1
8000324a:	c0 48       	rjmp	80003252 <getBaudDiv+0x48>
	}

	return baudDiv;
8000324c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003250:	5c 88       	casts.h	r8
}
80003252:	10 9c       	mov	r12,r8
80003254:	2f dd       	sub	sp,-12
80003256:	e3 cd 80 80 	ldm	sp++,r7,pc

8000325a <spi_initMaster>:
	return SPI_OK;
}

spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
8000325a:	eb cd 40 80 	pushm	r7,lr
8000325e:	1a 97       	mov	r7,sp
80003260:	20 3d       	sub	sp,12
80003262:	ef 4c ff f8 	st.w	r7[-8],r12
80003266:	ef 4b ff f4 	st.w	r7[-12],r11
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
8000326a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000326e:	f1 39 00 0d 	ld.ub	r9,r8[13]
80003272:	30 18       	mov	r8,1
80003274:	f0 09 18 00 	cp.b	r9,r8
80003278:	e0 88 00 04 	brls	80003280 <spi_initMaster+0x26>
		return SPI_ERROR_ARGUMENT;
8000327c:	30 28       	mov	r8,2
8000327e:	c3 48       	rjmp	800032e6 <spi_initMaster+0x8c>
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80003280:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003284:	e0 69 00 80 	mov	r9,128
80003288:	91 09       	st.w	r8[0x0],r9

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
8000328a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000328e:	70 18       	ld.w	r8,r8[0x4]
80003290:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.mstr = 1;
80003294:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003298:	30 19       	mov	r9,1
8000329a:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
8000329e:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800032a2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800032a6:	f1 38 00 0d 	ld.ub	r8,r8[13]
800032aa:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800032ae:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800032b2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032b6:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
800032ba:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.llb = 0;
800032be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032c2:	30 09       	mov	r9,0
800032c4:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
800032c8:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800032cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032d0:	30 f9       	mov	r9,15
800032d2:	f1 d9 d2 04 	bfins	r8,r9,0x10,0x4
800032d6:	ef 48 ff fc 	st.w	r7[-4],r8
	spi->mr = u_avr32_spi_mr.mr;
800032da:	ee f9 ff fc 	ld.w	r9,r7[-4]
800032de:	ee f8 ff f8 	ld.w	r8,r7[-8]
800032e2:	91 19       	st.w	r8[0x4],r9

	return SPI_OK;
800032e4:	30 08       	mov	r8,0
}
800032e6:	10 9c       	mov	r12,r8
800032e8:	2f dd       	sub	sp,-12
800032ea:	e3 cd 80 80 	ldm	sp++,r7,pc

800032ee <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800032ee:	eb cd 40 80 	pushm	r7,lr
800032f2:	1a 97       	mov	r7,sp
800032f4:	20 5d       	sub	sp,20
800032f6:	ef 4c ff f8 	st.w	r7[-8],r12
800032fa:	12 98       	mov	r8,r9
800032fc:	16 99       	mov	r9,r11
800032fe:	ef 69 ff f4 	st.b	r7[-12],r9
80003302:	14 99       	mov	r9,r10
80003304:	ef 69 ff f0 	st.b	r7[-16],r9
80003308:	ef 68 ff ec 	st.b	r7[-20],r8
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
8000330c:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80003310:	30 18       	mov	r8,1
80003312:	f0 09 18 00 	cp.b	r9,r8
80003316:	e0 8b 00 09 	brhi	80003328 <spi_selectionMode+0x3a>
8000331a:	ef 39 ff f0 	ld.ub	r9,r7[-16]
8000331e:	30 18       	mov	r8,1
80003320:	f0 09 18 00 	cp.b	r9,r8
80003324:	e0 88 00 04 	brls	8000332c <spi_selectionMode+0x3e>
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
80003328:	30 28       	mov	r8,2
8000332a:	c2 88       	rjmp	8000337a <spi_selectionMode+0x8c>
	}

	u_avr32_spi_mr.mr = spi->mr;
8000332c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003330:	70 18       	ld.w	r8,r8[0x4]
80003332:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.ps = variable_ps;
80003336:	ef 38 ff f4 	ld.ub	r8,r7[-12]
8000333a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000333e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003342:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003346:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
8000334a:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
8000334e:	ef 38 ff f0 	ld.ub	r8,r7[-16]
80003352:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003356:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000335a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000335e:	f1 d9 d0 41 	bfins	r8,r9,0x2,0x1
80003362:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.dlybcs = delay;
80003366:	ef 38 ff ec 	ld.ub	r8,r7[-20]
8000336a:	ef 68 ff fc 	st.b	r7[-4],r8
	spi->mr = u_avr32_spi_mr.mr;
8000336e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003372:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003376:	91 19       	st.w	r8[0x4],r9

	return SPI_OK;
80003378:	30 08       	mov	r8,0
}
8000337a:	10 9c       	mov	r12,r8
8000337c:	2f bd       	sub	sp,-20
8000337e:	e3 cd 80 80 	ldm	sp++,r7,pc

80003382 <spi_selectChip>:

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80003382:	eb cd 40 80 	pushm	r7,lr
80003386:	1a 97       	mov	r7,sp
80003388:	20 2d       	sub	sp,8
8000338a:	ef 4c ff fc 	st.w	r7[-4],r12
8000338e:	16 98       	mov	r8,r11
80003390:	ef 68 ff f8 	st.b	r7[-8],r8
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80003394:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003398:	70 18       	ld.w	r8,r8[0x4]
8000339a:	10 99       	mov	r9,r8
8000339c:	ea 19 00 0f 	orh	r9,0xf
800033a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033a4:	91 19       	st.w	r8[0x4],r9

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800033a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033aa:	70 18       	ld.w	r8,r8[0x4]
800033ac:	e2 18 00 04 	andl	r8,0x4,COH
800033b0:	c1 90       	breq	800033e2 <spi_selectChip+0x60>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800033b2:	ef 39 ff f8 	ld.ub	r9,r7[-8]
800033b6:	30 e8       	mov	r8,14
800033b8:	f0 09 18 00 	cp.b	r9,r8
800033bc:	e0 88 00 04 	brls	800033c4 <spi_selectChip+0x42>
			return SPI_ERROR_ARGUMENT;
800033c0:	30 28       	mov	r8,2
800033c2:	c2 88       	rjmp	80003412 <spi_selectChip+0x90>
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800033c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033c8:	70 19       	ld.w	r9,r8[0x4]
				(chip << AVR32_SPI_MR_PCS_OFFSET);
800033ca:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800033ce:	b1 68       	lsl	r8,0x10
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800033d0:	ea 18 ff f0 	orh	r8,0xfff0
800033d4:	e8 18 ff ff 	orl	r8,0xffff
800033d8:	10 69       	and	r9,r8
800033da:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033de:	91 19       	st.w	r8[0x4],r9
800033e0:	c1 88       	rjmp	80003410 <spi_selectChip+0x8e>
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800033e2:	ef 39 ff f8 	ld.ub	r9,r7[-8]
800033e6:	30 38       	mov	r8,3
800033e8:	f0 09 18 00 	cp.b	r9,r8
800033ec:	e0 88 00 04 	brls	800033f4 <spi_selectChip+0x72>
			return SPI_ERROR_ARGUMENT;
800033f0:	30 28       	mov	r8,2
800033f2:	c1 08       	rjmp	80003412 <spi_selectChip+0x90>
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800033f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033f8:	70 19       	ld.w	r9,r8[0x4]
800033fa:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800033fe:	2f 08       	sub	r8,-16
80003400:	30 1a       	mov	r10,1
80003402:	f4 08 09 48 	lsl	r8,r10,r8
80003406:	5c d8       	com	r8
80003408:	10 69       	and	r9,r8
8000340a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000340e:	91 19       	st.w	r8[0x4],r9
	}

	return SPI_OK;
80003410:	30 08       	mov	r8,0
}
80003412:	10 9c       	mov	r12,r8
80003414:	2f ed       	sub	sp,-8
80003416:	e3 cd 80 80 	ldm	sp++,r7,pc

8000341a <spi_unselectChip>:

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000341a:	eb cd 40 80 	pushm	r7,lr
8000341e:	1a 97       	mov	r7,sp
80003420:	20 3d       	sub	sp,12
80003422:	ef 4c ff f8 	st.w	r7[-8],r12
80003426:	16 98       	mov	r8,r11
80003428:	ef 68 ff f4 	st.b	r7[-12],r8
	uint32_t timeout = SPI_TIMEOUT;
8000342c:	e0 68 3a 98 	mov	r8,15000
80003430:	ef 48 ff fc 	st.w	r7[-4],r8

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80003434:	c0 f8       	rjmp	80003452 <spi_unselectChip+0x38>
		if (!timeout--) {
80003436:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000343a:	58 08       	cp.w	r8,0
8000343c:	5f 08       	sreq	r8
8000343e:	5c 58       	castu.b	r8
80003440:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003444:	20 19       	sub	r9,1
80003446:	ef 49 ff fc 	st.w	r7[-4],r9
8000344a:	58 08       	cp.w	r8,0
8000344c:	c0 30       	breq	80003452 <spi_unselectChip+0x38>
			return SPI_ERROR_TIMEOUT;
8000344e:	30 18       	mov	r8,1
80003450:	c1 68       	rjmp	8000347c <spi_unselectChip+0x62>

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80003452:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003456:	70 48       	ld.w	r8,r8[0x10]
80003458:	e2 18 02 00 	andl	r8,0x200,COH
8000345c:	ce d0       	breq	80003436 <spi_unselectChip+0x1c>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000345e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003462:	70 18       	ld.w	r8,r8[0x4]
80003464:	10 99       	mov	r9,r8
80003466:	ea 19 00 0f 	orh	r9,0xf
8000346a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000346e:	91 19       	st.w	r8[0x4],r9

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80003470:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003474:	fc 19 01 00 	movh	r9,0x100
80003478:	91 09       	st.w	r8[0x0],r9

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
#endif

	return SPI_OK;
8000347a:	30 08       	mov	r8,0
}
8000347c:	10 9c       	mov	r12,r8
8000347e:	2f dd       	sub	sp,-12
80003480:	e3 cd 80 80 	ldm	sp++,r7,pc

80003484 <spi_setupChipReg>:

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80003484:	eb cd 40 80 	pushm	r7,lr
80003488:	1a 97       	mov	r7,sp
8000348a:	20 5d       	sub	sp,20
8000348c:	ef 4c ff f4 	st.w	r7[-12],r12
80003490:	ef 4b ff f0 	st.w	r7[-16],r11
80003494:	ef 4a ff ec 	st.w	r7[-20],r10
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80003498:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000349c:	f1 39 00 0c 	ld.ub	r9,r8[12]
800034a0:	30 38       	mov	r8,3
800034a2:	f0 09 18 00 	cp.b	r9,r8
800034a6:	e0 8b 00 1d 	brhi	800034e0 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
800034aa:	ee f8 ff f0 	ld.w	r8,r7[-16]
800034ae:	f1 39 00 0b 	ld.ub	r9,r8[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800034b2:	30 18       	mov	r8,1
800034b4:	f0 09 18 00 	cp.b	r9,r8
800034b8:	e0 8b 00 14 	brhi	800034e0 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800034bc:	ee f8 ff f0 	ld.w	r8,r7[-16]
800034c0:	f1 39 00 08 	ld.ub	r9,r8[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800034c4:	30 78       	mov	r8,7
800034c6:	f0 09 18 00 	cp.b	r9,r8
800034ca:	e0 88 00 0b 	brls	800034e0 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800034ce:	ee f8 ff f0 	ld.w	r8,r7[-16]
800034d2:	f1 39 00 08 	ld.ub	r9,r8[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800034d6:	31 08       	mov	r8,16
800034d8:	f0 09 18 00 	cp.b	r9,r8
800034dc:	e0 88 00 04 	brls	800034e4 <spi_setupChipReg+0x60>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
800034e0:	30 28       	mov	r8,2
800034e2:	c8 d8       	rjmp	800035fc <spi_setupChipReg+0x178>
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800034e4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800034e8:	70 18       	ld.w	r8,r8[0x4]
800034ea:	ee fb ff ec 	ld.w	r11,r7[-20]
800034ee:	10 9c       	mov	r12,r8
800034f0:	f0 1f 00 45 	mcall	80003604 <spi_setupChipReg+0x180>
800034f4:	18 98       	mov	r8,r12
800034f6:	ef 48 ff fc 	st.w	r7[-4],r8

	if (baudDiv < 0) {
800034fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034fe:	58 08       	cp.w	r8,0
80003500:	c0 34       	brge	80003506 <spi_setupChipReg+0x82>
		return SPI_ERROR_ARGUMENT;
80003502:	30 28       	mov	r8,2
80003504:	c7 c8       	rjmp	800035fc <spi_setupChipReg+0x178>
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80003506:	30 08       	mov	r8,0
80003508:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
8000350c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003510:	f1 38 00 0c 	ld.ub	r8,r8[12]
80003514:	a1 98       	lsr	r8,0x1
80003516:	5c 58       	castu.b	r8
80003518:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000351c:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003520:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003524:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
80003528:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
8000352c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003530:	f1 38 00 0c 	ld.ub	r8,r8[12]
80003534:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003538:	5f 08       	sreq	r8
8000353a:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000353e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003542:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
80003546:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
8000354a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000354e:	f1 38 00 0b 	ld.ub	r8,r8[11]
80003552:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003556:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000355a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000355e:	f1 d9 d0 61 	bfins	r8,r9,0x3,0x1
80003562:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80003566:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000356a:	f1 38 00 08 	ld.ub	r8,r8[8]
8000356e:	20 88       	sub	r8,8
80003570:	5c 58       	castu.b	r8
80003572:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003576:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000357a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000357e:	f1 d9 d0 84 	bfins	r8,r9,0x4,0x4
80003582:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80003586:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000358a:	5c 58       	castu.b	r8
8000358c:	ef 68 ff fa 	st.b	r7[-6],r8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80003590:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003594:	f1 38 00 09 	ld.ub	r8,r8[9]
80003598:	ef 68 ff f9 	st.b	r7[-7],r8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
8000359c:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035a0:	f1 38 00 0a 	ld.ub	r8,r8[10]
800035a4:	ef 68 ff f8 	st.b	r7[-8],r8

	switch (options->reg) {
800035a8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035ac:	11 88       	ld.ub	r8,r8[0x0]
800035ae:	58 18       	cp.w	r8,1
800035b0:	c1 10       	breq	800035d2 <spi_setupChipReg+0x14e>
800035b2:	e0 89 00 05 	brgt	800035bc <spi_setupChipReg+0x138>
800035b6:	58 08       	cp.w	r8,0
800035b8:	c0 70       	breq	800035c6 <spi_setupChipReg+0x142>
800035ba:	c1 e8       	rjmp	800035f6 <spi_setupChipReg+0x172>
800035bc:	58 28       	cp.w	r8,2
800035be:	c1 00       	breq	800035de <spi_setupChipReg+0x15a>
800035c0:	58 38       	cp.w	r8,3
800035c2:	c1 40       	breq	800035ea <spi_setupChipReg+0x166>
800035c4:	c1 98       	rjmp	800035f6 <spi_setupChipReg+0x172>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800035c6:	ee f9 ff f8 	ld.w	r9,r7[-8]
800035ca:	ee f8 ff f4 	ld.w	r8,r7[-12]
800035ce:	91 c9       	st.w	r8[0x30],r9
		break;
800035d0:	c1 58       	rjmp	800035fa <spi_setupChipReg+0x176>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800035d2:	ee f9 ff f8 	ld.w	r9,r7[-8]
800035d6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800035da:	91 d9       	st.w	r8[0x34],r9
		break;
800035dc:	c0 f8       	rjmp	800035fa <spi_setupChipReg+0x176>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800035de:	ee f9 ff f8 	ld.w	r9,r7[-8]
800035e2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800035e6:	91 e9       	st.w	r8[0x38],r9
		break;
800035e8:	c0 98       	rjmp	800035fa <spi_setupChipReg+0x176>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800035ea:	ee f9 ff f8 	ld.w	r9,r7[-8]
800035ee:	ee f8 ff f4 	ld.w	r8,r7[-12]
800035f2:	91 f9       	st.w	r8[0x3c],r9
		break;
800035f4:	c0 38       	rjmp	800035fa <spi_setupChipReg+0x176>

	default:
		return SPI_ERROR_ARGUMENT;
800035f6:	30 28       	mov	r8,2
800035f8:	c0 28       	rjmp	800035fc <spi_setupChipReg+0x178>
			}
		}
	}
#endif

	return SPI_OK;
800035fa:	30 08       	mov	r8,0
}
800035fc:	10 9c       	mov	r12,r8
800035fe:	2f bd       	sub	sp,-20
80003600:	e3 cd 80 80 	ldm	sp++,r7,pc
80003604:	80 00       	ld.sh	r0,r0[0x0]
80003606:	32 0a       	mov	r10,32

80003608 <spi_enable>:

void spi_enable(volatile avr32_spi_t *spi)
{
80003608:	eb cd 40 80 	pushm	r7,lr
8000360c:	1a 97       	mov	r7,sp
8000360e:	20 1d       	sub	sp,4
80003610:	ef 4c ff fc 	st.w	r7[-4],r12
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80003614:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003618:	30 19       	mov	r9,1
8000361a:	91 09       	st.w	r8[0x0],r9
}
8000361c:	2f fd       	sub	sp,-4
8000361e:	e3 cd 80 80 	ldm	sp++,r7,pc

80003622 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80003622:	eb cd 40 80 	pushm	r7,lr
80003626:	1a 97       	mov	r7,sp
80003628:	20 3d       	sub	sp,12
8000362a:	ef 4c ff f8 	st.w	r7[-8],r12
8000362e:	16 98       	mov	r8,r11
80003630:	ef 58 ff f4 	st.h	r7[-12],r8
	uint32_t timeout = SPI_TIMEOUT;
80003634:	e0 68 3a 98 	mov	r8,15000
80003638:	ef 48 ff fc 	st.w	r7[-4],r8

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000363c:	c0 f8       	rjmp	8000365a <spi_write+0x38>
		if (!timeout--) {
8000363e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003642:	58 08       	cp.w	r8,0
80003644:	5f 08       	sreq	r8
80003646:	5c 58       	castu.b	r8
80003648:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000364c:	20 19       	sub	r9,1
8000364e:	ef 49 ff fc 	st.w	r7[-4],r9
80003652:	58 08       	cp.w	r8,0
80003654:	c0 30       	breq	8000365a <spi_write+0x38>
			return SPI_ERROR_TIMEOUT;
80003656:	30 18       	mov	r8,1
80003658:	c0 d8       	rjmp	80003672 <spi_write+0x50>

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000365a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000365e:	70 48       	ld.w	r8,r8[0x10]
80003660:	e2 18 00 02 	andl	r8,0x2,COH
80003664:	ce d0       	breq	8000363e <spi_write+0x1c>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80003666:	ef 19 ff f4 	ld.uh	r9,r7[-12]
8000366a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000366e:	91 39       	st.w	r8[0xc],r9

	return SPI_OK;
80003670:	30 08       	mov	r8,0
}
80003672:	10 9c       	mov	r12,r8
80003674:	2f dd       	sub	sp,-12
80003676:	e3 cd 80 80 	ldm	sp++,r7,pc

8000367a <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000367a:	eb cd 40 80 	pushm	r7,lr
8000367e:	1a 97       	mov	r7,sp
80003680:	20 3d       	sub	sp,12
80003682:	ef 4c ff f8 	st.w	r7[-8],r12
80003686:	ef 4b ff f4 	st.w	r7[-12],r11
	unsigned int timeout = SPI_TIMEOUT;
8000368a:	e0 68 3a 98 	mov	r8,15000
8000368e:	ef 48 ff fc 	st.w	r7[-4],r8

	while ((spi->sr &
80003692:	c0 f8       	rjmp	800036b0 <spi_read+0x36>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80003694:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003698:	58 08       	cp.w	r8,0
8000369a:	5f 08       	sreq	r8
8000369c:	5c 58       	castu.b	r8
8000369e:	ee f9 ff fc 	ld.w	r9,r7[-4]
800036a2:	20 19       	sub	r9,1
800036a4:	ef 49 ff fc 	st.w	r7[-4],r9
800036a8:	58 08       	cp.w	r8,0
800036aa:	c0 30       	breq	800036b0 <spi_read+0x36>
			return SPI_ERROR_TIMEOUT;
800036ac:	30 18       	mov	r8,1
800036ae:	c1 18       	rjmp	800036d0 <spi_read+0x56>

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800036b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800036b4:	70 48       	ld.w	r8,r8[0x10]
800036b6:	e2 18 02 01 	andl	r8,0x201,COH
800036ba:	e0 48 02 01 	cp.w	r8,513
800036be:	ce b1       	brne	80003694 <spi_read+0x1a>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800036c0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800036c4:	70 28       	ld.w	r8,r8[0x8]
800036c6:	5c 88       	casts.h	r8
800036c8:	ee f9 ff f4 	ld.w	r9,r7[-12]
800036cc:	b2 08       	st.h	r9[0x0],r8

	return SPI_OK;
800036ce:	30 08       	mov	r8,0
}
800036d0:	10 9c       	mov	r12,r8
800036d2:	2f dd       	sub	sp,-12
800036d4:	e3 cd 80 80 	ldm	sp++,r7,pc

800036d8 <buttonIsPressed>:
	button_port->oderc = BUTTON2_PIN;
	
}

int buttonIsPressed(int buttonNr)
{
800036d8:	eb cd 40 80 	pushm	r7,lr
800036dc:	1a 97       	mov	r7,sp
800036de:	20 2d       	sub	sp,8
800036e0:	ef 4c ff f8 	st.w	r7[-8],r12
	int buttonState = AVR32_GPIO.port[BUTTON_PORT].pvr & (buttonNr);
800036e4:	fe 78 10 00 	mov	r8,-61440
800036e8:	f0 f9 02 60 	ld.w	r9,r8[608]
800036ec:	ee f8 ff f8 	ld.w	r8,r7[-8]
800036f0:	f3 e8 00 08 	and	r8,r9,r8
800036f4:	ef 48 ff fc 	st.w	r7[-4],r8
	
	if(buttonState == 0)
800036f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800036fc:	58 08       	cp.w	r8,0
800036fe:	c0 31       	brne	80003704 <buttonIsPressed+0x2c>
		return 1;
80003700:	30 18       	mov	r8,1
80003702:	c0 28       	rjmp	80003706 <buttonIsPressed+0x2e>
	else
		return 0;
80003704:	30 08       	mov	r8,0
80003706:	10 9c       	mov	r12,r8
80003708:	2f ed       	sub	sp,-8
8000370a:	e3 cd 80 80 	ldm	sp++,r7,pc

8000370e <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern bool sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
8000370e:	eb cd 40 80 	pushm	r7,lr
80003712:	1a 97       	mov	r7,sp
	}
#endif

	switch (CONFIG_SYSCLK_SOURCE) {
	case SYSCLK_SRC_RCSYS:
		return OSC_SLOW_NOMINAL_HZ;
80003714:	e0 78 c2 00 	mov	r8,115200

	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
80003718:	10 9c       	mov	r12,r8
8000371a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000371e:	d7 03       	nop

80003720 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
80003720:	eb cd 40 80 	pushm	r7,lr
80003724:	1a 97       	mov	r7,sp
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_CPU_DIV;
80003726:	f0 1f 00 04 	mcall	80003734 <sysclk_get_cpu_hz+0x14>
8000372a:	18 98       	mov	r8,r12
}
8000372c:	10 9c       	mov	r12,r8
8000372e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003732:	00 00       	add	r0,r0
80003734:	80 00       	ld.sh	r0,r0[0x0]
80003736:	37 0e       	mov	lr,112

80003738 <display_init>:

// Include Files
#include "display_init.h"

void display_init(void)
{
80003738:	eb cd 40 8f 	pushm	r0-r3,r7,lr
8000373c:	1a 97       	mov	r7,sp
8000373e:	21 0d       	sub	sp,64
	volatile avr32_pm_t* pm = &AVR32_PM;
80003740:	fe 78 0c 00 	mov	r8,-62464
80003744:	ef 48 ff dc 	st.w	r7[-36],r8
	   .spck_delay           = 0,
	   .trans_delay  		 = 8,
	   .stay_act             = 1,
	   .spi_mode             = 0,
	   .modfdis              = 1
	};
80003748:	4f 68       	lddpc	r8,80003920 <display_init+0x1e8>
8000374a:	ee ca 00 34 	sub	r10,r7,52
8000374e:	10 9b       	mov	r11,r8
80003750:	f6 e8 00 00 	ld.d	r8,r11[0]
80003754:	f4 e9 00 00 	st.d	r10[0],r8
80003758:	f6 e8 00 08 	ld.d	r8,r11[8]
8000375c:	f4 e9 00 08 	st.d	r10[8],r8

	// Switch clock to external 12 MHz crystal
	// 1) Configure OSC0 in crystal mode, external crystal with a FOSC0 Hz frequency.
	pm_enable_osc0_crystal(pm, FOSC0);
80003760:	e0 6b 1b 00 	mov	r11,6912
80003764:	ea 1b 00 b7 	orh	r11,0xb7
80003768:	ee fc ff dc 	ld.w	r12,r7[-36]
8000376c:	f0 1f 00 6e 	mcall	80003924 <display_init+0x1ec>

	// 2) Enable the OSC0
	pm_enable_clk0(pm, OSC0_STARTUP);
80003770:	30 3b       	mov	r11,3
80003772:	ee fc ff dc 	ld.w	r12,r7[-36]
80003776:	f0 1f 00 6d 	mcall	80003928 <display_init+0x1f0>

	// 3) Set the main clock source as being OSC0.
	pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
8000377a:	30 1b       	mov	r11,1
8000377c:	ee fc ff dc 	ld.w	r12,r7[-36]
80003780:	f0 1f 00 6b 	mcall	8000392c <display_init+0x1f4>

	// Initialize the delay function
	delay_init(12000000);
	// Delay for a ms, to allow the display to power up properly
	delay_ms(1);
80003784:	f0 1f 00 6b 	mcall	80003930 <display_init+0x1f8>
80003788:	18 98       	mov	r8,r12
8000378a:	30 19       	mov	r9,1
8000378c:	ef 49 ff e4 	st.w	r7[-28],r9
80003790:	ef 48 ff e0 	st.w	r7[-32],r8
80003794:	ee f8 ff e4 	ld.w	r8,r7[-28]
80003798:	ef 48 ff ec 	st.w	r7[-20],r8
8000379c:	ee f8 ff e0 	ld.w	r8,r7[-32]
800037a0:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800037a4:	ee f0 ff ec 	ld.w	r0,r7[-20]
800037a8:	30 01       	mov	r1,0
800037aa:	ee f2 ff e8 	ld.w	r2,r7[-24]
800037ae:	30 03       	mov	r3,0
800037b0:	e2 02 02 4a 	mul	r10,r1,r2
800037b4:	e6 00 02 48 	mul	r8,r3,r0
800037b8:	10 0a       	add	r10,r8
800037ba:	e0 02 06 48 	mulu.d	r8,r0,r2
800037be:	12 0a       	add	r10,r9
800037c0:	14 99       	mov	r9,r10
800037c2:	e0 6a 03 e7 	mov	r10,999
800037c6:	30 0b       	mov	r11,0
800037c8:	f0 0a 00 0a 	add	r10,r8,r10
800037cc:	f2 0b 00 4b 	adc	r11,r9,r11
800037d0:	e0 68 03 e8 	mov	r8,1000
800037d4:	30 09       	mov	r9,0
800037d6:	f0 1f 00 58 	mcall	80003934 <display_init+0x1fc>
800037da:	14 98       	mov	r8,r10
800037dc:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
800037de:	ef 48 ff f4 	st.w	r7[-12],r8
800037e2:	ee c8 00 40 	sub	r8,r7,64
800037e6:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800037ea:	e1 b8 00 42 	mfsr	r8,0x108
800037ee:	10 99       	mov	r9,r8
800037f0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800037f4:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800037f6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800037fa:	70 09       	ld.w	r9,r8[0x0]
800037fc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003800:	10 09       	add	r9,r8
80003802:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003806:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80003808:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000380c:	30 08       	mov	r8,0
8000380e:	f3 68 00 08 	st.b	r9[8],r8
80003812:	ee c8 00 40 	sub	r8,r7,64
80003816:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000381a:	e1 b8 00 42 	mfsr	r8,0x108
8000381e:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80003822:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003826:	f1 39 00 08 	ld.ub	r9,r8[8]
8000382a:	30 28       	mov	r8,2
8000382c:	f0 09 18 00 	cp.b	r9,r8
80003830:	c0 31       	brne	80003836 <display_init+0xfe>
    return false;
80003832:	30 08       	mov	r8,0
80003834:	c4 38       	rjmp	800038ba <display_init+0x182>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80003836:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000383a:	f1 39 00 08 	ld.ub	r9,r8[8]
8000383e:	30 18       	mov	r8,1
80003840:	f0 09 18 00 	cp.b	r9,r8
80003844:	c0 31       	brne	8000384a <display_init+0x112>
    return true;
80003846:	30 18       	mov	r8,1
80003848:	c3 98       	rjmp	800038ba <display_init+0x182>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000384a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000384e:	70 09       	ld.w	r9,r8[0x0]
80003850:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003854:	70 18       	ld.w	r8,r8[0x4]
80003856:	10 39       	cp.w	r9,r8
80003858:	e0 88 00 1a 	brls	8000388c <display_init+0x154>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000385c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003860:	70 08       	ld.w	r8,r8[0x0]
80003862:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003866:	10 39       	cp.w	r9,r8
80003868:	c1 02       	brcc	80003888 <display_init+0x150>
8000386a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000386e:	70 18       	ld.w	r8,r8[0x4]
80003870:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003874:	10 39       	cp.w	r9,r8
80003876:	e0 88 00 09 	brls	80003888 <display_init+0x150>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000387a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000387e:	30 18       	mov	r8,1
80003880:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80003884:	30 18       	mov	r8,1
80003886:	c1 a8       	rjmp	800038ba <display_init+0x182>
    }
    return false;
80003888:	30 08       	mov	r8,0
8000388a:	c1 88       	rjmp	800038ba <display_init+0x182>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000388c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003890:	70 08       	ld.w	r8,r8[0x0]
80003892:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003896:	10 39       	cp.w	r9,r8
80003898:	c0 93       	brcs	800038aa <display_init+0x172>
8000389a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000389e:	70 18       	ld.w	r8,r8[0x4]
800038a0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800038a4:	10 39       	cp.w	r9,r8
800038a6:	e0 88 00 09 	brls	800038b8 <display_init+0x180>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800038aa:	ee f9 ff f8 	ld.w	r9,r7[-8]
800038ae:	30 18       	mov	r8,1
800038b0:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800038b4:	30 18       	mov	r8,1
800038b6:	c0 28       	rjmp	800038ba <display_init+0x182>
    }
    return false;
800038b8:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800038ba:	58 08       	cp.w	r8,0
800038bc:	ca b0       	breq	80003812 <display_init+0xda>

	// Enable the SPI peripheral on GPIO pins
	gpio_enable_module(DIP204_SPI_GPIO_MAP,
800038be:	30 4b       	mov	r11,4
800038c0:	49 ec       	lddpc	r12,80003938 <display_init+0x200>
800038c2:	f0 1f 00 1f 	mcall	8000393c <display_init+0x204>
						sizeof(DIP204_SPI_GPIO_MAP) / 	sizeof(DIP204_SPI_GPIO_MAP[0]));

	// Initialize as SPI master
	spi_initMaster(DIP204_SPI, &spiOptions);
800038c6:	ee c8 00 34 	sub	r8,r7,52
800038ca:	10 9b       	mov	r11,r8
800038cc:	fe 7c 28 00 	mov	r12,-55296
800038d0:	f0 1f 00 1c 	mcall	80003940 <display_init+0x208>
	spi_selectionMode(DIP204_SPI, 0, 0, 0);
800038d4:	30 09       	mov	r9,0
800038d6:	30 0a       	mov	r10,0
800038d8:	30 0b       	mov	r11,0
800038da:	fe 7c 28 00 	mov	r12,-55296
800038de:	f0 1f 00 1a 	mcall	80003944 <display_init+0x20c>
	spi_enable(DIP204_SPI);
800038e2:	fe 7c 28 00 	mov	r12,-55296
800038e6:	f0 1f 00 19 	mcall	80003948 <display_init+0x210>
	spi_setupChipReg(DIP204_SPI, &spiOptions, FOSC0);
800038ea:	ee c8 00 34 	sub	r8,r7,52
800038ee:	e0 6a 1b 00 	mov	r10,6912
800038f2:	ea 1a 00 b7 	orh	r10,0xb7
800038f6:	10 9b       	mov	r11,r8
800038f8:	fe 7c 28 00 	mov	r12,-55296
800038fc:	f0 1f 00 14 	mcall	8000394c <display_init+0x214>

	dip204_init(backlight_IO, ON);
80003900:	30 1b       	mov	r11,1
80003902:	30 0c       	mov	r12,0
80003904:	f0 1f 00 13 	mcall	80003950 <display_init+0x218>
	dip204_clear_display();
80003908:	f0 1f 00 13 	mcall	80003954 <display_init+0x21c>
	dip204_hide_cursor();
8000390c:	f0 1f 00 13 	mcall	80003958 <display_init+0x220>
	dip204_set_cursor_position(1,1);
80003910:	30 1b       	mov	r11,1
80003912:	30 1c       	mov	r12,1
80003914:	f0 1f 00 12 	mcall	8000395c <display_init+0x224>
}
80003918:	2f 0d       	sub	sp,-64
8000391a:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
8000391e:	00 00       	add	r0,r0
80003920:	80 00       	ld.sh	r0,r0[0x0]
80003922:	c6 18       	rjmp	800039e4 <onLED+0x8>
80003924:	80 00       	ld.sh	r0,r0[0x0]
80003926:	44 7c       	lddsp	r12,sp[0x11c]
80003928:	80 00       	ld.sh	r0,r0[0x0]
8000392a:	44 e0       	lddsp	r0,sp[0x138]
8000392c:	80 00       	ld.sh	r0,r0[0x0]
8000392e:	45 8c       	lddsp	r12,sp[0x160]
80003930:	80 00       	ld.sh	r0,r0[0x0]
80003932:	37 20       	mov	r0,114
80003934:	80 00       	ld.sh	r0,r0[0x0]
80003936:	67 60       	ld.w	r0,r3[0x58]
80003938:	80 00       	ld.sh	r0,r0[0x0]
8000393a:	c6 28       	rjmp	800039fe <offLED+0x4>
8000393c:	80 00       	ld.sh	r0,r0[0x0]
8000393e:	3f e8       	mov	r8,-2
80003940:	80 00       	ld.sh	r0,r0[0x0]
80003942:	32 5a       	mov	r10,37
80003944:	80 00       	ld.sh	r0,r0[0x0]
80003946:	32 ee       	mov	lr,46
80003948:	80 00       	ld.sh	r0,r0[0x0]
8000394a:	36 08       	mov	r8,96
8000394c:	80 00       	ld.sh	r0,r0[0x0]
8000394e:	34 84       	mov	r4,72
80003950:	80 00       	ld.sh	r0,r0[0x0]
80003952:	21 08       	sub	r8,16
80003954:	80 00       	ld.sh	r0,r0[0x0]
80003956:	2c a0       	sub	r0,-54
80003958:	80 00       	ld.sh	r0,r0[0x0]
8000395a:	2b e4       	sub	r4,-66
8000395c:	80 00       	ld.sh	r0,r0[0x0]
8000395e:	2c 18       	sub	r8,-63

80003960 <initLED>:
#include "LED.h"

void initLED (void)
{
80003960:	eb cd 40 80 	pushm	r7,lr
80003964:	1a 97       	mov	r7,sp
80003966:	20 1d       	sub	sp,4
	/*
	* First make access to the GPIO port registers
	* shorter to type , just for our convenience
	*/
	volatile avr32_gpio_port_t * led0_port;
	led0_port = &AVR32_GPIO.port[LED0_PORT];
80003968:	fe 78 11 00 	mov	r8,-61184
8000396c:	ef 48 ff fc 	st.w	r7[-4],r8
	/*
	* Choose GPIO peripheral function ,
	* by writing a 1 to gpers , GPIO Enable Register Set
	*/
	led0_port->gpers = LED0_BIT_VALUE;
80003970:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003974:	fc 19 08 00 	movh	r9,0x800
80003978:	91 19       	st.w	r8[0x4],r9
	led0_port->gpers = LED1_BIT_VALUE;
8000397a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000397e:	fc 19 10 00 	movh	r9,0x1000
80003982:	91 19       	st.w	r8[0x4],r9
	led0_port->gpers = LED2_BIT_VALUE;
80003984:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003988:	fc 19 20 00 	movh	r9,0x2000
8000398c:	91 19       	st.w	r8[0x4],r9
	/*
	* Set the output value register to 1 in order to
	* turn the LED off (1= off , 0= on in this case ) ,
	* by writing a 1 to ovrs , Output Value Register Set
	*/
	led0_port->ovrs = LED0_BIT_VALUE;
8000398e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003992:	fc 19 08 00 	movh	r9,0x800
80003996:	f1 49 00 54 	st.w	r8[84],r9
	led0_port->ovrs = LED1_BIT_VALUE;
8000399a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000399e:	fc 19 10 00 	movh	r9,0x1000
800039a2:	f1 49 00 54 	st.w	r8[84],r9
	led0_port->ovrs = LED2_BIT_VALUE;
800039a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039aa:	fc 19 20 00 	movh	r9,0x2000
800039ae:	f1 49 00 54 	st.w	r8[84],r9
	/*
	* Set the output enable register ,
	* by writing a 1 to oders , Output Drive Enable
	* Register Set
	*/
	led0_port->oders = LED0_BIT_VALUE;
800039b2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039b6:	fc 19 08 00 	movh	r9,0x800
800039ba:	f1 49 00 44 	st.w	r8[68],r9
	led0_port->oders = LED1_BIT_VALUE;
800039be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039c2:	fc 19 10 00 	movh	r9,0x1000
800039c6:	f1 49 00 44 	st.w	r8[68],r9
	led0_port->oders = LED2_BIT_VALUE;
800039ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039ce:	fc 19 20 00 	movh	r9,0x2000
800039d2:	f1 49 00 44 	st.w	r8[68],r9
}
800039d6:	2f fd       	sub	sp,-4
800039d8:	e3 cd 80 80 	ldm	sp++,r7,pc

800039dc <onLED>:
{
	AVR32_GPIO.port[LED0_PORT].ovrt = ledNr;
}

void onLED(int ledNr)
{
800039dc:	eb cd 40 80 	pushm	r7,lr
800039e0:	1a 97       	mov	r7,sp
800039e2:	20 1d       	sub	sp,4
800039e4:	ef 4c ff fc 	st.w	r7[-4],r12
	AVR32_GPIO.port[LED0_PORT].ovrc = ledNr;
800039e8:	fe 78 10 00 	mov	r8,-61440
800039ec:	ee f9 ff fc 	ld.w	r9,r7[-4]
800039f0:	f1 49 01 58 	st.w	r8[344],r9
}
800039f4:	2f fd       	sub	sp,-4
800039f6:	e3 cd 80 80 	ldm	sp++,r7,pc

800039fa <offLED>:

void offLED(int ledNr)
{
800039fa:	eb cd 40 80 	pushm	r7,lr
800039fe:	1a 97       	mov	r7,sp
80003a00:	20 1d       	sub	sp,4
80003a02:	ef 4c ff fc 	st.w	r7[-4],r12
	AVR32_GPIO.port[LED0_PORT].ovrs = ledNr;
80003a06:	fe 78 10 00 	mov	r8,-61440
80003a0a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003a0e:	f1 49 01 54 	st.w	r8[340],r9
80003a12:	2f fd       	sub	sp,-4
80003a14:	e3 cd 80 80 	ldm	sp++,r7,pc
80003a18:	25 63       	sub	r3,86
80003a1a:	00 00       	add	r0,r0
80003a1c:	25 64       	sub	r4,86
80003a1e:	00 00       	add	r0,r0
80003a20:	20 20       	sub	r0,2
80003a22:	20 20       	sub	r0,2
80003a24:	20 20       	sub	r0,2
80003a26:	20 20       	sub	r0,2
80003a28:	20 20       	sub	r0,2
80003a2a:	20 20       	sub	r0,2
80003a2c:	20 20       	sub	r0,2
80003a2e:	20 20       	sub	r0,2
80003a30:	20 20       	sub	r0,2
80003a32:	20 20       	sub	r0,2
80003a34:	00 00       	add	r0,r0
80003a36:	00 00       	add	r0,r0
80003a38:	76 50       	ld.w	r0,r11[0x14]
80003a3a:	72 6f       	ld.w	pc,r9[0x18]
80003a3c:	64 75       	ld.w	r5,r2[0x1c]
80003a3e:	63 65       	ld.w	r5,r1[0x58]
80003a40:	72 00       	ld.w	r0,r9[0x0]
80003a42:	00 00       	add	r0,r0
80003a44:	76 43       	ld.w	r3,r11[0x10]
80003a46:	6f 6e       	ld.w	lr,r7[0x58]
80003a48:	73 75       	ld.w	r5,r9[0x5c]
80003a4a:	6d 65       	ld.w	r5,r6[0x58]
80003a4c:	72 00       	ld.w	r0,r9[0x0]
80003a4e:	00 00       	add	r0,r0
80003a50:	76 53       	ld.w	r3,r11[0x14]
80003a52:	74 61       	ld.w	r1,r10[0x18]
80003a54:	74 75       	ld.w	r5,r10[0x1c]
80003a56:	73 00       	ld.w	r0,r9[0x40]

80003a58 <init_usart>:
		cycles--;
	}
}

void init_usart ( void )
{
80003a58:	eb cd 40 80 	pushm	r7,lr
80003a5c:	1a 97       	mov	r7,sp
		. charlength = 8,
		. paritytype = USART_NO_PARITY ,
		. stopbits = USART_1_STOPBIT ,
		. channelmode = USART_NORMAL_CHMODE
	};
	pm_switch_to_osc0 (& AVR32_PM , FOSC0 , OSC0_STARTUP );
80003a5e:	30 3a       	mov	r10,3
80003a60:	e0 6b 1b 00 	mov	r11,6912
80003a64:	ea 1b 00 b7 	orh	r11,0xb7
80003a68:	fe 7c 0c 00 	mov	r12,-62464
80003a6c:	f0 1f 00 0f 	mcall	80003aa8 <init_usart+0x50>
	gpio_enable_module ( USART_SERIAL_GPIO_MAP , 2);
80003a70:	30 2b       	mov	r11,2
80003a72:	48 fc       	lddpc	r12,80003aac <init_usart+0x54>
80003a74:	f0 1f 00 0f 	mcall	80003ab0 <init_usart+0x58>
	gpio_enable_module ( USART_DEBUG_GPIO_MAP , 2);
80003a78:	30 2b       	mov	r11,2
80003a7a:	48 fc       	lddpc	r12,80003ab4 <init_usart+0x5c>
80003a7c:	f0 1f 00 0d 	mcall	80003ab0 <init_usart+0x58>
	usart_init_rs232 ( serialPORT_USART , & USART_OPTIONS , FOSC0 );
80003a80:	e0 6a 1b 00 	mov	r10,6912
80003a84:	ea 1a 00 b7 	orh	r10,0xb7
80003a88:	48 cb       	lddpc	r11,80003ab8 <init_usart+0x60>
80003a8a:	fe 7c 18 00 	mov	r12,-59392
80003a8e:	f0 1f 00 0c 	mcall	80003abc <init_usart+0x64>
	usart_init_rs232 ( configDBG_USART , & USART_OPTIONS , FOSC0 );
80003a92:	e0 6a 1b 00 	mov	r10,6912
80003a96:	ea 1a 00 b7 	orh	r10,0xb7
80003a9a:	48 8b       	lddpc	r11,80003ab8 <init_usart+0x60>
80003a9c:	fe 7c 18 00 	mov	r12,-59392
80003aa0:	f0 1f 00 07 	mcall	80003abc <init_usart+0x64>
}
80003aa4:	e3 cd 80 80 	ldm	sp++,r7,pc
80003aa8:	80 00       	ld.sh	r0,r0[0x0]
80003aaa:	45 d8       	lddsp	r8,sp[0x174]
80003aac:	80 00       	ld.sh	r0,r0[0x0]
80003aae:	c6 48       	rjmp	80003b76 <vProducer+0xb6>
80003ab0:	80 00       	ld.sh	r0,r0[0x0]
80003ab2:	3f e8       	mov	r8,-2
80003ab4:	80 00       	ld.sh	r0,r0[0x0]
80003ab6:	c6 58       	rjmp	80003b80 <vProducer+0xc0>
80003ab8:	80 00       	ld.sh	r0,r0[0x0]
80003aba:	c6 68       	rjmp	80003b86 <vProducer+0xc6>
80003abc:	80 00       	ld.sh	r0,r0[0x0]
80003abe:	47 88       	lddsp	r8,sp[0x1e0]

80003ac0 <vProducer>:

void vProducer(void *pvParameters)
{	
80003ac0:	eb cd 40 80 	pushm	r7,lr
80003ac4:	1a 97       	mov	r7,sp
80003ac6:	20 ed       	sub	sp,56
80003ac8:	ef 4c ff c8 	st.w	r7[-56],r12
	portTickType xLastWakeTime;
	const portTickType xFreq = TASK_DELAY_MS(1000);
80003acc:	e0 68 03 e8 	mov	r8,1000
80003ad0:	ef 48 ff f4 	st.w	r7[-12],r8
	
	xLastWakeTime = xTaskGetTickCount();
80003ad4:	f0 1f 00 45 	mcall	80003be8 <vProducer+0x128>
80003ad8:	18 98       	mov	r8,r12
80003ada:	ef 48 ff f0 	st.w	r7[-16],r8
	
	struct msg message;
	message.id = 0;
80003ade:	30 08       	mov	r8,0
80003ae0:	ef 48 ff dc 	st.w	r7[-36],r8
	//message.data = 0;
	message.timestamp = 0;
80003ae4:	30 08       	mov	r8,0
80003ae6:	ef 48 ff ec 	st.w	r7[-20],r8
	
	struct msg *pMesg = &message;
80003aea:	ee c8 00 24 	sub	r8,r7,36
80003aee:	ef 48 ff f8 	st.w	r7[-8],r8
	
	char data[DATALEN] = "hej\n";
80003af2:	30 08       	mov	r8,0
80003af4:	e0 69 6a 0a 	mov	r9,27146
80003af8:	ea 19 68 65 	orh	r9,0x6865
80003afc:	ee e9 ff d0 	st.d	r7[-48],r8
80003b00:	30 08       	mov	r8,0
80003b02:	ef 58 ff d8 	st.h	r7[-40],r8
	int i = byteCount;
80003b06:	4b a8       	lddpc	r8,80003bec <vProducer+0x12c>
80003b08:	70 08       	ld.w	r8,r8[0x0]
80003b0a:	ef 48 ff fc 	st.w	r7[-4],r8
	
	char c;
	
	onLED(LED0_BIT_VALUE);
80003b0e:	fc 1c 08 00 	movh	r12,0x800
80003b12:	f0 1f 00 38 	mcall	80003bf0 <vProducer+0x130>
80003b16:	c0 28       	rjmp	80003b1a <vProducer+0x5a>
				//Successfully given back
				//usart_write_line(serialPORT_USART,"PRODUCER2 Semaphore GIVEN\n");
			}
		}
		
	}
80003b18:	d7 03       	nop
	
	onLED(LED0_BIT_VALUE);
	
	while(1)
	{
		if(xSemaphoreTake(xSemaphore, (portTickType)portMAX_DELAY) == pdTRUE)
80003b1a:	4b 78       	lddpc	r8,80003bf4 <vProducer+0x134>
80003b1c:	70 08       	ld.w	r8,r8[0x0]
80003b1e:	30 09       	mov	r9,0
80003b20:	3f fa       	mov	r10,-1
80003b22:	30 0b       	mov	r11,0
80003b24:	10 9c       	mov	r12,r8
80003b26:	f0 1f 00 35 	mcall	80003bf8 <vProducer+0x138>
80003b2a:	18 98       	mov	r8,r12
80003b2c:	58 18       	cp.w	r8,1
80003b2e:	c2 41       	brne	80003b76 <vProducer+0xb6>
		{
			//usart_write_line(serialPORT_USART,"PRODUCER1 Semaphore TAKEN\n");
			if(byteCount == BUFFER_SIZE)
80003b30:	4a f8       	lddpc	r8,80003bec <vProducer+0x12c>
80003b32:	70 08       	ld.w	r8,r8[0x0]
80003b34:	58 a8       	cp.w	r8,10
80003b36:	c1 81       	brne	80003b66 <vProducer+0xa6>
			{
				vTaskPrioritySet(NULL, 2);
80003b38:	30 2b       	mov	r11,2
80003b3a:	30 0c       	mov	r12,0
80003b3c:	f0 1f 00 30 	mcall	80003bfc <vProducer+0x13c>
				
				offLED(LED0_BIT_VALUE);
80003b40:	fc 1c 08 00 	movh	r12,0x800
80003b44:	f0 1f 00 2f 	mcall	80003c00 <vProducer+0x140>
				if(xSemaphoreGive(xSemaphore) == pdTRUE)
80003b48:	4a b8       	lddpc	r8,80003bf4 <vProducer+0x134>
80003b4a:	70 08       	ld.w	r8,r8[0x0]
80003b4c:	30 09       	mov	r9,0
80003b4e:	30 0a       	mov	r10,0
80003b50:	30 0b       	mov	r11,0
80003b52:	10 9c       	mov	r12,r8
80003b54:	f0 1f 00 2c 	mcall	80003c04 <vProducer+0x144>
				{
					//Successfully given back
					//usart_write_line(serialPORT_USART,"PRODUCER1 Semaphore GIVEN\n");
				}
				vTaskSuspend(NULL);
80003b58:	30 0c       	mov	r12,0
80003b5a:	f0 1f 00 2c 	mcall	80003c08 <vProducer+0x148>
				vTaskPrioritySet(NULL, 1);
80003b5e:	30 1b       	mov	r11,1
80003b60:	30 0c       	mov	r12,0
80003b62:	f0 1f 00 27 	mcall	80003bfc <vProducer+0x13c>
			}
			if(xSemaphoreGive(xSemaphore) == pdTRUE)
80003b66:	4a 48       	lddpc	r8,80003bf4 <vProducer+0x134>
80003b68:	70 08       	ld.w	r8,r8[0x0]
80003b6a:	30 09       	mov	r9,0
80003b6c:	30 0a       	mov	r10,0
80003b6e:	30 0b       	mov	r11,0
80003b70:	10 9c       	mov	r12,r8
80003b72:	f0 1f 00 25 	mcall	80003c04 <vProducer+0x144>
				//Successfully given back
				//usart_write_line(serialPORT_USART,"PRODUCER1 Semaphore GIVEN\n");
			}
		}
		
		c = usart_getchar(serialPORT_USART);
80003b76:	fe 7c 18 00 	mov	r12,-59392
80003b7a:	f0 1f 00 25 	mcall	80003c0c <vProducer+0x14c>
80003b7e:	18 98       	mov	r8,r12
80003b80:	5c 58       	castu.b	r8
80003b82:	ef 68 ff cf 	st.b	r7[-49],r8
		//c = 'b';
		
		//strcpy(pMesg->data, data);
		
		xQueueSendToBack(xQHandle, &c, (portTickType)10);
80003b86:	4a 38       	lddpc	r8,80003c10 <vProducer+0x150>
80003b88:	70 08       	ld.w	r8,r8[0x0]
80003b8a:	ee cb 00 31 	sub	r11,r7,49
80003b8e:	30 09       	mov	r9,0
80003b90:	30 aa       	mov	r10,10
80003b92:	10 9c       	mov	r12,r8
80003b94:	f0 1f 00 1c 	mcall	80003c04 <vProducer+0x144>
		
		if(xSemaphoreTake(xSemaphore, (portTickType)portMAX_DELAY) == pdTRUE)
80003b98:	49 78       	lddpc	r8,80003bf4 <vProducer+0x134>
80003b9a:	70 08       	ld.w	r8,r8[0x0]
80003b9c:	30 09       	mov	r9,0
80003b9e:	3f fa       	mov	r10,-1
80003ba0:	30 0b       	mov	r11,0
80003ba2:	10 9c       	mov	r12,r8
80003ba4:	f0 1f 00 15 	mcall	80003bf8 <vProducer+0x138>
80003ba8:	18 98       	mov	r8,r12
80003baa:	58 18       	cp.w	r8,1
80003bac:	cb 61       	brne	80003b18 <vProducer+0x58>
		{
			//usart_write_line(serialPORT_USART,"PRODUCER2 Semaphore TAKEN\n");
			byteCount++;
80003bae:	49 08       	lddpc	r8,80003bec <vProducer+0x12c>
80003bb0:	70 08       	ld.w	r8,r8[0x0]
80003bb2:	f0 c9 ff ff 	sub	r9,r8,-1
80003bb6:	48 e8       	lddpc	r8,80003bec <vProducer+0x12c>
80003bb8:	91 09       	st.w	r8[0x0],r9
			
			if(byteCount == 1)
80003bba:	48 d8       	lddpc	r8,80003bec <vProducer+0x12c>
80003bbc:	70 08       	ld.w	r8,r8[0x0]
80003bbe:	58 18       	cp.w	r8,1
80003bc0:	c0 a1       	brne	80003bd4 <vProducer+0x114>
			{
				vTaskResume(xHandleConsumer);
80003bc2:	49 58       	lddpc	r8,80003c14 <vProducer+0x154>
80003bc4:	70 08       	ld.w	r8,r8[0x0]
80003bc6:	10 9c       	mov	r12,r8
80003bc8:	f0 1f 00 14 	mcall	80003c18 <vProducer+0x158>
				onLED(LED1_BIT_VALUE);
80003bcc:	fc 1c 10 00 	movh	r12,0x1000
80003bd0:	f0 1f 00 08 	mcall	80003bf0 <vProducer+0x130>
			}
			if(xSemaphoreGive(xSemaphore) == pdTRUE)
80003bd4:	48 88       	lddpc	r8,80003bf4 <vProducer+0x134>
80003bd6:	70 08       	ld.w	r8,r8[0x0]
80003bd8:	30 09       	mov	r9,0
80003bda:	30 0a       	mov	r10,0
80003bdc:	30 0b       	mov	r11,0
80003bde:	10 9c       	mov	r12,r8
80003be0:	f0 1f 00 09 	mcall	80003c04 <vProducer+0x144>
				//Successfully given back
				//usart_write_line(serialPORT_USART,"PRODUCER2 Semaphore GIVEN\n");
			}
		}
		
	}
80003be4:	c9 bb       	rjmp	80003b1a <vProducer+0x5a>
80003be6:	00 00       	add	r0,r0
80003be8:	80 00       	ld.sh	r0,r0[0x0]
80003bea:	5f a0       	srle	r0
80003bec:	00 00       	add	r0,r0
80003bee:	05 74       	ld.ub	r4,--r2
80003bf0:	80 00       	ld.sh	r0,r0[0x0]
80003bf2:	39 dc       	mov	r12,-99
80003bf4:	00 00       	add	r0,r0
80003bf6:	07 f4       	ld.ub	r4,r3[0x7]
80003bf8:	80 00       	ld.sh	r0,r0[0x0]
80003bfa:	54 54       	stdsp	sp[0x114],r4
80003bfc:	80 00       	ld.sh	r0,r0[0x0]
80003bfe:	5a d4       	cp.w	r4,-19
80003c00:	80 00       	ld.sh	r0,r0[0x0]
80003c02:	39 fa       	mov	r10,-97
80003c04:	80 00       	ld.sh	r0,r0[0x0]
80003c06:	52 ec       	stdsp	sp[0xb8],r12
80003c08:	80 00       	ld.sh	r0,r0[0x0]
80003c0a:	5c 1c       	scr	r12
80003c0c:	80 00       	ld.sh	r0,r0[0x0]
80003c0e:	49 e4       	lddpc	r4,80003c84 <vConsumer+0x68>
80003c10:	00 00       	add	r0,r0
80003c12:	07 e4       	ld.ub	r4,r3[0x6]
80003c14:	00 00       	add	r0,r0
80003c16:	07 e8       	ld.ub	r8,r3[0x6]
80003c18:	80 00       	ld.sh	r0,r0[0x0]
80003c1a:	5d 34       	musfr	r4

80003c1c <vConsumer>:
}

void vConsumer( void *pvParameters )
{
80003c1c:	eb cd 40 80 	pushm	r7,lr
80003c20:	1a 97       	mov	r7,sp
80003c22:	20 7d       	sub	sp,28
80003c24:	ef 4c ff e4 	st.w	r7[-28],r12
	portTickType xLastWakeTime;
	const portTickType xFreq = TASK_DELAY_MS(10000);
80003c28:	e0 68 27 10 	mov	r8,10000
80003c2c:	ef 48 ff f4 	st.w	r7[-12],r8
	volatile portTickType elapsed;
	
	struct msg *pMesg;
	
	char c;
	int column = 0;
80003c30:	30 08       	mov	r8,0
80003c32:	ef 48 ff fc 	st.w	r7[-4],r8
	
	onLED(LED1_BIT_VALUE);
80003c36:	fc 1c 10 00 	movh	r12,0x1000
80003c3a:	f0 1f 00 55 	mcall	80003d8c <vConsumer+0x170>
80003c3e:	c0 28       	rjmp	80003c42 <vConsumer+0x26>
			{
				//Successfully given back
				//usart_write_line(serialPORT_USART,"CONSUMER2 Semaphore TAKEN\n");
			}
		}
	}
80003c40:	d7 03       	nop
	
	onLED(LED1_BIT_VALUE);
	
	while(1)
	{
		if(xSemaphoreTake(xSemaphore, (portTickType)portMAX_DELAY) == pdTRUE)
80003c42:	4d 48       	lddpc	r8,80003d90 <vConsumer+0x174>
80003c44:	70 08       	ld.w	r8,r8[0x0]
80003c46:	30 09       	mov	r9,0
80003c48:	3f fa       	mov	r10,-1
80003c4a:	30 0b       	mov	r11,0
80003c4c:	10 9c       	mov	r12,r8
80003c4e:	f0 1f 00 52 	mcall	80003d94 <vConsumer+0x178>
80003c52:	18 98       	mov	r8,r12
80003c54:	58 18       	cp.w	r8,1
80003c56:	c2 41       	brne	80003c9e <vConsumer+0x82>
		{
			//usart_write_line(serialPORT_USART,"CONSUMER1 Semaphore TAKEN\n");
			if(byteCount == 0)
80003c58:	4d 08       	lddpc	r8,80003d98 <vConsumer+0x17c>
80003c5a:	70 08       	ld.w	r8,r8[0x0]
80003c5c:	58 08       	cp.w	r8,0
80003c5e:	c1 81       	brne	80003c8e <vConsumer+0x72>
			{
				vTaskPrioritySet(NULL, 2);
80003c60:	30 2b       	mov	r11,2
80003c62:	30 0c       	mov	r12,0
80003c64:	f0 1f 00 4e 	mcall	80003d9c <vConsumer+0x180>
				
				offLED(LED1_BIT_VALUE);
80003c68:	fc 1c 10 00 	movh	r12,0x1000
80003c6c:	f0 1f 00 4d 	mcall	80003da0 <vConsumer+0x184>
				if(xSemaphoreGive(xSemaphore) == pdTRUE)
80003c70:	4c 88       	lddpc	r8,80003d90 <vConsumer+0x174>
80003c72:	70 08       	ld.w	r8,r8[0x0]
80003c74:	30 09       	mov	r9,0
80003c76:	30 0a       	mov	r10,0
80003c78:	30 0b       	mov	r11,0
80003c7a:	10 9c       	mov	r12,r8
80003c7c:	f0 1f 00 4a 	mcall	80003da4 <vConsumer+0x188>
				{
					//Successfully given back
					//usart_write_line(serialPORT_USART,"CONSUMER1 Semaphore GIVEN\n");
				}
				vTaskSuspend(NULL);
80003c80:	30 0c       	mov	r12,0
80003c82:	f0 1f 00 4a 	mcall	80003da8 <vConsumer+0x18c>
							
				vTaskPrioritySet(NULL, 1);
80003c86:	30 1b       	mov	r11,1
80003c88:	30 0c       	mov	r12,0
80003c8a:	f0 1f 00 45 	mcall	80003d9c <vConsumer+0x180>
			}
			if(xSemaphoreGive(xSemaphore) == pdTRUE)
80003c8e:	4c 18       	lddpc	r8,80003d90 <vConsumer+0x174>
80003c90:	70 08       	ld.w	r8,r8[0x0]
80003c92:	30 09       	mov	r9,0
80003c94:	30 0a       	mov	r10,0
80003c96:	30 0b       	mov	r11,0
80003c98:	10 9c       	mov	r12,r8
80003c9a:	f0 1f 00 43 	mcall	80003da4 <vConsumer+0x188>
					//Successfully given back
					//usart_write_line(serialPORT_USART,"CONSUMER1 Semaphore GIVEN\n");
			}
		}
			
		xQueueReceive(xQHandle, &c, (portTickType)10);
80003c9e:	4c 48       	lddpc	r8,80003dac <vConsumer+0x190>
80003ca0:	70 08       	ld.w	r8,r8[0x0]
80003ca2:	ee cb 00 15 	sub	r11,r7,21
80003ca6:	30 09       	mov	r9,0
80003ca8:	30 aa       	mov	r10,10
80003caa:	10 9c       	mov	r12,r8
80003cac:	f0 1f 00 3a 	mcall	80003d94 <vConsumer+0x178>
		statusCount++;
80003cb0:	4c 08       	lddpc	r8,80003db0 <vConsumer+0x194>
80003cb2:	70 08       	ld.w	r8,r8[0x0]
80003cb4:	f0 c9 ff ff 	sub	r9,r8,-1
80003cb8:	4b e8       	lddpc	r8,80003db0 <vConsumer+0x194>
80003cba:	91 09       	st.w	r8[0x0],r9
		
		//usart_write_line(serialPORT_USART, pMesg->data);
		
		column++;
80003cbc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003cc0:	2f f8       	sub	r8,-1
80003cc2:	ef 48 ff fc 	st.w	r7[-4],r8
		if(column > 20)
80003cc6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003cca:	59 48       	cp.w	r8,20
80003ccc:	e0 8a 00 07 	brle	80003cda <vConsumer+0xbe>
		{	
			dip204_clear_display();
80003cd0:	f0 1f 00 39 	mcall	80003db4 <vConsumer+0x198>
			column = 1;		
80003cd4:	30 18       	mov	r8,1
80003cd6:	ef 48 ff fc 	st.w	r7[-4],r8
		}
		if(xSemaphoreTake(xLCDSemaphore, (portTickType)portMAX_DELAY) == pdTRUE)
80003cda:	4b 88       	lddpc	r8,80003db8 <vConsumer+0x19c>
80003cdc:	70 08       	ld.w	r8,r8[0x0]
80003cde:	30 09       	mov	r9,0
80003ce0:	3f fa       	mov	r10,-1
80003ce2:	30 0b       	mov	r11,0
80003ce4:	10 9c       	mov	r12,r8
80003ce6:	f0 1f 00 2c 	mcall	80003d94 <vConsumer+0x178>
80003cea:	18 98       	mov	r8,r12
80003cec:	58 18       	cp.w	r8,1
80003cee:	c2 61       	brne	80003d3a <vConsumer+0x11e>
		{
			dip204_set_cursor_position(column, 1);	
80003cf0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003cf4:	5c 58       	castu.b	r8
80003cf6:	30 1b       	mov	r11,1
80003cf8:	10 9c       	mov	r12,r8
80003cfa:	f0 1f 00 31 	mcall	80003dbc <vConsumer+0x1a0>
			dip204_printf_string("%c", c); //print value
80003cfe:	ef 38 ff eb 	ld.ub	r8,r7[-21]
80003d02:	1a d8       	st.w	--sp,r8
80003d04:	4a fc       	lddpc	r12,80003dc0 <vConsumer+0x1a4>
80003d06:	f0 1f 00 30 	mcall	80003dc4 <vConsumer+0x1a8>
80003d0a:	2f fd       	sub	sp,-4
		
			if(statusTaskActive == pdTRUE)
80003d0c:	4a f8       	lddpc	r8,80003dc8 <vConsumer+0x1ac>
80003d0e:	70 08       	ld.w	r8,r8[0x0]
80003d10:	58 18       	cp.w	r8,1
80003d12:	c0 c1       	brne	80003d2a <vConsumer+0x10e>
			{
				dip204_set_cursor_position(1, 2);
80003d14:	30 2b       	mov	r11,2
80003d16:	30 1c       	mov	r12,1
80003d18:	f0 1f 00 29 	mcall	80003dbc <vConsumer+0x1a0>
				dip204_printf_string("%d", statusCount); //print value
80003d1c:	4a 58       	lddpc	r8,80003db0 <vConsumer+0x194>
80003d1e:	70 08       	ld.w	r8,r8[0x0]
80003d20:	1a d8       	st.w	--sp,r8
80003d22:	4a bc       	lddpc	r12,80003dcc <vConsumer+0x1b0>
80003d24:	f0 1f 00 28 	mcall	80003dc4 <vConsumer+0x1a8>
80003d28:	2f fd       	sub	sp,-4
			}
			if(xSemaphoreGive(xLCDSemaphore) == pdTRUE)
80003d2a:	4a 48       	lddpc	r8,80003db8 <vConsumer+0x19c>
80003d2c:	70 08       	ld.w	r8,r8[0x0]
80003d2e:	30 09       	mov	r9,0
80003d30:	30 0a       	mov	r10,0
80003d32:	30 0b       	mov	r11,0
80003d34:	10 9c       	mov	r12,r8
80003d36:	f0 1f 00 1c 	mcall	80003da4 <vConsumer+0x188>
			{
				//Successfully given back
			}
		}
			
		if(xSemaphoreTake(xSemaphore, (portTickType)portMAX_DELAY) == pdTRUE)
80003d3a:	49 68       	lddpc	r8,80003d90 <vConsumer+0x174>
80003d3c:	70 08       	ld.w	r8,r8[0x0]
80003d3e:	30 09       	mov	r9,0
80003d40:	3f fa       	mov	r10,-1
80003d42:	30 0b       	mov	r11,0
80003d44:	10 9c       	mov	r12,r8
80003d46:	f0 1f 00 14 	mcall	80003d94 <vConsumer+0x178>
80003d4a:	18 98       	mov	r8,r12
80003d4c:	58 18       	cp.w	r8,1
80003d4e:	fe 91 ff 79 	brne	80003c40 <vConsumer+0x24>
		{
			//usart_write_line(serialPORT_USART,"CONSUMER2 Semaphore TAKEN\n");
			byteCount--;
80003d52:	49 28       	lddpc	r8,80003d98 <vConsumer+0x17c>
80003d54:	70 08       	ld.w	r8,r8[0x0]
80003d56:	f0 c9 00 01 	sub	r9,r8,1
80003d5a:	49 08       	lddpc	r8,80003d98 <vConsumer+0x17c>
80003d5c:	91 09       	st.w	r8[0x0],r9
			
			if(byteCount == BUFFER_SIZE - 1)
80003d5e:	48 f8       	lddpc	r8,80003d98 <vConsumer+0x17c>
80003d60:	70 08       	ld.w	r8,r8[0x0]
80003d62:	58 98       	cp.w	r8,9
80003d64:	c0 a1       	brne	80003d78 <vConsumer+0x15c>
			{
				vTaskResume(xHandleProducer);
80003d66:	49 b8       	lddpc	r8,80003dd0 <vConsumer+0x1b4>
80003d68:	70 08       	ld.w	r8,r8[0x0]
80003d6a:	10 9c       	mov	r12,r8
80003d6c:	f0 1f 00 1a 	mcall	80003dd4 <vConsumer+0x1b8>
				onLED(LED0_BIT_VALUE);
80003d70:	fc 1c 08 00 	movh	r12,0x800
80003d74:	f0 1f 00 06 	mcall	80003d8c <vConsumer+0x170>
			}
			if(xSemaphoreGive(xSemaphore) == pdTRUE)
80003d78:	48 68       	lddpc	r8,80003d90 <vConsumer+0x174>
80003d7a:	70 08       	ld.w	r8,r8[0x0]
80003d7c:	30 09       	mov	r9,0
80003d7e:	30 0a       	mov	r10,0
80003d80:	30 0b       	mov	r11,0
80003d82:	10 9c       	mov	r12,r8
80003d84:	f0 1f 00 08 	mcall	80003da4 <vConsumer+0x188>
			{
				//Successfully given back
				//usart_write_line(serialPORT_USART,"CONSUMER2 Semaphore TAKEN\n");
			}
		}
	}
80003d88:	c5 db       	rjmp	80003c42 <vConsumer+0x26>
80003d8a:	00 00       	add	r0,r0
80003d8c:	80 00       	ld.sh	r0,r0[0x0]
80003d8e:	39 dc       	mov	r12,-99
80003d90:	00 00       	add	r0,r0
80003d92:	07 f4       	ld.ub	r4,r3[0x7]
80003d94:	80 00       	ld.sh	r0,r0[0x0]
80003d96:	54 54       	stdsp	sp[0x114],r4
80003d98:	00 00       	add	r0,r0
80003d9a:	05 74       	ld.ub	r4,--r2
80003d9c:	80 00       	ld.sh	r0,r0[0x0]
80003d9e:	5a d4       	cp.w	r4,-19
80003da0:	80 00       	ld.sh	r0,r0[0x0]
80003da2:	39 fa       	mov	r10,-97
80003da4:	80 00       	ld.sh	r0,r0[0x0]
80003da6:	52 ec       	stdsp	sp[0xb8],r12
80003da8:	80 00       	ld.sh	r0,r0[0x0]
80003daa:	5c 1c       	scr	r12
80003dac:	00 00       	add	r0,r0
80003dae:	07 e4       	ld.ub	r4,r3[0x6]
80003db0:	00 00       	add	r0,r0
80003db2:	05 7c       	ld.ub	r12,--r2
80003db4:	80 00       	ld.sh	r0,r0[0x0]
80003db6:	2c a0       	sub	r0,-54
80003db8:	00 00       	add	r0,r0
80003dba:	07 e0       	ld.ub	r0,r3[0x6]
80003dbc:	80 00       	ld.sh	r0,r0[0x0]
80003dbe:	2c 18       	sub	r8,-63
80003dc0:	80 00       	ld.sh	r0,r0[0x0]
80003dc2:	3a 18       	mov	r8,-95
80003dc4:	80 00       	ld.sh	r0,r0[0x0]
80003dc6:	2e 8c       	sub	r12,-24
80003dc8:	00 00       	add	r0,r0
80003dca:	05 78       	ld.ub	r8,--r2
80003dcc:	80 00       	ld.sh	r0,r0[0x0]
80003dce:	3a 1c       	mov	r12,-95
80003dd0:	00 00       	add	r0,r0
80003dd2:	07 ec       	ld.ub	r12,r3[0x6]
80003dd4:	80 00       	ld.sh	r0,r0[0x0]
80003dd6:	5d 34       	musfr	r4

80003dd8 <vStatus>:
}

void vStatus( void *pvParameters )
{
80003dd8:	eb cd 40 80 	pushm	r7,lr
80003ddc:	1a 97       	mov	r7,sp
80003dde:	20 1d       	sub	sp,4
80003de0:	ef 4c ff fc 	st.w	r7[-4],r12
80003de4:	c0 48       	rjmp	80003dec <vStatus+0x14>
				{
					//Successfully given back
				}
			}
		}
	}
80003de6:	d7 03       	nop
80003de8:	c0 28       	rjmp	80003dec <vStatus+0x14>
80003dea:	d7 03       	nop

void vStatus( void *pvParameters )
{
	while (1)
	{
		if(buttonIsPressed(BUTTON0_PIN))
80003dec:	fc 1c 01 00 	movh	r12,0x100
80003df0:	f0 1f 00 28 	mcall	80003e90 <vStatus+0xb8>
80003df4:	18 98       	mov	r8,r12
80003df6:	58 08       	cp.w	r8,0
80003df8:	cf 70       	breq	80003de6 <vStatus+0xe>
		{
			statusTaskActive = pdTRUE;
80003dfa:	4a 78       	lddpc	r8,80003e94 <vStatus+0xbc>
80003dfc:	30 19       	mov	r9,1
80003dfe:	91 09       	st.w	r8[0x0],r9
			onLED(LED2_BIT_VALUE);
80003e00:	fc 1c 20 00 	movh	r12,0x2000
80003e04:	f0 1f 00 25 	mcall	80003e98 <vStatus+0xc0>
			if(xSemaphoreTake(xLCDSemaphore, (portTickType)portMAX_DELAY) == pdTRUE)
80003e08:	4a 58       	lddpc	r8,80003e9c <vStatus+0xc4>
80003e0a:	70 08       	ld.w	r8,r8[0x0]
80003e0c:	30 09       	mov	r9,0
80003e0e:	3f fa       	mov	r10,-1
80003e10:	30 0b       	mov	r11,0
80003e12:	10 9c       	mov	r12,r8
80003e14:	f0 1f 00 23 	mcall	80003ea0 <vStatus+0xc8>
80003e18:	18 98       	mov	r8,r12
80003e1a:	58 18       	cp.w	r8,1
80003e1c:	c1 41       	brne	80003e44 <vStatus+0x6c>
			{
				dip204_set_cursor_position(1, 2);	
80003e1e:	30 2b       	mov	r11,2
80003e20:	30 1c       	mov	r12,1
80003e22:	f0 1f 00 21 	mcall	80003ea4 <vStatus+0xcc>
				dip204_printf_string("%d", statusCount); //print value
80003e26:	4a 18       	lddpc	r8,80003ea8 <vStatus+0xd0>
80003e28:	70 08       	ld.w	r8,r8[0x0]
80003e2a:	1a d8       	st.w	--sp,r8
80003e2c:	4a 0c       	lddpc	r12,80003eac <vStatus+0xd4>
80003e2e:	f0 1f 00 21 	mcall	80003eb0 <vStatus+0xd8>
80003e32:	2f fd       	sub	sp,-4
				if(xSemaphoreGive(xLCDSemaphore) == pdTRUE)
80003e34:	49 a8       	lddpc	r8,80003e9c <vStatus+0xc4>
80003e36:	70 08       	ld.w	r8,r8[0x0]
80003e38:	30 09       	mov	r9,0
80003e3a:	30 0a       	mov	r10,0
80003e3c:	30 0b       	mov	r11,0
80003e3e:	10 9c       	mov	r12,r8
80003e40:	f0 1f 00 1d 	mcall	80003eb4 <vStatus+0xdc>
				{
					//Successfully given back
				}
			}
			vTaskDelay(TASK_DELAY_MS(10000));//Sleep for 10 sec
80003e44:	e0 6c 27 10 	mov	r12,10000
80003e48:	f0 1f 00 1c 	mcall	80003eb8 <vStatus+0xe0>
			offLED(LED2_BIT_VALUE);
80003e4c:	fc 1c 20 00 	movh	r12,0x2000
80003e50:	f0 1f 00 1b 	mcall	80003ebc <vStatus+0xe4>
			statusTaskActive = pdFALSE;
80003e54:	49 08       	lddpc	r8,80003e94 <vStatus+0xbc>
80003e56:	30 09       	mov	r9,0
80003e58:	91 09       	st.w	r8[0x0],r9
			if(xSemaphoreTake(xLCDSemaphore, (portTickType)portMAX_DELAY) == pdTRUE)
80003e5a:	49 18       	lddpc	r8,80003e9c <vStatus+0xc4>
80003e5c:	70 08       	ld.w	r8,r8[0x0]
80003e5e:	30 09       	mov	r9,0
80003e60:	3f fa       	mov	r10,-1
80003e62:	30 0b       	mov	r11,0
80003e64:	10 9c       	mov	r12,r8
80003e66:	f0 1f 00 0f 	mcall	80003ea0 <vStatus+0xc8>
80003e6a:	18 98       	mov	r8,r12
80003e6c:	58 18       	cp.w	r8,1
80003e6e:	cb e1       	brne	80003dea <vStatus+0x12>
			{
				dip204_set_cursor_position(1, 2);	
80003e70:	30 2b       	mov	r11,2
80003e72:	30 1c       	mov	r12,1
80003e74:	f0 1f 00 0c 	mcall	80003ea4 <vStatus+0xcc>
				dip204_write_string("                    "); 
80003e78:	49 2c       	lddpc	r12,80003ec0 <vStatus+0xe8>
80003e7a:	f0 1f 00 13 	mcall	80003ec4 <vStatus+0xec>
				if(xSemaphoreGive(xLCDSemaphore) == pdTRUE)
80003e7e:	48 88       	lddpc	r8,80003e9c <vStatus+0xc4>
80003e80:	70 08       	ld.w	r8,r8[0x0]
80003e82:	30 09       	mov	r9,0
80003e84:	30 0a       	mov	r10,0
80003e86:	30 0b       	mov	r11,0
80003e88:	10 9c       	mov	r12,r8
80003e8a:	f0 1f 00 0b 	mcall	80003eb4 <vStatus+0xdc>
				{
					//Successfully given back
				}
			}
		}
	}
80003e8e:	ca fb       	rjmp	80003dec <vStatus+0x14>
80003e90:	80 00       	ld.sh	r0,r0[0x0]
80003e92:	36 d8       	mov	r8,109
80003e94:	00 00       	add	r0,r0
80003e96:	05 78       	ld.ub	r8,--r2
80003e98:	80 00       	ld.sh	r0,r0[0x0]
80003e9a:	39 dc       	mov	r12,-99
80003e9c:	00 00       	add	r0,r0
80003e9e:	07 e0       	ld.ub	r0,r3[0x6]
80003ea0:	80 00       	ld.sh	r0,r0[0x0]
80003ea2:	54 54       	stdsp	sp[0x114],r4
80003ea4:	80 00       	ld.sh	r0,r0[0x0]
80003ea6:	2c 18       	sub	r8,-63
80003ea8:	00 00       	add	r0,r0
80003eaa:	05 7c       	ld.ub	r12,--r2
80003eac:	80 00       	ld.sh	r0,r0[0x0]
80003eae:	3a 1c       	mov	r12,-95
80003eb0:	80 00       	ld.sh	r0,r0[0x0]
80003eb2:	2e 8c       	sub	r12,-24
80003eb4:	80 00       	ld.sh	r0,r0[0x0]
80003eb6:	52 ec       	stdsp	sp[0xb8],r12
80003eb8:	80 00       	ld.sh	r0,r0[0x0]
80003eba:	5a 60       	cp.w	r0,-26
80003ebc:	80 00       	ld.sh	r0,r0[0x0]
80003ebe:	39 fa       	mov	r10,-97
80003ec0:	80 00       	ld.sh	r0,r0[0x0]
80003ec2:	3a 20       	mov	r0,-94
80003ec4:	80 00       	ld.sh	r0,r0[0x0]
80003ec6:	2e 1c       	sub	r12,-31

80003ec8 <main>:
}

int main(void)
{
80003ec8:	eb cd 40 80 	pushm	r7,lr
80003ecc:	1a 97       	mov	r7,sp
	initLED();
80003ece:	f0 1f 00 33 	mcall	80003f98 <main+0xd0>
	init_usart();
80003ed2:	f0 1f 00 33 	mcall	80003f9c <main+0xd4>
	display_init();
80003ed6:	f0 1f 00 33 	mcall	80003fa0 <main+0xd8>
	dip204_clear_display();
80003eda:	f0 1f 00 33 	mcall	80003fa4 <main+0xdc>

	static unsigned char ucParameterToPass ;
	
	vSemaphoreCreateBinary(xSemaphore);
80003ede:	30 0b       	mov	r11,0
80003ee0:	30 1c       	mov	r12,1
80003ee2:	f0 1f 00 32 	mcall	80003fa8 <main+0xe0>
80003ee6:	18 99       	mov	r9,r12
80003ee8:	4b 18       	lddpc	r8,80003fac <main+0xe4>
80003eea:	91 09       	st.w	r8[0x0],r9
80003eec:	4b 08       	lddpc	r8,80003fac <main+0xe4>
80003eee:	70 08       	ld.w	r8,r8[0x0]
80003ef0:	58 08       	cp.w	r8,0
80003ef2:	c0 90       	breq	80003f04 <main+0x3c>
80003ef4:	4a e8       	lddpc	r8,80003fac <main+0xe4>
80003ef6:	70 08       	ld.w	r8,r8[0x0]
80003ef8:	30 09       	mov	r9,0
80003efa:	30 0a       	mov	r10,0
80003efc:	30 0b       	mov	r11,0
80003efe:	10 9c       	mov	r12,r8
80003f00:	f0 1f 00 2c 	mcall	80003fb0 <main+0xe8>
	vSemaphoreCreateBinary(xLCDSemaphore);
80003f04:	30 0b       	mov	r11,0
80003f06:	30 1c       	mov	r12,1
80003f08:	f0 1f 00 28 	mcall	80003fa8 <main+0xe0>
80003f0c:	18 99       	mov	r9,r12
80003f0e:	4a a8       	lddpc	r8,80003fb4 <main+0xec>
80003f10:	91 09       	st.w	r8[0x0],r9
80003f12:	4a 98       	lddpc	r8,80003fb4 <main+0xec>
80003f14:	70 08       	ld.w	r8,r8[0x0]
80003f16:	58 08       	cp.w	r8,0
80003f18:	c0 90       	breq	80003f2a <main+0x62>
80003f1a:	4a 78       	lddpc	r8,80003fb4 <main+0xec>
80003f1c:	70 08       	ld.w	r8,r8[0x0]
80003f1e:	30 09       	mov	r9,0
80003f20:	30 0a       	mov	r10,0
80003f22:	30 0b       	mov	r11,0
80003f24:	10 9c       	mov	r12,r8
80003f26:	f0 1f 00 23 	mcall	80003fb0 <main+0xe8>
	
	xQHandle = xQueueCreate(10, sizeof(char*));
80003f2a:	30 4b       	mov	r11,4
80003f2c:	30 ac       	mov	r12,10
80003f2e:	f0 1f 00 1f 	mcall	80003fa8 <main+0xe0>
80003f32:	18 99       	mov	r9,r12
80003f34:	4a 18       	lddpc	r8,80003fb8 <main+0xf0>
80003f36:	91 09       	st.w	r8[0x0],r9
		//ERROR!
	}
	
	
	// Create the task , store the handle .
	xTaskCreate(	vProducer,
80003f38:	4a 1b       	lddpc	r11,80003fbc <main+0xf4>
80003f3a:	30 08       	mov	r8,0
80003f3c:	1a d8       	st.w	--sp,r8
80003f3e:	30 08       	mov	r8,0
80003f40:	1a d8       	st.w	--sp,r8
80003f42:	4a 08       	lddpc	r8,80003fc0 <main+0xf8>
80003f44:	1a d8       	st.w	--sp,r8
80003f46:	30 18       	mov	r8,1
80003f48:	30 09       	mov	r9,0
80003f4a:	e0 6a 01 00 	mov	r10,256
80003f4e:	49 ec       	lddpc	r12,80003fc4 <main+0xfc>
80003f50:	f0 1f 00 1e 	mcall	80003fc8 <main+0x100>
80003f54:	2f dd       	sub	sp,-12
					"vProducer",
					configMINIMAL_STACK_SIZE,
					NULL,
					1,
					&xHandleProducer);
	xTaskCreate(	vConsumer, "vConsumer", configMINIMAL_STACK_SIZE, NULL, 1, &xHandleConsumer);
80003f56:	49 eb       	lddpc	r11,80003fcc <main+0x104>
80003f58:	30 08       	mov	r8,0
80003f5a:	1a d8       	st.w	--sp,r8
80003f5c:	30 08       	mov	r8,0
80003f5e:	1a d8       	st.w	--sp,r8
80003f60:	49 c8       	lddpc	r8,80003fd0 <main+0x108>
80003f62:	1a d8       	st.w	--sp,r8
80003f64:	30 18       	mov	r8,1
80003f66:	30 09       	mov	r9,0
80003f68:	e0 6a 01 00 	mov	r10,256
80003f6c:	49 ac       	lddpc	r12,80003fd4 <main+0x10c>
80003f6e:	f0 1f 00 17 	mcall	80003fc8 <main+0x100>
80003f72:	2f dd       	sub	sp,-12
	
	xTaskCreate(	vStatus, "vStatus", configMINIMAL_STACK_SIZE, NULL, 1, &xHandleStatus);
80003f74:	49 9b       	lddpc	r11,80003fd8 <main+0x110>
80003f76:	30 08       	mov	r8,0
80003f78:	1a d8       	st.w	--sp,r8
80003f7a:	30 08       	mov	r8,0
80003f7c:	1a d8       	st.w	--sp,r8
80003f7e:	49 88       	lddpc	r8,80003fdc <main+0x114>
80003f80:	1a d8       	st.w	--sp,r8
80003f82:	30 18       	mov	r8,1
80003f84:	30 09       	mov	r9,0
80003f86:	e0 6a 01 00 	mov	r10,256
80003f8a:	49 6c       	lddpc	r12,80003fe0 <main+0x118>
80003f8c:	f0 1f 00 0f 	mcall	80003fc8 <main+0x100>
80003f90:	2f dd       	sub	sp,-12
	
	vTaskStartScheduler();
80003f92:	f0 1f 00 15 	mcall	80003fe4 <main+0x11c>

	
	for( ;; )
	{
		
	}
80003f96:	c0 08       	rjmp	80003f96 <main+0xce>
80003f98:	80 00       	ld.sh	r0,r0[0x0]
80003f9a:	39 60       	mov	r0,-106
80003f9c:	80 00       	ld.sh	r0,r0[0x0]
80003f9e:	3a 58       	mov	r8,-91
80003fa0:	80 00       	ld.sh	r0,r0[0x0]
80003fa2:	37 38       	mov	r8,115
80003fa4:	80 00       	ld.sh	r0,r0[0x0]
80003fa6:	2c a0       	sub	r0,-54
80003fa8:	80 00       	ld.sh	r0,r0[0x0]
80003faa:	51 d4       	stdsp	sp[0x74],r4
80003fac:	00 00       	add	r0,r0
80003fae:	07 f4       	ld.ub	r4,r3[0x7]
80003fb0:	80 00       	ld.sh	r0,r0[0x0]
80003fb2:	52 ec       	stdsp	sp[0xb8],r12
80003fb4:	00 00       	add	r0,r0
80003fb6:	07 e0       	ld.ub	r0,r3[0x6]
80003fb8:	00 00       	add	r0,r0
80003fba:	07 e4       	ld.ub	r4,r3[0x6]
80003fbc:	80 00       	ld.sh	r0,r0[0x0]
80003fbe:	3a 38       	mov	r8,-93
80003fc0:	00 00       	add	r0,r0
80003fc2:	07 ec       	ld.ub	r12,r3[0x6]
80003fc4:	80 00       	ld.sh	r0,r0[0x0]
80003fc6:	3a c0       	mov	r0,-84
80003fc8:	80 00       	ld.sh	r0,r0[0x0]
80003fca:	58 98       	cp.w	r8,9
80003fcc:	80 00       	ld.sh	r0,r0[0x0]
80003fce:	3a 44       	mov	r4,-92
80003fd0:	00 00       	add	r0,r0
80003fd2:	07 e8       	ld.ub	r8,r3[0x6]
80003fd4:	80 00       	ld.sh	r0,r0[0x0]
80003fd6:	3c 1c       	mov	r12,-63
80003fd8:	80 00       	ld.sh	r0,r0[0x0]
80003fda:	3a 50       	mov	r0,-91
80003fdc:	00 00       	add	r0,r0
80003fde:	07 f0       	ld.ub	r0,r3[0x7]
80003fe0:	80 00       	ld.sh	r0,r0[0x0]
80003fe2:	3d d8       	mov	r8,-35
80003fe4:	80 00       	ld.sh	r0,r0[0x0]
80003fe6:	5d f8       	*unknown*

80003fe8 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80003fe8:	eb cd 40 80 	pushm	r7,lr
80003fec:	1a 97       	mov	r7,sp
80003fee:	20 4d       	sub	sp,16
80003ff0:	ef 4c ff f4 	st.w	r7[-12],r12
80003ff4:	ef 4b ff f0 	st.w	r7[-16],r11
	uint32_t status = GPIO_SUCCESS;
80003ff8:	30 08       	mov	r8,0
80003ffa:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t i;

	for (i = 0; i < size; i++) {
80003ffe:	30 08       	mov	r8,0
80004000:	ef 48 ff fc 	st.w	r7[-4],r8
80004004:	c1 c8       	rjmp	8000403c <gpio_enable_module+0x54>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80004006:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000400a:	70 19       	ld.w	r9,r8[0x4]
8000400c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004010:	70 08       	ld.w	r8,r8[0x0]
80004012:	12 9b       	mov	r11,r9
80004014:	10 9c       	mov	r12,r8
80004016:	f0 1f 00 10 	mcall	80004054 <gpio_enable_module+0x6c>
8000401a:	18 98       	mov	r8,r12
8000401c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004020:	f3 e8 10 08 	or	r8,r9,r8
80004024:	ef 48 ff f8 	st.w	r7[-8],r8
		gpiomap++;
80004028:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000402c:	2f 88       	sub	r8,-8
8000402e:	ef 48 ff f4 	st.w	r7[-12],r8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80004032:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004036:	2f f8       	sub	r8,-1
80004038:	ef 48 ff fc 	st.w	r7[-4],r8
8000403c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004040:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004044:	10 39       	cp.w	r9,r8
80004046:	ce 03       	brcs	80004006 <gpio_enable_module+0x1e>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
80004048:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
8000404c:	10 9c       	mov	r12,r8
8000404e:	2f cd       	sub	sp,-16
80004050:	e3 cd 80 80 	ldm	sp++,r7,pc
80004054:	80 00       	ld.sh	r0,r0[0x0]
80004056:	40 58       	lddsp	r8,sp[0x14]

80004058 <gpio_enable_module_pin>:
 * \param function The pin function.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
80004058:	eb cd 40 80 	pushm	r7,lr
8000405c:	1a 97       	mov	r7,sp
8000405e:	20 3d       	sub	sp,12
80004060:	ef 4c ff f8 	st.w	r7[-8],r12
80004064:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004068:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000406c:	a5 98       	lsr	r8,0x5
8000406e:	a9 68       	lsl	r8,0x8
80004070:	e0 28 f0 00 	sub	r8,61440
80004074:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Enable the correct function. */
	switch (function) {
80004078:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000407c:	58 18       	cp.w	r8,1
8000407e:	c1 e0       	breq	800040ba <gpio_enable_module_pin+0x62>
80004080:	c0 63       	brcs	8000408c <gpio_enable_module_pin+0x34>
80004082:	58 28       	cp.w	r8,2
80004084:	c3 20       	breq	800040e8 <gpio_enable_module_pin+0x90>
80004086:	58 38       	cp.w	r8,3
80004088:	c4 70       	breq	80004116 <gpio_enable_module_pin+0xbe>
8000408a:	c5 d8       	rjmp	80004144 <gpio_enable_module_pin+0xec>
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000408c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004090:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004094:	30 19       	mov	r9,1
80004096:	f2 08 09 48 	lsl	r8,r9,r8
8000409a:	10 99       	mov	r9,r8
8000409c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800040a0:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800040a2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800040a6:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800040aa:	30 19       	mov	r9,1
800040ac:	f2 08 09 48 	lsl	r8,r9,r8
800040b0:	10 99       	mov	r9,r8
800040b2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800040b6:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800040b8:	c4 88       	rjmp	80004148 <gpio_enable_module_pin+0xf0>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800040ba:	ee f8 ff f8 	ld.w	r8,r7[-8]
800040be:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800040c2:	30 19       	mov	r9,1
800040c4:	f2 08 09 48 	lsl	r8,r9,r8
800040c8:	10 99       	mov	r9,r8
800040ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
800040ce:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800040d0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800040d4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800040d8:	30 19       	mov	r9,1
800040da:	f2 08 09 48 	lsl	r8,r9,r8
800040de:	10 99       	mov	r9,r8
800040e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800040e4:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800040e6:	c3 18       	rjmp	80004148 <gpio_enable_module_pin+0xf0>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800040e8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800040ec:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800040f0:	30 19       	mov	r9,1
800040f2:	f2 08 09 48 	lsl	r8,r9,r8
800040f6:	10 99       	mov	r9,r8
800040f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800040fc:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800040fe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004102:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004106:	30 19       	mov	r9,1
80004108:	f2 08 09 48 	lsl	r8,r9,r8
8000410c:	10 99       	mov	r9,r8
8000410e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004112:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004114:	c1 a8       	rjmp	80004148 <gpio_enable_module_pin+0xf0>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004116:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000411a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000411e:	30 19       	mov	r9,1
80004120:	f2 08 09 48 	lsl	r8,r9,r8
80004124:	10 99       	mov	r9,r8
80004126:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000412a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000412c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004130:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004134:	30 19       	mov	r9,1
80004136:	f2 08 09 48 	lsl	r8,r9,r8
8000413a:	10 99       	mov	r9,r8
8000413c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004140:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004142:	c0 38       	rjmp	80004148 <gpio_enable_module_pin+0xf0>
		gpio_port->pmr2s = 1 << (pin & 0x1F);
		break;
#endif

	default:
		return GPIO_INVALID_ARGUMENT;
80004144:	30 18       	mov	r8,1
80004146:	c0 d8       	rjmp	80004160 <gpio_enable_module_pin+0x108>
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80004148:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000414c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004150:	30 19       	mov	r9,1
80004152:	f2 08 09 48 	lsl	r8,r9,r8
80004156:	10 99       	mov	r9,r8
80004158:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000415c:	91 29       	st.w	r8[0x8],r9

	return GPIO_SUCCESS;
8000415e:	30 08       	mov	r8,0
}
80004160:	10 9c       	mov	r12,r8
80004162:	2f dd       	sub	sp,-12
80004164:	e3 cd 80 80 	ldm	sp++,r7,pc

80004168 <gpio_set_gpio_pin>:
/** \brief Drives a GPIO pin to 1.
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
80004168:	eb cd 40 80 	pushm	r7,lr
8000416c:	1a 97       	mov	r7,sp
8000416e:	20 2d       	sub	sp,8
80004170:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004174:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004178:	a5 98       	lsr	r8,0x5
8000417a:	a9 68       	lsl	r8,0x8
8000417c:	e0 28 f0 00 	sub	r8,61440
80004180:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80004184:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004188:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000418c:	30 19       	mov	r9,1
8000418e:	f2 08 09 48 	lsl	r8,r9,r8
80004192:	10 99       	mov	r9,r8
80004194:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004198:	f1 49 00 54 	st.w	r8[84],r9
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
8000419c:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041a0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800041a4:	30 19       	mov	r9,1
800041a6:	f2 08 09 48 	lsl	r8,r9,r8
800041aa:	10 99       	mov	r9,r8
800041ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800041b0:	f1 49 00 44 	st.w	r8[68],r9
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800041b4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041b8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800041bc:	30 19       	mov	r9,1
800041be:	f2 08 09 48 	lsl	r8,r9,r8
800041c2:	10 99       	mov	r9,r8
800041c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800041c8:	91 19       	st.w	r8[0x4],r9
}
800041ca:	2f ed       	sub	sp,-8
800041cc:	e3 cd 80 80 	ldm	sp++,r7,pc

800041d0 <gpio_clr_gpio_pin>:
/** \brief Drives a GPIO pin to 0.
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
800041d0:	eb cd 40 80 	pushm	r7,lr
800041d4:	1a 97       	mov	r7,sp
800041d6:	20 2d       	sub	sp,8
800041d8:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800041dc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041e0:	a5 98       	lsr	r8,0x5
800041e2:	a9 68       	lsl	r8,0x8
800041e4:	e0 28 f0 00 	sub	r8,61440
800041e8:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800041ec:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041f0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800041f4:	30 19       	mov	r9,1
800041f6:	f2 08 09 48 	lsl	r8,r9,r8
800041fa:	10 99       	mov	r9,r8
800041fc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004200:	f1 49 00 58 	st.w	r8[88],r9
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80004204:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004208:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000420c:	30 19       	mov	r9,1
8000420e:	f2 08 09 48 	lsl	r8,r9,r8
80004212:	10 99       	mov	r9,r8
80004214:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004218:	f1 49 00 44 	st.w	r8[68],r9
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000421c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004220:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004224:	30 19       	mov	r9,1
80004226:	f2 08 09 48 	lsl	r8,r9,r8
8000422a:	10 99       	mov	r9,r8
8000422c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004230:	91 19       	st.w	r8[0x4],r9
}
80004232:	2f ed       	sub	sp,-8
80004234:	e3 cd 80 80 	ldm	sp++,r7,pc

80004238 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004238:	eb cd 40 80 	pushm	r7,lr
8000423c:	1a 97       	mov	r7,sp
	// Catch unregistered interrupts.
	while (true);
8000423e:	c0 08       	rjmp	8000423e <_unhandled_interrupt+0x6>

80004240 <_get_interrupt_handler>:
 *
 * \return Interrupt handler to execute.
 */
__int_handler _get_interrupt_handler(uint32_t int_level);
__int_handler _get_interrupt_handler(uint32_t int_level)
{
80004240:	eb cd 40 80 	pushm	r7,lr
80004244:	1a 97       	mov	r7,sp
80004246:	20 3d       	sub	sp,12
80004248:	ef 4c ff f4 	st.w	r7[-12],r12
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
8000424c:	fe 78 08 00 	mov	r8,-63488
80004250:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004254:	f2 09 11 03 	rsub	r9,r9,3
80004258:	28 09       	sub	r9,-128
8000425a:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
8000425e:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004262:	fe 78 08 00 	mov	r8,-63488
80004266:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000426a:	2c 09       	sub	r9,-64
8000426c:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80004270:	ef 48 ff fc 	st.w	r7[-4],r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004274:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004278:	58 08       	cp.w	r8,0
8000427a:	c1 30       	breq	800042a0 <_get_interrupt_handler+0x60>
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000427c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004280:	48 b8       	lddpc	r8,800042ac <_get_interrupt_handler+0x6c>
80004282:	a1 79       	lsl	r9,0x1
80004284:	2f f9       	sub	r9,-1
80004286:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
8000428a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000428e:	f0 08 12 00 	clz	r8,r8
80004292:	f0 08 11 1f 	rsub	r8,r8,31
			- clz(int_req) - 1]
80004296:	a3 68       	lsl	r8,0x2
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004298:	f2 08 00 08 	add	r8,r9,r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000429c:	70 08       	ld.w	r8,r8[0x0]
8000429e:	c0 28       	rjmp	800042a2 <_get_interrupt_handler+0x62>
800042a0:	30 08       	mov	r8,0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800042a2:	10 9c       	mov	r12,r8
800042a4:	2f dd       	sub	sp,-12
800042a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800042aa:	00 00       	add	r0,r0
800042ac:	80 00       	ld.sh	r0,r0[0x0]
800042ae:	c6 74       	brge	8000437c <INTC_register_interrupt+0x20>

800042b0 <INTC_init_evba>:
 * \internal
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
800042b0:	eb cd 40 80 	pushm	r7,lr
800042b4:	1a 97       	mov	r7,sp
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800042b6:	48 38       	lddpc	r8,800042c0 <INTC_init_evba+0x10>
800042b8:	e3 b8 00 01 	mtsr	0x4,r8
}
800042bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800042c0:	80 00       	ld.sh	r0,r0[0x0]
800042c2:	c4 00       	breq	80004342 <INTC_init_interrupts+0x7e>

800042c4 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800042c4:	eb cd 40 80 	pushm	r7,lr
800042c8:	1a 97       	mov	r7,sp
800042ca:	20 2d       	sub	sp,8
	uint32_t int_grp, int_req;

	INTC_init_evba();
800042cc:	f0 1f 00 1f 	mcall	80004348 <INTC_init_interrupts+0x84>

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800042d0:	30 08       	mov	r8,0
800042d2:	ef 48 ff f8 	st.w	r7[-8],r8
800042d6:	c3 18       	rjmp	80004338 <INTC_init_interrupts+0x74>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800042d8:	30 08       	mov	r8,0
800042da:	ef 48 ff fc 	st.w	r7[-4],r8
800042de:	c1 48       	rjmp	80004306 <INTC_init_interrupts+0x42>
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800042e0:	ee f9 ff f8 	ld.w	r9,r7[-8]
800042e4:	49 a8       	lddpc	r8,8000434c <INTC_init_interrupts+0x88>
800042e6:	a1 79       	lsl	r9,0x1
800042e8:	2f f9       	sub	r9,-1
800042ea:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
800042ee:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042f2:	a3 68       	lsl	r8,0x2
800042f4:	f2 08 00 08 	add	r8,r9,r8
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800042f8:	49 69       	lddpc	r9,80004350 <INTC_init_interrupts+0x8c>
800042fa:	91 09       	st.w	r8[0x0],r9
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800042fc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004300:	2f f8       	sub	r8,-1
80004302:	ef 48 ff fc 	st.w	r7[-4],r8
	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
80004306:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000430a:	49 18       	lddpc	r8,8000434c <INTC_init_interrupts+0x88>
8000430c:	f0 09 03 39 	ld.w	r9,r8[r9<<0x3]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004310:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004314:	10 39       	cp.w	r9,r8
80004316:	fe 9b ff e5 	brhi	800042e0 <INTC_init_interrupts+0x1c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000431a:	fe 78 08 00 	mov	r8,-63488
8000431e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004322:	48 db       	lddpc	r11,80004354 <INTC_init_interrupts+0x90>
80004324:	48 da       	lddpc	r10,80004358 <INTC_init_interrupts+0x94>
80004326:	f6 0a 01 0a 	sub	r10,r11,r10
8000432a:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
8000432e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004332:	2f f8       	sub	r8,-1
80004334:	ef 48 ff f8 	st.w	r7[-8],r8
80004338:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000433c:	59 38       	cp.w	r8,19
8000433e:	fe 98 ff cd 	brls	800042d8 <INTC_init_interrupts+0x14>
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	}
}
80004342:	2f ed       	sub	sp,-8
80004344:	e3 cd 80 80 	ldm	sp++,r7,pc
80004348:	80 00       	ld.sh	r0,r0[0x0]
8000434a:	42 b0       	lddsp	r0,sp[0xac]
8000434c:	80 00       	ld.sh	r0,r0[0x0]
8000434e:	c6 74       	brge	8000441c <INTC_register_interrupt+0xc0>
80004350:	80 00       	ld.sh	r0,r0[0x0]
80004352:	42 38       	lddsp	r8,sp[0x8c]
80004354:	80 00       	ld.sh	r0,r0[0x0]
80004356:	c5 04       	brge	800043f6 <INTC_register_interrupt+0x9a>
80004358:	80 00       	ld.sh	r0,r0[0x0]
8000435a:	c4 00       	breq	800043da <INTC_register_interrupt+0x7e>

8000435c <INTC_register_interrupt>:
 *          be effective.
 *
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
8000435c:	eb cd 40 80 	pushm	r7,lr
80004360:	1a 97       	mov	r7,sp
80004362:	20 4d       	sub	sp,16
80004364:	ef 4c ff f8 	st.w	r7[-8],r12
80004368:	ef 4b ff f4 	st.w	r7[-12],r11
8000436c:	ef 4a ff f0 	st.w	r7[-16],r10
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004370:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004374:	a5 98       	lsr	r8,0x5
80004376:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
8000437a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000437e:	4a 78       	lddpc	r8,80004418 <INTC_register_interrupt+0xbc>
80004380:	a1 79       	lsl	r9,0x1
80004382:	2f f9       	sub	r9,-1
80004384:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80004388:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000438c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004390:	a3 68       	lsl	r8,0x2
80004392:	f2 08 00 08 	add	r8,r9,r8
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004396:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000439a:	91 09       	st.w	r8[0x0],r9
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
8000439c:	ee f8 ff f0 	ld.w	r8,r7[-16]
800043a0:	58 08       	cp.w	r8,0
800043a2:	c0 c1       	brne	800043ba <INTC_register_interrupt+0x5e>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800043a4:	fe 78 08 00 	mov	r8,-63488
800043a8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800043ac:	49 cb       	lddpc	r11,8000441c <INTC_register_interrupt+0xc0>
800043ae:	49 da       	lddpc	r10,80004420 <INTC_register_interrupt+0xc4>
800043b0:	f6 0a 01 0a 	sub	r10,r11,r10
800043b4:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
800043b8:	c2 d8       	rjmp	80004412 <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT1) {
800043ba:	ee f8 ff f0 	ld.w	r8,r7[-16]
800043be:	58 18       	cp.w	r8,1
800043c0:	c0 d1       	brne	800043da <INTC_register_interrupt+0x7e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800043c2:	fe 78 08 00 	mov	r8,-63488
800043c6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800043ca:	49 7b       	lddpc	r11,80004424 <INTC_register_interrupt+0xc8>
800043cc:	49 5a       	lddpc	r10,80004420 <INTC_register_interrupt+0xc4>
800043ce:	f6 0a 01 0a 	sub	r10,r11,r10
800043d2:	bf aa       	sbr	r10,0x1e
800043d4:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
800043d8:	c1 d8       	rjmp	80004412 <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT2) {
800043da:	ee f8 ff f0 	ld.w	r8,r7[-16]
800043de:	58 28       	cp.w	r8,2
800043e0:	c0 d1       	brne	800043fa <INTC_register_interrupt+0x9e>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800043e2:	fe 78 08 00 	mov	r8,-63488
800043e6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800043ea:	49 0b       	lddpc	r11,80004428 <INTC_register_interrupt+0xcc>
800043ec:	48 da       	lddpc	r10,80004420 <INTC_register_interrupt+0xc4>
800043ee:	f6 0a 01 0a 	sub	r10,r11,r10
800043f2:	bf ba       	sbr	r10,0x1f
800043f4:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
800043f8:	c0 d8       	rjmp	80004412 <INTC_register_interrupt+0xb6>
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800043fa:	fe 78 08 00 	mov	r8,-63488
800043fe:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004402:	48 bb       	lddpc	r11,8000442c <INTC_register_interrupt+0xd0>
80004404:	48 7a       	lddpc	r10,80004420 <INTC_register_interrupt+0xc4>
80004406:	f6 0a 01 0a 	sub	r10,r11,r10
8000440a:	ea 1a c0 00 	orh	r10,0xc000
8000440e:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	}
}
80004412:	2f cd       	sub	sp,-16
80004414:	e3 cd 80 80 	ldm	sp++,r7,pc
80004418:	80 00       	ld.sh	r0,r0[0x0]
8000441a:	c6 74       	brge	800044e8 <pm_enable_clk0+0x8>
8000441c:	80 00       	ld.sh	r0,r0[0x0]
8000441e:	c5 04       	brge	800044be <pm_enable_osc0_crystal+0x42>
80004420:	80 00       	ld.sh	r0,r0[0x0]
80004422:	c4 00       	breq	800044a2 <pm_enable_osc0_crystal+0x26>
80004424:	80 00       	ld.sh	r0,r0[0x0]
80004426:	c5 12       	brcc	800044c8 <pm_enable_osc0_crystal+0x4c>
80004428:	80 00       	ld.sh	r0,r0[0x0]
8000442a:	c5 20       	breq	800044ce <pm_enable_osc0_crystal+0x52>
8000442c:	80 00       	ld.sh	r0,r0[0x0]
8000442e:	c5 2e       	rcall	800040d2 <gpio_enable_module_pin+0x7a>

80004430 <pm_set_osc0_mode>:
 *
 * \param pm Base address of the Power Manager (i.e. &AVR32_PM).
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
80004430:	eb cd 40 80 	pushm	r7,lr
80004434:	1a 97       	mov	r7,sp
80004436:	20 3d       	sub	sp,12
80004438:	ef 4c ff f8 	st.w	r7[-8],r12
8000443c:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80004440:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004444:	70 a8       	ld.w	r8,r8[0x28]
80004446:	30 09       	mov	r9,0
80004448:	ef 49 ff fc 	st.w	r7[-4],r9
8000444c:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80004450:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004454:	5c 58       	castu.b	r8
80004456:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000445a:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000445e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004462:	f1 d9 d0 03 	bfins	r8,r9,0x0,0x3
80004466:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000446a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000446e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004472:	91 a9       	st.w	r8[0x28],r9
}
80004474:	2f dd       	sub	sp,-12
80004476:	e3 cd 80 80 	ldm	sp++,r7,pc
8000447a:	d7 03       	nop

8000447c <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
8000447c:	eb cd 40 80 	pushm	r7,lr
80004480:	1a 97       	mov	r7,sp
80004482:	20 2d       	sub	sp,8
80004484:	ef 4c ff fc 	st.w	r7[-4],r12
80004488:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000448c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004490:	ec 58 bb 9f 	cp.w	r8,899999
80004494:	e0 88 00 1a 	brls	800044c8 <pm_enable_osc0_crystal+0x4c>
80004498:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000449c:	e0 69 c6 bf 	mov	r9,50879
800044a0:	ea 19 00 2d 	orh	r9,0x2d
800044a4:	12 38       	cp.w	r8,r9
800044a6:	e0 88 00 0f 	brls	800044c4 <pm_enable_osc0_crystal+0x48>
800044aa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044ae:	e0 69 11 ff 	mov	r9,4607
800044b2:	ea 19 00 7a 	orh	r9,0x7a
800044b6:	12 38       	cp.w	r8,r9
800044b8:	e0 8b 00 04 	brhi	800044c0 <pm_enable_osc0_crystal+0x44>
800044bc:	30 68       	mov	r8,6
800044be:	c0 28       	rjmp	800044c2 <pm_enable_osc0_crystal+0x46>
800044c0:	30 78       	mov	r8,7
800044c2:	c0 28       	rjmp	800044c6 <pm_enable_osc0_crystal+0x4a>
800044c4:	30 58       	mov	r8,5
800044c6:	c0 28       	rjmp	800044ca <pm_enable_osc0_crystal+0x4e>
800044c8:	30 48       	mov	r8,4
800044ca:	10 9b       	mov	r11,r8
800044cc:	ee fc ff fc 	ld.w	r12,r7[-4]
800044d0:	f0 1f 00 03 	mcall	800044dc <pm_enable_osc0_crystal+0x60>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
800044d4:	2f ed       	sub	sp,-8
800044d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800044da:	00 00       	add	r0,r0
800044dc:	80 00       	ld.sh	r0,r0[0x0]
800044de:	44 30       	lddsp	r0,sp[0x10c]

800044e0 <pm_enable_clk0>:


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800044e0:	eb cd 40 80 	pushm	r7,lr
800044e4:	1a 97       	mov	r7,sp
800044e6:	20 2d       	sub	sp,8
800044e8:	ef 4c ff fc 	st.w	r7[-4],r12
800044ec:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_enable_clk0_no_wait(pm, startup);
800044f0:	ee fb ff f8 	ld.w	r11,r7[-8]
800044f4:	ee fc ff fc 	ld.w	r12,r7[-4]
800044f8:	f0 1f 00 05 	mcall	8000450c <pm_enable_clk0+0x2c>
  pm_wait_for_clk0_ready(pm);
800044fc:	ee fc ff fc 	ld.w	r12,r7[-4]
80004500:	f0 1f 00 04 	mcall	80004510 <pm_enable_clk0+0x30>
}
80004504:	2f ed       	sub	sp,-8
80004506:	e3 cd 80 80 	ldm	sp++,r7,pc
8000450a:	00 00       	add	r0,r0
8000450c:	80 00       	ld.sh	r0,r0[0x0]
8000450e:	45 14       	lddsp	r4,sp[0x144]
80004510:	80 00       	ld.sh	r0,r0[0x0]
80004512:	45 6e       	lddsp	lr,sp[0x158]

80004514 <pm_enable_clk0_no_wait>:
  pm->mcctrl &= ~AVR32_PM_MCCTRL_OSC0EN_MASK;
}


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
80004514:	eb cd 40 80 	pushm	r7,lr
80004518:	1a 97       	mov	r7,sp
8000451a:	20 3d       	sub	sp,12
8000451c:	ef 4c ff f8 	st.w	r7[-8],r12
80004520:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80004524:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004528:	70 a8       	ld.w	r8,r8[0x28]
8000452a:	30 09       	mov	r9,0
8000452c:	ef 49 ff fc 	st.w	r7[-4],r9
80004530:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80004534:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004538:	5c 58       	castu.b	r8
8000453a:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000453e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80004542:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004546:	f1 d9 d1 03 	bfins	r8,r9,0x8,0x3
8000454a:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000454e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004552:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004556:	91 a9       	st.w	r8[0x28],r9

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80004558:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000455c:	70 08       	ld.w	r8,r8[0x0]
8000455e:	10 99       	mov	r9,r8
80004560:	a3 a9       	sbr	r9,0x2
80004562:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004566:	91 09       	st.w	r8[0x0],r9
}
80004568:	2f dd       	sub	sp,-12
8000456a:	e3 cd 80 80 	ldm	sp++,r7,pc

8000456e <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
8000456e:	eb cd 40 80 	pushm	r7,lr
80004572:	1a 97       	mov	r7,sp
80004574:	20 1d       	sub	sp,4
80004576:	ef 4c ff fc 	st.w	r7[-4],r12
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000457a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000457e:	71 58       	ld.w	r8,r8[0x54]
80004580:	e2 18 00 80 	andl	r8,0x80,COH
80004584:	cf b0       	breq	8000457a <pm_wait_for_clk0_ready+0xc>
}
80004586:	2f fd       	sub	sp,-4
80004588:	e3 cd 80 80 	ldm	sp++,r7,pc

8000458c <pm_switch_to_clock>:
  return u_avr32_pm_mcctrl.MCCTRL.mcsel;
}


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
8000458c:	eb cd 40 80 	pushm	r7,lr
80004590:	1a 97       	mov	r7,sp
80004592:	20 3d       	sub	sp,12
80004594:	ef 4c ff f8 	st.w	r7[-8],r12
80004598:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
8000459c:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045a0:	70 08       	ld.w	r8,r8[0x0]
800045a2:	30 09       	mov	r9,0
800045a4:	ef 49 ff fc 	st.w	r7[-4],r9
800045a8:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800045ac:	ee f8 ff f4 	ld.w	r8,r7[-12]
800045b0:	5c 58       	castu.b	r8
800045b2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800045b6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800045ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800045be:	f1 d9 d0 02 	bfins	r8,r9,0x0,0x2
800045c2:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800045c6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800045ca:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045ce:	91 09       	st.w	r8[0x0],r9
}
800045d0:	2f dd       	sub	sp,-12
800045d2:	e3 cd 80 80 	ldm	sp++,r7,pc
800045d6:	d7 03       	nop

800045d8 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800045d8:	eb cd 40 80 	pushm	r7,lr
800045dc:	1a 97       	mov	r7,sp
800045de:	20 3d       	sub	sp,12
800045e0:	ef 4c ff fc 	st.w	r7[-4],r12
800045e4:	ef 4b ff f8 	st.w	r7[-8],r11
800045e8:	ef 4a ff f4 	st.w	r7[-12],r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800045ec:	ee fb ff f8 	ld.w	r11,r7[-8]
800045f0:	ee fc ff fc 	ld.w	r12,r7[-4]
800045f4:	f0 1f 00 08 	mcall	80004614 <pm_switch_to_osc0+0x3c>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800045f8:	ee fb ff f4 	ld.w	r11,r7[-12]
800045fc:	ee fc ff fc 	ld.w	r12,r7[-4]
80004600:	f0 1f 00 06 	mcall	80004618 <pm_switch_to_osc0+0x40>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80004604:	30 1b       	mov	r11,1
80004606:	ee fc ff fc 	ld.w	r12,r7[-4]
8000460a:	f0 1f 00 05 	mcall	8000461c <pm_switch_to_osc0+0x44>
}
8000460e:	2f dd       	sub	sp,-12
80004610:	e3 cd 80 80 	ldm	sp++,r7,pc
80004614:	80 00       	ld.sh	r0,r0[0x0]
80004616:	44 7c       	lddsp	r12,sp[0x11c]
80004618:	80 00       	ld.sh	r0,r0[0x0]
8000461a:	44 e0       	lddsp	r0,sp[0x138]
8000461c:	80 00       	ld.sh	r0,r0[0x0]
8000461e:	45 8c       	lddsp	r12,sp[0x160]

80004620 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80004620:	eb cd 40 80 	pushm	r7,lr
80004624:	1a 97       	mov	r7,sp
80004626:	20 1d       	sub	sp,4
80004628:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
8000462c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004630:	e6 18 00 01 	andh	r8,0x1,COH
80004634:	5f 08       	sreq	r8
80004636:	5c 58       	castu.b	r8
}
80004638:	10 9c       	mov	r12,r8
8000463a:	2f fd       	sub	sp,-4
8000463c:	e3 cd 80 80 	ldm	sp++,r7,pc

80004640 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004640:	eb cd 40 80 	pushm	r7,lr
80004644:	1a 97       	mov	r7,sp
80004646:	20 7d       	sub	sp,28
80004648:	ef 4c ff ec 	st.w	r7[-20],r12
8000464c:	ef 4b ff e8 	st.w	r7[-24],r11
80004650:	ef 4a ff e4 	st.w	r7[-28],r10
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004654:	ee f8 ff e8 	ld.w	r8,r7[-24]
80004658:	f0 09 15 04 	lsl	r9,r8,0x4
8000465c:	ee f8 ff e4 	ld.w	r8,r7[-28]
80004660:	10 39       	cp.w	r9,r8
80004662:	e0 8b 00 04 	brhi	8000466a <usart_set_async_baudrate+0x2a>
80004666:	31 08       	mov	r8,16
80004668:	c0 28       	rjmp	8000466c <usart_set_async_baudrate+0x2c>
8000466a:	30 88       	mov	r8,8
8000466c:	ef 48 ff f0 	st.w	r7[-16],r8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004670:	ee f8 ff e4 	ld.w	r8,r7[-28]
80004674:	f0 09 15 03 	lsl	r9,r8,0x3
80004678:	ee fa ff f0 	ld.w	r10,r7[-16]
8000467c:	ee f8 ff e8 	ld.w	r8,r7[-24]
80004680:	f4 08 02 48 	mul	r8,r10,r8
80004684:	a1 98       	lsr	r8,0x1
80004686:	f2 08 00 08 	add	r8,r9,r8
8000468a:	ee fa ff f0 	ld.w	r10,r7[-16]
8000468e:	ee f9 ff e8 	ld.w	r9,r7[-24]
80004692:	f4 09 02 49 	mul	r9,r10,r9
80004696:	f0 09 0d 08 	divu	r8,r8,r9
8000469a:	ef 48 ff f4 	st.w	r7[-12],r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
8000469e:	ee f8 ff f4 	ld.w	r8,r7[-12]
800046a2:	a3 98       	lsr	r8,0x3
800046a4:	ef 48 ff f8 	st.w	r7[-8],r8
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);
800046a8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800046ac:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800046b0:	ef 48 ff fc 	st.w	r7[-4],r8

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
800046b4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046b8:	58 08       	cp.w	r8,0
800046ba:	c0 70       	breq	800046c8 <usart_set_async_baudrate+0x88>
800046bc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046c0:	e0 48 ff ff 	cp.w	r8,65535
800046c4:	e0 88 00 04 	brls	800046cc <usart_set_async_baudrate+0x8c>
    return USART_INVALID_INPUT;
800046c8:	30 18       	mov	r8,1
800046ca:	c2 08       	rjmp	8000470a <usart_set_async_baudrate+0xca>

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
800046cc:	ee f8 ff ec 	ld.w	r8,r7[-20]
800046d0:	70 18       	ld.w	r8,r8[0x4]
800046d2:	10 99       	mov	r9,r8
800046d4:	e4 19 ff f7 	andh	r9,0xfff7
800046d8:	e0 19 fe cf 	andl	r9,0xfecf
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
800046dc:	ee f8 ff f0 	ld.w	r8,r7[-16]
800046e0:	59 08       	cp.w	r8,16
800046e2:	c0 40       	breq	800046ea <usart_set_async_baudrate+0xaa>
800046e4:	e8 68 00 00 	mov	r8,524288
800046e8:	c0 28       	rjmp	800046ec <usart_set_async_baudrate+0xac>
800046ea:	30 08       	mov	r8,0
800046ec:	10 49       	or	r9,r8
800046ee:	ee f8 ff ec 	ld.w	r8,r7[-20]
800046f2:	91 19       	st.w	r8[0x4],r9
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
                fp << AVR32_USART_BRGR_FP_OFFSET;
800046f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046f8:	f0 09 15 10 	lsl	r9,r8,0x10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
800046fc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004700:	10 49       	or	r9,r8
80004702:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004706:	91 89       	st.w	r8[0x20],r9
                fp << AVR32_USART_BRGR_FP_OFFSET;

  return USART_SUCCESS;
80004708:	30 08       	mov	r8,0
}
8000470a:	10 9c       	mov	r12,r8
8000470c:	2f 9d       	sub	sp,-28
8000470e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004712:	d7 03       	nop

80004714 <usart_reset>:
 */
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
80004714:	eb cd 40 80 	pushm	r7,lr
80004718:	1a 97       	mov	r7,sp
8000471a:	20 2d       	sub	sp,8
8000471c:	ef 4c ff f8 	st.w	r7[-8],r12
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004720:	e1 b8 00 00 	mfsr	r8,0x0
80004724:	10 9c       	mov	r12,r8
80004726:	f0 1f 00 18 	mcall	80004784 <usart_reset+0x70>
8000472a:	18 98       	mov	r8,r12
8000472c:	ef 68 ff ff 	st.b	r7[-1],r8

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80004730:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80004734:	30 08       	mov	r8,0
80004736:	f0 09 18 00 	cp.b	r9,r8
8000473a:	c0 20       	breq	8000473e <usart_reset+0x2a>
8000473c:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
8000473e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004742:	3f f9       	mov	r9,-1
80004744:	91 39       	st.w	r8[0xc],r9
  usart->csr;
80004746:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000474a:	70 58       	ld.w	r8,r8[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
8000474c:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80004750:	30 08       	mov	r8,0
80004752:	f0 09 18 00 	cp.b	r9,r8
80004756:	c0 20       	breq	8000475a <usart_reset+0x46>
80004758:	d5 03       	csrf	0x10

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
8000475a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000475e:	30 09       	mov	r9,0
80004760:	91 19       	st.w	r8[0x4],r9
  usart->rtor = 0;
80004762:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004766:	30 09       	mov	r9,0
80004768:	91 99       	st.w	r8[0x24],r9
  usart->ttgr = 0;
8000476a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000476e:	30 09       	mov	r9,0
80004770:	91 a9       	st.w	r8[0x28],r9

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004772:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004776:	ea 69 61 0c 	mov	r9,680204
8000477a:	91 09       	st.w	r8[0x0],r9
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000477c:	2f ed       	sub	sp,-8
8000477e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004782:	00 00       	add	r0,r0
80004784:	80 00       	ld.sh	r0,r0[0x0]
80004786:	46 20       	lddsp	r0,sp[0x188]

80004788 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004788:	eb cd 40 80 	pushm	r7,lr
8000478c:	1a 97       	mov	r7,sp
8000478e:	20 3d       	sub	sp,12
80004790:	ef 4c ff fc 	st.w	r7[-4],r12
80004794:	ef 4b ff f8 	st.w	r7[-8],r11
80004798:	ef 4a ff f4 	st.w	r7[-12],r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000479c:	ee fc ff fc 	ld.w	r12,r7[-4]
800047a0:	f0 1f 00 54 	mcall	800048f0 <usart_init_rs232+0x168>

  // Check input values.
  if (!opt || // Null pointer.
800047a4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047a8:	58 08       	cp.w	r8,0
800047aa:	c3 90       	breq	8000481c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
800047ac:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047b0:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800047b2:	30 48       	mov	r8,4
800047b4:	f0 09 18 00 	cp.b	r9,r8
800047b8:	e0 88 00 32 	brls	8000481c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
800047bc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047c0:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800047c2:	30 98       	mov	r8,9
800047c4:	f0 09 18 00 	cp.b	r9,r8
800047c8:	e0 8b 00 2a 	brhi	8000481c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
800047cc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047d0:	11 d9       	ld.ub	r9,r8[0x5]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800047d2:	30 78       	mov	r8,7
800047d4:	f0 09 18 00 	cp.b	r9,r8
800047d8:	e0 8b 00 22 	brhi	8000481c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
800047dc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047e0:	90 39       	ld.sh	r9,r8[0x6]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800047e2:	e0 68 01 01 	mov	r8,257
800047e6:	f0 09 19 00 	cp.h	r9,r8
800047ea:	e0 8b 00 19 	brhi	8000481c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
800047ee:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047f2:	f1 39 00 08 	ld.ub	r9,r8[8]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800047f6:	30 38       	mov	r8,3
800047f8:	f0 09 18 00 	cp.b	r9,r8
800047fc:	e0 8b 00 10 	brhi	8000481c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004800:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004804:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004808:	70 08       	ld.w	r8,r8[0x0]
8000480a:	12 9a       	mov	r10,r9
8000480c:	10 9b       	mov	r11,r8
8000480e:	ee fc ff fc 	ld.w	r12,r7[-4]
80004812:	f0 1f 00 39 	mcall	800048f4 <usart_init_rs232+0x16c>
80004816:	18 98       	mov	r8,r12
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004818:	58 18       	cp.w	r8,1
8000481a:	c0 31       	brne	80004820 <usart_init_rs232+0x98>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;
8000481c:	30 18       	mov	r8,1
8000481e:	c6 48       	rjmp	800048e6 <usart_init_rs232+0x15e>

  if (opt->charlength == 9)
80004820:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004824:	11 c9       	ld.ub	r9,r8[0x4]
80004826:	30 98       	mov	r8,9
80004828:	f0 09 18 00 	cp.b	r9,r8
8000482c:	c0 a1       	brne	80004840 <usart_init_rs232+0xb8>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
8000482e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004832:	70 18       	ld.w	r8,r8[0x4]
80004834:	10 99       	mov	r9,r8
80004836:	b1 b9       	sbr	r9,0x11
80004838:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000483c:	91 19       	st.w	r8[0x4],r9
8000483e:	c0 d8       	rjmp	80004858 <usart_init_rs232+0xd0>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004840:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004844:	70 19       	ld.w	r9,r8[0x4]
80004846:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000484a:	11 c8       	ld.ub	r8,r8[0x4]
8000484c:	20 58       	sub	r8,5
8000484e:	a7 68       	lsl	r8,0x6
80004850:	10 49       	or	r9,r8
80004852:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004856:	91 19       	st.w	r8[0x4],r9
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004858:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000485c:	70 19       	ld.w	r9,r8[0x4]
8000485e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004862:	11 d8       	ld.ub	r8,r8[0x5]
80004864:	f0 0a 15 09 	lsl	r10,r8,0x9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;
80004868:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000486c:	f1 38 00 08 	ld.ub	r8,r8[8]
80004870:	af 68       	lsl	r8,0xe
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004872:	f5 e8 10 08 	or	r8,r10,r8
80004876:	10 49       	or	r9,r8
80004878:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000487c:	91 19       	st.w	r8[0x4],r9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
8000487e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004882:	90 39       	ld.sh	r9,r8[0x6]
80004884:	30 28       	mov	r8,2
80004886:	f0 09 19 00 	cp.h	r9,r8
8000488a:	e0 88 00 14 	brls	800048b2 <usart_init_rs232+0x12a>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
8000488e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004892:	70 18       	ld.w	r8,r8[0x4]
80004894:	10 99       	mov	r9,r8
80004896:	ad b9       	sbr	r9,0xd
80004898:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000489c:	91 19       	st.w	r8[0x4],r9
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
8000489e:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048a2:	90 38       	ld.sh	r8,r8[0x6]
800048a4:	5c 78       	castu.h	r8
800048a6:	20 28       	sub	r8,2
800048a8:	10 99       	mov	r9,r8
800048aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800048ae:	91 a9       	st.w	r8[0x28],r9
800048b0:	c0 d8       	rjmp	800048ca <usart_init_rs232+0x142>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800048b2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800048b6:	70 19       	ld.w	r9,r8[0x4]
800048b8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048bc:	90 38       	ld.sh	r8,r8[0x6]
800048be:	5c 78       	castu.h	r8
800048c0:	ad 68       	lsl	r8,0xc
800048c2:	10 49       	or	r9,r8
800048c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800048c8:	91 19       	st.w	r8[0x4],r9

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800048ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
800048ce:	70 18       	ld.w	r8,r8[0x4]
800048d0:	10 99       	mov	r9,r8
800048d2:	e0 19 ff f0 	andl	r9,0xfff0
800048d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800048da:	91 19       	st.w	r8[0x4],r9
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800048dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800048e0:	35 09       	mov	r9,80
800048e2:	91 09       	st.w	r8[0x0],r9
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800048e4:	30 08       	mov	r8,0
}
800048e6:	10 9c       	mov	r12,r8
800048e8:	2f dd       	sub	sp,-12
800048ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800048ee:	00 00       	add	r0,r0
800048f0:	80 00       	ld.sh	r0,r0[0x0]
800048f2:	47 14       	lddsp	r4,sp[0x1c4]
800048f4:	80 00       	ld.sh	r0,r0[0x0]
800048f6:	46 40       	lddsp	r0,sp[0x190]

800048f8 <usart_write_char>:
  return USART_SUCCESS;
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
800048f8:	eb cd 40 80 	pushm	r7,lr
800048fc:	1a 97       	mov	r7,sp
800048fe:	20 3d       	sub	sp,12
80004900:	ef 4c ff f8 	st.w	r7[-8],r12
80004904:	ef 4b ff f4 	st.w	r7[-12],r11
80004908:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000490c:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004910:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004914:	70 58       	ld.w	r8,r8[0x14]
80004916:	e2 18 00 02 	andl	r8,0x2,COH
8000491a:	5f 18       	srne	r8
  if (usart_tx_ready(usart))
8000491c:	58 08       	cp.w	r8,0
8000491e:	c0 a0       	breq	80004932 <usart_write_char+0x3a>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004920:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004924:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80004928:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000492c:	91 79       	st.w	r8[0x1c],r9
    return USART_SUCCESS;
8000492e:	30 08       	mov	r8,0
80004930:	c0 28       	rjmp	80004934 <usart_write_char+0x3c>
  }
  else
    return USART_TX_BUSY;
80004932:	30 28       	mov	r8,2
}
80004934:	10 9c       	mov	r12,r8
80004936:	2f dd       	sub	sp,-12
80004938:	e3 cd 80 80 	ldm	sp++,r7,pc

8000493c <usart_putchar>:


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
8000493c:	eb cd 40 80 	pushm	r7,lr
80004940:	1a 97       	mov	r7,sp
80004942:	20 3d       	sub	sp,12
80004944:	ef 4c ff f8 	st.w	r7[-8],r12
80004948:	ef 4b ff f4 	st.w	r7[-12],r11
  int timeout = USART_DEFAULT_TIMEOUT;
8000494c:	e0 68 27 10 	mov	r8,10000
80004950:	ef 48 ff fc 	st.w	r7[-4],r8

  do
  {
    if (!timeout--) return USART_FAILURE;
80004954:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004958:	58 08       	cp.w	r8,0
8000495a:	5f 08       	sreq	r8
8000495c:	5c 58       	castu.b	r8
8000495e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004962:	20 19       	sub	r9,1
80004964:	ef 49 ff fc 	st.w	r7[-4],r9
80004968:	58 08       	cp.w	r8,0
8000496a:	c0 30       	breq	80004970 <usart_putchar+0x34>
8000496c:	3f f8       	mov	r8,-1
8000496e:	c0 b8       	rjmp	80004984 <usart_putchar+0x48>
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004970:	ee fb ff f4 	ld.w	r11,r7[-12]
80004974:	ee fc ff f8 	ld.w	r12,r7[-8]
80004978:	f0 1f 00 05 	mcall	8000498c <usart_putchar+0x50>
8000497c:	18 98       	mov	r8,r12
8000497e:	58 08       	cp.w	r8,0
80004980:	ce a1       	brne	80004954 <usart_putchar+0x18>

  return USART_SUCCESS;
80004982:	30 08       	mov	r8,0
}
80004984:	10 9c       	mov	r12,r8
80004986:	2f dd       	sub	sp,-12
80004988:	e3 cd 80 80 	ldm	sp++,r7,pc
8000498c:	80 00       	ld.sh	r0,r0[0x0]
8000498e:	48 f8       	lddpc	r8,800049c8 <usart_read_char+0x38>

80004990 <usart_read_char>:


int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
80004990:	eb cd 40 80 	pushm	r7,lr
80004994:	1a 97       	mov	r7,sp
80004996:	20 3d       	sub	sp,12
80004998:	ef 4c ff f8 	st.w	r7[-8],r12
8000499c:	ef 4b ff f4 	st.w	r7[-12],r11
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800049a0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049a4:	70 58       	ld.w	r8,r8[0x14]
800049a6:	e2 18 00 e0 	andl	r8,0xe0,COH
800049aa:	c0 30       	breq	800049b0 <usart_read_char+0x20>
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;
800049ac:	30 48       	mov	r8,4
800049ae:	c1 68       	rjmp	800049da <usart_read_char+0x4a>
800049b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049b4:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800049b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800049bc:	70 58       	ld.w	r8,r8[0x14]
800049be:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800049c2:	c0 b0       	breq	800049d8 <usart_read_char+0x48>
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800049c4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049c8:	70 68       	ld.w	r8,r8[0x18]
800049ca:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
800049ce:	ee f8 ff f4 	ld.w	r8,r7[-12]
800049d2:	91 09       	st.w	r8[0x0],r9
    return USART_SUCCESS;
800049d4:	30 08       	mov	r8,0
800049d6:	c0 28       	rjmp	800049da <usart_read_char+0x4a>
  }
  else
    return USART_RX_EMPTY;
800049d8:	30 38       	mov	r8,3
}
800049da:	10 9c       	mov	r12,r8
800049dc:	2f dd       	sub	sp,-12
800049de:	e3 cd 80 80 	ldm	sp++,r7,pc
800049e2:	d7 03       	nop

800049e4 <usart_getchar>:


int usart_getchar(volatile avr32_usart_t *usart)
{
800049e4:	eb cd 40 80 	pushm	r7,lr
800049e8:	1a 97       	mov	r7,sp
800049ea:	20 3d       	sub	sp,12
800049ec:	ef 4c ff f4 	st.w	r7[-12],r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800049f0:	ee c8 00 08 	sub	r8,r7,8
800049f4:	10 9b       	mov	r11,r8
800049f6:	ee fc ff f4 	ld.w	r12,r7[-12]
800049fa:	f0 1f 00 0b 	mcall	80004a24 <usart_getchar+0x40>
800049fe:	18 98       	mov	r8,r12
80004a00:	ef 48 ff fc 	st.w	r7[-4],r8
80004a04:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a08:	58 38       	cp.w	r8,3
80004a0a:	cf 30       	breq	800049f0 <usart_getchar+0xc>

  if (ret == USART_RX_ERROR)
80004a0c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a10:	58 48       	cp.w	r8,4
80004a12:	c0 31       	brne	80004a18 <usart_getchar+0x34>
    return USART_FAILURE;
80004a14:	3f f8       	mov	r8,-1
80004a16:	c0 38       	rjmp	80004a1c <usart_getchar+0x38>

  return c;
80004a18:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80004a1c:	10 9c       	mov	r12,r8
80004a1e:	2f dd       	sub	sp,-12
80004a20:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a24:	80 00       	ld.sh	r0,r0[0x0]
80004a26:	49 90       	lddpc	r0,80004a88 <vListInitialiseItem+0x14>

80004a28 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
80004a28:	eb cd 40 80 	pushm	r7,lr
80004a2c:	1a 97       	mov	r7,sp
80004a2e:	20 1d       	sub	sp,4
80004a30:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004a34:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a38:	2f 88       	sub	r8,-8
80004a3a:	10 99       	mov	r9,r8
80004a3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a40:	91 19       	st.w	r8[0x4],r9

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004a42:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a46:	3f f9       	mov	r9,-1
80004a48:	91 29       	st.w	r8[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004a4a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a4e:	2f 88       	sub	r8,-8
80004a50:	10 99       	mov	r9,r8
80004a52:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a56:	91 39       	st.w	r8[0xc],r9
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004a58:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a5c:	2f 88       	sub	r8,-8
80004a5e:	10 99       	mov	r9,r8
80004a60:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a64:	91 49       	st.w	r8[0x10],r9

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004a66:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a6a:	30 09       	mov	r9,0
80004a6c:	91 09       	st.w	r8[0x0],r9
}
80004a6e:	2f fd       	sub	sp,-4
80004a70:	e3 cd 80 80 	ldm	sp++,r7,pc

80004a74 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
80004a74:	eb cd 40 80 	pushm	r7,lr
80004a78:	1a 97       	mov	r7,sp
80004a7a:	20 1d       	sub	sp,4
80004a7c:	ef 4c ff fc 	st.w	r7[-4],r12
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004a80:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a84:	30 09       	mov	r9,0
80004a86:	91 49       	st.w	r8[0x10],r9
}
80004a88:	2f fd       	sub	sp,-4
80004a8a:	e3 cd 80 80 	ldm	sp++,r7,pc

80004a8e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
80004a8e:	eb cd 40 80 	pushm	r7,lr
80004a92:	1a 97       	mov	r7,sp
80004a94:	20 3d       	sub	sp,12
80004a96:	ef 4c ff f8 	st.w	r7[-8],r12
80004a9a:	ef 4b ff f4 	st.w	r7[-12],r11

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004a9e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004aa2:	70 18       	ld.w	r8,r8[0x4]
80004aa4:	ef 48 ff fc 	st.w	r7[-4],r8

	pxNewListItem->pxNext = pxIndex->pxNext;
80004aa8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004aac:	70 19       	ld.w	r9,r8[0x4]
80004aae:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004ab2:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004ab4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ab8:	70 19       	ld.w	r9,r8[0x4]
80004aba:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004abe:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004ac0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ac4:	70 18       	ld.w	r8,r8[0x4]
80004ac6:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004aca:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004acc:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004ad0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ad4:	91 19       	st.w	r8[0x4],r9
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004ad6:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004ada:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ade:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004ae0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004ae4:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004ae8:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80004aea:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004aee:	70 08       	ld.w	r8,r8[0x0]
80004af0:	f0 c9 ff ff 	sub	r9,r8,-1
80004af4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004af8:	91 09       	st.w	r8[0x0],r9
}
80004afa:	2f dd       	sub	sp,-12
80004afc:	e3 cd 80 80 	ldm	sp++,r7,pc

80004b00 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
80004b00:	eb cd 40 80 	pushm	r7,lr
80004b04:	1a 97       	mov	r7,sp
80004b06:	20 4d       	sub	sp,16
80004b08:	ef 4c ff f4 	st.w	r7[-12],r12
80004b0c:	ef 4b ff f0 	st.w	r7[-16],r11
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004b10:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004b14:	70 08       	ld.w	r8,r8[0x0]
80004b16:	ef 48 ff fc 	st.w	r7[-4],r8
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004b1a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b1e:	5b f8       	cp.w	r8,-1
80004b20:	c0 71       	brne	80004b2e <vListInsert+0x2e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004b22:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004b26:	70 48       	ld.w	r8,r8[0x10]
80004b28:	ef 48 ff f8 	st.w	r7[-8],r8
80004b2c:	c1 58       	rjmp	80004b56 <vListInsert+0x56>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004b2e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004b32:	2f 88       	sub	r8,-8
80004b34:	ef 48 ff f8 	st.w	r7[-8],r8
80004b38:	c0 68       	rjmp	80004b44 <vListInsert+0x44>
80004b3a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b3e:	70 18       	ld.w	r8,r8[0x4]
80004b40:	ef 48 ff f8 	st.w	r7[-8],r8
80004b44:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b48:	70 18       	ld.w	r8,r8[0x4]
80004b4a:	70 09       	ld.w	r9,r8[0x0]
80004b4c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b50:	10 39       	cp.w	r9,r8
80004b52:	fe 98 ff f4 	brls	80004b3a <vListInsert+0x3a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004b56:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b5a:	70 19       	ld.w	r9,r8[0x4]
80004b5c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004b60:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004b62:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004b66:	70 18       	ld.w	r8,r8[0x4]
80004b68:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004b6c:	91 29       	st.w	r8[0x8],r9
	pxNewListItem->pxPrevious = pxIterator;
80004b6e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004b72:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004b76:	91 29       	st.w	r8[0x8],r9
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004b78:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004b7c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b80:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004b82:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004b86:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004b8a:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80004b8c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004b90:	70 08       	ld.w	r8,r8[0x0]
80004b92:	f0 c9 ff ff 	sub	r9,r8,-1
80004b96:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004b9a:	91 09       	st.w	r8[0x0],r9
}
80004b9c:	2f cd       	sub	sp,-16
80004b9e:	e3 cd 80 80 	ldm	sp++,r7,pc

80004ba2 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
80004ba2:	eb cd 40 80 	pushm	r7,lr
80004ba6:	1a 97       	mov	r7,sp
80004ba8:	20 2d       	sub	sp,8
80004baa:	ef 4c ff f8 	st.w	r7[-8],r12
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004bae:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004bb2:	70 18       	ld.w	r8,r8[0x4]
80004bb4:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004bb8:	72 29       	ld.w	r9,r9[0x8]
80004bba:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004bbc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004bc0:	70 28       	ld.w	r8,r8[0x8]
80004bc2:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004bc6:	72 19       	ld.w	r9,r9[0x4]
80004bc8:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004bca:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004bce:	70 48       	ld.w	r8,r8[0x10]
80004bd0:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004bd4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bd8:	70 19       	ld.w	r9,r8[0x4]
80004bda:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004bde:	10 39       	cp.w	r9,r8
80004be0:	c0 71       	brne	80004bee <vListRemove+0x4c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004be2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004be6:	70 29       	ld.w	r9,r8[0x8]
80004be8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bec:	91 19       	st.w	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004bee:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004bf2:	30 09       	mov	r9,0
80004bf4:	91 49       	st.w	r8[0x10],r9
	( pxList->uxNumberOfItems )--;
80004bf6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bfa:	70 08       	ld.w	r8,r8[0x0]
80004bfc:	f0 c9 00 01 	sub	r9,r8,1
80004c00:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c04:	91 09       	st.w	r8[0x0],r9
}
80004c06:	2f ed       	sub	sp,-8
80004c08:	e3 cd 80 80 	ldm	sp++,r7,pc

80004c0c <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80004c0c:	eb cd 40 80 	pushm	r7,lr
80004c10:	1a 97       	mov	r7,sp
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
80004c12:	48 e8       	lddpc	r8,80004c48 <_init_startup+0x3c>
80004c14:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
80004c18:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
80004c1a:	f0 1f 00 0d 	mcall	80004c4c <_init_startup+0x40>
			.channelmode = USART_NORMAL_CHMODE
		};

		/* Initialize the USART used for the debug trace with the configured parameters. */
		extern volatile avr32_usart_t *volatile stdio_usart_base;
		stdio_usart_base = configDBG_USART;
80004c1e:	48 d8       	lddpc	r8,80004c50 <_init_startup+0x44>
80004c20:	fe 79 18 00 	mov	r9,-59392
80004c24:	91 09       	st.w	r8[0x0],r9
		gpio_enable_module( DBG_USART_GPIO_MAP,
80004c26:	30 2b       	mov	r11,2
80004c28:	48 bc       	lddpc	r12,80004c54 <_init_startup+0x48>
80004c2a:	f0 1f 00 0c 	mcall	80004c58 <_init_startup+0x4c>
		                    sizeof( DBG_USART_GPIO_MAP ) / sizeof( DBG_USART_GPIO_MAP[0] ) );
		usart_init_rs232(configDBG_USART, &DBG_USART_OPTIONS, configPBA_CLOCK_HZ);
80004c2e:	e0 6a 1b 00 	mov	r10,6912
80004c32:	ea 1a 00 b7 	orh	r10,0xb7
80004c36:	48 ab       	lddpc	r11,80004c5c <_init_startup+0x50>
80004c38:	fe 7c 18 00 	mov	r12,-59392
80004c3c:	f0 1f 00 09 	mcall	80004c60 <_init_startup+0x54>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
80004c40:	30 18       	mov	r8,1
}
80004c42:	10 9c       	mov	r12,r8
80004c44:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c48:	80 00       	ld.sh	r0,r0[0x0]
80004c4a:	c4 00       	breq	80004cca <LABEL_INT_SKIP_SAVE_CONTEXT_234+0x6>
80004c4c:	80 00       	ld.sh	r0,r0[0x0]
80004c4e:	42 c4       	lddsp	r4,sp[0xb0]
80004c50:	00 00       	add	r0,r0
80004c52:	07 f8       	ld.ub	r8,r3[0x7]
80004c54:	80 00       	ld.sh	r0,r0[0x0]
80004c56:	c7 14       	brge	80004d38 <SCALLYield+0x18>
80004c58:	80 00       	ld.sh	r0,r0[0x0]
80004c5a:	3f e8       	mov	r8,-2
80004c5c:	80 00       	ld.sh	r0,r0[0x0]
80004c5e:	c7 24       	brge	80004d42 <SCALLYield+0x22>
80004c60:	80 00       	ld.sh	r0,r0[0x0]
80004c62:	47 88       	lddsp	r8,sp[0x1e0]

80004c64 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80004c64:	eb cd 40 80 	pushm	r7,lr
80004c68:	1a 97       	mov	r7,sp
80004c6a:	20 1d       	sub	sp,4
80004c6c:	ef 4c ff fc 	st.w	r7[-4],r12
	vTaskSuspendAll();
80004c70:	f0 1f 00 03 	mcall	80004c7c <__malloc_lock+0x18>
}
80004c74:	2f fd       	sub	sp,-4
80004c76:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c7a:	00 00       	add	r0,r0
80004c7c:	80 00       	ld.sh	r0,r0[0x0]
80004c7e:	5e 5c       	retlt	r12

80004c80 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80004c80:	eb cd 40 80 	pushm	r7,lr
80004c84:	1a 97       	mov	r7,sp
80004c86:	20 1d       	sub	sp,4
80004c88:	ef 4c ff fc 	st.w	r7[-4],r12
	xTaskResumeAll();
80004c8c:	f0 1f 00 03 	mcall	80004c98 <__malloc_unlock+0x18>
}
80004c90:	2f fd       	sub	sp,-4
80004c92:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c96:	00 00       	add	r0,r0
80004c98:	80 00       	ld.sh	r0,r0[0x0]
80004c9a:	5e 78       	retpl	r8

80004c9c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004c9c:	eb cd 00 ff 	pushm	r0-r7
80004ca0:	e0 68 00 20 	mov	r8,32
80004ca4:	ea 18 00 00 	orh	r8,0x0
80004ca8:	70 00       	ld.w	r0,r8[0x0]
80004caa:	1a d0       	st.w	--sp,r0
80004cac:	7a 90       	ld.w	r0,sp[0x24]
80004cae:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004cb2:	58 10       	cp.w	r0,1
80004cb4:	e0 8b 00 08 	brhi	80004cc4 <LABEL_INT_SKIP_SAVE_CONTEXT_234>
80004cb8:	e0 68 06 6c 	mov	r8,1644
80004cbc:	ea 18 00 00 	orh	r8,0x0
80004cc0:	70 00       	ld.w	r0,r8[0x0]
80004cc2:	81 0d       	st.w	r0[0x0],sp

80004cc4 <LABEL_INT_SKIP_SAVE_CONTEXT_234>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80004cc4:	f0 1f 00 12 	mcall	80004d0c <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80004cc8:	f0 1f 00 12 	mcall	80004d10 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
		vTaskIncrementTick();
80004ccc:	f0 1f 00 12 	mcall	80004d14 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x1c>
	portEXIT_CRITICAL();
80004cd0:	f0 1f 00 12 	mcall	80004d18 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80004cd4:	7a 90       	ld.w	r0,sp[0x24]
80004cd6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004cda:	58 10       	cp.w	r0,1
80004cdc:	e0 8b 00 0e 	brhi	80004cf8 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
80004ce0:	f0 1f 00 0c 	mcall	80004d10 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
80004ce4:	f0 1f 00 0e 	mcall	80004d1c <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x24>
80004ce8:	f0 1f 00 0c 	mcall	80004d18 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>
80004cec:	e0 68 06 6c 	mov	r8,1644
80004cf0:	ea 18 00 00 	orh	r8,0x0
80004cf4:	70 00       	ld.w	r0,r8[0x0]
80004cf6:	60 0d       	ld.w	sp,r0[0x0]

80004cf8 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>:
80004cf8:	1b 00       	ld.w	r0,sp++
80004cfa:	e0 68 00 20 	mov	r8,32
80004cfe:	ea 18 00 00 	orh	r8,0x0
80004d02:	91 00       	st.w	r8[0x0],r0
80004d04:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004d08:	d6 03       	rete
80004d0a:	00 00       	add	r0,r0
80004d0c:	80 00       	ld.sh	r0,r0[0x0]
80004d0e:	50 08       	stdsp	sp[0x0],r8
80004d10:	80 00       	ld.sh	r0,r0[0x0]
80004d12:	4d b8       	lddpc	r8,80004e7c <pxPortInitialiseStack+0x7c>
80004d14:	80 00       	ld.sh	r0,r0[0x0]
80004d16:	5f d0       	srvc	r0
80004d18:	80 00       	ld.sh	r0,r0[0x0]
80004d1a:	4d d4       	lddpc	r4,80004e8c <pxPortInitialiseStack+0x8c>
80004d1c:	80 00       	ld.sh	r0,r0[0x0]
80004d1e:	61 30       	ld.w	r0,r0[0x4c]

80004d20 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004d20:	20 6d       	sub	sp,24
80004d22:	eb cd 00 ff 	pushm	r0-r7
80004d26:	fa c7 ff c0 	sub	r7,sp,-64
80004d2a:	ee f0 ff f8 	ld.w	r0,r7[-8]
80004d2e:	ef 40 ff e0 	st.w	r7[-32],r0
80004d32:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004d36:	ef 40 ff e4 	st.w	r7[-28],r0
80004d3a:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80004d3e:	e0 68 00 20 	mov	r8,32
80004d42:	ea 18 00 00 	orh	r8,0x0
80004d46:	70 00       	ld.w	r0,r8[0x0]
80004d48:	1a d0       	st.w	--sp,r0
80004d4a:	f0 1f 00 1a 	mcall	80004db0 <LABEL_RET_SCALL_260+0x14>
80004d4e:	e0 68 06 6c 	mov	r8,1644
80004d52:	ea 18 00 00 	orh	r8,0x0
80004d56:	70 00       	ld.w	r0,r8[0x0]
80004d58:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80004d5a:	f0 1f 00 17 	mcall	80004db4 <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
80004d5e:	e0 68 06 6c 	mov	r8,1644
80004d62:	ea 18 00 00 	orh	r8,0x0
80004d66:	70 00       	ld.w	r0,r8[0x0]
80004d68:	60 0d       	ld.w	sp,r0[0x0]
80004d6a:	1b 00       	ld.w	r0,sp++
80004d6c:	e0 68 00 20 	mov	r8,32
80004d70:	ea 18 00 00 	orh	r8,0x0
80004d74:	91 00       	st.w	r8[0x0],r0
80004d76:	fa c7 ff d8 	sub	r7,sp,-40
80004d7a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80004d7e:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004d82:	e0 61 00 20 	mov	r1,32
80004d86:	ea 11 00 00 	orh	r1,0x0
80004d8a:	62 02       	ld.w	r2,r1[0x0]
80004d8c:	58 02       	cp.w	r2,0
80004d8e:	c0 70       	breq	80004d9c <LABEL_RET_SCALL_260>
80004d90:	e4 c2 00 01 	sub	r2,r2,1
80004d94:	83 02       	st.w	r1[0x0],r2
80004d96:	58 02       	cp.w	r2,0
80004d98:	c0 21       	brne	80004d9c <LABEL_RET_SCALL_260>
80004d9a:	b1 c0       	cbr	r0,0x10

80004d9c <LABEL_RET_SCALL_260>:
80004d9c:	ef 40 ff f8 	st.w	r7[-8],r0
80004da0:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004da4:	ef 40 ff fc 	st.w	r7[-4],r0
80004da8:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004dac:	2f ad       	sub	sp,-24
80004dae:	d6 13       	rets
80004db0:	80 00       	ld.sh	r0,r0[0x0]
80004db2:	4d b8       	lddpc	r8,80004f1c <pxPortInitialiseStack+0x11c>
80004db4:	80 00       	ld.sh	r0,r0[0x0]
80004db6:	61 30       	ld.w	r0,r0[0x4c]

80004db8 <vPortEnterCritical>:
/* The code generated by the GCC compiler uses the stack in different ways at
different optimisation levels.  The interrupt flags can therefore not always
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
80004db8:	eb cd 40 80 	pushm	r7,lr
80004dbc:	1a 97       	mov	r7,sp
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004dbe:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80004dc0:	48 48       	lddpc	r8,80004dd0 <vPortEnterCritical+0x18>
80004dc2:	70 08       	ld.w	r8,r8[0x0]
80004dc4:	f0 c9 ff ff 	sub	r9,r8,-1
80004dc8:	48 28       	lddpc	r8,80004dd0 <vPortEnterCritical+0x18>
80004dca:	91 09       	st.w	r8[0x0],r9
}
80004dcc:	e3 cd 80 80 	ldm	sp++,r7,pc
80004dd0:	00 00       	add	r0,r0
80004dd2:	00 20       	rsub	r0,r0

80004dd4 <vPortExitCritical>:
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
80004dd4:	eb cd 40 80 	pushm	r7,lr
80004dd8:	1a 97       	mov	r7,sp
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004dda:	48 98       	lddpc	r8,80004dfc <vPortExitCritical+0x28>
80004ddc:	70 08       	ld.w	r8,r8[0x0]
80004dde:	58 08       	cp.w	r8,0
80004de0:	c0 c0       	breq	80004df8 <vPortExitCritical+0x24>
	{
		ulCriticalNesting--;
80004de2:	48 78       	lddpc	r8,80004dfc <vPortExitCritical+0x28>
80004de4:	70 08       	ld.w	r8,r8[0x0]
80004de6:	f0 c9 00 01 	sub	r9,r8,1
80004dea:	48 58       	lddpc	r8,80004dfc <vPortExitCritical+0x28>
80004dec:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004dee:	48 48       	lddpc	r8,80004dfc <vPortExitCritical+0x28>
80004df0:	70 08       	ld.w	r8,r8[0x0]
80004df2:	58 08       	cp.w	r8,0
80004df4:	c0 21       	brne	80004df8 <vPortExitCritical+0x24>
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80004df6:	d5 03       	csrf	0x10
		}
	}
}
80004df8:	e3 cd 80 80 	ldm	sp++,r7,pc
80004dfc:	00 00       	add	r0,r0
80004dfe:	00 20       	rsub	r0,r0

80004e00 <pxPortInitialiseStack>:
 * portSAVE_CONTEXT had been called.
 *
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
80004e00:	eb cd 40 80 	pushm	r7,lr
80004e04:	1a 97       	mov	r7,sp
80004e06:	20 3d       	sub	sp,12
80004e08:	ef 4c ff fc 	st.w	r7[-4],r12
80004e0c:	ef 4b ff f8 	st.w	r7[-8],r11
80004e10:	ef 4a ff f4 	st.w	r7[-12],r10
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
80004e14:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e18:	20 48       	sub	r8,4
80004e1a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004e1e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e22:	e0 69 08 08 	mov	r9,2056
80004e26:	ea 19 08 08 	orh	r9,0x808
80004e2a:	91 09       	st.w	r8[0x0],r9
80004e2c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e30:	20 48       	sub	r8,4
80004e32:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80004e36:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e3a:	e0 69 09 09 	mov	r9,2313
80004e3e:	ea 19 09 09 	orh	r9,0x909
80004e42:	91 09       	st.w	r8[0x0],r9
80004e44:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e48:	20 48       	sub	r8,4
80004e4a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004e4e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e52:	e0 69 0a 0a 	mov	r9,2570
80004e56:	ea 19 0a 0a 	orh	r9,0xa0a
80004e5a:	91 09       	st.w	r8[0x0],r9
80004e5c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e60:	20 48       	sub	r8,4
80004e62:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80004e66:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e6a:	e0 69 0b 0b 	mov	r9,2827
80004e6e:	ea 19 0b 0b 	orh	r9,0xb0b
80004e72:	91 09       	st.w	r8[0x0],r9
80004e74:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e78:	20 48       	sub	r8,4
80004e7a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80004e7e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004e82:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e86:	91 09       	st.w	r8[0x0],r9
80004e88:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e8c:	20 48       	sub	r8,4
80004e8e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80004e92:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e96:	e0 69 be ef 	mov	r9,48879
80004e9a:	ea 19 de ad 	orh	r9,0xdead
80004e9e:	91 09       	st.w	r8[0x0],r9
80004ea0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ea4:	20 48       	sub	r8,4
80004ea6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80004eaa:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004eae:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004eb2:	91 09       	st.w	r8[0x0],r9
80004eb4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004eb8:	20 48       	sub	r8,4
80004eba:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80004ebe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ec2:	fc 19 00 40 	movh	r9,0x40
80004ec6:	91 09       	st.w	r8[0x0],r9
80004ec8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ecc:	20 48       	sub	r8,4
80004ece:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80004ed2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ed6:	e0 69 00 ff 	mov	r9,255
80004eda:	ea 19 ff 00 	orh	r9,0xff00
80004ede:	91 09       	st.w	r8[0x0],r9
80004ee0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ee4:	20 48       	sub	r8,4
80004ee6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80004eea:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004eee:	e0 69 01 01 	mov	r9,257
80004ef2:	ea 19 01 01 	orh	r9,0x101
80004ef6:	91 09       	st.w	r8[0x0],r9
80004ef8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004efc:	20 48       	sub	r8,4
80004efe:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004f02:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f06:	e0 69 02 02 	mov	r9,514
80004f0a:	ea 19 02 02 	orh	r9,0x202
80004f0e:	91 09       	st.w	r8[0x0],r9
80004f10:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f14:	20 48       	sub	r8,4
80004f16:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80004f1a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f1e:	e0 69 03 03 	mov	r9,771
80004f22:	ea 19 03 03 	orh	r9,0x303
80004f26:	91 09       	st.w	r8[0x0],r9
80004f28:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f2c:	20 48       	sub	r8,4
80004f2e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80004f32:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f36:	e0 69 04 04 	mov	r9,1028
80004f3a:	ea 19 04 04 	orh	r9,0x404
80004f3e:	91 09       	st.w	r8[0x0],r9
80004f40:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f44:	20 48       	sub	r8,4
80004f46:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004f4a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f4e:	e0 69 05 05 	mov	r9,1285
80004f52:	ea 19 05 05 	orh	r9,0x505
80004f56:	91 09       	st.w	r8[0x0],r9
80004f58:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f5c:	20 48       	sub	r8,4
80004f5e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80004f62:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f66:	e0 69 06 06 	mov	r9,1542
80004f6a:	ea 19 06 06 	orh	r9,0x606
80004f6e:	91 09       	st.w	r8[0x0],r9
80004f70:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f74:	20 48       	sub	r8,4
80004f76:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80004f7a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f7e:	e0 69 07 07 	mov	r9,1799
80004f82:	ea 19 07 07 	orh	r9,0x707
80004f86:	91 09       	st.w	r8[0x0],r9
80004f88:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f8c:	20 48       	sub	r8,4
80004f8e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004f92:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f96:	30 09       	mov	r9,0
80004f98:	91 09       	st.w	r8[0x0],r9

	return pxTopOfStack;
80004f9a:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80004f9e:	10 9c       	mov	r12,r8
80004fa0:	2f dd       	sub	sp,-12
80004fa2:	e3 cd 80 80 	ldm	sp++,r7,pc
80004fa6:	d7 03       	nop

80004fa8 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80004fa8:	eb cd 40 80 	pushm	r7,lr
80004fac:	1a 97       	mov	r7,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
80004fae:	f0 1f 00 10 	mcall	80004fec <xPortStartScheduler+0x44>

	/* Start the first task. */
	portRESTORE_CONTEXT();
80004fb2:	e0 68 06 6c 	mov	r8,1644
80004fb6:	ea 18 00 00 	orh	r8,0x0
80004fba:	70 00       	ld.w	r0,r8[0x0]
80004fbc:	60 0d       	ld.w	sp,r0[0x0]
80004fbe:	1b 00       	ld.w	r0,sp++
80004fc0:	e0 68 00 20 	mov	r8,32
80004fc4:	ea 18 00 00 	orh	r8,0x0
80004fc8:	91 00       	st.w	r8[0x0],r0
80004fca:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004fce:	2f ed       	sub	sp,-8
80004fd0:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80004fd4:	fa f0 ff e0 	ld.w	r0,sp[-32]
80004fd8:	e3 b0 00 00 	mtsr	0x0,r0
80004fdc:	fa f0 ff dc 	ld.w	r0,sp[-36]
80004fe0:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
80004fe4:	30 08       	mov	r8,0
}
80004fe6:	10 9c       	mov	r12,r8
80004fe8:	e3 cd 80 80 	ldm	sp++,r7,pc
80004fec:	80 00       	ld.sh	r0,r0[0x0]
80004fee:	50 1c       	stdsp	sp[0x4],r12

80004ff0 <prvScheduleFirstTick>:

/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
80004ff0:	eb cd 40 80 	pushm	r7,lr
80004ff4:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
80004ff6:	e0 68 2e e0 	mov	r8,12000
80004ffa:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80004ffe:	30 08       	mov	r8,0
80005000:	e3 b8 00 42 	mtsr	0x108,r8
	}
80005004:	e3 cd 80 80 	ldm	sp++,r7,pc

80005008 <prvClearCcInt>:

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
80005008:	eb cd 40 80 	pushm	r7,lr
8000500c:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
8000500e:	e1 b8 00 43 	mfsr	r8,0x10c
80005012:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005016:	e3 cd 80 80 	ldm	sp++,r7,pc
8000501a:	d7 03       	nop

8000501c <prvSetupTimerInterrupt>:
#endif
/*-----------------------------------------------------------*/

/* Setup the timer to generate the tick interrupts. */
static void prvSetupTimerInterrupt(void)
{
8000501c:	eb cd 40 80 	pushm	r7,lr
80005020:	1a 97       	mov	r7,sp
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005022:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005024:	30 0a       	mov	r10,0
80005026:	30 0b       	mov	r11,0
80005028:	48 4c       	lddpc	r12,80005038 <prvSetupTimerInterrupt+0x1c>
8000502a:	f0 1f 00 05 	mcall	8000503c <prvSetupTimerInterrupt+0x20>
		prvScheduleFirstTick();
8000502e:	f0 1f 00 05 	mcall	80005040 <prvSetupTimerInterrupt+0x24>
	}
	#endif
}
80005032:	e3 cd 80 80 	ldm	sp++,r7,pc
80005036:	00 00       	add	r0,r0
80005038:	80 00       	ld.sh	r0,r0[0x0]
8000503a:	4c 9c       	lddpc	r12,8000515c <_write+0x8c>
8000503c:	80 00       	ld.sh	r0,r0[0x0]
8000503e:	43 5c       	lddsp	r12,sp[0xd4]
80005040:	80 00       	ld.sh	r0,r0[0x0]
80005042:	4f f0       	lddpc	r0,8000523c <xQueueCreate+0x68>

80005044 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005044:	eb cd 40 80 	pushm	r7,lr
80005048:	1a 97       	mov	r7,sp
8000504a:	20 5d       	sub	sp,20
8000504c:	ef 4c ff f4 	st.w	r7[-12],r12
80005050:	ef 4b ff f0 	st.w	r7[-16],r11
80005054:	ef 4a ff ec 	st.w	r7[-20],r10
  int nChars = 0;
80005058:	30 08       	mov	r8,0
8000505a:	ef 48 ff f8 	st.w	r7[-8],r8

  if (file != 0)
8000505e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005062:	58 08       	cp.w	r8,0
80005064:	c2 40       	breq	800050ac <_read+0x68>
    return -1;
80005066:	3f f8       	mov	r8,-1
80005068:	c2 b8       	rjmp	800050be <_read+0x7a>

  for (; len > 0; --len)
  {
    int c = usart_getchar(stdio_usart_base);
8000506a:	49 88       	lddpc	r8,800050c8 <_read+0x84>
8000506c:	70 08       	ld.w	r8,r8[0x0]
8000506e:	10 9c       	mov	r12,r8
80005070:	f0 1f 00 17 	mcall	800050cc <_read+0x88>
80005074:	18 98       	mov	r8,r12
80005076:	ef 48 ff fc 	st.w	r7[-4],r8
    if (c < 0)
8000507a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000507e:	58 08       	cp.w	r8,0
80005080:	c1 c5       	brlt	800050b8 <_read+0x74>
      break;

    *ptr++ = c;
80005082:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005086:	5c 58       	castu.b	r8
80005088:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000508c:	b2 88       	st.b	r9[0x0],r8
8000508e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005092:	2f f8       	sub	r8,-1
80005094:	ef 48 ff f0 	st.w	r7[-16],r8
    ++nChars;
80005098:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000509c:	2f f8       	sub	r8,-1
8000509e:	ef 48 ff f8 	st.w	r7[-8],r8
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
800050a2:	ee f8 ff ec 	ld.w	r8,r7[-20]
800050a6:	20 18       	sub	r8,1
800050a8:	ef 48 ff ec 	st.w	r7[-20],r8
800050ac:	ee f8 ff ec 	ld.w	r8,r7[-20]
800050b0:	58 08       	cp.w	r8,0
800050b2:	fe 99 ff dc 	brgt	8000506a <_read+0x26>
800050b6:	c0 28       	rjmp	800050ba <_read+0x76>
  {
    int c = usart_getchar(stdio_usart_base);
    if (c < 0)
      break;
800050b8:	d7 03       	nop

    *ptr++ = c;
    ++nChars;
  }

  return nChars;
800050ba:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800050be:	10 9c       	mov	r12,r8
800050c0:	2f bd       	sub	sp,-20
800050c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800050c6:	00 00       	add	r0,r0
800050c8:	00 00       	add	r0,r0
800050ca:	07 f8       	ld.ub	r8,r3[0x7]
800050cc:	80 00       	ld.sh	r0,r0[0x0]
800050ce:	49 e4       	lddpc	r4,80005144 <_write+0x74>

800050d0 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
800050d0:	eb cd 40 80 	pushm	r7,lr
800050d4:	1a 97       	mov	r7,sp
800050d6:	20 4d       	sub	sp,16
800050d8:	ef 4c ff f8 	st.w	r7[-8],r12
800050dc:	ef 4b ff f4 	st.w	r7[-12],r11
800050e0:	ef 4a ff f0 	st.w	r7[-16],r10
  int nChars = 0;
800050e4:	30 08       	mov	r8,0
800050e6:	ef 48 ff fc 	st.w	r7[-4],r8

  if ( (file != 1)
800050ea:	ee f8 ff f8 	ld.w	r8,r7[-8]
800050ee:	58 18       	cp.w	r8,1
800050f0:	c2 90       	breq	80005142 <_write+0x72>
800050f2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800050f6:	58 28       	cp.w	r8,2
800050f8:	c2 50       	breq	80005142 <_write+0x72>
800050fa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800050fe:	58 38       	cp.w	r8,3
80005100:	c2 10       	breq	80005142 <_write+0x72>
       && (file != 2) && (file!=3))
    return -1;
80005102:	3f f8       	mov	r8,-1
80005104:	c2 58       	rjmp	8000514e <_write+0x7e>

  for (; len != 0; --len)
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005106:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000510a:	11 88       	ld.ub	r8,r8[0x0]
8000510c:	10 99       	mov	r9,r8
8000510e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005112:	2f f8       	sub	r8,-1
80005114:	ef 48 ff f4 	st.w	r7[-12],r8
80005118:	49 08       	lddpc	r8,80005158 <_write+0x88>
8000511a:	70 08       	ld.w	r8,r8[0x0]
8000511c:	12 9b       	mov	r11,r9
8000511e:	10 9c       	mov	r12,r8
80005120:	f0 1f 00 0f 	mcall	8000515c <_write+0x8c>
80005124:	18 98       	mov	r8,r12
80005126:	58 08       	cp.w	r8,0
80005128:	c0 34       	brge	8000512e <_write+0x5e>
    {
      return -1;
8000512a:	3f f8       	mov	r8,-1
8000512c:	c1 18       	rjmp	8000514e <_write+0x7e>
    }

    ++nChars;
8000512e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005132:	2f f8       	sub	r8,-1
80005134:	ef 48 ff fc 	st.w	r7[-4],r8

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005138:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000513c:	20 18       	sub	r8,1
8000513e:	ef 48 ff f0 	st.w	r7[-16],r8
80005142:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005146:	58 08       	cp.w	r8,0
80005148:	cd f1       	brne	80005106 <_write+0x36>
    }

    ++nChars;
  }

  return nChars;
8000514a:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000514e:	10 9c       	mov	r12,r8
80005150:	2f cd       	sub	sp,-16
80005152:	e3 cd 80 80 	ldm	sp++,r7,pc
80005156:	00 00       	add	r0,r0
80005158:	00 00       	add	r0,r0
8000515a:	07 f8       	ld.ub	r8,r3[0x7]
8000515c:	80 00       	ld.sh	r0,r0[0x0]
8000515e:	49 3c       	lddpc	r12,800051a8 <vPortFree+0xc>

80005160 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005160:	eb cd 40 80 	pushm	r7,lr
80005164:	1a 97       	mov	r7,sp
80005166:	20 2d       	sub	sp,8
80005168:	ef 4c ff f8 	st.w	r7[-8],r12
void *pvReturn;

	vTaskSuspendAll();
8000516c:	f0 1f 00 09 	mcall	80005190 <pvPortMalloc+0x30>
	{
		pvReturn = malloc( xWantedSize );
80005170:	ee fc ff f8 	ld.w	r12,r7[-8]
80005174:	f0 1f 00 08 	mcall	80005194 <pvPortMalloc+0x34>
80005178:	18 98       	mov	r8,r12
8000517a:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	xTaskResumeAll();
8000517e:	f0 1f 00 07 	mcall	80005198 <pvPortMalloc+0x38>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
80005182:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005186:	10 9c       	mov	r12,r8
80005188:	2f ed       	sub	sp,-8
8000518a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000518e:	00 00       	add	r0,r0
80005190:	80 00       	ld.sh	r0,r0[0x0]
80005192:	5e 5c       	retlt	r12
80005194:	80 00       	ld.sh	r0,r0[0x0]
80005196:	6a 04       	ld.w	r4,r5[0x0]
80005198:	80 00       	ld.sh	r0,r0[0x0]
8000519a:	5e 78       	retpl	r8

8000519c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
8000519c:	eb cd 40 80 	pushm	r7,lr
800051a0:	1a 97       	mov	r7,sp
800051a2:	20 1d       	sub	sp,4
800051a4:	ef 4c ff fc 	st.w	r7[-4],r12
	if( pv )
800051a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051ac:	58 08       	cp.w	r8,0
800051ae:	c0 90       	breq	800051c0 <vPortFree+0x24>
	{
		vTaskSuspendAll();
800051b0:	f0 1f 00 06 	mcall	800051c8 <vPortFree+0x2c>
		{
			free( pv );
800051b4:	ee fc ff fc 	ld.w	r12,r7[-4]
800051b8:	f0 1f 00 05 	mcall	800051cc <vPortFree+0x30>
		}
		xTaskResumeAll();
800051bc:	f0 1f 00 05 	mcall	800051d0 <vPortFree+0x34>
	}
}
800051c0:	2f fd       	sub	sp,-4
800051c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800051c6:	00 00       	add	r0,r0
800051c8:	80 00       	ld.sh	r0,r0[0x0]
800051ca:	5e 5c       	retlt	r12
800051cc:	80 00       	ld.sh	r0,r0[0x0]
800051ce:	69 f4       	ld.w	r4,r4[0x7c]
800051d0:	80 00       	ld.sh	r0,r0[0x0]
800051d2:	5e 78       	retpl	r8

800051d4 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800051d4:	eb cd 40 80 	pushm	r7,lr
800051d8:	1a 97       	mov	r7,sp
800051da:	20 5d       	sub	sp,20
800051dc:	ef 4c ff f0 	st.w	r7[-16],r12
800051e0:	ef 4b ff ec 	st.w	r7[-20],r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
800051e4:	30 08       	mov	r8,0
800051e6:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800051ea:	ee f8 ff f0 	ld.w	r8,r7[-16]
800051ee:	58 08       	cp.w	r8,0
800051f0:	c7 20       	breq	800052d4 <xQueueCreate+0x100>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800051f2:	34 cc       	mov	r12,76
800051f4:	f0 1f 00 3b 	mcall	800052e0 <xQueueCreate+0x10c>
800051f8:	18 98       	mov	r8,r12
800051fa:	ef 48 ff f4 	st.w	r7[-12],r8
		if( pxNewQueue != NULL )
800051fe:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005202:	58 08       	cp.w	r8,0
80005204:	c6 80       	breq	800052d4 <xQueueCreate+0x100>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005206:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000520a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000520e:	f2 08 02 48 	mul	r8,r9,r8
80005212:	2f f8       	sub	r8,-1
80005214:	ef 48 ff f8 	st.w	r7[-8],r8

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005218:	ee fc ff f8 	ld.w	r12,r7[-8]
8000521c:	f0 1f 00 31 	mcall	800052e0 <xQueueCreate+0x10c>
80005220:	18 98       	mov	r8,r12
80005222:	10 99       	mov	r9,r8
80005224:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005228:	91 09       	st.w	r8[0x0],r9
			if( pxNewQueue->pcHead != NULL )
8000522a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000522e:	70 08       	ld.w	r8,r8[0x0]
80005230:	58 08       	cp.w	r8,0
80005232:	c4 d0       	breq	800052cc <xQueueCreate+0xf8>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005234:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005238:	70 09       	ld.w	r9,r8[0x0]
8000523a:	ee fa ff f0 	ld.w	r10,r7[-16]
8000523e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005242:	f4 08 02 48 	mul	r8,r10,r8
80005246:	10 09       	add	r9,r8
80005248:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000524c:	91 19       	st.w	r8[0x4],r9
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000524e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005252:	30 09       	mov	r9,0
80005254:	91 e9       	st.w	r8[0x38],r9
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005256:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000525a:	70 09       	ld.w	r9,r8[0x0]
8000525c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005260:	91 29       	st.w	r8[0x8],r9
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005262:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005266:	70 09       	ld.w	r9,r8[0x0]
80005268:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000526c:	f0 ca 00 01 	sub	r10,r8,1
80005270:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005274:	f4 08 02 48 	mul	r8,r10,r8
80005278:	10 09       	add	r9,r8
8000527a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000527e:	91 39       	st.w	r8[0xc],r9
				pxNewQueue->uxLength = uxQueueLength;
80005280:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005284:	ee f9 ff f0 	ld.w	r9,r7[-16]
80005288:	91 f9       	st.w	r8[0x3c],r9
				pxNewQueue->uxItemSize = uxItemSize;
8000528a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000528e:	ee f9 ff ec 	ld.w	r9,r7[-20]
80005292:	f1 49 00 40 	st.w	r8[64],r9
				pxNewQueue->xRxLock = queueUNLOCKED;
80005296:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000529a:	3f f9       	mov	r9,-1
8000529c:	f1 49 00 44 	st.w	r8[68],r9
				pxNewQueue->xTxLock = queueUNLOCKED;
800052a0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800052a4:	3f f9       	mov	r9,-1
800052a6:	f1 49 00 48 	st.w	r8[72],r9

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800052aa:	ee f8 ff f4 	ld.w	r8,r7[-12]
800052ae:	2f 08       	sub	r8,-16
800052b0:	10 9c       	mov	r12,r8
800052b2:	f0 1f 00 0d 	mcall	800052e4 <xQueueCreate+0x110>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800052b6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800052ba:	2d c8       	sub	r8,-36
800052bc:	10 9c       	mov	r12,r8
800052be:	f0 1f 00 0a 	mcall	800052e4 <xQueueCreate+0x110>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
800052c2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800052c6:	ef 48 ff fc 	st.w	r7[-4],r8
800052ca:	c0 58       	rjmp	800052d4 <xQueueCreate+0x100>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800052cc:	ee fc ff f4 	ld.w	r12,r7[-12]
800052d0:	f0 1f 00 06 	mcall	800052e8 <xQueueCreate+0x114>
		}
	}

	configASSERT( xReturn );

	return xReturn;
800052d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800052d8:	10 9c       	mov	r12,r8
800052da:	2f bd       	sub	sp,-20
800052dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800052e0:	80 00       	ld.sh	r0,r0[0x0]
800052e2:	51 60       	stdsp	sp[0x58],r0
800052e4:	80 00       	ld.sh	r0,r0[0x0]
800052e6:	4a 28       	lddpc	r8,8000536c <xQueueGenericSend+0x80>
800052e8:	80 00       	ld.sh	r0,r0[0x0]
800052ea:	51 9c       	stdsp	sp[0x64],r12

800052ec <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800052ec:	eb cd 40 80 	pushm	r7,lr
800052f0:	1a 97       	mov	r7,sp
800052f2:	20 7d       	sub	sp,28
800052f4:	ef 4c ff f0 	st.w	r7[-16],r12
800052f8:	ef 4b ff ec 	st.w	r7[-20],r11
800052fc:	ef 4a ff e8 	st.w	r7[-24],r10
80005300:	ef 49 ff e4 	st.w	r7[-28],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
80005304:	30 08       	mov	r8,0
80005306:	ef 48 ff fc 	st.w	r7[-4],r8
8000530a:	c0 28       	rjmp	8000530e <xQueueGenericSend+0x22>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
8000530c:	d7 03       	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000530e:	f0 1f 00 47 	mcall	80005428 <xQueueGenericSend+0x13c>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005312:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005316:	70 e9       	ld.w	r9,r8[0x38]
80005318:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000531c:	70 f8       	ld.w	r8,r8[0x3c]
8000531e:	10 39       	cp.w	r9,r8
80005320:	c1 c2       	brcc	80005358 <xQueueGenericSend+0x6c>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005322:	ee fa ff e4 	ld.w	r10,r7[-28]
80005326:	ee fb ff ec 	ld.w	r11,r7[-20]
8000532a:	ee fc ff f0 	ld.w	r12,r7[-16]
8000532e:	f0 1f 00 40 	mcall	8000542c <xQueueGenericSend+0x140>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005332:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005336:	70 98       	ld.w	r8,r8[0x24]
80005338:	58 08       	cp.w	r8,0
8000533a:	c0 b0       	breq	80005350 <xQueueGenericSend+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
8000533c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005340:	2d c8       	sub	r8,-36
80005342:	10 9c       	mov	r12,r8
80005344:	f0 1f 00 3b 	mcall	80005430 <xQueueGenericSend+0x144>
80005348:	18 98       	mov	r8,r12
8000534a:	58 18       	cp.w	r8,1
8000534c:	c0 21       	brne	80005350 <xQueueGenericSend+0x64>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
8000534e:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005350:	f0 1f 00 39 	mcall	80005434 <xQueueGenericSend+0x148>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005354:	30 18       	mov	r8,1
80005356:	c6 58       	rjmp	80005420 <xQueueGenericSend+0x134>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005358:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000535c:	58 08       	cp.w	r8,0
8000535e:	c0 51       	brne	80005368 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005360:	f0 1f 00 35 	mcall	80005434 <xQueueGenericSend+0x148>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005364:	30 08       	mov	r8,0
80005366:	c5 d8       	rjmp	80005420 <xQueueGenericSend+0x134>
				}
				else if( xEntryTimeSet == pdFALSE )
80005368:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000536c:	58 08       	cp.w	r8,0
8000536e:	c0 91       	brne	80005380 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005370:	ee c8 00 0c 	sub	r8,r7,12
80005374:	10 9c       	mov	r12,r8
80005376:	f0 1f 00 31 	mcall	80005438 <xQueueGenericSend+0x14c>
					xEntryTimeSet = pdTRUE;
8000537a:	30 18       	mov	r8,1
8000537c:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}
		}
		taskEXIT_CRITICAL();
80005380:	f0 1f 00 2d 	mcall	80005434 <xQueueGenericSend+0x148>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005384:	f0 1f 00 2e 	mcall	8000543c <xQueueGenericSend+0x150>
		prvLockQueue( pxQueue );
80005388:	f0 1f 00 28 	mcall	80005428 <xQueueGenericSend+0x13c>
8000538c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005390:	71 18       	ld.w	r8,r8[0x44]
80005392:	5b f8       	cp.w	r8,-1
80005394:	c0 61       	brne	800053a0 <xQueueGenericSend+0xb4>
80005396:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000539a:	30 09       	mov	r9,0
8000539c:	f1 49 00 44 	st.w	r8[68],r9
800053a0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800053a4:	71 28       	ld.w	r8,r8[0x48]
800053a6:	5b f8       	cp.w	r8,-1
800053a8:	c0 61       	brne	800053b4 <xQueueGenericSend+0xc8>
800053aa:	ee f8 ff f0 	ld.w	r8,r7[-16]
800053ae:	30 09       	mov	r9,0
800053b0:	f1 49 00 48 	st.w	r8[72],r9
800053b4:	f0 1f 00 20 	mcall	80005434 <xQueueGenericSend+0x148>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800053b8:	ee c9 00 18 	sub	r9,r7,24
800053bc:	ee c8 00 0c 	sub	r8,r7,12
800053c0:	12 9b       	mov	r11,r9
800053c2:	10 9c       	mov	r12,r8
800053c4:	f0 1f 00 1f 	mcall	80005440 <xQueueGenericSend+0x154>
800053c8:	18 98       	mov	r8,r12
800053ca:	58 08       	cp.w	r8,0
800053cc:	c2 31       	brne	80005412 <xQueueGenericSend+0x126>
		{
			if( prvIsQueueFull( pxQueue ) )
800053ce:	ee fc ff f0 	ld.w	r12,r7[-16]
800053d2:	f0 1f 00 1d 	mcall	80005444 <xQueueGenericSend+0x158>
800053d6:	18 98       	mov	r8,r12
800053d8:	58 08       	cp.w	r8,0
800053da:	c1 50       	breq	80005404 <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800053dc:	ee f9 ff e8 	ld.w	r9,r7[-24]
800053e0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800053e4:	2f 08       	sub	r8,-16
800053e6:	12 9b       	mov	r11,r9
800053e8:	10 9c       	mov	r12,r8
800053ea:	f0 1f 00 18 	mcall	80005448 <xQueueGenericSend+0x15c>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800053ee:	ee fc ff f0 	ld.w	r12,r7[-16]
800053f2:	f0 1f 00 17 	mcall	8000544c <xQueueGenericSend+0x160>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800053f6:	f0 1f 00 17 	mcall	80005450 <xQueueGenericSend+0x164>
800053fa:	18 98       	mov	r8,r12
800053fc:	58 08       	cp.w	r8,0
800053fe:	c8 71       	brne	8000530c <xQueueGenericSend+0x20>
				{
					portYIELD_WITHIN_API();
80005400:	d7 33       	scall
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80005402:	c8 6b       	rjmp	8000530e <xQueueGenericSend+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005404:	ee fc ff f0 	ld.w	r12,r7[-16]
80005408:	f0 1f 00 11 	mcall	8000544c <xQueueGenericSend+0x160>
				( void ) xTaskResumeAll();
8000540c:	f0 1f 00 11 	mcall	80005450 <xQueueGenericSend+0x164>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80005410:	c7 fb       	rjmp	8000530e <xQueueGenericSend+0x22>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005412:	ee fc ff f0 	ld.w	r12,r7[-16]
80005416:	f0 1f 00 0e 	mcall	8000544c <xQueueGenericSend+0x160>
			( void ) xTaskResumeAll();
8000541a:	f0 1f 00 0e 	mcall	80005450 <xQueueGenericSend+0x164>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
8000541e:	30 08       	mov	r8,0
		}
	}
}
80005420:	10 9c       	mov	r12,r8
80005422:	2f 9d       	sub	sp,-28
80005424:	e3 cd 80 80 	ldm	sp++,r7,pc
80005428:	80 00       	ld.sh	r0,r0[0x0]
8000542a:	4d b8       	lddpc	r8,80005594 <xQueueGenericReceive+0x140>
8000542c:	80 00       	ld.sh	r0,r0[0x0]
8000542e:	56 00       	stdsp	sp[0x180],r0
80005430:	80 00       	ld.sh	r0,r0[0x0]
80005432:	62 60       	ld.w	r0,r1[0x18]
80005434:	80 00       	ld.sh	r0,r0[0x0]
80005436:	4d d4       	lddpc	r4,800055a8 <xQueueGenericReceive+0x154>
80005438:	80 00       	ld.sh	r0,r0[0x0]
8000543a:	63 30       	ld.w	r0,r1[0x4c]
8000543c:	80 00       	ld.sh	r0,r0[0x0]
8000543e:	5e 5c       	retlt	r12
80005440:	80 00       	ld.sh	r0,r0[0x0]
80005442:	63 60       	ld.w	r0,r1[0x58]
80005444:	80 00       	ld.sh	r0,r0[0x0]
80005446:	58 54       	cp.w	r4,5
80005448:	80 00       	ld.sh	r0,r0[0x0]
8000544a:	61 e0       	ld.w	r0,r0[0x78]
8000544c:	80 00       	ld.sh	r0,r0[0x0]
8000544e:	57 4c       	stdsp	sp[0x1d0],r12
80005450:	80 00       	ld.sh	r0,r0[0x0]
80005452:	5e 78       	retpl	r8

80005454 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005454:	eb cd 40 80 	pushm	r7,lr
80005458:	1a 97       	mov	r7,sp
8000545a:	20 8d       	sub	sp,32
8000545c:	ef 4c ff ec 	st.w	r7[-20],r12
80005460:	ef 4b ff e8 	st.w	r7[-24],r11
80005464:	ef 4a ff e4 	st.w	r7[-28],r10
80005468:	ef 49 ff e0 	st.w	r7[-32],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
8000546c:	30 08       	mov	r8,0
8000546e:	ef 48 ff f8 	st.w	r7[-8],r8
80005472:	c0 28       	rjmp	80005476 <xQueueGenericReceive+0x22>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
80005474:	d7 03       	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005476:	f0 1f 00 58 	mcall	800055d4 <xQueueGenericReceive+0x180>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000547a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000547e:	70 e8       	ld.w	r8,r8[0x38]
80005480:	58 08       	cp.w	r8,0
80005482:	c4 00       	breq	80005502 <xQueueGenericReceive+0xae>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005484:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005488:	70 38       	ld.w	r8,r8[0xc]
8000548a:	ef 48 ff fc 	st.w	r7[-4],r8

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000548e:	ee fb ff e8 	ld.w	r11,r7[-24]
80005492:	ee fc ff ec 	ld.w	r12,r7[-20]
80005496:	f0 1f 00 51 	mcall	800055d8 <xQueueGenericReceive+0x184>

				if( xJustPeeking == pdFALSE )
8000549a:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000549e:	58 08       	cp.w	r8,0
800054a0:	c1 91       	brne	800054d2 <xQueueGenericReceive+0x7e>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800054a2:	ee f8 ff ec 	ld.w	r8,r7[-20]
800054a6:	70 e8       	ld.w	r8,r8[0x38]
800054a8:	f0 c9 00 01 	sub	r9,r8,1
800054ac:	ee f8 ff ec 	ld.w	r8,r7[-20]
800054b0:	91 e9       	st.w	r8[0x38],r9
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800054b2:	ee f8 ff ec 	ld.w	r8,r7[-20]
800054b6:	70 48       	ld.w	r8,r8[0x10]
800054b8:	58 08       	cp.w	r8,0
800054ba:	c2 00       	breq	800054fa <xQueueGenericReceive+0xa6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800054bc:	ee f8 ff ec 	ld.w	r8,r7[-20]
800054c0:	2f 08       	sub	r8,-16
800054c2:	10 9c       	mov	r12,r8
800054c4:	f0 1f 00 46 	mcall	800055dc <xQueueGenericReceive+0x188>
800054c8:	18 98       	mov	r8,r12
800054ca:	58 18       	cp.w	r8,1
800054cc:	c1 71       	brne	800054fa <xQueueGenericReceive+0xa6>
						{
							portYIELD_WITHIN_API();
800054ce:	d7 33       	scall
800054d0:	c1 58       	rjmp	800054fa <xQueueGenericReceive+0xa6>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800054d2:	ee f8 ff ec 	ld.w	r8,r7[-20]
800054d6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800054da:	91 39       	st.w	r8[0xc],r9

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800054dc:	ee f8 ff ec 	ld.w	r8,r7[-20]
800054e0:	70 98       	ld.w	r8,r8[0x24]
800054e2:	58 08       	cp.w	r8,0
800054e4:	c0 b0       	breq	800054fa <xQueueGenericReceive+0xa6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800054e6:	ee f8 ff ec 	ld.w	r8,r7[-20]
800054ea:	2d c8       	sub	r8,-36
800054ec:	10 9c       	mov	r12,r8
800054ee:	f0 1f 00 3c 	mcall	800055dc <xQueueGenericReceive+0x188>
800054f2:	18 98       	mov	r8,r12
800054f4:	58 08       	cp.w	r8,0
800054f6:	c0 20       	breq	800054fa <xQueueGenericReceive+0xa6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800054f8:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800054fa:	f0 1f 00 3a 	mcall	800055e0 <xQueueGenericReceive+0x18c>
				return pdPASS;
800054fe:	30 18       	mov	r8,1
80005500:	c6 68       	rjmp	800055cc <xQueueGenericReceive+0x178>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005502:	ee f8 ff e4 	ld.w	r8,r7[-28]
80005506:	58 08       	cp.w	r8,0
80005508:	c0 51       	brne	80005512 <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000550a:	f0 1f 00 36 	mcall	800055e0 <xQueueGenericReceive+0x18c>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000550e:	30 08       	mov	r8,0
80005510:	c5 e8       	rjmp	800055cc <xQueueGenericReceive+0x178>
				}
				else if( xEntryTimeSet == pdFALSE )
80005512:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005516:	58 08       	cp.w	r8,0
80005518:	c0 91       	brne	8000552a <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000551a:	ee c8 00 10 	sub	r8,r7,16
8000551e:	10 9c       	mov	r12,r8
80005520:	f0 1f 00 31 	mcall	800055e4 <xQueueGenericReceive+0x190>
					xEntryTimeSet = pdTRUE;
80005524:	30 18       	mov	r8,1
80005526:	ef 48 ff f8 	st.w	r7[-8],r8
				}
			}
		}
		taskEXIT_CRITICAL();
8000552a:	f0 1f 00 2e 	mcall	800055e0 <xQueueGenericReceive+0x18c>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000552e:	f0 1f 00 2f 	mcall	800055e8 <xQueueGenericReceive+0x194>
		prvLockQueue( pxQueue );
80005532:	f0 1f 00 29 	mcall	800055d4 <xQueueGenericReceive+0x180>
80005536:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000553a:	71 18       	ld.w	r8,r8[0x44]
8000553c:	5b f8       	cp.w	r8,-1
8000553e:	c0 61       	brne	8000554a <xQueueGenericReceive+0xf6>
80005540:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005544:	30 09       	mov	r9,0
80005546:	f1 49 00 44 	st.w	r8[68],r9
8000554a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000554e:	71 28       	ld.w	r8,r8[0x48]
80005550:	5b f8       	cp.w	r8,-1
80005552:	c0 61       	brne	8000555e <xQueueGenericReceive+0x10a>
80005554:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005558:	30 09       	mov	r9,0
8000555a:	f1 49 00 48 	st.w	r8[72],r9
8000555e:	f0 1f 00 21 	mcall	800055e0 <xQueueGenericReceive+0x18c>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005562:	ee c9 00 1c 	sub	r9,r7,28
80005566:	ee c8 00 10 	sub	r8,r7,16
8000556a:	12 9b       	mov	r11,r9
8000556c:	10 9c       	mov	r12,r8
8000556e:	f0 1f 00 20 	mcall	800055ec <xQueueGenericReceive+0x198>
80005572:	18 98       	mov	r8,r12
80005574:	58 08       	cp.w	r8,0
80005576:	c2 41       	brne	800055be <xQueueGenericReceive+0x16a>
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005578:	ee fc ff ec 	ld.w	r12,r7[-20]
8000557c:	f0 1f 00 1d 	mcall	800055f0 <xQueueGenericReceive+0x19c>
80005580:	18 98       	mov	r8,r12
80005582:	58 08       	cp.w	r8,0
80005584:	c1 60       	breq	800055b0 <xQueueGenericReceive+0x15c>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005586:	ee f9 ff e4 	ld.w	r9,r7[-28]
8000558a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000558e:	2d c8       	sub	r8,-36
80005590:	12 9b       	mov	r11,r9
80005592:	10 9c       	mov	r12,r8
80005594:	f0 1f 00 18 	mcall	800055f4 <xQueueGenericReceive+0x1a0>
				prvUnlockQueue( pxQueue );
80005598:	ee fc ff ec 	ld.w	r12,r7[-20]
8000559c:	f0 1f 00 17 	mcall	800055f8 <xQueueGenericReceive+0x1a4>
				if( !xTaskResumeAll() )
800055a0:	f0 1f 00 17 	mcall	800055fc <xQueueGenericReceive+0x1a8>
800055a4:	18 98       	mov	r8,r12
800055a6:	58 08       	cp.w	r8,0
800055a8:	fe 91 ff 66 	brne	80005474 <xQueueGenericReceive+0x20>
				{
					portYIELD_WITHIN_API();
800055ac:	d7 33       	scall
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800055ae:	c6 4b       	rjmp	80005476 <xQueueGenericReceive+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800055b0:	ee fc ff ec 	ld.w	r12,r7[-20]
800055b4:	f0 1f 00 11 	mcall	800055f8 <xQueueGenericReceive+0x1a4>
				( void ) xTaskResumeAll();
800055b8:	f0 1f 00 11 	mcall	800055fc <xQueueGenericReceive+0x1a8>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800055bc:	c5 db       	rjmp	80005476 <xQueueGenericReceive+0x22>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800055be:	ee fc ff ec 	ld.w	r12,r7[-20]
800055c2:	f0 1f 00 0e 	mcall	800055f8 <xQueueGenericReceive+0x1a4>
			( void ) xTaskResumeAll();
800055c6:	f0 1f 00 0e 	mcall	800055fc <xQueueGenericReceive+0x1a8>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
800055ca:	30 08       	mov	r8,0
		}
	}
}
800055cc:	10 9c       	mov	r12,r8
800055ce:	2f 8d       	sub	sp,-32
800055d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800055d4:	80 00       	ld.sh	r0,r0[0x0]
800055d6:	4d b8       	lddpc	r8,80005740 <prvCopyDataFromQueue+0x60>
800055d8:	80 00       	ld.sh	r0,r0[0x0]
800055da:	56 e0       	stdsp	sp[0x1b8],r0
800055dc:	80 00       	ld.sh	r0,r0[0x0]
800055de:	62 60       	ld.w	r0,r1[0x18]
800055e0:	80 00       	ld.sh	r0,r0[0x0]
800055e2:	4d d4       	lddpc	r4,80005754 <prvUnlockQueue+0x8>
800055e4:	80 00       	ld.sh	r0,r0[0x0]
800055e6:	63 30       	ld.w	r0,r1[0x4c]
800055e8:	80 00       	ld.sh	r0,r0[0x0]
800055ea:	5e 5c       	retlt	r12
800055ec:	80 00       	ld.sh	r0,r0[0x0]
800055ee:	63 60       	ld.w	r0,r1[0x58]
800055f0:	80 00       	ld.sh	r0,r0[0x0]
800055f2:	58 1c       	cp.w	r12,1
800055f4:	80 00       	ld.sh	r0,r0[0x0]
800055f6:	61 e0       	ld.w	r0,r0[0x78]
800055f8:	80 00       	ld.sh	r0,r0[0x0]
800055fa:	57 4c       	stdsp	sp[0x1d0],r12
800055fc:	80 00       	ld.sh	r0,r0[0x0]
800055fe:	5e 78       	retpl	r8

80005600 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005600:	eb cd 40 80 	pushm	r7,lr
80005604:	1a 97       	mov	r7,sp
80005606:	20 3d       	sub	sp,12
80005608:	ef 4c ff fc 	st.w	r7[-4],r12
8000560c:	ef 4b ff f8 	st.w	r7[-8],r11
80005610:	ef 4a ff f4 	st.w	r7[-12],r10
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005614:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005618:	71 08       	ld.w	r8,r8[0x40]
8000561a:	58 08       	cp.w	r8,0
8000561c:	c5 40       	breq	800056c4 <prvCopyDataToQueue+0xc4>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000561e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005622:	58 08       	cp.w	r8,0
80005624:	c2 61       	brne	80005670 <prvCopyDataToQueue+0x70>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005626:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000562a:	71 09       	ld.w	r9,r8[0x40]
8000562c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005630:	70 28       	ld.w	r8,r8[0x8]
80005632:	12 9a       	mov	r10,r9
80005634:	ee fb ff f8 	ld.w	r11,r7[-8]
80005638:	10 9c       	mov	r12,r8
8000563a:	f0 1f 00 29 	mcall	800056dc <prvCopyDataToQueue+0xdc>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000563e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005642:	70 29       	ld.w	r9,r8[0x8]
80005644:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005648:	71 08       	ld.w	r8,r8[0x40]
8000564a:	10 09       	add	r9,r8
8000564c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005650:	91 29       	st.w	r8[0x8],r9
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005652:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005656:	70 29       	ld.w	r9,r8[0x8]
80005658:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000565c:	70 18       	ld.w	r8,r8[0x4]
8000565e:	10 39       	cp.w	r9,r8
80005660:	c3 23       	brcs	800056c4 <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005662:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005666:	70 09       	ld.w	r9,r8[0x0]
80005668:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000566c:	91 29       	st.w	r8[0x8],r9
8000566e:	c2 b8       	rjmp	800056c4 <prvCopyDataToQueue+0xc4>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005670:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005674:	71 09       	ld.w	r9,r8[0x40]
80005676:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000567a:	70 38       	ld.w	r8,r8[0xc]
8000567c:	12 9a       	mov	r10,r9
8000567e:	ee fb ff f8 	ld.w	r11,r7[-8]
80005682:	10 9c       	mov	r12,r8
80005684:	f0 1f 00 16 	mcall	800056dc <prvCopyDataToQueue+0xdc>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005688:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000568c:	70 39       	ld.w	r9,r8[0xc]
8000568e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005692:	71 08       	ld.w	r8,r8[0x40]
80005694:	5c 38       	neg	r8
80005696:	10 09       	add	r9,r8
80005698:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000569c:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000569e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056a2:	70 39       	ld.w	r9,r8[0xc]
800056a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056a8:	70 08       	ld.w	r8,r8[0x0]
800056aa:	10 39       	cp.w	r9,r8
800056ac:	c0 c2       	brcc	800056c4 <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800056ae:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056b2:	70 19       	ld.w	r9,r8[0x4]
800056b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056b8:	71 08       	ld.w	r8,r8[0x40]
800056ba:	5c 38       	neg	r8
800056bc:	10 09       	add	r9,r8
800056be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056c2:	91 39       	st.w	r8[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800056c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056c8:	70 e8       	ld.w	r8,r8[0x38]
800056ca:	f0 c9 ff ff 	sub	r9,r8,-1
800056ce:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056d2:	91 e9       	st.w	r8[0x38],r9
}
800056d4:	2f dd       	sub	sp,-12
800056d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800056da:	00 00       	add	r0,r0
800056dc:	80 00       	ld.sh	r0,r0[0x0]
800056de:	6e 4c       	ld.w	r12,r7[0x10]

800056e0 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800056e0:	eb cd 40 80 	pushm	r7,lr
800056e4:	1a 97       	mov	r7,sp
800056e6:	20 2d       	sub	sp,8
800056e8:	ef 4c ff fc 	st.w	r7[-4],r12
800056ec:	ef 4b ff f8 	st.w	r7[-8],r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800056f0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056f4:	70 08       	ld.w	r8,r8[0x0]
800056f6:	58 08       	cp.w	r8,0
800056f8:	c2 50       	breq	80005742 <prvCopyDataFromQueue+0x62>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
800056fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056fe:	70 39       	ld.w	r9,r8[0xc]
80005700:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005704:	71 08       	ld.w	r8,r8[0x40]
80005706:	10 09       	add	r9,r8
80005708:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000570c:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
8000570e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005712:	70 39       	ld.w	r9,r8[0xc]
80005714:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005718:	70 18       	ld.w	r8,r8[0x4]
8000571a:	10 39       	cp.w	r9,r8
8000571c:	c0 73       	brcs	8000572a <prvCopyDataFromQueue+0x4a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000571e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005722:	70 09       	ld.w	r9,r8[0x0]
80005724:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005728:	91 39       	st.w	r8[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
8000572a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000572e:	71 09       	ld.w	r9,r8[0x40]
80005730:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005734:	70 38       	ld.w	r8,r8[0xc]
80005736:	12 9a       	mov	r10,r9
80005738:	10 9b       	mov	r11,r8
8000573a:	ee fc ff f8 	ld.w	r12,r7[-8]
8000573e:	f0 1f 00 03 	mcall	80005748 <prvCopyDataFromQueue+0x68>
	}
}
80005742:	2f ed       	sub	sp,-8
80005744:	e3 cd 80 80 	ldm	sp++,r7,pc
80005748:	80 00       	ld.sh	r0,r0[0x0]
8000574a:	6e 4c       	ld.w	r12,r7[0x10]

8000574c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
8000574c:	eb cd 40 80 	pushm	r7,lr
80005750:	1a 97       	mov	r7,sp
80005752:	20 1d       	sub	sp,4
80005754:	ef 4c ff fc 	st.w	r7[-4],r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005758:	f0 1f 00 2d 	mcall	8000580c <prvUnlockQueue+0xc0>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000575c:	c1 a8       	rjmp	80005790 <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000575e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005762:	70 98       	ld.w	r8,r8[0x24]
80005764:	58 08       	cp.w	r8,0
80005766:	c1 c0       	breq	8000579e <prvUnlockQueue+0x52>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005768:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000576c:	2d c8       	sub	r8,-36
8000576e:	10 9c       	mov	r12,r8
80005770:	f0 1f 00 28 	mcall	80005810 <prvUnlockQueue+0xc4>
80005774:	18 98       	mov	r8,r12
80005776:	58 08       	cp.w	r8,0
80005778:	c0 30       	breq	8000577e <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
8000577a:	f0 1f 00 27 	mcall	80005814 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xTxLock );
8000577e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005782:	71 28       	ld.w	r8,r8[0x48]
80005784:	f0 c9 00 01 	sub	r9,r8,1
80005788:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000578c:	f1 49 00 48 	st.w	r8[72],r9
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005790:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005794:	71 28       	ld.w	r8,r8[0x48]
80005796:	58 08       	cp.w	r8,0
80005798:	fe 99 ff e3 	brgt	8000575e <prvUnlockQueue+0x12>
8000579c:	c0 28       	rjmp	800057a0 <prvUnlockQueue+0x54>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
8000579e:	d7 03       	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800057a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800057a4:	3f f9       	mov	r9,-1
800057a6:	f1 49 00 48 	st.w	r8[72],r9
	}
	taskEXIT_CRITICAL();
800057aa:	f0 1f 00 1c 	mcall	80005818 <prvUnlockQueue+0xcc>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800057ae:	f0 1f 00 18 	mcall	8000580c <prvUnlockQueue+0xc0>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800057b2:	c1 a8       	rjmp	800057e6 <prvUnlockQueue+0x9a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800057b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800057b8:	70 48       	ld.w	r8,r8[0x10]
800057ba:	58 08       	cp.w	r8,0
800057bc:	c1 c0       	breq	800057f4 <prvUnlockQueue+0xa8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800057be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800057c2:	2f 08       	sub	r8,-16
800057c4:	10 9c       	mov	r12,r8
800057c6:	f0 1f 00 13 	mcall	80005810 <prvUnlockQueue+0xc4>
800057ca:	18 98       	mov	r8,r12
800057cc:	58 08       	cp.w	r8,0
800057ce:	c0 30       	breq	800057d4 <prvUnlockQueue+0x88>
				{
					vTaskMissedYield();
800057d0:	f0 1f 00 11 	mcall	80005814 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xRxLock );
800057d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800057d8:	71 18       	ld.w	r8,r8[0x44]
800057da:	f0 c9 00 01 	sub	r9,r8,1
800057de:	ee f8 ff fc 	ld.w	r8,r7[-4]
800057e2:	f1 49 00 44 	st.w	r8[68],r9
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800057e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800057ea:	71 18       	ld.w	r8,r8[0x44]
800057ec:	58 08       	cp.w	r8,0
800057ee:	fe 99 ff e3 	brgt	800057b4 <prvUnlockQueue+0x68>
800057f2:	c0 28       	rjmp	800057f6 <prvUnlockQueue+0xaa>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
800057f4:	d7 03       	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800057f6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800057fa:	3f f9       	mov	r9,-1
800057fc:	f1 49 00 44 	st.w	r8[68],r9
	}
	taskEXIT_CRITICAL();
80005800:	f0 1f 00 06 	mcall	80005818 <prvUnlockQueue+0xcc>
}
80005804:	2f fd       	sub	sp,-4
80005806:	e3 cd 80 80 	ldm	sp++,r7,pc
8000580a:	00 00       	add	r0,r0
8000580c:	80 00       	ld.sh	r0,r0[0x0]
8000580e:	4d b8       	lddpc	r8,80005978 <xTaskGenericCreate+0xe0>
80005810:	80 00       	ld.sh	r0,r0[0x0]
80005812:	62 60       	ld.w	r0,r1[0x18]
80005814:	80 00       	ld.sh	r0,r0[0x0]
80005816:	64 18       	ld.w	r8,r2[0x4]
80005818:	80 00       	ld.sh	r0,r0[0x0]
8000581a:	4d d4       	lddpc	r4,8000598c <xTaskGenericCreate+0xf4>

8000581c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
8000581c:	eb cd 40 80 	pushm	r7,lr
80005820:	1a 97       	mov	r7,sp
80005822:	20 2d       	sub	sp,8
80005824:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005828:	f0 1f 00 09 	mcall	8000584c <prvIsQueueEmpty+0x30>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
8000582c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005830:	70 e8       	ld.w	r8,r8[0x38]
80005832:	58 08       	cp.w	r8,0
80005834:	5f 08       	sreq	r8
80005836:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
8000583a:	f0 1f 00 06 	mcall	80005850 <prvIsQueueEmpty+0x34>

	return xReturn;
8000583e:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005842:	10 9c       	mov	r12,r8
80005844:	2f ed       	sub	sp,-8
80005846:	e3 cd 80 80 	ldm	sp++,r7,pc
8000584a:	00 00       	add	r0,r0
8000584c:	80 00       	ld.sh	r0,r0[0x0]
8000584e:	4d b8       	lddpc	r8,800059b8 <xTaskGenericCreate+0x120>
80005850:	80 00       	ld.sh	r0,r0[0x0]
80005852:	4d d4       	lddpc	r4,800059c4 <xTaskGenericCreate+0x12c>

80005854 <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
80005854:	eb cd 40 80 	pushm	r7,lr
80005858:	1a 97       	mov	r7,sp
8000585a:	20 2d       	sub	sp,8
8000585c:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005860:	f0 1f 00 0a 	mcall	80005888 <prvIsQueueFull+0x34>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005864:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005868:	70 e9       	ld.w	r9,r8[0x38]
8000586a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000586e:	70 f8       	ld.w	r8,r8[0x3c]
80005870:	10 39       	cp.w	r9,r8
80005872:	5f 08       	sreq	r8
80005874:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80005878:	f0 1f 00 05 	mcall	8000588c <prvIsQueueFull+0x38>

	return xReturn;
8000587c:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005880:	10 9c       	mov	r12,r8
80005882:	2f ed       	sub	sp,-8
80005884:	e3 cd 80 80 	ldm	sp++,r7,pc
80005888:	80 00       	ld.sh	r0,r0[0x0]
8000588a:	4d b8       	lddpc	r8,800059f4 <xTaskGenericCreate+0x15c>
8000588c:	80 00       	ld.sh	r0,r0[0x0]
8000588e:	4d d4       	lddpc	r4,80005a00 <xTaskGenericCreate+0x168>
80005890:	49 44       	lddpc	r4,800058e0 <xTaskGenericCreate+0x48>
80005892:	4c 45       	lddpc	r5,800059a0 <xTaskGenericCreate+0x108>
80005894:	00 00       	add	r0,r0
	...

80005898 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005898:	eb cd 40 c0 	pushm	r6-r7,lr
8000589c:	1a 97       	mov	r7,sp
8000589e:	20 8d       	sub	sp,32
800058a0:	ee c6 ff f4 	sub	r6,r7,-12
800058a4:	ef 4c ff f0 	st.w	r7[-16],r12
800058a8:	ef 4b ff ec 	st.w	r7[-20],r11
800058ac:	ef 49 ff e4 	st.w	r7[-28],r9
800058b0:	ef 48 ff e0 	st.w	r7[-32],r8
800058b4:	14 98       	mov	r8,r10
800058b6:	ef 58 ff e8 	st.h	r7[-24],r8
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
800058ba:	ef 18 ff e8 	ld.uh	r8,r7[-24]
800058be:	6c 1b       	ld.w	r11,r6[0x4]
800058c0:	10 9c       	mov	r12,r8
800058c2:	f0 1f 00 5a 	mcall	80005a28 <xTaskGenericCreate+0x190>
800058c6:	18 98       	mov	r8,r12
800058c8:	ef 48 ff f8 	st.w	r7[-8],r8

	if( pxNewTCB != NULL )
800058cc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800058d0:	58 08       	cp.w	r8,0
800058d2:	e0 80 00 92 	breq	800059f6 <xTaskGenericCreate+0x15e>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
800058d6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800058da:	70 c9       	ld.w	r9,r8[0x30]
800058dc:	ef 18 ff e8 	ld.uh	r8,r7[-24]
800058e0:	20 18       	sub	r8,1
800058e2:	a3 68       	lsl	r8,0x2
800058e4:	f2 08 00 08 	add	r8,r9,r8
800058e8:	ef 48 ff fc 	st.w	r7[-4],r8
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800058ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058f0:	e0 18 ff fc 	andl	r8,0xfffc
800058f4:	ef 48 ff fc 	st.w	r7[-4],r8
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
800058f8:	ef 18 ff e8 	ld.uh	r8,r7[-24]
800058fc:	6c 29       	ld.w	r9,r6[0x8]
800058fe:	ee fa ff e0 	ld.w	r10,r7[-32]
80005902:	ee fb ff ec 	ld.w	r11,r7[-20]
80005906:	ee fc ff f8 	ld.w	r12,r7[-8]
8000590a:	f0 1f 00 49 	mcall	80005a2c <xTaskGenericCreate+0x194>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
8000590e:	ee fa ff e4 	ld.w	r10,r7[-28]
80005912:	ee fb ff f0 	ld.w	r11,r7[-16]
80005916:	ee fc ff fc 	ld.w	r12,r7[-4]
8000591a:	f0 1f 00 46 	mcall	80005a30 <xTaskGenericCreate+0x198>
8000591e:	18 98       	mov	r8,r12
80005920:	10 99       	mov	r9,r8
80005922:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005926:	91 09       	st.w	r8[0x0],r9
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
80005928:	6c 08       	ld.w	r8,r6[0x0]
8000592a:	58 08       	cp.w	r8,0
8000592c:	c0 50       	breq	80005936 <xTaskGenericCreate+0x9e>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
8000592e:	6c 08       	ld.w	r8,r6[0x0]
80005930:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005934:	91 09       	st.w	r8[0x0],r9
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005936:	f0 1f 00 40 	mcall	80005a34 <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
8000593a:	4c 08       	lddpc	r8,80005a38 <xTaskGenericCreate+0x1a0>
8000593c:	70 08       	ld.w	r8,r8[0x0]
8000593e:	f0 c9 ff ff 	sub	r9,r8,-1
80005942:	4b e8       	lddpc	r8,80005a38 <xTaskGenericCreate+0x1a0>
80005944:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005946:	4b e8       	lddpc	r8,80005a3c <xTaskGenericCreate+0x1a4>
80005948:	70 08       	ld.w	r8,r8[0x0]
8000594a:	58 08       	cp.w	r8,0
8000594c:	c0 c1       	brne	80005964 <xTaskGenericCreate+0xcc>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
8000594e:	4b c8       	lddpc	r8,80005a3c <xTaskGenericCreate+0x1a4>
80005950:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005954:	91 09       	st.w	r8[0x0],r9

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005956:	4b 98       	lddpc	r8,80005a38 <xTaskGenericCreate+0x1a0>
80005958:	70 08       	ld.w	r8,r8[0x0]
8000595a:	58 18       	cp.w	r8,1
8000595c:	c1 41       	brne	80005984 <xTaskGenericCreate+0xec>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
8000595e:	f0 1f 00 39 	mcall	80005a40 <xTaskGenericCreate+0x1a8>
80005962:	c1 18       	rjmp	80005984 <xTaskGenericCreate+0xec>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005964:	4b 88       	lddpc	r8,80005a44 <xTaskGenericCreate+0x1ac>
80005966:	70 08       	ld.w	r8,r8[0x0]
80005968:	58 08       	cp.w	r8,0
8000596a:	c0 d1       	brne	80005984 <xTaskGenericCreate+0xec>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
8000596c:	4b 48       	lddpc	r8,80005a3c <xTaskGenericCreate+0x1a4>
8000596e:	70 08       	ld.w	r8,r8[0x0]
80005970:	70 b9       	ld.w	r9,r8[0x2c]
80005972:	ee f8 ff e0 	ld.w	r8,r7[-32]
80005976:	10 39       	cp.w	r9,r8
80005978:	e0 8b 00 06 	brhi	80005984 <xTaskGenericCreate+0xec>
					{
						pxCurrentTCB = pxNewTCB;
8000597c:	4b 08       	lddpc	r8,80005a3c <xTaskGenericCreate+0x1a4>
8000597e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005982:	91 09       	st.w	r8[0x0],r9
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005984:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005988:	70 b9       	ld.w	r9,r8[0x2c]
8000598a:	4b 08       	lddpc	r8,80005a48 <xTaskGenericCreate+0x1b0>
8000598c:	70 08       	ld.w	r8,r8[0x0]
8000598e:	10 39       	cp.w	r9,r8
80005990:	e0 88 00 07 	brls	8000599e <xTaskGenericCreate+0x106>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005994:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005998:	70 b9       	ld.w	r9,r8[0x2c]
8000599a:	4a c8       	lddpc	r8,80005a48 <xTaskGenericCreate+0x1b0>
8000599c:	91 09       	st.w	r8[0x0],r9
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
8000599e:	4a c8       	lddpc	r8,80005a4c <xTaskGenericCreate+0x1b4>
800059a0:	70 08       	ld.w	r8,r8[0x0]
800059a2:	f0 c9 ff ff 	sub	r9,r8,-1
800059a6:	4a a8       	lddpc	r8,80005a4c <xTaskGenericCreate+0x1b4>
800059a8:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
800059aa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800059ae:	70 b9       	ld.w	r9,r8[0x2c]
800059b0:	4a 88       	lddpc	r8,80005a50 <xTaskGenericCreate+0x1b8>
800059b2:	70 08       	ld.w	r8,r8[0x0]
800059b4:	10 39       	cp.w	r9,r8
800059b6:	e0 88 00 07 	brls	800059c4 <xTaskGenericCreate+0x12c>
800059ba:	ee f8 ff f8 	ld.w	r8,r7[-8]
800059be:	70 b9       	ld.w	r9,r8[0x2c]
800059c0:	4a 48       	lddpc	r8,80005a50 <xTaskGenericCreate+0x1b8>
800059c2:	91 09       	st.w	r8[0x0],r9
800059c4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800059c8:	f0 ca ff fc 	sub	r10,r8,-4
800059cc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800059d0:	70 b9       	ld.w	r9,r8[0x2c]
800059d2:	12 98       	mov	r8,r9
800059d4:	a3 68       	lsl	r8,0x2
800059d6:	12 08       	add	r8,r9
800059d8:	a3 68       	lsl	r8,0x2
800059da:	10 99       	mov	r9,r8
800059dc:	49 e8       	lddpc	r8,80005a54 <xTaskGenericCreate+0x1bc>
800059de:	f2 08 00 08 	add	r8,r9,r8
800059e2:	14 9b       	mov	r11,r10
800059e4:	10 9c       	mov	r12,r8
800059e6:	f0 1f 00 1d 	mcall	80005a58 <xTaskGenericCreate+0x1c0>

			xReturn = pdPASS;
800059ea:	30 18       	mov	r8,1
800059ec:	ef 48 ff f4 	st.w	r7[-12],r8
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800059f0:	f0 1f 00 1b 	mcall	80005a5c <xTaskGenericCreate+0x1c4>
800059f4:	c0 48       	rjmp	800059fc <xTaskGenericCreate+0x164>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
800059f6:	3f f8       	mov	r8,-1
800059f8:	ef 48 ff f4 	st.w	r7[-12],r8
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
800059fc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005a00:	58 18       	cp.w	r8,1
80005a02:	c0 d1       	brne	80005a1c <xTaskGenericCreate+0x184>
	{
		if( xSchedulerRunning != pdFALSE )
80005a04:	49 08       	lddpc	r8,80005a44 <xTaskGenericCreate+0x1ac>
80005a06:	70 08       	ld.w	r8,r8[0x0]
80005a08:	58 08       	cp.w	r8,0
80005a0a:	c0 90       	breq	80005a1c <xTaskGenericCreate+0x184>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005a0c:	48 c8       	lddpc	r8,80005a3c <xTaskGenericCreate+0x1a4>
80005a0e:	70 08       	ld.w	r8,r8[0x0]
80005a10:	70 b9       	ld.w	r9,r8[0x2c]
80005a12:	ee f8 ff e0 	ld.w	r8,r7[-32]
80005a16:	10 39       	cp.w	r9,r8
80005a18:	c0 22       	brcc	80005a1c <xTaskGenericCreate+0x184>
			{
				portYIELD_WITHIN_API();
80005a1a:	d7 33       	scall
			}
		}
	}

	return xReturn;
80005a1c:	ee f8 ff f4 	ld.w	r8,r7[-12]
}
80005a20:	10 9c       	mov	r12,r8
80005a22:	2f 8d       	sub	sp,-32
80005a24:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005a28:	80 00       	ld.sh	r0,r0[0x0]
80005a2a:	66 a0       	ld.w	r0,r3[0x28]
80005a2c:	80 00       	ld.sh	r0,r0[0x0]
80005a2e:	64 58       	ld.w	r8,r2[0x14]
80005a30:	80 00       	ld.sh	r0,r0[0x0]
80005a32:	4e 00       	lddpc	r0,80005bb0 <vTaskPrioritySet+0xdc>
80005a34:	80 00       	ld.sh	r0,r0[0x0]
80005a36:	4d b8       	lddpc	r8,80005ba0 <vTaskPrioritySet+0xcc>
80005a38:	00 00       	add	r0,r0
80005a3a:	07 80       	ld.ub	r0,r3[0x0]
80005a3c:	00 00       	add	r0,r0
80005a3e:	06 6c       	and	r12,r3
80005a40:	80 00       	ld.sh	r0,r0[0x0]
80005a42:	64 f4       	ld.w	r4,r2[0x3c]
80005a44:	00 00       	add	r0,r0
80005a46:	07 90       	ld.ub	r0,r3[0x1]
80005a48:	00 00       	add	r0,r0
80005a4a:	07 88       	ld.ub	r8,r3[0x0]
80005a4c:	00 00       	add	r0,r0
80005a4e:	07 a4       	ld.ub	r4,r3[0x2]
80005a50:	00 00       	add	r0,r0
80005a52:	07 8c       	ld.ub	r12,r3[0x0]
80005a54:	00 00       	add	r0,r0
80005a56:	06 70       	tst	r0,r3
80005a58:	80 00       	ld.sh	r0,r0[0x0]
80005a5a:	4a 8e       	lddpc	lr,80005af8 <vTaskPrioritySet+0x24>
80005a5c:	80 00       	ld.sh	r0,r0[0x0]
80005a5e:	4d d4       	lddpc	r4,80005bd0 <vTaskPrioritySet+0xfc>

80005a60 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80005a60:	eb cd 40 80 	pushm	r7,lr
80005a64:	1a 97       	mov	r7,sp
80005a66:	20 3d       	sub	sp,12
80005a68:	ef 4c ff f4 	st.w	r7[-12],r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
80005a6c:	30 08       	mov	r8,0
80005a6e:	ef 48 ff fc 	st.w	r7[-4],r8

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80005a72:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005a76:	58 08       	cp.w	r8,0
80005a78:	c1 a0       	breq	80005aac <vTaskDelay+0x4c>
		{
			vTaskSuspendAll();
80005a7a:	f0 1f 00 11 	mcall	80005abc <vTaskDelay+0x5c>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80005a7e:	49 18       	lddpc	r8,80005ac0 <vTaskDelay+0x60>
80005a80:	70 09       	ld.w	r9,r8[0x0]
80005a82:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005a86:	f2 08 00 08 	add	r8,r9,r8
80005a8a:	ef 48 ff f8 	st.w	r7[-8],r8

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005a8e:	48 e8       	lddpc	r8,80005ac4 <vTaskDelay+0x64>
80005a90:	70 08       	ld.w	r8,r8[0x0]
80005a92:	2f c8       	sub	r8,-4
80005a94:	10 9c       	mov	r12,r8
80005a96:	f0 1f 00 0d 	mcall	80005ac8 <vTaskDelay+0x68>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005a9a:	ee fc ff f8 	ld.w	r12,r7[-8]
80005a9e:	f0 1f 00 0c 	mcall	80005acc <vTaskDelay+0x6c>
			}
			xAlreadyYielded = xTaskResumeAll();
80005aa2:	f0 1f 00 0c 	mcall	80005ad0 <vTaskDelay+0x70>
80005aa6:	18 98       	mov	r8,r12
80005aa8:	ef 48 ff fc 	st.w	r7[-4],r8
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005aac:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005ab0:	58 08       	cp.w	r8,0
80005ab2:	c0 21       	brne	80005ab6 <vTaskDelay+0x56>
		{
			portYIELD_WITHIN_API();
80005ab4:	d7 33       	scall
		}
	}
80005ab6:	2f dd       	sub	sp,-12
80005ab8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005abc:	80 00       	ld.sh	r0,r0[0x0]
80005abe:	5e 5c       	retlt	r12
80005ac0:	00 00       	add	r0,r0
80005ac2:	07 84       	ld.ub	r4,r3[0x0]
80005ac4:	00 00       	add	r0,r0
80005ac6:	06 6c       	and	r12,r3
80005ac8:	80 00       	ld.sh	r0,r0[0x0]
80005aca:	4b a2       	lddpc	r2,80005bb0 <vTaskPrioritySet+0xdc>
80005acc:	80 00       	ld.sh	r0,r0[0x0]
80005ace:	66 20       	ld.w	r0,r3[0x8]
80005ad0:	80 00       	ld.sh	r0,r0[0x0]
80005ad2:	5e 78       	retpl	r8

80005ad4 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
80005ad4:	eb cd 40 80 	pushm	r7,lr
80005ad8:	1a 97       	mov	r7,sp
80005ada:	20 5d       	sub	sp,20
80005adc:	ef 4c ff f0 	st.w	r7[-16],r12
80005ae0:	ef 4b ff ec 	st.w	r7[-20],r11
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentPriority;
	portBASE_TYPE xYieldRequired = pdFALSE;
80005ae4:	30 08       	mov	r8,0
80005ae6:	ef 48 ff fc 	st.w	r7[-4],r8

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= configMAX_PRIORITIES )
80005aea:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005aee:	58 78       	cp.w	r8,7
80005af0:	e0 88 00 05 	brls	80005afa <vTaskPrioritySet+0x26>
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
80005af4:	30 78       	mov	r8,7
80005af6:	ef 48 ff ec 	st.w	r7[-20],r8
		}

		taskENTER_CRITICAL();
80005afa:	f0 1f 00 42 	mcall	80005c00 <vTaskPrioritySet+0x12c>
		{
			if( pxTask == pxCurrentTCB )
80005afe:	4c 28       	lddpc	r8,80005c04 <vTaskPrioritySet+0x130>
80005b00:	70 08       	ld.w	r8,r8[0x0]
80005b02:	ee f9 ff f0 	ld.w	r9,r7[-16]
80005b06:	10 39       	cp.w	r9,r8
80005b08:	c0 41       	brne	80005b10 <vTaskPrioritySet+0x3c>
			{
				pxTask = NULL;
80005b0a:	30 08       	mov	r8,0
80005b0c:	ef 48 ff f0 	st.w	r7[-16],r8
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
80005b10:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005b14:	58 08       	cp.w	r8,0
80005b16:	c0 41       	brne	80005b1e <vTaskPrioritySet+0x4a>
80005b18:	4b b8       	lddpc	r8,80005c04 <vTaskPrioritySet+0x130>
80005b1a:	70 08       	ld.w	r8,r8[0x0]
80005b1c:	c0 38       	rjmp	80005b22 <vTaskPrioritySet+0x4e>
80005b1e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005b22:	ef 48 ff f4 	st.w	r7[-12],r8
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentPriority = pxTCB->uxPriority;
80005b26:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005b2a:	70 b8       	ld.w	r8,r8[0x2c]
80005b2c:	ef 48 ff f8 	st.w	r7[-8],r8
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
80005b30:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005b34:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005b38:	10 39       	cp.w	r9,r8
80005b3a:	c5 d0       	breq	80005bf4 <vTaskPrioritySet+0x120>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
80005b3c:	ee f9 ff ec 	ld.w	r9,r7[-20]
80005b40:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005b44:	10 39       	cp.w	r9,r8
80005b46:	e0 88 00 0a 	brls	80005b5a <vTaskPrioritySet+0x86>
				{
					if( pxTask != NULL )
80005b4a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005b4e:	58 08       	cp.w	r8,0
80005b50:	c0 c0       	breq	80005b68 <vTaskPrioritySet+0x94>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
80005b52:	30 18       	mov	r8,1
80005b54:	ef 48 ff fc 	st.w	r7[-4],r8
80005b58:	c0 88       	rjmp	80005b68 <vTaskPrioritySet+0x94>
					}
				}
				else if( pxTask == NULL )
80005b5a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005b5e:	58 08       	cp.w	r8,0
80005b60:	c0 41       	brne	80005b68 <vTaskPrioritySet+0x94>
				{
					/* Setting our own priority down means there may now be another
					task of higher priority that is ready to execute. */
					xYieldRequired = pdTRUE;
80005b62:	30 18       	mov	r8,1
80005b64:	ef 48 ff fc 	st.w	r7[-4],r8
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
80005b68:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005b6c:	ee f9 ff ec 	ld.w	r9,r7[-20]
80005b70:	91 b9       	st.w	r8[0x2c],r9
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
80005b72:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005b76:	f0 09 11 08 	rsub	r9,r8,8
80005b7a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005b7e:	91 69       	st.w	r8[0x18],r9

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
80005b80:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005b84:	70 5a       	ld.w	r10,r8[0x14]
80005b86:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005b8a:	12 98       	mov	r8,r9
80005b8c:	a3 68       	lsl	r8,0x2
80005b8e:	12 08       	add	r8,r9
80005b90:	a3 68       	lsl	r8,0x2
80005b92:	10 99       	mov	r9,r8
80005b94:	49 d8       	lddpc	r8,80005c08 <vTaskPrioritySet+0x134>
80005b96:	f2 08 00 08 	add	r8,r9,r8
80005b9a:	10 3a       	cp.w	r10,r8
80005b9c:	c2 71       	brne	80005bea <vTaskPrioritySet+0x116>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
80005b9e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005ba2:	2f c8       	sub	r8,-4
80005ba4:	10 9c       	mov	r12,r8
80005ba6:	f0 1f 00 1a 	mcall	80005c0c <vTaskPrioritySet+0x138>
					prvAddTaskToReadyQueue( pxTCB );
80005baa:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005bae:	70 b9       	ld.w	r9,r8[0x2c]
80005bb0:	49 88       	lddpc	r8,80005c10 <vTaskPrioritySet+0x13c>
80005bb2:	70 08       	ld.w	r8,r8[0x0]
80005bb4:	10 39       	cp.w	r9,r8
80005bb6:	e0 88 00 07 	brls	80005bc4 <vTaskPrioritySet+0xf0>
80005bba:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005bbe:	70 b9       	ld.w	r9,r8[0x2c]
80005bc0:	49 48       	lddpc	r8,80005c10 <vTaskPrioritySet+0x13c>
80005bc2:	91 09       	st.w	r8[0x0],r9
80005bc4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005bc8:	f0 ca ff fc 	sub	r10,r8,-4
80005bcc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005bd0:	70 b9       	ld.w	r9,r8[0x2c]
80005bd2:	12 98       	mov	r8,r9
80005bd4:	a3 68       	lsl	r8,0x2
80005bd6:	12 08       	add	r8,r9
80005bd8:	a3 68       	lsl	r8,0x2
80005bda:	10 99       	mov	r9,r8
80005bdc:	48 b8       	lddpc	r8,80005c08 <vTaskPrioritySet+0x134>
80005bde:	f2 08 00 08 	add	r8,r9,r8
80005be2:	14 9b       	mov	r11,r10
80005be4:	10 9c       	mov	r12,r8
80005be6:	f0 1f 00 0c 	mcall	80005c14 <vTaskPrioritySet+0x140>
				}

				if( xYieldRequired == pdTRUE )
80005bea:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005bee:	58 18       	cp.w	r8,1
80005bf0:	c0 21       	brne	80005bf4 <vTaskPrioritySet+0x120>
				{
					portYIELD_WITHIN_API();
80005bf2:	d7 33       	scall
				}
			}
		}
		taskEXIT_CRITICAL();
80005bf4:	f0 1f 00 09 	mcall	80005c18 <vTaskPrioritySet+0x144>
	}
80005bf8:	2f bd       	sub	sp,-20
80005bfa:	e3 cd 80 80 	ldm	sp++,r7,pc
80005bfe:	00 00       	add	r0,r0
80005c00:	80 00       	ld.sh	r0,r0[0x0]
80005c02:	4d b8       	lddpc	r8,80005d6c <vTaskResume+0x38>
80005c04:	00 00       	add	r0,r0
80005c06:	06 6c       	and	r12,r3
80005c08:	00 00       	add	r0,r0
80005c0a:	06 70       	tst	r0,r3
80005c0c:	80 00       	ld.sh	r0,r0[0x0]
80005c0e:	4b a2       	lddpc	r2,80005cf4 <xTaskIsTaskSuspended+0x18>
80005c10:	00 00       	add	r0,r0
80005c12:	07 8c       	ld.ub	r12,r3[0x0]
80005c14:	80 00       	ld.sh	r0,r0[0x0]
80005c16:	4a 8e       	lddpc	lr,80005cb4 <vTaskSuspend+0x98>
80005c18:	80 00       	ld.sh	r0,r0[0x0]
80005c1a:	4d d4       	lddpc	r4,80005d8c <vTaskResume+0x58>

80005c1c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
80005c1c:	eb cd 40 80 	pushm	r7,lr
80005c20:	1a 97       	mov	r7,sp
80005c22:	20 2d       	sub	sp,8
80005c24:	ef 4c ff f8 	st.w	r7[-8],r12
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
80005c28:	f0 1f 00 24 	mcall	80005cb8 <vTaskSuspend+0x9c>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
80005c2c:	4a 48       	lddpc	r8,80005cbc <vTaskSuspend+0xa0>
80005c2e:	70 08       	ld.w	r8,r8[0x0]
80005c30:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005c34:	10 39       	cp.w	r9,r8
80005c36:	c0 41       	brne	80005c3e <vTaskSuspend+0x22>
			{
				pxTaskToSuspend = NULL;
80005c38:	30 08       	mov	r8,0
80005c3a:	ef 48 ff f8 	st.w	r7[-8],r8
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
80005c3e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005c42:	58 08       	cp.w	r8,0
80005c44:	c0 41       	brne	80005c4c <vTaskSuspend+0x30>
80005c46:	49 e8       	lddpc	r8,80005cbc <vTaskSuspend+0xa0>
80005c48:	70 08       	ld.w	r8,r8[0x0]
80005c4a:	c0 38       	rjmp	80005c50 <vTaskSuspend+0x34>
80005c4c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005c50:	ef 48 ff fc 	st.w	r7[-4],r8

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
80005c54:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c58:	2f c8       	sub	r8,-4
80005c5a:	10 9c       	mov	r12,r8
80005c5c:	f0 1f 00 19 	mcall	80005cc0 <vTaskSuspend+0xa4>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
80005c60:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c64:	70 a8       	ld.w	r8,r8[0x28]
80005c66:	58 08       	cp.w	r8,0
80005c68:	c0 70       	breq	80005c76 <vTaskSuspend+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
80005c6a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c6e:	2e 88       	sub	r8,-24
80005c70:	10 9c       	mov	r12,r8
80005c72:	f0 1f 00 14 	mcall	80005cc0 <vTaskSuspend+0xa4>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
80005c76:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c7a:	2f c8       	sub	r8,-4
80005c7c:	10 9b       	mov	r11,r8
80005c7e:	49 2c       	lddpc	r12,80005cc4 <vTaskSuspend+0xa8>
80005c80:	f0 1f 00 12 	mcall	80005cc8 <vTaskSuspend+0xac>
		}
		taskEXIT_CRITICAL();
80005c84:	f0 1f 00 12 	mcall	80005ccc <vTaskSuspend+0xb0>

		if( ( void * ) pxTaskToSuspend == NULL )
80005c88:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005c8c:	58 08       	cp.w	r8,0
80005c8e:	c1 11       	brne	80005cb0 <vTaskSuspend+0x94>
		{
			if( xSchedulerRunning != pdFALSE )
80005c90:	49 08       	lddpc	r8,80005cd0 <vTaskSuspend+0xb4>
80005c92:	70 08       	ld.w	r8,r8[0x0]
80005c94:	58 08       	cp.w	r8,0
80005c96:	c0 30       	breq	80005c9c <vTaskSuspend+0x80>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
80005c98:	d7 33       	scall
80005c9a:	c0 b8       	rjmp	80005cb0 <vTaskSuspend+0x94>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1U )
80005c9c:	48 e8       	lddpc	r8,80005cd4 <vTaskSuspend+0xb8>
80005c9e:	70 08       	ld.w	r8,r8[0x0]
80005ca0:	58 18       	cp.w	r8,1
80005ca2:	c0 51       	brne	80005cac <vTaskSuspend+0x90>
				{
					/* No other tasks are defined, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
80005ca4:	48 68       	lddpc	r8,80005cbc <vTaskSuspend+0xa0>
80005ca6:	30 09       	mov	r9,0
80005ca8:	91 09       	st.w	r8[0x0],r9
80005caa:	c0 38       	rjmp	80005cb0 <vTaskSuspend+0x94>
				}
				else
				{
					vTaskSwitchContext();
80005cac:	f0 1f 00 0b 	mcall	80005cd8 <vTaskSuspend+0xbc>
				}
			}
		}
	}
80005cb0:	2f ed       	sub	sp,-8
80005cb2:	e3 cd 80 80 	ldm	sp++,r7,pc
80005cb6:	00 00       	add	r0,r0
80005cb8:	80 00       	ld.sh	r0,r0[0x0]
80005cba:	4d b8       	lddpc	r8,80005e24 <vTaskStartScheduler+0x2c>
80005cbc:	00 00       	add	r0,r0
80005cbe:	06 6c       	and	r12,r3
80005cc0:	80 00       	ld.sh	r0,r0[0x0]
80005cc2:	4b a2       	lddpc	r2,80005da8 <vTaskResume+0x74>
80005cc4:	00 00       	add	r0,r0
80005cc6:	07 6c       	ld.uh	r12,--r3
80005cc8:	80 00       	ld.sh	r0,r0[0x0]
80005cca:	4a 8e       	lddpc	lr,80005d68 <vTaskResume+0x34>
80005ccc:	80 00       	ld.sh	r0,r0[0x0]
80005cce:	4d d4       	lddpc	r4,80005e40 <vTaskStartScheduler+0x48>
80005cd0:	00 00       	add	r0,r0
80005cd2:	07 90       	ld.ub	r0,r3[0x1]
80005cd4:	00 00       	add	r0,r0
80005cd6:	07 80       	ld.ub	r0,r3[0x0]
80005cd8:	80 00       	ld.sh	r0,r0[0x0]
80005cda:	61 30       	ld.w	r0,r0[0x4c]

80005cdc <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
80005cdc:	eb cd 40 80 	pushm	r7,lr
80005ce0:	1a 97       	mov	r7,sp
80005ce2:	20 3d       	sub	sp,12
80005ce4:	ef 4c ff f4 	st.w	r7[-12],r12
	portBASE_TYPE xReturn = pdFALSE;
80005ce8:	30 08       	mov	r8,0
80005cea:	ef 48 ff f8 	st.w	r7[-8],r8
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
80005cee:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005cf2:	ef 48 ff fc 	st.w	r7[-4],r8
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
80005cf6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005cfa:	70 59       	ld.w	r9,r8[0x14]
80005cfc:	48 c8       	lddpc	r8,80005d2c <xTaskIsTaskSuspended+0x50>
80005cfe:	10 39       	cp.w	r9,r8
80005d00:	c0 f1       	brne	80005d1e <xTaskIsTaskSuspended+0x42>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
80005d02:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005d06:	70 a9       	ld.w	r9,r8[0x28]
80005d08:	48 a8       	lddpc	r8,80005d30 <xTaskIsTaskSuspended+0x54>
80005d0a:	10 39       	cp.w	r9,r8
80005d0c:	c0 90       	breq	80005d1e <xTaskIsTaskSuspended+0x42>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
80005d0e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005d12:	70 a8       	ld.w	r8,r8[0x28]
80005d14:	58 08       	cp.w	r8,0
80005d16:	c0 41       	brne	80005d1e <xTaskIsTaskSuspended+0x42>
				{
					xReturn = pdTRUE;
80005d18:	30 18       	mov	r8,1
80005d1a:	ef 48 ff f8 	st.w	r7[-8],r8
				}
			}
		}

		return xReturn;
80005d1e:	ee f8 ff f8 	ld.w	r8,r7[-8]
	}
80005d22:	10 9c       	mov	r12,r8
80005d24:	2f dd       	sub	sp,-12
80005d26:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d2a:	00 00       	add	r0,r0
80005d2c:	00 00       	add	r0,r0
80005d2e:	07 6c       	ld.uh	r12,--r3
80005d30:	00 00       	add	r0,r0
80005d32:	07 40       	ld.w	r0,--r3

80005d34 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
80005d34:	eb cd 40 80 	pushm	r7,lr
80005d38:	1a 97       	mov	r7,sp
80005d3a:	20 2d       	sub	sp,8
80005d3c:	ef 4c ff f8 	st.w	r7[-8],r12
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
80005d40:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d44:	ef 48 ff fc 	st.w	r7[-4],r8

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
80005d48:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005d4c:	58 08       	cp.w	r8,0
80005d4e:	c4 10       	breq	80005dd0 <vTaskResume+0x9c>
80005d50:	4a 28       	lddpc	r8,80005dd8 <vTaskResume+0xa4>
80005d52:	70 08       	ld.w	r8,r8[0x0]
80005d54:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005d58:	10 39       	cp.w	r9,r8
80005d5a:	c3 b0       	breq	80005dd0 <vTaskResume+0x9c>
		{
			taskENTER_CRITICAL();
80005d5c:	f0 1f 00 20 	mcall	80005ddc <vTaskResume+0xa8>
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
80005d60:	ee fc ff fc 	ld.w	r12,r7[-4]
80005d64:	f0 1f 00 1f 	mcall	80005de0 <vTaskResume+0xac>
80005d68:	18 98       	mov	r8,r12
80005d6a:	58 18       	cp.w	r8,1
80005d6c:	c3 01       	brne	80005dcc <vTaskResume+0x98>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
80005d6e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005d72:	2f c8       	sub	r8,-4
80005d74:	10 9c       	mov	r12,r8
80005d76:	f0 1f 00 1c 	mcall	80005de4 <vTaskResume+0xb0>
					prvAddTaskToReadyQueue( pxTCB );
80005d7a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005d7e:	70 b9       	ld.w	r9,r8[0x2c]
80005d80:	49 a8       	lddpc	r8,80005de8 <vTaskResume+0xb4>
80005d82:	70 08       	ld.w	r8,r8[0x0]
80005d84:	10 39       	cp.w	r9,r8
80005d86:	e0 88 00 07 	brls	80005d94 <vTaskResume+0x60>
80005d8a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005d8e:	70 b9       	ld.w	r9,r8[0x2c]
80005d90:	49 68       	lddpc	r8,80005de8 <vTaskResume+0xb4>
80005d92:	91 09       	st.w	r8[0x0],r9
80005d94:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005d98:	f0 ca ff fc 	sub	r10,r8,-4
80005d9c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005da0:	70 b9       	ld.w	r9,r8[0x2c]
80005da2:	12 98       	mov	r8,r9
80005da4:	a3 68       	lsl	r8,0x2
80005da6:	12 08       	add	r8,r9
80005da8:	a3 68       	lsl	r8,0x2
80005daa:	10 99       	mov	r9,r8
80005dac:	49 08       	lddpc	r8,80005dec <vTaskResume+0xb8>
80005dae:	f2 08 00 08 	add	r8,r9,r8
80005db2:	14 9b       	mov	r11,r10
80005db4:	10 9c       	mov	r12,r8
80005db6:	f0 1f 00 0f 	mcall	80005df0 <vTaskResume+0xbc>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005dba:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005dbe:	70 b9       	ld.w	r9,r8[0x2c]
80005dc0:	48 68       	lddpc	r8,80005dd8 <vTaskResume+0xa4>
80005dc2:	70 08       	ld.w	r8,r8[0x0]
80005dc4:	70 b8       	ld.w	r8,r8[0x2c]
80005dc6:	10 39       	cp.w	r9,r8
80005dc8:	c0 23       	brcs	80005dcc <vTaskResume+0x98>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
80005dca:	d7 33       	scall
					}
				}
			}
			taskEXIT_CRITICAL();
80005dcc:	f0 1f 00 0a 	mcall	80005df4 <vTaskResume+0xc0>
		}
	}
80005dd0:	2f ed       	sub	sp,-8
80005dd2:	e3 cd 80 80 	ldm	sp++,r7,pc
80005dd6:	00 00       	add	r0,r0
80005dd8:	00 00       	add	r0,r0
80005dda:	06 6c       	and	r12,r3
80005ddc:	80 00       	ld.sh	r0,r0[0x0]
80005dde:	4d b8       	lddpc	r8,80005f48 <xTaskResumeAll+0xd0>
80005de0:	80 00       	ld.sh	r0,r0[0x0]
80005de2:	5c dc       	com	r12
80005de4:	80 00       	ld.sh	r0,r0[0x0]
80005de6:	4b a2       	lddpc	r2,80005ecc <xTaskResumeAll+0x54>
80005de8:	00 00       	add	r0,r0
80005dea:	07 8c       	ld.ub	r12,r3[0x0]
80005dec:	00 00       	add	r0,r0
80005dee:	06 70       	tst	r0,r3
80005df0:	80 00       	ld.sh	r0,r0[0x0]
80005df2:	4a 8e       	lddpc	lr,80005e90 <xTaskResumeAll+0x18>
80005df4:	80 00       	ld.sh	r0,r0[0x0]
80005df6:	4d d4       	lddpc	r4,80005f68 <xTaskResumeAll+0xf0>

80005df8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005df8:	eb cd 40 80 	pushm	r7,lr
80005dfc:	1a 97       	mov	r7,sp
80005dfe:	20 1d       	sub	sp,4
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005e00:	49 1b       	lddpc	r11,80005e44 <vTaskStartScheduler+0x4c>
80005e02:	30 08       	mov	r8,0
80005e04:	1a d8       	st.w	--sp,r8
80005e06:	30 08       	mov	r8,0
80005e08:	1a d8       	st.w	--sp,r8
80005e0a:	30 08       	mov	r8,0
80005e0c:	1a d8       	st.w	--sp,r8
80005e0e:	30 08       	mov	r8,0
80005e10:	30 09       	mov	r9,0
80005e12:	e0 6a 01 00 	mov	r10,256
80005e16:	48 dc       	lddpc	r12,80005e48 <vTaskStartScheduler+0x50>
80005e18:	f0 1f 00 0d 	mcall	80005e4c <vTaskStartScheduler+0x54>
80005e1c:	2f dd       	sub	sp,-12
80005e1e:	18 98       	mov	r8,r12
80005e20:	ef 48 ff fc 	st.w	r7[-4],r8
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005e24:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005e28:	58 18       	cp.w	r8,1
80005e2a:	c0 a1       	brne	80005e3e <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005e2c:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005e2e:	48 98       	lddpc	r8,80005e50 <vTaskStartScheduler+0x58>
80005e30:	30 19       	mov	r9,1
80005e32:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005e34:	48 88       	lddpc	r8,80005e54 <vTaskStartScheduler+0x5c>
80005e36:	30 09       	mov	r9,0
80005e38:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005e3a:	f0 1f 00 08 	mcall	80005e58 <vTaskStartScheduler+0x60>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
80005e3e:	2f fd       	sub	sp,-4
80005e40:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e44:	80 00       	ld.sh	r0,r0[0x0]
80005e46:	58 90       	cp.w	r0,9
80005e48:	80 00       	ld.sh	r0,r0[0x0]
80005e4a:	64 2c       	ld.w	r12,r2[0x8]
80005e4c:	80 00       	ld.sh	r0,r0[0x0]
80005e4e:	58 98       	cp.w	r8,9
80005e50:	00 00       	add	r0,r0
80005e52:	07 90       	ld.ub	r0,r3[0x1]
80005e54:	00 00       	add	r0,r0
80005e56:	07 84       	ld.ub	r4,r3[0x0]
80005e58:	80 00       	ld.sh	r0,r0[0x0]
80005e5a:	4f a8       	lddpc	r8,80006040 <vTaskIncrementTick+0x70>

80005e5c <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
80005e5c:	eb cd 40 80 	pushm	r7,lr
80005e60:	1a 97       	mov	r7,sp
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005e62:	48 58       	lddpc	r8,80005e74 <vTaskSuspendAll+0x18>
80005e64:	70 08       	ld.w	r8,r8[0x0]
80005e66:	f0 c9 ff ff 	sub	r9,r8,-1
80005e6a:	48 38       	lddpc	r8,80005e74 <vTaskSuspendAll+0x18>
80005e6c:	91 09       	st.w	r8[0x0],r9
}
80005e6e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e72:	00 00       	add	r0,r0
80005e74:	00 00       	add	r0,r0
80005e76:	07 94       	ld.ub	r4,r3[0x1]

80005e78 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005e78:	eb cd 40 c0 	pushm	r6-r7,lr
80005e7c:	1a 97       	mov	r7,sp
80005e7e:	20 2d       	sub	sp,8
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
80005e80:	30 08       	mov	r8,0
80005e82:	ef 48 ff f8 	st.w	r7[-8],r8
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005e86:	f0 1f 00 3a 	mcall	80005f6c <xTaskResumeAll+0xf4>
	{
		--uxSchedulerSuspended;
80005e8a:	4b a8       	lddpc	r8,80005f70 <xTaskResumeAll+0xf8>
80005e8c:	70 08       	ld.w	r8,r8[0x0]
80005e8e:	f0 c9 00 01 	sub	r9,r8,1
80005e92:	4b 88       	lddpc	r8,80005f70 <xTaskResumeAll+0xf8>
80005e94:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005e96:	4b 78       	lddpc	r8,80005f70 <xTaskResumeAll+0xf8>
80005e98:	70 08       	ld.w	r8,r8[0x0]
80005e9a:	58 08       	cp.w	r8,0
80005e9c:	c5 f1       	brne	80005f5a <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005e9e:	4b 68       	lddpc	r8,80005f74 <xTaskResumeAll+0xfc>
80005ea0:	70 08       	ld.w	r8,r8[0x0]
80005ea2:	58 08       	cp.w	r8,0
80005ea4:	c5 b0       	breq	80005f5a <xTaskResumeAll+0xe2>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
80005ea6:	30 08       	mov	r8,0
80005ea8:	ef 48 ff fc 	st.w	r7[-4],r8

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005eac:	c3 08       	rjmp	80005f0c <xTaskResumeAll+0x94>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005eae:	4b 38       	lddpc	r8,80005f78 <xTaskResumeAll+0x100>
80005eb0:	70 38       	ld.w	r8,r8[0xc]
80005eb2:	70 38       	ld.w	r8,r8[0xc]
80005eb4:	10 96       	mov	r6,r8
					vListRemove( &( pxTCB->xEventListItem ) );
80005eb6:	ec c8 ff e8 	sub	r8,r6,-24
80005eba:	10 9c       	mov	r12,r8
80005ebc:	f0 1f 00 30 	mcall	80005f7c <xTaskResumeAll+0x104>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005ec0:	ec c8 ff fc 	sub	r8,r6,-4
80005ec4:	10 9c       	mov	r12,r8
80005ec6:	f0 1f 00 2e 	mcall	80005f7c <xTaskResumeAll+0x104>
					prvAddTaskToReadyQueue( pxTCB );
80005eca:	6c b9       	ld.w	r9,r6[0x2c]
80005ecc:	4a d8       	lddpc	r8,80005f80 <xTaskResumeAll+0x108>
80005ece:	70 08       	ld.w	r8,r8[0x0]
80005ed0:	10 39       	cp.w	r9,r8
80005ed2:	e0 88 00 05 	brls	80005edc <xTaskResumeAll+0x64>
80005ed6:	6c b9       	ld.w	r9,r6[0x2c]
80005ed8:	4a a8       	lddpc	r8,80005f80 <xTaskResumeAll+0x108>
80005eda:	91 09       	st.w	r8[0x0],r9
80005edc:	ec ca ff fc 	sub	r10,r6,-4
80005ee0:	6c b9       	ld.w	r9,r6[0x2c]
80005ee2:	12 98       	mov	r8,r9
80005ee4:	a3 68       	lsl	r8,0x2
80005ee6:	12 08       	add	r8,r9
80005ee8:	a3 68       	lsl	r8,0x2
80005eea:	10 99       	mov	r9,r8
80005eec:	4a 68       	lddpc	r8,80005f84 <xTaskResumeAll+0x10c>
80005eee:	f2 08 00 08 	add	r8,r9,r8
80005ef2:	14 9b       	mov	r11,r10
80005ef4:	10 9c       	mov	r12,r8
80005ef6:	f0 1f 00 25 	mcall	80005f88 <xTaskResumeAll+0x110>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005efa:	6c b9       	ld.w	r9,r6[0x2c]
80005efc:	4a 48       	lddpc	r8,80005f8c <xTaskResumeAll+0x114>
80005efe:	70 08       	ld.w	r8,r8[0x0]
80005f00:	70 b8       	ld.w	r8,r8[0x2c]
80005f02:	10 39       	cp.w	r9,r8
80005f04:	c0 43       	brcs	80005f0c <xTaskResumeAll+0x94>
					{
						xYieldRequired = pdTRUE;
80005f06:	30 18       	mov	r8,1
80005f08:	ef 48 ff fc 	st.w	r7[-4],r8
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005f0c:	49 b8       	lddpc	r8,80005f78 <xTaskResumeAll+0x100>
80005f0e:	70 08       	ld.w	r8,r8[0x0]
80005f10:	58 08       	cp.w	r8,0
80005f12:	cc e1       	brne	80005eae <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005f14:	49 f8       	lddpc	r8,80005f90 <xTaskResumeAll+0x118>
80005f16:	70 08       	ld.w	r8,r8[0x0]
80005f18:	58 08       	cp.w	r8,0
80005f1a:	c1 10       	breq	80005f3c <xTaskResumeAll+0xc4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005f1c:	c0 98       	rjmp	80005f2e <xTaskResumeAll+0xb6>
					{
						vTaskIncrementTick();
80005f1e:	f0 1f 00 1e 	mcall	80005f94 <xTaskResumeAll+0x11c>
						--uxMissedTicks;
80005f22:	49 c8       	lddpc	r8,80005f90 <xTaskResumeAll+0x118>
80005f24:	70 08       	ld.w	r8,r8[0x0]
80005f26:	f0 c9 00 01 	sub	r9,r8,1
80005f2a:	49 a8       	lddpc	r8,80005f90 <xTaskResumeAll+0x118>
80005f2c:	91 09       	st.w	r8[0x0],r9
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005f2e:	49 98       	lddpc	r8,80005f90 <xTaskResumeAll+0x118>
80005f30:	70 08       	ld.w	r8,r8[0x0]
80005f32:	58 08       	cp.w	r8,0
80005f34:	cf 51       	brne	80005f1e <xTaskResumeAll+0xa6>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
80005f36:	30 18       	mov	r8,1
80005f38:	ef 48 ff fc 	st.w	r7[-4],r8
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005f3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005f40:	58 18       	cp.w	r8,1
80005f42:	c0 50       	breq	80005f4c <xTaskResumeAll+0xd4>
80005f44:	49 58       	lddpc	r8,80005f98 <xTaskResumeAll+0x120>
80005f46:	70 08       	ld.w	r8,r8[0x0]
80005f48:	58 18       	cp.w	r8,1
80005f4a:	c0 81       	brne	80005f5a <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
80005f4c:	30 18       	mov	r8,1
80005f4e:	ef 48 ff f8 	st.w	r7[-8],r8
					xMissedYield = pdFALSE;
80005f52:	49 28       	lddpc	r8,80005f98 <xTaskResumeAll+0x120>
80005f54:	30 09       	mov	r9,0
80005f56:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005f58:	d7 33       	scall
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005f5a:	f0 1f 00 11 	mcall	80005f9c <xTaskResumeAll+0x124>

	return xAlreadyYielded;
80005f5e:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80005f62:	10 9c       	mov	r12,r8
80005f64:	2f ed       	sub	sp,-8
80005f66:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005f6a:	00 00       	add	r0,r0
80005f6c:	80 00       	ld.sh	r0,r0[0x0]
80005f6e:	4d b8       	lddpc	r8,800060d8 <vTaskIncrementTick+0x108>
80005f70:	00 00       	add	r0,r0
80005f72:	07 94       	ld.ub	r4,r3[0x1]
80005f74:	00 00       	add	r0,r0
80005f76:	07 80       	ld.ub	r0,r3[0x0]
80005f78:	00 00       	add	r0,r0
80005f7a:	07 40       	ld.w	r0,--r3
80005f7c:	80 00       	ld.sh	r0,r0[0x0]
80005f7e:	4b a2       	lddpc	r2,80006064 <vTaskIncrementTick+0x94>
80005f80:	00 00       	add	r0,r0
80005f82:	07 8c       	ld.ub	r12,r3[0x0]
80005f84:	00 00       	add	r0,r0
80005f86:	06 70       	tst	r0,r3
80005f88:	80 00       	ld.sh	r0,r0[0x0]
80005f8a:	4a 8e       	lddpc	lr,80006028 <vTaskIncrementTick+0x58>
80005f8c:	00 00       	add	r0,r0
80005f8e:	06 6c       	and	r12,r3
80005f90:	00 00       	add	r0,r0
80005f92:	07 98       	ld.ub	r8,r3[0x1]
80005f94:	80 00       	ld.sh	r0,r0[0x0]
80005f96:	5f d0       	srvc	r0
80005f98:	00 00       	add	r0,r0
80005f9a:	07 9c       	ld.ub	r12,r3[0x1]
80005f9c:	80 00       	ld.sh	r0,r0[0x0]
80005f9e:	4d d4       	lddpc	r4,80006110 <vTaskIncrementTick+0x140>

80005fa0 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005fa0:	eb cd 40 80 	pushm	r7,lr
80005fa4:	1a 97       	mov	r7,sp
80005fa6:	20 1d       	sub	sp,4
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005fa8:	f0 1f 00 07 	mcall	80005fc4 <xTaskGetTickCount+0x24>
	{
		xTicks = xTickCount;
80005fac:	48 78       	lddpc	r8,80005fc8 <xTaskGetTickCount+0x28>
80005fae:	70 08       	ld.w	r8,r8[0x0]
80005fb0:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	taskEXIT_CRITICAL();
80005fb4:	f0 1f 00 06 	mcall	80005fcc <xTaskGetTickCount+0x2c>

	return xTicks;
80005fb8:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005fbc:	10 9c       	mov	r12,r8
80005fbe:	2f fd       	sub	sp,-4
80005fc0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005fc4:	80 00       	ld.sh	r0,r0[0x0]
80005fc6:	4d b8       	lddpc	r8,80006130 <vTaskSwitchContext>
80005fc8:	00 00       	add	r0,r0
80005fca:	07 84       	ld.ub	r4,r3[0x0]
80005fcc:	80 00       	ld.sh	r0,r0[0x0]
80005fce:	4d d4       	lddpc	r4,80006140 <vTaskSwitchContext+0x10>

80005fd0 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005fd0:	eb cd 40 80 	pushm	r7,lr
80005fd4:	1a 97       	mov	r7,sp
80005fd6:	20 3d       	sub	sp,12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005fd8:	4c b8       	lddpc	r8,80006104 <vTaskIncrementTick+0x134>
80005fda:	70 08       	ld.w	r8,r8[0x0]
80005fdc:	58 08       	cp.w	r8,0
80005fde:	e0 81 00 89 	brne	800060f0 <vTaskIncrementTick+0x120>
	{
		++xTickCount;
80005fe2:	4c a8       	lddpc	r8,80006108 <vTaskIncrementTick+0x138>
80005fe4:	70 08       	ld.w	r8,r8[0x0]
80005fe6:	f0 c9 ff ff 	sub	r9,r8,-1
80005fea:	4c 88       	lddpc	r8,80006108 <vTaskIncrementTick+0x138>
80005fec:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005fee:	4c 78       	lddpc	r8,80006108 <vTaskIncrementTick+0x138>
80005ff0:	70 08       	ld.w	r8,r8[0x0]
80005ff2:	58 08       	cp.w	r8,0
80005ff4:	c2 71       	brne	80006042 <vTaskIncrementTick+0x72>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005ff6:	4c 68       	lddpc	r8,8000610c <vTaskIncrementTick+0x13c>
80005ff8:	70 08       	ld.w	r8,r8[0x0]
80005ffa:	ef 48 ff f8 	st.w	r7[-8],r8
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005ffe:	4c 58       	lddpc	r8,80006110 <vTaskIncrementTick+0x140>
80006000:	70 09       	ld.w	r9,r8[0x0]
80006002:	4c 38       	lddpc	r8,8000610c <vTaskIncrementTick+0x13c>
80006004:	91 09       	st.w	r8[0x0],r9
			pxOverflowDelayedTaskList = pxTemp;
80006006:	4c 38       	lddpc	r8,80006110 <vTaskIncrementTick+0x140>
80006008:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000600c:	91 09       	st.w	r8[0x0],r9
			xNumOfOverflows++;
8000600e:	4c 28       	lddpc	r8,80006114 <vTaskIncrementTick+0x144>
80006010:	70 08       	ld.w	r8,r8[0x0]
80006012:	f0 c9 ff ff 	sub	r9,r8,-1
80006016:	4c 08       	lddpc	r8,80006114 <vTaskIncrementTick+0x144>
80006018:	91 09       	st.w	r8[0x0],r9

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000601a:	4b d8       	lddpc	r8,8000610c <vTaskIncrementTick+0x13c>
8000601c:	70 08       	ld.w	r8,r8[0x0]
8000601e:	70 08       	ld.w	r8,r8[0x0]
80006020:	58 08       	cp.w	r8,0
80006022:	c0 51       	brne	8000602c <vTaskIncrementTick+0x5c>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80006024:	4b d8       	lddpc	r8,80006118 <vTaskIncrementTick+0x148>
80006026:	3f f9       	mov	r9,-1
80006028:	91 09       	st.w	r8[0x0],r9
8000602a:	c0 c8       	rjmp	80006042 <vTaskIncrementTick+0x72>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000602c:	4b 88       	lddpc	r8,8000610c <vTaskIncrementTick+0x13c>
8000602e:	70 08       	ld.w	r8,r8[0x0]
80006030:	70 38       	ld.w	r8,r8[0xc]
80006032:	70 38       	ld.w	r8,r8[0xc]
80006034:	ef 48 ff f4 	st.w	r7[-12],r8
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80006038:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000603c:	70 19       	ld.w	r9,r8[0x4]
8000603e:	4b 78       	lddpc	r8,80006118 <vTaskIncrementTick+0x148>
80006040:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006042:	4b 28       	lddpc	r8,80006108 <vTaskIncrementTick+0x138>
80006044:	70 09       	ld.w	r9,r8[0x0]
80006046:	4b 58       	lddpc	r8,80006118 <vTaskIncrementTick+0x148>
80006048:	70 08       	ld.w	r8,r8[0x0]
8000604a:	10 39       	cp.w	r9,r8
8000604c:	c5 83       	brcs	800060fc <vTaskIncrementTick+0x12c>
8000604e:	4b 08       	lddpc	r8,8000610c <vTaskIncrementTick+0x13c>
80006050:	70 08       	ld.w	r8,r8[0x0]
80006052:	70 08       	ld.w	r8,r8[0x0]
80006054:	58 08       	cp.w	r8,0
80006056:	c0 51       	brne	80006060 <vTaskIncrementTick+0x90>
80006058:	4b 08       	lddpc	r8,80006118 <vTaskIncrementTick+0x148>
8000605a:	3f f9       	mov	r9,-1
8000605c:	91 09       	st.w	r8[0x0],r9
8000605e:	c4 f8       	rjmp	800060fc <vTaskIncrementTick+0x12c>
80006060:	4a b8       	lddpc	r8,8000610c <vTaskIncrementTick+0x13c>
80006062:	70 08       	ld.w	r8,r8[0x0]
80006064:	70 38       	ld.w	r8,r8[0xc]
80006066:	70 38       	ld.w	r8,r8[0xc]
80006068:	ef 48 ff f4 	st.w	r7[-12],r8
8000606c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006070:	70 18       	ld.w	r8,r8[0x4]
80006072:	ef 48 ff fc 	st.w	r7[-4],r8
80006076:	4a 58       	lddpc	r8,80006108 <vTaskIncrementTick+0x138>
80006078:	70 09       	ld.w	r9,r8[0x0]
8000607a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000607e:	10 39       	cp.w	r9,r8
80006080:	c0 62       	brcc	8000608c <vTaskIncrementTick+0xbc>
80006082:	4a 68       	lddpc	r8,80006118 <vTaskIncrementTick+0x148>
80006084:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006088:	91 09       	st.w	r8[0x0],r9
8000608a:	c3 98       	rjmp	800060fc <vTaskIncrementTick+0x12c>
8000608c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006090:	2f c8       	sub	r8,-4
80006092:	10 9c       	mov	r12,r8
80006094:	f0 1f 00 22 	mcall	8000611c <vTaskIncrementTick+0x14c>
80006098:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000609c:	70 a8       	ld.w	r8,r8[0x28]
8000609e:	58 08       	cp.w	r8,0
800060a0:	c0 70       	breq	800060ae <vTaskIncrementTick+0xde>
800060a2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800060a6:	2e 88       	sub	r8,-24
800060a8:	10 9c       	mov	r12,r8
800060aa:	f0 1f 00 1d 	mcall	8000611c <vTaskIncrementTick+0x14c>
800060ae:	ee f8 ff f4 	ld.w	r8,r7[-12]
800060b2:	70 b9       	ld.w	r9,r8[0x2c]
800060b4:	49 b8       	lddpc	r8,80006120 <vTaskIncrementTick+0x150>
800060b6:	70 08       	ld.w	r8,r8[0x0]
800060b8:	10 39       	cp.w	r9,r8
800060ba:	e0 88 00 07 	brls	800060c8 <vTaskIncrementTick+0xf8>
800060be:	ee f8 ff f4 	ld.w	r8,r7[-12]
800060c2:	70 b9       	ld.w	r9,r8[0x2c]
800060c4:	49 78       	lddpc	r8,80006120 <vTaskIncrementTick+0x150>
800060c6:	91 09       	st.w	r8[0x0],r9
800060c8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800060cc:	f0 ca ff fc 	sub	r10,r8,-4
800060d0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800060d4:	70 b9       	ld.w	r9,r8[0x2c]
800060d6:	12 98       	mov	r8,r9
800060d8:	a3 68       	lsl	r8,0x2
800060da:	12 08       	add	r8,r9
800060dc:	a3 68       	lsl	r8,0x2
800060de:	10 99       	mov	r9,r8
800060e0:	49 18       	lddpc	r8,80006124 <vTaskIncrementTick+0x154>
800060e2:	f2 08 00 08 	add	r8,r9,r8
800060e6:	14 9b       	mov	r11,r10
800060e8:	10 9c       	mov	r12,r8
800060ea:	f0 1f 00 10 	mcall	80006128 <vTaskIncrementTick+0x158>
800060ee:	cb 0b       	rjmp	8000604e <vTaskIncrementTick+0x7e>
	}
	else
	{
		++uxMissedTicks;
800060f0:	48 f8       	lddpc	r8,8000612c <vTaskIncrementTick+0x15c>
800060f2:	70 08       	ld.w	r8,r8[0x0]
800060f4:	f0 c9 ff ff 	sub	r9,r8,-1
800060f8:	48 d8       	lddpc	r8,8000612c <vTaskIncrementTick+0x15c>
800060fa:	91 09       	st.w	r8[0x0],r9
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
800060fc:	2f dd       	sub	sp,-12
800060fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80006102:	00 00       	add	r0,r0
80006104:	00 00       	add	r0,r0
80006106:	07 94       	ld.ub	r4,r3[0x1]
80006108:	00 00       	add	r0,r0
8000610a:	07 84       	ld.ub	r4,r3[0x0]
8000610c:	00 00       	add	r0,r0
8000610e:	07 38       	ld.ub	r8,r3++
80006110:	00 00       	add	r0,r0
80006112:	07 3c       	ld.ub	r12,r3++
80006114:	00 00       	add	r0,r0
80006116:	07 a0       	ld.ub	r0,r3[0x2]
80006118:	00 00       	add	r0,r0
8000611a:	00 24       	rsub	r4,r0
8000611c:	80 00       	ld.sh	r0,r0[0x0]
8000611e:	4b a2       	lddpc	r2,80006204 <vTaskPlaceOnEventList+0x24>
80006120:	00 00       	add	r0,r0
80006122:	07 8c       	ld.ub	r12,r3[0x0]
80006124:	00 00       	add	r0,r0
80006126:	06 70       	tst	r0,r3
80006128:	80 00       	ld.sh	r0,r0[0x0]
8000612a:	4a 8e       	lddpc	lr,800061c8 <vTaskSwitchContext+0x98>
8000612c:	00 00       	add	r0,r0
8000612e:	07 98       	ld.ub	r8,r3[0x1]

80006130 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
80006130:	eb cd 40 80 	pushm	r7,lr
80006134:	1a 97       	mov	r7,sp
80006136:	20 1d       	sub	sp,4
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006138:	4a 58       	lddpc	r8,800061cc <vTaskSwitchContext+0x9c>
8000613a:	70 08       	ld.w	r8,r8[0x0]
8000613c:	58 08       	cp.w	r8,0
8000613e:	c0 c0       	breq	80006156 <vTaskSwitchContext+0x26>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006140:	4a 48       	lddpc	r8,800061d0 <vTaskSwitchContext+0xa0>
80006142:	30 19       	mov	r9,1
80006144:	91 09       	st.w	r8[0x0],r9
80006146:	c3 f8       	rjmp	800061c4 <vTaskSwitchContext+0x94>

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006148:	4a 38       	lddpc	r8,800061d4 <vTaskSwitchContext+0xa4>
8000614a:	70 08       	ld.w	r8,r8[0x0]
8000614c:	f0 c9 00 01 	sub	r9,r8,1
80006150:	4a 18       	lddpc	r8,800061d4 <vTaskSwitchContext+0xa4>
80006152:	91 09       	st.w	r8[0x0],r9
80006154:	c0 28       	rjmp	80006158 <vTaskSwitchContext+0x28>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006156:	d7 03       	nop
80006158:	49 f8       	lddpc	r8,800061d4 <vTaskSwitchContext+0xa4>
8000615a:	70 09       	ld.w	r9,r8[0x0]
8000615c:	12 98       	mov	r8,r9
8000615e:	a3 68       	lsl	r8,0x2
80006160:	12 08       	add	r8,r9
80006162:	a3 68       	lsl	r8,0x2
80006164:	10 99       	mov	r9,r8
80006166:	49 d8       	lddpc	r8,800061d8 <vTaskSwitchContext+0xa8>
80006168:	f2 08 00 08 	add	r8,r9,r8
8000616c:	70 08       	ld.w	r8,r8[0x0]
8000616e:	58 08       	cp.w	r8,0
80006170:	ce c0       	breq	80006148 <vTaskSwitchContext+0x18>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006172:	49 98       	lddpc	r8,800061d4 <vTaskSwitchContext+0xa4>
80006174:	70 09       	ld.w	r9,r8[0x0]
80006176:	12 98       	mov	r8,r9
80006178:	a3 68       	lsl	r8,0x2
8000617a:	12 08       	add	r8,r9
8000617c:	a3 68       	lsl	r8,0x2
8000617e:	10 99       	mov	r9,r8
80006180:	49 68       	lddpc	r8,800061d8 <vTaskSwitchContext+0xa8>
80006182:	f2 08 00 08 	add	r8,r9,r8
80006186:	ef 48 ff fc 	st.w	r7[-4],r8
8000618a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000618e:	70 18       	ld.w	r8,r8[0x4]
80006190:	70 19       	ld.w	r9,r8[0x4]
80006192:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006196:	91 19       	st.w	r8[0x4],r9
80006198:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000619c:	70 19       	ld.w	r9,r8[0x4]
8000619e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800061a2:	2f 88       	sub	r8,-8
800061a4:	10 39       	cp.w	r9,r8
800061a6:	c0 81       	brne	800061b6 <vTaskSwitchContext+0x86>
800061a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800061ac:	70 18       	ld.w	r8,r8[0x4]
800061ae:	70 19       	ld.w	r9,r8[0x4]
800061b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800061b4:	91 19       	st.w	r8[0x4],r9
800061b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800061ba:	70 18       	ld.w	r8,r8[0x4]
800061bc:	70 38       	ld.w	r8,r8[0xc]
800061be:	10 99       	mov	r9,r8
800061c0:	48 78       	lddpc	r8,800061dc <vTaskSwitchContext+0xac>
800061c2:	91 09       	st.w	r8[0x0],r9

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
800061c4:	2f fd       	sub	sp,-4
800061c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800061ca:	00 00       	add	r0,r0
800061cc:	00 00       	add	r0,r0
800061ce:	07 94       	ld.ub	r4,r3[0x1]
800061d0:	00 00       	add	r0,r0
800061d2:	07 9c       	ld.ub	r12,r3[0x1]
800061d4:	00 00       	add	r0,r0
800061d6:	07 8c       	ld.ub	r12,r3[0x0]
800061d8:	00 00       	add	r0,r0
800061da:	06 70       	tst	r0,r3
800061dc:	00 00       	add	r0,r0
800061de:	06 6c       	and	r12,r3

800061e0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800061e0:	eb cd 40 80 	pushm	r7,lr
800061e4:	1a 97       	mov	r7,sp
800061e6:	20 3d       	sub	sp,12
800061e8:	ef 4c ff f8 	st.w	r7[-8],r12
800061ec:	ef 4b ff f4 	st.w	r7[-12],r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800061f0:	49 58       	lddpc	r8,80006244 <vTaskPlaceOnEventList+0x64>
800061f2:	70 08       	ld.w	r8,r8[0x0]
800061f4:	2e 88       	sub	r8,-24
800061f6:	10 9b       	mov	r11,r8
800061f8:	ee fc ff f8 	ld.w	r12,r7[-8]
800061fc:	f0 1f 00 13 	mcall	80006248 <vTaskPlaceOnEventList+0x68>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006200:	49 18       	lddpc	r8,80006244 <vTaskPlaceOnEventList+0x64>
80006202:	70 08       	ld.w	r8,r8[0x0]
80006204:	2f c8       	sub	r8,-4
80006206:	10 9c       	mov	r12,r8
80006208:	f0 1f 00 11 	mcall	8000624c <vTaskPlaceOnEventList+0x6c>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
8000620c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006210:	5b f8       	cp.w	r8,-1
80006212:	c0 91       	brne	80006224 <vTaskPlaceOnEventList+0x44>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006214:	48 c8       	lddpc	r8,80006244 <vTaskPlaceOnEventList+0x64>
80006216:	70 08       	ld.w	r8,r8[0x0]
80006218:	2f c8       	sub	r8,-4
8000621a:	10 9b       	mov	r11,r8
8000621c:	48 dc       	lddpc	r12,80006250 <vTaskPlaceOnEventList+0x70>
8000621e:	f0 1f 00 0e 	mcall	80006254 <vTaskPlaceOnEventList+0x74>
80006222:	c0 d8       	rjmp	8000623c <vTaskPlaceOnEventList+0x5c>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006224:	48 d8       	lddpc	r8,80006258 <vTaskPlaceOnEventList+0x78>
80006226:	70 09       	ld.w	r9,r8[0x0]
80006228:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000622c:	f2 08 00 08 	add	r8,r9,r8
80006230:	ef 48 ff fc 	st.w	r7[-4],r8
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006234:	ee fc ff fc 	ld.w	r12,r7[-4]
80006238:	f0 1f 00 09 	mcall	8000625c <vTaskPlaceOnEventList+0x7c>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
8000623c:	2f dd       	sub	sp,-12
8000623e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006242:	00 00       	add	r0,r0
80006244:	00 00       	add	r0,r0
80006246:	06 6c       	and	r12,r3
80006248:	80 00       	ld.sh	r0,r0[0x0]
8000624a:	4b 00       	lddpc	r0,80006308 <xTaskRemoveFromEventList+0xa8>
8000624c:	80 00       	ld.sh	r0,r0[0x0]
8000624e:	4b a2       	lddpc	r2,80006334 <vTaskSetTimeOutState+0x4>
80006250:	00 00       	add	r0,r0
80006252:	07 6c       	ld.uh	r12,--r3
80006254:	80 00       	ld.sh	r0,r0[0x0]
80006256:	4a 8e       	lddpc	lr,800062f4 <xTaskRemoveFromEventList+0x94>
80006258:	00 00       	add	r0,r0
8000625a:	07 84       	ld.ub	r4,r3[0x0]
8000625c:	80 00       	ld.sh	r0,r0[0x0]
8000625e:	66 20       	ld.w	r0,r3[0x8]

80006260 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006260:	eb cd 40 80 	pushm	r7,lr
80006264:	1a 97       	mov	r7,sp
80006266:	20 3d       	sub	sp,12
80006268:	ef 4c ff f4 	st.w	r7[-12],r12
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
8000626c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006270:	70 38       	ld.w	r8,r8[0xc]
80006272:	70 38       	ld.w	r8,r8[0xc]
80006274:	ef 48 ff f8 	st.w	r7[-8],r8
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006278:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000627c:	2e 88       	sub	r8,-24
8000627e:	10 9c       	mov	r12,r8
80006280:	f0 1f 00 25 	mcall	80006314 <xTaskRemoveFromEventList+0xb4>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006284:	4a 58       	lddpc	r8,80006318 <xTaskRemoveFromEventList+0xb8>
80006286:	70 08       	ld.w	r8,r8[0x0]
80006288:	58 08       	cp.w	r8,0
8000628a:	c2 81       	brne	800062da <xTaskRemoveFromEventList+0x7a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000628c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006290:	2f c8       	sub	r8,-4
80006292:	10 9c       	mov	r12,r8
80006294:	f0 1f 00 20 	mcall	80006314 <xTaskRemoveFromEventList+0xb4>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006298:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000629c:	70 b9       	ld.w	r9,r8[0x2c]
8000629e:	4a 08       	lddpc	r8,8000631c <xTaskRemoveFromEventList+0xbc>
800062a0:	70 08       	ld.w	r8,r8[0x0]
800062a2:	10 39       	cp.w	r9,r8
800062a4:	e0 88 00 07 	brls	800062b2 <xTaskRemoveFromEventList+0x52>
800062a8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800062ac:	70 b9       	ld.w	r9,r8[0x2c]
800062ae:	49 c8       	lddpc	r8,8000631c <xTaskRemoveFromEventList+0xbc>
800062b0:	91 09       	st.w	r8[0x0],r9
800062b2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800062b6:	f0 ca ff fc 	sub	r10,r8,-4
800062ba:	ee f8 ff f8 	ld.w	r8,r7[-8]
800062be:	70 b9       	ld.w	r9,r8[0x2c]
800062c0:	12 98       	mov	r8,r9
800062c2:	a3 68       	lsl	r8,0x2
800062c4:	12 08       	add	r8,r9
800062c6:	a3 68       	lsl	r8,0x2
800062c8:	10 99       	mov	r9,r8
800062ca:	49 68       	lddpc	r8,80006320 <xTaskRemoveFromEventList+0xc0>
800062cc:	f2 08 00 08 	add	r8,r9,r8
800062d0:	14 9b       	mov	r11,r10
800062d2:	10 9c       	mov	r12,r8
800062d4:	f0 1f 00 14 	mcall	80006324 <xTaskRemoveFromEventList+0xc4>
800062d8:	c0 88       	rjmp	800062e8 <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800062da:	ee f8 ff f8 	ld.w	r8,r7[-8]
800062de:	2e 88       	sub	r8,-24
800062e0:	10 9b       	mov	r11,r8
800062e2:	49 2c       	lddpc	r12,80006328 <xTaskRemoveFromEventList+0xc8>
800062e4:	f0 1f 00 10 	mcall	80006324 <xTaskRemoveFromEventList+0xc4>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800062e8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800062ec:	70 b9       	ld.w	r9,r8[0x2c]
800062ee:	49 08       	lddpc	r8,8000632c <xTaskRemoveFromEventList+0xcc>
800062f0:	70 08       	ld.w	r8,r8[0x0]
800062f2:	70 b8       	ld.w	r8,r8[0x2c]
800062f4:	10 39       	cp.w	r9,r8
800062f6:	c0 53       	brcs	80006300 <xTaskRemoveFromEventList+0xa0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
800062f8:	30 18       	mov	r8,1
800062fa:	ef 48 ff fc 	st.w	r7[-4],r8
800062fe:	c0 48       	rjmp	80006306 <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		xReturn = pdFALSE;
80006300:	30 08       	mov	r8,0
80006302:	ef 48 ff fc 	st.w	r7[-4],r8
	}

	return xReturn;
80006306:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000630a:	10 9c       	mov	r12,r8
8000630c:	2f dd       	sub	sp,-12
8000630e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006312:	00 00       	add	r0,r0
80006314:	80 00       	ld.sh	r0,r0[0x0]
80006316:	4b a2       	lddpc	r2,800063fc <xTaskCheckForTimeOut+0x9c>
80006318:	00 00       	add	r0,r0
8000631a:	07 94       	ld.ub	r4,r3[0x1]
8000631c:	00 00       	add	r0,r0
8000631e:	07 8c       	ld.ub	r12,r3[0x0]
80006320:	00 00       	add	r0,r0
80006322:	06 70       	tst	r0,r3
80006324:	80 00       	ld.sh	r0,r0[0x0]
80006326:	4a 8e       	lddpc	lr,800063c4 <xTaskCheckForTimeOut+0x64>
80006328:	00 00       	add	r0,r0
8000632a:	07 40       	ld.w	r0,--r3
8000632c:	00 00       	add	r0,r0
8000632e:	06 6c       	and	r12,r3

80006330 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
80006330:	eb cd 40 80 	pushm	r7,lr
80006334:	1a 97       	mov	r7,sp
80006336:	20 1d       	sub	sp,4
80006338:	ef 4c ff fc 	st.w	r7[-4],r12
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000633c:	48 78       	lddpc	r8,80006358 <vTaskSetTimeOutState+0x28>
8000633e:	70 09       	ld.w	r9,r8[0x0]
80006340:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006344:	91 09       	st.w	r8[0x0],r9
	pxTimeOut->xTimeOnEntering = xTickCount;
80006346:	48 68       	lddpc	r8,8000635c <vTaskSetTimeOutState+0x2c>
80006348:	70 09       	ld.w	r9,r8[0x0]
8000634a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000634e:	91 19       	st.w	r8[0x4],r9
}
80006350:	2f fd       	sub	sp,-4
80006352:	e3 cd 80 80 	ldm	sp++,r7,pc
80006356:	00 00       	add	r0,r0
80006358:	00 00       	add	r0,r0
8000635a:	07 a0       	ld.ub	r0,r3[0x2]
8000635c:	00 00       	add	r0,r0
8000635e:	07 84       	ld.ub	r4,r3[0x0]

80006360 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006360:	eb cd 40 80 	pushm	r7,lr
80006364:	1a 97       	mov	r7,sp
80006366:	20 3d       	sub	sp,12
80006368:	ef 4c ff f8 	st.w	r7[-8],r12
8000636c:	ef 4b ff f4 	st.w	r7[-12],r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006370:	f0 1f 00 25 	mcall	80006404 <xTaskCheckForTimeOut+0xa4>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006374:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006378:	70 08       	ld.w	r8,r8[0x0]
8000637a:	5b f8       	cp.w	r8,-1
8000637c:	c0 51       	brne	80006386 <xTaskCheckForTimeOut+0x26>
			{
				xReturn = pdFALSE;
8000637e:	30 08       	mov	r8,0
80006380:	ef 48 ff fc 	st.w	r7[-4],r8
80006384:	c3 88       	rjmp	800063f4 <xTaskCheckForTimeOut+0x94>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80006386:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000638a:	70 09       	ld.w	r9,r8[0x0]
8000638c:	49 f8       	lddpc	r8,80006408 <xTaskCheckForTimeOut+0xa8>
8000638e:	70 08       	ld.w	r8,r8[0x0]
80006390:	10 39       	cp.w	r9,r8
80006392:	c0 d0       	breq	800063ac <xTaskCheckForTimeOut+0x4c>
80006394:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006398:	70 19       	ld.w	r9,r8[0x4]
8000639a:	49 d8       	lddpc	r8,8000640c <xTaskCheckForTimeOut+0xac>
8000639c:	70 08       	ld.w	r8,r8[0x0]
8000639e:	10 39       	cp.w	r9,r8
800063a0:	e0 8b 00 06 	brhi	800063ac <xTaskCheckForTimeOut+0x4c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
800063a4:	30 18       	mov	r8,1
800063a6:	ef 48 ff fc 	st.w	r7[-4],r8
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800063aa:	c2 58       	rjmp	800063f4 <xTaskCheckForTimeOut+0x94>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800063ac:	49 88       	lddpc	r8,8000640c <xTaskCheckForTimeOut+0xac>
800063ae:	70 09       	ld.w	r9,r8[0x0]
800063b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800063b4:	70 18       	ld.w	r8,r8[0x4]
800063b6:	10 19       	sub	r9,r8
800063b8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800063bc:	70 08       	ld.w	r8,r8[0x0]
800063be:	10 39       	cp.w	r9,r8
800063c0:	c1 72       	brcc	800063ee <xTaskCheckForTimeOut+0x8e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800063c2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800063c6:	70 09       	ld.w	r9,r8[0x0]
800063c8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800063cc:	70 1a       	ld.w	r10,r8[0x4]
800063ce:	49 08       	lddpc	r8,8000640c <xTaskCheckForTimeOut+0xac>
800063d0:	70 08       	ld.w	r8,r8[0x0]
800063d2:	f4 08 01 08 	sub	r8,r10,r8
800063d6:	10 09       	add	r9,r8
800063d8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800063dc:	91 09       	st.w	r8[0x0],r9
			vTaskSetTimeOutState( pxTimeOut );
800063de:	ee fc ff f8 	ld.w	r12,r7[-8]
800063e2:	f0 1f 00 0c 	mcall	80006410 <xTaskCheckForTimeOut+0xb0>
			xReturn = pdFALSE;
800063e6:	30 08       	mov	r8,0
800063e8:	ef 48 ff fc 	st.w	r7[-4],r8
800063ec:	c0 48       	rjmp	800063f4 <xTaskCheckForTimeOut+0x94>
		}
		else
		{
			xReturn = pdTRUE;
800063ee:	30 18       	mov	r8,1
800063f0:	ef 48 ff fc 	st.w	r7[-4],r8
		}
	}
	taskEXIT_CRITICAL();
800063f4:	f0 1f 00 08 	mcall	80006414 <xTaskCheckForTimeOut+0xb4>

	return xReturn;
800063f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800063fc:	10 9c       	mov	r12,r8
800063fe:	2f dd       	sub	sp,-12
80006400:	e3 cd 80 80 	ldm	sp++,r7,pc
80006404:	80 00       	ld.sh	r0,r0[0x0]
80006406:	4d b8       	lddpc	r8,80006570 <prvInitialiseTaskLists+0x7c>
80006408:	00 00       	add	r0,r0
8000640a:	07 a0       	ld.ub	r0,r3[0x2]
8000640c:	00 00       	add	r0,r0
8000640e:	07 84       	ld.ub	r4,r3[0x0]
80006410:	80 00       	ld.sh	r0,r0[0x0]
80006412:	63 30       	ld.w	r0,r1[0x4c]
80006414:	80 00       	ld.sh	r0,r0[0x0]
80006416:	4d d4       	lddpc	r4,80006588 <prvCheckTasksWaitingTermination>

80006418 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
80006418:	eb cd 40 80 	pushm	r7,lr
8000641c:	1a 97       	mov	r7,sp
	xMissedYield = pdTRUE;
8000641e:	48 38       	lddpc	r8,80006428 <vTaskMissedYield+0x10>
80006420:	30 19       	mov	r9,1
80006422:	91 09       	st.w	r8[0x0],r9
}
80006424:	e3 cd 80 80 	ldm	sp++,r7,pc
80006428:	00 00       	add	r0,r0
8000642a:	07 9c       	ld.ub	r12,r3[0x1]

8000642c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
8000642c:	eb cd 40 80 	pushm	r7,lr
80006430:	1a 97       	mov	r7,sp
80006432:	20 1d       	sub	sp,4
80006434:	ef 4c ff fc 	st.w	r7[-4],r12
80006438:	c0 28       	rjmp	8000643c <prvIdleTask+0x10>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
8000643a:	d7 03       	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
8000643c:	f0 1f 00 05 	mcall	80006450 <prvIdleTask+0x24>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006440:	48 58       	lddpc	r8,80006454 <prvIdleTask+0x28>
80006442:	70 08       	ld.w	r8,r8[0x0]
80006444:	58 18       	cp.w	r8,1
80006446:	fe 98 ff fa 	brls	8000643a <prvIdleTask+0xe>
			{
				taskYIELD();
8000644a:	d7 33       	scall
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
8000644c:	cf 8b       	rjmp	8000643c <prvIdleTask+0x10>
8000644e:	00 00       	add	r0,r0
80006450:	80 00       	ld.sh	r0,r0[0x0]
80006452:	65 88       	ld.w	r8,r2[0x60]
80006454:	00 00       	add	r0,r0
80006456:	06 70       	tst	r0,r3

80006458 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
80006458:	eb cd 40 80 	pushm	r7,lr
8000645c:	1a 97       	mov	r7,sp
8000645e:	20 5d       	sub	sp,20
80006460:	ef 4c ff fc 	st.w	r7[-4],r12
80006464:	ef 4b ff f8 	st.w	r7[-8],r11
80006468:	ef 4a ff f4 	st.w	r7[-12],r10
8000646c:	ef 49 ff f0 	st.w	r7[-16],r9
80006470:	ef 58 ff ec 	st.h	r7[-20],r8
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006474:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006478:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000647c:	2c c8       	sub	r8,-52
8000647e:	31 0a       	mov	r10,16
80006480:	12 9b       	mov	r11,r9
80006482:	10 9c       	mov	r12,r8
80006484:	f0 1f 00 1a 	mcall	800064ec <prvInitialiseTCBVariables+0x94>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006488:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000648c:	30 08       	mov	r8,0
8000648e:	f3 68 00 43 	st.b	r9[67],r8

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
80006492:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006496:	58 78       	cp.w	r8,7
80006498:	e0 88 00 05 	brls	800064a2 <prvInitialiseTCBVariables+0x4a>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
8000649c:	30 78       	mov	r8,7
8000649e:	ef 48 ff f4 	st.w	r7[-12],r8
	}

	pxTCB->uxPriority = uxPriority;
800064a2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800064a6:	ee f9 ff f4 	ld.w	r9,r7[-12]
800064aa:	91 b9       	st.w	r8[0x2c],r9
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800064ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800064b0:	2f c8       	sub	r8,-4
800064b2:	10 9c       	mov	r12,r8
800064b4:	f0 1f 00 0f 	mcall	800064f0 <prvInitialiseTCBVariables+0x98>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800064b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800064bc:	2e 88       	sub	r8,-24
800064be:	10 9c       	mov	r12,r8
800064c0:	f0 1f 00 0c 	mcall	800064f0 <prvInitialiseTCBVariables+0x98>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800064c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800064c8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800064cc:	91 49       	st.w	r8[0x10],r9

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800064ce:	ee f8 ff f4 	ld.w	r8,r7[-12]
800064d2:	f0 09 11 08 	rsub	r9,r8,8
800064d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800064da:	91 69       	st.w	r8[0x18],r9
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800064dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800064e0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800064e4:	91 99       	st.w	r8[0x24],r9
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
800064e6:	2f bd       	sub	sp,-20
800064e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800064ec:	80 00       	ld.sh	r0,r0[0x0]
800064ee:	72 84       	ld.w	r4,r9[0x20]
800064f0:	80 00       	ld.sh	r0,r0[0x0]
800064f2:	4a 74       	lddpc	r4,8000658c <prvCheckTasksWaitingTermination+0x4>

800064f4 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
800064f4:	eb cd 40 80 	pushm	r7,lr
800064f8:	1a 97       	mov	r7,sp
800064fa:	20 1d       	sub	sp,4
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800064fc:	30 08       	mov	r8,0
800064fe:	ef 48 ff fc 	st.w	r7[-4],r8
80006502:	c1 38       	rjmp	80006528 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006504:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006508:	12 98       	mov	r8,r9
8000650a:	a3 68       	lsl	r8,0x2
8000650c:	12 08       	add	r8,r9
8000650e:	a3 68       	lsl	r8,0x2
80006510:	10 99       	mov	r9,r8
80006512:	49 58       	lddpc	r8,80006564 <prvInitialiseTaskLists+0x70>
80006514:	f2 08 00 08 	add	r8,r9,r8
80006518:	10 9c       	mov	r12,r8
8000651a:	f0 1f 00 14 	mcall	80006568 <prvInitialiseTaskLists+0x74>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
8000651e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006522:	2f f8       	sub	r8,-1
80006524:	ef 48 ff fc 	st.w	r7[-4],r8
80006528:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000652c:	58 78       	cp.w	r8,7
8000652e:	fe 98 ff eb 	brls	80006504 <prvInitialiseTaskLists+0x10>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006532:	48 fc       	lddpc	r12,8000656c <prvInitialiseTaskLists+0x78>
80006534:	f0 1f 00 0d 	mcall	80006568 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006538:	48 ec       	lddpc	r12,80006570 <prvInitialiseTaskLists+0x7c>
8000653a:	f0 1f 00 0c 	mcall	80006568 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xPendingReadyList );
8000653e:	48 ec       	lddpc	r12,80006574 <prvInitialiseTaskLists+0x80>
80006540:	f0 1f 00 0a 	mcall	80006568 <prvInitialiseTaskLists+0x74>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006544:	48 dc       	lddpc	r12,80006578 <prvInitialiseTaskLists+0x84>
80006546:	f0 1f 00 09 	mcall	80006568 <prvInitialiseTaskLists+0x74>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
8000654a:	48 dc       	lddpc	r12,8000657c <prvInitialiseTaskLists+0x88>
8000654c:	f0 1f 00 07 	mcall	80006568 <prvInitialiseTaskLists+0x74>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006550:	48 c8       	lddpc	r8,80006580 <prvInitialiseTaskLists+0x8c>
80006552:	48 79       	lddpc	r9,8000656c <prvInitialiseTaskLists+0x78>
80006554:	91 09       	st.w	r8[0x0],r9
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006556:	48 c8       	lddpc	r8,80006584 <prvInitialiseTaskLists+0x90>
80006558:	48 69       	lddpc	r9,80006570 <prvInitialiseTaskLists+0x7c>
8000655a:	91 09       	st.w	r8[0x0],r9
}
8000655c:	2f fd       	sub	sp,-4
8000655e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006562:	00 00       	add	r0,r0
80006564:	00 00       	add	r0,r0
80006566:	06 70       	tst	r0,r3
80006568:	80 00       	ld.sh	r0,r0[0x0]
8000656a:	4a 28       	lddpc	r8,800065f0 <prvCheckTasksWaitingTermination+0x68>
8000656c:	00 00       	add	r0,r0
8000656e:	07 10       	ld.sh	r0,r3++
80006570:	00 00       	add	r0,r0
80006572:	07 24       	ld.uh	r4,r3++
80006574:	00 00       	add	r0,r0
80006576:	07 40       	ld.w	r0,--r3
80006578:	00 00       	add	r0,r0
8000657a:	07 54       	ld.sh	r4,--r3
8000657c:	00 00       	add	r0,r0
8000657e:	07 6c       	ld.uh	r12,--r3
80006580:	00 00       	add	r0,r0
80006582:	07 38       	ld.ub	r8,r3++
80006584:	00 00       	add	r0,r0
80006586:	07 3c       	ld.ub	r12,r3++

80006588 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
80006588:	eb cd 40 80 	pushm	r7,lr
8000658c:	1a 97       	mov	r7,sp
8000658e:	20 2d       	sub	sp,8
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006590:	49 b8       	lddpc	r8,800065fc <prvCheckTasksWaitingTermination+0x74>
80006592:	70 08       	ld.w	r8,r8[0x0]
80006594:	58 08       	cp.w	r8,0
80006596:	c2 f0       	breq	800065f4 <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
80006598:	f0 1f 00 1a 	mcall	80006600 <prvCheckTasksWaitingTermination+0x78>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000659c:	49 a8       	lddpc	r8,80006604 <prvCheckTasksWaitingTermination+0x7c>
8000659e:	70 08       	ld.w	r8,r8[0x0]
800065a0:	58 08       	cp.w	r8,0
800065a2:	5f 08       	sreq	r8
800065a4:	ef 48 ff f8 	st.w	r7[-8],r8
			xTaskResumeAll();
800065a8:	f0 1f 00 18 	mcall	80006608 <prvCheckTasksWaitingTermination+0x80>

			if( xListIsEmpty == pdFALSE )
800065ac:	ee f8 ff f8 	ld.w	r8,r7[-8]
800065b0:	58 08       	cp.w	r8,0
800065b2:	c2 11       	brne	800065f4 <prvCheckTasksWaitingTermination+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800065b4:	f0 1f 00 16 	mcall	8000660c <prvCheckTasksWaitingTermination+0x84>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800065b8:	49 38       	lddpc	r8,80006604 <prvCheckTasksWaitingTermination+0x7c>
800065ba:	2f 88       	sub	r8,-8
800065bc:	70 18       	ld.w	r8,r8[0x4]
800065be:	70 38       	ld.w	r8,r8[0xc]
800065c0:	ef 48 ff fc 	st.w	r7[-4],r8
					vListRemove( &( pxTCB->xGenericListItem ) );
800065c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800065c8:	2f c8       	sub	r8,-4
800065ca:	10 9c       	mov	r12,r8
800065cc:	f0 1f 00 11 	mcall	80006610 <prvCheckTasksWaitingTermination+0x88>
					--uxCurrentNumberOfTasks;
800065d0:	49 18       	lddpc	r8,80006614 <prvCheckTasksWaitingTermination+0x8c>
800065d2:	70 08       	ld.w	r8,r8[0x0]
800065d4:	f0 c9 00 01 	sub	r9,r8,1
800065d8:	48 f8       	lddpc	r8,80006614 <prvCheckTasksWaitingTermination+0x8c>
800065da:	91 09       	st.w	r8[0x0],r9
					--uxTasksDeleted;
800065dc:	48 88       	lddpc	r8,800065fc <prvCheckTasksWaitingTermination+0x74>
800065de:	70 08       	ld.w	r8,r8[0x0]
800065e0:	f0 c9 00 01 	sub	r9,r8,1
800065e4:	48 68       	lddpc	r8,800065fc <prvCheckTasksWaitingTermination+0x74>
800065e6:	91 09       	st.w	r8[0x0],r9
				}
				taskEXIT_CRITICAL();
800065e8:	f0 1f 00 0c 	mcall	80006618 <prvCheckTasksWaitingTermination+0x90>

				prvDeleteTCB( pxTCB );
800065ec:	ee fc ff fc 	ld.w	r12,r7[-4]
800065f0:	f0 1f 00 0b 	mcall	8000661c <prvCheckTasksWaitingTermination+0x94>
			}
		}
	}
	#endif
}
800065f4:	2f ed       	sub	sp,-8
800065f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800065fa:	00 00       	add	r0,r0
800065fc:	00 00       	add	r0,r0
800065fe:	07 68       	ld.uh	r8,--r3
80006600:	80 00       	ld.sh	r0,r0[0x0]
80006602:	5e 5c       	retlt	r12
80006604:	00 00       	add	r0,r0
80006606:	07 54       	ld.sh	r4,--r3
80006608:	80 00       	ld.sh	r0,r0[0x0]
8000660a:	5e 78       	retpl	r8
8000660c:	80 00       	ld.sh	r0,r0[0x0]
8000660e:	4d b8       	lddpc	r8,80006778 <__avr32_udiv64+0x18>
80006610:	80 00       	ld.sh	r0,r0[0x0]
80006612:	4b a2       	lddpc	r2,800066f8 <prvAllocateTCBAndStack+0x58>
80006614:	00 00       	add	r0,r0
80006616:	07 80       	ld.ub	r0,r3[0x0]
80006618:	80 00       	ld.sh	r0,r0[0x0]
8000661a:	4d d4       	lddpc	r4,8000678c <__avr32_udiv64+0x2c>
8000661c:	80 00       	ld.sh	r0,r0[0x0]
8000661e:	67 34       	ld.w	r4,r3[0x4c]

80006620 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006620:	eb cd 40 80 	pushm	r7,lr
80006624:	1a 97       	mov	r7,sp
80006626:	20 1d       	sub	sp,4
80006628:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000662c:	49 78       	lddpc	r8,80006688 <prvAddCurrentTaskToDelayedList+0x68>
8000662e:	70 08       	ld.w	r8,r8[0x0]
80006630:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006634:	91 19       	st.w	r8[0x4],r9

	if( xTimeToWake < xTickCount )
80006636:	49 68       	lddpc	r8,8000668c <prvAddCurrentTaskToDelayedList+0x6c>
80006638:	70 08       	ld.w	r8,r8[0x0]
8000663a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000663e:	10 39       	cp.w	r9,r8
80006640:	c0 c2       	brcc	80006658 <prvAddCurrentTaskToDelayedList+0x38>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006642:	49 28       	lddpc	r8,80006688 <prvAddCurrentTaskToDelayedList+0x68>
80006644:	70 08       	ld.w	r8,r8[0x0]
80006646:	f0 c9 ff fc 	sub	r9,r8,-4
8000664a:	49 28       	lddpc	r8,80006690 <prvAddCurrentTaskToDelayedList+0x70>
8000664c:	70 08       	ld.w	r8,r8[0x0]
8000664e:	12 9b       	mov	r11,r9
80006650:	10 9c       	mov	r12,r8
80006652:	f0 1f 00 11 	mcall	80006694 <prvAddCurrentTaskToDelayedList+0x74>
80006656:	c1 58       	rjmp	80006680 <prvAddCurrentTaskToDelayedList+0x60>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006658:	48 c8       	lddpc	r8,80006688 <prvAddCurrentTaskToDelayedList+0x68>
8000665a:	70 08       	ld.w	r8,r8[0x0]
8000665c:	f0 c9 ff fc 	sub	r9,r8,-4
80006660:	48 e8       	lddpc	r8,80006698 <prvAddCurrentTaskToDelayedList+0x78>
80006662:	70 08       	ld.w	r8,r8[0x0]
80006664:	12 9b       	mov	r11,r9
80006666:	10 9c       	mov	r12,r8
80006668:	f0 1f 00 0b 	mcall	80006694 <prvAddCurrentTaskToDelayedList+0x74>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
8000666c:	48 c8       	lddpc	r8,8000669c <prvAddCurrentTaskToDelayedList+0x7c>
8000666e:	70 08       	ld.w	r8,r8[0x0]
80006670:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006674:	10 39       	cp.w	r9,r8
80006676:	c0 52       	brcc	80006680 <prvAddCurrentTaskToDelayedList+0x60>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006678:	48 98       	lddpc	r8,8000669c <prvAddCurrentTaskToDelayedList+0x7c>
8000667a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000667e:	91 09       	st.w	r8[0x0],r9
		}
	}
}
80006680:	2f fd       	sub	sp,-4
80006682:	e3 cd 80 80 	ldm	sp++,r7,pc
80006686:	00 00       	add	r0,r0
80006688:	00 00       	add	r0,r0
8000668a:	06 6c       	and	r12,r3
8000668c:	00 00       	add	r0,r0
8000668e:	07 84       	ld.ub	r4,r3[0x0]
80006690:	00 00       	add	r0,r0
80006692:	07 3c       	ld.ub	r12,r3++
80006694:	80 00       	ld.sh	r0,r0[0x0]
80006696:	4b 00       	lddpc	r0,80006754 <prvDeleteTCB+0x20>
80006698:	00 00       	add	r0,r0
8000669a:	07 38       	ld.ub	r8,r3++
8000669c:	00 00       	add	r0,r0
8000669e:	00 24       	rsub	r4,r0

800066a0 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
800066a0:	eb cd 40 80 	pushm	r7,lr
800066a4:	1a 97       	mov	r7,sp
800066a6:	20 3d       	sub	sp,12
800066a8:	18 98       	mov	r8,r12
800066aa:	ef 4b ff f4 	st.w	r7[-12],r11
800066ae:	ef 58 ff f8 	st.h	r7[-8],r8
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800066b2:	34 4c       	mov	r12,68
800066b4:	f0 1f 00 1d 	mcall	80006728 <prvAllocateTCBAndStack+0x88>
800066b8:	18 98       	mov	r8,r12
800066ba:	ef 48 ff fc 	st.w	r7[-4],r8

	if( pxNewTCB != NULL )
800066be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800066c2:	58 08       	cp.w	r8,0
800066c4:	c2 c0       	breq	8000671c <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800066c6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800066ca:	58 08       	cp.w	r8,0
800066cc:	c0 91       	brne	800066de <prvAllocateTCBAndStack+0x3e>
800066ce:	ef 18 ff f8 	ld.uh	r8,r7[-8]
800066d2:	a3 68       	lsl	r8,0x2
800066d4:	10 9c       	mov	r12,r8
800066d6:	f0 1f 00 15 	mcall	80006728 <prvAllocateTCBAndStack+0x88>
800066da:	18 98       	mov	r8,r12
800066dc:	c0 38       	rjmp	800066e2 <prvAllocateTCBAndStack+0x42>
800066de:	ee f8 ff f4 	ld.w	r8,r7[-12]
800066e2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800066e6:	93 c8       	st.w	r9[0x30],r8

		if( pxNewTCB->pxStack == NULL )
800066e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800066ec:	70 c8       	ld.w	r8,r8[0x30]
800066ee:	58 08       	cp.w	r8,0
800066f0:	c0 91       	brne	80006702 <prvAllocateTCBAndStack+0x62>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800066f2:	ee fc ff fc 	ld.w	r12,r7[-4]
800066f6:	f0 1f 00 0e 	mcall	8000672c <prvAllocateTCBAndStack+0x8c>
			pxNewTCB = NULL;
800066fa:	30 08       	mov	r8,0
800066fc:	ef 48 ff fc 	st.w	r7[-4],r8
80006700:	c0 e8       	rjmp	8000671c <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006702:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80006706:	f0 09 15 02 	lsl	r9,r8,0x2
8000670a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000670e:	70 c8       	ld.w	r8,r8[0x30]
80006710:	12 9a       	mov	r10,r9
80006712:	e0 6b 00 a5 	mov	r11,165
80006716:	10 9c       	mov	r12,r8
80006718:	f0 1f 00 06 	mcall	80006730 <prvAllocateTCBAndStack+0x90>
		}
	}

	return pxNewTCB;
8000671c:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80006720:	10 9c       	mov	r12,r8
80006722:	2f dd       	sub	sp,-12
80006724:	e3 cd 80 80 	ldm	sp++,r7,pc
80006728:	80 00       	ld.sh	r0,r0[0x0]
8000672a:	51 60       	stdsp	sp[0x58],r0
8000672c:	80 00       	ld.sh	r0,r0[0x0]
8000672e:	51 9c       	stdsp	sp[0x64],r12
80006730:	80 00       	ld.sh	r0,r0[0x0]
80006732:	6f 94       	ld.w	r4,r7[0x64]

80006734 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
80006734:	eb cd 40 80 	pushm	r7,lr
80006738:	1a 97       	mov	r7,sp
8000673a:	20 1d       	sub	sp,4
8000673c:	ef 4c ff fc 	st.w	r7[-4],r12
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006740:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006744:	70 c8       	ld.w	r8,r8[0x30]
80006746:	10 9c       	mov	r12,r8
80006748:	f0 1f 00 05 	mcall	8000675c <prvDeleteTCB+0x28>
		vPortFree( pxTCB );
8000674c:	ee fc ff fc 	ld.w	r12,r7[-4]
80006750:	f0 1f 00 03 	mcall	8000675c <prvDeleteTCB+0x28>
	}
80006754:	2f fd       	sub	sp,-4
80006756:	e3 cd 80 80 	ldm	sp++,r7,pc
8000675a:	00 00       	add	r0,r0
8000675c:	80 00       	ld.sh	r0,r0[0x0]
8000675e:	51 9c       	stdsp	sp[0x64],r12

80006760 <__avr32_udiv64>:
80006760:	d4 31       	pushm	r0-r7,lr
80006762:	1a 97       	mov	r7,sp
80006764:	20 3d       	sub	sp,12
80006766:	10 9c       	mov	r12,r8
80006768:	12 9e       	mov	lr,r9
8000676a:	14 93       	mov	r3,r10
8000676c:	58 09       	cp.w	r9,0
8000676e:	e0 81 00 bd 	brne	800068e8 <__avr32_udiv64+0x188>
80006772:	16 38       	cp.w	r8,r11
80006774:	e0 88 00 40 	brls	800067f4 <__avr32_udiv64+0x94>
80006778:	f0 08 12 00 	clz	r8,r8
8000677c:	c0 d0       	breq	80006796 <__avr32_udiv64+0x36>
8000677e:	f6 08 09 4b 	lsl	r11,r11,r8
80006782:	f0 09 11 20 	rsub	r9,r8,32
80006786:	f8 08 09 4c 	lsl	r12,r12,r8
8000678a:	f4 09 0a 49 	lsr	r9,r10,r9
8000678e:	f4 08 09 43 	lsl	r3,r10,r8
80006792:	f3 eb 10 0b 	or	r11,r9,r11
80006796:	f8 0e 16 10 	lsr	lr,r12,0x10
8000679a:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000679e:	f6 0e 0d 00 	divu	r0,r11,lr
800067a2:	e6 0b 16 10 	lsr	r11,r3,0x10
800067a6:	00 99       	mov	r9,r0
800067a8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800067ac:	e0 0a 02 48 	mul	r8,r0,r10
800067b0:	10 3b       	cp.w	r11,r8
800067b2:	c0 a2       	brcc	800067c6 <__avr32_udiv64+0x66>
800067b4:	20 19       	sub	r9,1
800067b6:	18 0b       	add	r11,r12
800067b8:	18 3b       	cp.w	r11,r12
800067ba:	c0 63       	brcs	800067c6 <__avr32_udiv64+0x66>
800067bc:	10 3b       	cp.w	r11,r8
800067be:	f7 b9 03 01 	sublo	r9,1
800067c2:	f7 dc e3 0b 	addcs	r11,r11,r12
800067c6:	f6 08 01 01 	sub	r1,r11,r8
800067ca:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
800067ce:	e2 0e 0d 00 	divu	r0,r1,lr
800067d2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
800067d6:	00 98       	mov	r8,r0
800067d8:	e0 0a 02 4a 	mul	r10,r0,r10
800067dc:	14 33       	cp.w	r3,r10
800067de:	c0 82       	brcc	800067ee <__avr32_udiv64+0x8e>
800067e0:	20 18       	sub	r8,1
800067e2:	18 03       	add	r3,r12
800067e4:	18 33       	cp.w	r3,r12
800067e6:	c0 43       	brcs	800067ee <__avr32_udiv64+0x8e>
800067e8:	14 33       	cp.w	r3,r10
800067ea:	f7 b8 03 01 	sublo	r8,1
800067ee:	f1 e9 11 08 	or	r8,r8,r9<<0x10
800067f2:	cd f8       	rjmp	800069b0 <__avr32_udiv64+0x250>
800067f4:	58 08       	cp.w	r8,0
800067f6:	c0 51       	brne	80006800 <__avr32_udiv64+0xa0>
800067f8:	30 19       	mov	r9,1
800067fa:	f2 08 0d 08 	divu	r8,r9,r8
800067fe:	10 9c       	mov	r12,r8
80006800:	f8 06 12 00 	clz	r6,r12
80006804:	c0 41       	brne	8000680c <__avr32_udiv64+0xac>
80006806:	18 1b       	sub	r11,r12
80006808:	30 19       	mov	r9,1
8000680a:	c4 08       	rjmp	8000688a <__avr32_udiv64+0x12a>
8000680c:	ec 01 11 20 	rsub	r1,r6,32
80006810:	f4 01 0a 49 	lsr	r9,r10,r1
80006814:	f8 06 09 4c 	lsl	r12,r12,r6
80006818:	f6 06 09 48 	lsl	r8,r11,r6
8000681c:	f6 01 0a 41 	lsr	r1,r11,r1
80006820:	f3 e8 10 08 	or	r8,r9,r8
80006824:	f8 03 16 10 	lsr	r3,r12,0x10
80006828:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000682c:	e2 03 0d 00 	divu	r0,r1,r3
80006830:	f0 0b 16 10 	lsr	r11,r8,0x10
80006834:	00 9e       	mov	lr,r0
80006836:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000683a:	e0 05 02 49 	mul	r9,r0,r5
8000683e:	12 3b       	cp.w	r11,r9
80006840:	c0 a2       	brcc	80006854 <__avr32_udiv64+0xf4>
80006842:	20 1e       	sub	lr,1
80006844:	18 0b       	add	r11,r12
80006846:	18 3b       	cp.w	r11,r12
80006848:	c0 63       	brcs	80006854 <__avr32_udiv64+0xf4>
8000684a:	12 3b       	cp.w	r11,r9
8000684c:	f7 be 03 01 	sublo	lr,1
80006850:	f7 dc e3 0b 	addcs	r11,r11,r12
80006854:	12 1b       	sub	r11,r9
80006856:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000685a:	f6 03 0d 02 	divu	r2,r11,r3
8000685e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
80006862:	04 99       	mov	r9,r2
80006864:	e4 05 02 4b 	mul	r11,r2,r5
80006868:	16 38       	cp.w	r8,r11
8000686a:	c0 a2       	brcc	8000687e <__avr32_udiv64+0x11e>
8000686c:	20 19       	sub	r9,1
8000686e:	18 08       	add	r8,r12
80006870:	18 38       	cp.w	r8,r12
80006872:	c0 63       	brcs	8000687e <__avr32_udiv64+0x11e>
80006874:	16 38       	cp.w	r8,r11
80006876:	f7 b9 03 01 	sublo	r9,1
8000687a:	f1 dc e3 08 	addcs	r8,r8,r12
8000687e:	f4 06 09 43 	lsl	r3,r10,r6
80006882:	f0 0b 01 0b 	sub	r11,r8,r11
80006886:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000688a:	f8 06 16 10 	lsr	r6,r12,0x10
8000688e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
80006892:	f6 06 0d 00 	divu	r0,r11,r6
80006896:	e6 0b 16 10 	lsr	r11,r3,0x10
8000689a:	00 9a       	mov	r10,r0
8000689c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800068a0:	e0 0e 02 48 	mul	r8,r0,lr
800068a4:	10 3b       	cp.w	r11,r8
800068a6:	c0 a2       	brcc	800068ba <__avr32_udiv64+0x15a>
800068a8:	20 1a       	sub	r10,1
800068aa:	18 0b       	add	r11,r12
800068ac:	18 3b       	cp.w	r11,r12
800068ae:	c0 63       	brcs	800068ba <__avr32_udiv64+0x15a>
800068b0:	10 3b       	cp.w	r11,r8
800068b2:	f7 ba 03 01 	sublo	r10,1
800068b6:	f7 dc e3 0b 	addcs	r11,r11,r12
800068ba:	f6 08 01 01 	sub	r1,r11,r8
800068be:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
800068c2:	e2 06 0d 00 	divu	r0,r1,r6
800068c6:	e7 e1 11 03 	or	r3,r3,r1<<0x10
800068ca:	00 98       	mov	r8,r0
800068cc:	e0 0e 02 4b 	mul	r11,r0,lr
800068d0:	16 33       	cp.w	r3,r11
800068d2:	c0 82       	brcc	800068e2 <__avr32_udiv64+0x182>
800068d4:	20 18       	sub	r8,1
800068d6:	18 03       	add	r3,r12
800068d8:	18 33       	cp.w	r3,r12
800068da:	c0 43       	brcs	800068e2 <__avr32_udiv64+0x182>
800068dc:	16 33       	cp.w	r3,r11
800068de:	f7 b8 03 01 	sublo	r8,1
800068e2:	f1 ea 11 08 	or	r8,r8,r10<<0x10
800068e6:	c6 98       	rjmp	800069b8 <__avr32_udiv64+0x258>
800068e8:	16 39       	cp.w	r9,r11
800068ea:	e0 8b 00 65 	brhi	800069b4 <__avr32_udiv64+0x254>
800068ee:	f2 09 12 00 	clz	r9,r9
800068f2:	c0 b1       	brne	80006908 <__avr32_udiv64+0x1a8>
800068f4:	10 3a       	cp.w	r10,r8
800068f6:	5f 2a       	srhs	r10
800068f8:	1c 3b       	cp.w	r11,lr
800068fa:	5f b8       	srhi	r8
800068fc:	10 4a       	or	r10,r8
800068fe:	f2 0a 18 00 	cp.b	r10,r9
80006902:	c5 90       	breq	800069b4 <__avr32_udiv64+0x254>
80006904:	30 18       	mov	r8,1
80006906:	c5 98       	rjmp	800069b8 <__avr32_udiv64+0x258>
80006908:	f0 09 09 46 	lsl	r6,r8,r9
8000690c:	f2 03 11 20 	rsub	r3,r9,32
80006910:	fc 09 09 4e 	lsl	lr,lr,r9
80006914:	f0 03 0a 48 	lsr	r8,r8,r3
80006918:	f6 09 09 4c 	lsl	r12,r11,r9
8000691c:	f4 03 0a 42 	lsr	r2,r10,r3
80006920:	ef 46 ff f4 	st.w	r7[-12],r6
80006924:	f6 03 0a 43 	lsr	r3,r11,r3
80006928:	18 42       	or	r2,r12
8000692a:	f1 ee 10 0c 	or	r12,r8,lr
8000692e:	f8 01 16 10 	lsr	r1,r12,0x10
80006932:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80006936:	e6 01 0d 04 	divu	r4,r3,r1
8000693a:	e4 03 16 10 	lsr	r3,r2,0x10
8000693e:	08 9e       	mov	lr,r4
80006940:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80006944:	e8 06 02 48 	mul	r8,r4,r6
80006948:	10 33       	cp.w	r3,r8
8000694a:	c0 a2       	brcc	8000695e <__avr32_udiv64+0x1fe>
8000694c:	20 1e       	sub	lr,1
8000694e:	18 03       	add	r3,r12
80006950:	18 33       	cp.w	r3,r12
80006952:	c0 63       	brcs	8000695e <__avr32_udiv64+0x1fe>
80006954:	10 33       	cp.w	r3,r8
80006956:	f7 be 03 01 	sublo	lr,1
8000695a:	e7 dc e3 03 	addcs	r3,r3,r12
8000695e:	10 13       	sub	r3,r8
80006960:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
80006964:	e6 01 0d 00 	divu	r0,r3,r1
80006968:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000696c:	00 98       	mov	r8,r0
8000696e:	e0 06 02 46 	mul	r6,r0,r6
80006972:	0c 3b       	cp.w	r11,r6
80006974:	c0 a2       	brcc	80006988 <__avr32_udiv64+0x228>
80006976:	20 18       	sub	r8,1
80006978:	18 0b       	add	r11,r12
8000697a:	18 3b       	cp.w	r11,r12
8000697c:	c0 63       	brcs	80006988 <__avr32_udiv64+0x228>
8000697e:	0c 3b       	cp.w	r11,r6
80006980:	f7 dc e3 0b 	addcs	r11,r11,r12
80006984:	f7 b8 03 01 	sublo	r8,1
80006988:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000698c:	ee f4 ff f4 	ld.w	r4,r7[-12]
80006990:	0c 1b       	sub	r11,r6
80006992:	f0 04 06 42 	mulu.d	r2,r8,r4
80006996:	06 95       	mov	r5,r3
80006998:	16 35       	cp.w	r5,r11
8000699a:	e0 8b 00 0a 	brhi	800069ae <__avr32_udiv64+0x24e>
8000699e:	5f 0b       	sreq	r11
800069a0:	f4 09 09 49 	lsl	r9,r10,r9
800069a4:	12 32       	cp.w	r2,r9
800069a6:	5f b9       	srhi	r9
800069a8:	f7 e9 00 09 	and	r9,r11,r9
800069ac:	c0 60       	breq	800069b8 <__avr32_udiv64+0x258>
800069ae:	20 18       	sub	r8,1
800069b0:	30 09       	mov	r9,0
800069b2:	c0 38       	rjmp	800069b8 <__avr32_udiv64+0x258>
800069b4:	30 09       	mov	r9,0
800069b6:	12 98       	mov	r8,r9
800069b8:	10 9a       	mov	r10,r8
800069ba:	12 93       	mov	r3,r9
800069bc:	10 92       	mov	r2,r8
800069be:	12 9b       	mov	r11,r9
800069c0:	2f dd       	sub	sp,-12
800069c2:	d8 32       	popm	r0-r7,pc

800069c4 <atexit>:
800069c4:	d4 01       	pushm	lr
800069c6:	30 09       	mov	r9,0
800069c8:	18 9b       	mov	r11,r12
800069ca:	12 9a       	mov	r10,r9
800069cc:	12 9c       	mov	r12,r9
800069ce:	e0 a0 05 01 	rcall	800073d0 <__register_exitproc>
800069d2:	d8 02       	popm	pc

800069d4 <exit>:
800069d4:	d4 21       	pushm	r4-r7,lr
800069d6:	30 0b       	mov	r11,0
800069d8:	18 97       	mov	r7,r12
800069da:	e0 a0 05 4d 	rcall	80007474 <__call_exitprocs>
800069de:	fe c8 a2 aa 	sub	r8,pc,-23894
800069e2:	70 0c       	ld.w	r12,r8[0x0]
800069e4:	78 a8       	ld.w	r8,r12[0x28]
800069e6:	58 08       	cp.w	r8,0
800069e8:	c0 20       	breq	800069ec <exit+0x18>
800069ea:	5d 18       	icall	r8
800069ec:	0e 9c       	mov	r12,r7
800069ee:	e0 a0 04 60 	rcall	800072ae <_exit>
800069f2:	d7 03       	nop

800069f4 <free>:
800069f4:	d4 01       	pushm	lr
800069f6:	e0 68 01 18 	mov	r8,280
800069fa:	18 9b       	mov	r11,r12
800069fc:	70 0c       	ld.w	r12,r8[0x0]
800069fe:	e0 a0 06 93 	rcall	80007724 <_free_r>
80006a02:	d8 02       	popm	pc

80006a04 <malloc>:
80006a04:	d4 01       	pushm	lr
80006a06:	e0 68 01 18 	mov	r8,280
80006a0a:	18 9b       	mov	r11,r12
80006a0c:	70 0c       	ld.w	r12,r8[0x0]
80006a0e:	c0 3c       	rcall	80006a14 <_malloc_r>
80006a10:	d8 02       	popm	pc
80006a12:	d7 03       	nop

80006a14 <_malloc_r>:
80006a14:	d4 31       	pushm	r0-r7,lr
80006a16:	f6 c8 ff f5 	sub	r8,r11,-11
80006a1a:	18 95       	mov	r5,r12
80006a1c:	10 97       	mov	r7,r8
80006a1e:	e0 17 ff f8 	andl	r7,0xfff8
80006a22:	59 68       	cp.w	r8,22
80006a24:	f9 b7 08 10 	movls	r7,16
80006a28:	16 37       	cp.w	r7,r11
80006a2a:	5f 38       	srlo	r8
80006a2c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006a30:	c0 50       	breq	80006a3a <_malloc_r+0x26>
80006a32:	30 c8       	mov	r8,12
80006a34:	99 38       	st.w	r12[0xc],r8
80006a36:	e0 8f 01 fa 	bral	80006e2a <_malloc_r+0x416>
80006a3a:	fe b0 f1 15 	rcall	80004c64 <__malloc_lock>
80006a3e:	e0 47 01 f7 	cp.w	r7,503
80006a42:	e0 8b 00 1d 	brhi	80006a7c <_malloc_r+0x68>
80006a46:	ee 03 16 03 	lsr	r3,r7,0x3
80006a4a:	e0 68 01 1c 	mov	r8,284
80006a4e:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006a52:	70 36       	ld.w	r6,r8[0xc]
80006a54:	10 36       	cp.w	r6,r8
80006a56:	c0 61       	brne	80006a62 <_malloc_r+0x4e>
80006a58:	ec c8 ff f8 	sub	r8,r6,-8
80006a5c:	70 36       	ld.w	r6,r8[0xc]
80006a5e:	10 36       	cp.w	r6,r8
80006a60:	c0 c0       	breq	80006a78 <_malloc_r+0x64>
80006a62:	6c 18       	ld.w	r8,r6[0x4]
80006a64:	e0 18 ff fc 	andl	r8,0xfffc
80006a68:	6c 3a       	ld.w	r10,r6[0xc]
80006a6a:	ec 08 00 09 	add	r9,r6,r8
80006a6e:	0a 9c       	mov	r12,r5
80006a70:	6c 28       	ld.w	r8,r6[0x8]
80006a72:	95 28       	st.w	r10[0x8],r8
80006a74:	91 3a       	st.w	r8[0xc],r10
80006a76:	c4 78       	rjmp	80006b04 <_malloc_r+0xf0>
80006a78:	2f e3       	sub	r3,-2
80006a7a:	c4 d8       	rjmp	80006b14 <_malloc_r+0x100>
80006a7c:	ee 03 16 09 	lsr	r3,r7,0x9
80006a80:	c0 41       	brne	80006a88 <_malloc_r+0x74>
80006a82:	ee 03 16 03 	lsr	r3,r7,0x3
80006a86:	c2 68       	rjmp	80006ad2 <_malloc_r+0xbe>
80006a88:	58 43       	cp.w	r3,4
80006a8a:	e0 8b 00 06 	brhi	80006a96 <_malloc_r+0x82>
80006a8e:	ee 03 16 06 	lsr	r3,r7,0x6
80006a92:	2c 83       	sub	r3,-56
80006a94:	c1 f8       	rjmp	80006ad2 <_malloc_r+0xbe>
80006a96:	59 43       	cp.w	r3,20
80006a98:	e0 8b 00 04 	brhi	80006aa0 <_malloc_r+0x8c>
80006a9c:	2a 53       	sub	r3,-91
80006a9e:	c1 a8       	rjmp	80006ad2 <_malloc_r+0xbe>
80006aa0:	e0 43 00 54 	cp.w	r3,84
80006aa4:	e0 8b 00 06 	brhi	80006ab0 <_malloc_r+0x9c>
80006aa8:	ee 03 16 0c 	lsr	r3,r7,0xc
80006aac:	29 23       	sub	r3,-110
80006aae:	c1 28       	rjmp	80006ad2 <_malloc_r+0xbe>
80006ab0:	e0 43 01 54 	cp.w	r3,340
80006ab4:	e0 8b 00 06 	brhi	80006ac0 <_malloc_r+0xac>
80006ab8:	ee 03 16 0f 	lsr	r3,r7,0xf
80006abc:	28 93       	sub	r3,-119
80006abe:	c0 a8       	rjmp	80006ad2 <_malloc_r+0xbe>
80006ac0:	e0 43 05 54 	cp.w	r3,1364
80006ac4:	e0 88 00 04 	brls	80006acc <_malloc_r+0xb8>
80006ac8:	37 e3       	mov	r3,126
80006aca:	c0 48       	rjmp	80006ad2 <_malloc_r+0xbe>
80006acc:	ee 03 16 12 	lsr	r3,r7,0x12
80006ad0:	28 43       	sub	r3,-124
80006ad2:	e0 6a 01 1c 	mov	r10,284
80006ad6:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006ada:	74 36       	ld.w	r6,r10[0xc]
80006adc:	c1 98       	rjmp	80006b0e <_malloc_r+0xfa>
80006ade:	6c 19       	ld.w	r9,r6[0x4]
80006ae0:	e0 19 ff fc 	andl	r9,0xfffc
80006ae4:	f2 07 01 0b 	sub	r11,r9,r7
80006ae8:	58 fb       	cp.w	r11,15
80006aea:	e0 8a 00 04 	brle	80006af2 <_malloc_r+0xde>
80006aee:	20 13       	sub	r3,1
80006af0:	c1 18       	rjmp	80006b12 <_malloc_r+0xfe>
80006af2:	6c 38       	ld.w	r8,r6[0xc]
80006af4:	58 0b       	cp.w	r11,0
80006af6:	c0 b5       	brlt	80006b0c <_malloc_r+0xf8>
80006af8:	6c 2a       	ld.w	r10,r6[0x8]
80006afa:	ec 09 00 09 	add	r9,r6,r9
80006afe:	0a 9c       	mov	r12,r5
80006b00:	91 2a       	st.w	r8[0x8],r10
80006b02:	95 38       	st.w	r10[0xc],r8
80006b04:	72 18       	ld.w	r8,r9[0x4]
80006b06:	a1 a8       	sbr	r8,0x0
80006b08:	93 18       	st.w	r9[0x4],r8
80006b0a:	cb c8       	rjmp	80006c82 <_malloc_r+0x26e>
80006b0c:	10 96       	mov	r6,r8
80006b0e:	14 36       	cp.w	r6,r10
80006b10:	ce 71       	brne	80006ade <_malloc_r+0xca>
80006b12:	2f f3       	sub	r3,-1
80006b14:	e0 6a 01 1c 	mov	r10,284
80006b18:	f4 cc ff f8 	sub	r12,r10,-8
80006b1c:	78 26       	ld.w	r6,r12[0x8]
80006b1e:	18 36       	cp.w	r6,r12
80006b20:	c6 c0       	breq	80006bf8 <_malloc_r+0x1e4>
80006b22:	6c 19       	ld.w	r9,r6[0x4]
80006b24:	e0 19 ff fc 	andl	r9,0xfffc
80006b28:	f2 07 01 08 	sub	r8,r9,r7
80006b2c:	58 f8       	cp.w	r8,15
80006b2e:	e0 89 00 8f 	brgt	80006c4c <_malloc_r+0x238>
80006b32:	99 3c       	st.w	r12[0xc],r12
80006b34:	99 2c       	st.w	r12[0x8],r12
80006b36:	58 08       	cp.w	r8,0
80006b38:	c0 55       	brlt	80006b42 <_malloc_r+0x12e>
80006b3a:	ec 09 00 09 	add	r9,r6,r9
80006b3e:	0a 9c       	mov	r12,r5
80006b40:	ce 2b       	rjmp	80006b04 <_malloc_r+0xf0>
80006b42:	e0 49 01 ff 	cp.w	r9,511
80006b46:	e0 8b 00 13 	brhi	80006b6c <_malloc_r+0x158>
80006b4a:	a3 99       	lsr	r9,0x3
80006b4c:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006b50:	70 2b       	ld.w	r11,r8[0x8]
80006b52:	8d 38       	st.w	r6[0xc],r8
80006b54:	8d 2b       	st.w	r6[0x8],r11
80006b56:	97 36       	st.w	r11[0xc],r6
80006b58:	91 26       	st.w	r8[0x8],r6
80006b5a:	a3 49       	asr	r9,0x2
80006b5c:	74 18       	ld.w	r8,r10[0x4]
80006b5e:	30 1b       	mov	r11,1
80006b60:	f6 09 09 49 	lsl	r9,r11,r9
80006b64:	f1 e9 10 09 	or	r9,r8,r9
80006b68:	95 19       	st.w	r10[0x4],r9
80006b6a:	c4 78       	rjmp	80006bf8 <_malloc_r+0x1e4>
80006b6c:	f2 0a 16 09 	lsr	r10,r9,0x9
80006b70:	58 4a       	cp.w	r10,4
80006b72:	e0 8b 00 07 	brhi	80006b80 <_malloc_r+0x16c>
80006b76:	f2 0a 16 06 	lsr	r10,r9,0x6
80006b7a:	2c 8a       	sub	r10,-56
80006b7c:	c2 08       	rjmp	80006bbc <_malloc_r+0x1a8>
80006b7e:	d7 03       	nop
80006b80:	59 4a       	cp.w	r10,20
80006b82:	e0 8b 00 04 	brhi	80006b8a <_malloc_r+0x176>
80006b86:	2a 5a       	sub	r10,-91
80006b88:	c1 a8       	rjmp	80006bbc <_malloc_r+0x1a8>
80006b8a:	e0 4a 00 54 	cp.w	r10,84
80006b8e:	e0 8b 00 06 	brhi	80006b9a <_malloc_r+0x186>
80006b92:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006b96:	29 2a       	sub	r10,-110
80006b98:	c1 28       	rjmp	80006bbc <_malloc_r+0x1a8>
80006b9a:	e0 4a 01 54 	cp.w	r10,340
80006b9e:	e0 8b 00 06 	brhi	80006baa <_malloc_r+0x196>
80006ba2:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006ba6:	28 9a       	sub	r10,-119
80006ba8:	c0 a8       	rjmp	80006bbc <_malloc_r+0x1a8>
80006baa:	e0 4a 05 54 	cp.w	r10,1364
80006bae:	e0 88 00 04 	brls	80006bb6 <_malloc_r+0x1a2>
80006bb2:	37 ea       	mov	r10,126
80006bb4:	c0 48       	rjmp	80006bbc <_malloc_r+0x1a8>
80006bb6:	f2 0a 16 12 	lsr	r10,r9,0x12
80006bba:	28 4a       	sub	r10,-124
80006bbc:	e0 6b 01 1c 	mov	r11,284
80006bc0:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006bc4:	68 28       	ld.w	r8,r4[0x8]
80006bc6:	08 38       	cp.w	r8,r4
80006bc8:	c0 e1       	brne	80006be4 <_malloc_r+0x1d0>
80006bca:	76 19       	ld.w	r9,r11[0x4]
80006bcc:	a3 4a       	asr	r10,0x2
80006bce:	30 1e       	mov	lr,1
80006bd0:	fc 0a 09 4a 	lsl	r10,lr,r10
80006bd4:	f3 ea 10 0a 	or	r10,r9,r10
80006bd8:	10 99       	mov	r9,r8
80006bda:	97 1a       	st.w	r11[0x4],r10
80006bdc:	c0 a8       	rjmp	80006bf0 <_malloc_r+0x1dc>
80006bde:	70 28       	ld.w	r8,r8[0x8]
80006be0:	08 38       	cp.w	r8,r4
80006be2:	c0 60       	breq	80006bee <_malloc_r+0x1da>
80006be4:	70 1a       	ld.w	r10,r8[0x4]
80006be6:	e0 1a ff fc 	andl	r10,0xfffc
80006bea:	14 39       	cp.w	r9,r10
80006bec:	cf 93       	brcs	80006bde <_malloc_r+0x1ca>
80006bee:	70 39       	ld.w	r9,r8[0xc]
80006bf0:	8d 39       	st.w	r6[0xc],r9
80006bf2:	8d 28       	st.w	r6[0x8],r8
80006bf4:	91 36       	st.w	r8[0xc],r6
80006bf6:	93 26       	st.w	r9[0x8],r6
80006bf8:	e6 08 14 02 	asr	r8,r3,0x2
80006bfc:	30 1b       	mov	r11,1
80006bfe:	e0 64 01 1c 	mov	r4,284
80006c02:	f6 08 09 4b 	lsl	r11,r11,r8
80006c06:	68 18       	ld.w	r8,r4[0x4]
80006c08:	10 3b       	cp.w	r11,r8
80006c0a:	e0 8b 00 6b 	brhi	80006ce0 <_malloc_r+0x2cc>
80006c0e:	f7 e8 00 09 	and	r9,r11,r8
80006c12:	c0 b1       	brne	80006c28 <_malloc_r+0x214>
80006c14:	e0 13 ff fc 	andl	r3,0xfffc
80006c18:	a1 7b       	lsl	r11,0x1
80006c1a:	2f c3       	sub	r3,-4
80006c1c:	c0 38       	rjmp	80006c22 <_malloc_r+0x20e>
80006c1e:	2f c3       	sub	r3,-4
80006c20:	a1 7b       	lsl	r11,0x1
80006c22:	f7 e8 00 09 	and	r9,r11,r8
80006c26:	cf c0       	breq	80006c1e <_malloc_r+0x20a>
80006c28:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006c2c:	06 92       	mov	r2,r3
80006c2e:	1c 91       	mov	r1,lr
80006c30:	62 36       	ld.w	r6,r1[0xc]
80006c32:	c2 e8       	rjmp	80006c8e <_malloc_r+0x27a>
80006c34:	6c 1a       	ld.w	r10,r6[0x4]
80006c36:	e0 1a ff fc 	andl	r10,0xfffc
80006c3a:	f4 07 01 08 	sub	r8,r10,r7
80006c3e:	58 f8       	cp.w	r8,15
80006c40:	e0 8a 00 15 	brle	80006c6a <_malloc_r+0x256>
80006c44:	6c 3a       	ld.w	r10,r6[0xc]
80006c46:	6c 29       	ld.w	r9,r6[0x8]
80006c48:	95 29       	st.w	r10[0x8],r9
80006c4a:	93 3a       	st.w	r9[0xc],r10
80006c4c:	0e 99       	mov	r9,r7
80006c4e:	ec 07 00 07 	add	r7,r6,r7
80006c52:	a1 a9       	sbr	r9,0x0
80006c54:	99 37       	st.w	r12[0xc],r7
80006c56:	99 27       	st.w	r12[0x8],r7
80006c58:	8d 19       	st.w	r6[0x4],r9
80006c5a:	ee 08 09 08 	st.w	r7[r8],r8
80006c5e:	8f 2c       	st.w	r7[0x8],r12
80006c60:	8f 3c       	st.w	r7[0xc],r12
80006c62:	a1 a8       	sbr	r8,0x0
80006c64:	0a 9c       	mov	r12,r5
80006c66:	8f 18       	st.w	r7[0x4],r8
80006c68:	c0 d8       	rjmp	80006c82 <_malloc_r+0x26e>
80006c6a:	6c 39       	ld.w	r9,r6[0xc]
80006c6c:	58 08       	cp.w	r8,0
80006c6e:	c0 f5       	brlt	80006c8c <_malloc_r+0x278>
80006c70:	ec 0a 00 0a 	add	r10,r6,r10
80006c74:	74 18       	ld.w	r8,r10[0x4]
80006c76:	a1 a8       	sbr	r8,0x0
80006c78:	0a 9c       	mov	r12,r5
80006c7a:	95 18       	st.w	r10[0x4],r8
80006c7c:	6c 28       	ld.w	r8,r6[0x8]
80006c7e:	93 28       	st.w	r9[0x8],r8
80006c80:	91 39       	st.w	r8[0xc],r9
80006c82:	fe b0 ef ff 	rcall	80004c80 <__malloc_unlock>
80006c86:	ec cc ff f8 	sub	r12,r6,-8
80006c8a:	d8 32       	popm	r0-r7,pc
80006c8c:	12 96       	mov	r6,r9
80006c8e:	02 36       	cp.w	r6,r1
80006c90:	cd 21       	brne	80006c34 <_malloc_r+0x220>
80006c92:	2f f2       	sub	r2,-1
80006c94:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006c98:	c0 30       	breq	80006c9e <_malloc_r+0x28a>
80006c9a:	2f 81       	sub	r1,-8
80006c9c:	cc ab       	rjmp	80006c30 <_malloc_r+0x21c>
80006c9e:	1c 98       	mov	r8,lr
80006ca0:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006ca4:	c0 81       	brne	80006cb4 <_malloc_r+0x2a0>
80006ca6:	68 19       	ld.w	r9,r4[0x4]
80006ca8:	f6 08 11 ff 	rsub	r8,r11,-1
80006cac:	f3 e8 00 08 	and	r8,r9,r8
80006cb0:	89 18       	st.w	r4[0x4],r8
80006cb2:	c0 78       	rjmp	80006cc0 <_malloc_r+0x2ac>
80006cb4:	f0 c9 00 08 	sub	r9,r8,8
80006cb8:	20 13       	sub	r3,1
80006cba:	70 08       	ld.w	r8,r8[0x0]
80006cbc:	12 38       	cp.w	r8,r9
80006cbe:	cf 10       	breq	80006ca0 <_malloc_r+0x28c>
80006cc0:	a1 7b       	lsl	r11,0x1
80006cc2:	68 18       	ld.w	r8,r4[0x4]
80006cc4:	10 3b       	cp.w	r11,r8
80006cc6:	e0 8b 00 0d 	brhi	80006ce0 <_malloc_r+0x2cc>
80006cca:	58 0b       	cp.w	r11,0
80006ccc:	c0 a0       	breq	80006ce0 <_malloc_r+0x2cc>
80006cce:	04 93       	mov	r3,r2
80006cd0:	c0 38       	rjmp	80006cd6 <_malloc_r+0x2c2>
80006cd2:	2f c3       	sub	r3,-4
80006cd4:	a1 7b       	lsl	r11,0x1
80006cd6:	f7 e8 00 09 	and	r9,r11,r8
80006cda:	ca 71       	brne	80006c28 <_malloc_r+0x214>
80006cdc:	cf bb       	rjmp	80006cd2 <_malloc_r+0x2be>
80006cde:	d7 03       	nop
80006ce0:	68 23       	ld.w	r3,r4[0x8]
80006ce2:	66 12       	ld.w	r2,r3[0x4]
80006ce4:	e0 12 ff fc 	andl	r2,0xfffc
80006ce8:	0e 32       	cp.w	r2,r7
80006cea:	5f 39       	srlo	r9
80006cec:	e4 07 01 08 	sub	r8,r2,r7
80006cf0:	58 f8       	cp.w	r8,15
80006cf2:	5f aa       	srle	r10
80006cf4:	f5 e9 10 09 	or	r9,r10,r9
80006cf8:	e0 80 00 9a 	breq	80006e2c <_malloc_r+0x418>
80006cfc:	e0 68 07 b0 	mov	r8,1968
80006d00:	70 01       	ld.w	r1,r8[0x0]
80006d02:	e0 68 05 28 	mov	r8,1320
80006d06:	2f 01       	sub	r1,-16
80006d08:	70 08       	ld.w	r8,r8[0x0]
80006d0a:	0e 01       	add	r1,r7
80006d0c:	5b f8       	cp.w	r8,-1
80006d0e:	c0 40       	breq	80006d16 <_malloc_r+0x302>
80006d10:	28 11       	sub	r1,-127
80006d12:	e0 11 ff 80 	andl	r1,0xff80
80006d16:	02 9b       	mov	r11,r1
80006d18:	0a 9c       	mov	r12,r5
80006d1a:	e0 a0 02 a5 	rcall	80007264 <_sbrk_r>
80006d1e:	18 96       	mov	r6,r12
80006d20:	5b fc       	cp.w	r12,-1
80006d22:	c7 50       	breq	80006e0c <_malloc_r+0x3f8>
80006d24:	e6 02 00 08 	add	r8,r3,r2
80006d28:	10 3c       	cp.w	r12,r8
80006d2a:	c0 32       	brcc	80006d30 <_malloc_r+0x31c>
80006d2c:	08 33       	cp.w	r3,r4
80006d2e:	c6 f1       	brne	80006e0c <_malloc_r+0x3f8>
80006d30:	e0 6a 07 b4 	mov	r10,1972
80006d34:	74 09       	ld.w	r9,r10[0x0]
80006d36:	e2 09 00 09 	add	r9,r1,r9
80006d3a:	95 09       	st.w	r10[0x0],r9
80006d3c:	10 36       	cp.w	r6,r8
80006d3e:	c0 a1       	brne	80006d52 <_malloc_r+0x33e>
80006d40:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006d44:	c0 71       	brne	80006d52 <_malloc_r+0x33e>
80006d46:	e2 02 00 02 	add	r2,r1,r2
80006d4a:	68 28       	ld.w	r8,r4[0x8]
80006d4c:	a1 a2       	sbr	r2,0x0
80006d4e:	91 12       	st.w	r8[0x4],r2
80006d50:	c4 f8       	rjmp	80006dee <_malloc_r+0x3da>
80006d52:	e0 6a 05 28 	mov	r10,1320
80006d56:	74 0b       	ld.w	r11,r10[0x0]
80006d58:	5b fb       	cp.w	r11,-1
80006d5a:	c0 31       	brne	80006d60 <_malloc_r+0x34c>
80006d5c:	95 06       	st.w	r10[0x0],r6
80006d5e:	c0 78       	rjmp	80006d6c <_malloc_r+0x358>
80006d60:	ec 09 00 09 	add	r9,r6,r9
80006d64:	e0 6a 07 b4 	mov	r10,1972
80006d68:	10 19       	sub	r9,r8
80006d6a:	95 09       	st.w	r10[0x0],r9
80006d6c:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006d70:	f0 09 11 08 	rsub	r9,r8,8
80006d74:	58 08       	cp.w	r8,0
80006d76:	f2 08 17 10 	movne	r8,r9
80006d7a:	ed d8 e1 06 	addne	r6,r6,r8
80006d7e:	28 08       	sub	r8,-128
80006d80:	ec 01 00 01 	add	r1,r6,r1
80006d84:	0a 9c       	mov	r12,r5
80006d86:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006d8a:	f0 01 01 01 	sub	r1,r8,r1
80006d8e:	02 9b       	mov	r11,r1
80006d90:	e0 a0 02 6a 	rcall	80007264 <_sbrk_r>
80006d94:	e0 68 07 b4 	mov	r8,1972
80006d98:	5b fc       	cp.w	r12,-1
80006d9a:	ec 0c 17 00 	moveq	r12,r6
80006d9e:	f9 b1 00 00 	moveq	r1,0
80006da2:	70 09       	ld.w	r9,r8[0x0]
80006da4:	0c 1c       	sub	r12,r6
80006da6:	89 26       	st.w	r4[0x8],r6
80006da8:	02 0c       	add	r12,r1
80006daa:	12 01       	add	r1,r9
80006dac:	a1 ac       	sbr	r12,0x0
80006dae:	91 01       	st.w	r8[0x0],r1
80006db0:	8d 1c       	st.w	r6[0x4],r12
80006db2:	08 33       	cp.w	r3,r4
80006db4:	c1 d0       	breq	80006dee <_malloc_r+0x3da>
80006db6:	58 f2       	cp.w	r2,15
80006db8:	e0 8b 00 05 	brhi	80006dc2 <_malloc_r+0x3ae>
80006dbc:	30 18       	mov	r8,1
80006dbe:	8d 18       	st.w	r6[0x4],r8
80006dc0:	c2 68       	rjmp	80006e0c <_malloc_r+0x3f8>
80006dc2:	30 59       	mov	r9,5
80006dc4:	20 c2       	sub	r2,12
80006dc6:	e0 12 ff f8 	andl	r2,0xfff8
80006dca:	e6 02 00 08 	add	r8,r3,r2
80006dce:	91 29       	st.w	r8[0x8],r9
80006dd0:	91 19       	st.w	r8[0x4],r9
80006dd2:	66 18       	ld.w	r8,r3[0x4]
80006dd4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006dd8:	e5 e8 10 08 	or	r8,r2,r8
80006ddc:	87 18       	st.w	r3[0x4],r8
80006dde:	58 f2       	cp.w	r2,15
80006de0:	e0 88 00 07 	brls	80006dee <_malloc_r+0x3da>
80006de4:	e6 cb ff f8 	sub	r11,r3,-8
80006de8:	0a 9c       	mov	r12,r5
80006dea:	e0 a0 04 9d 	rcall	80007724 <_free_r>
80006dee:	e0 69 07 ac 	mov	r9,1964
80006df2:	72 0a       	ld.w	r10,r9[0x0]
80006df4:	e0 68 07 b4 	mov	r8,1972
80006df8:	70 08       	ld.w	r8,r8[0x0]
80006dfa:	14 38       	cp.w	r8,r10
80006dfc:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006e00:	e0 69 07 a8 	mov	r9,1960
80006e04:	72 0a       	ld.w	r10,r9[0x0]
80006e06:	14 38       	cp.w	r8,r10
80006e08:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006e0c:	68 28       	ld.w	r8,r4[0x8]
80006e0e:	70 18       	ld.w	r8,r8[0x4]
80006e10:	e0 18 ff fc 	andl	r8,0xfffc
80006e14:	0e 38       	cp.w	r8,r7
80006e16:	5f 39       	srlo	r9
80006e18:	0e 18       	sub	r8,r7
80006e1a:	58 f8       	cp.w	r8,15
80006e1c:	5f aa       	srle	r10
80006e1e:	f5 e9 10 09 	or	r9,r10,r9
80006e22:	c0 50       	breq	80006e2c <_malloc_r+0x418>
80006e24:	0a 9c       	mov	r12,r5
80006e26:	fe b0 ef 2d 	rcall	80004c80 <__malloc_unlock>
80006e2a:	d8 3a       	popm	r0-r7,pc,r12=0
80006e2c:	68 26       	ld.w	r6,r4[0x8]
80006e2e:	a1 a8       	sbr	r8,0x0
80006e30:	0e 99       	mov	r9,r7
80006e32:	a1 a9       	sbr	r9,0x0
80006e34:	8d 19       	st.w	r6[0x4],r9
80006e36:	ec 07 00 07 	add	r7,r6,r7
80006e3a:	0a 9c       	mov	r12,r5
80006e3c:	89 27       	st.w	r4[0x8],r7
80006e3e:	8f 18       	st.w	r7[0x4],r8
80006e40:	fe b0 ef 20 	rcall	80004c80 <__malloc_unlock>
80006e44:	ec cc ff f8 	sub	r12,r6,-8
80006e48:	d8 32       	popm	r0-r7,pc
80006e4a:	d7 03       	nop

80006e4c <memcpy>:
80006e4c:	58 8a       	cp.w	r10,8
80006e4e:	c2 f5       	brlt	80006eac <memcpy+0x60>
80006e50:	f9 eb 10 09 	or	r9,r12,r11
80006e54:	e2 19 00 03 	andl	r9,0x3,COH
80006e58:	e0 81 00 97 	brne	80006f86 <memcpy+0x13a>
80006e5c:	e0 4a 00 20 	cp.w	r10,32
80006e60:	c3 b4       	brge	80006ed6 <memcpy+0x8a>
80006e62:	f4 08 14 02 	asr	r8,r10,0x2
80006e66:	f0 09 11 08 	rsub	r9,r8,8
80006e6a:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80006e6e:	76 69       	ld.w	r9,r11[0x18]
80006e70:	99 69       	st.w	r12[0x18],r9
80006e72:	76 59       	ld.w	r9,r11[0x14]
80006e74:	99 59       	st.w	r12[0x14],r9
80006e76:	76 49       	ld.w	r9,r11[0x10]
80006e78:	99 49       	st.w	r12[0x10],r9
80006e7a:	76 39       	ld.w	r9,r11[0xc]
80006e7c:	99 39       	st.w	r12[0xc],r9
80006e7e:	76 29       	ld.w	r9,r11[0x8]
80006e80:	99 29       	st.w	r12[0x8],r9
80006e82:	76 19       	ld.w	r9,r11[0x4]
80006e84:	99 19       	st.w	r12[0x4],r9
80006e86:	76 09       	ld.w	r9,r11[0x0]
80006e88:	99 09       	st.w	r12[0x0],r9
80006e8a:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006e8e:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006e92:	e0 1a 00 03 	andl	r10,0x3
80006e96:	f4 0a 11 04 	rsub	r10,r10,4
80006e9a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006e9e:	17 a9       	ld.ub	r9,r11[0x2]
80006ea0:	b0 a9       	st.b	r8[0x2],r9
80006ea2:	17 99       	ld.ub	r9,r11[0x1]
80006ea4:	b0 99       	st.b	r8[0x1],r9
80006ea6:	17 89       	ld.ub	r9,r11[0x0]
80006ea8:	b0 89       	st.b	r8[0x0],r9
80006eaa:	5e fc       	retal	r12
80006eac:	f4 0a 11 09 	rsub	r10,r10,9
80006eb0:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006eb4:	17 f9       	ld.ub	r9,r11[0x7]
80006eb6:	b8 f9       	st.b	r12[0x7],r9
80006eb8:	17 e9       	ld.ub	r9,r11[0x6]
80006eba:	b8 e9       	st.b	r12[0x6],r9
80006ebc:	17 d9       	ld.ub	r9,r11[0x5]
80006ebe:	b8 d9       	st.b	r12[0x5],r9
80006ec0:	17 c9       	ld.ub	r9,r11[0x4]
80006ec2:	b8 c9       	st.b	r12[0x4],r9
80006ec4:	17 b9       	ld.ub	r9,r11[0x3]
80006ec6:	b8 b9       	st.b	r12[0x3],r9
80006ec8:	17 a9       	ld.ub	r9,r11[0x2]
80006eca:	b8 a9       	st.b	r12[0x2],r9
80006ecc:	17 99       	ld.ub	r9,r11[0x1]
80006ece:	b8 99       	st.b	r12[0x1],r9
80006ed0:	17 89       	ld.ub	r9,r11[0x0]
80006ed2:	b8 89       	st.b	r12[0x0],r9
80006ed4:	5e fc       	retal	r12
80006ed6:	eb cd 40 c0 	pushm	r6-r7,lr
80006eda:	18 99       	mov	r9,r12
80006edc:	22 0a       	sub	r10,32
80006ede:	b7 07       	ld.d	r6,r11++
80006ee0:	b3 26       	st.d	r9++,r6
80006ee2:	b7 07       	ld.d	r6,r11++
80006ee4:	b3 26       	st.d	r9++,r6
80006ee6:	b7 07       	ld.d	r6,r11++
80006ee8:	b3 26       	st.d	r9++,r6
80006eea:	b7 07       	ld.d	r6,r11++
80006eec:	b3 26       	st.d	r9++,r6
80006eee:	22 0a       	sub	r10,32
80006ef0:	cf 74       	brge	80006ede <memcpy+0x92>
80006ef2:	2f 0a       	sub	r10,-16
80006ef4:	c0 65       	brlt	80006f00 <memcpy+0xb4>
80006ef6:	b7 07       	ld.d	r6,r11++
80006ef8:	b3 26       	st.d	r9++,r6
80006efa:	b7 07       	ld.d	r6,r11++
80006efc:	b3 26       	st.d	r9++,r6
80006efe:	21 0a       	sub	r10,16
80006f00:	5c 3a       	neg	r10
80006f02:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006f06:	d7 03       	nop
80006f08:	d7 03       	nop
80006f0a:	f7 36 00 0e 	ld.ub	r6,r11[14]
80006f0e:	f3 66 00 0e 	st.b	r9[14],r6
80006f12:	f7 36 00 0d 	ld.ub	r6,r11[13]
80006f16:	f3 66 00 0d 	st.b	r9[13],r6
80006f1a:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006f1e:	f3 66 00 0c 	st.b	r9[12],r6
80006f22:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006f26:	f3 66 00 0b 	st.b	r9[11],r6
80006f2a:	f7 36 00 0a 	ld.ub	r6,r11[10]
80006f2e:	f3 66 00 0a 	st.b	r9[10],r6
80006f32:	f7 36 00 09 	ld.ub	r6,r11[9]
80006f36:	f3 66 00 09 	st.b	r9[9],r6
80006f3a:	f7 36 00 08 	ld.ub	r6,r11[8]
80006f3e:	f3 66 00 08 	st.b	r9[8],r6
80006f42:	f7 36 00 07 	ld.ub	r6,r11[7]
80006f46:	f3 66 00 07 	st.b	r9[7],r6
80006f4a:	f7 36 00 06 	ld.ub	r6,r11[6]
80006f4e:	f3 66 00 06 	st.b	r9[6],r6
80006f52:	f7 36 00 05 	ld.ub	r6,r11[5]
80006f56:	f3 66 00 05 	st.b	r9[5],r6
80006f5a:	f7 36 00 04 	ld.ub	r6,r11[4]
80006f5e:	f3 66 00 04 	st.b	r9[4],r6
80006f62:	f7 36 00 03 	ld.ub	r6,r11[3]
80006f66:	f3 66 00 03 	st.b	r9[3],r6
80006f6a:	f7 36 00 02 	ld.ub	r6,r11[2]
80006f6e:	f3 66 00 02 	st.b	r9[2],r6
80006f72:	f7 36 00 01 	ld.ub	r6,r11[1]
80006f76:	f3 66 00 01 	st.b	r9[1],r6
80006f7a:	f7 36 00 00 	ld.ub	r6,r11[0]
80006f7e:	f3 66 00 00 	st.b	r9[0],r6
80006f82:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006f86:	20 1a       	sub	r10,1
80006f88:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006f8c:	f8 0a 0b 09 	st.b	r12[r10],r9
80006f90:	cf b1       	brne	80006f86 <memcpy+0x13a>
80006f92:	5e fc       	retal	r12

80006f94 <memset>:
80006f94:	18 98       	mov	r8,r12
80006f96:	c0 38       	rjmp	80006f9c <memset+0x8>
80006f98:	10 cb       	st.b	r8++,r11
80006f9a:	20 1a       	sub	r10,1
80006f9c:	58 0a       	cp.w	r10,0
80006f9e:	cf d1       	brne	80006f98 <memset+0x4>
80006fa0:	5e fc       	retal	r12
80006fa2:	d7 03       	nop

80006fa4 <_realloc_r>:
80006fa4:	d4 31       	pushm	r0-r7,lr
80006fa6:	20 1d       	sub	sp,4
80006fa8:	16 94       	mov	r4,r11
80006faa:	18 92       	mov	r2,r12
80006fac:	14 9b       	mov	r11,r10
80006fae:	58 04       	cp.w	r4,0
80006fb0:	c0 51       	brne	80006fba <_realloc_r+0x16>
80006fb2:	fe b0 fd 31 	rcall	80006a14 <_malloc_r>
80006fb6:	18 95       	mov	r5,r12
80006fb8:	c5 39       	rjmp	8000725e <_realloc_r+0x2ba>
80006fba:	50 0a       	stdsp	sp[0x0],r10
80006fbc:	fe b0 ee 54 	rcall	80004c64 <__malloc_lock>
80006fc0:	40 0b       	lddsp	r11,sp[0x0]
80006fc2:	f6 c8 ff f5 	sub	r8,r11,-11
80006fc6:	e8 c1 00 08 	sub	r1,r4,8
80006fca:	10 96       	mov	r6,r8
80006fcc:	62 1c       	ld.w	r12,r1[0x4]
80006fce:	e0 16 ff f8 	andl	r6,0xfff8
80006fd2:	59 68       	cp.w	r8,22
80006fd4:	f9 b6 08 10 	movls	r6,16
80006fd8:	16 36       	cp.w	r6,r11
80006fda:	5f 38       	srlo	r8
80006fdc:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006fe0:	c0 50       	breq	80006fea <_realloc_r+0x46>
80006fe2:	30 c8       	mov	r8,12
80006fe4:	30 05       	mov	r5,0
80006fe6:	85 38       	st.w	r2[0xc],r8
80006fe8:	c3 b9       	rjmp	8000725e <_realloc_r+0x2ba>
80006fea:	18 90       	mov	r0,r12
80006fec:	e0 10 ff fc 	andl	r0,0xfffc
80006ff0:	0c 30       	cp.w	r0,r6
80006ff2:	e0 84 01 0b 	brge	80007208 <_realloc_r+0x264>
80006ff6:	e0 68 01 1c 	mov	r8,284
80006ffa:	e2 00 00 09 	add	r9,r1,r0
80006ffe:	70 25       	ld.w	r5,r8[0x8]
80007000:	0a 39       	cp.w	r9,r5
80007002:	c0 90       	breq	80007014 <_realloc_r+0x70>
80007004:	72 1a       	ld.w	r10,r9[0x4]
80007006:	a1 ca       	cbr	r10,0x0
80007008:	f2 0a 00 0a 	add	r10,r9,r10
8000700c:	74 1a       	ld.w	r10,r10[0x4]
8000700e:	ed ba 00 00 	bld	r10,0x0
80007012:	c2 20       	breq	80007056 <_realloc_r+0xb2>
80007014:	72 1a       	ld.w	r10,r9[0x4]
80007016:	e0 1a ff fc 	andl	r10,0xfffc
8000701a:	f4 00 00 03 	add	r3,r10,r0
8000701e:	0a 39       	cp.w	r9,r5
80007020:	c1 31       	brne	80007046 <_realloc_r+0xa2>
80007022:	ec c7 ff f0 	sub	r7,r6,-16
80007026:	0e 33       	cp.w	r3,r7
80007028:	c1 95       	brlt	8000705a <_realloc_r+0xb6>
8000702a:	e2 06 00 09 	add	r9,r1,r6
8000702e:	0c 13       	sub	r3,r6
80007030:	a1 a3       	sbr	r3,0x0
80007032:	93 13       	st.w	r9[0x4],r3
80007034:	91 29       	st.w	r8[0x8],r9
80007036:	04 9c       	mov	r12,r2
80007038:	62 18       	ld.w	r8,r1[0x4]
8000703a:	08 95       	mov	r5,r4
8000703c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007040:	10 46       	or	r6,r8
80007042:	83 16       	st.w	r1[0x4],r6
80007044:	c0 b9       	rjmp	8000725a <_realloc_r+0x2b6>
80007046:	0c 33       	cp.w	r3,r6
80007048:	c0 95       	brlt	8000705a <_realloc_r+0xb6>
8000704a:	72 28       	ld.w	r8,r9[0x8]
8000704c:	02 97       	mov	r7,r1
8000704e:	72 39       	ld.w	r9,r9[0xc]
80007050:	93 28       	st.w	r9[0x8],r8
80007052:	91 39       	st.w	r8[0xc],r9
80007054:	cd c8       	rjmp	8000720c <_realloc_r+0x268>
80007056:	30 0a       	mov	r10,0
80007058:	14 99       	mov	r9,r10
8000705a:	ed bc 00 00 	bld	r12,0x0
8000705e:	e0 80 00 95 	breq	80007188 <_realloc_r+0x1e4>
80007062:	62 07       	ld.w	r7,r1[0x0]
80007064:	e2 07 01 07 	sub	r7,r1,r7
80007068:	6e 1c       	ld.w	r12,r7[0x4]
8000706a:	e0 1c ff fc 	andl	r12,0xfffc
8000706e:	58 09       	cp.w	r9,0
80007070:	c5 60       	breq	8000711c <_realloc_r+0x178>
80007072:	f8 00 00 03 	add	r3,r12,r0
80007076:	0a 39       	cp.w	r9,r5
80007078:	c4 81       	brne	80007108 <_realloc_r+0x164>
8000707a:	14 03       	add	r3,r10
8000707c:	ec c9 ff f0 	sub	r9,r6,-16
80007080:	12 33       	cp.w	r3,r9
80007082:	c4 d5       	brlt	8000711c <_realloc_r+0x178>
80007084:	6e 3a       	ld.w	r10,r7[0xc]
80007086:	6e 29       	ld.w	r9,r7[0x8]
80007088:	95 29       	st.w	r10[0x8],r9
8000708a:	93 3a       	st.w	r9[0xc],r10
8000708c:	ee c5 ff f8 	sub	r5,r7,-8
80007090:	e0 ca 00 04 	sub	r10,r0,4
80007094:	e0 4a 00 24 	cp.w	r10,36
80007098:	e0 8b 00 25 	brhi	800070e2 <_realloc_r+0x13e>
8000709c:	0a 99       	mov	r9,r5
8000709e:	59 3a       	cp.w	r10,19
800070a0:	e0 88 00 1a 	brls	800070d4 <_realloc_r+0x130>
800070a4:	09 09       	ld.w	r9,r4++
800070a6:	8b 09       	st.w	r5[0x0],r9
800070a8:	09 09       	ld.w	r9,r4++
800070aa:	8f 39       	st.w	r7[0xc],r9
800070ac:	ee c9 ff f0 	sub	r9,r7,-16
800070b0:	59 ba       	cp.w	r10,27
800070b2:	e0 88 00 11 	brls	800070d4 <_realloc_r+0x130>
800070b6:	09 0b       	ld.w	r11,r4++
800070b8:	93 0b       	st.w	r9[0x0],r11
800070ba:	09 09       	ld.w	r9,r4++
800070bc:	8f 59       	st.w	r7[0x14],r9
800070be:	ee c9 ff e8 	sub	r9,r7,-24
800070c2:	e0 4a 00 24 	cp.w	r10,36
800070c6:	c0 71       	brne	800070d4 <_realloc_r+0x130>
800070c8:	09 0a       	ld.w	r10,r4++
800070ca:	93 0a       	st.w	r9[0x0],r10
800070cc:	ee c9 ff e0 	sub	r9,r7,-32
800070d0:	09 0a       	ld.w	r10,r4++
800070d2:	8f 7a       	st.w	r7[0x1c],r10
800070d4:	09 0a       	ld.w	r10,r4++
800070d6:	12 aa       	st.w	r9++,r10
800070d8:	68 0a       	ld.w	r10,r4[0x0]
800070da:	93 0a       	st.w	r9[0x0],r10
800070dc:	68 1a       	ld.w	r10,r4[0x4]
800070de:	93 1a       	st.w	r9[0x4],r10
800070e0:	c0 78       	rjmp	800070ee <_realloc_r+0x14a>
800070e2:	50 08       	stdsp	sp[0x0],r8
800070e4:	08 9b       	mov	r11,r4
800070e6:	0a 9c       	mov	r12,r5
800070e8:	e0 a0 04 08 	rcall	800078f8 <memmove>
800070ec:	40 08       	lddsp	r8,sp[0x0]
800070ee:	ee 06 00 09 	add	r9,r7,r6
800070f2:	0c 13       	sub	r3,r6
800070f4:	a1 a3       	sbr	r3,0x0
800070f6:	93 13       	st.w	r9[0x4],r3
800070f8:	91 29       	st.w	r8[0x8],r9
800070fa:	04 9c       	mov	r12,r2
800070fc:	6e 18       	ld.w	r8,r7[0x4]
800070fe:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007102:	10 46       	or	r6,r8
80007104:	8f 16       	st.w	r7[0x4],r6
80007106:	ca a8       	rjmp	8000725a <_realloc_r+0x2b6>
80007108:	14 03       	add	r3,r10
8000710a:	0c 33       	cp.w	r3,r6
8000710c:	c0 85       	brlt	8000711c <_realloc_r+0x178>
8000710e:	72 28       	ld.w	r8,r9[0x8]
80007110:	72 39       	ld.w	r9,r9[0xc]
80007112:	93 28       	st.w	r9[0x8],r8
80007114:	91 39       	st.w	r8[0xc],r9
80007116:	6e 28       	ld.w	r8,r7[0x8]
80007118:	6e 39       	ld.w	r9,r7[0xc]
8000711a:	c0 78       	rjmp	80007128 <_realloc_r+0x184>
8000711c:	f8 00 00 03 	add	r3,r12,r0
80007120:	0c 33       	cp.w	r3,r6
80007122:	c3 35       	brlt	80007188 <_realloc_r+0x1e4>
80007124:	6e 39       	ld.w	r9,r7[0xc]
80007126:	6e 28       	ld.w	r8,r7[0x8]
80007128:	93 28       	st.w	r9[0x8],r8
8000712a:	91 39       	st.w	r8[0xc],r9
8000712c:	e0 ca 00 04 	sub	r10,r0,4
80007130:	ee cc ff f8 	sub	r12,r7,-8
80007134:	e0 4a 00 24 	cp.w	r10,36
80007138:	e0 8b 00 24 	brhi	80007180 <_realloc_r+0x1dc>
8000713c:	59 3a       	cp.w	r10,19
8000713e:	e0 88 00 1a 	brls	80007172 <_realloc_r+0x1ce>
80007142:	09 08       	ld.w	r8,r4++
80007144:	99 08       	st.w	r12[0x0],r8
80007146:	09 08       	ld.w	r8,r4++
80007148:	8f 38       	st.w	r7[0xc],r8
8000714a:	ee cc ff f0 	sub	r12,r7,-16
8000714e:	59 ba       	cp.w	r10,27
80007150:	e0 88 00 11 	brls	80007172 <_realloc_r+0x1ce>
80007154:	09 08       	ld.w	r8,r4++
80007156:	99 08       	st.w	r12[0x0],r8
80007158:	09 08       	ld.w	r8,r4++
8000715a:	8f 58       	st.w	r7[0x14],r8
8000715c:	ee cc ff e8 	sub	r12,r7,-24
80007160:	e0 4a 00 24 	cp.w	r10,36
80007164:	c0 71       	brne	80007172 <_realloc_r+0x1ce>
80007166:	09 08       	ld.w	r8,r4++
80007168:	99 08       	st.w	r12[0x0],r8
8000716a:	ee cc ff e0 	sub	r12,r7,-32
8000716e:	09 08       	ld.w	r8,r4++
80007170:	8f 78       	st.w	r7[0x1c],r8
80007172:	09 08       	ld.w	r8,r4++
80007174:	18 a8       	st.w	r12++,r8
80007176:	68 08       	ld.w	r8,r4[0x0]
80007178:	99 08       	st.w	r12[0x0],r8
8000717a:	68 18       	ld.w	r8,r4[0x4]
8000717c:	99 18       	st.w	r12[0x4],r8
8000717e:	c4 78       	rjmp	8000720c <_realloc_r+0x268>
80007180:	08 9b       	mov	r11,r4
80007182:	e0 a0 03 bb 	rcall	800078f8 <memmove>
80007186:	c4 38       	rjmp	8000720c <_realloc_r+0x268>
80007188:	04 9c       	mov	r12,r2
8000718a:	fe b0 fc 45 	rcall	80006a14 <_malloc_r>
8000718e:	18 95       	mov	r5,r12
80007190:	c3 a0       	breq	80007204 <_realloc_r+0x260>
80007192:	62 18       	ld.w	r8,r1[0x4]
80007194:	f8 c9 00 08 	sub	r9,r12,8
80007198:	a1 c8       	cbr	r8,0x0
8000719a:	e2 08 00 08 	add	r8,r1,r8
8000719e:	10 39       	cp.w	r9,r8
800071a0:	c0 71       	brne	800071ae <_realloc_r+0x20a>
800071a2:	72 13       	ld.w	r3,r9[0x4]
800071a4:	02 97       	mov	r7,r1
800071a6:	e0 13 ff fc 	andl	r3,0xfffc
800071aa:	00 03       	add	r3,r0
800071ac:	c3 08       	rjmp	8000720c <_realloc_r+0x268>
800071ae:	e0 ca 00 04 	sub	r10,r0,4
800071b2:	e0 4a 00 24 	cp.w	r10,36
800071b6:	e0 8b 00 20 	brhi	800071f6 <_realloc_r+0x252>
800071ba:	08 99       	mov	r9,r4
800071bc:	18 98       	mov	r8,r12
800071be:	59 3a       	cp.w	r10,19
800071c0:	e0 88 00 14 	brls	800071e8 <_realloc_r+0x244>
800071c4:	13 0b       	ld.w	r11,r9++
800071c6:	10 ab       	st.w	r8++,r11
800071c8:	13 0b       	ld.w	r11,r9++
800071ca:	10 ab       	st.w	r8++,r11
800071cc:	59 ba       	cp.w	r10,27
800071ce:	e0 88 00 0d 	brls	800071e8 <_realloc_r+0x244>
800071d2:	13 0b       	ld.w	r11,r9++
800071d4:	10 ab       	st.w	r8++,r11
800071d6:	13 0b       	ld.w	r11,r9++
800071d8:	10 ab       	st.w	r8++,r11
800071da:	e0 4a 00 24 	cp.w	r10,36
800071de:	c0 51       	brne	800071e8 <_realloc_r+0x244>
800071e0:	13 0a       	ld.w	r10,r9++
800071e2:	10 aa       	st.w	r8++,r10
800071e4:	13 0a       	ld.w	r10,r9++
800071e6:	10 aa       	st.w	r8++,r10
800071e8:	13 0a       	ld.w	r10,r9++
800071ea:	10 aa       	st.w	r8++,r10
800071ec:	72 0a       	ld.w	r10,r9[0x0]
800071ee:	91 0a       	st.w	r8[0x0],r10
800071f0:	72 19       	ld.w	r9,r9[0x4]
800071f2:	91 19       	st.w	r8[0x4],r9
800071f4:	c0 48       	rjmp	800071fc <_realloc_r+0x258>
800071f6:	08 9b       	mov	r11,r4
800071f8:	e0 a0 03 80 	rcall	800078f8 <memmove>
800071fc:	08 9b       	mov	r11,r4
800071fe:	04 9c       	mov	r12,r2
80007200:	e0 a0 02 92 	rcall	80007724 <_free_r>
80007204:	04 9c       	mov	r12,r2
80007206:	c2 a8       	rjmp	8000725a <_realloc_r+0x2b6>
80007208:	00 93       	mov	r3,r0
8000720a:	02 97       	mov	r7,r1
8000720c:	e6 06 01 09 	sub	r9,r3,r6
80007210:	6e 18       	ld.w	r8,r7[0x4]
80007212:	58 f9       	cp.w	r9,15
80007214:	e0 88 00 16 	brls	80007240 <_realloc_r+0x29c>
80007218:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000721c:	ed e8 10 08 	or	r8,r6,r8
80007220:	8f 18       	st.w	r7[0x4],r8
80007222:	12 98       	mov	r8,r9
80007224:	a1 a8       	sbr	r8,0x0
80007226:	ee 06 00 0b 	add	r11,r7,r6
8000722a:	f6 09 00 09 	add	r9,r11,r9
8000722e:	97 18       	st.w	r11[0x4],r8
80007230:	72 18       	ld.w	r8,r9[0x4]
80007232:	a1 a8       	sbr	r8,0x0
80007234:	2f 8b       	sub	r11,-8
80007236:	93 18       	st.w	r9[0x4],r8
80007238:	04 9c       	mov	r12,r2
8000723a:	e0 a0 02 75 	rcall	80007724 <_free_r>
8000723e:	c0 b8       	rjmp	80007254 <_realloc_r+0x2b0>
80007240:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007244:	e7 e8 10 08 	or	r8,r3,r8
80007248:	8f 18       	st.w	r7[0x4],r8
8000724a:	ee 03 00 03 	add	r3,r7,r3
8000724e:	66 18       	ld.w	r8,r3[0x4]
80007250:	a1 a8       	sbr	r8,0x0
80007252:	87 18       	st.w	r3[0x4],r8
80007254:	04 9c       	mov	r12,r2
80007256:	ee c5 ff f8 	sub	r5,r7,-8
8000725a:	fe b0 ed 13 	rcall	80004c80 <__malloc_unlock>
8000725e:	0a 9c       	mov	r12,r5
80007260:	2f fd       	sub	sp,-4
80007262:	d8 32       	popm	r0-r7,pc

80007264 <_sbrk_r>:
80007264:	d4 21       	pushm	r4-r7,lr
80007266:	30 08       	mov	r8,0
80007268:	18 97       	mov	r7,r12
8000726a:	e0 66 07 fc 	mov	r6,2044
8000726e:	16 9c       	mov	r12,r11
80007270:	8d 08       	st.w	r6[0x0],r8
80007272:	c7 1c       	rcall	80007354 <_sbrk>
80007274:	5b fc       	cp.w	r12,-1
80007276:	c0 51       	brne	80007280 <_sbrk_r+0x1c>
80007278:	6c 08       	ld.w	r8,r6[0x0]
8000727a:	58 08       	cp.w	r8,0
8000727c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007280:	d8 22       	popm	r4-r7,pc
80007282:	d7 03       	nop

80007284 <strncpy>:
80007284:	30 08       	mov	r8,0
80007286:	10 3a       	cp.w	r10,r8
80007288:	5e 0c       	reteq	r12
8000728a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000728e:	f8 08 0b 09 	st.b	r12[r8],r9
80007292:	2f f8       	sub	r8,-1
80007294:	58 09       	cp.w	r9,0
80007296:	cf 81       	brne	80007286 <strncpy+0x2>
80007298:	10 3a       	cp.w	r10,r8
8000729a:	5e 0c       	reteq	r12
8000729c:	f8 08 0b 09 	st.b	r12[r8],r9
800072a0:	2f f8       	sub	r8,-1
800072a2:	cf bb       	rjmp	80007298 <strncpy+0x14>

800072a4 <_init_argv>:
800072a4:	30 e8       	mov	r8,14
800072a6:	d6 73       	breakpoint
800072a8:	3f fc       	mov	r12,-1
800072aa:	35 8b       	mov	r11,88
800072ac:	5e fc       	retal	r12

800072ae <_exit>:
800072ae:	30 d8       	mov	r8,13
800072b0:	d6 73       	breakpoint
800072b2:	3f fc       	mov	r12,-1
800072b4:	35 8b       	mov	r11,88
800072b6:	c0 08       	rjmp	800072b6 <_exit+0x8>

800072b8 <_close>:
800072b8:	30 28       	mov	r8,2
800072ba:	d6 73       	breakpoint
800072bc:	3f fc       	mov	r12,-1
800072be:	35 8b       	mov	r11,88
800072c0:	58 0c       	cp.w	r12,0
800072c2:	5e 4c       	retge	r12
800072c4:	e0 6a 07 fc 	mov	r10,2044
800072c8:	95 0b       	st.w	r10[0x0],r11
800072ca:	5e fc       	retal	r12

800072cc <_lseek>:
800072cc:	30 58       	mov	r8,5
800072ce:	d6 73       	breakpoint
800072d0:	3f fc       	mov	r12,-1
800072d2:	35 8b       	mov	r11,88
800072d4:	58 0c       	cp.w	r12,0
800072d6:	5e 4c       	retge	r12
800072d8:	e0 6a 07 fc 	mov	r10,2044
800072dc:	95 0b       	st.w	r10[0x0],r11
800072de:	5e fc       	retal	r12

800072e0 <isatty>:
800072e0:	30 b8       	mov	r8,11
800072e2:	d6 73       	breakpoint
800072e4:	3f fc       	mov	r12,-1
800072e6:	35 8b       	mov	r11,88
800072e8:	58 0c       	cp.w	r12,0
800072ea:	5e 4c       	retge	r12
800072ec:	e0 6a 07 fc 	mov	r10,2044
800072f0:	95 0b       	st.w	r10[0x0],r11
800072f2:	5e fc       	retal	r12

800072f4 <_fstat_host>:
800072f4:	30 98       	mov	r8,9
800072f6:	d6 73       	breakpoint
800072f8:	3f fc       	mov	r12,-1
800072fa:	35 8b       	mov	r11,88
800072fc:	58 0c       	cp.w	r12,0
800072fe:	5e 4c       	retge	r12
80007300:	e0 6a 07 fc 	mov	r10,2044
80007304:	95 0b       	st.w	r10[0x0],r11
80007306:	5e fc       	retal	r12

80007308 <_fstat>:
80007308:	d4 21       	pushm	r4-r7,lr
8000730a:	21 0d       	sub	sp,64
8000730c:	16 97       	mov	r7,r11
8000730e:	1a 9b       	mov	r11,sp
80007310:	cf 2f       	rcall	800072f4 <_fstat_host>
80007312:	c0 34       	brge	80007318 <_fstat+0x10>
80007314:	3f fc       	mov	r12,-1
80007316:	c1 c8       	rjmp	8000734e <_fstat+0x46>
80007318:	40 08       	lddsp	r8,sp[0x0]
8000731a:	ae 08       	st.h	r7[0x0],r8
8000731c:	40 18       	lddsp	r8,sp[0x4]
8000731e:	ae 18       	st.h	r7[0x2],r8
80007320:	40 28       	lddsp	r8,sp[0x8]
80007322:	8f 18       	st.w	r7[0x4],r8
80007324:	40 38       	lddsp	r8,sp[0xc]
80007326:	ae 48       	st.h	r7[0x8],r8
80007328:	40 48       	lddsp	r8,sp[0x10]
8000732a:	ae 58       	st.h	r7[0xa],r8
8000732c:	40 58       	lddsp	r8,sp[0x14]
8000732e:	ae 68       	st.h	r7[0xc],r8
80007330:	40 68       	lddsp	r8,sp[0x18]
80007332:	ae 78       	st.h	r7[0xe],r8
80007334:	40 88       	lddsp	r8,sp[0x20]
80007336:	8f 48       	st.w	r7[0x10],r8
80007338:	40 a8       	lddsp	r8,sp[0x28]
8000733a:	8f b8       	st.w	r7[0x2c],r8
8000733c:	40 c8       	lddsp	r8,sp[0x30]
8000733e:	8f c8       	st.w	r7[0x30],r8
80007340:	40 d8       	lddsp	r8,sp[0x34]
80007342:	8f 58       	st.w	r7[0x14],r8
80007344:	40 e8       	lddsp	r8,sp[0x38]
80007346:	30 0c       	mov	r12,0
80007348:	8f 78       	st.w	r7[0x1c],r8
8000734a:	40 f8       	lddsp	r8,sp[0x3c]
8000734c:	8f 98       	st.w	r7[0x24],r8
8000734e:	2f 0d       	sub	sp,-64
80007350:	d8 22       	popm	r4-r7,pc
80007352:	d7 03       	nop

80007354 <_sbrk>:
80007354:	d4 01       	pushm	lr
80007356:	e0 68 07 dc 	mov	r8,2012
8000735a:	70 09       	ld.w	r9,r8[0x0]
8000735c:	58 09       	cp.w	r9,0
8000735e:	c0 41       	brne	80007366 <_sbrk+0x12>
80007360:	e0 69 08 00 	mov	r9,2048
80007364:	91 09       	st.w	r8[0x0],r9
80007366:	e0 69 07 dc 	mov	r9,2012
8000736a:	e0 6a f0 00 	mov	r10,61440
8000736e:	72 08       	ld.w	r8,r9[0x0]
80007370:	f0 0c 00 0c 	add	r12,r8,r12
80007374:	14 3c       	cp.w	r12,r10
80007376:	e0 8b 00 04 	brhi	8000737e <_sbrk+0x2a>
8000737a:	93 0c       	st.w	r9[0x0],r12
8000737c:	c0 58       	rjmp	80007386 <_sbrk+0x32>
8000737e:	ce 1c       	rcall	80007540 <__errno>
80007380:	30 c8       	mov	r8,12
80007382:	99 08       	st.w	r12[0x0],r8
80007384:	3f f8       	mov	r8,-1
80007386:	10 9c       	mov	r12,r8
80007388:	d8 02       	popm	pc
8000738a:	d7 03       	nop

8000738c <_vsprintf_r>:
8000738c:	d4 01       	pushm	lr
8000738e:	21 7d       	sub	sp,92
80007390:	e0 68 ff ff 	mov	r8,65535
80007394:	ea 18 7f ff 	orh	r8,0x7fff
80007398:	50 58       	stdsp	sp[0x14],r8
8000739a:	50 28       	stdsp	sp[0x8],r8
8000739c:	e0 68 02 08 	mov	r8,520
800073a0:	ba 68       	st.h	sp[0xc],r8
800073a2:	3f f8       	mov	r8,-1
800073a4:	50 4b       	stdsp	sp[0x10],r11
800073a6:	50 0b       	stdsp	sp[0x0],r11
800073a8:	ba 78       	st.h	sp[0xe],r8
800073aa:	1a 9b       	mov	r11,sp
800073ac:	e0 a0 04 9e 	rcall	80007ce8 <_vfprintf_r>
800073b0:	30 09       	mov	r9,0
800073b2:	40 08       	lddsp	r8,sp[0x0]
800073b4:	b0 89       	st.b	r8[0x0],r9
800073b6:	2e 9d       	sub	sp,-92
800073b8:	d8 02       	popm	pc
800073ba:	d7 03       	nop

800073bc <vsprintf>:
800073bc:	d4 01       	pushm	lr
800073be:	e0 68 01 18 	mov	r8,280
800073c2:	14 99       	mov	r9,r10
800073c4:	16 9a       	mov	r10,r11
800073c6:	18 9b       	mov	r11,r12
800073c8:	70 0c       	ld.w	r12,r8[0x0]
800073ca:	ce 1f       	rcall	8000738c <_vsprintf_r>
800073cc:	d8 02       	popm	pc
800073ce:	d7 03       	nop

800073d0 <__register_exitproc>:
800073d0:	d4 31       	pushm	r0-r7,lr
800073d2:	fe c8 ac 9e 	sub	r8,pc,-21346
800073d6:	70 03       	ld.w	r3,r8[0x0]
800073d8:	67 24       	ld.w	r4,r3[0x48]
800073da:	e6 c8 ff b4 	sub	r8,r3,-76
800073de:	58 04       	cp.w	r4,0
800073e0:	f0 04 17 00 	moveq	r4,r8
800073e4:	e7 f4 0a 12 	st.weq	r3[0x48],r4
800073e8:	18 97       	mov	r7,r12
800073ea:	16 96       	mov	r6,r11
800073ec:	14 95       	mov	r5,r10
800073ee:	12 92       	mov	r2,r9
800073f0:	68 18       	ld.w	r8,r4[0x4]
800073f2:	59 f8       	cp.w	r8,31
800073f4:	e0 8a 00 0e 	brle	80007410 <__register_exitproc+0x40>
800073f8:	e0 6c 00 8c 	mov	r12,140
800073fc:	fe b0 fb 04 	rcall	80006a04 <malloc>
80007400:	18 94       	mov	r4,r12
80007402:	c3 80       	breq	80007472 <__register_exitproc+0xa2>
80007404:	67 28       	ld.w	r8,r3[0x48]
80007406:	99 08       	st.w	r12[0x0],r8
80007408:	e7 4c 00 48 	st.w	r3[72],r12
8000740c:	30 08       	mov	r8,0
8000740e:	99 18       	st.w	r12[0x4],r8
80007410:	58 07       	cp.w	r7,0
80007412:	c2 70       	breq	80007460 <__register_exitproc+0x90>
80007414:	e8 fc 00 88 	ld.w	r12,r4[136]
80007418:	58 0c       	cp.w	r12,0
8000741a:	c0 d1       	brne	80007434 <__register_exitproc+0x64>
8000741c:	e0 6c 01 08 	mov	r12,264
80007420:	fe b0 fa f2 	rcall	80006a04 <malloc>
80007424:	c2 70       	breq	80007472 <__register_exitproc+0xa2>
80007426:	30 08       	mov	r8,0
80007428:	e9 4c 00 88 	st.w	r4[136],r12
8000742c:	f9 48 01 04 	st.w	r12[260],r8
80007430:	f9 48 01 00 	st.w	r12[256],r8
80007434:	68 18       	ld.w	r8,r4[0x4]
80007436:	f0 c9 ff e0 	sub	r9,r8,-32
8000743a:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
8000743e:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
80007442:	30 1a       	mov	r10,1
80007444:	f8 f9 01 00 	ld.w	r9,r12[256]
80007448:	f4 08 09 48 	lsl	r8,r10,r8
8000744c:	10 49       	or	r9,r8
8000744e:	f9 49 01 00 	st.w	r12[256],r9
80007452:	58 27       	cp.w	r7,2
80007454:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
80007458:	f3 d8 e0 38 	oreq	r8,r9,r8
8000745c:	f9 f8 0a 41 	st.weq	r12[0x104],r8
80007460:	68 18       	ld.w	r8,r4[0x4]
80007462:	30 0c       	mov	r12,0
80007464:	f0 c9 ff ff 	sub	r9,r8,-1
80007468:	2f e8       	sub	r8,-2
8000746a:	89 19       	st.w	r4[0x4],r9
8000746c:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
80007470:	d8 32       	popm	r0-r7,pc
80007472:	dc 3a       	popm	r0-r7,pc,r12=-1

80007474 <__call_exitprocs>:
80007474:	d4 31       	pushm	r0-r7,lr
80007476:	20 3d       	sub	sp,12
80007478:	fe c8 ad 44 	sub	r8,pc,-21180
8000747c:	50 2c       	stdsp	sp[0x8],r12
8000747e:	70 08       	ld.w	r8,r8[0x0]
80007480:	16 91       	mov	r1,r11
80007482:	50 08       	stdsp	sp[0x0],r8
80007484:	2b 88       	sub	r8,-72
80007486:	50 18       	stdsp	sp[0x4],r8
80007488:	40 0a       	lddsp	r10,sp[0x0]
8000748a:	40 14       	lddsp	r4,sp[0x4]
8000748c:	75 27       	ld.w	r7,r10[0x48]
8000748e:	c5 58       	rjmp	80007538 <__call_exitprocs+0xc4>
80007490:	6e 15       	ld.w	r5,r7[0x4]
80007492:	ee f6 00 88 	ld.w	r6,r7[136]
80007496:	ea c2 ff ff 	sub	r2,r5,-1
8000749a:	20 15       	sub	r5,1
8000749c:	ee 02 00 22 	add	r2,r7,r2<<0x2
800074a0:	ec 05 00 23 	add	r3,r6,r5<<0x2
800074a4:	c3 58       	rjmp	8000750e <__call_exitprocs+0x9a>
800074a6:	58 01       	cp.w	r1,0
800074a8:	c0 70       	breq	800074b6 <__call_exitprocs+0x42>
800074aa:	58 06       	cp.w	r6,0
800074ac:	c2 e0       	breq	80007508 <__call_exitprocs+0x94>
800074ae:	e6 f8 00 80 	ld.w	r8,r3[128]
800074b2:	02 38       	cp.w	r8,r1
800074b4:	c2 a1       	brne	80007508 <__call_exitprocs+0x94>
800074b6:	6e 19       	ld.w	r9,r7[0x4]
800074b8:	64 08       	ld.w	r8,r2[0x0]
800074ba:	20 19       	sub	r9,1
800074bc:	12 35       	cp.w	r5,r9
800074be:	ef f5 0a 01 	st.weq	r7[0x4],r5
800074c2:	f9 b9 01 00 	movne	r9,0
800074c6:	e5 f9 1a 00 	st.wne	r2[0x0],r9
800074ca:	58 08       	cp.w	r8,0
800074cc:	c1 e0       	breq	80007508 <__call_exitprocs+0x94>
800074ce:	6e 10       	ld.w	r0,r7[0x4]
800074d0:	58 06       	cp.w	r6,0
800074d2:	c0 90       	breq	800074e4 <__call_exitprocs+0x70>
800074d4:	30 1a       	mov	r10,1
800074d6:	f4 05 09 49 	lsl	r9,r10,r5
800074da:	ec fa 01 00 	ld.w	r10,r6[256]
800074de:	f3 ea 00 0a 	and	r10,r9,r10
800074e2:	c0 31       	brne	800074e8 <__call_exitprocs+0x74>
800074e4:	5d 18       	icall	r8
800074e6:	c0 b8       	rjmp	800074fc <__call_exitprocs+0x88>
800074e8:	ec fa 01 04 	ld.w	r10,r6[260]
800074ec:	66 0b       	ld.w	r11,r3[0x0]
800074ee:	14 69       	and	r9,r10
800074f0:	c0 41       	brne	800074f8 <__call_exitprocs+0x84>
800074f2:	40 2c       	lddsp	r12,sp[0x8]
800074f4:	5d 18       	icall	r8
800074f6:	c0 38       	rjmp	800074fc <__call_exitprocs+0x88>
800074f8:	16 9c       	mov	r12,r11
800074fa:	5d 18       	icall	r8
800074fc:	6e 18       	ld.w	r8,r7[0x4]
800074fe:	10 30       	cp.w	r0,r8
80007500:	cc 41       	brne	80007488 <__call_exitprocs+0x14>
80007502:	68 08       	ld.w	r8,r4[0x0]
80007504:	0e 38       	cp.w	r8,r7
80007506:	cc 11       	brne	80007488 <__call_exitprocs+0x14>
80007508:	20 15       	sub	r5,1
8000750a:	20 43       	sub	r3,4
8000750c:	20 42       	sub	r2,4
8000750e:	58 05       	cp.w	r5,0
80007510:	cc b4       	brge	800074a6 <__call_exitprocs+0x32>
80007512:	6e 18       	ld.w	r8,r7[0x4]
80007514:	58 08       	cp.w	r8,0
80007516:	c0 f1       	brne	80007534 <__call_exitprocs+0xc0>
80007518:	6e 08       	ld.w	r8,r7[0x0]
8000751a:	58 08       	cp.w	r8,0
8000751c:	c0 c0       	breq	80007534 <__call_exitprocs+0xc0>
8000751e:	89 08       	st.w	r4[0x0],r8
80007520:	58 06       	cp.w	r6,0
80007522:	c0 40       	breq	8000752a <__call_exitprocs+0xb6>
80007524:	0c 9c       	mov	r12,r6
80007526:	fe b0 fa 67 	rcall	800069f4 <free>
8000752a:	0e 9c       	mov	r12,r7
8000752c:	fe b0 fa 64 	rcall	800069f4 <free>
80007530:	68 07       	ld.w	r7,r4[0x0]
80007532:	c0 38       	rjmp	80007538 <__call_exitprocs+0xc4>
80007534:	0e 94       	mov	r4,r7
80007536:	6e 07       	ld.w	r7,r7[0x0]
80007538:	58 07       	cp.w	r7,0
8000753a:	ca b1       	brne	80007490 <__call_exitprocs+0x1c>
8000753c:	2f dd       	sub	sp,-12
8000753e:	d8 32       	popm	r0-r7,pc

80007540 <__errno>:
80007540:	e0 68 01 18 	mov	r8,280
80007544:	70 0c       	ld.w	r12,r8[0x0]
80007546:	2f 4c       	sub	r12,-12
80007548:	5e fc       	retal	r12
8000754a:	d7 03       	nop

8000754c <__sfp_lock_acquire>:
8000754c:	5e fc       	retal	r12

8000754e <__sfp_lock_release>:
8000754e:	5e fc       	retal	r12

80007550 <_cleanup_r>:
80007550:	d4 01       	pushm	lr
80007552:	fe cb ca 82 	sub	r11,pc,-13694
80007556:	ca dd       	rcall	800078b0 <_fwalk>
80007558:	d8 02       	popm	pc
8000755a:	d7 03       	nop

8000755c <__sfmoreglue>:
8000755c:	d4 21       	pushm	r4-r7,lr
8000755e:	16 95       	mov	r5,r11
80007560:	f6 06 10 5c 	mul	r6,r11,92
80007564:	ec cb ff f4 	sub	r11,r6,-12
80007568:	fe b0 fa 56 	rcall	80006a14 <_malloc_r>
8000756c:	18 97       	mov	r7,r12
8000756e:	c0 90       	breq	80007580 <__sfmoreglue+0x24>
80007570:	99 15       	st.w	r12[0x4],r5
80007572:	30 0b       	mov	r11,0
80007574:	2f 4c       	sub	r12,-12
80007576:	0c 9a       	mov	r10,r6
80007578:	8f 2c       	st.w	r7[0x8],r12
8000757a:	8f 0b       	st.w	r7[0x0],r11
8000757c:	fe b0 fd 0c 	rcall	80006f94 <memset>
80007580:	0e 9c       	mov	r12,r7
80007582:	d8 22       	popm	r4-r7,pc

80007584 <__sfp>:
80007584:	d4 21       	pushm	r4-r7,lr
80007586:	fe c8 ae 52 	sub	r8,pc,-20910
8000758a:	18 96       	mov	r6,r12
8000758c:	70 07       	ld.w	r7,r8[0x0]
8000758e:	6e 68       	ld.w	r8,r7[0x18]
80007590:	58 08       	cp.w	r8,0
80007592:	c0 31       	brne	80007598 <__sfp+0x14>
80007594:	0e 9c       	mov	r12,r7
80007596:	c2 dc       	rcall	800075f0 <__sinit>
80007598:	ee c7 ff 28 	sub	r7,r7,-216
8000759c:	30 05       	mov	r5,0
8000759e:	6e 2c       	ld.w	r12,r7[0x8]
800075a0:	6e 18       	ld.w	r8,r7[0x4]
800075a2:	c0 68       	rjmp	800075ae <__sfp+0x2a>
800075a4:	98 69       	ld.sh	r9,r12[0xc]
800075a6:	ea 09 19 00 	cp.h	r9,r5
800075aa:	c1 10       	breq	800075cc <__sfp+0x48>
800075ac:	2a 4c       	sub	r12,-92
800075ae:	20 18       	sub	r8,1
800075b0:	cf a7       	brpl	800075a4 <__sfp+0x20>
800075b2:	6e 08       	ld.w	r8,r7[0x0]
800075b4:	58 08       	cp.w	r8,0
800075b6:	c0 61       	brne	800075c2 <__sfp+0x3e>
800075b8:	30 4b       	mov	r11,4
800075ba:	0c 9c       	mov	r12,r6
800075bc:	cd 0f       	rcall	8000755c <__sfmoreglue>
800075be:	8f 0c       	st.w	r7[0x0],r12
800075c0:	c0 30       	breq	800075c6 <__sfp+0x42>
800075c2:	6e 07       	ld.w	r7,r7[0x0]
800075c4:	ce db       	rjmp	8000759e <__sfp+0x1a>
800075c6:	30 c8       	mov	r8,12
800075c8:	8d 38       	st.w	r6[0xc],r8
800075ca:	d8 22       	popm	r4-r7,pc
800075cc:	30 08       	mov	r8,0
800075ce:	f9 48 00 4c 	st.w	r12[76],r8
800075d2:	99 08       	st.w	r12[0x0],r8
800075d4:	99 28       	st.w	r12[0x8],r8
800075d6:	99 18       	st.w	r12[0x4],r8
800075d8:	99 48       	st.w	r12[0x10],r8
800075da:	99 58       	st.w	r12[0x14],r8
800075dc:	99 68       	st.w	r12[0x18],r8
800075de:	99 d8       	st.w	r12[0x34],r8
800075e0:	99 e8       	st.w	r12[0x38],r8
800075e2:	f9 48 00 48 	st.w	r12[72],r8
800075e6:	3f f8       	mov	r8,-1
800075e8:	b8 78       	st.h	r12[0xe],r8
800075ea:	30 18       	mov	r8,1
800075ec:	b8 68       	st.h	r12[0xc],r8
800075ee:	d8 22       	popm	r4-r7,pc

800075f0 <__sinit>:
800075f0:	d4 21       	pushm	r4-r7,lr
800075f2:	18 96       	mov	r6,r12
800075f4:	78 67       	ld.w	r7,r12[0x18]
800075f6:	58 07       	cp.w	r7,0
800075f8:	c4 91       	brne	8000768a <__sinit+0x9a>
800075fa:	fe c8 00 aa 	sub	r8,pc,170
800075fe:	30 15       	mov	r5,1
80007600:	99 a8       	st.w	r12[0x28],r8
80007602:	f9 47 00 d8 	st.w	r12[216],r7
80007606:	f9 47 00 dc 	st.w	r12[220],r7
8000760a:	f9 47 00 e0 	st.w	r12[224],r7
8000760e:	99 65       	st.w	r12[0x18],r5
80007610:	cb af       	rcall	80007584 <__sfp>
80007612:	8d 0c       	st.w	r6[0x0],r12
80007614:	0c 9c       	mov	r12,r6
80007616:	cb 7f       	rcall	80007584 <__sfp>
80007618:	8d 1c       	st.w	r6[0x4],r12
8000761a:	0c 9c       	mov	r12,r6
8000761c:	cb 4f       	rcall	80007584 <__sfp>
8000761e:	6c 09       	ld.w	r9,r6[0x0]
80007620:	30 48       	mov	r8,4
80007622:	93 07       	st.w	r9[0x0],r7
80007624:	b2 68       	st.h	r9[0xc],r8
80007626:	93 17       	st.w	r9[0x4],r7
80007628:	93 27       	st.w	r9[0x8],r7
8000762a:	6c 18       	ld.w	r8,r6[0x4]
8000762c:	b2 77       	st.h	r9[0xe],r7
8000762e:	93 47       	st.w	r9[0x10],r7
80007630:	93 57       	st.w	r9[0x14],r7
80007632:	93 67       	st.w	r9[0x18],r7
80007634:	93 89       	st.w	r9[0x20],r9
80007636:	91 07       	st.w	r8[0x0],r7
80007638:	91 17       	st.w	r8[0x4],r7
8000763a:	91 27       	st.w	r8[0x8],r7
8000763c:	fe ce fc a4 	sub	lr,pc,-860
80007640:	fe cb fc d8 	sub	r11,pc,-808
80007644:	93 9e       	st.w	r9[0x24],lr
80007646:	93 ab       	st.w	r9[0x28],r11
80007648:	fe ca fd 04 	sub	r10,pc,-764
8000764c:	fe c4 fd 14 	sub	r4,pc,-748
80007650:	93 ba       	st.w	r9[0x2c],r10
80007652:	93 c4       	st.w	r9[0x30],r4
80007654:	30 99       	mov	r9,9
80007656:	b0 69       	st.h	r8[0xc],r9
80007658:	b0 75       	st.h	r8[0xe],r5
8000765a:	91 c4       	st.w	r8[0x30],r4
8000765c:	91 47       	st.w	r8[0x10],r7
8000765e:	91 57       	st.w	r8[0x14],r7
80007660:	91 67       	st.w	r8[0x18],r7
80007662:	91 88       	st.w	r8[0x20],r8
80007664:	91 9e       	st.w	r8[0x24],lr
80007666:	91 ab       	st.w	r8[0x28],r11
80007668:	91 ba       	st.w	r8[0x2c],r10
8000766a:	8d 2c       	st.w	r6[0x8],r12
8000766c:	31 28       	mov	r8,18
8000766e:	99 07       	st.w	r12[0x0],r7
80007670:	b8 68       	st.h	r12[0xc],r8
80007672:	99 17       	st.w	r12[0x4],r7
80007674:	99 27       	st.w	r12[0x8],r7
80007676:	30 28       	mov	r8,2
80007678:	b8 78       	st.h	r12[0xe],r8
8000767a:	99 c4       	st.w	r12[0x30],r4
8000767c:	99 67       	st.w	r12[0x18],r7
8000767e:	99 9e       	st.w	r12[0x24],lr
80007680:	99 ab       	st.w	r12[0x28],r11
80007682:	99 ba       	st.w	r12[0x2c],r10
80007684:	99 47       	st.w	r12[0x10],r7
80007686:	99 57       	st.w	r12[0x14],r7
80007688:	99 8c       	st.w	r12[0x20],r12
8000768a:	d8 22       	popm	r4-r7,pc

8000768c <_malloc_trim_r>:
8000768c:	d4 21       	pushm	r4-r7,lr
8000768e:	16 95       	mov	r5,r11
80007690:	18 97       	mov	r7,r12
80007692:	fe b0 ea e9 	rcall	80004c64 <__malloc_lock>
80007696:	e0 64 01 1c 	mov	r4,284
8000769a:	68 28       	ld.w	r8,r4[0x8]
8000769c:	70 16       	ld.w	r6,r8[0x4]
8000769e:	e0 16 ff fc 	andl	r6,0xfffc
800076a2:	ec c8 ff 91 	sub	r8,r6,-111
800076a6:	f0 05 01 05 	sub	r5,r8,r5
800076aa:	e0 15 ff 80 	andl	r5,0xff80
800076ae:	ea c5 00 80 	sub	r5,r5,128
800076b2:	e0 45 00 7f 	cp.w	r5,127
800076b6:	e0 8a 00 25 	brle	80007700 <_malloc_trim_r+0x74>
800076ba:	30 0b       	mov	r11,0
800076bc:	0e 9c       	mov	r12,r7
800076be:	fe b0 fd d3 	rcall	80007264 <_sbrk_r>
800076c2:	68 28       	ld.w	r8,r4[0x8]
800076c4:	0c 08       	add	r8,r6
800076c6:	10 3c       	cp.w	r12,r8
800076c8:	c1 c1       	brne	80007700 <_malloc_trim_r+0x74>
800076ca:	ea 0b 11 00 	rsub	r11,r5,0
800076ce:	0e 9c       	mov	r12,r7
800076d0:	fe b0 fd ca 	rcall	80007264 <_sbrk_r>
800076d4:	5b fc       	cp.w	r12,-1
800076d6:	c1 91       	brne	80007708 <_malloc_trim_r+0x7c>
800076d8:	30 0b       	mov	r11,0
800076da:	0e 9c       	mov	r12,r7
800076dc:	fe b0 fd c4 	rcall	80007264 <_sbrk_r>
800076e0:	68 28       	ld.w	r8,r4[0x8]
800076e2:	f8 08 01 09 	sub	r9,r12,r8
800076e6:	58 f9       	cp.w	r9,15
800076e8:	e0 8a 00 0c 	brle	80007700 <_malloc_trim_r+0x74>
800076ec:	a1 a9       	sbr	r9,0x0
800076ee:	91 19       	st.w	r8[0x4],r9
800076f0:	e0 68 05 28 	mov	r8,1320
800076f4:	70 09       	ld.w	r9,r8[0x0]
800076f6:	e0 68 07 b4 	mov	r8,1972
800076fa:	f8 09 01 09 	sub	r9,r12,r9
800076fe:	91 09       	st.w	r8[0x0],r9
80007700:	0e 9c       	mov	r12,r7
80007702:	fe b0 ea bf 	rcall	80004c80 <__malloc_unlock>
80007706:	d8 2a       	popm	r4-r7,pc,r12=0
80007708:	68 28       	ld.w	r8,r4[0x8]
8000770a:	0a 16       	sub	r6,r5
8000770c:	a1 a6       	sbr	r6,0x0
8000770e:	91 16       	st.w	r8[0x4],r6
80007710:	e0 68 07 b4 	mov	r8,1972
80007714:	70 09       	ld.w	r9,r8[0x0]
80007716:	0a 19       	sub	r9,r5
80007718:	0e 9c       	mov	r12,r7
8000771a:	91 09       	st.w	r8[0x0],r9
8000771c:	fe b0 ea b2 	rcall	80004c80 <__malloc_unlock>
80007720:	da 2a       	popm	r4-r7,pc,r12=1
80007722:	d7 03       	nop

80007724 <_free_r>:
80007724:	d4 21       	pushm	r4-r7,lr
80007726:	16 96       	mov	r6,r11
80007728:	18 97       	mov	r7,r12
8000772a:	58 0b       	cp.w	r11,0
8000772c:	e0 80 00 c0 	breq	800078ac <_free_r+0x188>
80007730:	fe b0 ea 9a 	rcall	80004c64 <__malloc_lock>
80007734:	20 86       	sub	r6,8
80007736:	e0 6a 01 1c 	mov	r10,284
8000773a:	6c 18       	ld.w	r8,r6[0x4]
8000773c:	74 2e       	ld.w	lr,r10[0x8]
8000773e:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80007742:	a1 c8       	cbr	r8,0x0
80007744:	ec 08 00 09 	add	r9,r6,r8
80007748:	72 1b       	ld.w	r11,r9[0x4]
8000774a:	e0 1b ff fc 	andl	r11,0xfffc
8000774e:	1c 39       	cp.w	r9,lr
80007750:	c1 e1       	brne	8000778c <_free_r+0x68>
80007752:	f6 08 00 08 	add	r8,r11,r8
80007756:	58 0c       	cp.w	r12,0
80007758:	c0 81       	brne	80007768 <_free_r+0x44>
8000775a:	6c 09       	ld.w	r9,r6[0x0]
8000775c:	12 16       	sub	r6,r9
8000775e:	12 08       	add	r8,r9
80007760:	6c 3b       	ld.w	r11,r6[0xc]
80007762:	6c 29       	ld.w	r9,r6[0x8]
80007764:	97 29       	st.w	r11[0x8],r9
80007766:	93 3b       	st.w	r9[0xc],r11
80007768:	10 99       	mov	r9,r8
8000776a:	95 26       	st.w	r10[0x8],r6
8000776c:	a1 a9       	sbr	r9,0x0
8000776e:	8d 19       	st.w	r6[0x4],r9
80007770:	e0 69 05 24 	mov	r9,1316
80007774:	72 09       	ld.w	r9,r9[0x0]
80007776:	12 38       	cp.w	r8,r9
80007778:	c0 63       	brcs	80007784 <_free_r+0x60>
8000777a:	e0 68 07 b0 	mov	r8,1968
8000777e:	0e 9c       	mov	r12,r7
80007780:	70 0b       	ld.w	r11,r8[0x0]
80007782:	c8 5f       	rcall	8000768c <_malloc_trim_r>
80007784:	0e 9c       	mov	r12,r7
80007786:	fe b0 ea 7d 	rcall	80004c80 <__malloc_unlock>
8000778a:	d8 22       	popm	r4-r7,pc
8000778c:	93 1b       	st.w	r9[0x4],r11
8000778e:	58 0c       	cp.w	r12,0
80007790:	c0 30       	breq	80007796 <_free_r+0x72>
80007792:	30 0c       	mov	r12,0
80007794:	c1 08       	rjmp	800077b4 <_free_r+0x90>
80007796:	6c 0e       	ld.w	lr,r6[0x0]
80007798:	f4 c5 ff f8 	sub	r5,r10,-8
8000779c:	1c 16       	sub	r6,lr
8000779e:	1c 08       	add	r8,lr
800077a0:	6c 2e       	ld.w	lr,r6[0x8]
800077a2:	0a 3e       	cp.w	lr,r5
800077a4:	f9 bc 00 01 	moveq	r12,1
800077a8:	ed f5 10 03 	ld.wne	r5,r6[0xc]
800077ac:	eb fe 1a 02 	st.wne	r5[0x8],lr
800077b0:	fd f5 1a 03 	st.wne	lr[0xc],r5
800077b4:	f2 0b 00 0e 	add	lr,r9,r11
800077b8:	7c 1e       	ld.w	lr,lr[0x4]
800077ba:	ed be 00 00 	bld	lr,0x0
800077be:	c1 40       	breq	800077e6 <_free_r+0xc2>
800077c0:	16 08       	add	r8,r11
800077c2:	58 0c       	cp.w	r12,0
800077c4:	c0 d1       	brne	800077de <_free_r+0xba>
800077c6:	e0 6e 01 1c 	mov	lr,284
800077ca:	72 2b       	ld.w	r11,r9[0x8]
800077cc:	2f 8e       	sub	lr,-8
800077ce:	1c 3b       	cp.w	r11,lr
800077d0:	c0 71       	brne	800077de <_free_r+0xba>
800077d2:	97 36       	st.w	r11[0xc],r6
800077d4:	97 26       	st.w	r11[0x8],r6
800077d6:	8d 2b       	st.w	r6[0x8],r11
800077d8:	8d 3b       	st.w	r6[0xc],r11
800077da:	30 1c       	mov	r12,1
800077dc:	c0 58       	rjmp	800077e6 <_free_r+0xc2>
800077de:	72 2b       	ld.w	r11,r9[0x8]
800077e0:	72 39       	ld.w	r9,r9[0xc]
800077e2:	93 2b       	st.w	r9[0x8],r11
800077e4:	97 39       	st.w	r11[0xc],r9
800077e6:	10 99       	mov	r9,r8
800077e8:	ec 08 09 08 	st.w	r6[r8],r8
800077ec:	a1 a9       	sbr	r9,0x0
800077ee:	8d 19       	st.w	r6[0x4],r9
800077f0:	58 0c       	cp.w	r12,0
800077f2:	c5 a1       	brne	800078a6 <_free_r+0x182>
800077f4:	e0 48 01 ff 	cp.w	r8,511
800077f8:	e0 8b 00 13 	brhi	8000781e <_free_r+0xfa>
800077fc:	a3 98       	lsr	r8,0x3
800077fe:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007802:	72 2b       	ld.w	r11,r9[0x8]
80007804:	8d 39       	st.w	r6[0xc],r9
80007806:	8d 2b       	st.w	r6[0x8],r11
80007808:	97 36       	st.w	r11[0xc],r6
8000780a:	93 26       	st.w	r9[0x8],r6
8000780c:	a3 48       	asr	r8,0x2
8000780e:	74 19       	ld.w	r9,r10[0x4]
80007810:	30 1b       	mov	r11,1
80007812:	f6 08 09 48 	lsl	r8,r11,r8
80007816:	f3 e8 10 08 	or	r8,r9,r8
8000781a:	95 18       	st.w	r10[0x4],r8
8000781c:	c4 58       	rjmp	800078a6 <_free_r+0x182>
8000781e:	f0 0b 16 09 	lsr	r11,r8,0x9
80007822:	58 4b       	cp.w	r11,4
80007824:	e0 8b 00 06 	brhi	80007830 <_free_r+0x10c>
80007828:	f0 0b 16 06 	lsr	r11,r8,0x6
8000782c:	2c 8b       	sub	r11,-56
8000782e:	c2 08       	rjmp	8000786e <_free_r+0x14a>
80007830:	59 4b       	cp.w	r11,20
80007832:	e0 8b 00 04 	brhi	8000783a <_free_r+0x116>
80007836:	2a 5b       	sub	r11,-91
80007838:	c1 b8       	rjmp	8000786e <_free_r+0x14a>
8000783a:	e0 4b 00 54 	cp.w	r11,84
8000783e:	e0 8b 00 06 	brhi	8000784a <_free_r+0x126>
80007842:	f0 0b 16 0c 	lsr	r11,r8,0xc
80007846:	29 2b       	sub	r11,-110
80007848:	c1 38       	rjmp	8000786e <_free_r+0x14a>
8000784a:	e0 4b 01 54 	cp.w	r11,340
8000784e:	e0 8b 00 06 	brhi	8000785a <_free_r+0x136>
80007852:	f0 0b 16 0f 	lsr	r11,r8,0xf
80007856:	28 9b       	sub	r11,-119
80007858:	c0 b8       	rjmp	8000786e <_free_r+0x14a>
8000785a:	e0 4b 05 54 	cp.w	r11,1364
8000785e:	e0 88 00 05 	brls	80007868 <_free_r+0x144>
80007862:	37 eb       	mov	r11,126
80007864:	c0 58       	rjmp	8000786e <_free_r+0x14a>
80007866:	d7 03       	nop
80007868:	f0 0b 16 12 	lsr	r11,r8,0x12
8000786c:	28 4b       	sub	r11,-124
8000786e:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80007872:	78 29       	ld.w	r9,r12[0x8]
80007874:	18 39       	cp.w	r9,r12
80007876:	c0 e1       	brne	80007892 <_free_r+0x16e>
80007878:	74 18       	ld.w	r8,r10[0x4]
8000787a:	a3 4b       	asr	r11,0x2
8000787c:	30 1c       	mov	r12,1
8000787e:	f8 0b 09 4b 	lsl	r11,r12,r11
80007882:	f1 eb 10 0b 	or	r11,r8,r11
80007886:	12 98       	mov	r8,r9
80007888:	95 1b       	st.w	r10[0x4],r11
8000788a:	c0 a8       	rjmp	8000789e <_free_r+0x17a>
8000788c:	72 29       	ld.w	r9,r9[0x8]
8000788e:	18 39       	cp.w	r9,r12
80007890:	c0 60       	breq	8000789c <_free_r+0x178>
80007892:	72 1a       	ld.w	r10,r9[0x4]
80007894:	e0 1a ff fc 	andl	r10,0xfffc
80007898:	14 38       	cp.w	r8,r10
8000789a:	cf 93       	brcs	8000788c <_free_r+0x168>
8000789c:	72 38       	ld.w	r8,r9[0xc]
8000789e:	8d 38       	st.w	r6[0xc],r8
800078a0:	8d 29       	st.w	r6[0x8],r9
800078a2:	93 36       	st.w	r9[0xc],r6
800078a4:	91 26       	st.w	r8[0x8],r6
800078a6:	0e 9c       	mov	r12,r7
800078a8:	fe b0 e9 ec 	rcall	80004c80 <__malloc_unlock>
800078ac:	d8 22       	popm	r4-r7,pc
800078ae:	d7 03       	nop

800078b0 <_fwalk>:
800078b0:	d4 31       	pushm	r0-r7,lr
800078b2:	30 05       	mov	r5,0
800078b4:	16 91       	mov	r1,r11
800078b6:	f8 c7 ff 28 	sub	r7,r12,-216
800078ba:	0a 92       	mov	r2,r5
800078bc:	c4 8e       	rcall	8000754c <__sfp_lock_acquire>
800078be:	3f f3       	mov	r3,-1
800078c0:	c1 68       	rjmp	800078ec <_fwalk+0x3c>
800078c2:	6e 26       	ld.w	r6,r7[0x8]
800078c4:	6e 14       	ld.w	r4,r7[0x4]
800078c6:	2f 46       	sub	r6,-12
800078c8:	c0 c8       	rjmp	800078e0 <_fwalk+0x30>
800078ca:	8c 08       	ld.sh	r8,r6[0x0]
800078cc:	e4 08 19 00 	cp.h	r8,r2
800078d0:	c0 70       	breq	800078de <_fwalk+0x2e>
800078d2:	8c 18       	ld.sh	r8,r6[0x2]
800078d4:	e6 08 19 00 	cp.h	r8,r3
800078d8:	c0 30       	breq	800078de <_fwalk+0x2e>
800078da:	5d 11       	icall	r1
800078dc:	18 45       	or	r5,r12
800078de:	2a 46       	sub	r6,-92
800078e0:	20 14       	sub	r4,1
800078e2:	ec cc 00 0c 	sub	r12,r6,12
800078e6:	58 04       	cp.w	r4,0
800078e8:	cf 14       	brge	800078ca <_fwalk+0x1a>
800078ea:	6e 07       	ld.w	r7,r7[0x0]
800078ec:	58 07       	cp.w	r7,0
800078ee:	ce a1       	brne	800078c2 <_fwalk+0x12>
800078f0:	c2 fe       	rcall	8000754e <__sfp_lock_release>
800078f2:	0a 9c       	mov	r12,r5
800078f4:	d8 32       	popm	r0-r7,pc
800078f6:	d7 03       	nop

800078f8 <memmove>:
800078f8:	d4 01       	pushm	lr
800078fa:	18 3b       	cp.w	r11,r12
800078fc:	c1 92       	brcc	8000792e <memmove+0x36>
800078fe:	f6 0a 00 09 	add	r9,r11,r10
80007902:	12 3c       	cp.w	r12,r9
80007904:	c1 52       	brcc	8000792e <memmove+0x36>
80007906:	f8 0a 00 0b 	add	r11,r12,r10
8000790a:	30 08       	mov	r8,0
8000790c:	c0 68       	rjmp	80007918 <memmove+0x20>
8000790e:	f2 08 07 0e 	ld.ub	lr,r9[r8]
80007912:	20 1a       	sub	r10,1
80007914:	f6 08 0b 0e 	st.b	r11[r8],lr
80007918:	20 18       	sub	r8,1
8000791a:	58 0a       	cp.w	r10,0
8000791c:	cf 91       	brne	8000790e <memmove+0x16>
8000791e:	d8 02       	popm	pc
80007920:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007924:	20 1a       	sub	r10,1
80007926:	f8 08 0b 09 	st.b	r12[r8],r9
8000792a:	2f f8       	sub	r8,-1
8000792c:	c0 28       	rjmp	80007930 <memmove+0x38>
8000792e:	30 08       	mov	r8,0
80007930:	58 0a       	cp.w	r10,0
80007932:	cf 71       	brne	80007920 <memmove+0x28>
80007934:	d8 02       	popm	pc
80007936:	d7 03       	nop

80007938 <__sclose>:
80007938:	d4 01       	pushm	lr
8000793a:	96 7b       	ld.sh	r11,r11[0xe]
8000793c:	e0 a0 11 e2 	rcall	80009d00 <_close_r>
80007940:	d8 02       	popm	pc
80007942:	d7 03       	nop

80007944 <__sseek>:
80007944:	d4 21       	pushm	r4-r7,lr
80007946:	16 97       	mov	r7,r11
80007948:	96 7b       	ld.sh	r11,r11[0xe]
8000794a:	e0 a0 1a a5 	rcall	8000ae94 <_lseek_r>
8000794e:	8e 68       	ld.sh	r8,r7[0xc]
80007950:	10 99       	mov	r9,r8
80007952:	ad c8       	cbr	r8,0xc
80007954:	ad a9       	sbr	r9,0xc
80007956:	5b fc       	cp.w	r12,-1
80007958:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000795c:	ef f9 1c 06 	st.hne	r7[0xc],r9
80007960:	ef fc 1a 15 	st.wne	r7[0x54],r12
80007964:	d8 22       	popm	r4-r7,pc
80007966:	d7 03       	nop

80007968 <__swrite>:
80007968:	d4 21       	pushm	r4-r7,lr
8000796a:	96 68       	ld.sh	r8,r11[0xc]
8000796c:	16 97       	mov	r7,r11
8000796e:	14 95       	mov	r5,r10
80007970:	12 94       	mov	r4,r9
80007972:	e2 18 01 00 	andl	r8,0x100,COH
80007976:	18 96       	mov	r6,r12
80007978:	c0 60       	breq	80007984 <__swrite+0x1c>
8000797a:	30 29       	mov	r9,2
8000797c:	30 0a       	mov	r10,0
8000797e:	96 7b       	ld.sh	r11,r11[0xe]
80007980:	e0 a0 1a 8a 	rcall	8000ae94 <_lseek_r>
80007984:	8e 68       	ld.sh	r8,r7[0xc]
80007986:	ad c8       	cbr	r8,0xc
80007988:	08 99       	mov	r9,r4
8000798a:	0a 9a       	mov	r10,r5
8000798c:	8e 7b       	ld.sh	r11,r7[0xe]
8000798e:	0c 9c       	mov	r12,r6
80007990:	ae 68       	st.h	r7[0xc],r8
80007992:	e0 a0 11 35 	rcall	80009bfc <_write_r>
80007996:	d8 22       	popm	r4-r7,pc

80007998 <__sread>:
80007998:	d4 21       	pushm	r4-r7,lr
8000799a:	16 97       	mov	r7,r11
8000799c:	96 7b       	ld.sh	r11,r11[0xe]
8000799e:	e0 a0 1d e3 	rcall	8000b564 <_read_r>
800079a2:	c0 65       	brlt	800079ae <__sread+0x16>
800079a4:	6f 58       	ld.w	r8,r7[0x54]
800079a6:	18 08       	add	r8,r12
800079a8:	ef 48 00 54 	st.w	r7[84],r8
800079ac:	d8 22       	popm	r4-r7,pc
800079ae:	8e 68       	ld.sh	r8,r7[0xc]
800079b0:	ad c8       	cbr	r8,0xc
800079b2:	ae 68       	st.h	r7[0xc],r8
800079b4:	d8 22       	popm	r4-r7,pc
800079b6:	d7 03       	nop

800079b8 <get_arg>:
800079b8:	d4 31       	pushm	r0-r7,lr
800079ba:	20 8d       	sub	sp,32
800079bc:	fa c4 ff bc 	sub	r4,sp,-68
800079c0:	50 4b       	stdsp	sp[0x10],r11
800079c2:	68 2e       	ld.w	lr,r4[0x8]
800079c4:	50 58       	stdsp	sp[0x14],r8
800079c6:	12 96       	mov	r6,r9
800079c8:	7c 0b       	ld.w	r11,lr[0x0]
800079ca:	70 05       	ld.w	r5,r8[0x0]
800079cc:	50 6e       	stdsp	sp[0x18],lr
800079ce:	58 0b       	cp.w	r11,0
800079d0:	f4 0b 17 00 	moveq	r11,r10
800079d4:	68 03       	ld.w	r3,r4[0x0]
800079d6:	68 11       	ld.w	r1,r4[0x4]
800079d8:	40 49       	lddsp	r9,sp[0x10]
800079da:	30 08       	mov	r8,0
800079dc:	c2 89       	rjmp	80007c2c <get_arg+0x274>
800079de:	2f fb       	sub	r11,-1
800079e0:	32 5c       	mov	r12,37
800079e2:	17 8a       	ld.ub	r10,r11[0x0]
800079e4:	f8 0a 18 00 	cp.b	r10,r12
800079e8:	5f 1e       	srne	lr
800079ea:	f0 0a 18 00 	cp.b	r10,r8
800079ee:	5f 1c       	srne	r12
800079f0:	fd ec 00 0c 	and	r12,lr,r12
800079f4:	f0 0c 18 00 	cp.b	r12,r8
800079f8:	cf 31       	brne	800079de <get_arg+0x26>
800079fa:	58 0a       	cp.w	r10,0
800079fc:	e0 80 01 25 	breq	80007c46 <get_arg+0x28e>
80007a00:	30 0c       	mov	r12,0
80007a02:	3f fa       	mov	r10,-1
80007a04:	18 90       	mov	r0,r12
80007a06:	50 3a       	stdsp	sp[0xc],r10
80007a08:	18 94       	mov	r4,r12
80007a0a:	18 92       	mov	r2,r12
80007a0c:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007a10:	16 97       	mov	r7,r11
80007a12:	50 7c       	stdsp	sp[0x1c],r12
80007a14:	fe cc af a8 	sub	r12,pc,-20568
80007a18:	0f 3a       	ld.ub	r10,r7++
80007a1a:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007a1e:	40 7c       	lddsp	r12,sp[0x1c]
80007a20:	1c 0c       	add	r12,lr
80007a22:	fe ce b0 7e 	sub	lr,pc,-20354
80007a26:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007a2a:	20 1e       	sub	lr,1
80007a2c:	50 0e       	stdsp	sp[0x0],lr
80007a2e:	fe ce b0 f6 	sub	lr,pc,-20234
80007a32:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007a36:	50 7c       	stdsp	sp[0x1c],r12
80007a38:	40 0c       	lddsp	r12,sp[0x0]
80007a3a:	58 7c       	cp.w	r12,7
80007a3c:	e0 8b 00 f1 	brhi	80007c1e <get_arg+0x266>
80007a40:	fe ce b2 a8 	sub	lr,pc,-19800
80007a44:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007a48:	36 8b       	mov	r11,104
80007a4a:	f6 0a 18 00 	cp.b	r10,r11
80007a4e:	e0 80 00 e8 	breq	80007c1e <get_arg+0x266>
80007a52:	37 1b       	mov	r11,113
80007a54:	f6 0a 18 00 	cp.b	r10,r11
80007a58:	c0 70       	breq	80007a66 <get_arg+0xae>
80007a5a:	34 cb       	mov	r11,76
80007a5c:	f6 0a 18 00 	cp.b	r10,r11
80007a60:	c0 51       	brne	80007a6a <get_arg+0xb2>
80007a62:	a3 b4       	sbr	r4,0x3
80007a64:	cd d8       	rjmp	80007c1e <get_arg+0x266>
80007a66:	a5 b4       	sbr	r4,0x5
80007a68:	cd b8       	rjmp	80007c1e <get_arg+0x266>
80007a6a:	08 9a       	mov	r10,r4
80007a6c:	0e 9b       	mov	r11,r7
80007a6e:	a5 aa       	sbr	r10,0x4
80007a70:	17 3c       	ld.ub	r12,r11++
80007a72:	a5 b4       	sbr	r4,0x5
80007a74:	36 ce       	mov	lr,108
80007a76:	fc 0c 18 00 	cp.b	r12,lr
80007a7a:	e0 80 00 d3 	breq	80007c20 <get_arg+0x268>
80007a7e:	14 94       	mov	r4,r10
80007a80:	cc f8       	rjmp	80007c1e <get_arg+0x266>
80007a82:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007a86:	36 7c       	mov	r12,103
80007a88:	f8 0a 18 00 	cp.b	r10,r12
80007a8c:	e0 8b 00 27 	brhi	80007ada <get_arg+0x122>
80007a90:	36 5b       	mov	r11,101
80007a92:	f6 0a 18 00 	cp.b	r10,r11
80007a96:	c4 82       	brcc	80007b26 <get_arg+0x16e>
80007a98:	34 fb       	mov	r11,79
80007a9a:	f6 0a 18 00 	cp.b	r10,r11
80007a9e:	c4 80       	breq	80007b2e <get_arg+0x176>
80007aa0:	e0 8b 00 0c 	brhi	80007ab8 <get_arg+0x100>
80007aa4:	34 5b       	mov	r11,69
80007aa6:	f6 0a 18 00 	cp.b	r10,r11
80007aaa:	c3 e0       	breq	80007b26 <get_arg+0x16e>
80007aac:	34 7b       	mov	r11,71
80007aae:	f6 0a 18 00 	cp.b	r10,r11
80007ab2:	c3 a0       	breq	80007b26 <get_arg+0x16e>
80007ab4:	34 4b       	mov	r11,68
80007ab6:	c0 88       	rjmp	80007ac6 <get_arg+0x10e>
80007ab8:	35 8b       	mov	r11,88
80007aba:	f6 0a 18 00 	cp.b	r10,r11
80007abe:	c2 c0       	breq	80007b16 <get_arg+0x15e>
80007ac0:	e0 8b 00 07 	brhi	80007ace <get_arg+0x116>
80007ac4:	35 5b       	mov	r11,85
80007ac6:	f6 0a 18 00 	cp.b	r10,r11
80007aca:	c3 51       	brne	80007b34 <get_arg+0x17c>
80007acc:	c3 18       	rjmp	80007b2e <get_arg+0x176>
80007ace:	36 3b       	mov	r11,99
80007ad0:	f6 0a 18 00 	cp.b	r10,r11
80007ad4:	c2 f0       	breq	80007b32 <get_arg+0x17a>
80007ad6:	36 4b       	mov	r11,100
80007ad8:	c0 e8       	rjmp	80007af4 <get_arg+0x13c>
80007ada:	37 0b       	mov	r11,112
80007adc:	f6 0a 18 00 	cp.b	r10,r11
80007ae0:	c2 50       	breq	80007b2a <get_arg+0x172>
80007ae2:	e0 8b 00 0d 	brhi	80007afc <get_arg+0x144>
80007ae6:	36 eb       	mov	r11,110
80007ae8:	f6 0a 18 00 	cp.b	r10,r11
80007aec:	c1 f0       	breq	80007b2a <get_arg+0x172>
80007aee:	e0 8b 00 14 	brhi	80007b16 <get_arg+0x15e>
80007af2:	36 9b       	mov	r11,105
80007af4:	f6 0a 18 00 	cp.b	r10,r11
80007af8:	c1 e1       	brne	80007b34 <get_arg+0x17c>
80007afa:	c0 e8       	rjmp	80007b16 <get_arg+0x15e>
80007afc:	37 5b       	mov	r11,117
80007afe:	f6 0a 18 00 	cp.b	r10,r11
80007b02:	c0 a0       	breq	80007b16 <get_arg+0x15e>
80007b04:	37 8b       	mov	r11,120
80007b06:	f6 0a 18 00 	cp.b	r10,r11
80007b0a:	c0 60       	breq	80007b16 <get_arg+0x15e>
80007b0c:	37 3b       	mov	r11,115
80007b0e:	f6 0a 18 00 	cp.b	r10,r11
80007b12:	c1 11       	brne	80007b34 <get_arg+0x17c>
80007b14:	c0 b8       	rjmp	80007b2a <get_arg+0x172>
80007b16:	ed b4 00 04 	bld	r4,0x4
80007b1a:	c0 a0       	breq	80007b2e <get_arg+0x176>
80007b1c:	ed b4 00 05 	bld	r4,0x5
80007b20:	c0 91       	brne	80007b32 <get_arg+0x17a>
80007b22:	30 20       	mov	r0,2
80007b24:	c0 88       	rjmp	80007b34 <get_arg+0x17c>
80007b26:	30 40       	mov	r0,4
80007b28:	c0 68       	rjmp	80007b34 <get_arg+0x17c>
80007b2a:	30 30       	mov	r0,3
80007b2c:	c0 48       	rjmp	80007b34 <get_arg+0x17c>
80007b2e:	30 10       	mov	r0,1
80007b30:	c0 28       	rjmp	80007b34 <get_arg+0x17c>
80007b32:	30 00       	mov	r0,0
80007b34:	40 3b       	lddsp	r11,sp[0xc]
80007b36:	5b fb       	cp.w	r11,-1
80007b38:	c0 40       	breq	80007b40 <get_arg+0x188>
80007b3a:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007b3e:	c7 08       	rjmp	80007c1e <get_arg+0x266>
80007b40:	58 60       	cp.w	r0,6
80007b42:	e0 8b 00 6e 	brhi	80007c1e <get_arg+0x266>
80007b46:	6c 0a       	ld.w	r10,r6[0x0]
80007b48:	ea cc ff ff 	sub	r12,r5,-1
80007b4c:	fe ce b3 94 	sub	lr,pc,-19564
80007b50:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007b54:	f4 cb ff f8 	sub	r11,r10,-8
80007b58:	8d 0b       	st.w	r6[0x0],r11
80007b5a:	f4 ea 00 00 	ld.d	r10,r10[0]
80007b5e:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007b62:	c0 f8       	rjmp	80007b80 <get_arg+0x1c8>
80007b64:	f4 cb ff fc 	sub	r11,r10,-4
80007b68:	8d 0b       	st.w	r6[0x0],r11
80007b6a:	74 0a       	ld.w	r10,r10[0x0]
80007b6c:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007b70:	c0 88       	rjmp	80007b80 <get_arg+0x1c8>
80007b72:	f4 cb ff f8 	sub	r11,r10,-8
80007b76:	8d 0b       	st.w	r6[0x0],r11
80007b78:	f4 ea 00 00 	ld.d	r10,r10[0]
80007b7c:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007b80:	0e 9b       	mov	r11,r7
80007b82:	18 95       	mov	r5,r12
80007b84:	c4 e8       	rjmp	80007c20 <get_arg+0x268>
80007b86:	62 0a       	ld.w	r10,r1[0x0]
80007b88:	5b fa       	cp.w	r10,-1
80007b8a:	c0 b1       	brne	80007ba0 <get_arg+0x1e8>
80007b8c:	50 19       	stdsp	sp[0x4],r9
80007b8e:	50 28       	stdsp	sp[0x8],r8
80007b90:	e0 6a 00 80 	mov	r10,128
80007b94:	30 0b       	mov	r11,0
80007b96:	02 9c       	mov	r12,r1
80007b98:	fe b0 f9 fe 	rcall	80006f94 <memset>
80007b9c:	40 28       	lddsp	r8,sp[0x8]
80007b9e:	40 19       	lddsp	r9,sp[0x4]
80007ba0:	e4 cc 00 01 	sub	r12,r2,1
80007ba4:	0e 9b       	mov	r11,r7
80007ba6:	50 3c       	stdsp	sp[0xc],r12
80007ba8:	f2 0c 0c 49 	max	r9,r9,r12
80007bac:	c3 a8       	rjmp	80007c20 <get_arg+0x268>
80007bae:	62 0a       	ld.w	r10,r1[0x0]
80007bb0:	5b fa       	cp.w	r10,-1
80007bb2:	c0 b1       	brne	80007bc8 <get_arg+0x210>
80007bb4:	50 19       	stdsp	sp[0x4],r9
80007bb6:	50 28       	stdsp	sp[0x8],r8
80007bb8:	e0 6a 00 80 	mov	r10,128
80007bbc:	30 0b       	mov	r11,0
80007bbe:	02 9c       	mov	r12,r1
80007bc0:	fe b0 f9 ea 	rcall	80006f94 <memset>
80007bc4:	40 28       	lddsp	r8,sp[0x8]
80007bc6:	40 19       	lddsp	r9,sp[0x4]
80007bc8:	20 12       	sub	r2,1
80007bca:	30 0a       	mov	r10,0
80007bcc:	0e 9b       	mov	r11,r7
80007bce:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007bd2:	f2 02 0c 49 	max	r9,r9,r2
80007bd6:	c2 58       	rjmp	80007c20 <get_arg+0x268>
80007bd8:	16 97       	mov	r7,r11
80007bda:	6c 0a       	ld.w	r10,r6[0x0]
80007bdc:	f4 cb ff fc 	sub	r11,r10,-4
80007be0:	8d 0b       	st.w	r6[0x0],r11
80007be2:	74 0a       	ld.w	r10,r10[0x0]
80007be4:	0e 9b       	mov	r11,r7
80007be6:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007bea:	2f f5       	sub	r5,-1
80007bec:	c1 a8       	rjmp	80007c20 <get_arg+0x268>
80007bee:	f4 c2 00 30 	sub	r2,r10,48
80007bf2:	c0 68       	rjmp	80007bfe <get_arg+0x246>
80007bf4:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007bf8:	2f f7       	sub	r7,-1
80007bfa:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007bfe:	0f 8a       	ld.ub	r10,r7[0x0]
80007c00:	58 0a       	cp.w	r10,0
80007c02:	c0 e0       	breq	80007c1e <get_arg+0x266>
80007c04:	23 0a       	sub	r10,48
80007c06:	58 9a       	cp.w	r10,9
80007c08:	fe 98 ff f6 	brls	80007bf4 <get_arg+0x23c>
80007c0c:	c0 98       	rjmp	80007c1e <get_arg+0x266>
80007c0e:	2f f7       	sub	r7,-1
80007c10:	0f 8a       	ld.ub	r10,r7[0x0]
80007c12:	58 0a       	cp.w	r10,0
80007c14:	c0 50       	breq	80007c1e <get_arg+0x266>
80007c16:	23 0a       	sub	r10,48
80007c18:	58 9a       	cp.w	r10,9
80007c1a:	fe 98 ff fa 	brls	80007c0e <get_arg+0x256>
80007c1e:	0e 9b       	mov	r11,r7
80007c20:	40 7c       	lddsp	r12,sp[0x1c]
80007c22:	30 ba       	mov	r10,11
80007c24:	f4 0c 18 00 	cp.b	r12,r10
80007c28:	fe 91 fe f2 	brne	80007a0c <get_arg+0x54>
80007c2c:	40 42       	lddsp	r2,sp[0x10]
80007c2e:	17 8c       	ld.ub	r12,r11[0x0]
80007c30:	0a 32       	cp.w	r2,r5
80007c32:	5f 4a       	srge	r10
80007c34:	f0 0c 18 00 	cp.b	r12,r8
80007c38:	5f 1c       	srne	r12
80007c3a:	f9 ea 00 0a 	and	r10,r12,r10
80007c3e:	f0 0a 18 00 	cp.b	r10,r8
80007c42:	fe 91 fe cf 	brne	800079e0 <get_arg+0x28>
80007c46:	30 08       	mov	r8,0
80007c48:	40 4e       	lddsp	lr,sp[0x10]
80007c4a:	17 8a       	ld.ub	r10,r11[0x0]
80007c4c:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007c50:	f0 0a 18 00 	cp.b	r10,r8
80007c54:	fc 09 17 10 	movne	r9,lr
80007c58:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007c5c:	06 9e       	mov	lr,r3
80007c5e:	c2 a8       	rjmp	80007cb2 <get_arg+0x2fa>
80007c60:	62 0a       	ld.w	r10,r1[0x0]
80007c62:	58 3a       	cp.w	r10,3
80007c64:	c1 e0       	breq	80007ca0 <get_arg+0x2e8>
80007c66:	e0 89 00 07 	brgt	80007c74 <get_arg+0x2bc>
80007c6a:	58 1a       	cp.w	r10,1
80007c6c:	c1 a0       	breq	80007ca0 <get_arg+0x2e8>
80007c6e:	58 2a       	cp.w	r10,2
80007c70:	c1 81       	brne	80007ca0 <get_arg+0x2e8>
80007c72:	c0 58       	rjmp	80007c7c <get_arg+0x2c4>
80007c74:	58 5a       	cp.w	r10,5
80007c76:	c0 c0       	breq	80007c8e <get_arg+0x2d6>
80007c78:	c0 b5       	brlt	80007c8e <get_arg+0x2d6>
80007c7a:	c1 38       	rjmp	80007ca0 <get_arg+0x2e8>
80007c7c:	6c 0a       	ld.w	r10,r6[0x0]
80007c7e:	f4 cc ff f8 	sub	r12,r10,-8
80007c82:	8d 0c       	st.w	r6[0x0],r12
80007c84:	f4 e2 00 00 	ld.d	r2,r10[0]
80007c88:	f0 e3 00 00 	st.d	r8[0],r2
80007c8c:	c1 08       	rjmp	80007cac <get_arg+0x2f4>
80007c8e:	6c 0a       	ld.w	r10,r6[0x0]
80007c90:	f4 cc ff f8 	sub	r12,r10,-8
80007c94:	8d 0c       	st.w	r6[0x0],r12
80007c96:	f4 e2 00 00 	ld.d	r2,r10[0]
80007c9a:	f0 e3 00 00 	st.d	r8[0],r2
80007c9e:	c0 78       	rjmp	80007cac <get_arg+0x2f4>
80007ca0:	6c 0a       	ld.w	r10,r6[0x0]
80007ca2:	f4 cc ff fc 	sub	r12,r10,-4
80007ca6:	8d 0c       	st.w	r6[0x0],r12
80007ca8:	74 0a       	ld.w	r10,r10[0x0]
80007caa:	91 0a       	st.w	r8[0x0],r10
80007cac:	2f f5       	sub	r5,-1
80007cae:	2f 88       	sub	r8,-8
80007cb0:	2f c1       	sub	r1,-4
80007cb2:	12 35       	cp.w	r5,r9
80007cb4:	fe 9a ff d6 	brle	80007c60 <get_arg+0x2a8>
80007cb8:	1c 93       	mov	r3,lr
80007cba:	40 52       	lddsp	r2,sp[0x14]
80007cbc:	40 6e       	lddsp	lr,sp[0x18]
80007cbe:	85 05       	st.w	r2[0x0],r5
80007cc0:	9d 0b       	st.w	lr[0x0],r11
80007cc2:	40 4b       	lddsp	r11,sp[0x10]
80007cc4:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007cc8:	2f 8d       	sub	sp,-32
80007cca:	d8 32       	popm	r0-r7,pc

80007ccc <__sprint_r>:
80007ccc:	d4 21       	pushm	r4-r7,lr
80007cce:	14 97       	mov	r7,r10
80007cd0:	74 28       	ld.w	r8,r10[0x8]
80007cd2:	58 08       	cp.w	r8,0
80007cd4:	c0 41       	brne	80007cdc <__sprint_r+0x10>
80007cd6:	95 18       	st.w	r10[0x4],r8
80007cd8:	10 9c       	mov	r12,r8
80007cda:	d8 22       	popm	r4-r7,pc
80007cdc:	e0 a0 17 8a 	rcall	8000abf0 <__sfvwrite_r>
80007ce0:	30 08       	mov	r8,0
80007ce2:	8f 18       	st.w	r7[0x4],r8
80007ce4:	8f 28       	st.w	r7[0x8],r8
80007ce6:	d8 22       	popm	r4-r7,pc

80007ce8 <_vfprintf_r>:
80007ce8:	d4 31       	pushm	r0-r7,lr
80007cea:	fa cd 06 bc 	sub	sp,sp,1724
80007cee:	51 09       	stdsp	sp[0x40],r9
80007cf0:	16 91       	mov	r1,r11
80007cf2:	14 97       	mov	r7,r10
80007cf4:	18 95       	mov	r5,r12
80007cf6:	e0 a0 18 cb 	rcall	8000ae8c <_localeconv_r>
80007cfa:	78 0c       	ld.w	r12,r12[0x0]
80007cfc:	50 cc       	stdsp	sp[0x30],r12
80007cfe:	58 05       	cp.w	r5,0
80007d00:	c0 70       	breq	80007d0e <_vfprintf_r+0x26>
80007d02:	6a 68       	ld.w	r8,r5[0x18]
80007d04:	58 08       	cp.w	r8,0
80007d06:	c0 41       	brne	80007d0e <_vfprintf_r+0x26>
80007d08:	0a 9c       	mov	r12,r5
80007d0a:	fe b0 fc 73 	rcall	800075f0 <__sinit>
80007d0e:	fe c8 b5 d6 	sub	r8,pc,-18986
80007d12:	10 31       	cp.w	r1,r8
80007d14:	c0 31       	brne	80007d1a <_vfprintf_r+0x32>
80007d16:	6a 01       	ld.w	r1,r5[0x0]
80007d18:	c0 c8       	rjmp	80007d30 <_vfprintf_r+0x48>
80007d1a:	fe c8 b5 c2 	sub	r8,pc,-19006
80007d1e:	10 31       	cp.w	r1,r8
80007d20:	c0 31       	brne	80007d26 <_vfprintf_r+0x3e>
80007d22:	6a 11       	ld.w	r1,r5[0x4]
80007d24:	c0 68       	rjmp	80007d30 <_vfprintf_r+0x48>
80007d26:	fe c8 b5 ae 	sub	r8,pc,-19026
80007d2a:	10 31       	cp.w	r1,r8
80007d2c:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007d30:	82 68       	ld.sh	r8,r1[0xc]
80007d32:	ed b8 00 03 	bld	r8,0x3
80007d36:	c0 41       	brne	80007d3e <_vfprintf_r+0x56>
80007d38:	62 48       	ld.w	r8,r1[0x10]
80007d3a:	58 08       	cp.w	r8,0
80007d3c:	c0 71       	brne	80007d4a <_vfprintf_r+0x62>
80007d3e:	02 9b       	mov	r11,r1
80007d40:	0a 9c       	mov	r12,r5
80007d42:	e0 a0 0f 71 	rcall	80009c24 <__swsetup_r>
80007d46:	e0 81 0f 54 	brne	80009bee <_vfprintf_r+0x1f06>
80007d4a:	82 68       	ld.sh	r8,r1[0xc]
80007d4c:	10 99       	mov	r9,r8
80007d4e:	e2 19 00 1a 	andl	r9,0x1a,COH
80007d52:	58 a9       	cp.w	r9,10
80007d54:	c3 c1       	brne	80007dcc <_vfprintf_r+0xe4>
80007d56:	82 79       	ld.sh	r9,r1[0xe]
80007d58:	30 0a       	mov	r10,0
80007d5a:	f4 09 19 00 	cp.h	r9,r10
80007d5e:	c3 75       	brlt	80007dcc <_vfprintf_r+0xe4>
80007d60:	a1 d8       	cbr	r8,0x1
80007d62:	fb 58 05 d0 	st.h	sp[1488],r8
80007d66:	62 88       	ld.w	r8,r1[0x20]
80007d68:	fb 48 05 e4 	st.w	sp[1508],r8
80007d6c:	62 a8       	ld.w	r8,r1[0x28]
80007d6e:	fb 48 05 ec 	st.w	sp[1516],r8
80007d72:	fa c8 ff bc 	sub	r8,sp,-68
80007d76:	fb 48 05 d4 	st.w	sp[1492],r8
80007d7a:	fb 48 05 c4 	st.w	sp[1476],r8
80007d7e:	e0 68 04 00 	mov	r8,1024
80007d82:	fb 48 05 d8 	st.w	sp[1496],r8
80007d86:	fb 48 05 cc 	st.w	sp[1484],r8
80007d8a:	30 08       	mov	r8,0
80007d8c:	fb 59 05 d2 	st.h	sp[1490],r9
80007d90:	0e 9a       	mov	r10,r7
80007d92:	41 09       	lddsp	r9,sp[0x40]
80007d94:	fa c7 fa 3c 	sub	r7,sp,-1476
80007d98:	fb 48 05 dc 	st.w	sp[1500],r8
80007d9c:	0a 9c       	mov	r12,r5
80007d9e:	0e 9b       	mov	r11,r7
80007da0:	ca 4f       	rcall	80007ce8 <_vfprintf_r>
80007da2:	50 bc       	stdsp	sp[0x2c],r12
80007da4:	c0 95       	brlt	80007db6 <_vfprintf_r+0xce>
80007da6:	0e 9b       	mov	r11,r7
80007da8:	0a 9c       	mov	r12,r5
80007daa:	e0 a0 16 9b 	rcall	8000aae0 <_fflush_r>
80007dae:	40 be       	lddsp	lr,sp[0x2c]
80007db0:	f9 be 01 ff 	movne	lr,-1
80007db4:	50 be       	stdsp	sp[0x2c],lr
80007db6:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007dba:	ed b8 00 06 	bld	r8,0x6
80007dbe:	e0 81 0f 1a 	brne	80009bf2 <_vfprintf_r+0x1f0a>
80007dc2:	82 68       	ld.sh	r8,r1[0xc]
80007dc4:	a7 a8       	sbr	r8,0x6
80007dc6:	a2 68       	st.h	r1[0xc],r8
80007dc8:	e0 8f 0f 15 	bral	80009bf2 <_vfprintf_r+0x1f0a>
80007dcc:	30 08       	mov	r8,0
80007dce:	fb 48 06 b4 	st.w	sp[1716],r8
80007dd2:	fb 48 06 90 	st.w	sp[1680],r8
80007dd6:	fb 48 06 8c 	st.w	sp[1676],r8
80007dda:	fb 48 06 b0 	st.w	sp[1712],r8
80007dde:	30 08       	mov	r8,0
80007de0:	30 09       	mov	r9,0
80007de2:	50 a7       	stdsp	sp[0x28],r7
80007de4:	50 78       	stdsp	sp[0x1c],r8
80007de6:	fa c3 f9 e0 	sub	r3,sp,-1568
80007dea:	3f f8       	mov	r8,-1
80007dec:	50 59       	stdsp	sp[0x14],r9
80007dee:	fb 43 06 88 	st.w	sp[1672],r3
80007df2:	fb 48 05 44 	st.w	sp[1348],r8
80007df6:	12 9c       	mov	r12,r9
80007df8:	50 69       	stdsp	sp[0x18],r9
80007dfa:	50 d9       	stdsp	sp[0x34],r9
80007dfc:	50 e9       	stdsp	sp[0x38],r9
80007dfe:	50 b9       	stdsp	sp[0x2c],r9
80007e00:	12 97       	mov	r7,r9
80007e02:	0a 94       	mov	r4,r5
80007e04:	40 a2       	lddsp	r2,sp[0x28]
80007e06:	32 5a       	mov	r10,37
80007e08:	30 08       	mov	r8,0
80007e0a:	c0 28       	rjmp	80007e0e <_vfprintf_r+0x126>
80007e0c:	2f f2       	sub	r2,-1
80007e0e:	05 89       	ld.ub	r9,r2[0x0]
80007e10:	f0 09 18 00 	cp.b	r9,r8
80007e14:	5f 1b       	srne	r11
80007e16:	f4 09 18 00 	cp.b	r9,r10
80007e1a:	5f 19       	srne	r9
80007e1c:	f3 eb 00 0b 	and	r11,r9,r11
80007e20:	f0 0b 18 00 	cp.b	r11,r8
80007e24:	cf 41       	brne	80007e0c <_vfprintf_r+0x124>
80007e26:	40 ab       	lddsp	r11,sp[0x28]
80007e28:	e4 0b 01 06 	sub	r6,r2,r11
80007e2c:	c1 e0       	breq	80007e68 <_vfprintf_r+0x180>
80007e2e:	fa f8 06 90 	ld.w	r8,sp[1680]
80007e32:	0c 08       	add	r8,r6
80007e34:	87 0b       	st.w	r3[0x0],r11
80007e36:	fb 48 06 90 	st.w	sp[1680],r8
80007e3a:	87 16       	st.w	r3[0x4],r6
80007e3c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007e40:	2f f8       	sub	r8,-1
80007e42:	fb 48 06 8c 	st.w	sp[1676],r8
80007e46:	58 78       	cp.w	r8,7
80007e48:	e0 89 00 04 	brgt	80007e50 <_vfprintf_r+0x168>
80007e4c:	2f 83       	sub	r3,-8
80007e4e:	c0 a8       	rjmp	80007e62 <_vfprintf_r+0x17a>
80007e50:	fa ca f9 78 	sub	r10,sp,-1672
80007e54:	02 9b       	mov	r11,r1
80007e56:	08 9c       	mov	r12,r4
80007e58:	c3 af       	rcall	80007ccc <__sprint_r>
80007e5a:	e0 81 0e c6 	brne	80009be6 <_vfprintf_r+0x1efe>
80007e5e:	fa c3 f9 e0 	sub	r3,sp,-1568
80007e62:	40 ba       	lddsp	r10,sp[0x2c]
80007e64:	0c 0a       	add	r10,r6
80007e66:	50 ba       	stdsp	sp[0x2c],r10
80007e68:	05 89       	ld.ub	r9,r2[0x0]
80007e6a:	30 08       	mov	r8,0
80007e6c:	f0 09 18 00 	cp.b	r9,r8
80007e70:	e0 80 0e aa 	breq	80009bc4 <_vfprintf_r+0x1edc>
80007e74:	30 09       	mov	r9,0
80007e76:	fb 68 06 bb 	st.b	sp[1723],r8
80007e7a:	0e 96       	mov	r6,r7
80007e7c:	e4 c8 ff ff 	sub	r8,r2,-1
80007e80:	3f fe       	mov	lr,-1
80007e82:	50 93       	stdsp	sp[0x24],r3
80007e84:	50 41       	stdsp	sp[0x10],r1
80007e86:	0e 93       	mov	r3,r7
80007e88:	04 91       	mov	r1,r2
80007e8a:	50 89       	stdsp	sp[0x20],r9
80007e8c:	50 a8       	stdsp	sp[0x28],r8
80007e8e:	50 2e       	stdsp	sp[0x8],lr
80007e90:	50 39       	stdsp	sp[0xc],r9
80007e92:	12 95       	mov	r5,r9
80007e94:	12 90       	mov	r0,r9
80007e96:	10 97       	mov	r7,r8
80007e98:	08 92       	mov	r2,r4
80007e9a:	c0 78       	rjmp	80007ea8 <_vfprintf_r+0x1c0>
80007e9c:	3f fc       	mov	r12,-1
80007e9e:	08 97       	mov	r7,r4
80007ea0:	50 2c       	stdsp	sp[0x8],r12
80007ea2:	c0 38       	rjmp	80007ea8 <_vfprintf_r+0x1c0>
80007ea4:	30 0b       	mov	r11,0
80007ea6:	50 3b       	stdsp	sp[0xc],r11
80007ea8:	0f 38       	ld.ub	r8,r7++
80007eaa:	c0 28       	rjmp	80007eae <_vfprintf_r+0x1c6>
80007eac:	12 90       	mov	r0,r9
80007eae:	f0 c9 00 20 	sub	r9,r8,32
80007eb2:	e0 49 00 58 	cp.w	r9,88
80007eb6:	e0 8b 0a 30 	brhi	80009316 <_vfprintf_r+0x162e>
80007eba:	fe ca b6 e6 	sub	r10,pc,-18714
80007ebe:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007ec2:	50 a7       	stdsp	sp[0x28],r7
80007ec4:	50 80       	stdsp	sp[0x20],r0
80007ec6:	0c 97       	mov	r7,r6
80007ec8:	04 94       	mov	r4,r2
80007eca:	06 96       	mov	r6,r3
80007ecc:	02 92       	mov	r2,r1
80007ece:	fe c9 b4 be 	sub	r9,pc,-19266
80007ed2:	40 93       	lddsp	r3,sp[0x24]
80007ed4:	10 90       	mov	r0,r8
80007ed6:	40 41       	lddsp	r1,sp[0x10]
80007ed8:	50 d9       	stdsp	sp[0x34],r9
80007eda:	e0 8f 08 8e 	bral	80008ff6 <_vfprintf_r+0x130e>
80007ede:	30 08       	mov	r8,0
80007ee0:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007ee4:	f0 09 18 00 	cp.b	r9,r8
80007ee8:	ce 01       	brne	80007ea8 <_vfprintf_r+0x1c0>
80007eea:	32 08       	mov	r8,32
80007eec:	c6 e8       	rjmp	80007fc8 <_vfprintf_r+0x2e0>
80007eee:	a1 a5       	sbr	r5,0x0
80007ef0:	cd cb       	rjmp	80007ea8 <_vfprintf_r+0x1c0>
80007ef2:	0f 89       	ld.ub	r9,r7[0x0]
80007ef4:	f2 c8 00 30 	sub	r8,r9,48
80007ef8:	58 98       	cp.w	r8,9
80007efa:	e0 8b 00 1d 	brhi	80007f34 <_vfprintf_r+0x24c>
80007efe:	ee c8 ff ff 	sub	r8,r7,-1
80007f02:	30 0b       	mov	r11,0
80007f04:	23 09       	sub	r9,48
80007f06:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007f0a:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007f0e:	11 39       	ld.ub	r9,r8++
80007f10:	f2 ca 00 30 	sub	r10,r9,48
80007f14:	58 9a       	cp.w	r10,9
80007f16:	fe 98 ff f7 	brls	80007f04 <_vfprintf_r+0x21c>
80007f1a:	e0 49 00 24 	cp.w	r9,36
80007f1e:	cc 31       	brne	80007ea4 <_vfprintf_r+0x1bc>
80007f20:	e0 4b 00 20 	cp.w	r11,32
80007f24:	e0 89 0e 60 	brgt	80009be4 <_vfprintf_r+0x1efc>
80007f28:	20 1b       	sub	r11,1
80007f2a:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007f2e:	12 3b       	cp.w	r11,r9
80007f30:	c0 95       	brlt	80007f42 <_vfprintf_r+0x25a>
80007f32:	c1 08       	rjmp	80007f52 <_vfprintf_r+0x26a>
80007f34:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007f38:	ec ca ff ff 	sub	r10,r6,-1
80007f3c:	12 36       	cp.w	r6,r9
80007f3e:	c1 f5       	brlt	80007f7c <_vfprintf_r+0x294>
80007f40:	c2 68       	rjmp	80007f8c <_vfprintf_r+0x2a4>
80007f42:	fa ce f9 44 	sub	lr,sp,-1724
80007f46:	10 97       	mov	r7,r8
80007f48:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007f4c:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007f50:	c3 58       	rjmp	80007fba <_vfprintf_r+0x2d2>
80007f52:	10 97       	mov	r7,r8
80007f54:	fa c8 f9 50 	sub	r8,sp,-1712
80007f58:	1a d8       	st.w	--sp,r8
80007f5a:	fa c8 fa b8 	sub	r8,sp,-1352
80007f5e:	1a d8       	st.w	--sp,r8
80007f60:	fa c8 fb b4 	sub	r8,sp,-1100
80007f64:	02 9a       	mov	r10,r1
80007f66:	1a d8       	st.w	--sp,r8
80007f68:	04 9c       	mov	r12,r2
80007f6a:	fa c8 f9 40 	sub	r8,sp,-1728
80007f6e:	fa c9 ff b4 	sub	r9,sp,-76
80007f72:	fe b0 fd 23 	rcall	800079b8 <get_arg>
80007f76:	2f dd       	sub	sp,-12
80007f78:	78 00       	ld.w	r0,r12[0x0]
80007f7a:	c2 08       	rjmp	80007fba <_vfprintf_r+0x2d2>
80007f7c:	fa cc f9 44 	sub	r12,sp,-1724
80007f80:	14 96       	mov	r6,r10
80007f82:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007f86:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007f8a:	c1 88       	rjmp	80007fba <_vfprintf_r+0x2d2>
80007f8c:	41 08       	lddsp	r8,sp[0x40]
80007f8e:	59 f9       	cp.w	r9,31
80007f90:	e0 89 00 11 	brgt	80007fb2 <_vfprintf_r+0x2ca>
80007f94:	f0 cb ff fc 	sub	r11,r8,-4
80007f98:	51 0b       	stdsp	sp[0x40],r11
80007f9a:	70 00       	ld.w	r0,r8[0x0]
80007f9c:	fa cb f9 44 	sub	r11,sp,-1724
80007fa0:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007fa4:	f1 40 fd 88 	st.w	r8[-632],r0
80007fa8:	2f f9       	sub	r9,-1
80007faa:	14 96       	mov	r6,r10
80007fac:	fb 49 06 b4 	st.w	sp[1716],r9
80007fb0:	c0 58       	rjmp	80007fba <_vfprintf_r+0x2d2>
80007fb2:	70 00       	ld.w	r0,r8[0x0]
80007fb4:	14 96       	mov	r6,r10
80007fb6:	2f c8       	sub	r8,-4
80007fb8:	51 08       	stdsp	sp[0x40],r8
80007fba:	58 00       	cp.w	r0,0
80007fbc:	fe 94 ff 76 	brge	80007ea8 <_vfprintf_r+0x1c0>
80007fc0:	5c 30       	neg	r0
80007fc2:	a3 a5       	sbr	r5,0x2
80007fc4:	c7 2b       	rjmp	80007ea8 <_vfprintf_r+0x1c0>
80007fc6:	32 b8       	mov	r8,43
80007fc8:	fb 68 06 bb 	st.b	sp[1723],r8
80007fcc:	c6 eb       	rjmp	80007ea8 <_vfprintf_r+0x1c0>
80007fce:	0f 38       	ld.ub	r8,r7++
80007fd0:	e0 48 00 2a 	cp.w	r8,42
80007fd4:	c0 30       	breq	80007fda <_vfprintf_r+0x2f2>
80007fd6:	30 09       	mov	r9,0
80007fd8:	c7 98       	rjmp	800080ca <_vfprintf_r+0x3e2>
80007fda:	0f 88       	ld.ub	r8,r7[0x0]
80007fdc:	f0 c9 00 30 	sub	r9,r8,48
80007fe0:	58 99       	cp.w	r9,9
80007fe2:	e0 8b 00 1f 	brhi	80008020 <_vfprintf_r+0x338>
80007fe6:	ee c4 ff ff 	sub	r4,r7,-1
80007fea:	30 0b       	mov	r11,0
80007fec:	23 08       	sub	r8,48
80007fee:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007ff2:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007ff6:	09 38       	ld.ub	r8,r4++
80007ff8:	f0 c9 00 30 	sub	r9,r8,48
80007ffc:	58 99       	cp.w	r9,9
80007ffe:	fe 98 ff f7 	brls	80007fec <_vfprintf_r+0x304>
80008002:	e0 48 00 24 	cp.w	r8,36
80008006:	fe 91 ff 4f 	brne	80007ea4 <_vfprintf_r+0x1bc>
8000800a:	e0 4b 00 20 	cp.w	r11,32
8000800e:	e0 89 0d eb 	brgt	80009be4 <_vfprintf_r+0x1efc>
80008012:	20 1b       	sub	r11,1
80008014:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008018:	10 3b       	cp.w	r11,r8
8000801a:	c0 a5       	brlt	8000802e <_vfprintf_r+0x346>
8000801c:	c1 18       	rjmp	8000803e <_vfprintf_r+0x356>
8000801e:	d7 03       	nop
80008020:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008024:	ec c9 ff ff 	sub	r9,r6,-1
80008028:	14 36       	cp.w	r6,r10
8000802a:	c1 f5       	brlt	80008068 <_vfprintf_r+0x380>
8000802c:	c2 88       	rjmp	8000807c <_vfprintf_r+0x394>
8000802e:	fa ca f9 44 	sub	r10,sp,-1724
80008032:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80008036:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000803a:	50 2b       	stdsp	sp[0x8],r11
8000803c:	c3 c8       	rjmp	800080b4 <_vfprintf_r+0x3cc>
8000803e:	fa c8 f9 50 	sub	r8,sp,-1712
80008042:	1a d8       	st.w	--sp,r8
80008044:	fa c8 fa b8 	sub	r8,sp,-1352
80008048:	1a d8       	st.w	--sp,r8
8000804a:	fa c8 fb b4 	sub	r8,sp,-1100
8000804e:	02 9a       	mov	r10,r1
80008050:	1a d8       	st.w	--sp,r8
80008052:	04 9c       	mov	r12,r2
80008054:	fa c8 f9 40 	sub	r8,sp,-1728
80008058:	fa c9 ff b4 	sub	r9,sp,-76
8000805c:	fe b0 fc ae 	rcall	800079b8 <get_arg>
80008060:	2f dd       	sub	sp,-12
80008062:	78 0c       	ld.w	r12,r12[0x0]
80008064:	50 2c       	stdsp	sp[0x8],r12
80008066:	c2 78       	rjmp	800080b4 <_vfprintf_r+0x3cc>
80008068:	12 96       	mov	r6,r9
8000806a:	0e 94       	mov	r4,r7
8000806c:	fa c9 f9 44 	sub	r9,sp,-1724
80008070:	f2 03 00 38 	add	r8,r9,r3<<0x3
80008074:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80008078:	50 28       	stdsp	sp[0x8],r8
8000807a:	c1 d8       	rjmp	800080b4 <_vfprintf_r+0x3cc>
8000807c:	41 08       	lddsp	r8,sp[0x40]
8000807e:	59 fa       	cp.w	r10,31
80008080:	e0 89 00 14 	brgt	800080a8 <_vfprintf_r+0x3c0>
80008084:	f0 cb ff fc 	sub	r11,r8,-4
80008088:	70 08       	ld.w	r8,r8[0x0]
8000808a:	51 0b       	stdsp	sp[0x40],r11
8000808c:	50 28       	stdsp	sp[0x8],r8
8000808e:	fa c6 f9 44 	sub	r6,sp,-1724
80008092:	40 2e       	lddsp	lr,sp[0x8]
80008094:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80008098:	f1 4e fd 88 	st.w	r8[-632],lr
8000809c:	2f fa       	sub	r10,-1
8000809e:	0e 94       	mov	r4,r7
800080a0:	fb 4a 06 b4 	st.w	sp[1716],r10
800080a4:	12 96       	mov	r6,r9
800080a6:	c0 78       	rjmp	800080b4 <_vfprintf_r+0x3cc>
800080a8:	70 0c       	ld.w	r12,r8[0x0]
800080aa:	0e 94       	mov	r4,r7
800080ac:	2f c8       	sub	r8,-4
800080ae:	50 2c       	stdsp	sp[0x8],r12
800080b0:	12 96       	mov	r6,r9
800080b2:	51 08       	stdsp	sp[0x40],r8
800080b4:	40 2b       	lddsp	r11,sp[0x8]
800080b6:	58 0b       	cp.w	r11,0
800080b8:	fe 95 fe f2 	brlt	80007e9c <_vfprintf_r+0x1b4>
800080bc:	08 97       	mov	r7,r4
800080be:	cf 5a       	rjmp	80007ea8 <_vfprintf_r+0x1c0>
800080c0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800080c4:	0f 38       	ld.ub	r8,r7++
800080c6:	f4 09 00 19 	add	r9,r10,r9<<0x1
800080ca:	f0 ca 00 30 	sub	r10,r8,48
800080ce:	58 9a       	cp.w	r10,9
800080d0:	fe 98 ff f8 	brls	800080c0 <_vfprintf_r+0x3d8>
800080d4:	3f fa       	mov	r10,-1
800080d6:	f2 0a 0c 49 	max	r9,r9,r10
800080da:	50 29       	stdsp	sp[0x8],r9
800080dc:	ce 9a       	rjmp	80007eae <_vfprintf_r+0x1c6>
800080de:	a7 b5       	sbr	r5,0x7
800080e0:	ce 4a       	rjmp	80007ea8 <_vfprintf_r+0x1c0>
800080e2:	30 09       	mov	r9,0
800080e4:	23 08       	sub	r8,48
800080e6:	f2 09 00 29 	add	r9,r9,r9<<0x2
800080ea:	f0 09 00 19 	add	r9,r8,r9<<0x1
800080ee:	0f 38       	ld.ub	r8,r7++
800080f0:	f0 ca 00 30 	sub	r10,r8,48
800080f4:	58 9a       	cp.w	r10,9
800080f6:	fe 98 ff f7 	brls	800080e4 <_vfprintf_r+0x3fc>
800080fa:	e0 48 00 24 	cp.w	r8,36
800080fe:	fe 91 fe d7 	brne	80007eac <_vfprintf_r+0x1c4>
80008102:	e0 49 00 20 	cp.w	r9,32
80008106:	e0 89 0d 6f 	brgt	80009be4 <_vfprintf_r+0x1efc>
8000810a:	f2 c3 00 01 	sub	r3,r9,1
8000810e:	30 19       	mov	r9,1
80008110:	50 39       	stdsp	sp[0xc],r9
80008112:	cc ba       	rjmp	80007ea8 <_vfprintf_r+0x1c0>
80008114:	a3 b5       	sbr	r5,0x3
80008116:	cc 9a       	rjmp	80007ea8 <_vfprintf_r+0x1c0>
80008118:	a7 a5       	sbr	r5,0x6
8000811a:	cc 7a       	rjmp	80007ea8 <_vfprintf_r+0x1c0>
8000811c:	0a 98       	mov	r8,r5
8000811e:	a5 b5       	sbr	r5,0x5
80008120:	a5 a8       	sbr	r8,0x4
80008122:	0f 89       	ld.ub	r9,r7[0x0]
80008124:	36 ce       	mov	lr,108
80008126:	fc 09 18 00 	cp.b	r9,lr
8000812a:	f7 b7 00 ff 	subeq	r7,-1
8000812e:	f0 05 17 10 	movne	r5,r8
80008132:	cb ba       	rjmp	80007ea8 <_vfprintf_r+0x1c0>
80008134:	a5 b5       	sbr	r5,0x5
80008136:	cb 9a       	rjmp	80007ea8 <_vfprintf_r+0x1c0>
80008138:	50 a7       	stdsp	sp[0x28],r7
8000813a:	50 80       	stdsp	sp[0x20],r0
8000813c:	0c 97       	mov	r7,r6
8000813e:	10 90       	mov	r0,r8
80008140:	06 96       	mov	r6,r3
80008142:	04 94       	mov	r4,r2
80008144:	40 93       	lddsp	r3,sp[0x24]
80008146:	02 92       	mov	r2,r1
80008148:	0e 99       	mov	r9,r7
8000814a:	40 41       	lddsp	r1,sp[0x10]
8000814c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008150:	40 3c       	lddsp	r12,sp[0xc]
80008152:	58 0c       	cp.w	r12,0
80008154:	c1 d0       	breq	8000818e <_vfprintf_r+0x4a6>
80008156:	10 36       	cp.w	r6,r8
80008158:	c0 64       	brge	80008164 <_vfprintf_r+0x47c>
8000815a:	fa cb f9 44 	sub	r11,sp,-1724
8000815e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008162:	c1 d8       	rjmp	8000819c <_vfprintf_r+0x4b4>
80008164:	fa c8 f9 50 	sub	r8,sp,-1712
80008168:	1a d8       	st.w	--sp,r8
8000816a:	fa c8 fa b8 	sub	r8,sp,-1352
8000816e:	1a d8       	st.w	--sp,r8
80008170:	fa c8 fb b4 	sub	r8,sp,-1100
80008174:	1a d8       	st.w	--sp,r8
80008176:	fa c8 f9 40 	sub	r8,sp,-1728
8000817a:	fa c9 ff b4 	sub	r9,sp,-76
8000817e:	04 9a       	mov	r10,r2
80008180:	0c 9b       	mov	r11,r6
80008182:	08 9c       	mov	r12,r4
80008184:	fe b0 fc 1a 	rcall	800079b8 <get_arg>
80008188:	2f dd       	sub	sp,-12
8000818a:	19 b8       	ld.ub	r8,r12[0x3]
8000818c:	c2 28       	rjmp	800081d0 <_vfprintf_r+0x4e8>
8000818e:	2f f7       	sub	r7,-1
80008190:	10 39       	cp.w	r9,r8
80008192:	c0 84       	brge	800081a2 <_vfprintf_r+0x4ba>
80008194:	fa ca f9 44 	sub	r10,sp,-1724
80008198:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000819c:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800081a0:	c1 88       	rjmp	800081d0 <_vfprintf_r+0x4e8>
800081a2:	41 09       	lddsp	r9,sp[0x40]
800081a4:	59 f8       	cp.w	r8,31
800081a6:	e0 89 00 12 	brgt	800081ca <_vfprintf_r+0x4e2>
800081aa:	f2 ca ff fc 	sub	r10,r9,-4
800081ae:	51 0a       	stdsp	sp[0x40],r10
800081b0:	72 09       	ld.w	r9,r9[0x0]
800081b2:	fa c6 f9 44 	sub	r6,sp,-1724
800081b6:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800081ba:	2f f8       	sub	r8,-1
800081bc:	f5 49 fd 88 	st.w	r10[-632],r9
800081c0:	fb 48 06 b4 	st.w	sp[1716],r8
800081c4:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800081c8:	c0 48       	rjmp	800081d0 <_vfprintf_r+0x4e8>
800081ca:	13 b8       	ld.ub	r8,r9[0x3]
800081cc:	2f c9       	sub	r9,-4
800081ce:	51 09       	stdsp	sp[0x40],r9
800081d0:	fb 68 06 60 	st.b	sp[1632],r8
800081d4:	30 0e       	mov	lr,0
800081d6:	30 08       	mov	r8,0
800081d8:	30 12       	mov	r2,1
800081da:	fb 68 06 bb 	st.b	sp[1723],r8
800081de:	50 2e       	stdsp	sp[0x8],lr
800081e0:	e0 8f 08 ad 	bral	8000933a <_vfprintf_r+0x1652>
800081e4:	50 a7       	stdsp	sp[0x28],r7
800081e6:	50 80       	stdsp	sp[0x20],r0
800081e8:	0c 97       	mov	r7,r6
800081ea:	04 94       	mov	r4,r2
800081ec:	06 96       	mov	r6,r3
800081ee:	02 92       	mov	r2,r1
800081f0:	40 93       	lddsp	r3,sp[0x24]
800081f2:	10 90       	mov	r0,r8
800081f4:	40 41       	lddsp	r1,sp[0x10]
800081f6:	a5 a5       	sbr	r5,0x4
800081f8:	c0 a8       	rjmp	8000820c <_vfprintf_r+0x524>
800081fa:	50 a7       	stdsp	sp[0x28],r7
800081fc:	50 80       	stdsp	sp[0x20],r0
800081fe:	0c 97       	mov	r7,r6
80008200:	04 94       	mov	r4,r2
80008202:	06 96       	mov	r6,r3
80008204:	02 92       	mov	r2,r1
80008206:	40 93       	lddsp	r3,sp[0x24]
80008208:	10 90       	mov	r0,r8
8000820a:	40 41       	lddsp	r1,sp[0x10]
8000820c:	ed b5 00 05 	bld	r5,0x5
80008210:	c5 11       	brne	800082b2 <_vfprintf_r+0x5ca>
80008212:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008216:	40 3c       	lddsp	r12,sp[0xc]
80008218:	58 0c       	cp.w	r12,0
8000821a:	c1 e0       	breq	80008256 <_vfprintf_r+0x56e>
8000821c:	10 36       	cp.w	r6,r8
8000821e:	c0 64       	brge	8000822a <_vfprintf_r+0x542>
80008220:	fa cb f9 44 	sub	r11,sp,-1724
80008224:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008228:	c2 08       	rjmp	80008268 <_vfprintf_r+0x580>
8000822a:	fa c8 f9 50 	sub	r8,sp,-1712
8000822e:	1a d8       	st.w	--sp,r8
80008230:	fa c8 fa b8 	sub	r8,sp,-1352
80008234:	0c 9b       	mov	r11,r6
80008236:	1a d8       	st.w	--sp,r8
80008238:	fa c8 fb b4 	sub	r8,sp,-1100
8000823c:	1a d8       	st.w	--sp,r8
8000823e:	fa c9 ff b4 	sub	r9,sp,-76
80008242:	fa c8 f9 40 	sub	r8,sp,-1728
80008246:	04 9a       	mov	r10,r2
80008248:	08 9c       	mov	r12,r4
8000824a:	fe b0 fb b7 	rcall	800079b8 <get_arg>
8000824e:	2f dd       	sub	sp,-12
80008250:	78 1b       	ld.w	r11,r12[0x4]
80008252:	78 09       	ld.w	r9,r12[0x0]
80008254:	c2 b8       	rjmp	800082aa <_vfprintf_r+0x5c2>
80008256:	ee ca ff ff 	sub	r10,r7,-1
8000825a:	10 37       	cp.w	r7,r8
8000825c:	c0 b4       	brge	80008272 <_vfprintf_r+0x58a>
8000825e:	fa c9 f9 44 	sub	r9,sp,-1724
80008262:	14 97       	mov	r7,r10
80008264:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008268:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000826c:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008270:	c1 d8       	rjmp	800082aa <_vfprintf_r+0x5c2>
80008272:	41 09       	lddsp	r9,sp[0x40]
80008274:	59 f8       	cp.w	r8,31
80008276:	e0 89 00 14 	brgt	8000829e <_vfprintf_r+0x5b6>
8000827a:	f2 cb ff f8 	sub	r11,r9,-8
8000827e:	51 0b       	stdsp	sp[0x40],r11
80008280:	fa c6 f9 44 	sub	r6,sp,-1724
80008284:	72 1b       	ld.w	r11,r9[0x4]
80008286:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000828a:	72 09       	ld.w	r9,r9[0x0]
8000828c:	f9 4b fd 8c 	st.w	r12[-628],r11
80008290:	f9 49 fd 88 	st.w	r12[-632],r9
80008294:	2f f8       	sub	r8,-1
80008296:	14 97       	mov	r7,r10
80008298:	fb 48 06 b4 	st.w	sp[1716],r8
8000829c:	c0 78       	rjmp	800082aa <_vfprintf_r+0x5c2>
8000829e:	f2 c8 ff f8 	sub	r8,r9,-8
800082a2:	72 1b       	ld.w	r11,r9[0x4]
800082a4:	14 97       	mov	r7,r10
800082a6:	51 08       	stdsp	sp[0x40],r8
800082a8:	72 09       	ld.w	r9,r9[0x0]
800082aa:	16 98       	mov	r8,r11
800082ac:	fa e9 00 00 	st.d	sp[0],r8
800082b0:	ca e8       	rjmp	8000840c <_vfprintf_r+0x724>
800082b2:	ed b5 00 04 	bld	r5,0x4
800082b6:	c1 71       	brne	800082e4 <_vfprintf_r+0x5fc>
800082b8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082bc:	40 3e       	lddsp	lr,sp[0xc]
800082be:	58 0e       	cp.w	lr,0
800082c0:	c0 80       	breq	800082d0 <_vfprintf_r+0x5e8>
800082c2:	10 36       	cp.w	r6,r8
800082c4:	c6 94       	brge	80008396 <_vfprintf_r+0x6ae>
800082c6:	fa cc f9 44 	sub	r12,sp,-1724
800082ca:	f8 06 00 36 	add	r6,r12,r6<<0x3
800082ce:	c8 28       	rjmp	800083d2 <_vfprintf_r+0x6ea>
800082d0:	ee ca ff ff 	sub	r10,r7,-1
800082d4:	10 37       	cp.w	r7,r8
800082d6:	e0 84 00 81 	brge	800083d8 <_vfprintf_r+0x6f0>
800082da:	fa cb f9 44 	sub	r11,sp,-1724
800082de:	f6 06 00 36 	add	r6,r11,r6<<0x3
800082e2:	c7 78       	rjmp	800083d0 <_vfprintf_r+0x6e8>
800082e4:	ed b5 00 06 	bld	r5,0x6
800082e8:	c4 b1       	brne	8000837e <_vfprintf_r+0x696>
800082ea:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082ee:	40 3c       	lddsp	r12,sp[0xc]
800082f0:	58 0c       	cp.w	r12,0
800082f2:	c1 d0       	breq	8000832c <_vfprintf_r+0x644>
800082f4:	10 36       	cp.w	r6,r8
800082f6:	c0 64       	brge	80008302 <_vfprintf_r+0x61a>
800082f8:	fa cb f9 44 	sub	r11,sp,-1724
800082fc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008300:	c1 f8       	rjmp	8000833e <_vfprintf_r+0x656>
80008302:	fa c8 f9 50 	sub	r8,sp,-1712
80008306:	1a d8       	st.w	--sp,r8
80008308:	fa c8 fa b8 	sub	r8,sp,-1352
8000830c:	1a d8       	st.w	--sp,r8
8000830e:	fa c8 fb b4 	sub	r8,sp,-1100
80008312:	1a d8       	st.w	--sp,r8
80008314:	fa c8 f9 40 	sub	r8,sp,-1728
80008318:	fa c9 ff b4 	sub	r9,sp,-76
8000831c:	04 9a       	mov	r10,r2
8000831e:	0c 9b       	mov	r11,r6
80008320:	08 9c       	mov	r12,r4
80008322:	fe b0 fb 4b 	rcall	800079b8 <get_arg>
80008326:	2f dd       	sub	sp,-12
80008328:	98 18       	ld.sh	r8,r12[0x2]
8000832a:	c2 68       	rjmp	80008376 <_vfprintf_r+0x68e>
8000832c:	ee ca ff ff 	sub	r10,r7,-1
80008330:	10 37       	cp.w	r7,r8
80008332:	c0 94       	brge	80008344 <_vfprintf_r+0x65c>
80008334:	fa c9 f9 44 	sub	r9,sp,-1724
80008338:	14 97       	mov	r7,r10
8000833a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000833e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008342:	c1 a8       	rjmp	80008376 <_vfprintf_r+0x68e>
80008344:	41 09       	lddsp	r9,sp[0x40]
80008346:	59 f8       	cp.w	r8,31
80008348:	e0 89 00 13 	brgt	8000836e <_vfprintf_r+0x686>
8000834c:	f2 cb ff fc 	sub	r11,r9,-4
80008350:	51 0b       	stdsp	sp[0x40],r11
80008352:	72 09       	ld.w	r9,r9[0x0]
80008354:	fa c6 f9 44 	sub	r6,sp,-1724
80008358:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000835c:	2f f8       	sub	r8,-1
8000835e:	f7 49 fd 88 	st.w	r11[-632],r9
80008362:	fb 48 06 b4 	st.w	sp[1716],r8
80008366:	14 97       	mov	r7,r10
80008368:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000836c:	c0 58       	rjmp	80008376 <_vfprintf_r+0x68e>
8000836e:	92 18       	ld.sh	r8,r9[0x2]
80008370:	14 97       	mov	r7,r10
80008372:	2f c9       	sub	r9,-4
80008374:	51 09       	stdsp	sp[0x40],r9
80008376:	50 18       	stdsp	sp[0x4],r8
80008378:	bf 58       	asr	r8,0x1f
8000837a:	50 08       	stdsp	sp[0x0],r8
8000837c:	c4 88       	rjmp	8000840c <_vfprintf_r+0x724>
8000837e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008382:	40 3c       	lddsp	r12,sp[0xc]
80008384:	58 0c       	cp.w	r12,0
80008386:	c1 d0       	breq	800083c0 <_vfprintf_r+0x6d8>
80008388:	10 36       	cp.w	r6,r8
8000838a:	c0 64       	brge	80008396 <_vfprintf_r+0x6ae>
8000838c:	fa cb f9 44 	sub	r11,sp,-1724
80008390:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008394:	c1 f8       	rjmp	800083d2 <_vfprintf_r+0x6ea>
80008396:	fa c8 f9 50 	sub	r8,sp,-1712
8000839a:	1a d8       	st.w	--sp,r8
8000839c:	fa c8 fa b8 	sub	r8,sp,-1352
800083a0:	0c 9b       	mov	r11,r6
800083a2:	1a d8       	st.w	--sp,r8
800083a4:	fa c8 fb b4 	sub	r8,sp,-1100
800083a8:	04 9a       	mov	r10,r2
800083aa:	1a d8       	st.w	--sp,r8
800083ac:	08 9c       	mov	r12,r4
800083ae:	fa c8 f9 40 	sub	r8,sp,-1728
800083b2:	fa c9 ff b4 	sub	r9,sp,-76
800083b6:	fe b0 fb 01 	rcall	800079b8 <get_arg>
800083ba:	2f dd       	sub	sp,-12
800083bc:	78 0b       	ld.w	r11,r12[0x0]
800083be:	c2 48       	rjmp	80008406 <_vfprintf_r+0x71e>
800083c0:	ee ca ff ff 	sub	r10,r7,-1
800083c4:	10 37       	cp.w	r7,r8
800083c6:	c0 94       	brge	800083d8 <_vfprintf_r+0x6f0>
800083c8:	fa c9 f9 44 	sub	r9,sp,-1724
800083cc:	f2 06 00 36 	add	r6,r9,r6<<0x3
800083d0:	14 97       	mov	r7,r10
800083d2:	ec fb fd 88 	ld.w	r11,r6[-632]
800083d6:	c1 88       	rjmp	80008406 <_vfprintf_r+0x71e>
800083d8:	41 09       	lddsp	r9,sp[0x40]
800083da:	59 f8       	cp.w	r8,31
800083dc:	e0 89 00 11 	brgt	800083fe <_vfprintf_r+0x716>
800083e0:	f2 cb ff fc 	sub	r11,r9,-4
800083e4:	51 0b       	stdsp	sp[0x40],r11
800083e6:	fa c6 f9 44 	sub	r6,sp,-1724
800083ea:	72 0b       	ld.w	r11,r9[0x0]
800083ec:	ec 08 00 39 	add	r9,r6,r8<<0x3
800083f0:	f3 4b fd 88 	st.w	r9[-632],r11
800083f4:	2f f8       	sub	r8,-1
800083f6:	14 97       	mov	r7,r10
800083f8:	fb 48 06 b4 	st.w	sp[1716],r8
800083fc:	c0 58       	rjmp	80008406 <_vfprintf_r+0x71e>
800083fe:	72 0b       	ld.w	r11,r9[0x0]
80008400:	14 97       	mov	r7,r10
80008402:	2f c9       	sub	r9,-4
80008404:	51 09       	stdsp	sp[0x40],r9
80008406:	50 1b       	stdsp	sp[0x4],r11
80008408:	bf 5b       	asr	r11,0x1f
8000840a:	50 0b       	stdsp	sp[0x0],r11
8000840c:	fa ea 00 00 	ld.d	r10,sp[0]
80008410:	58 0a       	cp.w	r10,0
80008412:	5c 2b       	cpc	r11
80008414:	c0 e4       	brge	80008430 <_vfprintf_r+0x748>
80008416:	30 08       	mov	r8,0
80008418:	fa ea 00 00 	ld.d	r10,sp[0]
8000841c:	30 09       	mov	r9,0
8000841e:	f0 0a 01 0a 	sub	r10,r8,r10
80008422:	f2 0b 01 4b 	sbc	r11,r9,r11
80008426:	32 d8       	mov	r8,45
80008428:	fa eb 00 00 	st.d	sp[0],r10
8000842c:	fb 68 06 bb 	st.b	sp[1723],r8
80008430:	30 18       	mov	r8,1
80008432:	e0 8f 06 fa 	bral	80009226 <_vfprintf_r+0x153e>
80008436:	50 a7       	stdsp	sp[0x28],r7
80008438:	50 80       	stdsp	sp[0x20],r0
8000843a:	0c 97       	mov	r7,r6
8000843c:	04 94       	mov	r4,r2
8000843e:	06 96       	mov	r6,r3
80008440:	02 92       	mov	r2,r1
80008442:	40 93       	lddsp	r3,sp[0x24]
80008444:	10 90       	mov	r0,r8
80008446:	40 41       	lddsp	r1,sp[0x10]
80008448:	0e 99       	mov	r9,r7
8000844a:	ed b5 00 03 	bld	r5,0x3
8000844e:	c4 11       	brne	800084d0 <_vfprintf_r+0x7e8>
80008450:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008454:	40 3a       	lddsp	r10,sp[0xc]
80008456:	58 0a       	cp.w	r10,0
80008458:	c1 90       	breq	8000848a <_vfprintf_r+0x7a2>
8000845a:	10 36       	cp.w	r6,r8
8000845c:	c6 45       	brlt	80008524 <_vfprintf_r+0x83c>
8000845e:	fa c8 f9 50 	sub	r8,sp,-1712
80008462:	1a d8       	st.w	--sp,r8
80008464:	fa c8 fa b8 	sub	r8,sp,-1352
80008468:	1a d8       	st.w	--sp,r8
8000846a:	fa c8 fb b4 	sub	r8,sp,-1100
8000846e:	0c 9b       	mov	r11,r6
80008470:	1a d8       	st.w	--sp,r8
80008472:	04 9a       	mov	r10,r2
80008474:	fa c8 f9 40 	sub	r8,sp,-1728
80008478:	fa c9 ff b4 	sub	r9,sp,-76
8000847c:	08 9c       	mov	r12,r4
8000847e:	fe b0 fa 9d 	rcall	800079b8 <get_arg>
80008482:	2f dd       	sub	sp,-12
80008484:	78 16       	ld.w	r6,r12[0x4]
80008486:	50 76       	stdsp	sp[0x1c],r6
80008488:	c4 88       	rjmp	80008518 <_vfprintf_r+0x830>
8000848a:	2f f7       	sub	r7,-1
8000848c:	10 39       	cp.w	r9,r8
8000848e:	c0 c4       	brge	800084a6 <_vfprintf_r+0x7be>
80008490:	fa ce f9 44 	sub	lr,sp,-1724
80008494:	fc 06 00 36 	add	r6,lr,r6<<0x3
80008498:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000849c:	50 7c       	stdsp	sp[0x1c],r12
8000849e:	ec f6 fd 88 	ld.w	r6,r6[-632]
800084a2:	50 56       	stdsp	sp[0x14],r6
800084a4:	c6 68       	rjmp	80008570 <_vfprintf_r+0x888>
800084a6:	41 09       	lddsp	r9,sp[0x40]
800084a8:	59 f8       	cp.w	r8,31
800084aa:	e0 89 00 10 	brgt	800084ca <_vfprintf_r+0x7e2>
800084ae:	f2 ca ff f8 	sub	r10,r9,-8
800084b2:	72 1b       	ld.w	r11,r9[0x4]
800084b4:	51 0a       	stdsp	sp[0x40],r10
800084b6:	72 09       	ld.w	r9,r9[0x0]
800084b8:	fa ca f9 44 	sub	r10,sp,-1724
800084bc:	50 7b       	stdsp	sp[0x1c],r11
800084be:	50 59       	stdsp	sp[0x14],r9
800084c0:	f4 08 00 39 	add	r9,r10,r8<<0x3
800084c4:	40 5b       	lddsp	r11,sp[0x14]
800084c6:	40 7a       	lddsp	r10,sp[0x1c]
800084c8:	c4 78       	rjmp	80008556 <_vfprintf_r+0x86e>
800084ca:	72 18       	ld.w	r8,r9[0x4]
800084cc:	50 78       	stdsp	sp[0x1c],r8
800084ce:	c4 c8       	rjmp	80008566 <_vfprintf_r+0x87e>
800084d0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084d4:	40 3e       	lddsp	lr,sp[0xc]
800084d6:	58 0e       	cp.w	lr,0
800084d8:	c2 30       	breq	8000851e <_vfprintf_r+0x836>
800084da:	10 36       	cp.w	r6,r8
800084dc:	c0 94       	brge	800084ee <_vfprintf_r+0x806>
800084de:	fa cc f9 44 	sub	r12,sp,-1724
800084e2:	f8 06 00 36 	add	r6,r12,r6<<0x3
800084e6:	ec fb fd 8c 	ld.w	r11,r6[-628]
800084ea:	50 7b       	stdsp	sp[0x1c],r11
800084ec:	cd 9b       	rjmp	8000849e <_vfprintf_r+0x7b6>
800084ee:	fa c8 f9 50 	sub	r8,sp,-1712
800084f2:	1a d8       	st.w	--sp,r8
800084f4:	fa c8 fa b8 	sub	r8,sp,-1352
800084f8:	04 9a       	mov	r10,r2
800084fa:	1a d8       	st.w	--sp,r8
800084fc:	fa c8 fb b4 	sub	r8,sp,-1100
80008500:	0c 9b       	mov	r11,r6
80008502:	1a d8       	st.w	--sp,r8
80008504:	08 9c       	mov	r12,r4
80008506:	fa c8 f9 40 	sub	r8,sp,-1728
8000850a:	fa c9 ff b4 	sub	r9,sp,-76
8000850e:	fe b0 fa 55 	rcall	800079b8 <get_arg>
80008512:	2f dd       	sub	sp,-12
80008514:	78 1a       	ld.w	r10,r12[0x4]
80008516:	50 7a       	stdsp	sp[0x1c],r10
80008518:	78 0c       	ld.w	r12,r12[0x0]
8000851a:	50 5c       	stdsp	sp[0x14],r12
8000851c:	c2 a8       	rjmp	80008570 <_vfprintf_r+0x888>
8000851e:	2f f7       	sub	r7,-1
80008520:	10 39       	cp.w	r9,r8
80008522:	c0 94       	brge	80008534 <_vfprintf_r+0x84c>
80008524:	fa c9 f9 44 	sub	r9,sp,-1724
80008528:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000852c:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008530:	50 78       	stdsp	sp[0x1c],r8
80008532:	cb 6b       	rjmp	8000849e <_vfprintf_r+0x7b6>
80008534:	41 09       	lddsp	r9,sp[0x40]
80008536:	59 f8       	cp.w	r8,31
80008538:	e0 89 00 15 	brgt	80008562 <_vfprintf_r+0x87a>
8000853c:	f2 ca ff f8 	sub	r10,r9,-8
80008540:	72 16       	ld.w	r6,r9[0x4]
80008542:	72 09       	ld.w	r9,r9[0x0]
80008544:	51 0a       	stdsp	sp[0x40],r10
80008546:	50 59       	stdsp	sp[0x14],r9
80008548:	fa ce f9 44 	sub	lr,sp,-1724
8000854c:	50 76       	stdsp	sp[0x1c],r6
8000854e:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008552:	40 5b       	lddsp	r11,sp[0x14]
80008554:	0c 9a       	mov	r10,r6
80008556:	f2 eb fd 88 	st.d	r9[-632],r10
8000855a:	2f f8       	sub	r8,-1
8000855c:	fb 48 06 b4 	st.w	sp[1716],r8
80008560:	c0 88       	rjmp	80008570 <_vfprintf_r+0x888>
80008562:	72 1c       	ld.w	r12,r9[0x4]
80008564:	50 7c       	stdsp	sp[0x1c],r12
80008566:	f2 c8 ff f8 	sub	r8,r9,-8
8000856a:	51 08       	stdsp	sp[0x40],r8
8000856c:	72 09       	ld.w	r9,r9[0x0]
8000856e:	50 59       	stdsp	sp[0x14],r9
80008570:	40 5b       	lddsp	r11,sp[0x14]
80008572:	40 7a       	lddsp	r10,sp[0x1c]
80008574:	e0 a0 18 0c 	rcall	8000b58c <__isinfd>
80008578:	18 96       	mov	r6,r12
8000857a:	c1 70       	breq	800085a8 <_vfprintf_r+0x8c0>
8000857c:	30 08       	mov	r8,0
8000857e:	30 09       	mov	r9,0
80008580:	40 5b       	lddsp	r11,sp[0x14]
80008582:	40 7a       	lddsp	r10,sp[0x1c]
80008584:	e0 a0 1b 82 	rcall	8000bc88 <__avr32_f64_cmp_lt>
80008588:	c0 40       	breq	80008590 <_vfprintf_r+0x8a8>
8000858a:	32 d8       	mov	r8,45
8000858c:	fb 68 06 bb 	st.b	sp[1723],r8
80008590:	fe c8 bb 6c 	sub	r8,pc,-17556
80008594:	fe c6 bb 6c 	sub	r6,pc,-17556
80008598:	a7 d5       	cbr	r5,0x7
8000859a:	e0 40 00 47 	cp.w	r0,71
8000859e:	f0 06 17 a0 	movle	r6,r8
800085a2:	30 32       	mov	r2,3
800085a4:	e0 8f 06 ce 	bral	80009340 <_vfprintf_r+0x1658>
800085a8:	40 5b       	lddsp	r11,sp[0x14]
800085aa:	40 7a       	lddsp	r10,sp[0x1c]
800085ac:	e0 a0 18 05 	rcall	8000b5b6 <__isnand>
800085b0:	c0 e0       	breq	800085cc <_vfprintf_r+0x8e4>
800085b2:	50 26       	stdsp	sp[0x8],r6
800085b4:	fe c8 bb 88 	sub	r8,pc,-17528
800085b8:	fe c6 bb 88 	sub	r6,pc,-17528
800085bc:	a7 d5       	cbr	r5,0x7
800085be:	e0 40 00 47 	cp.w	r0,71
800085c2:	f0 06 17 a0 	movle	r6,r8
800085c6:	30 32       	mov	r2,3
800085c8:	e0 8f 06 c2 	bral	8000934c <_vfprintf_r+0x1664>
800085cc:	40 2a       	lddsp	r10,sp[0x8]
800085ce:	5b fa       	cp.w	r10,-1
800085d0:	c0 41       	brne	800085d8 <_vfprintf_r+0x8f0>
800085d2:	30 69       	mov	r9,6
800085d4:	50 29       	stdsp	sp[0x8],r9
800085d6:	c1 18       	rjmp	800085f8 <_vfprintf_r+0x910>
800085d8:	e0 40 00 47 	cp.w	r0,71
800085dc:	5f 09       	sreq	r9
800085de:	e0 40 00 67 	cp.w	r0,103
800085e2:	5f 08       	sreq	r8
800085e4:	f3 e8 10 08 	or	r8,r9,r8
800085e8:	f8 08 18 00 	cp.b	r8,r12
800085ec:	c0 60       	breq	800085f8 <_vfprintf_r+0x910>
800085ee:	40 28       	lddsp	r8,sp[0x8]
800085f0:	58 08       	cp.w	r8,0
800085f2:	f9 b8 00 01 	moveq	r8,1
800085f6:	50 28       	stdsp	sp[0x8],r8
800085f8:	40 78       	lddsp	r8,sp[0x1c]
800085fa:	40 59       	lddsp	r9,sp[0x14]
800085fc:	fa e9 06 94 	st.d	sp[1684],r8
80008600:	a9 a5       	sbr	r5,0x8
80008602:	fa f8 06 94 	ld.w	r8,sp[1684]
80008606:	58 08       	cp.w	r8,0
80008608:	c0 65       	brlt	80008614 <_vfprintf_r+0x92c>
8000860a:	40 5e       	lddsp	lr,sp[0x14]
8000860c:	30 0c       	mov	r12,0
8000860e:	50 6e       	stdsp	sp[0x18],lr
80008610:	50 9c       	stdsp	sp[0x24],r12
80008612:	c0 78       	rjmp	80008620 <_vfprintf_r+0x938>
80008614:	40 5b       	lddsp	r11,sp[0x14]
80008616:	32 da       	mov	r10,45
80008618:	ee 1b 80 00 	eorh	r11,0x8000
8000861c:	50 9a       	stdsp	sp[0x24],r10
8000861e:	50 6b       	stdsp	sp[0x18],r11
80008620:	e0 40 00 46 	cp.w	r0,70
80008624:	5f 09       	sreq	r9
80008626:	e0 40 00 66 	cp.w	r0,102
8000862a:	5f 08       	sreq	r8
8000862c:	f3 e8 10 08 	or	r8,r9,r8
80008630:	50 48       	stdsp	sp[0x10],r8
80008632:	c0 40       	breq	8000863a <_vfprintf_r+0x952>
80008634:	40 22       	lddsp	r2,sp[0x8]
80008636:	30 39       	mov	r9,3
80008638:	c1 08       	rjmp	80008658 <_vfprintf_r+0x970>
8000863a:	e0 40 00 45 	cp.w	r0,69
8000863e:	5f 09       	sreq	r9
80008640:	e0 40 00 65 	cp.w	r0,101
80008644:	5f 08       	sreq	r8
80008646:	40 22       	lddsp	r2,sp[0x8]
80008648:	10 49       	or	r9,r8
8000864a:	2f f2       	sub	r2,-1
8000864c:	40 46       	lddsp	r6,sp[0x10]
8000864e:	ec 09 18 00 	cp.b	r9,r6
80008652:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008656:	30 29       	mov	r9,2
80008658:	fa c8 f9 5c 	sub	r8,sp,-1700
8000865c:	1a d8       	st.w	--sp,r8
8000865e:	fa c8 f9 54 	sub	r8,sp,-1708
80008662:	1a d8       	st.w	--sp,r8
80008664:	fa c8 f9 4c 	sub	r8,sp,-1716
80008668:	08 9c       	mov	r12,r4
8000866a:	1a d8       	st.w	--sp,r8
8000866c:	04 98       	mov	r8,r2
8000866e:	40 9b       	lddsp	r11,sp[0x24]
80008670:	40 aa       	lddsp	r10,sp[0x28]
80008672:	e0 a0 0b e7 	rcall	80009e40 <_dtoa_r>
80008676:	e0 40 00 47 	cp.w	r0,71
8000867a:	5f 19       	srne	r9
8000867c:	e0 40 00 67 	cp.w	r0,103
80008680:	5f 18       	srne	r8
80008682:	18 96       	mov	r6,r12
80008684:	2f dd       	sub	sp,-12
80008686:	f3 e8 00 08 	and	r8,r9,r8
8000868a:	c0 41       	brne	80008692 <_vfprintf_r+0x9aa>
8000868c:	ed b5 00 00 	bld	r5,0x0
80008690:	c3 01       	brne	800086f0 <_vfprintf_r+0xa08>
80008692:	ec 02 00 0e 	add	lr,r6,r2
80008696:	50 3e       	stdsp	sp[0xc],lr
80008698:	40 4c       	lddsp	r12,sp[0x10]
8000869a:	58 0c       	cp.w	r12,0
8000869c:	c1 50       	breq	800086c6 <_vfprintf_r+0x9de>
8000869e:	0d 89       	ld.ub	r9,r6[0x0]
800086a0:	33 08       	mov	r8,48
800086a2:	f0 09 18 00 	cp.b	r9,r8
800086a6:	c0 b1       	brne	800086bc <_vfprintf_r+0x9d4>
800086a8:	30 08       	mov	r8,0
800086aa:	30 09       	mov	r9,0
800086ac:	40 6b       	lddsp	r11,sp[0x18]
800086ae:	40 7a       	lddsp	r10,sp[0x1c]
800086b0:	e0 a0 1a a5 	rcall	8000bbfa <__avr32_f64_cmp_eq>
800086b4:	fb b2 00 01 	rsubeq	r2,1
800086b8:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800086bc:	40 3b       	lddsp	r11,sp[0xc]
800086be:	fa f8 06 ac 	ld.w	r8,sp[1708]
800086c2:	10 0b       	add	r11,r8
800086c4:	50 3b       	stdsp	sp[0xc],r11
800086c6:	40 6b       	lddsp	r11,sp[0x18]
800086c8:	30 08       	mov	r8,0
800086ca:	30 09       	mov	r9,0
800086cc:	40 7a       	lddsp	r10,sp[0x1c]
800086ce:	e0 a0 1a 96 	rcall	8000bbfa <__avr32_f64_cmp_eq>
800086d2:	c0 90       	breq	800086e4 <_vfprintf_r+0x9fc>
800086d4:	40 3a       	lddsp	r10,sp[0xc]
800086d6:	fb 4a 06 a4 	st.w	sp[1700],r10
800086da:	c0 58       	rjmp	800086e4 <_vfprintf_r+0x9fc>
800086dc:	10 c9       	st.b	r8++,r9
800086de:	fb 48 06 a4 	st.w	sp[1700],r8
800086e2:	c0 28       	rjmp	800086e6 <_vfprintf_r+0x9fe>
800086e4:	33 09       	mov	r9,48
800086e6:	fa f8 06 a4 	ld.w	r8,sp[1700]
800086ea:	40 3e       	lddsp	lr,sp[0xc]
800086ec:	1c 38       	cp.w	r8,lr
800086ee:	cf 73       	brcs	800086dc <_vfprintf_r+0x9f4>
800086f0:	e0 40 00 47 	cp.w	r0,71
800086f4:	5f 09       	sreq	r9
800086f6:	e0 40 00 67 	cp.w	r0,103
800086fa:	5f 08       	sreq	r8
800086fc:	f3 e8 10 08 	or	r8,r9,r8
80008700:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008704:	0c 19       	sub	r9,r6
80008706:	50 69       	stdsp	sp[0x18],r9
80008708:	58 08       	cp.w	r8,0
8000870a:	c0 b0       	breq	80008720 <_vfprintf_r+0xa38>
8000870c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008710:	5b d8       	cp.w	r8,-3
80008712:	c0 55       	brlt	8000871c <_vfprintf_r+0xa34>
80008714:	40 2c       	lddsp	r12,sp[0x8]
80008716:	18 38       	cp.w	r8,r12
80008718:	e0 8a 00 6a 	brle	800087ec <_vfprintf_r+0xb04>
8000871c:	20 20       	sub	r0,2
8000871e:	c0 58       	rjmp	80008728 <_vfprintf_r+0xa40>
80008720:	e0 40 00 65 	cp.w	r0,101
80008724:	e0 89 00 46 	brgt	800087b0 <_vfprintf_r+0xac8>
80008728:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000872c:	fb 60 06 9c 	st.b	sp[1692],r0
80008730:	20 1b       	sub	r11,1
80008732:	fb 4b 06 ac 	st.w	sp[1708],r11
80008736:	c0 47       	brpl	8000873e <_vfprintf_r+0xa56>
80008738:	5c 3b       	neg	r11
8000873a:	32 d8       	mov	r8,45
8000873c:	c0 28       	rjmp	80008740 <_vfprintf_r+0xa58>
8000873e:	32 b8       	mov	r8,43
80008740:	fb 68 06 9d 	st.b	sp[1693],r8
80008744:	58 9b       	cp.w	r11,9
80008746:	e0 8a 00 1d 	brle	80008780 <_vfprintf_r+0xa98>
8000874a:	fa c9 fa 35 	sub	r9,sp,-1483
8000874e:	30 aa       	mov	r10,10
80008750:	12 98       	mov	r8,r9
80008752:	0e 9c       	mov	r12,r7
80008754:	0c 92       	mov	r2,r6
80008756:	f6 0a 0c 06 	divs	r6,r11,r10
8000875a:	0e 9b       	mov	r11,r7
8000875c:	2d 0b       	sub	r11,-48
8000875e:	10 fb       	st.b	--r8,r11
80008760:	0c 9b       	mov	r11,r6
80008762:	58 96       	cp.w	r6,9
80008764:	fe 99 ff f9 	brgt	80008756 <_vfprintf_r+0xa6e>
80008768:	2d 0b       	sub	r11,-48
8000876a:	18 97       	mov	r7,r12
8000876c:	04 96       	mov	r6,r2
8000876e:	10 fb       	st.b	--r8,r11
80008770:	fa ca f9 62 	sub	r10,sp,-1694
80008774:	c0 38       	rjmp	8000877a <_vfprintf_r+0xa92>
80008776:	11 3b       	ld.ub	r11,r8++
80008778:	14 cb       	st.b	r10++,r11
8000877a:	12 38       	cp.w	r8,r9
8000877c:	cf d3       	brcs	80008776 <_vfprintf_r+0xa8e>
8000877e:	c0 98       	rjmp	80008790 <_vfprintf_r+0xaa8>
80008780:	2d 0b       	sub	r11,-48
80008782:	33 08       	mov	r8,48
80008784:	fb 6b 06 9f 	st.b	sp[1695],r11
80008788:	fb 68 06 9e 	st.b	sp[1694],r8
8000878c:	fa ca f9 60 	sub	r10,sp,-1696
80008790:	fa c8 f9 64 	sub	r8,sp,-1692
80008794:	f4 08 01 08 	sub	r8,r10,r8
80008798:	50 e8       	stdsp	sp[0x38],r8
8000879a:	10 92       	mov	r2,r8
8000879c:	40 6b       	lddsp	r11,sp[0x18]
8000879e:	16 02       	add	r2,r11
800087a0:	58 1b       	cp.w	r11,1
800087a2:	e0 89 00 05 	brgt	800087ac <_vfprintf_r+0xac4>
800087a6:	ed b5 00 00 	bld	r5,0x0
800087aa:	c3 51       	brne	80008814 <_vfprintf_r+0xb2c>
800087ac:	2f f2       	sub	r2,-1
800087ae:	c3 38       	rjmp	80008814 <_vfprintf_r+0xb2c>
800087b0:	e0 40 00 66 	cp.w	r0,102
800087b4:	c1 c1       	brne	800087ec <_vfprintf_r+0xb04>
800087b6:	fa f2 06 ac 	ld.w	r2,sp[1708]
800087ba:	58 02       	cp.w	r2,0
800087bc:	e0 8a 00 0c 	brle	800087d4 <_vfprintf_r+0xaec>
800087c0:	40 2a       	lddsp	r10,sp[0x8]
800087c2:	58 0a       	cp.w	r10,0
800087c4:	c0 41       	brne	800087cc <_vfprintf_r+0xae4>
800087c6:	ed b5 00 00 	bld	r5,0x0
800087ca:	c2 51       	brne	80008814 <_vfprintf_r+0xb2c>
800087cc:	2f f2       	sub	r2,-1
800087ce:	40 29       	lddsp	r9,sp[0x8]
800087d0:	12 02       	add	r2,r9
800087d2:	c0 b8       	rjmp	800087e8 <_vfprintf_r+0xb00>
800087d4:	40 28       	lddsp	r8,sp[0x8]
800087d6:	58 08       	cp.w	r8,0
800087d8:	c0 61       	brne	800087e4 <_vfprintf_r+0xafc>
800087da:	ed b5 00 00 	bld	r5,0x0
800087de:	c0 30       	breq	800087e4 <_vfprintf_r+0xafc>
800087e0:	30 12       	mov	r2,1
800087e2:	c1 98       	rjmp	80008814 <_vfprintf_r+0xb2c>
800087e4:	40 22       	lddsp	r2,sp[0x8]
800087e6:	2f e2       	sub	r2,-2
800087e8:	36 60       	mov	r0,102
800087ea:	c1 58       	rjmp	80008814 <_vfprintf_r+0xb2c>
800087ec:	fa f2 06 ac 	ld.w	r2,sp[1708]
800087f0:	40 6e       	lddsp	lr,sp[0x18]
800087f2:	1c 32       	cp.w	r2,lr
800087f4:	c0 65       	brlt	80008800 <_vfprintf_r+0xb18>
800087f6:	ed b5 00 00 	bld	r5,0x0
800087fa:	f7 b2 00 ff 	subeq	r2,-1
800087fe:	c0 a8       	rjmp	80008812 <_vfprintf_r+0xb2a>
80008800:	e4 08 11 02 	rsub	r8,r2,2
80008804:	40 6c       	lddsp	r12,sp[0x18]
80008806:	58 02       	cp.w	r2,0
80008808:	f0 02 17 a0 	movle	r2,r8
8000880c:	f9 b2 09 01 	movgt	r2,1
80008810:	18 02       	add	r2,r12
80008812:	36 70       	mov	r0,103
80008814:	40 9b       	lddsp	r11,sp[0x24]
80008816:	58 0b       	cp.w	r11,0
80008818:	e0 80 05 94 	breq	80009340 <_vfprintf_r+0x1658>
8000881c:	32 d8       	mov	r8,45
8000881e:	fb 68 06 bb 	st.b	sp[1723],r8
80008822:	e0 8f 05 93 	bral	80009348 <_vfprintf_r+0x1660>
80008826:	50 a7       	stdsp	sp[0x28],r7
80008828:	04 94       	mov	r4,r2
8000882a:	0c 97       	mov	r7,r6
8000882c:	02 92       	mov	r2,r1
8000882e:	06 96       	mov	r6,r3
80008830:	40 41       	lddsp	r1,sp[0x10]
80008832:	40 93       	lddsp	r3,sp[0x24]
80008834:	0e 99       	mov	r9,r7
80008836:	ed b5 00 05 	bld	r5,0x5
8000883a:	c4 81       	brne	800088ca <_vfprintf_r+0xbe2>
8000883c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008840:	40 3e       	lddsp	lr,sp[0xc]
80008842:	58 0e       	cp.w	lr,0
80008844:	c1 d0       	breq	8000887e <_vfprintf_r+0xb96>
80008846:	10 36       	cp.w	r6,r8
80008848:	c0 64       	brge	80008854 <_vfprintf_r+0xb6c>
8000884a:	fa cc f9 44 	sub	r12,sp,-1724
8000884e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008852:	c1 d8       	rjmp	8000888c <_vfprintf_r+0xba4>
80008854:	fa c8 f9 50 	sub	r8,sp,-1712
80008858:	1a d8       	st.w	--sp,r8
8000885a:	fa c8 fa b8 	sub	r8,sp,-1352
8000885e:	04 9a       	mov	r10,r2
80008860:	1a d8       	st.w	--sp,r8
80008862:	fa c8 fb b4 	sub	r8,sp,-1100
80008866:	0c 9b       	mov	r11,r6
80008868:	1a d8       	st.w	--sp,r8
8000886a:	08 9c       	mov	r12,r4
8000886c:	fa c8 f9 40 	sub	r8,sp,-1728
80008870:	fa c9 ff b4 	sub	r9,sp,-76
80008874:	fe b0 f8 a2 	rcall	800079b8 <get_arg>
80008878:	2f dd       	sub	sp,-12
8000887a:	78 0a       	ld.w	r10,r12[0x0]
8000887c:	c2 08       	rjmp	800088bc <_vfprintf_r+0xbd4>
8000887e:	2f f7       	sub	r7,-1
80008880:	10 39       	cp.w	r9,r8
80008882:	c0 84       	brge	80008892 <_vfprintf_r+0xbaa>
80008884:	fa cb f9 44 	sub	r11,sp,-1724
80008888:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000888c:	ec fa fd 88 	ld.w	r10,r6[-632]
80008890:	c1 68       	rjmp	800088bc <_vfprintf_r+0xbd4>
80008892:	41 09       	lddsp	r9,sp[0x40]
80008894:	59 f8       	cp.w	r8,31
80008896:	e0 89 00 10 	brgt	800088b6 <_vfprintf_r+0xbce>
8000889a:	f2 ca ff fc 	sub	r10,r9,-4
8000889e:	51 0a       	stdsp	sp[0x40],r10
800088a0:	fa c6 f9 44 	sub	r6,sp,-1724
800088a4:	72 0a       	ld.w	r10,r9[0x0]
800088a6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800088aa:	f3 4a fd 88 	st.w	r9[-632],r10
800088ae:	2f f8       	sub	r8,-1
800088b0:	fb 48 06 b4 	st.w	sp[1716],r8
800088b4:	c0 48       	rjmp	800088bc <_vfprintf_r+0xbd4>
800088b6:	72 0a       	ld.w	r10,r9[0x0]
800088b8:	2f c9       	sub	r9,-4
800088ba:	51 09       	stdsp	sp[0x40],r9
800088bc:	40 be       	lddsp	lr,sp[0x2c]
800088be:	1c 98       	mov	r8,lr
800088c0:	95 1e       	st.w	r10[0x4],lr
800088c2:	bf 58       	asr	r8,0x1f
800088c4:	95 08       	st.w	r10[0x0],r8
800088c6:	fe 9f fa 9f 	bral	80007e04 <_vfprintf_r+0x11c>
800088ca:	ed b5 00 04 	bld	r5,0x4
800088ce:	c4 80       	breq	8000895e <_vfprintf_r+0xc76>
800088d0:	e2 15 00 40 	andl	r5,0x40,COH
800088d4:	c4 50       	breq	8000895e <_vfprintf_r+0xc76>
800088d6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088da:	40 3c       	lddsp	r12,sp[0xc]
800088dc:	58 0c       	cp.w	r12,0
800088de:	c1 d0       	breq	80008918 <_vfprintf_r+0xc30>
800088e0:	10 36       	cp.w	r6,r8
800088e2:	c0 64       	brge	800088ee <_vfprintf_r+0xc06>
800088e4:	fa cb f9 44 	sub	r11,sp,-1724
800088e8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800088ec:	c1 d8       	rjmp	80008926 <_vfprintf_r+0xc3e>
800088ee:	fa c8 f9 50 	sub	r8,sp,-1712
800088f2:	1a d8       	st.w	--sp,r8
800088f4:	fa c8 fa b8 	sub	r8,sp,-1352
800088f8:	04 9a       	mov	r10,r2
800088fa:	1a d8       	st.w	--sp,r8
800088fc:	fa c8 fb b4 	sub	r8,sp,-1100
80008900:	0c 9b       	mov	r11,r6
80008902:	1a d8       	st.w	--sp,r8
80008904:	08 9c       	mov	r12,r4
80008906:	fa c8 f9 40 	sub	r8,sp,-1728
8000890a:	fa c9 ff b4 	sub	r9,sp,-76
8000890e:	fe b0 f8 55 	rcall	800079b8 <get_arg>
80008912:	2f dd       	sub	sp,-12
80008914:	78 0a       	ld.w	r10,r12[0x0]
80008916:	c2 08       	rjmp	80008956 <_vfprintf_r+0xc6e>
80008918:	2f f7       	sub	r7,-1
8000891a:	10 39       	cp.w	r9,r8
8000891c:	c0 84       	brge	8000892c <_vfprintf_r+0xc44>
8000891e:	fa ca f9 44 	sub	r10,sp,-1724
80008922:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008926:	ec fa fd 88 	ld.w	r10,r6[-632]
8000892a:	c1 68       	rjmp	80008956 <_vfprintf_r+0xc6e>
8000892c:	41 09       	lddsp	r9,sp[0x40]
8000892e:	59 f8       	cp.w	r8,31
80008930:	e0 89 00 10 	brgt	80008950 <_vfprintf_r+0xc68>
80008934:	f2 ca ff fc 	sub	r10,r9,-4
80008938:	51 0a       	stdsp	sp[0x40],r10
8000893a:	fa c6 f9 44 	sub	r6,sp,-1724
8000893e:	72 0a       	ld.w	r10,r9[0x0]
80008940:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008944:	f3 4a fd 88 	st.w	r9[-632],r10
80008948:	2f f8       	sub	r8,-1
8000894a:	fb 48 06 b4 	st.w	sp[1716],r8
8000894e:	c0 48       	rjmp	80008956 <_vfprintf_r+0xc6e>
80008950:	72 0a       	ld.w	r10,r9[0x0]
80008952:	2f c9       	sub	r9,-4
80008954:	51 09       	stdsp	sp[0x40],r9
80008956:	40 be       	lddsp	lr,sp[0x2c]
80008958:	b4 0e       	st.h	r10[0x0],lr
8000895a:	fe 9f fa 55 	bral	80007e04 <_vfprintf_r+0x11c>
8000895e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008962:	40 3c       	lddsp	r12,sp[0xc]
80008964:	58 0c       	cp.w	r12,0
80008966:	c1 d0       	breq	800089a0 <_vfprintf_r+0xcb8>
80008968:	10 36       	cp.w	r6,r8
8000896a:	c0 64       	brge	80008976 <_vfprintf_r+0xc8e>
8000896c:	fa cb f9 44 	sub	r11,sp,-1724
80008970:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008974:	c1 d8       	rjmp	800089ae <_vfprintf_r+0xcc6>
80008976:	fa c8 f9 50 	sub	r8,sp,-1712
8000897a:	1a d8       	st.w	--sp,r8
8000897c:	fa c8 fa b8 	sub	r8,sp,-1352
80008980:	04 9a       	mov	r10,r2
80008982:	1a d8       	st.w	--sp,r8
80008984:	fa c8 fb b4 	sub	r8,sp,-1100
80008988:	0c 9b       	mov	r11,r6
8000898a:	1a d8       	st.w	--sp,r8
8000898c:	08 9c       	mov	r12,r4
8000898e:	fa c8 f9 40 	sub	r8,sp,-1728
80008992:	fa c9 ff b4 	sub	r9,sp,-76
80008996:	fe b0 f8 11 	rcall	800079b8 <get_arg>
8000899a:	2f dd       	sub	sp,-12
8000899c:	78 0a       	ld.w	r10,r12[0x0]
8000899e:	c2 08       	rjmp	800089de <_vfprintf_r+0xcf6>
800089a0:	2f f7       	sub	r7,-1
800089a2:	10 39       	cp.w	r9,r8
800089a4:	c0 84       	brge	800089b4 <_vfprintf_r+0xccc>
800089a6:	fa ca f9 44 	sub	r10,sp,-1724
800089aa:	f4 06 00 36 	add	r6,r10,r6<<0x3
800089ae:	ec fa fd 88 	ld.w	r10,r6[-632]
800089b2:	c1 68       	rjmp	800089de <_vfprintf_r+0xcf6>
800089b4:	41 09       	lddsp	r9,sp[0x40]
800089b6:	59 f8       	cp.w	r8,31
800089b8:	e0 89 00 10 	brgt	800089d8 <_vfprintf_r+0xcf0>
800089bc:	f2 ca ff fc 	sub	r10,r9,-4
800089c0:	51 0a       	stdsp	sp[0x40],r10
800089c2:	fa c6 f9 44 	sub	r6,sp,-1724
800089c6:	72 0a       	ld.w	r10,r9[0x0]
800089c8:	ec 08 00 39 	add	r9,r6,r8<<0x3
800089cc:	f3 4a fd 88 	st.w	r9[-632],r10
800089d0:	2f f8       	sub	r8,-1
800089d2:	fb 48 06 b4 	st.w	sp[1716],r8
800089d6:	c0 48       	rjmp	800089de <_vfprintf_r+0xcf6>
800089d8:	72 0a       	ld.w	r10,r9[0x0]
800089da:	2f c9       	sub	r9,-4
800089dc:	51 09       	stdsp	sp[0x40],r9
800089de:	40 be       	lddsp	lr,sp[0x2c]
800089e0:	95 0e       	st.w	r10[0x0],lr
800089e2:	fe 9f fa 11 	bral	80007e04 <_vfprintf_r+0x11c>
800089e6:	50 a7       	stdsp	sp[0x28],r7
800089e8:	50 80       	stdsp	sp[0x20],r0
800089ea:	0c 97       	mov	r7,r6
800089ec:	04 94       	mov	r4,r2
800089ee:	06 96       	mov	r6,r3
800089f0:	02 92       	mov	r2,r1
800089f2:	40 93       	lddsp	r3,sp[0x24]
800089f4:	10 90       	mov	r0,r8
800089f6:	40 41       	lddsp	r1,sp[0x10]
800089f8:	a5 a5       	sbr	r5,0x4
800089fa:	c0 a8       	rjmp	80008a0e <_vfprintf_r+0xd26>
800089fc:	50 a7       	stdsp	sp[0x28],r7
800089fe:	50 80       	stdsp	sp[0x20],r0
80008a00:	0c 97       	mov	r7,r6
80008a02:	04 94       	mov	r4,r2
80008a04:	06 96       	mov	r6,r3
80008a06:	02 92       	mov	r2,r1
80008a08:	40 93       	lddsp	r3,sp[0x24]
80008a0a:	10 90       	mov	r0,r8
80008a0c:	40 41       	lddsp	r1,sp[0x10]
80008a0e:	ed b5 00 05 	bld	r5,0x5
80008a12:	c5 d1       	brne	80008acc <_vfprintf_r+0xde4>
80008a14:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a18:	40 3c       	lddsp	r12,sp[0xc]
80008a1a:	58 0c       	cp.w	r12,0
80008a1c:	c2 60       	breq	80008a68 <_vfprintf_r+0xd80>
80008a1e:	10 36       	cp.w	r6,r8
80008a20:	c0 a4       	brge	80008a34 <_vfprintf_r+0xd4c>
80008a22:	fa cb f9 44 	sub	r11,sp,-1724
80008a26:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a2a:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008a2e:	fa e9 00 00 	st.d	sp[0],r8
80008a32:	c1 88       	rjmp	80008a62 <_vfprintf_r+0xd7a>
80008a34:	fa c8 f9 50 	sub	r8,sp,-1712
80008a38:	1a d8       	st.w	--sp,r8
80008a3a:	fa c8 fa b8 	sub	r8,sp,-1352
80008a3e:	04 9a       	mov	r10,r2
80008a40:	1a d8       	st.w	--sp,r8
80008a42:	0c 9b       	mov	r11,r6
80008a44:	fa c8 fb b4 	sub	r8,sp,-1100
80008a48:	08 9c       	mov	r12,r4
80008a4a:	1a d8       	st.w	--sp,r8
80008a4c:	fa c8 f9 40 	sub	r8,sp,-1728
80008a50:	fa c9 ff b4 	sub	r9,sp,-76
80008a54:	fe b0 f7 b2 	rcall	800079b8 <get_arg>
80008a58:	2f dd       	sub	sp,-12
80008a5a:	f8 ea 00 00 	ld.d	r10,r12[0]
80008a5e:	fa eb 00 00 	st.d	sp[0],r10
80008a62:	30 08       	mov	r8,0
80008a64:	e0 8f 03 de 	bral	80009220 <_vfprintf_r+0x1538>
80008a68:	ee ca ff ff 	sub	r10,r7,-1
80008a6c:	10 37       	cp.w	r7,r8
80008a6e:	c0 b4       	brge	80008a84 <_vfprintf_r+0xd9c>
80008a70:	fa c9 f9 44 	sub	r9,sp,-1724
80008a74:	14 97       	mov	r7,r10
80008a76:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008a7a:	ec ea fd 88 	ld.d	r10,r6[-632]
80008a7e:	fa eb 00 00 	st.d	sp[0],r10
80008a82:	c1 88       	rjmp	80008ab2 <_vfprintf_r+0xdca>
80008a84:	41 09       	lddsp	r9,sp[0x40]
80008a86:	59 f8       	cp.w	r8,31
80008a88:	e0 89 00 18 	brgt	80008ab8 <_vfprintf_r+0xdd0>
80008a8c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008a90:	f2 cb ff f8 	sub	r11,r9,-8
80008a94:	fa e7 00 00 	st.d	sp[0],r6
80008a98:	51 0b       	stdsp	sp[0x40],r11
80008a9a:	fa c6 f9 44 	sub	r6,sp,-1724
80008a9e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008aa2:	fa e6 00 00 	ld.d	r6,sp[0]
80008aa6:	f2 e7 fd 88 	st.d	r9[-632],r6
80008aaa:	2f f8       	sub	r8,-1
80008aac:	14 97       	mov	r7,r10
80008aae:	fb 48 06 b4 	st.w	sp[1716],r8
80008ab2:	40 38       	lddsp	r8,sp[0xc]
80008ab4:	e0 8f 03 b6 	bral	80009220 <_vfprintf_r+0x1538>
80008ab8:	f2 e6 00 00 	ld.d	r6,r9[0]
80008abc:	40 38       	lddsp	r8,sp[0xc]
80008abe:	fa e7 00 00 	st.d	sp[0],r6
80008ac2:	2f 89       	sub	r9,-8
80008ac4:	14 97       	mov	r7,r10
80008ac6:	51 09       	stdsp	sp[0x40],r9
80008ac8:	e0 8f 03 ac 	bral	80009220 <_vfprintf_r+0x1538>
80008acc:	ed b5 00 04 	bld	r5,0x4
80008ad0:	c1 61       	brne	80008afc <_vfprintf_r+0xe14>
80008ad2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ad6:	40 3e       	lddsp	lr,sp[0xc]
80008ad8:	58 0e       	cp.w	lr,0
80008ada:	c0 80       	breq	80008aea <_vfprintf_r+0xe02>
80008adc:	10 36       	cp.w	r6,r8
80008ade:	c6 74       	brge	80008bac <_vfprintf_r+0xec4>
80008ae0:	fa cc f9 44 	sub	r12,sp,-1724
80008ae4:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008ae8:	c8 08       	rjmp	80008be8 <_vfprintf_r+0xf00>
80008aea:	ee ca ff ff 	sub	r10,r7,-1
80008aee:	10 37       	cp.w	r7,r8
80008af0:	c7 f4       	brge	80008bee <_vfprintf_r+0xf06>
80008af2:	fa cb f9 44 	sub	r11,sp,-1724
80008af6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008afa:	c7 68       	rjmp	80008be6 <_vfprintf_r+0xefe>
80008afc:	ed b5 00 06 	bld	r5,0x6
80008b00:	c4 a1       	brne	80008b94 <_vfprintf_r+0xeac>
80008b02:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b06:	40 3c       	lddsp	r12,sp[0xc]
80008b08:	58 0c       	cp.w	r12,0
80008b0a:	c1 d0       	breq	80008b44 <_vfprintf_r+0xe5c>
80008b0c:	10 36       	cp.w	r6,r8
80008b0e:	c0 64       	brge	80008b1a <_vfprintf_r+0xe32>
80008b10:	fa cb f9 44 	sub	r11,sp,-1724
80008b14:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b18:	c1 f8       	rjmp	80008b56 <_vfprintf_r+0xe6e>
80008b1a:	fa c8 f9 50 	sub	r8,sp,-1712
80008b1e:	1a d8       	st.w	--sp,r8
80008b20:	fa c8 fa b8 	sub	r8,sp,-1352
80008b24:	1a d8       	st.w	--sp,r8
80008b26:	fa c8 fb b4 	sub	r8,sp,-1100
80008b2a:	1a d8       	st.w	--sp,r8
80008b2c:	fa c8 f9 40 	sub	r8,sp,-1728
80008b30:	fa c9 ff b4 	sub	r9,sp,-76
80008b34:	04 9a       	mov	r10,r2
80008b36:	0c 9b       	mov	r11,r6
80008b38:	08 9c       	mov	r12,r4
80008b3a:	fe b0 f7 3f 	rcall	800079b8 <get_arg>
80008b3e:	2f dd       	sub	sp,-12
80008b40:	98 18       	ld.sh	r8,r12[0x2]
80008b42:	c2 68       	rjmp	80008b8e <_vfprintf_r+0xea6>
80008b44:	ee ca ff ff 	sub	r10,r7,-1
80008b48:	10 37       	cp.w	r7,r8
80008b4a:	c0 94       	brge	80008b5c <_vfprintf_r+0xe74>
80008b4c:	fa c9 f9 44 	sub	r9,sp,-1724
80008b50:	14 97       	mov	r7,r10
80008b52:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008b56:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008b5a:	c1 a8       	rjmp	80008b8e <_vfprintf_r+0xea6>
80008b5c:	41 09       	lddsp	r9,sp[0x40]
80008b5e:	59 f8       	cp.w	r8,31
80008b60:	e0 89 00 13 	brgt	80008b86 <_vfprintf_r+0xe9e>
80008b64:	f2 cb ff fc 	sub	r11,r9,-4
80008b68:	51 0b       	stdsp	sp[0x40],r11
80008b6a:	72 09       	ld.w	r9,r9[0x0]
80008b6c:	fa c6 f9 44 	sub	r6,sp,-1724
80008b70:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008b74:	2f f8       	sub	r8,-1
80008b76:	f7 49 fd 88 	st.w	r11[-632],r9
80008b7a:	fb 48 06 b4 	st.w	sp[1716],r8
80008b7e:	14 97       	mov	r7,r10
80008b80:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008b84:	c0 58       	rjmp	80008b8e <_vfprintf_r+0xea6>
80008b86:	92 18       	ld.sh	r8,r9[0x2]
80008b88:	14 97       	mov	r7,r10
80008b8a:	2f c9       	sub	r9,-4
80008b8c:	51 09       	stdsp	sp[0x40],r9
80008b8e:	5c 78       	castu.h	r8
80008b90:	50 18       	stdsp	sp[0x4],r8
80008b92:	c4 68       	rjmp	80008c1e <_vfprintf_r+0xf36>
80008b94:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b98:	40 3c       	lddsp	r12,sp[0xc]
80008b9a:	58 0c       	cp.w	r12,0
80008b9c:	c1 d0       	breq	80008bd6 <_vfprintf_r+0xeee>
80008b9e:	10 36       	cp.w	r6,r8
80008ba0:	c0 64       	brge	80008bac <_vfprintf_r+0xec4>
80008ba2:	fa cb f9 44 	sub	r11,sp,-1724
80008ba6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008baa:	c1 f8       	rjmp	80008be8 <_vfprintf_r+0xf00>
80008bac:	fa c8 f9 50 	sub	r8,sp,-1712
80008bb0:	1a d8       	st.w	--sp,r8
80008bb2:	fa c8 fa b8 	sub	r8,sp,-1352
80008bb6:	0c 9b       	mov	r11,r6
80008bb8:	1a d8       	st.w	--sp,r8
80008bba:	fa c8 fb b4 	sub	r8,sp,-1100
80008bbe:	04 9a       	mov	r10,r2
80008bc0:	1a d8       	st.w	--sp,r8
80008bc2:	08 9c       	mov	r12,r4
80008bc4:	fa c8 f9 40 	sub	r8,sp,-1728
80008bc8:	fa c9 ff b4 	sub	r9,sp,-76
80008bcc:	fe b0 f6 f6 	rcall	800079b8 <get_arg>
80008bd0:	2f dd       	sub	sp,-12
80008bd2:	78 0b       	ld.w	r11,r12[0x0]
80008bd4:	c2 48       	rjmp	80008c1c <_vfprintf_r+0xf34>
80008bd6:	ee ca ff ff 	sub	r10,r7,-1
80008bda:	10 37       	cp.w	r7,r8
80008bdc:	c0 94       	brge	80008bee <_vfprintf_r+0xf06>
80008bde:	fa c9 f9 44 	sub	r9,sp,-1724
80008be2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008be6:	14 97       	mov	r7,r10
80008be8:	ec fb fd 88 	ld.w	r11,r6[-632]
80008bec:	c1 88       	rjmp	80008c1c <_vfprintf_r+0xf34>
80008bee:	41 09       	lddsp	r9,sp[0x40]
80008bf0:	59 f8       	cp.w	r8,31
80008bf2:	e0 89 00 11 	brgt	80008c14 <_vfprintf_r+0xf2c>
80008bf6:	f2 cb ff fc 	sub	r11,r9,-4
80008bfa:	51 0b       	stdsp	sp[0x40],r11
80008bfc:	fa c6 f9 44 	sub	r6,sp,-1724
80008c00:	72 0b       	ld.w	r11,r9[0x0]
80008c02:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c06:	f3 4b fd 88 	st.w	r9[-632],r11
80008c0a:	2f f8       	sub	r8,-1
80008c0c:	14 97       	mov	r7,r10
80008c0e:	fb 48 06 b4 	st.w	sp[1716],r8
80008c12:	c0 58       	rjmp	80008c1c <_vfprintf_r+0xf34>
80008c14:	72 0b       	ld.w	r11,r9[0x0]
80008c16:	14 97       	mov	r7,r10
80008c18:	2f c9       	sub	r9,-4
80008c1a:	51 09       	stdsp	sp[0x40],r9
80008c1c:	50 1b       	stdsp	sp[0x4],r11
80008c1e:	30 0e       	mov	lr,0
80008c20:	50 0e       	stdsp	sp[0x0],lr
80008c22:	1c 98       	mov	r8,lr
80008c24:	e0 8f 02 fe 	bral	80009220 <_vfprintf_r+0x1538>
80008c28:	50 a7       	stdsp	sp[0x28],r7
80008c2a:	50 80       	stdsp	sp[0x20],r0
80008c2c:	0c 97       	mov	r7,r6
80008c2e:	04 94       	mov	r4,r2
80008c30:	06 96       	mov	r6,r3
80008c32:	02 92       	mov	r2,r1
80008c34:	40 93       	lddsp	r3,sp[0x24]
80008c36:	40 41       	lddsp	r1,sp[0x10]
80008c38:	0e 99       	mov	r9,r7
80008c3a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c3e:	40 3c       	lddsp	r12,sp[0xc]
80008c40:	58 0c       	cp.w	r12,0
80008c42:	c1 d0       	breq	80008c7c <_vfprintf_r+0xf94>
80008c44:	10 36       	cp.w	r6,r8
80008c46:	c0 64       	brge	80008c52 <_vfprintf_r+0xf6a>
80008c48:	fa cb f9 44 	sub	r11,sp,-1724
80008c4c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c50:	c1 d8       	rjmp	80008c8a <_vfprintf_r+0xfa2>
80008c52:	fa c8 f9 50 	sub	r8,sp,-1712
80008c56:	1a d8       	st.w	--sp,r8
80008c58:	fa c8 fa b8 	sub	r8,sp,-1352
80008c5c:	1a d8       	st.w	--sp,r8
80008c5e:	fa c8 fb b4 	sub	r8,sp,-1100
80008c62:	1a d8       	st.w	--sp,r8
80008c64:	fa c9 ff b4 	sub	r9,sp,-76
80008c68:	fa c8 f9 40 	sub	r8,sp,-1728
80008c6c:	04 9a       	mov	r10,r2
80008c6e:	0c 9b       	mov	r11,r6
80008c70:	08 9c       	mov	r12,r4
80008c72:	fe b0 f6 a3 	rcall	800079b8 <get_arg>
80008c76:	2f dd       	sub	sp,-12
80008c78:	78 09       	ld.w	r9,r12[0x0]
80008c7a:	c2 18       	rjmp	80008cbc <_vfprintf_r+0xfd4>
80008c7c:	2f f7       	sub	r7,-1
80008c7e:	10 39       	cp.w	r9,r8
80008c80:	c0 84       	brge	80008c90 <_vfprintf_r+0xfa8>
80008c82:	fa ca f9 44 	sub	r10,sp,-1724
80008c86:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008c8a:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008c8e:	c1 78       	rjmp	80008cbc <_vfprintf_r+0xfd4>
80008c90:	41 09       	lddsp	r9,sp[0x40]
80008c92:	59 f8       	cp.w	r8,31
80008c94:	e0 89 00 10 	brgt	80008cb4 <_vfprintf_r+0xfcc>
80008c98:	f2 ca ff fc 	sub	r10,r9,-4
80008c9c:	51 0a       	stdsp	sp[0x40],r10
80008c9e:	fa c6 f9 44 	sub	r6,sp,-1724
80008ca2:	72 09       	ld.w	r9,r9[0x0]
80008ca4:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008ca8:	f5 49 fd 88 	st.w	r10[-632],r9
80008cac:	2f f8       	sub	r8,-1
80008cae:	fb 48 06 b4 	st.w	sp[1716],r8
80008cb2:	c0 58       	rjmp	80008cbc <_vfprintf_r+0xfd4>
80008cb4:	f2 c8 ff fc 	sub	r8,r9,-4
80008cb8:	51 08       	stdsp	sp[0x40],r8
80008cba:	72 09       	ld.w	r9,r9[0x0]
80008cbc:	33 08       	mov	r8,48
80008cbe:	fb 68 06 b8 	st.b	sp[1720],r8
80008cc2:	37 88       	mov	r8,120
80008cc4:	30 0e       	mov	lr,0
80008cc6:	fb 68 06 b9 	st.b	sp[1721],r8
80008cca:	fe cc c2 96 	sub	r12,pc,-15722
80008cce:	50 19       	stdsp	sp[0x4],r9
80008cd0:	a1 b5       	sbr	r5,0x1
80008cd2:	50 0e       	stdsp	sp[0x0],lr
80008cd4:	50 dc       	stdsp	sp[0x34],r12
80008cd6:	30 28       	mov	r8,2
80008cd8:	37 80       	mov	r0,120
80008cda:	e0 8f 02 a3 	bral	80009220 <_vfprintf_r+0x1538>
80008cde:	50 a7       	stdsp	sp[0x28],r7
80008ce0:	50 80       	stdsp	sp[0x20],r0
80008ce2:	10 90       	mov	r0,r8
80008ce4:	30 08       	mov	r8,0
80008ce6:	fb 68 06 bb 	st.b	sp[1723],r8
80008cea:	0c 97       	mov	r7,r6
80008cec:	04 94       	mov	r4,r2
80008cee:	06 96       	mov	r6,r3
80008cf0:	02 92       	mov	r2,r1
80008cf2:	40 93       	lddsp	r3,sp[0x24]
80008cf4:	40 41       	lddsp	r1,sp[0x10]
80008cf6:	0e 99       	mov	r9,r7
80008cf8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cfc:	40 3b       	lddsp	r11,sp[0xc]
80008cfe:	58 0b       	cp.w	r11,0
80008d00:	c1 d0       	breq	80008d3a <_vfprintf_r+0x1052>
80008d02:	10 36       	cp.w	r6,r8
80008d04:	c0 64       	brge	80008d10 <_vfprintf_r+0x1028>
80008d06:	fa ca f9 44 	sub	r10,sp,-1724
80008d0a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d0e:	c1 d8       	rjmp	80008d48 <_vfprintf_r+0x1060>
80008d10:	fa c8 f9 50 	sub	r8,sp,-1712
80008d14:	1a d8       	st.w	--sp,r8
80008d16:	fa c8 fa b8 	sub	r8,sp,-1352
80008d1a:	1a d8       	st.w	--sp,r8
80008d1c:	fa c8 fb b4 	sub	r8,sp,-1100
80008d20:	0c 9b       	mov	r11,r6
80008d22:	1a d8       	st.w	--sp,r8
80008d24:	04 9a       	mov	r10,r2
80008d26:	fa c8 f9 40 	sub	r8,sp,-1728
80008d2a:	fa c9 ff b4 	sub	r9,sp,-76
80008d2e:	08 9c       	mov	r12,r4
80008d30:	fe b0 f6 44 	rcall	800079b8 <get_arg>
80008d34:	2f dd       	sub	sp,-12
80008d36:	78 06       	ld.w	r6,r12[0x0]
80008d38:	c2 08       	rjmp	80008d78 <_vfprintf_r+0x1090>
80008d3a:	2f f7       	sub	r7,-1
80008d3c:	10 39       	cp.w	r9,r8
80008d3e:	c0 84       	brge	80008d4e <_vfprintf_r+0x1066>
80008d40:	fa c9 f9 44 	sub	r9,sp,-1724
80008d44:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d48:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008d4c:	c1 68       	rjmp	80008d78 <_vfprintf_r+0x1090>
80008d4e:	41 09       	lddsp	r9,sp[0x40]
80008d50:	59 f8       	cp.w	r8,31
80008d52:	e0 89 00 10 	brgt	80008d72 <_vfprintf_r+0x108a>
80008d56:	f2 ca ff fc 	sub	r10,r9,-4
80008d5a:	51 0a       	stdsp	sp[0x40],r10
80008d5c:	72 06       	ld.w	r6,r9[0x0]
80008d5e:	fa ce f9 44 	sub	lr,sp,-1724
80008d62:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008d66:	f3 46 fd 88 	st.w	r9[-632],r6
80008d6a:	2f f8       	sub	r8,-1
80008d6c:	fb 48 06 b4 	st.w	sp[1716],r8
80008d70:	c0 48       	rjmp	80008d78 <_vfprintf_r+0x1090>
80008d72:	72 06       	ld.w	r6,r9[0x0]
80008d74:	2f c9       	sub	r9,-4
80008d76:	51 09       	stdsp	sp[0x40],r9
80008d78:	40 2c       	lddsp	r12,sp[0x8]
80008d7a:	58 0c       	cp.w	r12,0
80008d7c:	c1 05       	brlt	80008d9c <_vfprintf_r+0x10b4>
80008d7e:	18 9a       	mov	r10,r12
80008d80:	30 0b       	mov	r11,0
80008d82:	0c 9c       	mov	r12,r6
80008d84:	e0 a0 10 fa 	rcall	8000af78 <memchr>
80008d88:	e0 80 02 df 	breq	80009346 <_vfprintf_r+0x165e>
80008d8c:	f8 06 01 02 	sub	r2,r12,r6
80008d90:	40 2b       	lddsp	r11,sp[0x8]
80008d92:	16 32       	cp.w	r2,r11
80008d94:	e0 89 02 d9 	brgt	80009346 <_vfprintf_r+0x165e>
80008d98:	e0 8f 02 d4 	bral	80009340 <_vfprintf_r+0x1658>
80008d9c:	30 0a       	mov	r10,0
80008d9e:	0c 9c       	mov	r12,r6
80008da0:	50 2a       	stdsp	sp[0x8],r10
80008da2:	e0 a0 14 18 	rcall	8000b5d2 <strlen>
80008da6:	18 92       	mov	r2,r12
80008da8:	e0 8f 02 d2 	bral	8000934c <_vfprintf_r+0x1664>
80008dac:	50 a7       	stdsp	sp[0x28],r7
80008dae:	50 80       	stdsp	sp[0x20],r0
80008db0:	0c 97       	mov	r7,r6
80008db2:	04 94       	mov	r4,r2
80008db4:	06 96       	mov	r6,r3
80008db6:	02 92       	mov	r2,r1
80008db8:	40 93       	lddsp	r3,sp[0x24]
80008dba:	10 90       	mov	r0,r8
80008dbc:	40 41       	lddsp	r1,sp[0x10]
80008dbe:	a5 a5       	sbr	r5,0x4
80008dc0:	c0 a8       	rjmp	80008dd4 <_vfprintf_r+0x10ec>
80008dc2:	50 a7       	stdsp	sp[0x28],r7
80008dc4:	50 80       	stdsp	sp[0x20],r0
80008dc6:	0c 97       	mov	r7,r6
80008dc8:	04 94       	mov	r4,r2
80008dca:	06 96       	mov	r6,r3
80008dcc:	02 92       	mov	r2,r1
80008dce:	40 93       	lddsp	r3,sp[0x24]
80008dd0:	10 90       	mov	r0,r8
80008dd2:	40 41       	lddsp	r1,sp[0x10]
80008dd4:	ed b5 00 05 	bld	r5,0x5
80008dd8:	c5 61       	brne	80008e84 <_vfprintf_r+0x119c>
80008dda:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008dde:	40 39       	lddsp	r9,sp[0xc]
80008de0:	58 09       	cp.w	r9,0
80008de2:	c2 10       	breq	80008e24 <_vfprintf_r+0x113c>
80008de4:	10 36       	cp.w	r6,r8
80008de6:	c0 74       	brge	80008df4 <_vfprintf_r+0x110c>
80008de8:	fa c8 f9 44 	sub	r8,sp,-1724
80008dec:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008df0:	c2 38       	rjmp	80008e36 <_vfprintf_r+0x114e>
80008df2:	d7 03       	nop
80008df4:	fa c8 f9 50 	sub	r8,sp,-1712
80008df8:	1a d8       	st.w	--sp,r8
80008dfa:	fa c8 fa b8 	sub	r8,sp,-1352
80008dfe:	1a d8       	st.w	--sp,r8
80008e00:	fa c8 fb b4 	sub	r8,sp,-1100
80008e04:	1a d8       	st.w	--sp,r8
80008e06:	fa c8 f9 40 	sub	r8,sp,-1728
80008e0a:	fa c9 ff b4 	sub	r9,sp,-76
80008e0e:	04 9a       	mov	r10,r2
80008e10:	0c 9b       	mov	r11,r6
80008e12:	08 9c       	mov	r12,r4
80008e14:	fe b0 f5 d2 	rcall	800079b8 <get_arg>
80008e18:	2f dd       	sub	sp,-12
80008e1a:	f8 e8 00 00 	ld.d	r8,r12[0]
80008e1e:	fa e9 00 00 	st.d	sp[0],r8
80008e22:	c2 e8       	rjmp	80008e7e <_vfprintf_r+0x1196>
80008e24:	ee ca ff ff 	sub	r10,r7,-1
80008e28:	10 37       	cp.w	r7,r8
80008e2a:	c0 b4       	brge	80008e40 <_vfprintf_r+0x1158>
80008e2c:	fa c8 f9 44 	sub	r8,sp,-1724
80008e30:	14 97       	mov	r7,r10
80008e32:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008e36:	ec ea fd 88 	ld.d	r10,r6[-632]
80008e3a:	fa eb 00 00 	st.d	sp[0],r10
80008e3e:	c2 08       	rjmp	80008e7e <_vfprintf_r+0x1196>
80008e40:	41 09       	lddsp	r9,sp[0x40]
80008e42:	59 f8       	cp.w	r8,31
80008e44:	e0 89 00 16 	brgt	80008e70 <_vfprintf_r+0x1188>
80008e48:	f2 e6 00 00 	ld.d	r6,r9[0]
80008e4c:	f2 cb ff f8 	sub	r11,r9,-8
80008e50:	fa e7 00 00 	st.d	sp[0],r6
80008e54:	51 0b       	stdsp	sp[0x40],r11
80008e56:	fa c6 f9 44 	sub	r6,sp,-1724
80008e5a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e5e:	fa e6 00 00 	ld.d	r6,sp[0]
80008e62:	f2 e7 fd 88 	st.d	r9[-632],r6
80008e66:	2f f8       	sub	r8,-1
80008e68:	14 97       	mov	r7,r10
80008e6a:	fb 48 06 b4 	st.w	sp[1716],r8
80008e6e:	c0 88       	rjmp	80008e7e <_vfprintf_r+0x1196>
80008e70:	f2 e6 00 00 	ld.d	r6,r9[0]
80008e74:	2f 89       	sub	r9,-8
80008e76:	fa e7 00 00 	st.d	sp[0],r6
80008e7a:	51 09       	stdsp	sp[0x40],r9
80008e7c:	14 97       	mov	r7,r10
80008e7e:	30 18       	mov	r8,1
80008e80:	e0 8f 01 d0 	bral	80009220 <_vfprintf_r+0x1538>
80008e84:	ed b5 00 04 	bld	r5,0x4
80008e88:	c1 61       	brne	80008eb4 <_vfprintf_r+0x11cc>
80008e8a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e8e:	40 3e       	lddsp	lr,sp[0xc]
80008e90:	58 0e       	cp.w	lr,0
80008e92:	c0 80       	breq	80008ea2 <_vfprintf_r+0x11ba>
80008e94:	10 36       	cp.w	r6,r8
80008e96:	c6 74       	brge	80008f64 <_vfprintf_r+0x127c>
80008e98:	fa cc f9 44 	sub	r12,sp,-1724
80008e9c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008ea0:	c8 08       	rjmp	80008fa0 <_vfprintf_r+0x12b8>
80008ea2:	ee ca ff ff 	sub	r10,r7,-1
80008ea6:	10 37       	cp.w	r7,r8
80008ea8:	c7 f4       	brge	80008fa6 <_vfprintf_r+0x12be>
80008eaa:	fa cb f9 44 	sub	r11,sp,-1724
80008eae:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008eb2:	c7 68       	rjmp	80008f9e <_vfprintf_r+0x12b6>
80008eb4:	ed b5 00 06 	bld	r5,0x6
80008eb8:	c4 a1       	brne	80008f4c <_vfprintf_r+0x1264>
80008eba:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ebe:	40 3c       	lddsp	r12,sp[0xc]
80008ec0:	58 0c       	cp.w	r12,0
80008ec2:	c1 d0       	breq	80008efc <_vfprintf_r+0x1214>
80008ec4:	10 36       	cp.w	r6,r8
80008ec6:	c0 64       	brge	80008ed2 <_vfprintf_r+0x11ea>
80008ec8:	fa cb f9 44 	sub	r11,sp,-1724
80008ecc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ed0:	c1 f8       	rjmp	80008f0e <_vfprintf_r+0x1226>
80008ed2:	fa c8 f9 50 	sub	r8,sp,-1712
80008ed6:	1a d8       	st.w	--sp,r8
80008ed8:	fa c8 fa b8 	sub	r8,sp,-1352
80008edc:	1a d8       	st.w	--sp,r8
80008ede:	fa c8 fb b4 	sub	r8,sp,-1100
80008ee2:	1a d8       	st.w	--sp,r8
80008ee4:	fa c8 f9 40 	sub	r8,sp,-1728
80008ee8:	fa c9 ff b4 	sub	r9,sp,-76
80008eec:	04 9a       	mov	r10,r2
80008eee:	0c 9b       	mov	r11,r6
80008ef0:	08 9c       	mov	r12,r4
80008ef2:	fe b0 f5 63 	rcall	800079b8 <get_arg>
80008ef6:	2f dd       	sub	sp,-12
80008ef8:	98 18       	ld.sh	r8,r12[0x2]
80008efa:	c2 68       	rjmp	80008f46 <_vfprintf_r+0x125e>
80008efc:	ee ca ff ff 	sub	r10,r7,-1
80008f00:	10 37       	cp.w	r7,r8
80008f02:	c0 94       	brge	80008f14 <_vfprintf_r+0x122c>
80008f04:	fa c9 f9 44 	sub	r9,sp,-1724
80008f08:	14 97       	mov	r7,r10
80008f0a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f0e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008f12:	c1 a8       	rjmp	80008f46 <_vfprintf_r+0x125e>
80008f14:	41 09       	lddsp	r9,sp[0x40]
80008f16:	59 f8       	cp.w	r8,31
80008f18:	e0 89 00 13 	brgt	80008f3e <_vfprintf_r+0x1256>
80008f1c:	f2 cb ff fc 	sub	r11,r9,-4
80008f20:	51 0b       	stdsp	sp[0x40],r11
80008f22:	72 09       	ld.w	r9,r9[0x0]
80008f24:	fa c6 f9 44 	sub	r6,sp,-1724
80008f28:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008f2c:	2f f8       	sub	r8,-1
80008f2e:	f7 49 fd 88 	st.w	r11[-632],r9
80008f32:	fb 48 06 b4 	st.w	sp[1716],r8
80008f36:	14 97       	mov	r7,r10
80008f38:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008f3c:	c0 58       	rjmp	80008f46 <_vfprintf_r+0x125e>
80008f3e:	92 18       	ld.sh	r8,r9[0x2]
80008f40:	14 97       	mov	r7,r10
80008f42:	2f c9       	sub	r9,-4
80008f44:	51 09       	stdsp	sp[0x40],r9
80008f46:	5c 78       	castu.h	r8
80008f48:	50 18       	stdsp	sp[0x4],r8
80008f4a:	c4 68       	rjmp	80008fd6 <_vfprintf_r+0x12ee>
80008f4c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f50:	40 3c       	lddsp	r12,sp[0xc]
80008f52:	58 0c       	cp.w	r12,0
80008f54:	c1 d0       	breq	80008f8e <_vfprintf_r+0x12a6>
80008f56:	10 36       	cp.w	r6,r8
80008f58:	c0 64       	brge	80008f64 <_vfprintf_r+0x127c>
80008f5a:	fa cb f9 44 	sub	r11,sp,-1724
80008f5e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f62:	c1 f8       	rjmp	80008fa0 <_vfprintf_r+0x12b8>
80008f64:	fa c8 f9 50 	sub	r8,sp,-1712
80008f68:	1a d8       	st.w	--sp,r8
80008f6a:	fa c8 fa b8 	sub	r8,sp,-1352
80008f6e:	0c 9b       	mov	r11,r6
80008f70:	1a d8       	st.w	--sp,r8
80008f72:	fa c8 fb b4 	sub	r8,sp,-1100
80008f76:	04 9a       	mov	r10,r2
80008f78:	1a d8       	st.w	--sp,r8
80008f7a:	08 9c       	mov	r12,r4
80008f7c:	fa c8 f9 40 	sub	r8,sp,-1728
80008f80:	fa c9 ff b4 	sub	r9,sp,-76
80008f84:	fe b0 f5 1a 	rcall	800079b8 <get_arg>
80008f88:	2f dd       	sub	sp,-12
80008f8a:	78 0b       	ld.w	r11,r12[0x0]
80008f8c:	c2 48       	rjmp	80008fd4 <_vfprintf_r+0x12ec>
80008f8e:	ee ca ff ff 	sub	r10,r7,-1
80008f92:	10 37       	cp.w	r7,r8
80008f94:	c0 94       	brge	80008fa6 <_vfprintf_r+0x12be>
80008f96:	fa c9 f9 44 	sub	r9,sp,-1724
80008f9a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f9e:	14 97       	mov	r7,r10
80008fa0:	ec fb fd 88 	ld.w	r11,r6[-632]
80008fa4:	c1 88       	rjmp	80008fd4 <_vfprintf_r+0x12ec>
80008fa6:	41 09       	lddsp	r9,sp[0x40]
80008fa8:	59 f8       	cp.w	r8,31
80008faa:	e0 89 00 11 	brgt	80008fcc <_vfprintf_r+0x12e4>
80008fae:	f2 cb ff fc 	sub	r11,r9,-4
80008fb2:	51 0b       	stdsp	sp[0x40],r11
80008fb4:	fa c6 f9 44 	sub	r6,sp,-1724
80008fb8:	72 0b       	ld.w	r11,r9[0x0]
80008fba:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008fbe:	f3 4b fd 88 	st.w	r9[-632],r11
80008fc2:	2f f8       	sub	r8,-1
80008fc4:	14 97       	mov	r7,r10
80008fc6:	fb 48 06 b4 	st.w	sp[1716],r8
80008fca:	c0 58       	rjmp	80008fd4 <_vfprintf_r+0x12ec>
80008fcc:	72 0b       	ld.w	r11,r9[0x0]
80008fce:	14 97       	mov	r7,r10
80008fd0:	2f c9       	sub	r9,-4
80008fd2:	51 09       	stdsp	sp[0x40],r9
80008fd4:	50 1b       	stdsp	sp[0x4],r11
80008fd6:	30 0e       	mov	lr,0
80008fd8:	30 18       	mov	r8,1
80008fda:	50 0e       	stdsp	sp[0x0],lr
80008fdc:	c2 29       	rjmp	80009220 <_vfprintf_r+0x1538>
80008fde:	50 a7       	stdsp	sp[0x28],r7
80008fe0:	50 80       	stdsp	sp[0x20],r0
80008fe2:	0c 97       	mov	r7,r6
80008fe4:	04 94       	mov	r4,r2
80008fe6:	06 96       	mov	r6,r3
80008fe8:	02 92       	mov	r2,r1
80008fea:	fe cc c5 b6 	sub	r12,pc,-14922
80008fee:	40 93       	lddsp	r3,sp[0x24]
80008ff0:	10 90       	mov	r0,r8
80008ff2:	40 41       	lddsp	r1,sp[0x10]
80008ff4:	50 dc       	stdsp	sp[0x34],r12
80008ff6:	ed b5 00 05 	bld	r5,0x5
80008ffa:	c5 51       	brne	800090a4 <_vfprintf_r+0x13bc>
80008ffc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009000:	40 3b       	lddsp	r11,sp[0xc]
80009002:	58 0b       	cp.w	r11,0
80009004:	c2 20       	breq	80009048 <_vfprintf_r+0x1360>
80009006:	10 36       	cp.w	r6,r8
80009008:	c0 a4       	brge	8000901c <_vfprintf_r+0x1334>
8000900a:	fa ca f9 44 	sub	r10,sp,-1724
8000900e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009012:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009016:	fa e9 00 00 	st.d	sp[0],r8
8000901a:	cf 28       	rjmp	800091fe <_vfprintf_r+0x1516>
8000901c:	fa c8 f9 50 	sub	r8,sp,-1712
80009020:	1a d8       	st.w	--sp,r8
80009022:	fa c8 fa b8 	sub	r8,sp,-1352
80009026:	04 9a       	mov	r10,r2
80009028:	1a d8       	st.w	--sp,r8
8000902a:	0c 9b       	mov	r11,r6
8000902c:	fa c8 fb b4 	sub	r8,sp,-1100
80009030:	08 9c       	mov	r12,r4
80009032:	1a d8       	st.w	--sp,r8
80009034:	fa c8 f9 40 	sub	r8,sp,-1728
80009038:	fa c9 ff b4 	sub	r9,sp,-76
8000903c:	fe b0 f4 be 	rcall	800079b8 <get_arg>
80009040:	2f dd       	sub	sp,-12
80009042:	f8 ea 00 00 	ld.d	r10,r12[0]
80009046:	c0 c8       	rjmp	8000905e <_vfprintf_r+0x1376>
80009048:	ee ca ff ff 	sub	r10,r7,-1
8000904c:	10 37       	cp.w	r7,r8
8000904e:	c0 b4       	brge	80009064 <_vfprintf_r+0x137c>
80009050:	fa c9 f9 44 	sub	r9,sp,-1724
80009054:	14 97       	mov	r7,r10
80009056:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000905a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000905e:	fa eb 00 00 	st.d	sp[0],r10
80009062:	cc e8       	rjmp	800091fe <_vfprintf_r+0x1516>
80009064:	41 09       	lddsp	r9,sp[0x40]
80009066:	59 f8       	cp.w	r8,31
80009068:	e0 89 00 16 	brgt	80009094 <_vfprintf_r+0x13ac>
8000906c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009070:	f2 cb ff f8 	sub	r11,r9,-8
80009074:	fa e7 00 00 	st.d	sp[0],r6
80009078:	51 0b       	stdsp	sp[0x40],r11
8000907a:	fa c6 f9 44 	sub	r6,sp,-1724
8000907e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009082:	fa e6 00 00 	ld.d	r6,sp[0]
80009086:	f2 e7 fd 88 	st.d	r9[-632],r6
8000908a:	2f f8       	sub	r8,-1
8000908c:	14 97       	mov	r7,r10
8000908e:	fb 48 06 b4 	st.w	sp[1716],r8
80009092:	cb 68       	rjmp	800091fe <_vfprintf_r+0x1516>
80009094:	f2 e6 00 00 	ld.d	r6,r9[0]
80009098:	2f 89       	sub	r9,-8
8000909a:	fa e7 00 00 	st.d	sp[0],r6
8000909e:	51 09       	stdsp	sp[0x40],r9
800090a0:	14 97       	mov	r7,r10
800090a2:	ca e8       	rjmp	800091fe <_vfprintf_r+0x1516>
800090a4:	ed b5 00 04 	bld	r5,0x4
800090a8:	c1 71       	brne	800090d6 <_vfprintf_r+0x13ee>
800090aa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090ae:	40 3e       	lddsp	lr,sp[0xc]
800090b0:	58 0e       	cp.w	lr,0
800090b2:	c0 80       	breq	800090c2 <_vfprintf_r+0x13da>
800090b4:	10 36       	cp.w	r6,r8
800090b6:	c6 94       	brge	80009188 <_vfprintf_r+0x14a0>
800090b8:	fa cc f9 44 	sub	r12,sp,-1724
800090bc:	f8 06 00 36 	add	r6,r12,r6<<0x3
800090c0:	c8 28       	rjmp	800091c4 <_vfprintf_r+0x14dc>
800090c2:	ee ca ff ff 	sub	r10,r7,-1
800090c6:	10 37       	cp.w	r7,r8
800090c8:	e0 84 00 81 	brge	800091ca <_vfprintf_r+0x14e2>
800090cc:	fa cb f9 44 	sub	r11,sp,-1724
800090d0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090d4:	c7 78       	rjmp	800091c2 <_vfprintf_r+0x14da>
800090d6:	ed b5 00 06 	bld	r5,0x6
800090da:	c4 b1       	brne	80009170 <_vfprintf_r+0x1488>
800090dc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090e0:	40 3c       	lddsp	r12,sp[0xc]
800090e2:	58 0c       	cp.w	r12,0
800090e4:	c1 d0       	breq	8000911e <_vfprintf_r+0x1436>
800090e6:	10 36       	cp.w	r6,r8
800090e8:	c0 64       	brge	800090f4 <_vfprintf_r+0x140c>
800090ea:	fa cb f9 44 	sub	r11,sp,-1724
800090ee:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090f2:	c1 f8       	rjmp	80009130 <_vfprintf_r+0x1448>
800090f4:	fa c8 f9 50 	sub	r8,sp,-1712
800090f8:	1a d8       	st.w	--sp,r8
800090fa:	fa c8 fa b8 	sub	r8,sp,-1352
800090fe:	1a d8       	st.w	--sp,r8
80009100:	fa c8 fb b4 	sub	r8,sp,-1100
80009104:	1a d8       	st.w	--sp,r8
80009106:	fa c8 f9 40 	sub	r8,sp,-1728
8000910a:	fa c9 ff b4 	sub	r9,sp,-76
8000910e:	04 9a       	mov	r10,r2
80009110:	0c 9b       	mov	r11,r6
80009112:	08 9c       	mov	r12,r4
80009114:	fe b0 f4 52 	rcall	800079b8 <get_arg>
80009118:	2f dd       	sub	sp,-12
8000911a:	98 18       	ld.sh	r8,r12[0x2]
8000911c:	c2 78       	rjmp	8000916a <_vfprintf_r+0x1482>
8000911e:	ee ca ff ff 	sub	r10,r7,-1
80009122:	10 37       	cp.w	r7,r8
80009124:	c0 a4       	brge	80009138 <_vfprintf_r+0x1450>
80009126:	fa c9 f9 44 	sub	r9,sp,-1724
8000912a:	14 97       	mov	r7,r10
8000912c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009130:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009134:	c1 b8       	rjmp	8000916a <_vfprintf_r+0x1482>
80009136:	d7 03       	nop
80009138:	41 09       	lddsp	r9,sp[0x40]
8000913a:	59 f8       	cp.w	r8,31
8000913c:	e0 89 00 13 	brgt	80009162 <_vfprintf_r+0x147a>
80009140:	f2 cb ff fc 	sub	r11,r9,-4
80009144:	51 0b       	stdsp	sp[0x40],r11
80009146:	72 09       	ld.w	r9,r9[0x0]
80009148:	fa c6 f9 44 	sub	r6,sp,-1724
8000914c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009150:	2f f8       	sub	r8,-1
80009152:	f7 49 fd 88 	st.w	r11[-632],r9
80009156:	fb 48 06 b4 	st.w	sp[1716],r8
8000915a:	14 97       	mov	r7,r10
8000915c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009160:	c0 58       	rjmp	8000916a <_vfprintf_r+0x1482>
80009162:	92 18       	ld.sh	r8,r9[0x2]
80009164:	14 97       	mov	r7,r10
80009166:	2f c9       	sub	r9,-4
80009168:	51 09       	stdsp	sp[0x40],r9
8000916a:	5c 78       	castu.h	r8
8000916c:	50 18       	stdsp	sp[0x4],r8
8000916e:	c4 68       	rjmp	800091fa <_vfprintf_r+0x1512>
80009170:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009174:	40 3c       	lddsp	r12,sp[0xc]
80009176:	58 0c       	cp.w	r12,0
80009178:	c1 d0       	breq	800091b2 <_vfprintf_r+0x14ca>
8000917a:	10 36       	cp.w	r6,r8
8000917c:	c0 64       	brge	80009188 <_vfprintf_r+0x14a0>
8000917e:	fa cb f9 44 	sub	r11,sp,-1724
80009182:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009186:	c1 f8       	rjmp	800091c4 <_vfprintf_r+0x14dc>
80009188:	fa c8 f9 50 	sub	r8,sp,-1712
8000918c:	1a d8       	st.w	--sp,r8
8000918e:	fa c8 fa b8 	sub	r8,sp,-1352
80009192:	0c 9b       	mov	r11,r6
80009194:	1a d8       	st.w	--sp,r8
80009196:	fa c8 fb b4 	sub	r8,sp,-1100
8000919a:	04 9a       	mov	r10,r2
8000919c:	1a d8       	st.w	--sp,r8
8000919e:	08 9c       	mov	r12,r4
800091a0:	fa c8 f9 40 	sub	r8,sp,-1728
800091a4:	fa c9 ff b4 	sub	r9,sp,-76
800091a8:	fe b0 f4 08 	rcall	800079b8 <get_arg>
800091ac:	2f dd       	sub	sp,-12
800091ae:	78 0b       	ld.w	r11,r12[0x0]
800091b0:	c2 48       	rjmp	800091f8 <_vfprintf_r+0x1510>
800091b2:	ee ca ff ff 	sub	r10,r7,-1
800091b6:	10 37       	cp.w	r7,r8
800091b8:	c0 94       	brge	800091ca <_vfprintf_r+0x14e2>
800091ba:	fa c9 f9 44 	sub	r9,sp,-1724
800091be:	f2 06 00 36 	add	r6,r9,r6<<0x3
800091c2:	14 97       	mov	r7,r10
800091c4:	ec fb fd 88 	ld.w	r11,r6[-632]
800091c8:	c1 88       	rjmp	800091f8 <_vfprintf_r+0x1510>
800091ca:	41 09       	lddsp	r9,sp[0x40]
800091cc:	59 f8       	cp.w	r8,31
800091ce:	e0 89 00 11 	brgt	800091f0 <_vfprintf_r+0x1508>
800091d2:	f2 cb ff fc 	sub	r11,r9,-4
800091d6:	51 0b       	stdsp	sp[0x40],r11
800091d8:	fa c6 f9 44 	sub	r6,sp,-1724
800091dc:	72 0b       	ld.w	r11,r9[0x0]
800091de:	ec 08 00 39 	add	r9,r6,r8<<0x3
800091e2:	f3 4b fd 88 	st.w	r9[-632],r11
800091e6:	2f f8       	sub	r8,-1
800091e8:	14 97       	mov	r7,r10
800091ea:	fb 48 06 b4 	st.w	sp[1716],r8
800091ee:	c0 58       	rjmp	800091f8 <_vfprintf_r+0x1510>
800091f0:	72 0b       	ld.w	r11,r9[0x0]
800091f2:	14 97       	mov	r7,r10
800091f4:	2f c9       	sub	r9,-4
800091f6:	51 09       	stdsp	sp[0x40],r9
800091f8:	50 1b       	stdsp	sp[0x4],r11
800091fa:	30 0e       	mov	lr,0
800091fc:	50 0e       	stdsp	sp[0x0],lr
800091fe:	40 08       	lddsp	r8,sp[0x0]
80009200:	40 1c       	lddsp	r12,sp[0x4]
80009202:	18 48       	or	r8,r12
80009204:	5f 19       	srne	r9
80009206:	0a 98       	mov	r8,r5
80009208:	eb e9 00 09 	and	r9,r5,r9
8000920c:	a1 b8       	sbr	r8,0x1
8000920e:	58 09       	cp.w	r9,0
80009210:	c0 70       	breq	8000921e <_vfprintf_r+0x1536>
80009212:	10 95       	mov	r5,r8
80009214:	fb 60 06 b9 	st.b	sp[1721],r0
80009218:	33 08       	mov	r8,48
8000921a:	fb 68 06 b8 	st.b	sp[1720],r8
8000921e:	30 28       	mov	r8,2
80009220:	30 09       	mov	r9,0
80009222:	fb 69 06 bb 	st.b	sp[1723],r9
80009226:	0a 99       	mov	r9,r5
80009228:	a7 d9       	cbr	r9,0x7
8000922a:	40 2b       	lddsp	r11,sp[0x8]
8000922c:	40 16       	lddsp	r6,sp[0x4]
8000922e:	58 0b       	cp.w	r11,0
80009230:	5f 1a       	srne	r10
80009232:	f2 05 17 40 	movge	r5,r9
80009236:	fa c2 f9 78 	sub	r2,sp,-1672
8000923a:	40 09       	lddsp	r9,sp[0x0]
8000923c:	0c 49       	or	r9,r6
8000923e:	5f 19       	srne	r9
80009240:	f5 e9 10 09 	or	r9,r10,r9
80009244:	c5 c0       	breq	800092fc <_vfprintf_r+0x1614>
80009246:	30 19       	mov	r9,1
80009248:	f2 08 18 00 	cp.b	r8,r9
8000924c:	c0 60       	breq	80009258 <_vfprintf_r+0x1570>
8000924e:	30 29       	mov	r9,2
80009250:	f2 08 18 00 	cp.b	r8,r9
80009254:	c0 41       	brne	8000925c <_vfprintf_r+0x1574>
80009256:	c3 c8       	rjmp	800092ce <_vfprintf_r+0x15e6>
80009258:	04 96       	mov	r6,r2
8000925a:	c3 08       	rjmp	800092ba <_vfprintf_r+0x15d2>
8000925c:	04 96       	mov	r6,r2
8000925e:	fa e8 00 00 	ld.d	r8,sp[0]
80009262:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80009266:	2d 0a       	sub	r10,-48
80009268:	0c fa       	st.b	--r6,r10
8000926a:	f0 0b 16 03 	lsr	r11,r8,0x3
8000926e:	f2 0c 16 03 	lsr	r12,r9,0x3
80009272:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80009276:	18 99       	mov	r9,r12
80009278:	16 98       	mov	r8,r11
8000927a:	58 08       	cp.w	r8,0
8000927c:	5c 29       	cpc	r9
8000927e:	cf 21       	brne	80009262 <_vfprintf_r+0x157a>
80009280:	fa e9 00 00 	st.d	sp[0],r8
80009284:	ed b5 00 00 	bld	r5,0x0
80009288:	c4 51       	brne	80009312 <_vfprintf_r+0x162a>
8000928a:	33 09       	mov	r9,48
8000928c:	f2 0a 18 00 	cp.b	r10,r9
80009290:	c4 10       	breq	80009312 <_vfprintf_r+0x162a>
80009292:	0c f9       	st.b	--r6,r9
80009294:	c3 f8       	rjmp	80009312 <_vfprintf_r+0x162a>
80009296:	fa ea 00 00 	ld.d	r10,sp[0]
8000929a:	30 a8       	mov	r8,10
8000929c:	30 09       	mov	r9,0
8000929e:	e0 a0 16 b5 	rcall	8000c008 <__avr32_umod64>
800092a2:	30 a8       	mov	r8,10
800092a4:	2d 0a       	sub	r10,-48
800092a6:	30 09       	mov	r9,0
800092a8:	ac 8a       	st.b	r6[0x0],r10
800092aa:	fa ea 00 00 	ld.d	r10,sp[0]
800092ae:	fe b0 ea 59 	rcall	80006760 <__avr32_udiv64>
800092b2:	16 99       	mov	r9,r11
800092b4:	14 98       	mov	r8,r10
800092b6:	fa e9 00 00 	st.d	sp[0],r8
800092ba:	20 16       	sub	r6,1
800092bc:	fa ea 00 00 	ld.d	r10,sp[0]
800092c0:	58 9a       	cp.w	r10,9
800092c2:	5c 2b       	cpc	r11
800092c4:	fe 9b ff e9 	brhi	80009296 <_vfprintf_r+0x15ae>
800092c8:	1b f8       	ld.ub	r8,sp[0x7]
800092ca:	2d 08       	sub	r8,-48
800092cc:	c2 08       	rjmp	8000930c <_vfprintf_r+0x1624>
800092ce:	04 96       	mov	r6,r2
800092d0:	fa e8 00 00 	ld.d	r8,sp[0]
800092d4:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800092d8:	40 de       	lddsp	lr,sp[0x34]
800092da:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800092de:	0c fa       	st.b	--r6,r10
800092e0:	f2 0b 16 04 	lsr	r11,r9,0x4
800092e4:	f0 0a 16 04 	lsr	r10,r8,0x4
800092e8:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800092ec:	16 99       	mov	r9,r11
800092ee:	14 98       	mov	r8,r10
800092f0:	58 08       	cp.w	r8,0
800092f2:	5c 29       	cpc	r9
800092f4:	cf 01       	brne	800092d4 <_vfprintf_r+0x15ec>
800092f6:	fa e9 00 00 	st.d	sp[0],r8
800092fa:	c0 c8       	rjmp	80009312 <_vfprintf_r+0x162a>
800092fc:	58 08       	cp.w	r8,0
800092fe:	c0 91       	brne	80009310 <_vfprintf_r+0x1628>
80009300:	ed b5 00 00 	bld	r5,0x0
80009304:	c0 61       	brne	80009310 <_vfprintf_r+0x1628>
80009306:	fa c6 f9 79 	sub	r6,sp,-1671
8000930a:	33 08       	mov	r8,48
8000930c:	ac 88       	st.b	r6[0x0],r8
8000930e:	c0 28       	rjmp	80009312 <_vfprintf_r+0x162a>
80009310:	04 96       	mov	r6,r2
80009312:	0c 12       	sub	r2,r6
80009314:	c1 c8       	rjmp	8000934c <_vfprintf_r+0x1664>
80009316:	50 a7       	stdsp	sp[0x28],r7
80009318:	50 80       	stdsp	sp[0x20],r0
8000931a:	40 93       	lddsp	r3,sp[0x24]
8000931c:	0c 97       	mov	r7,r6
8000931e:	10 90       	mov	r0,r8
80009320:	04 94       	mov	r4,r2
80009322:	40 41       	lddsp	r1,sp[0x10]
80009324:	58 08       	cp.w	r8,0
80009326:	e0 80 04 4f 	breq	80009bc4 <_vfprintf_r+0x1edc>
8000932a:	fb 68 06 60 	st.b	sp[1632],r8
8000932e:	30 0c       	mov	r12,0
80009330:	30 08       	mov	r8,0
80009332:	30 12       	mov	r2,1
80009334:	fb 68 06 bb 	st.b	sp[1723],r8
80009338:	50 2c       	stdsp	sp[0x8],r12
8000933a:	fa c6 f9 a0 	sub	r6,sp,-1632
8000933e:	c0 78       	rjmp	8000934c <_vfprintf_r+0x1664>
80009340:	30 0b       	mov	r11,0
80009342:	50 2b       	stdsp	sp[0x8],r11
80009344:	c0 48       	rjmp	8000934c <_vfprintf_r+0x1664>
80009346:	40 22       	lddsp	r2,sp[0x8]
80009348:	30 0a       	mov	r10,0
8000934a:	50 2a       	stdsp	sp[0x8],r10
8000934c:	40 29       	lddsp	r9,sp[0x8]
8000934e:	e4 09 0c 49 	max	r9,r2,r9
80009352:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009356:	50 39       	stdsp	sp[0xc],r9
80009358:	0a 9e       	mov	lr,r5
8000935a:	30 09       	mov	r9,0
8000935c:	e2 1e 00 02 	andl	lr,0x2,COH
80009360:	f2 08 18 00 	cp.b	r8,r9
80009364:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009368:	f7 b8 01 ff 	subne	r8,-1
8000936c:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009370:	0a 9b       	mov	r11,r5
80009372:	58 0e       	cp.w	lr,0
80009374:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009378:	f7 bc 01 fe 	subne	r12,-2
8000937c:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009380:	e2 1b 00 84 	andl	r11,0x84,COH
80009384:	50 fe       	stdsp	sp[0x3c],lr
80009386:	50 9b       	stdsp	sp[0x24],r11
80009388:	c4 71       	brne	80009416 <_vfprintf_r+0x172e>
8000938a:	40 8a       	lddsp	r10,sp[0x20]
8000938c:	40 39       	lddsp	r9,sp[0xc]
8000938e:	12 1a       	sub	r10,r9
80009390:	50 4a       	stdsp	sp[0x10],r10
80009392:	58 0a       	cp.w	r10,0
80009394:	e0 89 00 20 	brgt	800093d4 <_vfprintf_r+0x16ec>
80009398:	c3 f8       	rjmp	80009416 <_vfprintf_r+0x172e>
8000939a:	2f 09       	sub	r9,-16
8000939c:	2f f8       	sub	r8,-1
8000939e:	fe ce c9 52 	sub	lr,pc,-13998
800093a2:	31 0c       	mov	r12,16
800093a4:	fb 49 06 90 	st.w	sp[1680],r9
800093a8:	87 0e       	st.w	r3[0x0],lr
800093aa:	87 1c       	st.w	r3[0x4],r12
800093ac:	fb 48 06 8c 	st.w	sp[1676],r8
800093b0:	58 78       	cp.w	r8,7
800093b2:	e0 89 00 04 	brgt	800093ba <_vfprintf_r+0x16d2>
800093b6:	2f 83       	sub	r3,-8
800093b8:	c0 b8       	rjmp	800093ce <_vfprintf_r+0x16e6>
800093ba:	fa ca f9 78 	sub	r10,sp,-1672
800093be:	02 9b       	mov	r11,r1
800093c0:	08 9c       	mov	r12,r4
800093c2:	fe b0 f4 85 	rcall	80007ccc <__sprint_r>
800093c6:	e0 81 04 10 	brne	80009be6 <_vfprintf_r+0x1efe>
800093ca:	fa c3 f9 e0 	sub	r3,sp,-1568
800093ce:	40 4b       	lddsp	r11,sp[0x10]
800093d0:	21 0b       	sub	r11,16
800093d2:	50 4b       	stdsp	sp[0x10],r11
800093d4:	fa f9 06 90 	ld.w	r9,sp[1680]
800093d8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093dc:	fe ca c9 90 	sub	r10,pc,-13936
800093e0:	40 4e       	lddsp	lr,sp[0x10]
800093e2:	59 0e       	cp.w	lr,16
800093e4:	fe 99 ff db 	brgt	8000939a <_vfprintf_r+0x16b2>
800093e8:	1c 09       	add	r9,lr
800093ea:	2f f8       	sub	r8,-1
800093ec:	87 0a       	st.w	r3[0x0],r10
800093ee:	fb 49 06 90 	st.w	sp[1680],r9
800093f2:	87 1e       	st.w	r3[0x4],lr
800093f4:	fb 48 06 8c 	st.w	sp[1676],r8
800093f8:	58 78       	cp.w	r8,7
800093fa:	e0 89 00 04 	brgt	80009402 <_vfprintf_r+0x171a>
800093fe:	2f 83       	sub	r3,-8
80009400:	c0 b8       	rjmp	80009416 <_vfprintf_r+0x172e>
80009402:	fa ca f9 78 	sub	r10,sp,-1672
80009406:	02 9b       	mov	r11,r1
80009408:	08 9c       	mov	r12,r4
8000940a:	fe b0 f4 61 	rcall	80007ccc <__sprint_r>
8000940e:	e0 81 03 ec 	brne	80009be6 <_vfprintf_r+0x1efe>
80009412:	fa c3 f9 e0 	sub	r3,sp,-1568
80009416:	30 09       	mov	r9,0
80009418:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000941c:	f2 08 18 00 	cp.b	r8,r9
80009420:	c1 f0       	breq	8000945e <_vfprintf_r+0x1776>
80009422:	fa f8 06 90 	ld.w	r8,sp[1680]
80009426:	fa c9 f9 45 	sub	r9,sp,-1723
8000942a:	2f f8       	sub	r8,-1
8000942c:	87 09       	st.w	r3[0x0],r9
8000942e:	fb 48 06 90 	st.w	sp[1680],r8
80009432:	30 19       	mov	r9,1
80009434:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009438:	87 19       	st.w	r3[0x4],r9
8000943a:	2f f8       	sub	r8,-1
8000943c:	fb 48 06 8c 	st.w	sp[1676],r8
80009440:	58 78       	cp.w	r8,7
80009442:	e0 89 00 04 	brgt	8000944a <_vfprintf_r+0x1762>
80009446:	2f 83       	sub	r3,-8
80009448:	c0 b8       	rjmp	8000945e <_vfprintf_r+0x1776>
8000944a:	fa ca f9 78 	sub	r10,sp,-1672
8000944e:	02 9b       	mov	r11,r1
80009450:	08 9c       	mov	r12,r4
80009452:	fe b0 f4 3d 	rcall	80007ccc <__sprint_r>
80009456:	e0 81 03 c8 	brne	80009be6 <_vfprintf_r+0x1efe>
8000945a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000945e:	40 fc       	lddsp	r12,sp[0x3c]
80009460:	58 0c       	cp.w	r12,0
80009462:	c1 f0       	breq	800094a0 <_vfprintf_r+0x17b8>
80009464:	fa f8 06 90 	ld.w	r8,sp[1680]
80009468:	fa c9 f9 48 	sub	r9,sp,-1720
8000946c:	2f e8       	sub	r8,-2
8000946e:	87 09       	st.w	r3[0x0],r9
80009470:	fb 48 06 90 	st.w	sp[1680],r8
80009474:	30 29       	mov	r9,2
80009476:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000947a:	87 19       	st.w	r3[0x4],r9
8000947c:	2f f8       	sub	r8,-1
8000947e:	fb 48 06 8c 	st.w	sp[1676],r8
80009482:	58 78       	cp.w	r8,7
80009484:	e0 89 00 04 	brgt	8000948c <_vfprintf_r+0x17a4>
80009488:	2f 83       	sub	r3,-8
8000948a:	c0 b8       	rjmp	800094a0 <_vfprintf_r+0x17b8>
8000948c:	fa ca f9 78 	sub	r10,sp,-1672
80009490:	02 9b       	mov	r11,r1
80009492:	08 9c       	mov	r12,r4
80009494:	fe b0 f4 1c 	rcall	80007ccc <__sprint_r>
80009498:	e0 81 03 a7 	brne	80009be6 <_vfprintf_r+0x1efe>
8000949c:	fa c3 f9 e0 	sub	r3,sp,-1568
800094a0:	40 9b       	lddsp	r11,sp[0x24]
800094a2:	e0 4b 00 80 	cp.w	r11,128
800094a6:	c4 71       	brne	80009534 <_vfprintf_r+0x184c>
800094a8:	40 8a       	lddsp	r10,sp[0x20]
800094aa:	40 39       	lddsp	r9,sp[0xc]
800094ac:	12 1a       	sub	r10,r9
800094ae:	50 4a       	stdsp	sp[0x10],r10
800094b0:	58 0a       	cp.w	r10,0
800094b2:	e0 89 00 20 	brgt	800094f2 <_vfprintf_r+0x180a>
800094b6:	c3 f8       	rjmp	80009534 <_vfprintf_r+0x184c>
800094b8:	2f 09       	sub	r9,-16
800094ba:	2f f8       	sub	r8,-1
800094bc:	fe ce ca 60 	sub	lr,pc,-13728
800094c0:	31 0c       	mov	r12,16
800094c2:	fb 49 06 90 	st.w	sp[1680],r9
800094c6:	87 0e       	st.w	r3[0x0],lr
800094c8:	87 1c       	st.w	r3[0x4],r12
800094ca:	fb 48 06 8c 	st.w	sp[1676],r8
800094ce:	58 78       	cp.w	r8,7
800094d0:	e0 89 00 04 	brgt	800094d8 <_vfprintf_r+0x17f0>
800094d4:	2f 83       	sub	r3,-8
800094d6:	c0 b8       	rjmp	800094ec <_vfprintf_r+0x1804>
800094d8:	fa ca f9 78 	sub	r10,sp,-1672
800094dc:	02 9b       	mov	r11,r1
800094de:	08 9c       	mov	r12,r4
800094e0:	fe b0 f3 f6 	rcall	80007ccc <__sprint_r>
800094e4:	e0 81 03 81 	brne	80009be6 <_vfprintf_r+0x1efe>
800094e8:	fa c3 f9 e0 	sub	r3,sp,-1568
800094ec:	40 4b       	lddsp	r11,sp[0x10]
800094ee:	21 0b       	sub	r11,16
800094f0:	50 4b       	stdsp	sp[0x10],r11
800094f2:	fa f9 06 90 	ld.w	r9,sp[1680]
800094f6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094fa:	fe ca ca 9e 	sub	r10,pc,-13666
800094fe:	40 4e       	lddsp	lr,sp[0x10]
80009500:	59 0e       	cp.w	lr,16
80009502:	fe 99 ff db 	brgt	800094b8 <_vfprintf_r+0x17d0>
80009506:	1c 09       	add	r9,lr
80009508:	2f f8       	sub	r8,-1
8000950a:	87 0a       	st.w	r3[0x0],r10
8000950c:	fb 49 06 90 	st.w	sp[1680],r9
80009510:	87 1e       	st.w	r3[0x4],lr
80009512:	fb 48 06 8c 	st.w	sp[1676],r8
80009516:	58 78       	cp.w	r8,7
80009518:	e0 89 00 04 	brgt	80009520 <_vfprintf_r+0x1838>
8000951c:	2f 83       	sub	r3,-8
8000951e:	c0 b8       	rjmp	80009534 <_vfprintf_r+0x184c>
80009520:	fa ca f9 78 	sub	r10,sp,-1672
80009524:	02 9b       	mov	r11,r1
80009526:	08 9c       	mov	r12,r4
80009528:	fe b0 f3 d2 	rcall	80007ccc <__sprint_r>
8000952c:	e0 81 03 5d 	brne	80009be6 <_vfprintf_r+0x1efe>
80009530:	fa c3 f9 e0 	sub	r3,sp,-1568
80009534:	40 2c       	lddsp	r12,sp[0x8]
80009536:	04 1c       	sub	r12,r2
80009538:	50 2c       	stdsp	sp[0x8],r12
8000953a:	58 0c       	cp.w	r12,0
8000953c:	e0 89 00 20 	brgt	8000957c <_vfprintf_r+0x1894>
80009540:	c3 f8       	rjmp	800095be <_vfprintf_r+0x18d6>
80009542:	2f 09       	sub	r9,-16
80009544:	2f f8       	sub	r8,-1
80009546:	fe cb ca ea 	sub	r11,pc,-13590
8000954a:	31 0a       	mov	r10,16
8000954c:	fb 49 06 90 	st.w	sp[1680],r9
80009550:	87 0b       	st.w	r3[0x0],r11
80009552:	87 1a       	st.w	r3[0x4],r10
80009554:	fb 48 06 8c 	st.w	sp[1676],r8
80009558:	58 78       	cp.w	r8,7
8000955a:	e0 89 00 04 	brgt	80009562 <_vfprintf_r+0x187a>
8000955e:	2f 83       	sub	r3,-8
80009560:	c0 b8       	rjmp	80009576 <_vfprintf_r+0x188e>
80009562:	fa ca f9 78 	sub	r10,sp,-1672
80009566:	02 9b       	mov	r11,r1
80009568:	08 9c       	mov	r12,r4
8000956a:	fe b0 f3 b1 	rcall	80007ccc <__sprint_r>
8000956e:	e0 81 03 3c 	brne	80009be6 <_vfprintf_r+0x1efe>
80009572:	fa c3 f9 e0 	sub	r3,sp,-1568
80009576:	40 29       	lddsp	r9,sp[0x8]
80009578:	21 09       	sub	r9,16
8000957a:	50 29       	stdsp	sp[0x8],r9
8000957c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009580:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009584:	fe ca cb 28 	sub	r10,pc,-13528
80009588:	40 2e       	lddsp	lr,sp[0x8]
8000958a:	59 0e       	cp.w	lr,16
8000958c:	fe 99 ff db 	brgt	80009542 <_vfprintf_r+0x185a>
80009590:	1c 09       	add	r9,lr
80009592:	2f f8       	sub	r8,-1
80009594:	87 0a       	st.w	r3[0x0],r10
80009596:	fb 49 06 90 	st.w	sp[1680],r9
8000959a:	87 1e       	st.w	r3[0x4],lr
8000959c:	fb 48 06 8c 	st.w	sp[1676],r8
800095a0:	58 78       	cp.w	r8,7
800095a2:	e0 89 00 04 	brgt	800095aa <_vfprintf_r+0x18c2>
800095a6:	2f 83       	sub	r3,-8
800095a8:	c0 b8       	rjmp	800095be <_vfprintf_r+0x18d6>
800095aa:	fa ca f9 78 	sub	r10,sp,-1672
800095ae:	02 9b       	mov	r11,r1
800095b0:	08 9c       	mov	r12,r4
800095b2:	fe b0 f3 8d 	rcall	80007ccc <__sprint_r>
800095b6:	e0 81 03 18 	brne	80009be6 <_vfprintf_r+0x1efe>
800095ba:	fa c3 f9 e0 	sub	r3,sp,-1568
800095be:	ed b5 00 08 	bld	r5,0x8
800095c2:	c0 b0       	breq	800095d8 <_vfprintf_r+0x18f0>
800095c4:	fa f8 06 90 	ld.w	r8,sp[1680]
800095c8:	87 12       	st.w	r3[0x4],r2
800095ca:	87 06       	st.w	r3[0x0],r6
800095cc:	f0 02 00 02 	add	r2,r8,r2
800095d0:	fb 42 06 90 	st.w	sp[1680],r2
800095d4:	e0 8f 01 d4 	bral	8000997c <_vfprintf_r+0x1c94>
800095d8:	e0 40 00 65 	cp.w	r0,101
800095dc:	e0 8a 01 d6 	brle	80009988 <_vfprintf_r+0x1ca0>
800095e0:	30 08       	mov	r8,0
800095e2:	30 09       	mov	r9,0
800095e4:	40 5b       	lddsp	r11,sp[0x14]
800095e6:	40 7a       	lddsp	r10,sp[0x1c]
800095e8:	e0 a0 13 09 	rcall	8000bbfa <__avr32_f64_cmp_eq>
800095ec:	c7 90       	breq	800096de <_vfprintf_r+0x19f6>
800095ee:	fa f8 06 90 	ld.w	r8,sp[1680]
800095f2:	fe c9 cb aa 	sub	r9,pc,-13398
800095f6:	2f f8       	sub	r8,-1
800095f8:	87 09       	st.w	r3[0x0],r9
800095fa:	fb 48 06 90 	st.w	sp[1680],r8
800095fe:	30 19       	mov	r9,1
80009600:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009604:	87 19       	st.w	r3[0x4],r9
80009606:	2f f8       	sub	r8,-1
80009608:	fb 48 06 8c 	st.w	sp[1676],r8
8000960c:	58 78       	cp.w	r8,7
8000960e:	e0 89 00 05 	brgt	80009618 <_vfprintf_r+0x1930>
80009612:	2f 83       	sub	r3,-8
80009614:	c0 c8       	rjmp	8000962c <_vfprintf_r+0x1944>
80009616:	d7 03       	nop
80009618:	fa ca f9 78 	sub	r10,sp,-1672
8000961c:	02 9b       	mov	r11,r1
8000961e:	08 9c       	mov	r12,r4
80009620:	fe b0 f3 56 	rcall	80007ccc <__sprint_r>
80009624:	e0 81 02 e1 	brne	80009be6 <_vfprintf_r+0x1efe>
80009628:	fa c3 f9 e0 	sub	r3,sp,-1568
8000962c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009630:	40 6c       	lddsp	r12,sp[0x18]
80009632:	18 38       	cp.w	r8,r12
80009634:	c0 55       	brlt	8000963e <_vfprintf_r+0x1956>
80009636:	ed b5 00 00 	bld	r5,0x0
8000963a:	e0 81 02 6b 	brne	80009b10 <_vfprintf_r+0x1e28>
8000963e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009642:	2f f8       	sub	r8,-1
80009644:	40 cb       	lddsp	r11,sp[0x30]
80009646:	fb 48 06 90 	st.w	sp[1680],r8
8000964a:	30 19       	mov	r9,1
8000964c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009650:	87 0b       	st.w	r3[0x0],r11
80009652:	2f f8       	sub	r8,-1
80009654:	87 19       	st.w	r3[0x4],r9
80009656:	fb 48 06 8c 	st.w	sp[1676],r8
8000965a:	58 78       	cp.w	r8,7
8000965c:	e0 89 00 04 	brgt	80009664 <_vfprintf_r+0x197c>
80009660:	2f 83       	sub	r3,-8
80009662:	c0 b8       	rjmp	80009678 <_vfprintf_r+0x1990>
80009664:	fa ca f9 78 	sub	r10,sp,-1672
80009668:	02 9b       	mov	r11,r1
8000966a:	08 9c       	mov	r12,r4
8000966c:	fe b0 f3 30 	rcall	80007ccc <__sprint_r>
80009670:	e0 81 02 bb 	brne	80009be6 <_vfprintf_r+0x1efe>
80009674:	fa c3 f9 e0 	sub	r3,sp,-1568
80009678:	40 66       	lddsp	r6,sp[0x18]
8000967a:	20 16       	sub	r6,1
8000967c:	58 06       	cp.w	r6,0
8000967e:	e0 89 00 1d 	brgt	800096b8 <_vfprintf_r+0x19d0>
80009682:	e0 8f 02 47 	bral	80009b10 <_vfprintf_r+0x1e28>
80009686:	2f 09       	sub	r9,-16
80009688:	2f f8       	sub	r8,-1
8000968a:	fb 49 06 90 	st.w	sp[1680],r9
8000968e:	87 02       	st.w	r3[0x0],r2
80009690:	87 10       	st.w	r3[0x4],r0
80009692:	fb 48 06 8c 	st.w	sp[1676],r8
80009696:	58 78       	cp.w	r8,7
80009698:	e0 89 00 04 	brgt	800096a0 <_vfprintf_r+0x19b8>
8000969c:	2f 83       	sub	r3,-8
8000969e:	c0 b8       	rjmp	800096b4 <_vfprintf_r+0x19cc>
800096a0:	fa ca f9 78 	sub	r10,sp,-1672
800096a4:	02 9b       	mov	r11,r1
800096a6:	08 9c       	mov	r12,r4
800096a8:	fe b0 f3 12 	rcall	80007ccc <__sprint_r>
800096ac:	e0 81 02 9d 	brne	80009be6 <_vfprintf_r+0x1efe>
800096b0:	fa c3 f9 e0 	sub	r3,sp,-1568
800096b4:	21 06       	sub	r6,16
800096b6:	c0 48       	rjmp	800096be <_vfprintf_r+0x19d6>
800096b8:	fe c2 cc 5c 	sub	r2,pc,-13220
800096bc:	31 00       	mov	r0,16
800096be:	fa f9 06 90 	ld.w	r9,sp[1680]
800096c2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096c6:	fe ca cc 6a 	sub	r10,pc,-13206
800096ca:	59 06       	cp.w	r6,16
800096cc:	fe 99 ff dd 	brgt	80009686 <_vfprintf_r+0x199e>
800096d0:	0c 09       	add	r9,r6
800096d2:	87 0a       	st.w	r3[0x0],r10
800096d4:	fb 49 06 90 	st.w	sp[1680],r9
800096d8:	2f f8       	sub	r8,-1
800096da:	87 16       	st.w	r3[0x4],r6
800096dc:	c5 39       	rjmp	80009982 <_vfprintf_r+0x1c9a>
800096de:	fa fa 06 ac 	ld.w	r10,sp[1708]
800096e2:	58 0a       	cp.w	r10,0
800096e4:	e0 89 00 92 	brgt	80009808 <_vfprintf_r+0x1b20>
800096e8:	fa f8 06 90 	ld.w	r8,sp[1680]
800096ec:	fe c9 cc a4 	sub	r9,pc,-13148
800096f0:	2f f8       	sub	r8,-1
800096f2:	87 09       	st.w	r3[0x0],r9
800096f4:	fb 48 06 90 	st.w	sp[1680],r8
800096f8:	30 19       	mov	r9,1
800096fa:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096fe:	87 19       	st.w	r3[0x4],r9
80009700:	2f f8       	sub	r8,-1
80009702:	fb 48 06 8c 	st.w	sp[1676],r8
80009706:	58 78       	cp.w	r8,7
80009708:	e0 89 00 04 	brgt	80009710 <_vfprintf_r+0x1a28>
8000970c:	2f 83       	sub	r3,-8
8000970e:	c0 b8       	rjmp	80009724 <_vfprintf_r+0x1a3c>
80009710:	fa ca f9 78 	sub	r10,sp,-1672
80009714:	02 9b       	mov	r11,r1
80009716:	08 9c       	mov	r12,r4
80009718:	fe b0 f2 da 	rcall	80007ccc <__sprint_r>
8000971c:	e0 81 02 65 	brne	80009be6 <_vfprintf_r+0x1efe>
80009720:	fa c3 f9 e0 	sub	r3,sp,-1568
80009724:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009728:	58 08       	cp.w	r8,0
8000972a:	c0 81       	brne	8000973a <_vfprintf_r+0x1a52>
8000972c:	40 6a       	lddsp	r10,sp[0x18]
8000972e:	58 0a       	cp.w	r10,0
80009730:	c0 51       	brne	8000973a <_vfprintf_r+0x1a52>
80009732:	ed b5 00 00 	bld	r5,0x0
80009736:	e0 81 01 ed 	brne	80009b10 <_vfprintf_r+0x1e28>
8000973a:	40 c9       	lddsp	r9,sp[0x30]
8000973c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009740:	2f f8       	sub	r8,-1
80009742:	87 09       	st.w	r3[0x0],r9
80009744:	fb 48 06 90 	st.w	sp[1680],r8
80009748:	30 19       	mov	r9,1
8000974a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000974e:	87 19       	st.w	r3[0x4],r9
80009750:	2f f8       	sub	r8,-1
80009752:	fb 48 06 8c 	st.w	sp[1676],r8
80009756:	58 78       	cp.w	r8,7
80009758:	e0 89 00 04 	brgt	80009760 <_vfprintf_r+0x1a78>
8000975c:	2f 83       	sub	r3,-8
8000975e:	c0 b8       	rjmp	80009774 <_vfprintf_r+0x1a8c>
80009760:	fa ca f9 78 	sub	r10,sp,-1672
80009764:	02 9b       	mov	r11,r1
80009766:	08 9c       	mov	r12,r4
80009768:	fe b0 f2 b2 	rcall	80007ccc <__sprint_r>
8000976c:	e0 81 02 3d 	brne	80009be6 <_vfprintf_r+0x1efe>
80009770:	fa c3 f9 e0 	sub	r3,sp,-1568
80009774:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009778:	5c 32       	neg	r2
8000977a:	58 02       	cp.w	r2,0
8000977c:	e0 89 00 1d 	brgt	800097b6 <_vfprintf_r+0x1ace>
80009780:	c3 d8       	rjmp	800097fa <_vfprintf_r+0x1b12>
80009782:	2f 09       	sub	r9,-16
80009784:	2f f8       	sub	r8,-1
80009786:	31 0e       	mov	lr,16
80009788:	fb 49 06 90 	st.w	sp[1680],r9
8000978c:	87 00       	st.w	r3[0x0],r0
8000978e:	87 1e       	st.w	r3[0x4],lr
80009790:	fb 48 06 8c 	st.w	sp[1676],r8
80009794:	58 78       	cp.w	r8,7
80009796:	e0 89 00 04 	brgt	8000979e <_vfprintf_r+0x1ab6>
8000979a:	2f 83       	sub	r3,-8
8000979c:	c0 b8       	rjmp	800097b2 <_vfprintf_r+0x1aca>
8000979e:	fa ca f9 78 	sub	r10,sp,-1672
800097a2:	02 9b       	mov	r11,r1
800097a4:	08 9c       	mov	r12,r4
800097a6:	fe b0 f2 93 	rcall	80007ccc <__sprint_r>
800097aa:	e0 81 02 1e 	brne	80009be6 <_vfprintf_r+0x1efe>
800097ae:	fa c3 f9 e0 	sub	r3,sp,-1568
800097b2:	21 02       	sub	r2,16
800097b4:	c0 38       	rjmp	800097ba <_vfprintf_r+0x1ad2>
800097b6:	fe c0 cd 5a 	sub	r0,pc,-12966
800097ba:	fa f9 06 90 	ld.w	r9,sp[1680]
800097be:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097c2:	fe ca cd 66 	sub	r10,pc,-12954
800097c6:	59 02       	cp.w	r2,16
800097c8:	fe 99 ff dd 	brgt	80009782 <_vfprintf_r+0x1a9a>
800097cc:	04 09       	add	r9,r2
800097ce:	2f f8       	sub	r8,-1
800097d0:	87 0a       	st.w	r3[0x0],r10
800097d2:	fb 49 06 90 	st.w	sp[1680],r9
800097d6:	87 12       	st.w	r3[0x4],r2
800097d8:	fb 48 06 8c 	st.w	sp[1676],r8
800097dc:	58 78       	cp.w	r8,7
800097de:	e0 89 00 04 	brgt	800097e6 <_vfprintf_r+0x1afe>
800097e2:	2f 83       	sub	r3,-8
800097e4:	c0 b8       	rjmp	800097fa <_vfprintf_r+0x1b12>
800097e6:	fa ca f9 78 	sub	r10,sp,-1672
800097ea:	02 9b       	mov	r11,r1
800097ec:	08 9c       	mov	r12,r4
800097ee:	fe b0 f2 6f 	rcall	80007ccc <__sprint_r>
800097f2:	e0 81 01 fa 	brne	80009be6 <_vfprintf_r+0x1efe>
800097f6:	fa c3 f9 e0 	sub	r3,sp,-1568
800097fa:	40 6c       	lddsp	r12,sp[0x18]
800097fc:	fa f8 06 90 	ld.w	r8,sp[1680]
80009800:	87 06       	st.w	r3[0x0],r6
80009802:	87 1c       	st.w	r3[0x4],r12
80009804:	18 08       	add	r8,r12
80009806:	cb 98       	rjmp	80009978 <_vfprintf_r+0x1c90>
80009808:	fa f9 06 90 	ld.w	r9,sp[1680]
8000980c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009810:	40 6b       	lddsp	r11,sp[0x18]
80009812:	16 3a       	cp.w	r10,r11
80009814:	c6 f5       	brlt	800098f2 <_vfprintf_r+0x1c0a>
80009816:	16 09       	add	r9,r11
80009818:	2f f8       	sub	r8,-1
8000981a:	87 06       	st.w	r3[0x0],r6
8000981c:	fb 49 06 90 	st.w	sp[1680],r9
80009820:	87 1b       	st.w	r3[0x4],r11
80009822:	fb 48 06 8c 	st.w	sp[1676],r8
80009826:	58 78       	cp.w	r8,7
80009828:	e0 89 00 04 	brgt	80009830 <_vfprintf_r+0x1b48>
8000982c:	2f 83       	sub	r3,-8
8000982e:	c0 b8       	rjmp	80009844 <_vfprintf_r+0x1b5c>
80009830:	fa ca f9 78 	sub	r10,sp,-1672
80009834:	02 9b       	mov	r11,r1
80009836:	08 9c       	mov	r12,r4
80009838:	fe b0 f2 4a 	rcall	80007ccc <__sprint_r>
8000983c:	e0 81 01 d5 	brne	80009be6 <_vfprintf_r+0x1efe>
80009840:	fa c3 f9 e0 	sub	r3,sp,-1568
80009844:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009848:	40 6a       	lddsp	r10,sp[0x18]
8000984a:	14 16       	sub	r6,r10
8000984c:	58 06       	cp.w	r6,0
8000984e:	e0 89 00 1c 	brgt	80009886 <_vfprintf_r+0x1b9e>
80009852:	c3 d8       	rjmp	800098cc <_vfprintf_r+0x1be4>
80009854:	2f 09       	sub	r9,-16
80009856:	2f f8       	sub	r8,-1
80009858:	fb 49 06 90 	st.w	sp[1680],r9
8000985c:	87 02       	st.w	r3[0x0],r2
8000985e:	87 10       	st.w	r3[0x4],r0
80009860:	fb 48 06 8c 	st.w	sp[1676],r8
80009864:	58 78       	cp.w	r8,7
80009866:	e0 89 00 04 	brgt	8000986e <_vfprintf_r+0x1b86>
8000986a:	2f 83       	sub	r3,-8
8000986c:	c0 b8       	rjmp	80009882 <_vfprintf_r+0x1b9a>
8000986e:	fa ca f9 78 	sub	r10,sp,-1672
80009872:	02 9b       	mov	r11,r1
80009874:	08 9c       	mov	r12,r4
80009876:	fe b0 f2 2b 	rcall	80007ccc <__sprint_r>
8000987a:	e0 81 01 b6 	brne	80009be6 <_vfprintf_r+0x1efe>
8000987e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009882:	21 06       	sub	r6,16
80009884:	c0 48       	rjmp	8000988c <_vfprintf_r+0x1ba4>
80009886:	fe c2 ce 2a 	sub	r2,pc,-12758
8000988a:	31 00       	mov	r0,16
8000988c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009890:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009894:	fe ca ce 38 	sub	r10,pc,-12744
80009898:	59 06       	cp.w	r6,16
8000989a:	fe 99 ff dd 	brgt	80009854 <_vfprintf_r+0x1b6c>
8000989e:	0c 09       	add	r9,r6
800098a0:	2f f8       	sub	r8,-1
800098a2:	87 0a       	st.w	r3[0x0],r10
800098a4:	fb 49 06 90 	st.w	sp[1680],r9
800098a8:	87 16       	st.w	r3[0x4],r6
800098aa:	fb 48 06 8c 	st.w	sp[1676],r8
800098ae:	58 78       	cp.w	r8,7
800098b0:	e0 89 00 04 	brgt	800098b8 <_vfprintf_r+0x1bd0>
800098b4:	2f 83       	sub	r3,-8
800098b6:	c0 b8       	rjmp	800098cc <_vfprintf_r+0x1be4>
800098b8:	fa ca f9 78 	sub	r10,sp,-1672
800098bc:	02 9b       	mov	r11,r1
800098be:	08 9c       	mov	r12,r4
800098c0:	fe b0 f2 06 	rcall	80007ccc <__sprint_r>
800098c4:	e0 81 01 91 	brne	80009be6 <_vfprintf_r+0x1efe>
800098c8:	fa c3 f9 e0 	sub	r3,sp,-1568
800098cc:	ed b5 00 00 	bld	r5,0x0
800098d0:	e0 81 01 20 	brne	80009b10 <_vfprintf_r+0x1e28>
800098d4:	40 c9       	lddsp	r9,sp[0x30]
800098d6:	fa f8 06 90 	ld.w	r8,sp[1680]
800098da:	2f f8       	sub	r8,-1
800098dc:	87 09       	st.w	r3[0x0],r9
800098de:	fb 48 06 90 	st.w	sp[1680],r8
800098e2:	30 19       	mov	r9,1
800098e4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098e8:	87 19       	st.w	r3[0x4],r9
800098ea:	2f f8       	sub	r8,-1
800098ec:	fb 48 06 8c 	st.w	sp[1676],r8
800098f0:	c0 29       	rjmp	80009af4 <_vfprintf_r+0x1e0c>
800098f2:	14 09       	add	r9,r10
800098f4:	2f f8       	sub	r8,-1
800098f6:	fb 49 06 90 	st.w	sp[1680],r9
800098fa:	87 06       	st.w	r3[0x0],r6
800098fc:	87 1a       	st.w	r3[0x4],r10
800098fe:	fb 48 06 8c 	st.w	sp[1676],r8
80009902:	58 78       	cp.w	r8,7
80009904:	e0 89 00 04 	brgt	8000990c <_vfprintf_r+0x1c24>
80009908:	2f 83       	sub	r3,-8
8000990a:	c0 b8       	rjmp	80009920 <_vfprintf_r+0x1c38>
8000990c:	fa ca f9 78 	sub	r10,sp,-1672
80009910:	02 9b       	mov	r11,r1
80009912:	08 9c       	mov	r12,r4
80009914:	fe b0 f1 dc 	rcall	80007ccc <__sprint_r>
80009918:	e0 81 01 67 	brne	80009be6 <_vfprintf_r+0x1efe>
8000991c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009920:	40 c8       	lddsp	r8,sp[0x30]
80009922:	87 08       	st.w	r3[0x0],r8
80009924:	fa f8 06 90 	ld.w	r8,sp[1680]
80009928:	2f f8       	sub	r8,-1
8000992a:	30 19       	mov	r9,1
8000992c:	fb 48 06 90 	st.w	sp[1680],r8
80009930:	87 19       	st.w	r3[0x4],r9
80009932:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009936:	2f f8       	sub	r8,-1
80009938:	fb 48 06 8c 	st.w	sp[1676],r8
8000993c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009940:	58 78       	cp.w	r8,7
80009942:	e0 89 00 04 	brgt	8000994a <_vfprintf_r+0x1c62>
80009946:	2f 83       	sub	r3,-8
80009948:	c0 b8       	rjmp	8000995e <_vfprintf_r+0x1c76>
8000994a:	fa ca f9 78 	sub	r10,sp,-1672
8000994e:	02 9b       	mov	r11,r1
80009950:	08 9c       	mov	r12,r4
80009952:	fe b0 f1 bd 	rcall	80007ccc <__sprint_r>
80009956:	e0 81 01 48 	brne	80009be6 <_vfprintf_r+0x1efe>
8000995a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000995e:	04 06       	add	r6,r2
80009960:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009964:	87 06       	st.w	r3[0x0],r6
80009966:	fa f9 06 90 	ld.w	r9,sp[1680]
8000996a:	40 66       	lddsp	r6,sp[0x18]
8000996c:	40 6e       	lddsp	lr,sp[0x18]
8000996e:	10 16       	sub	r6,r8
80009970:	f2 08 01 08 	sub	r8,r9,r8
80009974:	87 16       	st.w	r3[0x4],r6
80009976:	1c 08       	add	r8,lr
80009978:	fb 48 06 90 	st.w	sp[1680],r8
8000997c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009980:	2f f8       	sub	r8,-1
80009982:	fb 48 06 8c 	st.w	sp[1676],r8
80009986:	cb 78       	rjmp	80009af4 <_vfprintf_r+0x1e0c>
80009988:	40 6c       	lddsp	r12,sp[0x18]
8000998a:	58 1c       	cp.w	r12,1
8000998c:	e0 89 00 06 	brgt	80009998 <_vfprintf_r+0x1cb0>
80009990:	ed b5 00 00 	bld	r5,0x0
80009994:	e0 81 00 85 	brne	80009a9e <_vfprintf_r+0x1db6>
80009998:	fa f8 06 90 	ld.w	r8,sp[1680]
8000999c:	2f f8       	sub	r8,-1
8000999e:	30 19       	mov	r9,1
800099a0:	fb 48 06 90 	st.w	sp[1680],r8
800099a4:	87 06       	st.w	r3[0x0],r6
800099a6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099aa:	87 19       	st.w	r3[0x4],r9
800099ac:	2f f8       	sub	r8,-1
800099ae:	fb 48 06 8c 	st.w	sp[1676],r8
800099b2:	58 78       	cp.w	r8,7
800099b4:	e0 89 00 04 	brgt	800099bc <_vfprintf_r+0x1cd4>
800099b8:	2f 83       	sub	r3,-8
800099ba:	c0 b8       	rjmp	800099d0 <_vfprintf_r+0x1ce8>
800099bc:	fa ca f9 78 	sub	r10,sp,-1672
800099c0:	02 9b       	mov	r11,r1
800099c2:	08 9c       	mov	r12,r4
800099c4:	fe b0 f1 84 	rcall	80007ccc <__sprint_r>
800099c8:	e0 81 01 0f 	brne	80009be6 <_vfprintf_r+0x1efe>
800099cc:	fa c3 f9 e0 	sub	r3,sp,-1568
800099d0:	fa f8 06 90 	ld.w	r8,sp[1680]
800099d4:	2f f8       	sub	r8,-1
800099d6:	40 cb       	lddsp	r11,sp[0x30]
800099d8:	fb 48 06 90 	st.w	sp[1680],r8
800099dc:	30 19       	mov	r9,1
800099de:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099e2:	87 0b       	st.w	r3[0x0],r11
800099e4:	2f f8       	sub	r8,-1
800099e6:	87 19       	st.w	r3[0x4],r9
800099e8:	fb 48 06 8c 	st.w	sp[1676],r8
800099ec:	58 78       	cp.w	r8,7
800099ee:	e0 89 00 05 	brgt	800099f8 <_vfprintf_r+0x1d10>
800099f2:	2f 83       	sub	r3,-8
800099f4:	c0 c8       	rjmp	80009a0c <_vfprintf_r+0x1d24>
800099f6:	d7 03       	nop
800099f8:	fa ca f9 78 	sub	r10,sp,-1672
800099fc:	02 9b       	mov	r11,r1
800099fe:	08 9c       	mov	r12,r4
80009a00:	fe b0 f1 66 	rcall	80007ccc <__sprint_r>
80009a04:	e0 81 00 f1 	brne	80009be6 <_vfprintf_r+0x1efe>
80009a08:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a0c:	30 08       	mov	r8,0
80009a0e:	30 09       	mov	r9,0
80009a10:	40 5b       	lddsp	r11,sp[0x14]
80009a12:	40 7a       	lddsp	r10,sp[0x1c]
80009a14:	e0 a0 10 f3 	rcall	8000bbfa <__avr32_f64_cmp_eq>
80009a18:	40 68       	lddsp	r8,sp[0x18]
80009a1a:	20 18       	sub	r8,1
80009a1c:	58 0c       	cp.w	r12,0
80009a1e:	c0 d1       	brne	80009a38 <_vfprintf_r+0x1d50>
80009a20:	2f f6       	sub	r6,-1
80009a22:	87 18       	st.w	r3[0x4],r8
80009a24:	87 06       	st.w	r3[0x0],r6
80009a26:	fa f6 06 90 	ld.w	r6,sp[1680]
80009a2a:	10 06       	add	r6,r8
80009a2c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a30:	fb 46 06 90 	st.w	sp[1680],r6
80009a34:	2f f8       	sub	r8,-1
80009a36:	c3 18       	rjmp	80009a98 <_vfprintf_r+0x1db0>
80009a38:	10 96       	mov	r6,r8
80009a3a:	58 08       	cp.w	r8,0
80009a3c:	e0 89 00 1c 	brgt	80009a74 <_vfprintf_r+0x1d8c>
80009a40:	c4 b8       	rjmp	80009ad6 <_vfprintf_r+0x1dee>
80009a42:	2f 09       	sub	r9,-16
80009a44:	2f f8       	sub	r8,-1
80009a46:	fb 49 06 90 	st.w	sp[1680],r9
80009a4a:	87 02       	st.w	r3[0x0],r2
80009a4c:	87 10       	st.w	r3[0x4],r0
80009a4e:	fb 48 06 8c 	st.w	sp[1676],r8
80009a52:	58 78       	cp.w	r8,7
80009a54:	e0 89 00 04 	brgt	80009a5c <_vfprintf_r+0x1d74>
80009a58:	2f 83       	sub	r3,-8
80009a5a:	c0 b8       	rjmp	80009a70 <_vfprintf_r+0x1d88>
80009a5c:	fa ca f9 78 	sub	r10,sp,-1672
80009a60:	02 9b       	mov	r11,r1
80009a62:	08 9c       	mov	r12,r4
80009a64:	fe b0 f1 34 	rcall	80007ccc <__sprint_r>
80009a68:	e0 81 00 bf 	brne	80009be6 <_vfprintf_r+0x1efe>
80009a6c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a70:	21 06       	sub	r6,16
80009a72:	c0 48       	rjmp	80009a7a <_vfprintf_r+0x1d92>
80009a74:	fe c2 d0 18 	sub	r2,pc,-12264
80009a78:	31 00       	mov	r0,16
80009a7a:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a7e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a82:	fe ca d0 26 	sub	r10,pc,-12250
80009a86:	59 06       	cp.w	r6,16
80009a88:	fe 99 ff dd 	brgt	80009a42 <_vfprintf_r+0x1d5a>
80009a8c:	0c 09       	add	r9,r6
80009a8e:	87 0a       	st.w	r3[0x0],r10
80009a90:	fb 49 06 90 	st.w	sp[1680],r9
80009a94:	2f f8       	sub	r8,-1
80009a96:	87 16       	st.w	r3[0x4],r6
80009a98:	fb 48 06 8c 	st.w	sp[1676],r8
80009a9c:	c0 e8       	rjmp	80009ab8 <_vfprintf_r+0x1dd0>
80009a9e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009aa2:	2f f8       	sub	r8,-1
80009aa4:	30 19       	mov	r9,1
80009aa6:	fb 48 06 90 	st.w	sp[1680],r8
80009aaa:	87 06       	st.w	r3[0x0],r6
80009aac:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ab0:	87 19       	st.w	r3[0x4],r9
80009ab2:	2f f8       	sub	r8,-1
80009ab4:	fb 48 06 8c 	st.w	sp[1676],r8
80009ab8:	58 78       	cp.w	r8,7
80009aba:	e0 89 00 04 	brgt	80009ac2 <_vfprintf_r+0x1dda>
80009abe:	2f 83       	sub	r3,-8
80009ac0:	c0 b8       	rjmp	80009ad6 <_vfprintf_r+0x1dee>
80009ac2:	fa ca f9 78 	sub	r10,sp,-1672
80009ac6:	02 9b       	mov	r11,r1
80009ac8:	08 9c       	mov	r12,r4
80009aca:	fe b0 f1 01 	rcall	80007ccc <__sprint_r>
80009ace:	e0 81 00 8c 	brne	80009be6 <_vfprintf_r+0x1efe>
80009ad2:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ad6:	40 ea       	lddsp	r10,sp[0x38]
80009ad8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009adc:	14 08       	add	r8,r10
80009ade:	fa c9 f9 64 	sub	r9,sp,-1692
80009ae2:	fb 48 06 90 	st.w	sp[1680],r8
80009ae6:	87 1a       	st.w	r3[0x4],r10
80009ae8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009aec:	87 09       	st.w	r3[0x0],r9
80009aee:	2f f8       	sub	r8,-1
80009af0:	fb 48 06 8c 	st.w	sp[1676],r8
80009af4:	58 78       	cp.w	r8,7
80009af6:	e0 89 00 04 	brgt	80009afe <_vfprintf_r+0x1e16>
80009afa:	2f 83       	sub	r3,-8
80009afc:	c0 a8       	rjmp	80009b10 <_vfprintf_r+0x1e28>
80009afe:	fa ca f9 78 	sub	r10,sp,-1672
80009b02:	02 9b       	mov	r11,r1
80009b04:	08 9c       	mov	r12,r4
80009b06:	fe b0 f0 e3 	rcall	80007ccc <__sprint_r>
80009b0a:	c6 e1       	brne	80009be6 <_vfprintf_r+0x1efe>
80009b0c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b10:	e2 15 00 04 	andl	r5,0x4,COH
80009b14:	c3 f0       	breq	80009b92 <_vfprintf_r+0x1eaa>
80009b16:	40 86       	lddsp	r6,sp[0x20]
80009b18:	40 39       	lddsp	r9,sp[0xc]
80009b1a:	12 16       	sub	r6,r9
80009b1c:	58 06       	cp.w	r6,0
80009b1e:	e0 89 00 1a 	brgt	80009b52 <_vfprintf_r+0x1e6a>
80009b22:	c3 88       	rjmp	80009b92 <_vfprintf_r+0x1eaa>
80009b24:	2f 09       	sub	r9,-16
80009b26:	2f f8       	sub	r8,-1
80009b28:	fb 49 06 90 	st.w	sp[1680],r9
80009b2c:	87 05       	st.w	r3[0x0],r5
80009b2e:	87 12       	st.w	r3[0x4],r2
80009b30:	fb 48 06 8c 	st.w	sp[1676],r8
80009b34:	58 78       	cp.w	r8,7
80009b36:	e0 89 00 04 	brgt	80009b3e <_vfprintf_r+0x1e56>
80009b3a:	2f 83       	sub	r3,-8
80009b3c:	c0 98       	rjmp	80009b4e <_vfprintf_r+0x1e66>
80009b3e:	00 9a       	mov	r10,r0
80009b40:	02 9b       	mov	r11,r1
80009b42:	08 9c       	mov	r12,r4
80009b44:	fe b0 f0 c4 	rcall	80007ccc <__sprint_r>
80009b48:	c4 f1       	brne	80009be6 <_vfprintf_r+0x1efe>
80009b4a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b4e:	21 06       	sub	r6,16
80009b50:	c0 68       	rjmp	80009b5c <_vfprintf_r+0x1e74>
80009b52:	fe c5 d1 06 	sub	r5,pc,-12026
80009b56:	31 02       	mov	r2,16
80009b58:	fa c0 f9 78 	sub	r0,sp,-1672
80009b5c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b60:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b64:	fe ca d1 18 	sub	r10,pc,-12008
80009b68:	59 06       	cp.w	r6,16
80009b6a:	fe 99 ff dd 	brgt	80009b24 <_vfprintf_r+0x1e3c>
80009b6e:	0c 09       	add	r9,r6
80009b70:	2f f8       	sub	r8,-1
80009b72:	87 0a       	st.w	r3[0x0],r10
80009b74:	87 16       	st.w	r3[0x4],r6
80009b76:	fb 49 06 90 	st.w	sp[1680],r9
80009b7a:	fb 48 06 8c 	st.w	sp[1676],r8
80009b7e:	58 78       	cp.w	r8,7
80009b80:	e0 8a 00 09 	brle	80009b92 <_vfprintf_r+0x1eaa>
80009b84:	fa ca f9 78 	sub	r10,sp,-1672
80009b88:	02 9b       	mov	r11,r1
80009b8a:	08 9c       	mov	r12,r4
80009b8c:	fe b0 f0 a0 	rcall	80007ccc <__sprint_r>
80009b90:	c2 b1       	brne	80009be6 <_vfprintf_r+0x1efe>
80009b92:	40 bc       	lddsp	r12,sp[0x2c]
80009b94:	40 36       	lddsp	r6,sp[0xc]
80009b96:	40 8e       	lddsp	lr,sp[0x20]
80009b98:	ec 0e 0c 48 	max	r8,r6,lr
80009b9c:	10 0c       	add	r12,r8
80009b9e:	50 bc       	stdsp	sp[0x2c],r12
80009ba0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ba4:	58 08       	cp.w	r8,0
80009ba6:	c0 80       	breq	80009bb6 <_vfprintf_r+0x1ece>
80009ba8:	fa ca f9 78 	sub	r10,sp,-1672
80009bac:	02 9b       	mov	r11,r1
80009bae:	08 9c       	mov	r12,r4
80009bb0:	fe b0 f0 8e 	rcall	80007ccc <__sprint_r>
80009bb4:	c1 91       	brne	80009be6 <_vfprintf_r+0x1efe>
80009bb6:	30 0b       	mov	r11,0
80009bb8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bbc:	fb 4b 06 8c 	st.w	sp[1676],r11
80009bc0:	fe 9f f1 22 	bral	80007e04 <_vfprintf_r+0x11c>
80009bc4:	08 95       	mov	r5,r4
80009bc6:	fa f8 06 90 	ld.w	r8,sp[1680]
80009bca:	58 08       	cp.w	r8,0
80009bcc:	c0 80       	breq	80009bdc <_vfprintf_r+0x1ef4>
80009bce:	08 9c       	mov	r12,r4
80009bd0:	fa ca f9 78 	sub	r10,sp,-1672
80009bd4:	02 9b       	mov	r11,r1
80009bd6:	fe b0 f0 7b 	rcall	80007ccc <__sprint_r>
80009bda:	c0 61       	brne	80009be6 <_vfprintf_r+0x1efe>
80009bdc:	30 08       	mov	r8,0
80009bde:	fb 48 06 8c 	st.w	sp[1676],r8
80009be2:	c0 28       	rjmp	80009be6 <_vfprintf_r+0x1efe>
80009be4:	40 41       	lddsp	r1,sp[0x10]
80009be6:	82 68       	ld.sh	r8,r1[0xc]
80009be8:	ed b8 00 06 	bld	r8,0x6
80009bec:	c0 31       	brne	80009bf2 <_vfprintf_r+0x1f0a>
80009bee:	3f fa       	mov	r10,-1
80009bf0:	50 ba       	stdsp	sp[0x2c],r10
80009bf2:	40 bc       	lddsp	r12,sp[0x2c]
80009bf4:	fe 3d f9 44 	sub	sp,-1724
80009bf8:	d8 32       	popm	r0-r7,pc
80009bfa:	d7 03       	nop

80009bfc <_write_r>:
80009bfc:	d4 21       	pushm	r4-r7,lr
80009bfe:	16 98       	mov	r8,r11
80009c00:	18 97       	mov	r7,r12
80009c02:	10 9c       	mov	r12,r8
80009c04:	30 08       	mov	r8,0
80009c06:	14 9b       	mov	r11,r10
80009c08:	e0 66 07 fc 	mov	r6,2044
80009c0c:	12 9a       	mov	r10,r9
80009c0e:	8d 08       	st.w	r6[0x0],r8
80009c10:	fe b0 da 60 	rcall	800050d0 <_write>
80009c14:	5b fc       	cp.w	r12,-1
80009c16:	c0 51       	brne	80009c20 <_write_r+0x24>
80009c18:	6c 08       	ld.w	r8,r6[0x0]
80009c1a:	58 08       	cp.w	r8,0
80009c1c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80009c20:	d8 22       	popm	r4-r7,pc
80009c22:	d7 03       	nop

80009c24 <__swsetup_r>:
80009c24:	d4 21       	pushm	r4-r7,lr
80009c26:	e0 68 01 18 	mov	r8,280
80009c2a:	18 96       	mov	r6,r12
80009c2c:	16 97       	mov	r7,r11
80009c2e:	70 0c       	ld.w	r12,r8[0x0]
80009c30:	58 0c       	cp.w	r12,0
80009c32:	c0 60       	breq	80009c3e <__swsetup_r+0x1a>
80009c34:	78 68       	ld.w	r8,r12[0x18]
80009c36:	58 08       	cp.w	r8,0
80009c38:	c0 31       	brne	80009c3e <__swsetup_r+0x1a>
80009c3a:	fe b0 ec db 	rcall	800075f0 <__sinit>
80009c3e:	fe c8 d5 06 	sub	r8,pc,-11002
80009c42:	10 37       	cp.w	r7,r8
80009c44:	c0 61       	brne	80009c50 <__swsetup_r+0x2c>
80009c46:	e0 68 01 18 	mov	r8,280
80009c4a:	70 08       	ld.w	r8,r8[0x0]
80009c4c:	70 07       	ld.w	r7,r8[0x0]
80009c4e:	c1 28       	rjmp	80009c72 <__swsetup_r+0x4e>
80009c50:	fe c8 d4 f8 	sub	r8,pc,-11016
80009c54:	10 37       	cp.w	r7,r8
80009c56:	c0 61       	brne	80009c62 <__swsetup_r+0x3e>
80009c58:	e0 68 01 18 	mov	r8,280
80009c5c:	70 08       	ld.w	r8,r8[0x0]
80009c5e:	70 17       	ld.w	r7,r8[0x4]
80009c60:	c0 98       	rjmp	80009c72 <__swsetup_r+0x4e>
80009c62:	fe c8 d4 ea 	sub	r8,pc,-11030
80009c66:	10 37       	cp.w	r7,r8
80009c68:	c0 51       	brne	80009c72 <__swsetup_r+0x4e>
80009c6a:	e0 68 01 18 	mov	r8,280
80009c6e:	70 08       	ld.w	r8,r8[0x0]
80009c70:	70 27       	ld.w	r7,r8[0x8]
80009c72:	8e 68       	ld.sh	r8,r7[0xc]
80009c74:	ed b8 00 03 	bld	r8,0x3
80009c78:	c1 e0       	breq	80009cb4 <__swsetup_r+0x90>
80009c7a:	ed b8 00 04 	bld	r8,0x4
80009c7e:	c3 e1       	brne	80009cfa <__swsetup_r+0xd6>
80009c80:	ed b8 00 02 	bld	r8,0x2
80009c84:	c1 51       	brne	80009cae <__swsetup_r+0x8a>
80009c86:	6e db       	ld.w	r11,r7[0x34]
80009c88:	58 0b       	cp.w	r11,0
80009c8a:	c0 a0       	breq	80009c9e <__swsetup_r+0x7a>
80009c8c:	ee c8 ff bc 	sub	r8,r7,-68
80009c90:	10 3b       	cp.w	r11,r8
80009c92:	c0 40       	breq	80009c9a <__swsetup_r+0x76>
80009c94:	0c 9c       	mov	r12,r6
80009c96:	fe b0 ed 47 	rcall	80007724 <_free_r>
80009c9a:	30 08       	mov	r8,0
80009c9c:	8f d8       	st.w	r7[0x34],r8
80009c9e:	8e 68       	ld.sh	r8,r7[0xc]
80009ca0:	e0 18 ff db 	andl	r8,0xffdb
80009ca4:	ae 68       	st.h	r7[0xc],r8
80009ca6:	30 08       	mov	r8,0
80009ca8:	8f 18       	st.w	r7[0x4],r8
80009caa:	6e 48       	ld.w	r8,r7[0x10]
80009cac:	8f 08       	st.w	r7[0x0],r8
80009cae:	8e 68       	ld.sh	r8,r7[0xc]
80009cb0:	a3 b8       	sbr	r8,0x3
80009cb2:	ae 68       	st.h	r7[0xc],r8
80009cb4:	6e 48       	ld.w	r8,r7[0x10]
80009cb6:	58 08       	cp.w	r8,0
80009cb8:	c0 b1       	brne	80009cce <__swsetup_r+0xaa>
80009cba:	8e 68       	ld.sh	r8,r7[0xc]
80009cbc:	e2 18 02 80 	andl	r8,0x280,COH
80009cc0:	e0 48 02 00 	cp.w	r8,512
80009cc4:	c0 50       	breq	80009cce <__swsetup_r+0xaa>
80009cc6:	0c 9c       	mov	r12,r6
80009cc8:	0e 9b       	mov	r11,r7
80009cca:	e0 a0 08 f9 	rcall	8000aebc <__smakebuf_r>
80009cce:	8e 69       	ld.sh	r9,r7[0xc]
80009cd0:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009cd4:	c0 70       	breq	80009ce2 <__swsetup_r+0xbe>
80009cd6:	30 08       	mov	r8,0
80009cd8:	8f 28       	st.w	r7[0x8],r8
80009cda:	6e 58       	ld.w	r8,r7[0x14]
80009cdc:	5c 38       	neg	r8
80009cde:	8f 68       	st.w	r7[0x18],r8
80009ce0:	c0 68       	rjmp	80009cec <__swsetup_r+0xc8>
80009ce2:	ed b9 00 01 	bld	r9,0x1
80009ce6:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009cea:	8f 28       	st.w	r7[0x8],r8
80009cec:	6e 48       	ld.w	r8,r7[0x10]
80009cee:	58 08       	cp.w	r8,0
80009cf0:	c0 61       	brne	80009cfc <__swsetup_r+0xd8>
80009cf2:	8e 68       	ld.sh	r8,r7[0xc]
80009cf4:	ed b8 00 07 	bld	r8,0x7
80009cf8:	c0 21       	brne	80009cfc <__swsetup_r+0xd8>
80009cfa:	dc 2a       	popm	r4-r7,pc,r12=-1
80009cfc:	d8 2a       	popm	r4-r7,pc,r12=0
80009cfe:	d7 03       	nop

80009d00 <_close_r>:
80009d00:	d4 21       	pushm	r4-r7,lr
80009d02:	30 08       	mov	r8,0
80009d04:	18 97       	mov	r7,r12
80009d06:	e0 66 07 fc 	mov	r6,2044
80009d0a:	16 9c       	mov	r12,r11
80009d0c:	8d 08       	st.w	r6[0x0],r8
80009d0e:	fe b0 ea d5 	rcall	800072b8 <_close>
80009d12:	5b fc       	cp.w	r12,-1
80009d14:	c0 51       	brne	80009d1e <_close_r+0x1e>
80009d16:	6c 08       	ld.w	r8,r6[0x0]
80009d18:	58 08       	cp.w	r8,0
80009d1a:	ef f8 1a 03 	st.wne	r7[0xc],r8
80009d1e:	d8 22       	popm	r4-r7,pc

80009d20 <quorem>:
80009d20:	d4 31       	pushm	r0-r7,lr
80009d22:	20 2d       	sub	sp,8
80009d24:	18 97       	mov	r7,r12
80009d26:	78 48       	ld.w	r8,r12[0x10]
80009d28:	76 46       	ld.w	r6,r11[0x10]
80009d2a:	0c 38       	cp.w	r8,r6
80009d2c:	c0 34       	brge	80009d32 <quorem+0x12>
80009d2e:	30 0c       	mov	r12,0
80009d30:	c8 58       	rjmp	80009e3a <quorem+0x11a>
80009d32:	ec c2 ff fc 	sub	r2,r6,-4
80009d36:	f6 c3 ff ec 	sub	r3,r11,-20
80009d3a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009d3e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009d42:	2f f9       	sub	r9,-1
80009d44:	20 16       	sub	r6,1
80009d46:	f8 09 0d 08 	divu	r8,r12,r9
80009d4a:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009d4e:	ee c4 ff ec 	sub	r4,r7,-20
80009d52:	10 95       	mov	r5,r8
80009d54:	58 08       	cp.w	r8,0
80009d56:	c4 10       	breq	80009dd8 <quorem+0xb8>
80009d58:	30 09       	mov	r9,0
80009d5a:	06 9a       	mov	r10,r3
80009d5c:	08 98       	mov	r8,r4
80009d5e:	12 91       	mov	r1,r9
80009d60:	50 0b       	stdsp	sp[0x0],r11
80009d62:	70 0e       	ld.w	lr,r8[0x0]
80009d64:	b1 8e       	lsr	lr,0x10
80009d66:	50 1e       	stdsp	sp[0x4],lr
80009d68:	15 0e       	ld.w	lr,r10++
80009d6a:	fc 00 16 10 	lsr	r0,lr,0x10
80009d6e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009d72:	ea 0e 03 41 	mac	r1,r5,lr
80009d76:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009d7a:	b1 81       	lsr	r1,0x10
80009d7c:	40 1b       	lddsp	r11,sp[0x4]
80009d7e:	ea 00 02 40 	mul	r0,r5,r0
80009d82:	e2 00 00 00 	add	r0,r1,r0
80009d86:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009d8a:	02 1b       	sub	r11,r1
80009d8c:	50 1b       	stdsp	sp[0x4],r11
80009d8e:	70 0b       	ld.w	r11,r8[0x0]
80009d90:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009d94:	02 09       	add	r9,r1
80009d96:	f2 0e 01 0e 	sub	lr,r9,lr
80009d9a:	b0 1e       	st.h	r8[0x2],lr
80009d9c:	fc 09 14 10 	asr	r9,lr,0x10
80009da0:	40 1e       	lddsp	lr,sp[0x4]
80009da2:	fc 09 00 09 	add	r9,lr,r9
80009da6:	b0 09       	st.h	r8[0x0],r9
80009da8:	e0 01 16 10 	lsr	r1,r0,0x10
80009dac:	2f c8       	sub	r8,-4
80009dae:	b1 49       	asr	r9,0x10
80009db0:	04 3a       	cp.w	r10,r2
80009db2:	fe 98 ff d8 	brls	80009d62 <quorem+0x42>
80009db6:	40 0b       	lddsp	r11,sp[0x0]
80009db8:	58 0c       	cp.w	r12,0
80009dba:	c0 f1       	brne	80009dd8 <quorem+0xb8>
80009dbc:	ec c8 ff fb 	sub	r8,r6,-5
80009dc0:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009dc4:	c0 28       	rjmp	80009dc8 <quorem+0xa8>
80009dc6:	20 16       	sub	r6,1
80009dc8:	20 48       	sub	r8,4
80009dca:	08 38       	cp.w	r8,r4
80009dcc:	e0 88 00 05 	brls	80009dd6 <quorem+0xb6>
80009dd0:	70 09       	ld.w	r9,r8[0x0]
80009dd2:	58 09       	cp.w	r9,0
80009dd4:	cf 90       	breq	80009dc6 <quorem+0xa6>
80009dd6:	8f 46       	st.w	r7[0x10],r6
80009dd8:	0e 9c       	mov	r12,r7
80009dda:	e0 a0 09 51 	rcall	8000b07c <__mcmp>
80009dde:	c2 d5       	brlt	80009e38 <quorem+0x118>
80009de0:	2f f5       	sub	r5,-1
80009de2:	08 98       	mov	r8,r4
80009de4:	30 09       	mov	r9,0
80009de6:	07 0b       	ld.w	r11,r3++
80009de8:	f6 0a 16 10 	lsr	r10,r11,0x10
80009dec:	70 0c       	ld.w	r12,r8[0x0]
80009dee:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009df2:	f8 0e 16 10 	lsr	lr,r12,0x10
80009df6:	14 1e       	sub	lr,r10
80009df8:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009dfc:	16 1a       	sub	r10,r11
80009dfe:	12 0a       	add	r10,r9
80009e00:	b0 1a       	st.h	r8[0x2],r10
80009e02:	b1 4a       	asr	r10,0x10
80009e04:	fc 0a 00 09 	add	r9,lr,r10
80009e08:	b0 09       	st.h	r8[0x0],r9
80009e0a:	2f c8       	sub	r8,-4
80009e0c:	b1 49       	asr	r9,0x10
80009e0e:	04 33       	cp.w	r3,r2
80009e10:	fe 98 ff eb 	brls	80009de6 <quorem+0xc6>
80009e14:	ec c8 ff fb 	sub	r8,r6,-5
80009e18:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009e1c:	58 09       	cp.w	r9,0
80009e1e:	c0 d1       	brne	80009e38 <quorem+0x118>
80009e20:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009e24:	c0 28       	rjmp	80009e28 <quorem+0x108>
80009e26:	20 16       	sub	r6,1
80009e28:	20 48       	sub	r8,4
80009e2a:	08 38       	cp.w	r8,r4
80009e2c:	e0 88 00 05 	brls	80009e36 <quorem+0x116>
80009e30:	70 09       	ld.w	r9,r8[0x0]
80009e32:	58 09       	cp.w	r9,0
80009e34:	cf 90       	breq	80009e26 <quorem+0x106>
80009e36:	8f 46       	st.w	r7[0x10],r6
80009e38:	0a 9c       	mov	r12,r5
80009e3a:	2f ed       	sub	sp,-8
80009e3c:	d8 32       	popm	r0-r7,pc
80009e3e:	d7 03       	nop

80009e40 <_dtoa_r>:
80009e40:	d4 31       	pushm	r0-r7,lr
80009e42:	21 ad       	sub	sp,104
80009e44:	fa c4 ff 74 	sub	r4,sp,-140
80009e48:	18 97       	mov	r7,r12
80009e4a:	16 95       	mov	r5,r11
80009e4c:	68 2c       	ld.w	r12,r4[0x8]
80009e4e:	50 c9       	stdsp	sp[0x30],r9
80009e50:	68 16       	ld.w	r6,r4[0x4]
80009e52:	68 09       	ld.w	r9,r4[0x0]
80009e54:	50 e8       	stdsp	sp[0x38],r8
80009e56:	14 94       	mov	r4,r10
80009e58:	51 2c       	stdsp	sp[0x48],r12
80009e5a:	fa e5 00 08 	st.d	sp[8],r4
80009e5e:	51 59       	stdsp	sp[0x54],r9
80009e60:	6e 95       	ld.w	r5,r7[0x24]
80009e62:	58 05       	cp.w	r5,0
80009e64:	c0 91       	brne	80009e76 <_dtoa_r+0x36>
80009e66:	31 0c       	mov	r12,16
80009e68:	fe b0 e5 ce 	rcall	80006a04 <malloc>
80009e6c:	99 35       	st.w	r12[0xc],r5
80009e6e:	8f 9c       	st.w	r7[0x24],r12
80009e70:	99 15       	st.w	r12[0x4],r5
80009e72:	99 25       	st.w	r12[0x8],r5
80009e74:	99 05       	st.w	r12[0x0],r5
80009e76:	6e 99       	ld.w	r9,r7[0x24]
80009e78:	72 08       	ld.w	r8,r9[0x0]
80009e7a:	58 08       	cp.w	r8,0
80009e7c:	c0 f0       	breq	80009e9a <_dtoa_r+0x5a>
80009e7e:	72 1a       	ld.w	r10,r9[0x4]
80009e80:	91 1a       	st.w	r8[0x4],r10
80009e82:	30 1a       	mov	r10,1
80009e84:	72 19       	ld.w	r9,r9[0x4]
80009e86:	f4 09 09 49 	lsl	r9,r10,r9
80009e8a:	10 9b       	mov	r11,r8
80009e8c:	91 29       	st.w	r8[0x8],r9
80009e8e:	0e 9c       	mov	r12,r7
80009e90:	e0 a0 09 10 	rcall	8000b0b0 <_Bfree>
80009e94:	6e 98       	ld.w	r8,r7[0x24]
80009e96:	30 09       	mov	r9,0
80009e98:	91 09       	st.w	r8[0x0],r9
80009e9a:	40 28       	lddsp	r8,sp[0x8]
80009e9c:	10 94       	mov	r4,r8
80009e9e:	58 08       	cp.w	r8,0
80009ea0:	c0 64       	brge	80009eac <_dtoa_r+0x6c>
80009ea2:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009ea6:	50 28       	stdsp	sp[0x8],r8
80009ea8:	30 18       	mov	r8,1
80009eaa:	c0 28       	rjmp	80009eae <_dtoa_r+0x6e>
80009eac:	30 08       	mov	r8,0
80009eae:	8d 08       	st.w	r6[0x0],r8
80009eb0:	fc 1c 7f f0 	movh	r12,0x7ff0
80009eb4:	40 26       	lddsp	r6,sp[0x8]
80009eb6:	0c 98       	mov	r8,r6
80009eb8:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009ebc:	18 38       	cp.w	r8,r12
80009ebe:	c2 01       	brne	80009efe <_dtoa_r+0xbe>
80009ec0:	e0 68 27 0f 	mov	r8,9999
80009ec4:	41 5b       	lddsp	r11,sp[0x54]
80009ec6:	97 08       	st.w	r11[0x0],r8
80009ec8:	40 3a       	lddsp	r10,sp[0xc]
80009eca:	58 0a       	cp.w	r10,0
80009ecc:	c0 71       	brne	80009eda <_dtoa_r+0x9a>
80009ece:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009ed2:	c0 41       	brne	80009eda <_dtoa_r+0x9a>
80009ed4:	fe cc d3 68 	sub	r12,pc,-11416
80009ed8:	c0 38       	rjmp	80009ede <_dtoa_r+0x9e>
80009eda:	fe cc d3 62 	sub	r12,pc,-11422
80009ede:	41 29       	lddsp	r9,sp[0x48]
80009ee0:	58 09       	cp.w	r9,0
80009ee2:	e0 80 05 9a 	breq	8000aa16 <_dtoa_r+0xbd6>
80009ee6:	f8 c8 ff fd 	sub	r8,r12,-3
80009eea:	f8 c9 ff f8 	sub	r9,r12,-8
80009eee:	11 8b       	ld.ub	r11,r8[0x0]
80009ef0:	30 0a       	mov	r10,0
80009ef2:	41 25       	lddsp	r5,sp[0x48]
80009ef4:	f4 0b 18 00 	cp.b	r11,r10
80009ef8:	f2 08 17 10 	movne	r8,r9
80009efc:	c1 68       	rjmp	80009f28 <_dtoa_r+0xe8>
80009efe:	fa ea 00 08 	ld.d	r10,sp[8]
80009f02:	30 08       	mov	r8,0
80009f04:	fa eb 00 3c 	st.d	sp[60],r10
80009f08:	30 09       	mov	r9,0
80009f0a:	e0 a0 0e 78 	rcall	8000bbfa <__avr32_f64_cmp_eq>
80009f0e:	c1 00       	breq	80009f2e <_dtoa_r+0xee>
80009f10:	30 18       	mov	r8,1
80009f12:	41 5a       	lddsp	r10,sp[0x54]
80009f14:	95 08       	st.w	r10[0x0],r8
80009f16:	fe cc d4 ce 	sub	r12,pc,-11058
80009f1a:	41 29       	lddsp	r9,sp[0x48]
80009f1c:	f8 08 00 08 	add	r8,r12,r8
80009f20:	58 09       	cp.w	r9,0
80009f22:	e0 80 05 7a 	breq	8000aa16 <_dtoa_r+0xbd6>
80009f26:	12 95       	mov	r5,r9
80009f28:	8b 08       	st.w	r5[0x0],r8
80009f2a:	e0 8f 05 76 	bral	8000aa16 <_dtoa_r+0xbd6>
80009f2e:	fa c8 ff 9c 	sub	r8,sp,-100
80009f32:	fa c9 ff a0 	sub	r9,sp,-96
80009f36:	fa ea 00 3c 	ld.d	r10,sp[60]
80009f3a:	0e 9c       	mov	r12,r7
80009f3c:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009f40:	e0 a0 09 0a 	rcall	8000b154 <__d2b>
80009f44:	18 93       	mov	r3,r12
80009f46:	58 05       	cp.w	r5,0
80009f48:	c0 d0       	breq	80009f62 <_dtoa_r+0x122>
80009f4a:	fa ea 00 3c 	ld.d	r10,sp[60]
80009f4e:	30 04       	mov	r4,0
80009f50:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009f54:	ea c5 03 ff 	sub	r5,r5,1023
80009f58:	10 9b       	mov	r11,r8
80009f5a:	51 74       	stdsp	sp[0x5c],r4
80009f5c:	ea 1b 3f f0 	orh	r11,0x3ff0
80009f60:	c2 58       	rjmp	80009faa <_dtoa_r+0x16a>
80009f62:	41 88       	lddsp	r8,sp[0x60]
80009f64:	41 9c       	lddsp	r12,sp[0x64]
80009f66:	10 0c       	add	r12,r8
80009f68:	f8 c5 fb ce 	sub	r5,r12,-1074
80009f6c:	e0 45 00 20 	cp.w	r5,32
80009f70:	e0 8a 00 0e 	brle	80009f8c <_dtoa_r+0x14c>
80009f74:	f8 cc fb ee 	sub	r12,r12,-1042
80009f78:	40 3b       	lddsp	r11,sp[0xc]
80009f7a:	ea 08 11 40 	rsub	r8,r5,64
80009f7e:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009f82:	ec 08 09 46 	lsl	r6,r6,r8
80009f86:	0c 4c       	or	r12,r6
80009f88:	c0 78       	rjmp	80009f96 <_dtoa_r+0x156>
80009f8a:	d7 03       	nop
80009f8c:	ea 0c 11 20 	rsub	r12,r5,32
80009f90:	40 3a       	lddsp	r10,sp[0xc]
80009f92:	f4 0c 09 4c 	lsl	r12,r10,r12
80009f96:	e0 a0 0d be 	rcall	8000bb12 <__avr32_u32_to_f64>
80009f9a:	fc 18 fe 10 	movh	r8,0xfe10
80009f9e:	30 19       	mov	r9,1
80009fa0:	ea c5 04 33 	sub	r5,r5,1075
80009fa4:	f0 0b 00 0b 	add	r11,r8,r11
80009fa8:	51 79       	stdsp	sp[0x5c],r9
80009faa:	30 08       	mov	r8,0
80009fac:	fc 19 3f f8 	movh	r9,0x3ff8
80009fb0:	e0 a0 0c 46 	rcall	8000b83c <__avr32_f64_sub>
80009fb4:	e0 68 43 61 	mov	r8,17249
80009fb8:	ea 18 63 6f 	orh	r8,0x636f
80009fbc:	e0 69 87 a7 	mov	r9,34727
80009fc0:	ea 19 3f d2 	orh	r9,0x3fd2
80009fc4:	e0 a0 0b 50 	rcall	8000b664 <__avr32_f64_mul>
80009fc8:	e0 68 c8 b3 	mov	r8,51379
80009fcc:	ea 18 8b 60 	orh	r8,0x8b60
80009fd0:	e0 69 8a 28 	mov	r9,35368
80009fd4:	ea 19 3f c6 	orh	r9,0x3fc6
80009fd8:	e0 a0 0d 00 	rcall	8000b9d8 <__avr32_f64_add>
80009fdc:	0a 9c       	mov	r12,r5
80009fde:	14 90       	mov	r0,r10
80009fe0:	16 91       	mov	r1,r11
80009fe2:	e0 a0 0d 9c 	rcall	8000bb1a <__avr32_s32_to_f64>
80009fe6:	e0 68 79 fb 	mov	r8,31227
80009fea:	ea 18 50 9f 	orh	r8,0x509f
80009fee:	e0 69 44 13 	mov	r9,17427
80009ff2:	ea 19 3f d3 	orh	r9,0x3fd3
80009ff6:	e0 a0 0b 37 	rcall	8000b664 <__avr32_f64_mul>
80009ffa:	14 98       	mov	r8,r10
80009ffc:	16 99       	mov	r9,r11
80009ffe:	00 9a       	mov	r10,r0
8000a000:	02 9b       	mov	r11,r1
8000a002:	e0 a0 0c eb 	rcall	8000b9d8 <__avr32_f64_add>
8000a006:	14 90       	mov	r0,r10
8000a008:	16 91       	mov	r1,r11
8000a00a:	e0 a0 0d 71 	rcall	8000baec <__avr32_f64_to_s32>
8000a00e:	30 08       	mov	r8,0
8000a010:	18 96       	mov	r6,r12
8000a012:	30 09       	mov	r9,0
8000a014:	00 9a       	mov	r10,r0
8000a016:	02 9b       	mov	r11,r1
8000a018:	e0 a0 0e 38 	rcall	8000bc88 <__avr32_f64_cmp_lt>
8000a01c:	c0 c0       	breq	8000a034 <_dtoa_r+0x1f4>
8000a01e:	0c 9c       	mov	r12,r6
8000a020:	e0 a0 0d 7d 	rcall	8000bb1a <__avr32_s32_to_f64>
8000a024:	14 98       	mov	r8,r10
8000a026:	16 99       	mov	r9,r11
8000a028:	00 9a       	mov	r10,r0
8000a02a:	02 9b       	mov	r11,r1
8000a02c:	e0 a0 0d e7 	rcall	8000bbfa <__avr32_f64_cmp_eq>
8000a030:	f7 b6 00 01 	subeq	r6,1
8000a034:	59 66       	cp.w	r6,22
8000a036:	e0 88 00 05 	brls	8000a040 <_dtoa_r+0x200>
8000a03a:	30 18       	mov	r8,1
8000a03c:	51 48       	stdsp	sp[0x50],r8
8000a03e:	c1 38       	rjmp	8000a064 <_dtoa_r+0x224>
8000a040:	fe c8 d4 78 	sub	r8,pc,-11144
8000a044:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a048:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a04c:	e0 a0 0e 1e 	rcall	8000bc88 <__avr32_f64_cmp_lt>
8000a050:	f9 b4 00 00 	moveq	r4,0
8000a054:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a058:	f7 b6 01 01 	subne	r6,1
8000a05c:	f9 bc 01 00 	movne	r12,0
8000a060:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a064:	41 90       	lddsp	r0,sp[0x64]
8000a066:	20 10       	sub	r0,1
8000a068:	0a 10       	sub	r0,r5
8000a06a:	c0 46       	brmi	8000a072 <_dtoa_r+0x232>
8000a06c:	50 40       	stdsp	sp[0x10],r0
8000a06e:	30 00       	mov	r0,0
8000a070:	c0 48       	rjmp	8000a078 <_dtoa_r+0x238>
8000a072:	30 0b       	mov	r11,0
8000a074:	5c 30       	neg	r0
8000a076:	50 4b       	stdsp	sp[0x10],r11
8000a078:	ec 02 11 00 	rsub	r2,r6,0
8000a07c:	58 06       	cp.w	r6,0
8000a07e:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a082:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a086:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a08a:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a08e:	f9 b2 04 00 	movge	r2,0
8000a092:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a096:	f9 b9 05 00 	movlt	r9,0
8000a09a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a09e:	40 c8       	lddsp	r8,sp[0x30]
8000a0a0:	58 98       	cp.w	r8,9
8000a0a2:	e0 8b 00 20 	brhi	8000a0e2 <_dtoa_r+0x2a2>
8000a0a6:	58 58       	cp.w	r8,5
8000a0a8:	f9 b4 0a 01 	movle	r4,1
8000a0ac:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a0b0:	f7 b5 09 04 	subgt	r5,4
8000a0b4:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a0b8:	f9 b4 09 00 	movgt	r4,0
8000a0bc:	40 cc       	lddsp	r12,sp[0x30]
8000a0be:	58 3c       	cp.w	r12,3
8000a0c0:	c2 d0       	breq	8000a11a <_dtoa_r+0x2da>
8000a0c2:	e0 89 00 05 	brgt	8000a0cc <_dtoa_r+0x28c>
8000a0c6:	58 2c       	cp.w	r12,2
8000a0c8:	c1 01       	brne	8000a0e8 <_dtoa_r+0x2a8>
8000a0ca:	c1 88       	rjmp	8000a0fa <_dtoa_r+0x2ba>
8000a0cc:	40 cb       	lddsp	r11,sp[0x30]
8000a0ce:	58 4b       	cp.w	r11,4
8000a0d0:	c0 60       	breq	8000a0dc <_dtoa_r+0x29c>
8000a0d2:	58 5b       	cp.w	r11,5
8000a0d4:	c0 a1       	brne	8000a0e8 <_dtoa_r+0x2a8>
8000a0d6:	30 1a       	mov	r10,1
8000a0d8:	50 da       	stdsp	sp[0x34],r10
8000a0da:	c2 28       	rjmp	8000a11e <_dtoa_r+0x2de>
8000a0dc:	30 19       	mov	r9,1
8000a0de:	50 d9       	stdsp	sp[0x34],r9
8000a0e0:	c0 f8       	rjmp	8000a0fe <_dtoa_r+0x2be>
8000a0e2:	30 08       	mov	r8,0
8000a0e4:	30 14       	mov	r4,1
8000a0e6:	50 c8       	stdsp	sp[0x30],r8
8000a0e8:	3f f5       	mov	r5,-1
8000a0ea:	30 1c       	mov	r12,1
8000a0ec:	30 0b       	mov	r11,0
8000a0ee:	50 95       	stdsp	sp[0x24],r5
8000a0f0:	50 dc       	stdsp	sp[0x34],r12
8000a0f2:	0a 91       	mov	r1,r5
8000a0f4:	31 28       	mov	r8,18
8000a0f6:	50 eb       	stdsp	sp[0x38],r11
8000a0f8:	c2 08       	rjmp	8000a138 <_dtoa_r+0x2f8>
8000a0fa:	30 0a       	mov	r10,0
8000a0fc:	50 da       	stdsp	sp[0x34],r10
8000a0fe:	40 e9       	lddsp	r9,sp[0x38]
8000a100:	58 09       	cp.w	r9,0
8000a102:	e0 89 00 07 	brgt	8000a110 <_dtoa_r+0x2d0>
8000a106:	30 18       	mov	r8,1
8000a108:	50 98       	stdsp	sp[0x24],r8
8000a10a:	10 91       	mov	r1,r8
8000a10c:	50 e8       	stdsp	sp[0x38],r8
8000a10e:	c1 58       	rjmp	8000a138 <_dtoa_r+0x2f8>
8000a110:	40 e5       	lddsp	r5,sp[0x38]
8000a112:	50 95       	stdsp	sp[0x24],r5
8000a114:	0a 91       	mov	r1,r5
8000a116:	0a 98       	mov	r8,r5
8000a118:	c1 08       	rjmp	8000a138 <_dtoa_r+0x2f8>
8000a11a:	30 0c       	mov	r12,0
8000a11c:	50 dc       	stdsp	sp[0x34],r12
8000a11e:	40 eb       	lddsp	r11,sp[0x38]
8000a120:	ec 0b 00 0b 	add	r11,r6,r11
8000a124:	50 9b       	stdsp	sp[0x24],r11
8000a126:	16 98       	mov	r8,r11
8000a128:	2f f8       	sub	r8,-1
8000a12a:	58 08       	cp.w	r8,0
8000a12c:	e0 89 00 05 	brgt	8000a136 <_dtoa_r+0x2f6>
8000a130:	10 91       	mov	r1,r8
8000a132:	30 18       	mov	r8,1
8000a134:	c0 28       	rjmp	8000a138 <_dtoa_r+0x2f8>
8000a136:	10 91       	mov	r1,r8
8000a138:	30 09       	mov	r9,0
8000a13a:	6e 9a       	ld.w	r10,r7[0x24]
8000a13c:	95 19       	st.w	r10[0x4],r9
8000a13e:	30 49       	mov	r9,4
8000a140:	c0 68       	rjmp	8000a14c <_dtoa_r+0x30c>
8000a142:	d7 03       	nop
8000a144:	6a 1a       	ld.w	r10,r5[0x4]
8000a146:	a1 79       	lsl	r9,0x1
8000a148:	2f fa       	sub	r10,-1
8000a14a:	8b 1a       	st.w	r5[0x4],r10
8000a14c:	6e 95       	ld.w	r5,r7[0x24]
8000a14e:	f2 ca ff ec 	sub	r10,r9,-20
8000a152:	10 3a       	cp.w	r10,r8
8000a154:	fe 98 ff f8 	brls	8000a144 <_dtoa_r+0x304>
8000a158:	6a 1b       	ld.w	r11,r5[0x4]
8000a15a:	0e 9c       	mov	r12,r7
8000a15c:	e0 a0 07 c4 	rcall	8000b0e4 <_Balloc>
8000a160:	58 e1       	cp.w	r1,14
8000a162:	5f 88       	srls	r8
8000a164:	8b 0c       	st.w	r5[0x0],r12
8000a166:	f1 e4 00 04 	and	r4,r8,r4
8000a16a:	6e 98       	ld.w	r8,r7[0x24]
8000a16c:	70 08       	ld.w	r8,r8[0x0]
8000a16e:	50 88       	stdsp	sp[0x20],r8
8000a170:	e0 80 01 82 	breq	8000a474 <_dtoa_r+0x634>
8000a174:	58 06       	cp.w	r6,0
8000a176:	e0 8a 00 43 	brle	8000a1fc <_dtoa_r+0x3bc>
8000a17a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a17e:	fe c8 d5 b6 	sub	r8,pc,-10826
8000a182:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a186:	fa e5 00 18 	st.d	sp[24],r4
8000a18a:	ec 04 14 04 	asr	r4,r6,0x4
8000a18e:	ed b4 00 04 	bld	r4,0x4
8000a192:	c0 30       	breq	8000a198 <_dtoa_r+0x358>
8000a194:	30 25       	mov	r5,2
8000a196:	c1 08       	rjmp	8000a1b6 <_dtoa_r+0x376>
8000a198:	fe c8 d5 08 	sub	r8,pc,-11000
8000a19c:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a1a0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a1a4:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a1a8:	e0 a0 0d a4 	rcall	8000bcf0 <__avr32_f64_div>
8000a1ac:	30 35       	mov	r5,3
8000a1ae:	14 98       	mov	r8,r10
8000a1b0:	16 99       	mov	r9,r11
8000a1b2:	fa e9 00 08 	st.d	sp[8],r8
8000a1b6:	fe cc d5 26 	sub	r12,pc,-10970
8000a1ba:	50 a3       	stdsp	sp[0x28],r3
8000a1bc:	0c 93       	mov	r3,r6
8000a1be:	18 96       	mov	r6,r12
8000a1c0:	c0 f8       	rjmp	8000a1de <_dtoa_r+0x39e>
8000a1c2:	fa ea 00 18 	ld.d	r10,sp[24]
8000a1c6:	ed b4 00 00 	bld	r4,0x0
8000a1ca:	c0 81       	brne	8000a1da <_dtoa_r+0x39a>
8000a1cc:	ec e8 00 00 	ld.d	r8,r6[0]
8000a1d0:	2f f5       	sub	r5,-1
8000a1d2:	e0 a0 0a 49 	rcall	8000b664 <__avr32_f64_mul>
8000a1d6:	fa eb 00 18 	st.d	sp[24],r10
8000a1da:	a1 54       	asr	r4,0x1
8000a1dc:	2f 86       	sub	r6,-8
8000a1de:	58 04       	cp.w	r4,0
8000a1e0:	cf 11       	brne	8000a1c2 <_dtoa_r+0x382>
8000a1e2:	fa e8 00 18 	ld.d	r8,sp[24]
8000a1e6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1ea:	06 96       	mov	r6,r3
8000a1ec:	e0 a0 0d 82 	rcall	8000bcf0 <__avr32_f64_div>
8000a1f0:	40 a3       	lddsp	r3,sp[0x28]
8000a1f2:	14 98       	mov	r8,r10
8000a1f4:	16 99       	mov	r9,r11
8000a1f6:	fa e9 00 08 	st.d	sp[8],r8
8000a1fa:	c2 f8       	rjmp	8000a258 <_dtoa_r+0x418>
8000a1fc:	ec 08 11 00 	rsub	r8,r6,0
8000a200:	c0 31       	brne	8000a206 <_dtoa_r+0x3c6>
8000a202:	30 25       	mov	r5,2
8000a204:	c2 a8       	rjmp	8000a258 <_dtoa_r+0x418>
8000a206:	fe cc d5 76 	sub	r12,pc,-10890
8000a20a:	f0 04 14 04 	asr	r4,r8,0x4
8000a20e:	50 1c       	stdsp	sp[0x4],r12
8000a210:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a214:	fe c9 d6 4c 	sub	r9,pc,-10676
8000a218:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a21c:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a220:	e0 a0 0a 22 	rcall	8000b664 <__avr32_f64_mul>
8000a224:	40 1c       	lddsp	r12,sp[0x4]
8000a226:	50 63       	stdsp	sp[0x18],r3
8000a228:	30 25       	mov	r5,2
8000a22a:	0c 93       	mov	r3,r6
8000a22c:	fa eb 00 08 	st.d	sp[8],r10
8000a230:	18 96       	mov	r6,r12
8000a232:	c0 f8       	rjmp	8000a250 <_dtoa_r+0x410>
8000a234:	fa ea 00 08 	ld.d	r10,sp[8]
8000a238:	ed b4 00 00 	bld	r4,0x0
8000a23c:	c0 81       	brne	8000a24c <_dtoa_r+0x40c>
8000a23e:	ec e8 00 00 	ld.d	r8,r6[0]
8000a242:	2f f5       	sub	r5,-1
8000a244:	e0 a0 0a 10 	rcall	8000b664 <__avr32_f64_mul>
8000a248:	fa eb 00 08 	st.d	sp[8],r10
8000a24c:	a1 54       	asr	r4,0x1
8000a24e:	2f 86       	sub	r6,-8
8000a250:	58 04       	cp.w	r4,0
8000a252:	cf 11       	brne	8000a234 <_dtoa_r+0x3f4>
8000a254:	06 96       	mov	r6,r3
8000a256:	40 63       	lddsp	r3,sp[0x18]
8000a258:	41 4a       	lddsp	r10,sp[0x50]
8000a25a:	58 0a       	cp.w	r10,0
8000a25c:	c2 a0       	breq	8000a2b0 <_dtoa_r+0x470>
8000a25e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a262:	58 01       	cp.w	r1,0
8000a264:	5f 94       	srgt	r4
8000a266:	fa e9 00 18 	st.d	sp[24],r8
8000a26a:	30 08       	mov	r8,0
8000a26c:	fc 19 3f f0 	movh	r9,0x3ff0
8000a270:	fa ea 00 18 	ld.d	r10,sp[24]
8000a274:	e0 a0 0d 0a 	rcall	8000bc88 <__avr32_f64_cmp_lt>
8000a278:	f9 bc 00 00 	moveq	r12,0
8000a27c:	f9 bc 01 01 	movne	r12,1
8000a280:	e9 ec 00 0c 	and	r12,r4,r12
8000a284:	c1 60       	breq	8000a2b0 <_dtoa_r+0x470>
8000a286:	40 98       	lddsp	r8,sp[0x24]
8000a288:	58 08       	cp.w	r8,0
8000a28a:	e0 8a 00 f1 	brle	8000a46c <_dtoa_r+0x62c>
8000a28e:	30 08       	mov	r8,0
8000a290:	fc 19 40 24 	movh	r9,0x4024
8000a294:	ec c4 00 01 	sub	r4,r6,1
8000a298:	fa ea 00 18 	ld.d	r10,sp[24]
8000a29c:	2f f5       	sub	r5,-1
8000a29e:	50 64       	stdsp	sp[0x18],r4
8000a2a0:	e0 a0 09 e2 	rcall	8000b664 <__avr32_f64_mul>
8000a2a4:	40 94       	lddsp	r4,sp[0x24]
8000a2a6:	14 98       	mov	r8,r10
8000a2a8:	16 99       	mov	r9,r11
8000a2aa:	fa e9 00 08 	st.d	sp[8],r8
8000a2ae:	c0 38       	rjmp	8000a2b4 <_dtoa_r+0x474>
8000a2b0:	50 66       	stdsp	sp[0x18],r6
8000a2b2:	02 94       	mov	r4,r1
8000a2b4:	0a 9c       	mov	r12,r5
8000a2b6:	e0 a0 0c 32 	rcall	8000bb1a <__avr32_s32_to_f64>
8000a2ba:	fa e8 00 08 	ld.d	r8,sp[8]
8000a2be:	e0 a0 09 d3 	rcall	8000b664 <__avr32_f64_mul>
8000a2c2:	30 08       	mov	r8,0
8000a2c4:	fc 19 40 1c 	movh	r9,0x401c
8000a2c8:	e0 a0 0b 88 	rcall	8000b9d8 <__avr32_f64_add>
8000a2cc:	14 98       	mov	r8,r10
8000a2ce:	16 99       	mov	r9,r11
8000a2d0:	fa e9 00 28 	st.d	sp[40],r8
8000a2d4:	fc 18 fc c0 	movh	r8,0xfcc0
8000a2d8:	40 a5       	lddsp	r5,sp[0x28]
8000a2da:	10 05       	add	r5,r8
8000a2dc:	50 a5       	stdsp	sp[0x28],r5
8000a2de:	58 04       	cp.w	r4,0
8000a2e0:	c2 11       	brne	8000a322 <_dtoa_r+0x4e2>
8000a2e2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2e6:	30 08       	mov	r8,0
8000a2e8:	fc 19 40 14 	movh	r9,0x4014
8000a2ec:	e0 a0 0a a8 	rcall	8000b83c <__avr32_f64_sub>
8000a2f0:	40 bc       	lddsp	r12,sp[0x2c]
8000a2f2:	fa eb 00 08 	st.d	sp[8],r10
8000a2f6:	14 98       	mov	r8,r10
8000a2f8:	16 99       	mov	r9,r11
8000a2fa:	18 9a       	mov	r10,r12
8000a2fc:	0a 9b       	mov	r11,r5
8000a2fe:	e0 a0 0c c5 	rcall	8000bc88 <__avr32_f64_cmp_lt>
8000a302:	e0 81 02 54 	brne	8000a7aa <_dtoa_r+0x96a>
8000a306:	0a 98       	mov	r8,r5
8000a308:	40 b9       	lddsp	r9,sp[0x2c]
8000a30a:	ee 18 80 00 	eorh	r8,0x8000
8000a30e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a312:	10 95       	mov	r5,r8
8000a314:	12 98       	mov	r8,r9
8000a316:	0a 99       	mov	r9,r5
8000a318:	e0 a0 0c b8 	rcall	8000bc88 <__avr32_f64_cmp_lt>
8000a31c:	e0 81 02 3e 	brne	8000a798 <_dtoa_r+0x958>
8000a320:	ca 68       	rjmp	8000a46c <_dtoa_r+0x62c>
8000a322:	fe c9 d7 5a 	sub	r9,pc,-10406
8000a326:	e8 c8 00 01 	sub	r8,r4,1
8000a32a:	40 d5       	lddsp	r5,sp[0x34]
8000a32c:	58 05       	cp.w	r5,0
8000a32e:	c4 f0       	breq	8000a3cc <_dtoa_r+0x58c>
8000a330:	30 0c       	mov	r12,0
8000a332:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a336:	51 3c       	stdsp	sp[0x4c],r12
8000a338:	30 0a       	mov	r10,0
8000a33a:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a33e:	e0 a0 0c d9 	rcall	8000bcf0 <__avr32_f64_div>
8000a342:	fa e8 00 28 	ld.d	r8,sp[40]
8000a346:	40 85       	lddsp	r5,sp[0x20]
8000a348:	e0 a0 0a 7a 	rcall	8000b83c <__avr32_f64_sub>
8000a34c:	fa eb 00 28 	st.d	sp[40],r10
8000a350:	fa ea 00 08 	ld.d	r10,sp[8]
8000a354:	e0 a0 0b cc 	rcall	8000baec <__avr32_f64_to_s32>
8000a358:	51 6c       	stdsp	sp[0x58],r12
8000a35a:	e0 a0 0b e0 	rcall	8000bb1a <__avr32_s32_to_f64>
8000a35e:	14 98       	mov	r8,r10
8000a360:	16 99       	mov	r9,r11
8000a362:	fa ea 00 08 	ld.d	r10,sp[8]
8000a366:	e0 a0 0a 6b 	rcall	8000b83c <__avr32_f64_sub>
8000a36a:	fa eb 00 08 	st.d	sp[8],r10
8000a36e:	41 68       	lddsp	r8,sp[0x58]
8000a370:	2d 08       	sub	r8,-48
8000a372:	0a c8       	st.b	r5++,r8
8000a374:	41 39       	lddsp	r9,sp[0x4c]
8000a376:	2f f9       	sub	r9,-1
8000a378:	51 39       	stdsp	sp[0x4c],r9
8000a37a:	fa e8 00 28 	ld.d	r8,sp[40]
8000a37e:	e0 a0 0c 85 	rcall	8000bc88 <__avr32_f64_cmp_lt>
8000a382:	e0 81 03 39 	brne	8000a9f4 <_dtoa_r+0xbb4>
8000a386:	fa e8 00 08 	ld.d	r8,sp[8]
8000a38a:	30 0a       	mov	r10,0
8000a38c:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a390:	e0 a0 0a 56 	rcall	8000b83c <__avr32_f64_sub>
8000a394:	fa e8 00 28 	ld.d	r8,sp[40]
8000a398:	e0 a0 0c 78 	rcall	8000bc88 <__avr32_f64_cmp_lt>
8000a39c:	fa ea 00 28 	ld.d	r10,sp[40]
8000a3a0:	30 08       	mov	r8,0
8000a3a2:	fc 19 40 24 	movh	r9,0x4024
8000a3a6:	e0 81 00 da 	brne	8000a55a <_dtoa_r+0x71a>
8000a3aa:	41 3c       	lddsp	r12,sp[0x4c]
8000a3ac:	08 3c       	cp.w	r12,r4
8000a3ae:	c5 f4       	brge	8000a46c <_dtoa_r+0x62c>
8000a3b0:	e0 a0 09 5a 	rcall	8000b664 <__avr32_f64_mul>
8000a3b4:	30 08       	mov	r8,0
8000a3b6:	fa eb 00 28 	st.d	sp[40],r10
8000a3ba:	fc 19 40 24 	movh	r9,0x4024
8000a3be:	fa ea 00 08 	ld.d	r10,sp[8]
8000a3c2:	e0 a0 09 51 	rcall	8000b664 <__avr32_f64_mul>
8000a3c6:	fa eb 00 08 	st.d	sp[8],r10
8000a3ca:	cc 3b       	rjmp	8000a350 <_dtoa_r+0x510>
8000a3cc:	40 85       	lddsp	r5,sp[0x20]
8000a3ce:	08 05       	add	r5,r4
8000a3d0:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a3d4:	51 35       	stdsp	sp[0x4c],r5
8000a3d6:	fa e8 00 28 	ld.d	r8,sp[40]
8000a3da:	40 85       	lddsp	r5,sp[0x20]
8000a3dc:	e0 a0 09 44 	rcall	8000b664 <__avr32_f64_mul>
8000a3e0:	fa eb 00 28 	st.d	sp[40],r10
8000a3e4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a3e8:	e0 a0 0b 82 	rcall	8000baec <__avr32_f64_to_s32>
8000a3ec:	51 6c       	stdsp	sp[0x58],r12
8000a3ee:	e0 a0 0b 96 	rcall	8000bb1a <__avr32_s32_to_f64>
8000a3f2:	14 98       	mov	r8,r10
8000a3f4:	16 99       	mov	r9,r11
8000a3f6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a3fa:	e0 a0 0a 21 	rcall	8000b83c <__avr32_f64_sub>
8000a3fe:	fa eb 00 08 	st.d	sp[8],r10
8000a402:	41 68       	lddsp	r8,sp[0x58]
8000a404:	2d 08       	sub	r8,-48
8000a406:	0a c8       	st.b	r5++,r8
8000a408:	41 3c       	lddsp	r12,sp[0x4c]
8000a40a:	18 35       	cp.w	r5,r12
8000a40c:	c2 81       	brne	8000a45c <_dtoa_r+0x61c>
8000a40e:	30 08       	mov	r8,0
8000a410:	fc 19 3f e0 	movh	r9,0x3fe0
8000a414:	fa ea 00 28 	ld.d	r10,sp[40]
8000a418:	e0 a0 0a e0 	rcall	8000b9d8 <__avr32_f64_add>
8000a41c:	40 85       	lddsp	r5,sp[0x20]
8000a41e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a422:	08 05       	add	r5,r4
8000a424:	e0 a0 0c 32 	rcall	8000bc88 <__avr32_f64_cmp_lt>
8000a428:	e0 81 00 99 	brne	8000a55a <_dtoa_r+0x71a>
8000a42c:	fa e8 00 28 	ld.d	r8,sp[40]
8000a430:	30 0a       	mov	r10,0
8000a432:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a436:	e0 a0 0a 03 	rcall	8000b83c <__avr32_f64_sub>
8000a43a:	14 98       	mov	r8,r10
8000a43c:	16 99       	mov	r9,r11
8000a43e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a442:	e0 a0 0c 23 	rcall	8000bc88 <__avr32_f64_cmp_lt>
8000a446:	c1 30       	breq	8000a46c <_dtoa_r+0x62c>
8000a448:	33 09       	mov	r9,48
8000a44a:	0a 98       	mov	r8,r5
8000a44c:	11 7a       	ld.ub	r10,--r8
8000a44e:	f2 0a 18 00 	cp.b	r10,r9
8000a452:	e0 81 02 d1 	brne	8000a9f4 <_dtoa_r+0xbb4>
8000a456:	10 95       	mov	r5,r8
8000a458:	cf 9b       	rjmp	8000a44a <_dtoa_r+0x60a>
8000a45a:	d7 03       	nop
8000a45c:	30 08       	mov	r8,0
8000a45e:	fc 19 40 24 	movh	r9,0x4024
8000a462:	e0 a0 09 01 	rcall	8000b664 <__avr32_f64_mul>
8000a466:	fa eb 00 08 	st.d	sp[8],r10
8000a46a:	cb db       	rjmp	8000a3e4 <_dtoa_r+0x5a4>
8000a46c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a470:	fa eb 00 08 	st.d	sp[8],r10
8000a474:	58 e6       	cp.w	r6,14
8000a476:	5f ab       	srle	r11
8000a478:	41 8a       	lddsp	r10,sp[0x60]
8000a47a:	30 08       	mov	r8,0
8000a47c:	f4 09 11 ff 	rsub	r9,r10,-1
8000a480:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a484:	f0 09 18 00 	cp.b	r9,r8
8000a488:	e0 80 00 82 	breq	8000a58c <_dtoa_r+0x74c>
8000a48c:	40 ea       	lddsp	r10,sp[0x38]
8000a48e:	58 01       	cp.w	r1,0
8000a490:	5f a9       	srle	r9
8000a492:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a496:	fe ca d8 ce 	sub	r10,pc,-10034
8000a49a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a49e:	fa e5 00 10 	st.d	sp[16],r4
8000a4a2:	f0 09 18 00 	cp.b	r9,r8
8000a4a6:	c1 40       	breq	8000a4ce <_dtoa_r+0x68e>
8000a4a8:	58 01       	cp.w	r1,0
8000a4aa:	e0 81 01 77 	brne	8000a798 <_dtoa_r+0x958>
8000a4ae:	30 08       	mov	r8,0
8000a4b0:	fc 19 40 14 	movh	r9,0x4014
8000a4b4:	08 9a       	mov	r10,r4
8000a4b6:	0a 9b       	mov	r11,r5
8000a4b8:	e0 a0 08 d6 	rcall	8000b664 <__avr32_f64_mul>
8000a4bc:	fa e8 00 08 	ld.d	r8,sp[8]
8000a4c0:	e0 a0 0b b0 	rcall	8000bc20 <__avr32_f64_cmp_ge>
8000a4c4:	e0 81 01 6a 	brne	8000a798 <_dtoa_r+0x958>
8000a4c8:	02 92       	mov	r2,r1
8000a4ca:	e0 8f 01 72 	bral	8000a7ae <_dtoa_r+0x96e>
8000a4ce:	40 85       	lddsp	r5,sp[0x20]
8000a4d0:	30 14       	mov	r4,1
8000a4d2:	fa e8 00 10 	ld.d	r8,sp[16]
8000a4d6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4da:	e0 a0 0c 0b 	rcall	8000bcf0 <__avr32_f64_div>
8000a4de:	e0 a0 0b 07 	rcall	8000baec <__avr32_f64_to_s32>
8000a4e2:	18 92       	mov	r2,r12
8000a4e4:	e0 a0 0b 1b 	rcall	8000bb1a <__avr32_s32_to_f64>
8000a4e8:	fa e8 00 10 	ld.d	r8,sp[16]
8000a4ec:	e0 a0 08 bc 	rcall	8000b664 <__avr32_f64_mul>
8000a4f0:	14 98       	mov	r8,r10
8000a4f2:	16 99       	mov	r9,r11
8000a4f4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4f8:	e0 a0 09 a2 	rcall	8000b83c <__avr32_f64_sub>
8000a4fc:	fa eb 00 08 	st.d	sp[8],r10
8000a500:	e4 c8 ff d0 	sub	r8,r2,-48
8000a504:	0a c8       	st.b	r5++,r8
8000a506:	fc 19 40 24 	movh	r9,0x4024
8000a50a:	30 08       	mov	r8,0
8000a50c:	02 34       	cp.w	r4,r1
8000a50e:	c3 31       	brne	8000a574 <_dtoa_r+0x734>
8000a510:	fa e8 00 08 	ld.d	r8,sp[8]
8000a514:	e0 a0 0a 62 	rcall	8000b9d8 <__avr32_f64_add>
8000a518:	16 91       	mov	r1,r11
8000a51a:	14 90       	mov	r0,r10
8000a51c:	14 98       	mov	r8,r10
8000a51e:	02 99       	mov	r9,r1
8000a520:	fa ea 00 10 	ld.d	r10,sp[16]
8000a524:	e0 a0 0b b2 	rcall	8000bc88 <__avr32_f64_cmp_lt>
8000a528:	c1 a1       	brne	8000a55c <_dtoa_r+0x71c>
8000a52a:	fa e8 00 10 	ld.d	r8,sp[16]
8000a52e:	00 9a       	mov	r10,r0
8000a530:	02 9b       	mov	r11,r1
8000a532:	e0 a0 0b 64 	rcall	8000bbfa <__avr32_f64_cmp_eq>
8000a536:	e0 80 02 5e 	breq	8000a9f2 <_dtoa_r+0xbb2>
8000a53a:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a53e:	c0 f1       	brne	8000a55c <_dtoa_r+0x71c>
8000a540:	e0 8f 02 59 	bral	8000a9f2 <_dtoa_r+0xbb2>
8000a544:	40 8a       	lddsp	r10,sp[0x20]
8000a546:	14 38       	cp.w	r8,r10
8000a548:	c0 30       	breq	8000a54e <_dtoa_r+0x70e>
8000a54a:	10 95       	mov	r5,r8
8000a54c:	c0 98       	rjmp	8000a55e <_dtoa_r+0x71e>
8000a54e:	33 08       	mov	r8,48
8000a550:	40 89       	lddsp	r9,sp[0x20]
8000a552:	2f f6       	sub	r6,-1
8000a554:	b2 88       	st.b	r9[0x0],r8
8000a556:	40 88       	lddsp	r8,sp[0x20]
8000a558:	c0 88       	rjmp	8000a568 <_dtoa_r+0x728>
8000a55a:	40 66       	lddsp	r6,sp[0x18]
8000a55c:	33 99       	mov	r9,57
8000a55e:	0a 98       	mov	r8,r5
8000a560:	11 7a       	ld.ub	r10,--r8
8000a562:	f2 0a 18 00 	cp.b	r10,r9
8000a566:	ce f0       	breq	8000a544 <_dtoa_r+0x704>
8000a568:	50 66       	stdsp	sp[0x18],r6
8000a56a:	11 89       	ld.ub	r9,r8[0x0]
8000a56c:	2f f9       	sub	r9,-1
8000a56e:	b0 89       	st.b	r8[0x0],r9
8000a570:	e0 8f 02 42 	bral	8000a9f4 <_dtoa_r+0xbb4>
8000a574:	e0 a0 08 78 	rcall	8000b664 <__avr32_f64_mul>
8000a578:	2f f4       	sub	r4,-1
8000a57a:	fa eb 00 08 	st.d	sp[8],r10
8000a57e:	30 08       	mov	r8,0
8000a580:	30 09       	mov	r9,0
8000a582:	e0 a0 0b 3c 	rcall	8000bbfa <__avr32_f64_cmp_eq>
8000a586:	ca 60       	breq	8000a4d2 <_dtoa_r+0x692>
8000a588:	e0 8f 02 35 	bral	8000a9f2 <_dtoa_r+0xbb2>
8000a58c:	40 d8       	lddsp	r8,sp[0x34]
8000a58e:	58 08       	cp.w	r8,0
8000a590:	c0 51       	brne	8000a59a <_dtoa_r+0x75a>
8000a592:	04 98       	mov	r8,r2
8000a594:	00 95       	mov	r5,r0
8000a596:	40 d4       	lddsp	r4,sp[0x34]
8000a598:	c3 78       	rjmp	8000a606 <_dtoa_r+0x7c6>
8000a59a:	40 c5       	lddsp	r5,sp[0x30]
8000a59c:	58 15       	cp.w	r5,1
8000a59e:	e0 89 00 0f 	brgt	8000a5bc <_dtoa_r+0x77c>
8000a5a2:	41 74       	lddsp	r4,sp[0x5c]
8000a5a4:	58 04       	cp.w	r4,0
8000a5a6:	c0 40       	breq	8000a5ae <_dtoa_r+0x76e>
8000a5a8:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a5ac:	c0 48       	rjmp	8000a5b4 <_dtoa_r+0x774>
8000a5ae:	41 99       	lddsp	r9,sp[0x64]
8000a5b0:	f2 09 11 36 	rsub	r9,r9,54
8000a5b4:	04 98       	mov	r8,r2
8000a5b6:	00 95       	mov	r5,r0
8000a5b8:	c1 c8       	rjmp	8000a5f0 <_dtoa_r+0x7b0>
8000a5ba:	d7 03       	nop
8000a5bc:	e2 c8 00 01 	sub	r8,r1,1
8000a5c0:	58 01       	cp.w	r1,0
8000a5c2:	e0 05 17 40 	movge	r5,r0
8000a5c6:	e2 09 17 40 	movge	r9,r1
8000a5ca:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a5ce:	f9 b9 05 00 	movlt	r9,0
8000a5d2:	10 32       	cp.w	r2,r8
8000a5d4:	e5 d8 e4 18 	subge	r8,r2,r8
8000a5d8:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a5dc:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a5e0:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a5e4:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a5e8:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a5ec:	f9 b8 05 00 	movlt	r8,0
8000a5f0:	40 4b       	lddsp	r11,sp[0x10]
8000a5f2:	12 0b       	add	r11,r9
8000a5f4:	50 08       	stdsp	sp[0x0],r8
8000a5f6:	50 4b       	stdsp	sp[0x10],r11
8000a5f8:	12 00       	add	r0,r9
8000a5fa:	30 1b       	mov	r11,1
8000a5fc:	0e 9c       	mov	r12,r7
8000a5fe:	e0 a0 07 27 	rcall	8000b44c <__i2b>
8000a602:	40 08       	lddsp	r8,sp[0x0]
8000a604:	18 94       	mov	r4,r12
8000a606:	40 4a       	lddsp	r10,sp[0x10]
8000a608:	58 05       	cp.w	r5,0
8000a60a:	5f 99       	srgt	r9
8000a60c:	58 0a       	cp.w	r10,0
8000a60e:	5f 9a       	srgt	r10
8000a610:	f5 e9 00 09 	and	r9,r10,r9
8000a614:	c0 80       	breq	8000a624 <_dtoa_r+0x7e4>
8000a616:	40 4c       	lddsp	r12,sp[0x10]
8000a618:	f8 05 0d 49 	min	r9,r12,r5
8000a61c:	12 1c       	sub	r12,r9
8000a61e:	12 10       	sub	r0,r9
8000a620:	50 4c       	stdsp	sp[0x10],r12
8000a622:	12 15       	sub	r5,r9
8000a624:	58 02       	cp.w	r2,0
8000a626:	e0 8a 00 27 	brle	8000a674 <_dtoa_r+0x834>
8000a62a:	40 db       	lddsp	r11,sp[0x34]
8000a62c:	58 0b       	cp.w	r11,0
8000a62e:	c1 d0       	breq	8000a668 <_dtoa_r+0x828>
8000a630:	58 08       	cp.w	r8,0
8000a632:	e0 8a 00 17 	brle	8000a660 <_dtoa_r+0x820>
8000a636:	10 9a       	mov	r10,r8
8000a638:	50 08       	stdsp	sp[0x0],r8
8000a63a:	08 9b       	mov	r11,r4
8000a63c:	0e 9c       	mov	r12,r7
8000a63e:	e0 a0 07 4d 	rcall	8000b4d8 <__pow5mult>
8000a642:	06 9a       	mov	r10,r3
8000a644:	18 9b       	mov	r11,r12
8000a646:	18 94       	mov	r4,r12
8000a648:	0e 9c       	mov	r12,r7
8000a64a:	e0 a0 06 81 	rcall	8000b34c <__multiply>
8000a64e:	18 99       	mov	r9,r12
8000a650:	06 9b       	mov	r11,r3
8000a652:	50 19       	stdsp	sp[0x4],r9
8000a654:	0e 9c       	mov	r12,r7
8000a656:	e0 a0 05 2d 	rcall	8000b0b0 <_Bfree>
8000a65a:	40 19       	lddsp	r9,sp[0x4]
8000a65c:	40 08       	lddsp	r8,sp[0x0]
8000a65e:	12 93       	mov	r3,r9
8000a660:	e4 08 01 0a 	sub	r10,r2,r8
8000a664:	c0 80       	breq	8000a674 <_dtoa_r+0x834>
8000a666:	c0 28       	rjmp	8000a66a <_dtoa_r+0x82a>
8000a668:	04 9a       	mov	r10,r2
8000a66a:	06 9b       	mov	r11,r3
8000a66c:	0e 9c       	mov	r12,r7
8000a66e:	e0 a0 07 35 	rcall	8000b4d8 <__pow5mult>
8000a672:	18 93       	mov	r3,r12
8000a674:	30 1b       	mov	r11,1
8000a676:	0e 9c       	mov	r12,r7
8000a678:	e0 a0 06 ea 	rcall	8000b44c <__i2b>
8000a67c:	41 1a       	lddsp	r10,sp[0x44]
8000a67e:	18 92       	mov	r2,r12
8000a680:	58 0a       	cp.w	r10,0
8000a682:	e0 8a 00 07 	brle	8000a690 <_dtoa_r+0x850>
8000a686:	18 9b       	mov	r11,r12
8000a688:	0e 9c       	mov	r12,r7
8000a68a:	e0 a0 07 27 	rcall	8000b4d8 <__pow5mult>
8000a68e:	18 92       	mov	r2,r12
8000a690:	40 c9       	lddsp	r9,sp[0x30]
8000a692:	58 19       	cp.w	r9,1
8000a694:	e0 89 00 14 	brgt	8000a6bc <_dtoa_r+0x87c>
8000a698:	40 38       	lddsp	r8,sp[0xc]
8000a69a:	58 08       	cp.w	r8,0
8000a69c:	c1 01       	brne	8000a6bc <_dtoa_r+0x87c>
8000a69e:	40 29       	lddsp	r9,sp[0x8]
8000a6a0:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a6a4:	c0 c1       	brne	8000a6bc <_dtoa_r+0x87c>
8000a6a6:	12 98       	mov	r8,r9
8000a6a8:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a6ac:	c0 80       	breq	8000a6bc <_dtoa_r+0x87c>
8000a6ae:	40 4c       	lddsp	r12,sp[0x10]
8000a6b0:	30 1b       	mov	r11,1
8000a6b2:	2f fc       	sub	r12,-1
8000a6b4:	2f f0       	sub	r0,-1
8000a6b6:	50 4c       	stdsp	sp[0x10],r12
8000a6b8:	50 6b       	stdsp	sp[0x18],r11
8000a6ba:	c0 38       	rjmp	8000a6c0 <_dtoa_r+0x880>
8000a6bc:	30 0a       	mov	r10,0
8000a6be:	50 6a       	stdsp	sp[0x18],r10
8000a6c0:	41 19       	lddsp	r9,sp[0x44]
8000a6c2:	58 09       	cp.w	r9,0
8000a6c4:	c0 31       	brne	8000a6ca <_dtoa_r+0x88a>
8000a6c6:	30 1c       	mov	r12,1
8000a6c8:	c0 98       	rjmp	8000a6da <_dtoa_r+0x89a>
8000a6ca:	64 48       	ld.w	r8,r2[0x10]
8000a6cc:	2f c8       	sub	r8,-4
8000a6ce:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a6d2:	e0 a0 04 5e 	rcall	8000af8e <__hi0bits>
8000a6d6:	f8 0c 11 20 	rsub	r12,r12,32
8000a6da:	40 4b       	lddsp	r11,sp[0x10]
8000a6dc:	f8 0b 00 08 	add	r8,r12,r11
8000a6e0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a6e4:	c0 c0       	breq	8000a6fc <_dtoa_r+0x8bc>
8000a6e6:	f0 08 11 20 	rsub	r8,r8,32
8000a6ea:	58 48       	cp.w	r8,4
8000a6ec:	e0 8a 00 06 	brle	8000a6f8 <_dtoa_r+0x8b8>
8000a6f0:	20 48       	sub	r8,4
8000a6f2:	10 0b       	add	r11,r8
8000a6f4:	50 4b       	stdsp	sp[0x10],r11
8000a6f6:	c0 78       	rjmp	8000a704 <_dtoa_r+0x8c4>
8000a6f8:	58 48       	cp.w	r8,4
8000a6fa:	c0 70       	breq	8000a708 <_dtoa_r+0x8c8>
8000a6fc:	40 4a       	lddsp	r10,sp[0x10]
8000a6fe:	2e 48       	sub	r8,-28
8000a700:	10 0a       	add	r10,r8
8000a702:	50 4a       	stdsp	sp[0x10],r10
8000a704:	10 00       	add	r0,r8
8000a706:	10 05       	add	r5,r8
8000a708:	58 00       	cp.w	r0,0
8000a70a:	e0 8a 00 08 	brle	8000a71a <_dtoa_r+0x8da>
8000a70e:	06 9b       	mov	r11,r3
8000a710:	00 9a       	mov	r10,r0
8000a712:	0e 9c       	mov	r12,r7
8000a714:	e0 a0 05 d8 	rcall	8000b2c4 <__lshift>
8000a718:	18 93       	mov	r3,r12
8000a71a:	40 49       	lddsp	r9,sp[0x10]
8000a71c:	58 09       	cp.w	r9,0
8000a71e:	e0 8a 00 08 	brle	8000a72e <_dtoa_r+0x8ee>
8000a722:	04 9b       	mov	r11,r2
8000a724:	12 9a       	mov	r10,r9
8000a726:	0e 9c       	mov	r12,r7
8000a728:	e0 a0 05 ce 	rcall	8000b2c4 <__lshift>
8000a72c:	18 92       	mov	r2,r12
8000a72e:	41 48       	lddsp	r8,sp[0x50]
8000a730:	58 08       	cp.w	r8,0
8000a732:	c1 b0       	breq	8000a768 <_dtoa_r+0x928>
8000a734:	04 9b       	mov	r11,r2
8000a736:	06 9c       	mov	r12,r3
8000a738:	e0 a0 04 a2 	rcall	8000b07c <__mcmp>
8000a73c:	c1 64       	brge	8000a768 <_dtoa_r+0x928>
8000a73e:	06 9b       	mov	r11,r3
8000a740:	30 09       	mov	r9,0
8000a742:	30 aa       	mov	r10,10
8000a744:	0e 9c       	mov	r12,r7
8000a746:	e0 a0 06 8b 	rcall	8000b45c <__multadd>
8000a74a:	20 16       	sub	r6,1
8000a74c:	18 93       	mov	r3,r12
8000a74e:	40 dc       	lddsp	r12,sp[0x34]
8000a750:	58 0c       	cp.w	r12,0
8000a752:	c0 31       	brne	8000a758 <_dtoa_r+0x918>
8000a754:	40 91       	lddsp	r1,sp[0x24]
8000a756:	c0 98       	rjmp	8000a768 <_dtoa_r+0x928>
8000a758:	08 9b       	mov	r11,r4
8000a75a:	40 91       	lddsp	r1,sp[0x24]
8000a75c:	30 09       	mov	r9,0
8000a75e:	30 aa       	mov	r10,10
8000a760:	0e 9c       	mov	r12,r7
8000a762:	e0 a0 06 7d 	rcall	8000b45c <__multadd>
8000a766:	18 94       	mov	r4,r12
8000a768:	58 01       	cp.w	r1,0
8000a76a:	5f a9       	srle	r9
8000a76c:	40 cb       	lddsp	r11,sp[0x30]
8000a76e:	58 2b       	cp.w	r11,2
8000a770:	5f 98       	srgt	r8
8000a772:	f3 e8 00 08 	and	r8,r9,r8
8000a776:	c2 50       	breq	8000a7c0 <_dtoa_r+0x980>
8000a778:	58 01       	cp.w	r1,0
8000a77a:	c1 11       	brne	8000a79c <_dtoa_r+0x95c>
8000a77c:	04 9b       	mov	r11,r2
8000a77e:	02 99       	mov	r9,r1
8000a780:	30 5a       	mov	r10,5
8000a782:	0e 9c       	mov	r12,r7
8000a784:	e0 a0 06 6c 	rcall	8000b45c <__multadd>
8000a788:	18 92       	mov	r2,r12
8000a78a:	18 9b       	mov	r11,r12
8000a78c:	06 9c       	mov	r12,r3
8000a78e:	e0 a0 04 77 	rcall	8000b07c <__mcmp>
8000a792:	e0 89 00 0f 	brgt	8000a7b0 <_dtoa_r+0x970>
8000a796:	c0 38       	rjmp	8000a79c <_dtoa_r+0x95c>
8000a798:	30 02       	mov	r2,0
8000a79a:	04 94       	mov	r4,r2
8000a79c:	40 ea       	lddsp	r10,sp[0x38]
8000a79e:	30 09       	mov	r9,0
8000a7a0:	5c da       	com	r10
8000a7a2:	40 85       	lddsp	r5,sp[0x20]
8000a7a4:	50 6a       	stdsp	sp[0x18],r10
8000a7a6:	50 49       	stdsp	sp[0x10],r9
8000a7a8:	c0 f9       	rjmp	8000a9c6 <_dtoa_r+0xb86>
8000a7aa:	08 92       	mov	r2,r4
8000a7ac:	40 66       	lddsp	r6,sp[0x18]
8000a7ae:	04 94       	mov	r4,r2
8000a7b0:	2f f6       	sub	r6,-1
8000a7b2:	50 66       	stdsp	sp[0x18],r6
8000a7b4:	33 18       	mov	r8,49
8000a7b6:	40 85       	lddsp	r5,sp[0x20]
8000a7b8:	0a c8       	st.b	r5++,r8
8000a7ba:	30 08       	mov	r8,0
8000a7bc:	50 48       	stdsp	sp[0x10],r8
8000a7be:	c0 49       	rjmp	8000a9c6 <_dtoa_r+0xb86>
8000a7c0:	40 dc       	lddsp	r12,sp[0x34]
8000a7c2:	58 0c       	cp.w	r12,0
8000a7c4:	e0 80 00 b5 	breq	8000a92e <_dtoa_r+0xaee>
8000a7c8:	58 05       	cp.w	r5,0
8000a7ca:	e0 8a 00 08 	brle	8000a7da <_dtoa_r+0x99a>
8000a7ce:	08 9b       	mov	r11,r4
8000a7d0:	0a 9a       	mov	r10,r5
8000a7d2:	0e 9c       	mov	r12,r7
8000a7d4:	e0 a0 05 78 	rcall	8000b2c4 <__lshift>
8000a7d8:	18 94       	mov	r4,r12
8000a7da:	40 6b       	lddsp	r11,sp[0x18]
8000a7dc:	58 0b       	cp.w	r11,0
8000a7de:	c0 31       	brne	8000a7e4 <_dtoa_r+0x9a4>
8000a7e0:	08 9c       	mov	r12,r4
8000a7e2:	c1 38       	rjmp	8000a808 <_dtoa_r+0x9c8>
8000a7e4:	68 1b       	ld.w	r11,r4[0x4]
8000a7e6:	0e 9c       	mov	r12,r7
8000a7e8:	e0 a0 04 7e 	rcall	8000b0e4 <_Balloc>
8000a7ec:	68 4a       	ld.w	r10,r4[0x10]
8000a7ee:	18 95       	mov	r5,r12
8000a7f0:	e8 cb ff f4 	sub	r11,r4,-12
8000a7f4:	2f ea       	sub	r10,-2
8000a7f6:	2f 4c       	sub	r12,-12
8000a7f8:	a3 6a       	lsl	r10,0x2
8000a7fa:	fe b0 e3 29 	rcall	80006e4c <memcpy>
8000a7fe:	0a 9b       	mov	r11,r5
8000a800:	30 1a       	mov	r10,1
8000a802:	0e 9c       	mov	r12,r7
8000a804:	e0 a0 05 60 	rcall	8000b2c4 <__lshift>
8000a808:	50 44       	stdsp	sp[0x10],r4
8000a80a:	40 3a       	lddsp	r10,sp[0xc]
8000a80c:	30 19       	mov	r9,1
8000a80e:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a812:	18 94       	mov	r4,r12
8000a814:	50 da       	stdsp	sp[0x34],r10
8000a816:	40 85       	lddsp	r5,sp[0x20]
8000a818:	50 99       	stdsp	sp[0x24],r9
8000a81a:	50 26       	stdsp	sp[0x8],r6
8000a81c:	50 e1       	stdsp	sp[0x38],r1
8000a81e:	04 9b       	mov	r11,r2
8000a820:	06 9c       	mov	r12,r3
8000a822:	fe b0 fa 7f 	rcall	80009d20 <quorem>
8000a826:	40 4b       	lddsp	r11,sp[0x10]
8000a828:	f8 c0 ff d0 	sub	r0,r12,-48
8000a82c:	06 9c       	mov	r12,r3
8000a82e:	e0 a0 04 27 	rcall	8000b07c <__mcmp>
8000a832:	08 9a       	mov	r10,r4
8000a834:	50 6c       	stdsp	sp[0x18],r12
8000a836:	04 9b       	mov	r11,r2
8000a838:	0e 9c       	mov	r12,r7
8000a83a:	e0 a0 04 dd 	rcall	8000b1f4 <__mdiff>
8000a83e:	18 91       	mov	r1,r12
8000a840:	78 38       	ld.w	r8,r12[0xc]
8000a842:	58 08       	cp.w	r8,0
8000a844:	c0 30       	breq	8000a84a <_dtoa_r+0xa0a>
8000a846:	30 16       	mov	r6,1
8000a848:	c0 68       	rjmp	8000a854 <_dtoa_r+0xa14>
8000a84a:	18 9b       	mov	r11,r12
8000a84c:	06 9c       	mov	r12,r3
8000a84e:	e0 a0 04 17 	rcall	8000b07c <__mcmp>
8000a852:	18 96       	mov	r6,r12
8000a854:	0e 9c       	mov	r12,r7
8000a856:	02 9b       	mov	r11,r1
8000a858:	e0 a0 04 2c 	rcall	8000b0b0 <_Bfree>
8000a85c:	40 cc       	lddsp	r12,sp[0x30]
8000a85e:	ed ec 10 08 	or	r8,r6,r12
8000a862:	c0 d1       	brne	8000a87c <_dtoa_r+0xa3c>
8000a864:	40 db       	lddsp	r11,sp[0x34]
8000a866:	58 0b       	cp.w	r11,0
8000a868:	c0 a1       	brne	8000a87c <_dtoa_r+0xa3c>
8000a86a:	40 26       	lddsp	r6,sp[0x8]
8000a86c:	e0 40 00 39 	cp.w	r0,57
8000a870:	c3 00       	breq	8000a8d0 <_dtoa_r+0xa90>
8000a872:	40 6a       	lddsp	r10,sp[0x18]
8000a874:	58 0a       	cp.w	r10,0
8000a876:	e0 89 00 24 	brgt	8000a8be <_dtoa_r+0xa7e>
8000a87a:	c2 f8       	rjmp	8000a8d8 <_dtoa_r+0xa98>
8000a87c:	40 69       	lddsp	r9,sp[0x18]
8000a87e:	58 09       	cp.w	r9,0
8000a880:	c0 85       	brlt	8000a890 <_dtoa_r+0xa50>
8000a882:	12 98       	mov	r8,r9
8000a884:	40 cc       	lddsp	r12,sp[0x30]
8000a886:	18 48       	or	r8,r12
8000a888:	c1 d1       	brne	8000a8c2 <_dtoa_r+0xa82>
8000a88a:	40 db       	lddsp	r11,sp[0x34]
8000a88c:	58 0b       	cp.w	r11,0
8000a88e:	c1 a1       	brne	8000a8c2 <_dtoa_r+0xa82>
8000a890:	0c 99       	mov	r9,r6
8000a892:	40 26       	lddsp	r6,sp[0x8]
8000a894:	58 09       	cp.w	r9,0
8000a896:	e0 8a 00 21 	brle	8000a8d8 <_dtoa_r+0xa98>
8000a89a:	06 9b       	mov	r11,r3
8000a89c:	30 1a       	mov	r10,1
8000a89e:	0e 9c       	mov	r12,r7
8000a8a0:	e0 a0 05 12 	rcall	8000b2c4 <__lshift>
8000a8a4:	04 9b       	mov	r11,r2
8000a8a6:	18 93       	mov	r3,r12
8000a8a8:	e0 a0 03 ea 	rcall	8000b07c <__mcmp>
8000a8ac:	e0 89 00 06 	brgt	8000a8b8 <_dtoa_r+0xa78>
8000a8b0:	c1 41       	brne	8000a8d8 <_dtoa_r+0xa98>
8000a8b2:	ed b0 00 00 	bld	r0,0x0
8000a8b6:	c1 11       	brne	8000a8d8 <_dtoa_r+0xa98>
8000a8b8:	e0 40 00 39 	cp.w	r0,57
8000a8bc:	c0 a0       	breq	8000a8d0 <_dtoa_r+0xa90>
8000a8be:	2f f0       	sub	r0,-1
8000a8c0:	c0 c8       	rjmp	8000a8d8 <_dtoa_r+0xa98>
8000a8c2:	58 06       	cp.w	r6,0
8000a8c4:	e0 8a 00 0c 	brle	8000a8dc <_dtoa_r+0xa9c>
8000a8c8:	40 26       	lddsp	r6,sp[0x8]
8000a8ca:	e0 40 00 39 	cp.w	r0,57
8000a8ce:	c0 41       	brne	8000a8d6 <_dtoa_r+0xa96>
8000a8d0:	33 98       	mov	r8,57
8000a8d2:	0a c8       	st.b	r5++,r8
8000a8d4:	c6 78       	rjmp	8000a9a2 <_dtoa_r+0xb62>
8000a8d6:	2f f0       	sub	r0,-1
8000a8d8:	0a c0       	st.b	r5++,r0
8000a8da:	c7 58       	rjmp	8000a9c4 <_dtoa_r+0xb84>
8000a8dc:	0a c0       	st.b	r5++,r0
8000a8de:	40 9a       	lddsp	r10,sp[0x24]
8000a8e0:	40 e9       	lddsp	r9,sp[0x38]
8000a8e2:	12 3a       	cp.w	r10,r9
8000a8e4:	c4 30       	breq	8000a96a <_dtoa_r+0xb2a>
8000a8e6:	06 9b       	mov	r11,r3
8000a8e8:	30 09       	mov	r9,0
8000a8ea:	30 aa       	mov	r10,10
8000a8ec:	0e 9c       	mov	r12,r7
8000a8ee:	e0 a0 05 b7 	rcall	8000b45c <__multadd>
8000a8f2:	40 48       	lddsp	r8,sp[0x10]
8000a8f4:	18 93       	mov	r3,r12
8000a8f6:	08 38       	cp.w	r8,r4
8000a8f8:	c0 91       	brne	8000a90a <_dtoa_r+0xaca>
8000a8fa:	10 9b       	mov	r11,r8
8000a8fc:	30 09       	mov	r9,0
8000a8fe:	30 aa       	mov	r10,10
8000a900:	0e 9c       	mov	r12,r7
8000a902:	e0 a0 05 ad 	rcall	8000b45c <__multadd>
8000a906:	50 4c       	stdsp	sp[0x10],r12
8000a908:	c0 e8       	rjmp	8000a924 <_dtoa_r+0xae4>
8000a90a:	40 4b       	lddsp	r11,sp[0x10]
8000a90c:	30 09       	mov	r9,0
8000a90e:	30 aa       	mov	r10,10
8000a910:	0e 9c       	mov	r12,r7
8000a912:	e0 a0 05 a5 	rcall	8000b45c <__multadd>
8000a916:	08 9b       	mov	r11,r4
8000a918:	50 4c       	stdsp	sp[0x10],r12
8000a91a:	30 09       	mov	r9,0
8000a91c:	30 aa       	mov	r10,10
8000a91e:	0e 9c       	mov	r12,r7
8000a920:	e0 a0 05 9e 	rcall	8000b45c <__multadd>
8000a924:	18 94       	mov	r4,r12
8000a926:	40 9c       	lddsp	r12,sp[0x24]
8000a928:	2f fc       	sub	r12,-1
8000a92a:	50 9c       	stdsp	sp[0x24],r12
8000a92c:	c7 9b       	rjmp	8000a81e <_dtoa_r+0x9de>
8000a92e:	30 18       	mov	r8,1
8000a930:	06 90       	mov	r0,r3
8000a932:	40 85       	lddsp	r5,sp[0x20]
8000a934:	08 93       	mov	r3,r4
8000a936:	0c 94       	mov	r4,r6
8000a938:	10 96       	mov	r6,r8
8000a93a:	04 9b       	mov	r11,r2
8000a93c:	00 9c       	mov	r12,r0
8000a93e:	fe b0 f9 f1 	rcall	80009d20 <quorem>
8000a942:	2d 0c       	sub	r12,-48
8000a944:	0a cc       	st.b	r5++,r12
8000a946:	02 36       	cp.w	r6,r1
8000a948:	c0 a4       	brge	8000a95c <_dtoa_r+0xb1c>
8000a94a:	00 9b       	mov	r11,r0
8000a94c:	30 09       	mov	r9,0
8000a94e:	30 aa       	mov	r10,10
8000a950:	0e 9c       	mov	r12,r7
8000a952:	2f f6       	sub	r6,-1
8000a954:	e0 a0 05 84 	rcall	8000b45c <__multadd>
8000a958:	18 90       	mov	r0,r12
8000a95a:	cf 0b       	rjmp	8000a93a <_dtoa_r+0xafa>
8000a95c:	08 96       	mov	r6,r4
8000a95e:	30 0b       	mov	r11,0
8000a960:	06 94       	mov	r4,r3
8000a962:	50 4b       	stdsp	sp[0x10],r11
8000a964:	00 93       	mov	r3,r0
8000a966:	18 90       	mov	r0,r12
8000a968:	c0 28       	rjmp	8000a96c <_dtoa_r+0xb2c>
8000a96a:	40 26       	lddsp	r6,sp[0x8]
8000a96c:	06 9b       	mov	r11,r3
8000a96e:	30 1a       	mov	r10,1
8000a970:	0e 9c       	mov	r12,r7
8000a972:	e0 a0 04 a9 	rcall	8000b2c4 <__lshift>
8000a976:	04 9b       	mov	r11,r2
8000a978:	18 93       	mov	r3,r12
8000a97a:	e0 a0 03 81 	rcall	8000b07c <__mcmp>
8000a97e:	e0 89 00 12 	brgt	8000a9a2 <_dtoa_r+0xb62>
8000a982:	c1 b1       	brne	8000a9b8 <_dtoa_r+0xb78>
8000a984:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a988:	c0 d1       	brne	8000a9a2 <_dtoa_r+0xb62>
8000a98a:	c1 78       	rjmp	8000a9b8 <_dtoa_r+0xb78>
8000a98c:	40 89       	lddsp	r9,sp[0x20]
8000a98e:	12 38       	cp.w	r8,r9
8000a990:	c0 30       	breq	8000a996 <_dtoa_r+0xb56>
8000a992:	10 95       	mov	r5,r8
8000a994:	c0 88       	rjmp	8000a9a4 <_dtoa_r+0xb64>
8000a996:	2f f6       	sub	r6,-1
8000a998:	50 66       	stdsp	sp[0x18],r6
8000a99a:	33 18       	mov	r8,49
8000a99c:	40 8c       	lddsp	r12,sp[0x20]
8000a99e:	b8 88       	st.b	r12[0x0],r8
8000a9a0:	c1 38       	rjmp	8000a9c6 <_dtoa_r+0xb86>
8000a9a2:	33 9a       	mov	r10,57
8000a9a4:	0a 98       	mov	r8,r5
8000a9a6:	11 79       	ld.ub	r9,--r8
8000a9a8:	f4 09 18 00 	cp.b	r9,r10
8000a9ac:	cf 00       	breq	8000a98c <_dtoa_r+0xb4c>
8000a9ae:	2f f9       	sub	r9,-1
8000a9b0:	b0 89       	st.b	r8[0x0],r9
8000a9b2:	c0 98       	rjmp	8000a9c4 <_dtoa_r+0xb84>
8000a9b4:	10 95       	mov	r5,r8
8000a9b6:	c0 28       	rjmp	8000a9ba <_dtoa_r+0xb7a>
8000a9b8:	33 09       	mov	r9,48
8000a9ba:	0a 98       	mov	r8,r5
8000a9bc:	11 7a       	ld.ub	r10,--r8
8000a9be:	f2 0a 18 00 	cp.b	r10,r9
8000a9c2:	cf 90       	breq	8000a9b4 <_dtoa_r+0xb74>
8000a9c4:	50 66       	stdsp	sp[0x18],r6
8000a9c6:	04 9b       	mov	r11,r2
8000a9c8:	0e 9c       	mov	r12,r7
8000a9ca:	e0 a0 03 73 	rcall	8000b0b0 <_Bfree>
8000a9ce:	58 04       	cp.w	r4,0
8000a9d0:	c1 20       	breq	8000a9f4 <_dtoa_r+0xbb4>
8000a9d2:	40 4b       	lddsp	r11,sp[0x10]
8000a9d4:	08 3b       	cp.w	r11,r4
8000a9d6:	5f 19       	srne	r9
8000a9d8:	58 0b       	cp.w	r11,0
8000a9da:	5f 18       	srne	r8
8000a9dc:	f3 e8 00 08 	and	r8,r9,r8
8000a9e0:	c0 40       	breq	8000a9e8 <_dtoa_r+0xba8>
8000a9e2:	0e 9c       	mov	r12,r7
8000a9e4:	e0 a0 03 66 	rcall	8000b0b0 <_Bfree>
8000a9e8:	08 9b       	mov	r11,r4
8000a9ea:	0e 9c       	mov	r12,r7
8000a9ec:	e0 a0 03 62 	rcall	8000b0b0 <_Bfree>
8000a9f0:	c0 28       	rjmp	8000a9f4 <_dtoa_r+0xbb4>
8000a9f2:	50 66       	stdsp	sp[0x18],r6
8000a9f4:	0e 9c       	mov	r12,r7
8000a9f6:	06 9b       	mov	r11,r3
8000a9f8:	e0 a0 03 5c 	rcall	8000b0b0 <_Bfree>
8000a9fc:	30 08       	mov	r8,0
8000a9fe:	aa 88       	st.b	r5[0x0],r8
8000aa00:	40 68       	lddsp	r8,sp[0x18]
8000aa02:	41 5a       	lddsp	r10,sp[0x54]
8000aa04:	2f f8       	sub	r8,-1
8000aa06:	41 29       	lddsp	r9,sp[0x48]
8000aa08:	95 08       	st.w	r10[0x0],r8
8000aa0a:	40 8c       	lddsp	r12,sp[0x20]
8000aa0c:	58 09       	cp.w	r9,0
8000aa0e:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000aa12:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000aa16:	2e 6d       	sub	sp,-104
8000aa18:	d8 32       	popm	r0-r7,pc
8000aa1a:	d7 03       	nop

8000aa1c <_fclose_r>:
8000aa1c:	d4 21       	pushm	r4-r7,lr
8000aa1e:	18 96       	mov	r6,r12
8000aa20:	16 97       	mov	r7,r11
8000aa22:	58 0b       	cp.w	r11,0
8000aa24:	c0 31       	brne	8000aa2a <_fclose_r+0xe>
8000aa26:	16 95       	mov	r5,r11
8000aa28:	c5 28       	rjmp	8000aacc <_fclose_r+0xb0>
8000aa2a:	fe b0 e5 91 	rcall	8000754c <__sfp_lock_acquire>
8000aa2e:	58 06       	cp.w	r6,0
8000aa30:	c0 70       	breq	8000aa3e <_fclose_r+0x22>
8000aa32:	6c 68       	ld.w	r8,r6[0x18]
8000aa34:	58 08       	cp.w	r8,0
8000aa36:	c0 41       	brne	8000aa3e <_fclose_r+0x22>
8000aa38:	0c 9c       	mov	r12,r6
8000aa3a:	fe b0 e5 db 	rcall	800075f0 <__sinit>
8000aa3e:	fe c8 e3 06 	sub	r8,pc,-7418
8000aa42:	10 37       	cp.w	r7,r8
8000aa44:	c0 31       	brne	8000aa4a <_fclose_r+0x2e>
8000aa46:	6c 07       	ld.w	r7,r6[0x0]
8000aa48:	c0 c8       	rjmp	8000aa60 <_fclose_r+0x44>
8000aa4a:	fe c8 e2 f2 	sub	r8,pc,-7438
8000aa4e:	10 37       	cp.w	r7,r8
8000aa50:	c0 31       	brne	8000aa56 <_fclose_r+0x3a>
8000aa52:	6c 17       	ld.w	r7,r6[0x4]
8000aa54:	c0 68       	rjmp	8000aa60 <_fclose_r+0x44>
8000aa56:	fe c8 e2 de 	sub	r8,pc,-7458
8000aa5a:	10 37       	cp.w	r7,r8
8000aa5c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000aa60:	8e 69       	ld.sh	r9,r7[0xc]
8000aa62:	30 08       	mov	r8,0
8000aa64:	f0 09 19 00 	cp.h	r9,r8
8000aa68:	c0 51       	brne	8000aa72 <_fclose_r+0x56>
8000aa6a:	fe b0 e5 72 	rcall	8000754e <__sfp_lock_release>
8000aa6e:	30 05       	mov	r5,0
8000aa70:	c2 e8       	rjmp	8000aacc <_fclose_r+0xb0>
8000aa72:	0e 9b       	mov	r11,r7
8000aa74:	0c 9c       	mov	r12,r6
8000aa76:	c3 5c       	rcall	8000aae0 <_fflush_r>
8000aa78:	6e c8       	ld.w	r8,r7[0x30]
8000aa7a:	18 95       	mov	r5,r12
8000aa7c:	58 08       	cp.w	r8,0
8000aa7e:	c0 60       	breq	8000aa8a <_fclose_r+0x6e>
8000aa80:	6e 8b       	ld.w	r11,r7[0x20]
8000aa82:	0c 9c       	mov	r12,r6
8000aa84:	5d 18       	icall	r8
8000aa86:	f9 b5 05 ff 	movlt	r5,-1
8000aa8a:	8e 68       	ld.sh	r8,r7[0xc]
8000aa8c:	ed b8 00 07 	bld	r8,0x7
8000aa90:	c0 51       	brne	8000aa9a <_fclose_r+0x7e>
8000aa92:	6e 4b       	ld.w	r11,r7[0x10]
8000aa94:	0c 9c       	mov	r12,r6
8000aa96:	fe b0 e6 47 	rcall	80007724 <_free_r>
8000aa9a:	6e db       	ld.w	r11,r7[0x34]
8000aa9c:	58 0b       	cp.w	r11,0
8000aa9e:	c0 a0       	breq	8000aab2 <_fclose_r+0x96>
8000aaa0:	ee c8 ff bc 	sub	r8,r7,-68
8000aaa4:	10 3b       	cp.w	r11,r8
8000aaa6:	c0 40       	breq	8000aaae <_fclose_r+0x92>
8000aaa8:	0c 9c       	mov	r12,r6
8000aaaa:	fe b0 e6 3d 	rcall	80007724 <_free_r>
8000aaae:	30 08       	mov	r8,0
8000aab0:	8f d8       	st.w	r7[0x34],r8
8000aab2:	6f 2b       	ld.w	r11,r7[0x48]
8000aab4:	58 0b       	cp.w	r11,0
8000aab6:	c0 70       	breq	8000aac4 <_fclose_r+0xa8>
8000aab8:	0c 9c       	mov	r12,r6
8000aaba:	fe b0 e6 35 	rcall	80007724 <_free_r>
8000aabe:	30 08       	mov	r8,0
8000aac0:	ef 48 00 48 	st.w	r7[72],r8
8000aac4:	30 08       	mov	r8,0
8000aac6:	ae 68       	st.h	r7[0xc],r8
8000aac8:	fe b0 e5 43 	rcall	8000754e <__sfp_lock_release>
8000aacc:	0a 9c       	mov	r12,r5
8000aace:	d8 22       	popm	r4-r7,pc

8000aad0 <fclose>:
8000aad0:	d4 01       	pushm	lr
8000aad2:	e0 68 01 18 	mov	r8,280
8000aad6:	18 9b       	mov	r11,r12
8000aad8:	70 0c       	ld.w	r12,r8[0x0]
8000aada:	ca 1f       	rcall	8000aa1c <_fclose_r>
8000aadc:	d8 02       	popm	pc
8000aade:	d7 03       	nop

8000aae0 <_fflush_r>:
8000aae0:	d4 21       	pushm	r4-r7,lr
8000aae2:	16 97       	mov	r7,r11
8000aae4:	18 96       	mov	r6,r12
8000aae6:	76 48       	ld.w	r8,r11[0x10]
8000aae8:	58 08       	cp.w	r8,0
8000aaea:	e0 80 00 81 	breq	8000abec <_fflush_r+0x10c>
8000aaee:	58 0c       	cp.w	r12,0
8000aaf0:	c0 60       	breq	8000aafc <_fflush_r+0x1c>
8000aaf2:	78 68       	ld.w	r8,r12[0x18]
8000aaf4:	58 08       	cp.w	r8,0
8000aaf6:	c0 31       	brne	8000aafc <_fflush_r+0x1c>
8000aaf8:	fe b0 e5 7c 	rcall	800075f0 <__sinit>
8000aafc:	fe c8 e3 c4 	sub	r8,pc,-7228
8000ab00:	10 37       	cp.w	r7,r8
8000ab02:	c0 31       	brne	8000ab08 <_fflush_r+0x28>
8000ab04:	6c 07       	ld.w	r7,r6[0x0]
8000ab06:	c0 c8       	rjmp	8000ab1e <_fflush_r+0x3e>
8000ab08:	fe c8 e3 b0 	sub	r8,pc,-7248
8000ab0c:	10 37       	cp.w	r7,r8
8000ab0e:	c0 31       	brne	8000ab14 <_fflush_r+0x34>
8000ab10:	6c 17       	ld.w	r7,r6[0x4]
8000ab12:	c0 68       	rjmp	8000ab1e <_fflush_r+0x3e>
8000ab14:	fe c8 e3 9c 	sub	r8,pc,-7268
8000ab18:	10 37       	cp.w	r7,r8
8000ab1a:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ab1e:	8e 6a       	ld.sh	r10,r7[0xc]
8000ab20:	14 98       	mov	r8,r10
8000ab22:	ed ba 00 03 	bld	r10,0x3
8000ab26:	c4 20       	breq	8000abaa <_fflush_r+0xca>
8000ab28:	ab ba       	sbr	r10,0xb
8000ab2a:	ae 6a       	st.h	r7[0xc],r10
8000ab2c:	6e 18       	ld.w	r8,r7[0x4]
8000ab2e:	58 08       	cp.w	r8,0
8000ab30:	e0 89 00 06 	brgt	8000ab3c <_fflush_r+0x5c>
8000ab34:	6f 08       	ld.w	r8,r7[0x40]
8000ab36:	58 08       	cp.w	r8,0
8000ab38:	e0 8a 00 5a 	brle	8000abec <_fflush_r+0x10c>
8000ab3c:	6e b8       	ld.w	r8,r7[0x2c]
8000ab3e:	58 08       	cp.w	r8,0
8000ab40:	c5 60       	breq	8000abec <_fflush_r+0x10c>
8000ab42:	e2 1a 10 00 	andl	r10,0x1000,COH
8000ab46:	c0 30       	breq	8000ab4c <_fflush_r+0x6c>
8000ab48:	6f 55       	ld.w	r5,r7[0x54]
8000ab4a:	c0 f8       	rjmp	8000ab68 <_fflush_r+0x88>
8000ab4c:	30 19       	mov	r9,1
8000ab4e:	6e 8b       	ld.w	r11,r7[0x20]
8000ab50:	0c 9c       	mov	r12,r6
8000ab52:	5d 18       	icall	r8
8000ab54:	18 95       	mov	r5,r12
8000ab56:	5b fc       	cp.w	r12,-1
8000ab58:	c0 81       	brne	8000ab68 <_fflush_r+0x88>
8000ab5a:	6c 38       	ld.w	r8,r6[0xc]
8000ab5c:	59 d8       	cp.w	r8,29
8000ab5e:	c4 70       	breq	8000abec <_fflush_r+0x10c>
8000ab60:	8e 68       	ld.sh	r8,r7[0xc]
8000ab62:	a7 a8       	sbr	r8,0x6
8000ab64:	ae 68       	st.h	r7[0xc],r8
8000ab66:	d8 22       	popm	r4-r7,pc
8000ab68:	8e 68       	ld.sh	r8,r7[0xc]
8000ab6a:	ed b8 00 02 	bld	r8,0x2
8000ab6e:	c0 91       	brne	8000ab80 <_fflush_r+0xa0>
8000ab70:	6e 18       	ld.w	r8,r7[0x4]
8000ab72:	10 15       	sub	r5,r8
8000ab74:	6e d8       	ld.w	r8,r7[0x34]
8000ab76:	58 08       	cp.w	r8,0
8000ab78:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000ab7c:	eb d8 e1 15 	subne	r5,r5,r8
8000ab80:	6e b8       	ld.w	r8,r7[0x2c]
8000ab82:	0c 9c       	mov	r12,r6
8000ab84:	30 09       	mov	r9,0
8000ab86:	0a 9a       	mov	r10,r5
8000ab88:	6e 8b       	ld.w	r11,r7[0x20]
8000ab8a:	5d 18       	icall	r8
8000ab8c:	8e 68       	ld.sh	r8,r7[0xc]
8000ab8e:	0a 3c       	cp.w	r12,r5
8000ab90:	c2 61       	brne	8000abdc <_fflush_r+0xfc>
8000ab92:	ab d8       	cbr	r8,0xb
8000ab94:	30 0c       	mov	r12,0
8000ab96:	6e 49       	ld.w	r9,r7[0x10]
8000ab98:	ae 68       	st.h	r7[0xc],r8
8000ab9a:	8f 1c       	st.w	r7[0x4],r12
8000ab9c:	8f 09       	st.w	r7[0x0],r9
8000ab9e:	ed b8 00 0c 	bld	r8,0xc
8000aba2:	c2 51       	brne	8000abec <_fflush_r+0x10c>
8000aba4:	ef 45 00 54 	st.w	r7[84],r5
8000aba8:	d8 22       	popm	r4-r7,pc
8000abaa:	6e 45       	ld.w	r5,r7[0x10]
8000abac:	58 05       	cp.w	r5,0
8000abae:	c1 f0       	breq	8000abec <_fflush_r+0x10c>
8000abb0:	6e 04       	ld.w	r4,r7[0x0]
8000abb2:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000abb6:	8f 05       	st.w	r7[0x0],r5
8000abb8:	f9 b8 01 00 	movne	r8,0
8000abbc:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000abc0:	0a 14       	sub	r4,r5
8000abc2:	8f 28       	st.w	r7[0x8],r8
8000abc4:	c1 18       	rjmp	8000abe6 <_fflush_r+0x106>
8000abc6:	08 99       	mov	r9,r4
8000abc8:	0a 9a       	mov	r10,r5
8000abca:	6e a8       	ld.w	r8,r7[0x28]
8000abcc:	6e 8b       	ld.w	r11,r7[0x20]
8000abce:	0c 9c       	mov	r12,r6
8000abd0:	5d 18       	icall	r8
8000abd2:	18 14       	sub	r4,r12
8000abd4:	58 0c       	cp.w	r12,0
8000abd6:	e0 89 00 07 	brgt	8000abe4 <_fflush_r+0x104>
8000abda:	8e 68       	ld.sh	r8,r7[0xc]
8000abdc:	a7 a8       	sbr	r8,0x6
8000abde:	3f fc       	mov	r12,-1
8000abe0:	ae 68       	st.h	r7[0xc],r8
8000abe2:	d8 22       	popm	r4-r7,pc
8000abe4:	18 05       	add	r5,r12
8000abe6:	58 04       	cp.w	r4,0
8000abe8:	fe 99 ff ef 	brgt	8000abc6 <_fflush_r+0xe6>
8000abec:	d8 2a       	popm	r4-r7,pc,r12=0
8000abee:	d7 03       	nop

8000abf0 <__sfvwrite_r>:
8000abf0:	d4 31       	pushm	r0-r7,lr
8000abf2:	20 3d       	sub	sp,12
8000abf4:	14 94       	mov	r4,r10
8000abf6:	18 95       	mov	r5,r12
8000abf8:	16 97       	mov	r7,r11
8000abfa:	74 28       	ld.w	r8,r10[0x8]
8000abfc:	58 08       	cp.w	r8,0
8000abfe:	e0 80 01 43 	breq	8000ae84 <__sfvwrite_r+0x294>
8000ac02:	96 68       	ld.sh	r8,r11[0xc]
8000ac04:	ed b8 00 03 	bld	r8,0x3
8000ac08:	c0 41       	brne	8000ac10 <__sfvwrite_r+0x20>
8000ac0a:	76 48       	ld.w	r8,r11[0x10]
8000ac0c:	58 08       	cp.w	r8,0
8000ac0e:	c0 c1       	brne	8000ac26 <__sfvwrite_r+0x36>
8000ac10:	0e 9b       	mov	r11,r7
8000ac12:	0a 9c       	mov	r12,r5
8000ac14:	fe b0 f8 08 	rcall	80009c24 <__swsetup_r>
8000ac18:	c0 70       	breq	8000ac26 <__sfvwrite_r+0x36>
8000ac1a:	8e 68       	ld.sh	r8,r7[0xc]
8000ac1c:	a7 a8       	sbr	r8,0x6
8000ac1e:	ae 68       	st.h	r7[0xc],r8
8000ac20:	30 98       	mov	r8,9
8000ac22:	8b 38       	st.w	r5[0xc],r8
8000ac24:	c2 e9       	rjmp	8000ae80 <__sfvwrite_r+0x290>
8000ac26:	8e 63       	ld.sh	r3,r7[0xc]
8000ac28:	68 00       	ld.w	r0,r4[0x0]
8000ac2a:	06 96       	mov	r6,r3
8000ac2c:	e2 16 00 02 	andl	r6,0x2,COH
8000ac30:	c2 10       	breq	8000ac72 <__sfvwrite_r+0x82>
8000ac32:	30 03       	mov	r3,0
8000ac34:	e0 62 04 00 	mov	r2,1024
8000ac38:	06 96       	mov	r6,r3
8000ac3a:	c0 48       	rjmp	8000ac42 <__sfvwrite_r+0x52>
8000ac3c:	60 03       	ld.w	r3,r0[0x0]
8000ac3e:	60 16       	ld.w	r6,r0[0x4]
8000ac40:	2f 80       	sub	r0,-8
8000ac42:	58 06       	cp.w	r6,0
8000ac44:	cf c0       	breq	8000ac3c <__sfvwrite_r+0x4c>
8000ac46:	e0 46 04 00 	cp.w	r6,1024
8000ac4a:	ec 09 17 80 	movls	r9,r6
8000ac4e:	e4 09 17 b0 	movhi	r9,r2
8000ac52:	06 9a       	mov	r10,r3
8000ac54:	6e a8       	ld.w	r8,r7[0x28]
8000ac56:	6e 8b       	ld.w	r11,r7[0x20]
8000ac58:	0a 9c       	mov	r12,r5
8000ac5a:	5d 18       	icall	r8
8000ac5c:	18 16       	sub	r6,r12
8000ac5e:	58 0c       	cp.w	r12,0
8000ac60:	e0 8a 01 0d 	brle	8000ae7a <__sfvwrite_r+0x28a>
8000ac64:	68 28       	ld.w	r8,r4[0x8]
8000ac66:	18 18       	sub	r8,r12
8000ac68:	89 28       	st.w	r4[0x8],r8
8000ac6a:	e0 80 01 0d 	breq	8000ae84 <__sfvwrite_r+0x294>
8000ac6e:	18 03       	add	r3,r12
8000ac70:	ce 9b       	rjmp	8000ac42 <__sfvwrite_r+0x52>
8000ac72:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000ac76:	c0 70       	breq	8000ac84 <__sfvwrite_r+0x94>
8000ac78:	50 06       	stdsp	sp[0x0],r6
8000ac7a:	0c 93       	mov	r3,r6
8000ac7c:	0c 91       	mov	r1,r6
8000ac7e:	50 15       	stdsp	sp[0x4],r5
8000ac80:	08 92       	mov	r2,r4
8000ac82:	c9 f8       	rjmp	8000adc0 <__sfvwrite_r+0x1d0>
8000ac84:	06 96       	mov	r6,r3
8000ac86:	08 91       	mov	r1,r4
8000ac88:	c0 48       	rjmp	8000ac90 <__sfvwrite_r+0xa0>
8000ac8a:	60 03       	ld.w	r3,r0[0x0]
8000ac8c:	60 16       	ld.w	r6,r0[0x4]
8000ac8e:	2f 80       	sub	r0,-8
8000ac90:	58 06       	cp.w	r6,0
8000ac92:	cf c0       	breq	8000ac8a <__sfvwrite_r+0x9a>
8000ac94:	8e 68       	ld.sh	r8,r7[0xc]
8000ac96:	6e 24       	ld.w	r4,r7[0x8]
8000ac98:	10 99       	mov	r9,r8
8000ac9a:	e2 19 02 00 	andl	r9,0x200,COH
8000ac9e:	c5 70       	breq	8000ad4c <__sfvwrite_r+0x15c>
8000aca0:	08 36       	cp.w	r6,r4
8000aca2:	c4 53       	brcs	8000ad2c <__sfvwrite_r+0x13c>
8000aca4:	10 99       	mov	r9,r8
8000aca6:	e2 19 04 80 	andl	r9,0x480,COH
8000acaa:	c4 10       	breq	8000ad2c <__sfvwrite_r+0x13c>
8000acac:	6e 4b       	ld.w	r11,r7[0x10]
8000acae:	6e 09       	ld.w	r9,r7[0x0]
8000acb0:	16 19       	sub	r9,r11
8000acb2:	50 09       	stdsp	sp[0x0],r9
8000acb4:	6e 59       	ld.w	r9,r7[0x14]
8000acb6:	10 9c       	mov	r12,r8
8000acb8:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000acbc:	30 28       	mov	r8,2
8000acbe:	f4 08 0c 08 	divs	r8,r10,r8
8000acc2:	fa e9 00 04 	st.d	sp[4],r8
8000acc6:	10 94       	mov	r4,r8
8000acc8:	40 09       	lddsp	r9,sp[0x0]
8000acca:	e2 1c 04 00 	andl	r12,0x400,COH
8000acce:	2f f9       	sub	r9,-1
8000acd0:	0c 09       	add	r9,r6
8000acd2:	12 38       	cp.w	r8,r9
8000acd4:	f2 04 17 30 	movlo	r4,r9
8000acd8:	58 0c       	cp.w	r12,0
8000acda:	c1 10       	breq	8000acfc <__sfvwrite_r+0x10c>
8000acdc:	08 9b       	mov	r11,r4
8000acde:	0a 9c       	mov	r12,r5
8000ace0:	fe b0 de 9a 	rcall	80006a14 <_malloc_r>
8000ace4:	18 92       	mov	r2,r12
8000ace6:	c1 50       	breq	8000ad10 <__sfvwrite_r+0x120>
8000ace8:	40 0a       	lddsp	r10,sp[0x0]
8000acea:	6e 4b       	ld.w	r11,r7[0x10]
8000acec:	fe b0 e0 b0 	rcall	80006e4c <memcpy>
8000acf0:	8e 68       	ld.sh	r8,r7[0xc]
8000acf2:	e0 18 fb 7f 	andl	r8,0xfb7f
8000acf6:	a7 b8       	sbr	r8,0x7
8000acf8:	ae 68       	st.h	r7[0xc],r8
8000acfa:	c0 e8       	rjmp	8000ad16 <__sfvwrite_r+0x126>
8000acfc:	08 9a       	mov	r10,r4
8000acfe:	0a 9c       	mov	r12,r5
8000ad00:	fe b0 e1 52 	rcall	80006fa4 <_realloc_r>
8000ad04:	18 92       	mov	r2,r12
8000ad06:	c0 81       	brne	8000ad16 <__sfvwrite_r+0x126>
8000ad08:	6e 4b       	ld.w	r11,r7[0x10]
8000ad0a:	0a 9c       	mov	r12,r5
8000ad0c:	fe b0 e5 0c 	rcall	80007724 <_free_r>
8000ad10:	30 c8       	mov	r8,12
8000ad12:	8b 38       	st.w	r5[0xc],r8
8000ad14:	cb 38       	rjmp	8000ae7a <__sfvwrite_r+0x28a>
8000ad16:	40 0a       	lddsp	r10,sp[0x0]
8000ad18:	40 09       	lddsp	r9,sp[0x0]
8000ad1a:	e8 0a 01 0a 	sub	r10,r4,r10
8000ad1e:	e4 09 00 08 	add	r8,r2,r9
8000ad22:	8f 54       	st.w	r7[0x14],r4
8000ad24:	8f 2a       	st.w	r7[0x8],r10
8000ad26:	8f 08       	st.w	r7[0x0],r8
8000ad28:	8f 42       	st.w	r7[0x10],r2
8000ad2a:	0c 94       	mov	r4,r6
8000ad2c:	08 36       	cp.w	r6,r4
8000ad2e:	ec 04 17 30 	movlo	r4,r6
8000ad32:	06 9b       	mov	r11,r3
8000ad34:	08 9a       	mov	r10,r4
8000ad36:	6e 0c       	ld.w	r12,r7[0x0]
8000ad38:	fe b0 e5 e0 	rcall	800078f8 <memmove>
8000ad3c:	6e 08       	ld.w	r8,r7[0x0]
8000ad3e:	08 08       	add	r8,r4
8000ad40:	8f 08       	st.w	r7[0x0],r8
8000ad42:	6e 28       	ld.w	r8,r7[0x8]
8000ad44:	08 18       	sub	r8,r4
8000ad46:	0c 94       	mov	r4,r6
8000ad48:	8f 28       	st.w	r7[0x8],r8
8000ad4a:	c2 f8       	rjmp	8000ada8 <__sfvwrite_r+0x1b8>
8000ad4c:	08 36       	cp.w	r6,r4
8000ad4e:	5f ba       	srhi	r10
8000ad50:	6e 0c       	ld.w	r12,r7[0x0]
8000ad52:	6e 48       	ld.w	r8,r7[0x10]
8000ad54:	10 3c       	cp.w	r12,r8
8000ad56:	5f b8       	srhi	r8
8000ad58:	f5 e8 00 08 	and	r8,r10,r8
8000ad5c:	f2 08 18 00 	cp.b	r8,r9
8000ad60:	c0 d0       	breq	8000ad7a <__sfvwrite_r+0x18a>
8000ad62:	06 9b       	mov	r11,r3
8000ad64:	08 9a       	mov	r10,r4
8000ad66:	fe b0 e5 c9 	rcall	800078f8 <memmove>
8000ad6a:	6e 08       	ld.w	r8,r7[0x0]
8000ad6c:	08 08       	add	r8,r4
8000ad6e:	0e 9b       	mov	r11,r7
8000ad70:	8f 08       	st.w	r7[0x0],r8
8000ad72:	0a 9c       	mov	r12,r5
8000ad74:	cb 6e       	rcall	8000aae0 <_fflush_r>
8000ad76:	c1 90       	breq	8000ada8 <__sfvwrite_r+0x1b8>
8000ad78:	c8 18       	rjmp	8000ae7a <__sfvwrite_r+0x28a>
8000ad7a:	6e 59       	ld.w	r9,r7[0x14]
8000ad7c:	12 36       	cp.w	r6,r9
8000ad7e:	c0 a3       	brcs	8000ad92 <__sfvwrite_r+0x1a2>
8000ad80:	6e a8       	ld.w	r8,r7[0x28]
8000ad82:	06 9a       	mov	r10,r3
8000ad84:	6e 8b       	ld.w	r11,r7[0x20]
8000ad86:	0a 9c       	mov	r12,r5
8000ad88:	5d 18       	icall	r8
8000ad8a:	18 94       	mov	r4,r12
8000ad8c:	e0 89 00 0e 	brgt	8000ada8 <__sfvwrite_r+0x1b8>
8000ad90:	c7 58       	rjmp	8000ae7a <__sfvwrite_r+0x28a>
8000ad92:	0c 9a       	mov	r10,r6
8000ad94:	06 9b       	mov	r11,r3
8000ad96:	fe b0 e5 b1 	rcall	800078f8 <memmove>
8000ad9a:	6e 08       	ld.w	r8,r7[0x0]
8000ad9c:	0c 08       	add	r8,r6
8000ad9e:	0c 94       	mov	r4,r6
8000ada0:	8f 08       	st.w	r7[0x0],r8
8000ada2:	6e 28       	ld.w	r8,r7[0x8]
8000ada4:	0c 18       	sub	r8,r6
8000ada6:	8f 28       	st.w	r7[0x8],r8
8000ada8:	62 28       	ld.w	r8,r1[0x8]
8000adaa:	08 18       	sub	r8,r4
8000adac:	83 28       	st.w	r1[0x8],r8
8000adae:	c6 b0       	breq	8000ae84 <__sfvwrite_r+0x294>
8000adb0:	08 16       	sub	r6,r4
8000adb2:	08 03       	add	r3,r4
8000adb4:	c6 eb       	rjmp	8000ac90 <__sfvwrite_r+0xa0>
8000adb6:	60 03       	ld.w	r3,r0[0x0]
8000adb8:	60 11       	ld.w	r1,r0[0x4]
8000adba:	30 08       	mov	r8,0
8000adbc:	2f 80       	sub	r0,-8
8000adbe:	50 08       	stdsp	sp[0x0],r8
8000adc0:	58 01       	cp.w	r1,0
8000adc2:	cf a0       	breq	8000adb6 <__sfvwrite_r+0x1c6>
8000adc4:	40 0a       	lddsp	r10,sp[0x0]
8000adc6:	58 0a       	cp.w	r10,0
8000adc8:	c1 41       	brne	8000adf0 <__sfvwrite_r+0x200>
8000adca:	e2 c6 ff ff 	sub	r6,r1,-1
8000adce:	02 9a       	mov	r10,r1
8000add0:	30 ab       	mov	r11,10
8000add2:	06 9c       	mov	r12,r3
8000add4:	cd 2c       	rcall	8000af78 <memchr>
8000add6:	f8 c8 ff ff 	sub	r8,r12,-1
8000adda:	58 0c       	cp.w	r12,0
8000addc:	f1 d3 e1 16 	subne	r6,r8,r3
8000ade0:	f9 b9 01 01 	movne	r9,1
8000ade4:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ade8:	f9 b8 00 01 	moveq	r8,1
8000adec:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000adf0:	02 36       	cp.w	r6,r1
8000adf2:	ec 04 17 80 	movls	r4,r6
8000adf6:	e2 04 17 b0 	movhi	r4,r1
8000adfa:	6e 59       	ld.w	r9,r7[0x14]
8000adfc:	6e 25       	ld.w	r5,r7[0x8]
8000adfe:	f2 05 00 05 	add	r5,r9,r5
8000ae02:	0a 34       	cp.w	r4,r5
8000ae04:	5f 9a       	srgt	r10
8000ae06:	6e 0c       	ld.w	r12,r7[0x0]
8000ae08:	6e 48       	ld.w	r8,r7[0x10]
8000ae0a:	10 3c       	cp.w	r12,r8
8000ae0c:	5f b8       	srhi	r8
8000ae0e:	f5 e8 00 08 	and	r8,r10,r8
8000ae12:	30 0a       	mov	r10,0
8000ae14:	f4 08 18 00 	cp.b	r8,r10
8000ae18:	c0 d0       	breq	8000ae32 <__sfvwrite_r+0x242>
8000ae1a:	06 9b       	mov	r11,r3
8000ae1c:	0a 9a       	mov	r10,r5
8000ae1e:	fe b0 e5 6d 	rcall	800078f8 <memmove>
8000ae22:	6e 08       	ld.w	r8,r7[0x0]
8000ae24:	0a 08       	add	r8,r5
8000ae26:	0e 9b       	mov	r11,r7
8000ae28:	8f 08       	st.w	r7[0x0],r8
8000ae2a:	40 1c       	lddsp	r12,sp[0x4]
8000ae2c:	c5 ae       	rcall	8000aae0 <_fflush_r>
8000ae2e:	c1 80       	breq	8000ae5e <__sfvwrite_r+0x26e>
8000ae30:	c2 58       	rjmp	8000ae7a <__sfvwrite_r+0x28a>
8000ae32:	12 34       	cp.w	r4,r9
8000ae34:	c0 a5       	brlt	8000ae48 <__sfvwrite_r+0x258>
8000ae36:	6e a8       	ld.w	r8,r7[0x28]
8000ae38:	06 9a       	mov	r10,r3
8000ae3a:	6e 8b       	ld.w	r11,r7[0x20]
8000ae3c:	40 1c       	lddsp	r12,sp[0x4]
8000ae3e:	5d 18       	icall	r8
8000ae40:	18 95       	mov	r5,r12
8000ae42:	e0 89 00 0e 	brgt	8000ae5e <__sfvwrite_r+0x26e>
8000ae46:	c1 a8       	rjmp	8000ae7a <__sfvwrite_r+0x28a>
8000ae48:	08 9a       	mov	r10,r4
8000ae4a:	06 9b       	mov	r11,r3
8000ae4c:	fe b0 e5 56 	rcall	800078f8 <memmove>
8000ae50:	6e 08       	ld.w	r8,r7[0x0]
8000ae52:	08 08       	add	r8,r4
8000ae54:	08 95       	mov	r5,r4
8000ae56:	8f 08       	st.w	r7[0x0],r8
8000ae58:	6e 28       	ld.w	r8,r7[0x8]
8000ae5a:	08 18       	sub	r8,r4
8000ae5c:	8f 28       	st.w	r7[0x8],r8
8000ae5e:	0a 16       	sub	r6,r5
8000ae60:	c0 61       	brne	8000ae6c <__sfvwrite_r+0x27c>
8000ae62:	0e 9b       	mov	r11,r7
8000ae64:	40 1c       	lddsp	r12,sp[0x4]
8000ae66:	c3 de       	rcall	8000aae0 <_fflush_r>
8000ae68:	c0 91       	brne	8000ae7a <__sfvwrite_r+0x28a>
8000ae6a:	50 06       	stdsp	sp[0x0],r6
8000ae6c:	64 28       	ld.w	r8,r2[0x8]
8000ae6e:	0a 18       	sub	r8,r5
8000ae70:	85 28       	st.w	r2[0x8],r8
8000ae72:	c0 90       	breq	8000ae84 <__sfvwrite_r+0x294>
8000ae74:	0a 11       	sub	r1,r5
8000ae76:	0a 03       	add	r3,r5
8000ae78:	ca 4b       	rjmp	8000adc0 <__sfvwrite_r+0x1d0>
8000ae7a:	8e 68       	ld.sh	r8,r7[0xc]
8000ae7c:	a7 a8       	sbr	r8,0x6
8000ae7e:	ae 68       	st.h	r7[0xc],r8
8000ae80:	3f fc       	mov	r12,-1
8000ae82:	c0 28       	rjmp	8000ae86 <__sfvwrite_r+0x296>
8000ae84:	30 0c       	mov	r12,0
8000ae86:	2f dd       	sub	sp,-12
8000ae88:	d8 32       	popm	r0-r7,pc
8000ae8a:	d7 03       	nop

8000ae8c <_localeconv_r>:
8000ae8c:	fe cc e3 10 	sub	r12,pc,-7408
8000ae90:	5e fc       	retal	r12
8000ae92:	d7 03       	nop

8000ae94 <_lseek_r>:
8000ae94:	d4 21       	pushm	r4-r7,lr
8000ae96:	16 98       	mov	r8,r11
8000ae98:	18 97       	mov	r7,r12
8000ae9a:	10 9c       	mov	r12,r8
8000ae9c:	30 08       	mov	r8,0
8000ae9e:	14 9b       	mov	r11,r10
8000aea0:	e0 66 07 fc 	mov	r6,2044
8000aea4:	12 9a       	mov	r10,r9
8000aea6:	8d 08       	st.w	r6[0x0],r8
8000aea8:	fe b0 e2 12 	rcall	800072cc <_lseek>
8000aeac:	5b fc       	cp.w	r12,-1
8000aeae:	c0 51       	brne	8000aeb8 <_lseek_r+0x24>
8000aeb0:	6c 08       	ld.w	r8,r6[0x0]
8000aeb2:	58 08       	cp.w	r8,0
8000aeb4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000aeb8:	d8 22       	popm	r4-r7,pc
8000aeba:	d7 03       	nop

8000aebc <__smakebuf_r>:
8000aebc:	d4 21       	pushm	r4-r7,lr
8000aebe:	20 fd       	sub	sp,60
8000aec0:	96 68       	ld.sh	r8,r11[0xc]
8000aec2:	16 97       	mov	r7,r11
8000aec4:	18 96       	mov	r6,r12
8000aec6:	e2 18 00 02 	andl	r8,0x2,COH
8000aeca:	c3 d1       	brne	8000af44 <__smakebuf_r+0x88>
8000aecc:	96 7b       	ld.sh	r11,r11[0xe]
8000aece:	f0 0b 19 00 	cp.h	r11,r8
8000aed2:	c0 55       	brlt	8000aedc <__smakebuf_r+0x20>
8000aed4:	1a 9a       	mov	r10,sp
8000aed6:	e0 a0 03 b5 	rcall	8000b640 <_fstat_r>
8000aeda:	c0 f4       	brge	8000aef8 <__smakebuf_r+0x3c>
8000aedc:	8e 65       	ld.sh	r5,r7[0xc]
8000aede:	0a 98       	mov	r8,r5
8000aee0:	ab b8       	sbr	r8,0xb
8000aee2:	e2 15 00 80 	andl	r5,0x80,COH
8000aee6:	ae 68       	st.h	r7[0xc],r8
8000aee8:	30 04       	mov	r4,0
8000aeea:	e0 68 04 00 	mov	r8,1024
8000aeee:	f9 b5 01 40 	movne	r5,64
8000aef2:	f0 05 17 00 	moveq	r5,r8
8000aef6:	c1 c8       	rjmp	8000af2e <__smakebuf_r+0x72>
8000aef8:	40 18       	lddsp	r8,sp[0x4]
8000aefa:	e2 18 f0 00 	andl	r8,0xf000,COH
8000aefe:	e0 48 20 00 	cp.w	r8,8192
8000af02:	5f 04       	sreq	r4
8000af04:	e0 48 80 00 	cp.w	r8,32768
8000af08:	c0 e1       	brne	8000af24 <__smakebuf_r+0x68>
8000af0a:	6e b9       	ld.w	r9,r7[0x2c]
8000af0c:	fe c8 35 c8 	sub	r8,pc,13768
8000af10:	10 39       	cp.w	r9,r8
8000af12:	c0 91       	brne	8000af24 <__smakebuf_r+0x68>
8000af14:	8e 68       	ld.sh	r8,r7[0xc]
8000af16:	e0 65 04 00 	mov	r5,1024
8000af1a:	ab a8       	sbr	r8,0xa
8000af1c:	ef 45 00 50 	st.w	r7[80],r5
8000af20:	ae 68       	st.h	r7[0xc],r8
8000af22:	c0 68       	rjmp	8000af2e <__smakebuf_r+0x72>
8000af24:	8e 68       	ld.sh	r8,r7[0xc]
8000af26:	e0 65 04 00 	mov	r5,1024
8000af2a:	ab b8       	sbr	r8,0xb
8000af2c:	ae 68       	st.h	r7[0xc],r8
8000af2e:	0a 9b       	mov	r11,r5
8000af30:	0c 9c       	mov	r12,r6
8000af32:	fe b0 dd 71 	rcall	80006a14 <_malloc_r>
8000af36:	8e 68       	ld.sh	r8,r7[0xc]
8000af38:	c0 d1       	brne	8000af52 <__smakebuf_r+0x96>
8000af3a:	ed b8 00 09 	bld	r8,0x9
8000af3e:	c1 b0       	breq	8000af74 <__smakebuf_r+0xb8>
8000af40:	a1 b8       	sbr	r8,0x1
8000af42:	ae 68       	st.h	r7[0xc],r8
8000af44:	ee c8 ff b9 	sub	r8,r7,-71
8000af48:	8f 48       	st.w	r7[0x10],r8
8000af4a:	8f 08       	st.w	r7[0x0],r8
8000af4c:	30 18       	mov	r8,1
8000af4e:	8f 58       	st.w	r7[0x14],r8
8000af50:	c1 28       	rjmp	8000af74 <__smakebuf_r+0xb8>
8000af52:	a7 b8       	sbr	r8,0x7
8000af54:	8f 4c       	st.w	r7[0x10],r12
8000af56:	ae 68       	st.h	r7[0xc],r8
8000af58:	8f 55       	st.w	r7[0x14],r5
8000af5a:	fe c8 3a 0a 	sub	r8,pc,14858
8000af5e:	8f 0c       	st.w	r7[0x0],r12
8000af60:	8d a8       	st.w	r6[0x28],r8
8000af62:	58 04       	cp.w	r4,0
8000af64:	c0 80       	breq	8000af74 <__smakebuf_r+0xb8>
8000af66:	8e 7c       	ld.sh	r12,r7[0xe]
8000af68:	fe b0 e1 bc 	rcall	800072e0 <isatty>
8000af6c:	c0 40       	breq	8000af74 <__smakebuf_r+0xb8>
8000af6e:	8e 68       	ld.sh	r8,r7[0xc]
8000af70:	a1 a8       	sbr	r8,0x0
8000af72:	ae 68       	st.h	r7[0xc],r8
8000af74:	2f 1d       	sub	sp,-60
8000af76:	d8 22       	popm	r4-r7,pc

8000af78 <memchr>:
8000af78:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000af7c:	c0 68       	rjmp	8000af88 <memchr+0x10>
8000af7e:	20 1a       	sub	r10,1
8000af80:	19 88       	ld.ub	r8,r12[0x0]
8000af82:	16 38       	cp.w	r8,r11
8000af84:	5e 0c       	reteq	r12
8000af86:	2f fc       	sub	r12,-1
8000af88:	58 0a       	cp.w	r10,0
8000af8a:	cf a1       	brne	8000af7e <memchr+0x6>
8000af8c:	5e fa       	retal	r10

8000af8e <__hi0bits>:
8000af8e:	18 98       	mov	r8,r12
8000af90:	e0 1c 00 00 	andl	r12,0x0
8000af94:	f0 09 15 10 	lsl	r9,r8,0x10
8000af98:	58 0c       	cp.w	r12,0
8000af9a:	f2 08 17 00 	moveq	r8,r9
8000af9e:	f9 bc 00 10 	moveq	r12,16
8000afa2:	f9 bc 01 00 	movne	r12,0
8000afa6:	10 9a       	mov	r10,r8
8000afa8:	f0 09 15 08 	lsl	r9,r8,0x8
8000afac:	e6 1a ff 00 	andh	r10,0xff00,COH
8000afb0:	f7 bc 00 f8 	subeq	r12,-8
8000afb4:	f2 08 17 00 	moveq	r8,r9
8000afb8:	10 9a       	mov	r10,r8
8000afba:	f0 09 15 04 	lsl	r9,r8,0x4
8000afbe:	e6 1a f0 00 	andh	r10,0xf000,COH
8000afc2:	f7 bc 00 fc 	subeq	r12,-4
8000afc6:	f2 08 17 00 	moveq	r8,r9
8000afca:	10 9a       	mov	r10,r8
8000afcc:	f0 09 15 02 	lsl	r9,r8,0x2
8000afd0:	e6 1a c0 00 	andh	r10,0xc000,COH
8000afd4:	f7 bc 00 fe 	subeq	r12,-2
8000afd8:	f2 08 17 00 	moveq	r8,r9
8000afdc:	58 08       	cp.w	r8,0
8000afde:	5e 5c       	retlt	r12
8000afe0:	ed b8 00 1e 	bld	r8,0x1e
8000afe4:	f9 bc 01 20 	movne	r12,32
8000afe8:	f7 bc 00 ff 	subeq	r12,-1
8000afec:	5e fc       	retal	r12

8000afee <__lo0bits>:
8000afee:	18 99       	mov	r9,r12
8000aff0:	78 08       	ld.w	r8,r12[0x0]
8000aff2:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000aff6:	c1 50       	breq	8000b020 <__lo0bits+0x32>
8000aff8:	ed b8 00 00 	bld	r8,0x0
8000affc:	c0 21       	brne	8000b000 <__lo0bits+0x12>
8000affe:	5e fd       	retal	0
8000b000:	10 9b       	mov	r11,r8
8000b002:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b006:	e2 1b 00 02 	andl	r11,0x2,COH
8000b00a:	a3 88       	lsr	r8,0x2
8000b00c:	58 0b       	cp.w	r11,0
8000b00e:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b012:	f9 bc 01 01 	movne	r12,1
8000b016:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b01a:	f9 bc 00 02 	moveq	r12,2
8000b01e:	5e fc       	retal	r12
8000b020:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b024:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b028:	58 0a       	cp.w	r10,0
8000b02a:	f6 08 17 00 	moveq	r8,r11
8000b02e:	f9 bc 00 10 	moveq	r12,16
8000b032:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b036:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b03a:	58 0b       	cp.w	r11,0
8000b03c:	f7 bc 00 f8 	subeq	r12,-8
8000b040:	f4 08 17 00 	moveq	r8,r10
8000b044:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b048:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b04c:	58 0b       	cp.w	r11,0
8000b04e:	f7 bc 00 fc 	subeq	r12,-4
8000b052:	f4 08 17 00 	moveq	r8,r10
8000b056:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b05a:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b05e:	58 0b       	cp.w	r11,0
8000b060:	f7 bc 00 fe 	subeq	r12,-2
8000b064:	f4 08 17 00 	moveq	r8,r10
8000b068:	ed b8 00 00 	bld	r8,0x0
8000b06c:	c0 60       	breq	8000b078 <__lo0bits+0x8a>
8000b06e:	a1 98       	lsr	r8,0x1
8000b070:	c0 31       	brne	8000b076 <__lo0bits+0x88>
8000b072:	32 0c       	mov	r12,32
8000b074:	5e fc       	retal	r12
8000b076:	2f fc       	sub	r12,-1
8000b078:	93 08       	st.w	r9[0x0],r8
8000b07a:	5e fc       	retal	r12

8000b07c <__mcmp>:
8000b07c:	d4 01       	pushm	lr
8000b07e:	18 98       	mov	r8,r12
8000b080:	76 49       	ld.w	r9,r11[0x10]
8000b082:	78 4c       	ld.w	r12,r12[0x10]
8000b084:	12 1c       	sub	r12,r9
8000b086:	c1 31       	brne	8000b0ac <__mcmp+0x30>
8000b088:	2f b9       	sub	r9,-5
8000b08a:	a3 69       	lsl	r9,0x2
8000b08c:	12 0b       	add	r11,r9
8000b08e:	f0 09 00 09 	add	r9,r8,r9
8000b092:	2e c8       	sub	r8,-20
8000b094:	13 4e       	ld.w	lr,--r9
8000b096:	17 4a       	ld.w	r10,--r11
8000b098:	14 3e       	cp.w	lr,r10
8000b09a:	c0 60       	breq	8000b0a6 <__mcmp+0x2a>
8000b09c:	f9 bc 03 ff 	movlo	r12,-1
8000b0a0:	f9 bc 02 01 	movhs	r12,1
8000b0a4:	d8 02       	popm	pc
8000b0a6:	10 39       	cp.w	r9,r8
8000b0a8:	fe 9b ff f6 	brhi	8000b094 <__mcmp+0x18>
8000b0ac:	d8 02       	popm	pc
8000b0ae:	d7 03       	nop

8000b0b0 <_Bfree>:
8000b0b0:	d4 21       	pushm	r4-r7,lr
8000b0b2:	18 97       	mov	r7,r12
8000b0b4:	16 95       	mov	r5,r11
8000b0b6:	78 96       	ld.w	r6,r12[0x24]
8000b0b8:	58 06       	cp.w	r6,0
8000b0ba:	c0 91       	brne	8000b0cc <_Bfree+0x1c>
8000b0bc:	31 0c       	mov	r12,16
8000b0be:	fe b0 dc a3 	rcall	80006a04 <malloc>
8000b0c2:	99 36       	st.w	r12[0xc],r6
8000b0c4:	8f 9c       	st.w	r7[0x24],r12
8000b0c6:	99 16       	st.w	r12[0x4],r6
8000b0c8:	99 26       	st.w	r12[0x8],r6
8000b0ca:	99 06       	st.w	r12[0x0],r6
8000b0cc:	58 05       	cp.w	r5,0
8000b0ce:	c0 90       	breq	8000b0e0 <_Bfree+0x30>
8000b0d0:	6a 19       	ld.w	r9,r5[0x4]
8000b0d2:	6e 98       	ld.w	r8,r7[0x24]
8000b0d4:	70 38       	ld.w	r8,r8[0xc]
8000b0d6:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b0da:	8b 0a       	st.w	r5[0x0],r10
8000b0dc:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b0e0:	d8 22       	popm	r4-r7,pc
8000b0e2:	d7 03       	nop

8000b0e4 <_Balloc>:
8000b0e4:	d4 21       	pushm	r4-r7,lr
8000b0e6:	18 97       	mov	r7,r12
8000b0e8:	16 96       	mov	r6,r11
8000b0ea:	78 95       	ld.w	r5,r12[0x24]
8000b0ec:	58 05       	cp.w	r5,0
8000b0ee:	c0 91       	brne	8000b100 <_Balloc+0x1c>
8000b0f0:	31 0c       	mov	r12,16
8000b0f2:	fe b0 dc 89 	rcall	80006a04 <malloc>
8000b0f6:	99 35       	st.w	r12[0xc],r5
8000b0f8:	8f 9c       	st.w	r7[0x24],r12
8000b0fa:	99 15       	st.w	r12[0x4],r5
8000b0fc:	99 25       	st.w	r12[0x8],r5
8000b0fe:	99 05       	st.w	r12[0x0],r5
8000b100:	6e 95       	ld.w	r5,r7[0x24]
8000b102:	6a 38       	ld.w	r8,r5[0xc]
8000b104:	58 08       	cp.w	r8,0
8000b106:	c0 b1       	brne	8000b11c <_Balloc+0x38>
8000b108:	31 0a       	mov	r10,16
8000b10a:	30 4b       	mov	r11,4
8000b10c:	0e 9c       	mov	r12,r7
8000b10e:	e0 a0 02 6d 	rcall	8000b5e8 <_calloc_r>
8000b112:	8b 3c       	st.w	r5[0xc],r12
8000b114:	6e 98       	ld.w	r8,r7[0x24]
8000b116:	70 3c       	ld.w	r12,r8[0xc]
8000b118:	58 0c       	cp.w	r12,0
8000b11a:	c1 b0       	breq	8000b150 <_Balloc+0x6c>
8000b11c:	6e 98       	ld.w	r8,r7[0x24]
8000b11e:	70 38       	ld.w	r8,r8[0xc]
8000b120:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b124:	70 0c       	ld.w	r12,r8[0x0]
8000b126:	58 0c       	cp.w	r12,0
8000b128:	c0 40       	breq	8000b130 <_Balloc+0x4c>
8000b12a:	78 09       	ld.w	r9,r12[0x0]
8000b12c:	91 09       	st.w	r8[0x0],r9
8000b12e:	c0 e8       	rjmp	8000b14a <_Balloc+0x66>
8000b130:	0e 9c       	mov	r12,r7
8000b132:	30 17       	mov	r7,1
8000b134:	0e 9b       	mov	r11,r7
8000b136:	ee 06 09 47 	lsl	r7,r7,r6
8000b13a:	ee ca ff fb 	sub	r10,r7,-5
8000b13e:	a3 6a       	lsl	r10,0x2
8000b140:	e0 a0 02 54 	rcall	8000b5e8 <_calloc_r>
8000b144:	c0 60       	breq	8000b150 <_Balloc+0x6c>
8000b146:	99 16       	st.w	r12[0x4],r6
8000b148:	99 27       	st.w	r12[0x8],r7
8000b14a:	30 08       	mov	r8,0
8000b14c:	99 38       	st.w	r12[0xc],r8
8000b14e:	99 48       	st.w	r12[0x10],r8
8000b150:	d8 22       	popm	r4-r7,pc
8000b152:	d7 03       	nop

8000b154 <__d2b>:
8000b154:	d4 31       	pushm	r0-r7,lr
8000b156:	20 2d       	sub	sp,8
8000b158:	16 93       	mov	r3,r11
8000b15a:	12 96       	mov	r6,r9
8000b15c:	10 95       	mov	r5,r8
8000b15e:	14 92       	mov	r2,r10
8000b160:	30 1b       	mov	r11,1
8000b162:	cc 1f       	rcall	8000b0e4 <_Balloc>
8000b164:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b168:	50 09       	stdsp	sp[0x0],r9
8000b16a:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b16e:	b5 a9       	sbr	r9,0x14
8000b170:	f0 01 16 14 	lsr	r1,r8,0x14
8000b174:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b178:	18 94       	mov	r4,r12
8000b17a:	58 02       	cp.w	r2,0
8000b17c:	c1 d0       	breq	8000b1b6 <__d2b+0x62>
8000b17e:	fa cc ff f8 	sub	r12,sp,-8
8000b182:	18 d2       	st.w	--r12,r2
8000b184:	c3 5f       	rcall	8000afee <__lo0bits>
8000b186:	40 18       	lddsp	r8,sp[0x4]
8000b188:	c0 d0       	breq	8000b1a2 <__d2b+0x4e>
8000b18a:	40 09       	lddsp	r9,sp[0x0]
8000b18c:	f8 0a 11 20 	rsub	r10,r12,32
8000b190:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b194:	f5 e8 10 08 	or	r8,r10,r8
8000b198:	89 58       	st.w	r4[0x14],r8
8000b19a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b19e:	50 09       	stdsp	sp[0x0],r9
8000b1a0:	c0 28       	rjmp	8000b1a4 <__d2b+0x50>
8000b1a2:	89 58       	st.w	r4[0x14],r8
8000b1a4:	40 08       	lddsp	r8,sp[0x0]
8000b1a6:	58 08       	cp.w	r8,0
8000b1a8:	f9 b3 01 02 	movne	r3,2
8000b1ac:	f9 b3 00 01 	moveq	r3,1
8000b1b0:	89 68       	st.w	r4[0x18],r8
8000b1b2:	89 43       	st.w	r4[0x10],r3
8000b1b4:	c0 88       	rjmp	8000b1c4 <__d2b+0x70>
8000b1b6:	1a 9c       	mov	r12,sp
8000b1b8:	c1 bf       	rcall	8000afee <__lo0bits>
8000b1ba:	30 13       	mov	r3,1
8000b1bc:	40 08       	lddsp	r8,sp[0x0]
8000b1be:	2e 0c       	sub	r12,-32
8000b1c0:	89 43       	st.w	r4[0x10],r3
8000b1c2:	89 58       	st.w	r4[0x14],r8
8000b1c4:	58 01       	cp.w	r1,0
8000b1c6:	c0 90       	breq	8000b1d8 <__d2b+0x84>
8000b1c8:	e2 c1 04 33 	sub	r1,r1,1075
8000b1cc:	18 01       	add	r1,r12
8000b1ce:	8d 01       	st.w	r6[0x0],r1
8000b1d0:	f8 0c 11 35 	rsub	r12,r12,53
8000b1d4:	8b 0c       	st.w	r5[0x0],r12
8000b1d6:	c0 c8       	rjmp	8000b1ee <__d2b+0x9a>
8000b1d8:	e6 c8 ff fc 	sub	r8,r3,-4
8000b1dc:	f8 cc 04 32 	sub	r12,r12,1074
8000b1e0:	a5 73       	lsl	r3,0x5
8000b1e2:	8d 0c       	st.w	r6[0x0],r12
8000b1e4:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b1e8:	cd 3e       	rcall	8000af8e <__hi0bits>
8000b1ea:	18 13       	sub	r3,r12
8000b1ec:	8b 03       	st.w	r5[0x0],r3
8000b1ee:	08 9c       	mov	r12,r4
8000b1f0:	2f ed       	sub	sp,-8
8000b1f2:	d8 32       	popm	r0-r7,pc

8000b1f4 <__mdiff>:
8000b1f4:	d4 31       	pushm	r0-r7,lr
8000b1f6:	74 48       	ld.w	r8,r10[0x10]
8000b1f8:	76 45       	ld.w	r5,r11[0x10]
8000b1fa:	16 97       	mov	r7,r11
8000b1fc:	14 96       	mov	r6,r10
8000b1fe:	10 15       	sub	r5,r8
8000b200:	c1 31       	brne	8000b226 <__mdiff+0x32>
8000b202:	2f b8       	sub	r8,-5
8000b204:	ee ce ff ec 	sub	lr,r7,-20
8000b208:	a3 68       	lsl	r8,0x2
8000b20a:	f4 08 00 0b 	add	r11,r10,r8
8000b20e:	ee 08 00 08 	add	r8,r7,r8
8000b212:	11 4a       	ld.w	r10,--r8
8000b214:	17 49       	ld.w	r9,--r11
8000b216:	12 3a       	cp.w	r10,r9
8000b218:	c0 30       	breq	8000b21e <__mdiff+0x2a>
8000b21a:	c0 e2       	brcc	8000b236 <__mdiff+0x42>
8000b21c:	c0 78       	rjmp	8000b22a <__mdiff+0x36>
8000b21e:	1c 38       	cp.w	r8,lr
8000b220:	fe 9b ff f9 	brhi	8000b212 <__mdiff+0x1e>
8000b224:	c4 98       	rjmp	8000b2b6 <__mdiff+0xc2>
8000b226:	58 05       	cp.w	r5,0
8000b228:	c0 64       	brge	8000b234 <__mdiff+0x40>
8000b22a:	0e 98       	mov	r8,r7
8000b22c:	30 15       	mov	r5,1
8000b22e:	0c 97       	mov	r7,r6
8000b230:	10 96       	mov	r6,r8
8000b232:	c0 28       	rjmp	8000b236 <__mdiff+0x42>
8000b234:	30 05       	mov	r5,0
8000b236:	6e 1b       	ld.w	r11,r7[0x4]
8000b238:	c5 6f       	rcall	8000b0e4 <_Balloc>
8000b23a:	6e 49       	ld.w	r9,r7[0x10]
8000b23c:	6c 44       	ld.w	r4,r6[0x10]
8000b23e:	99 35       	st.w	r12[0xc],r5
8000b240:	2f b4       	sub	r4,-5
8000b242:	f2 c5 ff fb 	sub	r5,r9,-5
8000b246:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b24a:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b24e:	2e c6       	sub	r6,-20
8000b250:	2e c7       	sub	r7,-20
8000b252:	f8 c8 ff ec 	sub	r8,r12,-20
8000b256:	30 0a       	mov	r10,0
8000b258:	0f 0e       	ld.w	lr,r7++
8000b25a:	0d 0b       	ld.w	r11,r6++
8000b25c:	fc 02 16 10 	lsr	r2,lr,0x10
8000b260:	f6 03 16 10 	lsr	r3,r11,0x10
8000b264:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b268:	e4 03 01 03 	sub	r3,r2,r3
8000b26c:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b270:	fc 0b 01 0b 	sub	r11,lr,r11
8000b274:	f6 0a 00 0a 	add	r10,r11,r10
8000b278:	b0 1a       	st.h	r8[0x2],r10
8000b27a:	b1 4a       	asr	r10,0x10
8000b27c:	e6 0a 00 0a 	add	r10,r3,r10
8000b280:	b0 0a       	st.h	r8[0x0],r10
8000b282:	2f c8       	sub	r8,-4
8000b284:	b1 4a       	asr	r10,0x10
8000b286:	08 36       	cp.w	r6,r4
8000b288:	ce 83       	brcs	8000b258 <__mdiff+0x64>
8000b28a:	c0 d8       	rjmp	8000b2a4 <__mdiff+0xb0>
8000b28c:	0f 0b       	ld.w	r11,r7++
8000b28e:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b292:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b296:	16 0a       	add	r10,r11
8000b298:	b0 1a       	st.h	r8[0x2],r10
8000b29a:	b1 4a       	asr	r10,0x10
8000b29c:	1c 0a       	add	r10,lr
8000b29e:	b0 0a       	st.h	r8[0x0],r10
8000b2a0:	2f c8       	sub	r8,-4
8000b2a2:	b1 4a       	asr	r10,0x10
8000b2a4:	0a 37       	cp.w	r7,r5
8000b2a6:	cf 33       	brcs	8000b28c <__mdiff+0x98>
8000b2a8:	c0 28       	rjmp	8000b2ac <__mdiff+0xb8>
8000b2aa:	20 19       	sub	r9,1
8000b2ac:	11 4a       	ld.w	r10,--r8
8000b2ae:	58 0a       	cp.w	r10,0
8000b2b0:	cf d0       	breq	8000b2aa <__mdiff+0xb6>
8000b2b2:	99 49       	st.w	r12[0x10],r9
8000b2b4:	d8 32       	popm	r0-r7,pc
8000b2b6:	30 0b       	mov	r11,0
8000b2b8:	c1 6f       	rcall	8000b0e4 <_Balloc>
8000b2ba:	30 18       	mov	r8,1
8000b2bc:	99 48       	st.w	r12[0x10],r8
8000b2be:	30 08       	mov	r8,0
8000b2c0:	99 58       	st.w	r12[0x14],r8
8000b2c2:	d8 32       	popm	r0-r7,pc

8000b2c4 <__lshift>:
8000b2c4:	d4 31       	pushm	r0-r7,lr
8000b2c6:	16 97       	mov	r7,r11
8000b2c8:	76 46       	ld.w	r6,r11[0x10]
8000b2ca:	f4 02 14 05 	asr	r2,r10,0x5
8000b2ce:	2f f6       	sub	r6,-1
8000b2d0:	14 93       	mov	r3,r10
8000b2d2:	18 94       	mov	r4,r12
8000b2d4:	04 06       	add	r6,r2
8000b2d6:	76 1b       	ld.w	r11,r11[0x4]
8000b2d8:	6e 28       	ld.w	r8,r7[0x8]
8000b2da:	c0 38       	rjmp	8000b2e0 <__lshift+0x1c>
8000b2dc:	2f fb       	sub	r11,-1
8000b2de:	a1 78       	lsl	r8,0x1
8000b2e0:	10 36       	cp.w	r6,r8
8000b2e2:	fe 99 ff fd 	brgt	8000b2dc <__lshift+0x18>
8000b2e6:	08 9c       	mov	r12,r4
8000b2e8:	cf ee       	rcall	8000b0e4 <_Balloc>
8000b2ea:	30 09       	mov	r9,0
8000b2ec:	18 95       	mov	r5,r12
8000b2ee:	f8 c8 ff ec 	sub	r8,r12,-20
8000b2f2:	12 9a       	mov	r10,r9
8000b2f4:	c0 38       	rjmp	8000b2fa <__lshift+0x36>
8000b2f6:	10 aa       	st.w	r8++,r10
8000b2f8:	2f f9       	sub	r9,-1
8000b2fa:	04 39       	cp.w	r9,r2
8000b2fc:	cf d5       	brlt	8000b2f6 <__lshift+0x32>
8000b2fe:	6e 4b       	ld.w	r11,r7[0x10]
8000b300:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b304:	2f bb       	sub	r11,-5
8000b306:	ee c9 ff ec 	sub	r9,r7,-20
8000b30a:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b30e:	58 03       	cp.w	r3,0
8000b310:	c1 30       	breq	8000b336 <__lshift+0x72>
8000b312:	e6 0c 11 20 	rsub	r12,r3,32
8000b316:	30 0a       	mov	r10,0
8000b318:	72 02       	ld.w	r2,r9[0x0]
8000b31a:	e4 03 09 42 	lsl	r2,r2,r3
8000b31e:	04 4a       	or	r10,r2
8000b320:	10 aa       	st.w	r8++,r10
8000b322:	13 0a       	ld.w	r10,r9++
8000b324:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b328:	16 39       	cp.w	r9,r11
8000b32a:	cf 73       	brcs	8000b318 <__lshift+0x54>
8000b32c:	91 0a       	st.w	r8[0x0],r10
8000b32e:	58 0a       	cp.w	r10,0
8000b330:	c0 70       	breq	8000b33e <__lshift+0x7a>
8000b332:	2f f6       	sub	r6,-1
8000b334:	c0 58       	rjmp	8000b33e <__lshift+0x7a>
8000b336:	13 0a       	ld.w	r10,r9++
8000b338:	10 aa       	st.w	r8++,r10
8000b33a:	16 39       	cp.w	r9,r11
8000b33c:	cf d3       	brcs	8000b336 <__lshift+0x72>
8000b33e:	08 9c       	mov	r12,r4
8000b340:	20 16       	sub	r6,1
8000b342:	0e 9b       	mov	r11,r7
8000b344:	8b 46       	st.w	r5[0x10],r6
8000b346:	cb 5e       	rcall	8000b0b0 <_Bfree>
8000b348:	0a 9c       	mov	r12,r5
8000b34a:	d8 32       	popm	r0-r7,pc

8000b34c <__multiply>:
8000b34c:	d4 31       	pushm	r0-r7,lr
8000b34e:	20 2d       	sub	sp,8
8000b350:	76 49       	ld.w	r9,r11[0x10]
8000b352:	74 48       	ld.w	r8,r10[0x10]
8000b354:	16 96       	mov	r6,r11
8000b356:	14 95       	mov	r5,r10
8000b358:	10 39       	cp.w	r9,r8
8000b35a:	ec 08 17 50 	movlt	r8,r6
8000b35e:	ea 06 17 50 	movlt	r6,r5
8000b362:	f0 05 17 50 	movlt	r5,r8
8000b366:	6c 28       	ld.w	r8,r6[0x8]
8000b368:	76 43       	ld.w	r3,r11[0x10]
8000b36a:	74 42       	ld.w	r2,r10[0x10]
8000b36c:	76 1b       	ld.w	r11,r11[0x4]
8000b36e:	e4 03 00 07 	add	r7,r2,r3
8000b372:	10 37       	cp.w	r7,r8
8000b374:	f7 bb 09 ff 	subgt	r11,-1
8000b378:	cb 6e       	rcall	8000b0e4 <_Balloc>
8000b37a:	ee c4 ff fb 	sub	r4,r7,-5
8000b37e:	f8 c9 ff ec 	sub	r9,r12,-20
8000b382:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b386:	30 0a       	mov	r10,0
8000b388:	12 98       	mov	r8,r9
8000b38a:	c0 28       	rjmp	8000b38e <__multiply+0x42>
8000b38c:	10 aa       	st.w	r8++,r10
8000b38e:	08 38       	cp.w	r8,r4
8000b390:	cf e3       	brcs	8000b38c <__multiply+0x40>
8000b392:	2f b3       	sub	r3,-5
8000b394:	2f b2       	sub	r2,-5
8000b396:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b39a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b39e:	ec cb ff ec 	sub	r11,r6,-20
8000b3a2:	50 12       	stdsp	sp[0x4],r2
8000b3a4:	ea ca ff ec 	sub	r10,r5,-20
8000b3a8:	c4 48       	rjmp	8000b430 <__multiply+0xe4>
8000b3aa:	94 95       	ld.uh	r5,r10[0x2]
8000b3ac:	58 05       	cp.w	r5,0
8000b3ae:	c2 00       	breq	8000b3ee <__multiply+0xa2>
8000b3b0:	12 98       	mov	r8,r9
8000b3b2:	16 96       	mov	r6,r11
8000b3b4:	30 0e       	mov	lr,0
8000b3b6:	50 09       	stdsp	sp[0x0],r9
8000b3b8:	0d 02       	ld.w	r2,r6++
8000b3ba:	e4 00 16 10 	lsr	r0,r2,0x10
8000b3be:	70 01       	ld.w	r1,r8[0x0]
8000b3c0:	70 09       	ld.w	r9,r8[0x0]
8000b3c2:	b1 81       	lsr	r1,0x10
8000b3c4:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b3c8:	e0 05 03 41 	mac	r1,r0,r5
8000b3cc:	ab 32       	mul	r2,r5
8000b3ce:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b3d2:	00 02       	add	r2,r0
8000b3d4:	e4 0e 00 0e 	add	lr,r2,lr
8000b3d8:	b0 1e       	st.h	r8[0x2],lr
8000b3da:	b1 8e       	lsr	lr,0x10
8000b3dc:	1c 01       	add	r1,lr
8000b3de:	b0 01       	st.h	r8[0x0],r1
8000b3e0:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b3e4:	2f c8       	sub	r8,-4
8000b3e6:	06 36       	cp.w	r6,r3
8000b3e8:	ce 83       	brcs	8000b3b8 <__multiply+0x6c>
8000b3ea:	40 09       	lddsp	r9,sp[0x0]
8000b3ec:	91 0e       	st.w	r8[0x0],lr
8000b3ee:	94 86       	ld.uh	r6,r10[0x0]
8000b3f0:	58 06       	cp.w	r6,0
8000b3f2:	c1 d0       	breq	8000b42c <__multiply+0xe0>
8000b3f4:	72 02       	ld.w	r2,r9[0x0]
8000b3f6:	12 98       	mov	r8,r9
8000b3f8:	16 9e       	mov	lr,r11
8000b3fa:	30 05       	mov	r5,0
8000b3fc:	b0 12       	st.h	r8[0x2],r2
8000b3fe:	1d 01       	ld.w	r1,lr++
8000b400:	90 82       	ld.uh	r2,r8[0x0]
8000b402:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b406:	ad 30       	mul	r0,r6
8000b408:	e0 02 00 02 	add	r2,r0,r2
8000b40c:	e4 05 00 05 	add	r5,r2,r5
8000b410:	b0 05       	st.h	r8[0x0],r5
8000b412:	b1 85       	lsr	r5,0x10
8000b414:	b1 81       	lsr	r1,0x10
8000b416:	2f c8       	sub	r8,-4
8000b418:	ad 31       	mul	r1,r6
8000b41a:	90 92       	ld.uh	r2,r8[0x2]
8000b41c:	e2 02 00 02 	add	r2,r1,r2
8000b420:	0a 02       	add	r2,r5
8000b422:	e4 05 16 10 	lsr	r5,r2,0x10
8000b426:	06 3e       	cp.w	lr,r3
8000b428:	ce a3       	brcs	8000b3fc <__multiply+0xb0>
8000b42a:	91 02       	st.w	r8[0x0],r2
8000b42c:	2f ca       	sub	r10,-4
8000b42e:	2f c9       	sub	r9,-4
8000b430:	40 18       	lddsp	r8,sp[0x4]
8000b432:	10 3a       	cp.w	r10,r8
8000b434:	cb b3       	brcs	8000b3aa <__multiply+0x5e>
8000b436:	c0 28       	rjmp	8000b43a <__multiply+0xee>
8000b438:	20 17       	sub	r7,1
8000b43a:	58 07       	cp.w	r7,0
8000b43c:	e0 8a 00 05 	brle	8000b446 <__multiply+0xfa>
8000b440:	09 48       	ld.w	r8,--r4
8000b442:	58 08       	cp.w	r8,0
8000b444:	cf a0       	breq	8000b438 <__multiply+0xec>
8000b446:	99 47       	st.w	r12[0x10],r7
8000b448:	2f ed       	sub	sp,-8
8000b44a:	d8 32       	popm	r0-r7,pc

8000b44c <__i2b>:
8000b44c:	d4 21       	pushm	r4-r7,lr
8000b44e:	16 97       	mov	r7,r11
8000b450:	30 1b       	mov	r11,1
8000b452:	c4 9e       	rcall	8000b0e4 <_Balloc>
8000b454:	30 19       	mov	r9,1
8000b456:	99 57       	st.w	r12[0x14],r7
8000b458:	99 49       	st.w	r12[0x10],r9
8000b45a:	d8 22       	popm	r4-r7,pc

8000b45c <__multadd>:
8000b45c:	d4 31       	pushm	r0-r7,lr
8000b45e:	30 08       	mov	r8,0
8000b460:	12 95       	mov	r5,r9
8000b462:	16 97       	mov	r7,r11
8000b464:	18 96       	mov	r6,r12
8000b466:	76 44       	ld.w	r4,r11[0x10]
8000b468:	f6 c9 ff ec 	sub	r9,r11,-20
8000b46c:	72 0b       	ld.w	r11,r9[0x0]
8000b46e:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b472:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b476:	f4 0c 02 4c 	mul	r12,r10,r12
8000b47a:	f4 0b 03 45 	mac	r5,r10,r11
8000b47e:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b482:	b1 85       	lsr	r5,0x10
8000b484:	18 05       	add	r5,r12
8000b486:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b48a:	f8 0b 00 0b 	add	r11,r12,r11
8000b48e:	12 ab       	st.w	r9++,r11
8000b490:	2f f8       	sub	r8,-1
8000b492:	b1 85       	lsr	r5,0x10
8000b494:	08 38       	cp.w	r8,r4
8000b496:	ce b5       	brlt	8000b46c <__multadd+0x10>
8000b498:	58 05       	cp.w	r5,0
8000b49a:	c1 c0       	breq	8000b4d2 <__multadd+0x76>
8000b49c:	6e 28       	ld.w	r8,r7[0x8]
8000b49e:	10 34       	cp.w	r4,r8
8000b4a0:	c1 35       	brlt	8000b4c6 <__multadd+0x6a>
8000b4a2:	6e 1b       	ld.w	r11,r7[0x4]
8000b4a4:	0c 9c       	mov	r12,r6
8000b4a6:	2f fb       	sub	r11,-1
8000b4a8:	c1 ee       	rcall	8000b0e4 <_Balloc>
8000b4aa:	6e 4a       	ld.w	r10,r7[0x10]
8000b4ac:	ee cb ff f4 	sub	r11,r7,-12
8000b4b0:	18 93       	mov	r3,r12
8000b4b2:	2f ea       	sub	r10,-2
8000b4b4:	2f 4c       	sub	r12,-12
8000b4b6:	a3 6a       	lsl	r10,0x2
8000b4b8:	fe b0 dc ca 	rcall	80006e4c <memcpy>
8000b4bc:	0e 9b       	mov	r11,r7
8000b4be:	0c 9c       	mov	r12,r6
8000b4c0:	fe b0 fd f8 	rcall	8000b0b0 <_Bfree>
8000b4c4:	06 97       	mov	r7,r3
8000b4c6:	e8 c8 ff ff 	sub	r8,r4,-1
8000b4ca:	2f b4       	sub	r4,-5
8000b4cc:	8f 48       	st.w	r7[0x10],r8
8000b4ce:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b4d2:	0e 9c       	mov	r12,r7
8000b4d4:	d8 32       	popm	r0-r7,pc
8000b4d6:	d7 03       	nop

8000b4d8 <__pow5mult>:
8000b4d8:	d4 31       	pushm	r0-r7,lr
8000b4da:	14 96       	mov	r6,r10
8000b4dc:	18 97       	mov	r7,r12
8000b4de:	16 94       	mov	r4,r11
8000b4e0:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b4e4:	c0 90       	breq	8000b4f6 <__pow5mult+0x1e>
8000b4e6:	20 18       	sub	r8,1
8000b4e8:	fe c9 e9 2c 	sub	r9,pc,-5844
8000b4ec:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b4f0:	30 09       	mov	r9,0
8000b4f2:	cb 5f       	rcall	8000b45c <__multadd>
8000b4f4:	18 94       	mov	r4,r12
8000b4f6:	a3 46       	asr	r6,0x2
8000b4f8:	c3 40       	breq	8000b560 <__pow5mult+0x88>
8000b4fa:	6e 95       	ld.w	r5,r7[0x24]
8000b4fc:	58 05       	cp.w	r5,0
8000b4fe:	c0 91       	brne	8000b510 <__pow5mult+0x38>
8000b500:	31 0c       	mov	r12,16
8000b502:	fe b0 da 81 	rcall	80006a04 <malloc>
8000b506:	99 35       	st.w	r12[0xc],r5
8000b508:	8f 9c       	st.w	r7[0x24],r12
8000b50a:	99 15       	st.w	r12[0x4],r5
8000b50c:	99 25       	st.w	r12[0x8],r5
8000b50e:	99 05       	st.w	r12[0x0],r5
8000b510:	6e 93       	ld.w	r3,r7[0x24]
8000b512:	66 25       	ld.w	r5,r3[0x8]
8000b514:	58 05       	cp.w	r5,0
8000b516:	c0 c1       	brne	8000b52e <__pow5mult+0x56>
8000b518:	e0 6b 02 71 	mov	r11,625
8000b51c:	0e 9c       	mov	r12,r7
8000b51e:	c9 7f       	rcall	8000b44c <__i2b>
8000b520:	87 2c       	st.w	r3[0x8],r12
8000b522:	30 08       	mov	r8,0
8000b524:	18 95       	mov	r5,r12
8000b526:	99 08       	st.w	r12[0x0],r8
8000b528:	c0 38       	rjmp	8000b52e <__pow5mult+0x56>
8000b52a:	06 9c       	mov	r12,r3
8000b52c:	18 95       	mov	r5,r12
8000b52e:	ed b6 00 00 	bld	r6,0x0
8000b532:	c0 b1       	brne	8000b548 <__pow5mult+0x70>
8000b534:	08 9b       	mov	r11,r4
8000b536:	0a 9a       	mov	r10,r5
8000b538:	0e 9c       	mov	r12,r7
8000b53a:	c0 9f       	rcall	8000b34c <__multiply>
8000b53c:	08 9b       	mov	r11,r4
8000b53e:	18 93       	mov	r3,r12
8000b540:	0e 9c       	mov	r12,r7
8000b542:	06 94       	mov	r4,r3
8000b544:	fe b0 fd b6 	rcall	8000b0b0 <_Bfree>
8000b548:	a1 56       	asr	r6,0x1
8000b54a:	c0 b0       	breq	8000b560 <__pow5mult+0x88>
8000b54c:	6a 03       	ld.w	r3,r5[0x0]
8000b54e:	58 03       	cp.w	r3,0
8000b550:	ce d1       	brne	8000b52a <__pow5mult+0x52>
8000b552:	0a 9a       	mov	r10,r5
8000b554:	0a 9b       	mov	r11,r5
8000b556:	0e 9c       	mov	r12,r7
8000b558:	cf ae       	rcall	8000b34c <__multiply>
8000b55a:	8b 0c       	st.w	r5[0x0],r12
8000b55c:	99 03       	st.w	r12[0x0],r3
8000b55e:	ce 7b       	rjmp	8000b52c <__pow5mult+0x54>
8000b560:	08 9c       	mov	r12,r4
8000b562:	d8 32       	popm	r0-r7,pc

8000b564 <_read_r>:
8000b564:	d4 21       	pushm	r4-r7,lr
8000b566:	16 98       	mov	r8,r11
8000b568:	18 97       	mov	r7,r12
8000b56a:	10 9c       	mov	r12,r8
8000b56c:	30 08       	mov	r8,0
8000b56e:	14 9b       	mov	r11,r10
8000b570:	e0 66 07 fc 	mov	r6,2044
8000b574:	12 9a       	mov	r10,r9
8000b576:	8d 08       	st.w	r6[0x0],r8
8000b578:	fe b0 cd 66 	rcall	80005044 <_read>
8000b57c:	5b fc       	cp.w	r12,-1
8000b57e:	c0 51       	brne	8000b588 <_read_r+0x24>
8000b580:	6c 08       	ld.w	r8,r6[0x0]
8000b582:	58 08       	cp.w	r8,0
8000b584:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b588:	d8 22       	popm	r4-r7,pc
8000b58a:	d7 03       	nop

8000b58c <__isinfd>:
8000b58c:	14 98       	mov	r8,r10
8000b58e:	fc 19 7f f0 	movh	r9,0x7ff0
8000b592:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b596:	f0 0b 11 00 	rsub	r11,r8,0
8000b59a:	f7 e8 10 08 	or	r8,r11,r8
8000b59e:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b5a2:	f2 08 01 08 	sub	r8,r9,r8
8000b5a6:	f0 0c 11 00 	rsub	r12,r8,0
8000b5aa:	f9 e8 10 08 	or	r8,r12,r8
8000b5ae:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b5b2:	2f fc       	sub	r12,-1
8000b5b4:	5e fc       	retal	r12

8000b5b6 <__isnand>:
8000b5b6:	14 98       	mov	r8,r10
8000b5b8:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b5bc:	f0 0c 11 00 	rsub	r12,r8,0
8000b5c0:	10 4c       	or	r12,r8
8000b5c2:	fc 18 7f f0 	movh	r8,0x7ff0
8000b5c6:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b5ca:	f0 0c 01 0c 	sub	r12,r8,r12
8000b5ce:	bf 9c       	lsr	r12,0x1f
8000b5d0:	5e fc       	retal	r12

8000b5d2 <strlen>:
8000b5d2:	30 09       	mov	r9,0
8000b5d4:	18 98       	mov	r8,r12
8000b5d6:	c0 28       	rjmp	8000b5da <strlen+0x8>
8000b5d8:	2f f8       	sub	r8,-1
8000b5da:	11 8a       	ld.ub	r10,r8[0x0]
8000b5dc:	f2 0a 18 00 	cp.b	r10,r9
8000b5e0:	cf c1       	brne	8000b5d8 <strlen+0x6>
8000b5e2:	f0 0c 01 0c 	sub	r12,r8,r12
8000b5e6:	5e fc       	retal	r12

8000b5e8 <_calloc_r>:
8000b5e8:	d4 21       	pushm	r4-r7,lr
8000b5ea:	f4 0b 02 4b 	mul	r11,r10,r11
8000b5ee:	fe b0 da 13 	rcall	80006a14 <_malloc_r>
8000b5f2:	18 97       	mov	r7,r12
8000b5f4:	c2 30       	breq	8000b63a <_calloc_r+0x52>
8000b5f6:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b5fa:	e0 1a ff fc 	andl	r10,0xfffc
8000b5fe:	20 4a       	sub	r10,4
8000b600:	e0 4a 00 24 	cp.w	r10,36
8000b604:	e0 8b 00 18 	brhi	8000b634 <_calloc_r+0x4c>
8000b608:	18 98       	mov	r8,r12
8000b60a:	59 3a       	cp.w	r10,19
8000b60c:	e0 88 00 0f 	brls	8000b62a <_calloc_r+0x42>
8000b610:	30 09       	mov	r9,0
8000b612:	10 a9       	st.w	r8++,r9
8000b614:	10 a9       	st.w	r8++,r9
8000b616:	59 ba       	cp.w	r10,27
8000b618:	e0 88 00 09 	brls	8000b62a <_calloc_r+0x42>
8000b61c:	10 a9       	st.w	r8++,r9
8000b61e:	10 a9       	st.w	r8++,r9
8000b620:	e0 4a 00 24 	cp.w	r10,36
8000b624:	c0 31       	brne	8000b62a <_calloc_r+0x42>
8000b626:	10 a9       	st.w	r8++,r9
8000b628:	10 a9       	st.w	r8++,r9
8000b62a:	30 09       	mov	r9,0
8000b62c:	10 a9       	st.w	r8++,r9
8000b62e:	91 19       	st.w	r8[0x4],r9
8000b630:	91 09       	st.w	r8[0x0],r9
8000b632:	c0 48       	rjmp	8000b63a <_calloc_r+0x52>
8000b634:	30 0b       	mov	r11,0
8000b636:	fe b0 dc af 	rcall	80006f94 <memset>
8000b63a:	0e 9c       	mov	r12,r7
8000b63c:	d8 22       	popm	r4-r7,pc
8000b63e:	d7 03       	nop

8000b640 <_fstat_r>:
8000b640:	d4 21       	pushm	r4-r7,lr
8000b642:	16 98       	mov	r8,r11
8000b644:	18 97       	mov	r7,r12
8000b646:	10 9c       	mov	r12,r8
8000b648:	30 08       	mov	r8,0
8000b64a:	e0 66 07 fc 	mov	r6,2044
8000b64e:	14 9b       	mov	r11,r10
8000b650:	8d 08       	st.w	r6[0x0],r8
8000b652:	fe b0 de 5b 	rcall	80007308 <_fstat>
8000b656:	5b fc       	cp.w	r12,-1
8000b658:	c0 51       	brne	8000b662 <_fstat_r+0x22>
8000b65a:	6c 08       	ld.w	r8,r6[0x0]
8000b65c:	58 08       	cp.w	r8,0
8000b65e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b662:	d8 22       	popm	r4-r7,pc

8000b664 <__avr32_f64_mul>:
8000b664:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b668:	e0 80 00 dc 	breq	8000b820 <__avr32_f64_mul_op1_zero>
8000b66c:	d4 21       	pushm	r4-r7,lr
8000b66e:	f7 e9 20 0e 	eor	lr,r11,r9
8000b672:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b676:	30 15       	mov	r5,1
8000b678:	c4 30       	breq	8000b6fe <__avr32_f64_mul_op1_subnormal>
8000b67a:	ab 6b       	lsl	r11,0xa
8000b67c:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b680:	ab 6a       	lsl	r10,0xa
8000b682:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b686:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b68a:	c5 c0       	breq	8000b742 <__avr32_f64_mul_op2_subnormal>
8000b68c:	a1 78       	lsl	r8,0x1
8000b68e:	5c f9       	rol	r9
8000b690:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b694:	e0 47 07 ff 	cp.w	r7,2047
8000b698:	c7 70       	breq	8000b786 <__avr32_f64_mul_op_nan_or_inf>
8000b69a:	e0 46 07 ff 	cp.w	r6,2047
8000b69e:	c7 40       	breq	8000b786 <__avr32_f64_mul_op_nan_or_inf>
8000b6a0:	ee 06 00 0c 	add	r12,r7,r6
8000b6a4:	e0 2c 03 fe 	sub	r12,1022
8000b6a8:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b6ac:	f4 09 07 44 	macu.d	r4,r10,r9
8000b6b0:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b6b4:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b6b8:	08 07       	add	r7,r4
8000b6ba:	f4 05 00 4a 	adc	r10,r10,r5
8000b6be:	5c 0b       	acr	r11
8000b6c0:	ed bb 00 14 	bld	r11,0x14
8000b6c4:	c0 50       	breq	8000b6ce <__avr32_f64_mul+0x6a>
8000b6c6:	a1 77       	lsl	r7,0x1
8000b6c8:	5c fa       	rol	r10
8000b6ca:	5c fb       	rol	r11
8000b6cc:	20 1c       	sub	r12,1
8000b6ce:	58 0c       	cp.w	r12,0
8000b6d0:	e0 8a 00 6f 	brle	8000b7ae <__avr32_f64_mul_res_subnormal>
8000b6d4:	e0 4c 07 ff 	cp.w	r12,2047
8000b6d8:	e0 84 00 9c 	brge	8000b810 <__avr32_f64_mul_res_inf>
8000b6dc:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b6e0:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b6e4:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b6e8:	ee 17 80 00 	eorh	r7,0x8000
8000b6ec:	f1 b7 04 20 	satu	r7,0x1
8000b6f0:	0e 0a       	add	r10,r7
8000b6f2:	5c 0b       	acr	r11
8000b6f4:	ed be 00 1f 	bld	lr,0x1f
8000b6f8:	ef bb 00 1f 	bst	r11,0x1f
8000b6fc:	d8 22       	popm	r4-r7,pc

8000b6fe <__avr32_f64_mul_op1_subnormal>:
8000b6fe:	e4 1b 00 0f 	andh	r11,0xf
8000b702:	f4 0c 12 00 	clz	r12,r10
8000b706:	f6 06 12 00 	clz	r6,r11
8000b70a:	f7 bc 03 e1 	sublo	r12,-31
8000b70e:	f8 06 17 30 	movlo	r6,r12
8000b712:	f7 b6 02 01 	subhs	r6,1
8000b716:	e0 46 00 20 	cp.w	r6,32
8000b71a:	c0 d4       	brge	8000b734 <__avr32_f64_mul_op1_subnormal+0x36>
8000b71c:	ec 0c 11 20 	rsub	r12,r6,32
8000b720:	f6 06 09 4b 	lsl	r11,r11,r6
8000b724:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b728:	18 4b       	or	r11,r12
8000b72a:	f4 06 09 4a 	lsl	r10,r10,r6
8000b72e:	20 b6       	sub	r6,11
8000b730:	0c 17       	sub	r7,r6
8000b732:	ca ab       	rjmp	8000b686 <__avr32_f64_mul+0x22>
8000b734:	f4 06 09 4b 	lsl	r11,r10,r6
8000b738:	c6 40       	breq	8000b800 <__avr32_f64_mul_res_zero>
8000b73a:	30 0a       	mov	r10,0
8000b73c:	20 b6       	sub	r6,11
8000b73e:	0c 17       	sub	r7,r6
8000b740:	ca 3b       	rjmp	8000b686 <__avr32_f64_mul+0x22>

8000b742 <__avr32_f64_mul_op2_subnormal>:
8000b742:	e4 19 00 0f 	andh	r9,0xf
8000b746:	f0 0c 12 00 	clz	r12,r8
8000b74a:	f2 05 12 00 	clz	r5,r9
8000b74e:	f7 bc 03 ea 	sublo	r12,-22
8000b752:	f8 05 17 30 	movlo	r5,r12
8000b756:	f7 b5 02 0a 	subhs	r5,10
8000b75a:	e0 45 00 20 	cp.w	r5,32
8000b75e:	c0 d4       	brge	8000b778 <__avr32_f64_mul_op2_subnormal+0x36>
8000b760:	ea 0c 11 20 	rsub	r12,r5,32
8000b764:	f2 05 09 49 	lsl	r9,r9,r5
8000b768:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b76c:	18 49       	or	r9,r12
8000b76e:	f0 05 09 48 	lsl	r8,r8,r5
8000b772:	20 25       	sub	r5,2
8000b774:	0a 16       	sub	r6,r5
8000b776:	c8 fb       	rjmp	8000b694 <__avr32_f64_mul+0x30>
8000b778:	f0 05 09 49 	lsl	r9,r8,r5
8000b77c:	c4 20       	breq	8000b800 <__avr32_f64_mul_res_zero>
8000b77e:	30 08       	mov	r8,0
8000b780:	20 25       	sub	r5,2
8000b782:	0a 16       	sub	r6,r5
8000b784:	c8 8b       	rjmp	8000b694 <__avr32_f64_mul+0x30>

8000b786 <__avr32_f64_mul_op_nan_or_inf>:
8000b786:	e4 19 00 0f 	andh	r9,0xf
8000b78a:	e4 1b 00 0f 	andh	r11,0xf
8000b78e:	14 4b       	or	r11,r10
8000b790:	10 49       	or	r9,r8
8000b792:	e0 47 07 ff 	cp.w	r7,2047
8000b796:	c0 91       	brne	8000b7a8 <__avr32_f64_mul_op1_not_naninf>
8000b798:	58 0b       	cp.w	r11,0
8000b79a:	c3 81       	brne	8000b80a <__avr32_f64_mul_res_nan>
8000b79c:	e0 46 07 ff 	cp.w	r6,2047
8000b7a0:	c3 81       	brne	8000b810 <__avr32_f64_mul_res_inf>
8000b7a2:	58 09       	cp.w	r9,0
8000b7a4:	c3 60       	breq	8000b810 <__avr32_f64_mul_res_inf>
8000b7a6:	c3 28       	rjmp	8000b80a <__avr32_f64_mul_res_nan>

8000b7a8 <__avr32_f64_mul_op1_not_naninf>:
8000b7a8:	58 09       	cp.w	r9,0
8000b7aa:	c3 30       	breq	8000b810 <__avr32_f64_mul_res_inf>
8000b7ac:	c2 f8       	rjmp	8000b80a <__avr32_f64_mul_res_nan>

8000b7ae <__avr32_f64_mul_res_subnormal>:
8000b7ae:	5c 3c       	neg	r12
8000b7b0:	2f fc       	sub	r12,-1
8000b7b2:	f1 bc 04 c0 	satu	r12,0x6
8000b7b6:	e0 4c 00 20 	cp.w	r12,32
8000b7ba:	c1 14       	brge	8000b7dc <__avr32_f64_mul_res_subnormal+0x2e>
8000b7bc:	f8 08 11 20 	rsub	r8,r12,32
8000b7c0:	0e 46       	or	r6,r7
8000b7c2:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b7c6:	f4 08 09 49 	lsl	r9,r10,r8
8000b7ca:	12 47       	or	r7,r9
8000b7cc:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b7d0:	f6 08 09 49 	lsl	r9,r11,r8
8000b7d4:	12 4a       	or	r10,r9
8000b7d6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b7da:	c8 3b       	rjmp	8000b6e0 <__avr32_f64_mul+0x7c>
8000b7dc:	f8 08 11 20 	rsub	r8,r12,32
8000b7e0:	f9 b9 00 00 	moveq	r9,0
8000b7e4:	c0 30       	breq	8000b7ea <__avr32_f64_mul_res_subnormal+0x3c>
8000b7e6:	f6 08 09 49 	lsl	r9,r11,r8
8000b7ea:	0e 46       	or	r6,r7
8000b7ec:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b7f0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b7f4:	f3 ea 10 07 	or	r7,r9,r10
8000b7f8:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b7fc:	30 0b       	mov	r11,0
8000b7fe:	c7 1b       	rjmp	8000b6e0 <__avr32_f64_mul+0x7c>

8000b800 <__avr32_f64_mul_res_zero>:
8000b800:	1c 9b       	mov	r11,lr
8000b802:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b806:	30 0a       	mov	r10,0
8000b808:	d8 22       	popm	r4-r7,pc

8000b80a <__avr32_f64_mul_res_nan>:
8000b80a:	3f fb       	mov	r11,-1
8000b80c:	3f fa       	mov	r10,-1
8000b80e:	d8 22       	popm	r4-r7,pc

8000b810 <__avr32_f64_mul_res_inf>:
8000b810:	f0 6b 00 00 	mov	r11,-1048576
8000b814:	ed be 00 1f 	bld	lr,0x1f
8000b818:	ef bb 00 1f 	bst	r11,0x1f
8000b81c:	30 0a       	mov	r10,0
8000b81e:	d8 22       	popm	r4-r7,pc

8000b820 <__avr32_f64_mul_op1_zero>:
8000b820:	f7 e9 20 0b 	eor	r11,r11,r9
8000b824:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b828:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b82c:	e0 4c 07 ff 	cp.w	r12,2047
8000b830:	5e 1c       	retne	r12
8000b832:	3f fa       	mov	r10,-1
8000b834:	3f fb       	mov	r11,-1
8000b836:	5e fc       	retal	r12

8000b838 <__avr32_f64_sub_from_add>:
8000b838:	ee 19 80 00 	eorh	r9,0x8000

8000b83c <__avr32_f64_sub>:
8000b83c:	f7 e9 20 0c 	eor	r12,r11,r9
8000b840:	e0 86 00 ca 	brmi	8000b9d4 <__avr32_f64_add_from_sub>
8000b844:	eb cd 40 e0 	pushm	r5-r7,lr
8000b848:	16 9c       	mov	r12,r11
8000b84a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b84e:	bf db       	cbr	r11,0x1f
8000b850:	bf d9       	cbr	r9,0x1f
8000b852:	10 3a       	cp.w	r10,r8
8000b854:	f2 0b 13 00 	cpc	r11,r9
8000b858:	c0 92       	brcc	8000b86a <__avr32_f64_sub+0x2e>
8000b85a:	16 97       	mov	r7,r11
8000b85c:	12 9b       	mov	r11,r9
8000b85e:	0e 99       	mov	r9,r7
8000b860:	14 97       	mov	r7,r10
8000b862:	10 9a       	mov	r10,r8
8000b864:	0e 98       	mov	r8,r7
8000b866:	ee 1c 80 00 	eorh	r12,0x8000
8000b86a:	f6 07 16 14 	lsr	r7,r11,0x14
8000b86e:	ab 7b       	lsl	r11,0xb
8000b870:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b874:	ab 7a       	lsl	r10,0xb
8000b876:	bf bb       	sbr	r11,0x1f
8000b878:	f2 06 16 14 	lsr	r6,r9,0x14
8000b87c:	c4 40       	breq	8000b904 <__avr32_f64_sub_opL_subnormal>
8000b87e:	ab 79       	lsl	r9,0xb
8000b880:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b884:	ab 78       	lsl	r8,0xb
8000b886:	bf b9       	sbr	r9,0x1f

8000b888 <__avr32_f64_sub_opL_subnormal_done>:
8000b888:	e0 47 07 ff 	cp.w	r7,2047
8000b88c:	c4 f0       	breq	8000b92a <__avr32_f64_sub_opH_nan_or_inf>
8000b88e:	0e 26       	rsub	r6,r7
8000b890:	c1 20       	breq	8000b8b4 <__avr32_f64_sub_shift_done>
8000b892:	ec 05 11 20 	rsub	r5,r6,32
8000b896:	e0 46 00 20 	cp.w	r6,32
8000b89a:	c7 c2       	brcc	8000b992 <__avr32_f64_sub_longshift>
8000b89c:	f0 05 09 4e 	lsl	lr,r8,r5
8000b8a0:	f2 05 09 45 	lsl	r5,r9,r5
8000b8a4:	f0 06 0a 48 	lsr	r8,r8,r6
8000b8a8:	f2 06 0a 49 	lsr	r9,r9,r6
8000b8ac:	0a 48       	or	r8,r5
8000b8ae:	58 0e       	cp.w	lr,0
8000b8b0:	5f 1e       	srne	lr
8000b8b2:	1c 48       	or	r8,lr

8000b8b4 <__avr32_f64_sub_shift_done>:
8000b8b4:	10 1a       	sub	r10,r8
8000b8b6:	f6 09 01 4b 	sbc	r11,r11,r9
8000b8ba:	f6 06 12 00 	clz	r6,r11
8000b8be:	c0 e0       	breq	8000b8da <__avr32_f64_sub_longnormalize_done>
8000b8c0:	c7 83       	brcs	8000b9b0 <__avr32_f64_sub_longnormalize>
8000b8c2:	ec 0e 11 20 	rsub	lr,r6,32
8000b8c6:	f6 06 09 4b 	lsl	r11,r11,r6
8000b8ca:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b8ce:	1c 4b       	or	r11,lr
8000b8d0:	f4 06 09 4a 	lsl	r10,r10,r6
8000b8d4:	0c 17       	sub	r7,r6
8000b8d6:	e0 8a 00 39 	brle	8000b948 <__avr32_f64_sub_subnormal_result>

8000b8da <__avr32_f64_sub_longnormalize_done>:
8000b8da:	f4 09 15 15 	lsl	r9,r10,0x15
8000b8de:	ab 9a       	lsr	r10,0xb
8000b8e0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b8e4:	ab 9b       	lsr	r11,0xb
8000b8e6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b8ea:	18 4b       	or	r11,r12

8000b8ec <__avr32_f64_sub_round>:
8000b8ec:	fc 17 80 00 	movh	r7,0x8000
8000b8f0:	ed ba 00 00 	bld	r10,0x0
8000b8f4:	f7 b7 01 ff 	subne	r7,-1
8000b8f8:	0e 39       	cp.w	r9,r7
8000b8fa:	5f 29       	srhs	r9
8000b8fc:	12 0a       	add	r10,r9
8000b8fe:	5c 0b       	acr	r11
8000b900:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b904 <__avr32_f64_sub_opL_subnormal>:
8000b904:	ab 79       	lsl	r9,0xb
8000b906:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b90a:	ab 78       	lsl	r8,0xb
8000b90c:	f3 e8 10 0e 	or	lr,r9,r8
8000b910:	f9 b6 01 01 	movne	r6,1
8000b914:	ee 0e 11 00 	rsub	lr,r7,0
8000b918:	f9 b7 00 01 	moveq	r7,1
8000b91c:	ef bb 00 1f 	bst	r11,0x1f
8000b920:	f7 ea 10 0e 	or	lr,r11,r10
8000b924:	f9 b7 00 00 	moveq	r7,0
8000b928:	cb 0b       	rjmp	8000b888 <__avr32_f64_sub_opL_subnormal_done>

8000b92a <__avr32_f64_sub_opH_nan_or_inf>:
8000b92a:	bf db       	cbr	r11,0x1f
8000b92c:	f7 ea 10 0e 	or	lr,r11,r10
8000b930:	c0 81       	brne	8000b940 <__avr32_f64_sub_return_nan>
8000b932:	e0 46 07 ff 	cp.w	r6,2047
8000b936:	c0 50       	breq	8000b940 <__avr32_f64_sub_return_nan>
8000b938:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b93c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b940 <__avr32_f64_sub_return_nan>:
8000b940:	3f fa       	mov	r10,-1
8000b942:	3f fb       	mov	r11,-1
8000b944:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b948 <__avr32_f64_sub_subnormal_result>:
8000b948:	5c 37       	neg	r7
8000b94a:	2f f7       	sub	r7,-1
8000b94c:	f1 b7 04 c0 	satu	r7,0x6
8000b950:	e0 47 00 20 	cp.w	r7,32
8000b954:	c1 14       	brge	8000b976 <__avr32_f64_sub_subnormal_result+0x2e>
8000b956:	ee 08 11 20 	rsub	r8,r7,32
8000b95a:	f4 08 09 49 	lsl	r9,r10,r8
8000b95e:	5f 16       	srne	r6
8000b960:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b964:	0c 4a       	or	r10,r6
8000b966:	f6 08 09 49 	lsl	r9,r11,r8
8000b96a:	f5 e9 10 0a 	or	r10,r10,r9
8000b96e:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b972:	30 07       	mov	r7,0
8000b974:	cb 3b       	rjmp	8000b8da <__avr32_f64_sub_longnormalize_done>
8000b976:	ee 08 11 40 	rsub	r8,r7,64
8000b97a:	f6 08 09 49 	lsl	r9,r11,r8
8000b97e:	14 49       	or	r9,r10
8000b980:	5f 16       	srne	r6
8000b982:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b986:	0c 4a       	or	r10,r6
8000b988:	30 0b       	mov	r11,0
8000b98a:	30 07       	mov	r7,0
8000b98c:	ca 7b       	rjmp	8000b8da <__avr32_f64_sub_longnormalize_done>
8000b98e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b992 <__avr32_f64_sub_longshift>:
8000b992:	f1 b6 04 c0 	satu	r6,0x6
8000b996:	f0 0e 17 00 	moveq	lr,r8
8000b99a:	c0 40       	breq	8000b9a2 <__avr32_f64_sub_longshift+0x10>
8000b99c:	f2 05 09 4e 	lsl	lr,r9,r5
8000b9a0:	10 4e       	or	lr,r8
8000b9a2:	f2 06 0a 48 	lsr	r8,r9,r6
8000b9a6:	30 09       	mov	r9,0
8000b9a8:	58 0e       	cp.w	lr,0
8000b9aa:	5f 1e       	srne	lr
8000b9ac:	1c 48       	or	r8,lr
8000b9ae:	c8 3b       	rjmp	8000b8b4 <__avr32_f64_sub_shift_done>

8000b9b0 <__avr32_f64_sub_longnormalize>:
8000b9b0:	f4 06 12 00 	clz	r6,r10
8000b9b4:	f9 b7 03 00 	movlo	r7,0
8000b9b8:	f9 b6 03 00 	movlo	r6,0
8000b9bc:	f9 bc 03 00 	movlo	r12,0
8000b9c0:	f7 b6 02 e0 	subhs	r6,-32
8000b9c4:	f4 06 09 4b 	lsl	r11,r10,r6
8000b9c8:	30 0a       	mov	r10,0
8000b9ca:	0c 17       	sub	r7,r6
8000b9cc:	fe 9a ff be 	brle	8000b948 <__avr32_f64_sub_subnormal_result>
8000b9d0:	c8 5b       	rjmp	8000b8da <__avr32_f64_sub_longnormalize_done>
8000b9d2:	d7 03       	nop

8000b9d4 <__avr32_f64_add_from_sub>:
8000b9d4:	ee 19 80 00 	eorh	r9,0x8000

8000b9d8 <__avr32_f64_add>:
8000b9d8:	f7 e9 20 0c 	eor	r12,r11,r9
8000b9dc:	fe 96 ff 2e 	brmi	8000b838 <__avr32_f64_sub_from_add>
8000b9e0:	eb cd 40 e0 	pushm	r5-r7,lr
8000b9e4:	16 9c       	mov	r12,r11
8000b9e6:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b9ea:	bf db       	cbr	r11,0x1f
8000b9ec:	bf d9       	cbr	r9,0x1f
8000b9ee:	12 3b       	cp.w	r11,r9
8000b9f0:	c0 72       	brcc	8000b9fe <__avr32_f64_add+0x26>
8000b9f2:	16 97       	mov	r7,r11
8000b9f4:	12 9b       	mov	r11,r9
8000b9f6:	0e 99       	mov	r9,r7
8000b9f8:	14 97       	mov	r7,r10
8000b9fa:	10 9a       	mov	r10,r8
8000b9fc:	0e 98       	mov	r8,r7
8000b9fe:	30 0e       	mov	lr,0
8000ba00:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ba04:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000ba08:	b5 ab       	sbr	r11,0x14
8000ba0a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ba0e:	c6 20       	breq	8000bad2 <__avr32_f64_add_op2_subnormal>
8000ba10:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000ba14:	b5 a9       	sbr	r9,0x14
8000ba16:	e0 47 07 ff 	cp.w	r7,2047
8000ba1a:	c2 80       	breq	8000ba6a <__avr32_f64_add_opH_nan_or_inf>
8000ba1c:	0e 26       	rsub	r6,r7
8000ba1e:	c1 20       	breq	8000ba42 <__avr32_f64_add_shift_done>
8000ba20:	e0 46 00 36 	cp.w	r6,54
8000ba24:	c1 52       	brcc	8000ba4e <__avr32_f64_add_res_of_done>
8000ba26:	ec 05 11 20 	rsub	r5,r6,32
8000ba2a:	e0 46 00 20 	cp.w	r6,32
8000ba2e:	c3 52       	brcc	8000ba98 <__avr32_f64_add_longshift>
8000ba30:	f0 05 09 4e 	lsl	lr,r8,r5
8000ba34:	f2 05 09 45 	lsl	r5,r9,r5
8000ba38:	f0 06 0a 48 	lsr	r8,r8,r6
8000ba3c:	f2 06 0a 49 	lsr	r9,r9,r6
8000ba40:	0a 48       	or	r8,r5

8000ba42 <__avr32_f64_add_shift_done>:
8000ba42:	10 0a       	add	r10,r8
8000ba44:	f6 09 00 4b 	adc	r11,r11,r9
8000ba48:	ed bb 00 15 	bld	r11,0x15
8000ba4c:	c3 40       	breq	8000bab4 <__avr32_f64_add_res_of>

8000ba4e <__avr32_f64_add_res_of_done>:
8000ba4e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ba52:	18 4b       	or	r11,r12

8000ba54 <__avr32_f64_add_round>:
8000ba54:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000ba58:	18 4e       	or	lr,r12
8000ba5a:	ee 1e 80 00 	eorh	lr,0x8000
8000ba5e:	f1 be 04 20 	satu	lr,0x1
8000ba62:	1c 0a       	add	r10,lr
8000ba64:	5c 0b       	acr	r11
8000ba66:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ba6a <__avr32_f64_add_opH_nan_or_inf>:
8000ba6a:	b5 cb       	cbr	r11,0x14
8000ba6c:	f7 ea 10 0e 	or	lr,r11,r10
8000ba70:	c1 01       	brne	8000ba90 <__avr32_f64_add_return_nan>
8000ba72:	e0 46 07 ff 	cp.w	r6,2047
8000ba76:	c0 30       	breq	8000ba7c <__avr32_f64_add_opL_nan_or_inf>
8000ba78:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ba7c <__avr32_f64_add_opL_nan_or_inf>:
8000ba7c:	b5 c9       	cbr	r9,0x14
8000ba7e:	f3 e8 10 0e 	or	lr,r9,r8
8000ba82:	c0 71       	brne	8000ba90 <__avr32_f64_add_return_nan>
8000ba84:	30 0a       	mov	r10,0
8000ba86:	fc 1b 7f f0 	movh	r11,0x7ff0
8000ba8a:	18 4b       	or	r11,r12
8000ba8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ba90 <__avr32_f64_add_return_nan>:
8000ba90:	3f fa       	mov	r10,-1
8000ba92:	3f fb       	mov	r11,-1
8000ba94:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ba98 <__avr32_f64_add_longshift>:
8000ba98:	f1 b6 04 c0 	satu	r6,0x6
8000ba9c:	f0 0e 17 00 	moveq	lr,r8
8000baa0:	c0 60       	breq	8000baac <__avr32_f64_add_longshift+0x14>
8000baa2:	f2 05 09 4e 	lsl	lr,r9,r5
8000baa6:	58 08       	cp.w	r8,0
8000baa8:	5f 18       	srne	r8
8000baaa:	10 4e       	or	lr,r8
8000baac:	f2 06 0a 48 	lsr	r8,r9,r6
8000bab0:	30 09       	mov	r9,0
8000bab2:	cc 8b       	rjmp	8000ba42 <__avr32_f64_add_shift_done>

8000bab4 <__avr32_f64_add_res_of>:
8000bab4:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000bab8:	a1 9b       	lsr	r11,0x1
8000baba:	5d 0a       	ror	r10
8000babc:	5d 0e       	ror	lr
8000babe:	2f f7       	sub	r7,-1
8000bac0:	e0 47 07 ff 	cp.w	r7,2047
8000bac4:	f9 ba 00 00 	moveq	r10,0
8000bac8:	f9 bb 00 00 	moveq	r11,0
8000bacc:	f9 be 00 00 	moveq	lr,0
8000bad0:	cb fb       	rjmp	8000ba4e <__avr32_f64_add_res_of_done>

8000bad2 <__avr32_f64_add_op2_subnormal>:
8000bad2:	30 16       	mov	r6,1
8000bad4:	58 07       	cp.w	r7,0
8000bad6:	ca 01       	brne	8000ba16 <__avr32_f64_add+0x3e>
8000bad8:	b5 cb       	cbr	r11,0x14
8000bada:	10 0a       	add	r10,r8
8000badc:	f6 09 00 4b 	adc	r11,r11,r9
8000bae0:	18 4b       	or	r11,r12
8000bae2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000bae6:	d7 03       	nop

8000bae8 <__avr32_f64_to_u32>:
8000bae8:	58 0b       	cp.w	r11,0
8000baea:	5e 6d       	retmi	0

8000baec <__avr32_f64_to_s32>:
8000baec:	f6 0c 15 01 	lsl	r12,r11,0x1
8000baf0:	b5 9c       	lsr	r12,0x15
8000baf2:	e0 2c 03 ff 	sub	r12,1023
8000baf6:	5e 3d       	retlo	0
8000baf8:	f8 0c 11 1f 	rsub	r12,r12,31
8000bafc:	16 99       	mov	r9,r11
8000bafe:	ab 7b       	lsl	r11,0xb
8000bb00:	bf bb       	sbr	r11,0x1f
8000bb02:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bb06:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bb0a:	a1 79       	lsl	r9,0x1
8000bb0c:	5e 2b       	reths	r11
8000bb0e:	5c 3b       	neg	r11
8000bb10:	5e fb       	retal	r11

8000bb12 <__avr32_u32_to_f64>:
8000bb12:	f8 cb 00 00 	sub	r11,r12,0
8000bb16:	30 0c       	mov	r12,0
8000bb18:	c0 38       	rjmp	8000bb1e <__avr32_s32_to_f64+0x4>

8000bb1a <__avr32_s32_to_f64>:
8000bb1a:	18 9b       	mov	r11,r12
8000bb1c:	5c 4b       	abs	r11
8000bb1e:	30 0a       	mov	r10,0
8000bb20:	5e 0b       	reteq	r11
8000bb22:	d4 01       	pushm	lr
8000bb24:	e0 69 04 1e 	mov	r9,1054
8000bb28:	f6 08 12 00 	clz	r8,r11
8000bb2c:	c1 70       	breq	8000bb5a <__avr32_s32_to_f64+0x40>
8000bb2e:	c0 c3       	brcs	8000bb46 <__avr32_s32_to_f64+0x2c>
8000bb30:	f0 0e 11 20 	rsub	lr,r8,32
8000bb34:	f6 08 09 4b 	lsl	r11,r11,r8
8000bb38:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bb3c:	1c 4b       	or	r11,lr
8000bb3e:	f4 08 09 4a 	lsl	r10,r10,r8
8000bb42:	10 19       	sub	r9,r8
8000bb44:	c0 b8       	rjmp	8000bb5a <__avr32_s32_to_f64+0x40>
8000bb46:	f4 08 12 00 	clz	r8,r10
8000bb4a:	f9 b8 03 00 	movlo	r8,0
8000bb4e:	f7 b8 02 e0 	subhs	r8,-32
8000bb52:	f4 08 09 4b 	lsl	r11,r10,r8
8000bb56:	30 0a       	mov	r10,0
8000bb58:	10 19       	sub	r9,r8
8000bb5a:	58 09       	cp.w	r9,0
8000bb5c:	e0 89 00 30 	brgt	8000bbbc <__avr32_s32_to_f64+0xa2>
8000bb60:	5c 39       	neg	r9
8000bb62:	2f f9       	sub	r9,-1
8000bb64:	e0 49 00 36 	cp.w	r9,54
8000bb68:	c0 43       	brcs	8000bb70 <__avr32_s32_to_f64+0x56>
8000bb6a:	30 0b       	mov	r11,0
8000bb6c:	30 0a       	mov	r10,0
8000bb6e:	c2 68       	rjmp	8000bbba <__avr32_s32_to_f64+0xa0>
8000bb70:	2f 69       	sub	r9,-10
8000bb72:	f2 08 11 20 	rsub	r8,r9,32
8000bb76:	e0 49 00 20 	cp.w	r9,32
8000bb7a:	c0 b2       	brcc	8000bb90 <__avr32_s32_to_f64+0x76>
8000bb7c:	f4 08 09 4e 	lsl	lr,r10,r8
8000bb80:	f6 08 09 48 	lsl	r8,r11,r8
8000bb84:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bb88:	f6 09 0a 4b 	lsr	r11,r11,r9
8000bb8c:	10 4b       	or	r11,r8
8000bb8e:	c0 88       	rjmp	8000bb9e <__avr32_s32_to_f64+0x84>
8000bb90:	f6 08 09 4e 	lsl	lr,r11,r8
8000bb94:	14 4e       	or	lr,r10
8000bb96:	16 9a       	mov	r10,r11
8000bb98:	30 0b       	mov	r11,0
8000bb9a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bb9e:	ed ba 00 00 	bld	r10,0x0
8000bba2:	c0 92       	brcc	8000bbb4 <__avr32_s32_to_f64+0x9a>
8000bba4:	1c 7e       	tst	lr,lr
8000bba6:	c0 41       	brne	8000bbae <__avr32_s32_to_f64+0x94>
8000bba8:	ed ba 00 01 	bld	r10,0x1
8000bbac:	c0 42       	brcc	8000bbb4 <__avr32_s32_to_f64+0x9a>
8000bbae:	2f fa       	sub	r10,-1
8000bbb0:	f7 bb 02 ff 	subhs	r11,-1
8000bbb4:	5c fc       	rol	r12
8000bbb6:	5d 0b       	ror	r11
8000bbb8:	5d 0a       	ror	r10
8000bbba:	d8 02       	popm	pc
8000bbbc:	e0 68 03 ff 	mov	r8,1023
8000bbc0:	ed ba 00 0b 	bld	r10,0xb
8000bbc4:	f7 b8 00 ff 	subeq	r8,-1
8000bbc8:	10 0a       	add	r10,r8
8000bbca:	5c 0b       	acr	r11
8000bbcc:	f7 b9 03 fe 	sublo	r9,-2
8000bbd0:	e0 49 07 ff 	cp.w	r9,2047
8000bbd4:	c0 55       	brlt	8000bbde <__avr32_s32_to_f64+0xc4>
8000bbd6:	30 0a       	mov	r10,0
8000bbd8:	fc 1b ff e0 	movh	r11,0xffe0
8000bbdc:	c0 c8       	rjmp	8000bbf4 <__floatsidf_return_op1>
8000bbde:	ed bb 00 1f 	bld	r11,0x1f
8000bbe2:	f7 b9 01 01 	subne	r9,1
8000bbe6:	ab 9a       	lsr	r10,0xb
8000bbe8:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bbec:	a1 7b       	lsl	r11,0x1
8000bbee:	ab 9b       	lsr	r11,0xb
8000bbf0:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000bbf4 <__floatsidf_return_op1>:
8000bbf4:	a1 7c       	lsl	r12,0x1
8000bbf6:	5d 0b       	ror	r11
8000bbf8:	d8 02       	popm	pc

8000bbfa <__avr32_f64_cmp_eq>:
8000bbfa:	10 3a       	cp.w	r10,r8
8000bbfc:	f2 0b 13 00 	cpc	r11,r9
8000bc00:	c0 80       	breq	8000bc10 <__avr32_f64_cmp_eq+0x16>
8000bc02:	a1 7b       	lsl	r11,0x1
8000bc04:	a1 79       	lsl	r9,0x1
8000bc06:	14 4b       	or	r11,r10
8000bc08:	12 4b       	or	r11,r9
8000bc0a:	10 4b       	or	r11,r8
8000bc0c:	5e 0f       	reteq	1
8000bc0e:	5e fd       	retal	0
8000bc10:	a1 7b       	lsl	r11,0x1
8000bc12:	fc 1c ff e0 	movh	r12,0xffe0
8000bc16:	58 0a       	cp.w	r10,0
8000bc18:	f8 0b 13 00 	cpc	r11,r12
8000bc1c:	5e 8f       	retls	1
8000bc1e:	5e fd       	retal	0

8000bc20 <__avr32_f64_cmp_ge>:
8000bc20:	1a de       	st.w	--sp,lr
8000bc22:	1a d7       	st.w	--sp,r7
8000bc24:	a1 7b       	lsl	r11,0x1
8000bc26:	5f 3c       	srlo	r12
8000bc28:	a1 79       	lsl	r9,0x1
8000bc2a:	5f 37       	srlo	r7
8000bc2c:	5c fc       	rol	r12
8000bc2e:	fc 1e ff e0 	movh	lr,0xffe0
8000bc32:	58 0a       	cp.w	r10,0
8000bc34:	fc 0b 13 00 	cpc	r11,lr
8000bc38:	e0 8b 00 1d 	brhi	8000bc72 <__avr32_f64_cmp_ge+0x52>
8000bc3c:	58 08       	cp.w	r8,0
8000bc3e:	fc 09 13 00 	cpc	r9,lr
8000bc42:	e0 8b 00 18 	brhi	8000bc72 <__avr32_f64_cmp_ge+0x52>
8000bc46:	58 0b       	cp.w	r11,0
8000bc48:	f5 ba 00 00 	subfeq	r10,0
8000bc4c:	c1 50       	breq	8000bc76 <__avr32_f64_cmp_ge+0x56>
8000bc4e:	1b 07       	ld.w	r7,sp++
8000bc50:	1b 0e       	ld.w	lr,sp++
8000bc52:	58 3c       	cp.w	r12,3
8000bc54:	c0 a0       	breq	8000bc68 <__avr32_f64_cmp_ge+0x48>
8000bc56:	58 1c       	cp.w	r12,1
8000bc58:	c0 33       	brcs	8000bc5e <__avr32_f64_cmp_ge+0x3e>
8000bc5a:	5e 0f       	reteq	1
8000bc5c:	5e 1d       	retne	0
8000bc5e:	10 3a       	cp.w	r10,r8
8000bc60:	f2 0b 13 00 	cpc	r11,r9
8000bc64:	5e 2f       	reths	1
8000bc66:	5e 3d       	retlo	0
8000bc68:	14 38       	cp.w	r8,r10
8000bc6a:	f6 09 13 00 	cpc	r9,r11
8000bc6e:	5e 2f       	reths	1
8000bc70:	5e 3d       	retlo	0
8000bc72:	1b 07       	ld.w	r7,sp++
8000bc74:	d8 0a       	popm	pc,r12=0
8000bc76:	58 17       	cp.w	r7,1
8000bc78:	5f 0c       	sreq	r12
8000bc7a:	58 09       	cp.w	r9,0
8000bc7c:	f5 b8 00 00 	subfeq	r8,0
8000bc80:	1b 07       	ld.w	r7,sp++
8000bc82:	1b 0e       	ld.w	lr,sp++
8000bc84:	5e 0f       	reteq	1
8000bc86:	5e fc       	retal	r12

8000bc88 <__avr32_f64_cmp_lt>:
8000bc88:	1a de       	st.w	--sp,lr
8000bc8a:	1a d7       	st.w	--sp,r7
8000bc8c:	a1 7b       	lsl	r11,0x1
8000bc8e:	5f 3c       	srlo	r12
8000bc90:	a1 79       	lsl	r9,0x1
8000bc92:	5f 37       	srlo	r7
8000bc94:	5c fc       	rol	r12
8000bc96:	fc 1e ff e0 	movh	lr,0xffe0
8000bc9a:	58 0a       	cp.w	r10,0
8000bc9c:	fc 0b 13 00 	cpc	r11,lr
8000bca0:	e0 8b 00 1d 	brhi	8000bcda <__avr32_f64_cmp_lt+0x52>
8000bca4:	58 08       	cp.w	r8,0
8000bca6:	fc 09 13 00 	cpc	r9,lr
8000bcaa:	e0 8b 00 18 	brhi	8000bcda <__avr32_f64_cmp_lt+0x52>
8000bcae:	58 0b       	cp.w	r11,0
8000bcb0:	f5 ba 00 00 	subfeq	r10,0
8000bcb4:	c1 50       	breq	8000bcde <__avr32_f64_cmp_lt+0x56>
8000bcb6:	1b 07       	ld.w	r7,sp++
8000bcb8:	1b 0e       	ld.w	lr,sp++
8000bcba:	58 3c       	cp.w	r12,3
8000bcbc:	c0 a0       	breq	8000bcd0 <__avr32_f64_cmp_lt+0x48>
8000bcbe:	58 1c       	cp.w	r12,1
8000bcc0:	c0 33       	brcs	8000bcc6 <__avr32_f64_cmp_lt+0x3e>
8000bcc2:	5e 0d       	reteq	0
8000bcc4:	5e 1f       	retne	1
8000bcc6:	10 3a       	cp.w	r10,r8
8000bcc8:	f2 0b 13 00 	cpc	r11,r9
8000bccc:	5e 2d       	reths	0
8000bcce:	5e 3f       	retlo	1
8000bcd0:	14 38       	cp.w	r8,r10
8000bcd2:	f6 09 13 00 	cpc	r9,r11
8000bcd6:	5e 2d       	reths	0
8000bcd8:	5e 3f       	retlo	1
8000bcda:	1b 07       	ld.w	r7,sp++
8000bcdc:	d8 0a       	popm	pc,r12=0
8000bcde:	58 17       	cp.w	r7,1
8000bce0:	5f 1c       	srne	r12
8000bce2:	58 09       	cp.w	r9,0
8000bce4:	f5 b8 00 00 	subfeq	r8,0
8000bce8:	1b 07       	ld.w	r7,sp++
8000bcea:	1b 0e       	ld.w	lr,sp++
8000bcec:	5e 0d       	reteq	0
8000bcee:	5e fc       	retal	r12

8000bcf0 <__avr32_f64_div>:
8000bcf0:	eb cd 40 ff 	pushm	r0-r7,lr
8000bcf4:	f7 e9 20 0e 	eor	lr,r11,r9
8000bcf8:	f6 07 16 14 	lsr	r7,r11,0x14
8000bcfc:	a9 7b       	lsl	r11,0x9
8000bcfe:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000bd02:	a9 7a       	lsl	r10,0x9
8000bd04:	bd bb       	sbr	r11,0x1d
8000bd06:	e4 1b 3f ff 	andh	r11,0x3fff
8000bd0a:	ab d7       	cbr	r7,0xb
8000bd0c:	e0 80 00 cc 	breq	8000bea4 <__avr32_f64_div_round_subnormal+0x54>
8000bd10:	e0 47 07 ff 	cp.w	r7,2047
8000bd14:	e0 84 00 b5 	brge	8000be7e <__avr32_f64_div_round_subnormal+0x2e>
8000bd18:	f2 06 16 14 	lsr	r6,r9,0x14
8000bd1c:	a9 79       	lsl	r9,0x9
8000bd1e:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000bd22:	a9 78       	lsl	r8,0x9
8000bd24:	bd b9       	sbr	r9,0x1d
8000bd26:	e4 19 3f ff 	andh	r9,0x3fff
8000bd2a:	ab d6       	cbr	r6,0xb
8000bd2c:	e0 80 00 e2 	breq	8000bef0 <__avr32_f64_div_round_subnormal+0xa0>
8000bd30:	e0 46 07 ff 	cp.w	r6,2047
8000bd34:	e0 84 00 b2 	brge	8000be98 <__avr32_f64_div_round_subnormal+0x48>
8000bd38:	0c 17       	sub	r7,r6
8000bd3a:	fe 37 fc 01 	sub	r7,-1023
8000bd3e:	fc 1c 80 00 	movh	r12,0x8000
8000bd42:	f8 03 16 01 	lsr	r3,r12,0x1
8000bd46:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000bd4a:	5c d4       	com	r4
8000bd4c:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000bd50:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bd54:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bd58:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bd5c:	ea 03 15 02 	lsl	r3,r5,0x2
8000bd60:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bd64:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bd68:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bd6c:	ea 03 15 02 	lsl	r3,r5,0x2
8000bd70:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bd74:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bd78:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bd7c:	ea 03 15 02 	lsl	r3,r5,0x2
8000bd80:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bd84:	e4 09 07 40 	macu.d	r0,r2,r9
8000bd88:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bd8c:	02 04       	add	r4,r1
8000bd8e:	5c 05       	acr	r5
8000bd90:	a3 65       	lsl	r5,0x2
8000bd92:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bd96:	a3 64       	lsl	r4,0x2
8000bd98:	5c 34       	neg	r4
8000bd9a:	f8 05 01 45 	sbc	r5,r12,r5
8000bd9e:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bda2:	e4 05 07 40 	macu.d	r0,r2,r5
8000bda6:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bdaa:	02 04       	add	r4,r1
8000bdac:	5c 05       	acr	r5
8000bdae:	ea 03 15 02 	lsl	r3,r5,0x2
8000bdb2:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bdb6:	e8 02 15 02 	lsl	r2,r4,0x2
8000bdba:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bdbe:	e4 09 07 40 	macu.d	r0,r2,r9
8000bdc2:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bdc6:	02 04       	add	r4,r1
8000bdc8:	5c 05       	acr	r5
8000bdca:	a3 65       	lsl	r5,0x2
8000bdcc:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bdd0:	a3 64       	lsl	r4,0x2
8000bdd2:	5c 34       	neg	r4
8000bdd4:	f8 05 01 45 	sbc	r5,r12,r5
8000bdd8:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bddc:	e4 05 07 40 	macu.d	r0,r2,r5
8000bde0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bde4:	02 04       	add	r4,r1
8000bde6:	5c 05       	acr	r5
8000bde8:	ea 03 15 02 	lsl	r3,r5,0x2
8000bdec:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bdf0:	e8 02 15 02 	lsl	r2,r4,0x2
8000bdf4:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000bdf8:	e4 0b 07 40 	macu.d	r0,r2,r11
8000bdfc:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000be00:	02 02       	add	r2,r1
8000be02:	5c 03       	acr	r3
8000be04:	ed b3 00 1c 	bld	r3,0x1c
8000be08:	c0 90       	breq	8000be1a <__avr32_f64_div+0x12a>
8000be0a:	a1 72       	lsl	r2,0x1
8000be0c:	5c f3       	rol	r3
8000be0e:	20 17       	sub	r7,1
8000be10:	a3 9a       	lsr	r10,0x3
8000be12:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000be16:	a3 9b       	lsr	r11,0x3
8000be18:	c0 58       	rjmp	8000be22 <__avr32_f64_div+0x132>
8000be1a:	a5 8a       	lsr	r10,0x4
8000be1c:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000be20:	a5 8b       	lsr	r11,0x4
8000be22:	58 07       	cp.w	r7,0
8000be24:	e0 8a 00 8b 	brle	8000bf3a <__avr32_f64_div_res_subnormal>
8000be28:	e0 12 ff 00 	andl	r2,0xff00
8000be2c:	e8 12 00 80 	orl	r2,0x80
8000be30:	e6 08 06 40 	mulu.d	r0,r3,r8
8000be34:	e4 09 07 40 	macu.d	r0,r2,r9
8000be38:	e4 08 06 44 	mulu.d	r4,r2,r8
8000be3c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000be40:	00 05       	add	r5,r0
8000be42:	f0 01 00 48 	adc	r8,r8,r1
8000be46:	5c 09       	acr	r9
8000be48:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000be4c:	58 04       	cp.w	r4,0
8000be4e:	5c 25       	cpc	r5

8000be50 <__avr32_f64_div_round_subnormal>:
8000be50:	f4 08 13 00 	cpc	r8,r10
8000be54:	f6 09 13 00 	cpc	r9,r11
8000be58:	5f 36       	srlo	r6
8000be5a:	f8 06 17 00 	moveq	r6,r12
8000be5e:	e4 0a 16 08 	lsr	r10,r2,0x8
8000be62:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000be66:	e6 0b 16 08 	lsr	r11,r3,0x8
8000be6a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000be6e:	ed be 00 1f 	bld	lr,0x1f
8000be72:	ef bb 00 1f 	bst	r11,0x1f
8000be76:	0c 0a       	add	r10,r6
8000be78:	5c 0b       	acr	r11
8000be7a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000be7e:	e4 1b 00 0f 	andh	r11,0xf
8000be82:	14 4b       	or	r11,r10
8000be84:	e0 81 00 a7 	brne	8000bfd2 <__avr32_f64_div_res_subnormal+0x98>
8000be88:	f2 06 16 14 	lsr	r6,r9,0x14
8000be8c:	ab d6       	cbr	r6,0xb
8000be8e:	e0 46 07 ff 	cp.w	r6,2047
8000be92:	e0 81 00 a4 	brne	8000bfda <__avr32_f64_div_res_subnormal+0xa0>
8000be96:	c9 e8       	rjmp	8000bfd2 <__avr32_f64_div_res_subnormal+0x98>
8000be98:	e4 19 00 0f 	andh	r9,0xf
8000be9c:	10 49       	or	r9,r8
8000be9e:	e0 81 00 9a 	brne	8000bfd2 <__avr32_f64_div_res_subnormal+0x98>
8000bea2:	c9 28       	rjmp	8000bfc6 <__avr32_f64_div_res_subnormal+0x8c>
8000bea4:	a3 7b       	lsl	r11,0x3
8000bea6:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000beaa:	a3 7a       	lsl	r10,0x3
8000beac:	f5 eb 10 04 	or	r4,r10,r11
8000beb0:	e0 80 00 a0 	breq	8000bff0 <__avr32_f64_div_op1_zero>
8000beb4:	f6 04 12 00 	clz	r4,r11
8000beb8:	c1 70       	breq	8000bee6 <__avr32_f64_div_round_subnormal+0x96>
8000beba:	c0 c3       	brcs	8000bed2 <__avr32_f64_div_round_subnormal+0x82>
8000bebc:	e8 05 11 20 	rsub	r5,r4,32
8000bec0:	f6 04 09 4b 	lsl	r11,r11,r4
8000bec4:	f4 05 0a 45 	lsr	r5,r10,r5
8000bec8:	0a 4b       	or	r11,r5
8000beca:	f4 04 09 4a 	lsl	r10,r10,r4
8000bece:	08 17       	sub	r7,r4
8000bed0:	c0 b8       	rjmp	8000bee6 <__avr32_f64_div_round_subnormal+0x96>
8000bed2:	f4 04 12 00 	clz	r4,r10
8000bed6:	f9 b4 03 00 	movlo	r4,0
8000beda:	f7 b4 02 e0 	subhs	r4,-32
8000bede:	f4 04 09 4b 	lsl	r11,r10,r4
8000bee2:	30 0a       	mov	r10,0
8000bee4:	08 17       	sub	r7,r4
8000bee6:	a3 8a       	lsr	r10,0x2
8000bee8:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000beec:	a3 8b       	lsr	r11,0x2
8000beee:	c1 1b       	rjmp	8000bd10 <__avr32_f64_div+0x20>
8000bef0:	a3 79       	lsl	r9,0x3
8000bef2:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000bef6:	a3 78       	lsl	r8,0x3
8000bef8:	f3 e8 10 04 	or	r4,r9,r8
8000befc:	c6 f0       	breq	8000bfda <__avr32_f64_div_res_subnormal+0xa0>
8000befe:	f2 04 12 00 	clz	r4,r9
8000bf02:	c1 70       	breq	8000bf30 <__avr32_f64_div_round_subnormal+0xe0>
8000bf04:	c0 c3       	brcs	8000bf1c <__avr32_f64_div_round_subnormal+0xcc>
8000bf06:	e8 05 11 20 	rsub	r5,r4,32
8000bf0a:	f2 04 09 49 	lsl	r9,r9,r4
8000bf0e:	f0 05 0a 45 	lsr	r5,r8,r5
8000bf12:	0a 49       	or	r9,r5
8000bf14:	f0 04 09 48 	lsl	r8,r8,r4
8000bf18:	08 16       	sub	r6,r4
8000bf1a:	c0 b8       	rjmp	8000bf30 <__avr32_f64_div_round_subnormal+0xe0>
8000bf1c:	f0 04 12 00 	clz	r4,r8
8000bf20:	f9 b4 03 00 	movlo	r4,0
8000bf24:	f7 b4 02 e0 	subhs	r4,-32
8000bf28:	f0 04 09 49 	lsl	r9,r8,r4
8000bf2c:	30 08       	mov	r8,0
8000bf2e:	08 16       	sub	r6,r4
8000bf30:	a3 88       	lsr	r8,0x2
8000bf32:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000bf36:	a3 89       	lsr	r9,0x2
8000bf38:	cf ca       	rjmp	8000bd30 <__avr32_f64_div+0x40>

8000bf3a <__avr32_f64_div_res_subnormal>:
8000bf3a:	5c 37       	neg	r7
8000bf3c:	2f f7       	sub	r7,-1
8000bf3e:	f1 b7 04 c0 	satu	r7,0x6
8000bf42:	e0 47 00 20 	cp.w	r7,32
8000bf46:	c1 54       	brge	8000bf70 <__avr32_f64_div_res_subnormal+0x36>
8000bf48:	ee 06 11 20 	rsub	r6,r7,32
8000bf4c:	e4 07 0a 42 	lsr	r2,r2,r7
8000bf50:	e6 06 09 4c 	lsl	r12,r3,r6
8000bf54:	18 42       	or	r2,r12
8000bf56:	e6 07 0a 43 	lsr	r3,r3,r7
8000bf5a:	f4 06 09 41 	lsl	r1,r10,r6
8000bf5e:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bf62:	f6 06 09 4c 	lsl	r12,r11,r6
8000bf66:	18 4a       	or	r10,r12
8000bf68:	f6 07 0a 4b 	lsr	r11,r11,r7
8000bf6c:	30 00       	mov	r0,0
8000bf6e:	c1 58       	rjmp	8000bf98 <__avr32_f64_div_res_subnormal+0x5e>
8000bf70:	ee 06 11 20 	rsub	r6,r7,32
8000bf74:	f9 b0 00 00 	moveq	r0,0
8000bf78:	f9 bc 00 00 	moveq	r12,0
8000bf7c:	c0 50       	breq	8000bf86 <__avr32_f64_div_res_subnormal+0x4c>
8000bf7e:	f4 06 09 40 	lsl	r0,r10,r6
8000bf82:	f6 06 09 4c 	lsl	r12,r11,r6
8000bf86:	e6 07 0a 42 	lsr	r2,r3,r7
8000bf8a:	30 03       	mov	r3,0
8000bf8c:	f4 07 0a 41 	lsr	r1,r10,r7
8000bf90:	18 41       	or	r1,r12
8000bf92:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bf96:	30 0b       	mov	r11,0
8000bf98:	e0 12 ff 00 	andl	r2,0xff00
8000bf9c:	e8 12 00 80 	orl	r2,0x80
8000bfa0:	e6 08 06 46 	mulu.d	r6,r3,r8
8000bfa4:	e4 09 07 46 	macu.d	r6,r2,r9
8000bfa8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bfac:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bfb0:	0c 05       	add	r5,r6
8000bfb2:	f0 07 00 48 	adc	r8,r8,r7
8000bfb6:	5c 09       	acr	r9
8000bfb8:	30 07       	mov	r7,0
8000bfba:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bfbe:	00 34       	cp.w	r4,r0
8000bfc0:	e2 05 13 00 	cpc	r5,r1
8000bfc4:	c4 6b       	rjmp	8000be50 <__avr32_f64_div_round_subnormal>
8000bfc6:	1c 9b       	mov	r11,lr
8000bfc8:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bfcc:	30 0a       	mov	r10,0
8000bfce:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bfd2:	3f fb       	mov	r11,-1
8000bfd4:	30 0a       	mov	r10,0
8000bfd6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bfda:	f5 eb 10 04 	or	r4,r10,r11
8000bfde:	c0 90       	breq	8000bff0 <__avr32_f64_div_op1_zero>
8000bfe0:	1c 9b       	mov	r11,lr
8000bfe2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bfe6:	ea 1b 7f f0 	orh	r11,0x7ff0
8000bfea:	30 0a       	mov	r10,0
8000bfec:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000bff0 <__avr32_f64_div_op1_zero>:
8000bff0:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000bff4:	ce f0       	breq	8000bfd2 <__avr32_f64_div_res_subnormal+0x98>
8000bff6:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000bffa:	e0 44 07 ff 	cp.w	r4,2047
8000bffe:	ce 41       	brne	8000bfc6 <__avr32_f64_div_res_subnormal+0x8c>
8000c000:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c004:	ce 10       	breq	8000bfc6 <__avr32_f64_div_res_subnormal+0x8c>
8000c006:	ce 6b       	rjmp	8000bfd2 <__avr32_f64_div_res_subnormal+0x98>

8000c008 <__avr32_umod64>:
8000c008:	d4 31       	pushm	r0-r7,lr
8000c00a:	1a 97       	mov	r7,sp
8000c00c:	20 3d       	sub	sp,12
8000c00e:	10 9c       	mov	r12,r8
8000c010:	12 95       	mov	r5,r9
8000c012:	14 9e       	mov	lr,r10
8000c014:	16 91       	mov	r1,r11
8000c016:	16 96       	mov	r6,r11
8000c018:	58 09       	cp.w	r9,0
8000c01a:	e0 81 00 81 	brne	8000c11c <__avr32_umod64+0x114>
8000c01e:	16 38       	cp.w	r8,r11
8000c020:	e0 88 00 12 	brls	8000c044 <__avr32_umod64+0x3c>
8000c024:	f0 08 12 00 	clz	r8,r8
8000c028:	c4 e0       	breq	8000c0c4 <__avr32_umod64+0xbc>
8000c02a:	f6 08 09 46 	lsl	r6,r11,r8
8000c02e:	f8 08 09 4c 	lsl	r12,r12,r8
8000c032:	f0 0b 11 20 	rsub	r11,r8,32
8000c036:	f4 08 09 4e 	lsl	lr,r10,r8
8000c03a:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c03e:	f7 e6 10 06 	or	r6,r11,r6
8000c042:	c4 18       	rjmp	8000c0c4 <__avr32_umod64+0xbc>
8000c044:	58 08       	cp.w	r8,0
8000c046:	c0 51       	brne	8000c050 <__avr32_umod64+0x48>
8000c048:	30 19       	mov	r9,1
8000c04a:	f2 08 0d 08 	divu	r8,r9,r8
8000c04e:	10 9c       	mov	r12,r8
8000c050:	f8 08 12 00 	clz	r8,r12
8000c054:	c0 31       	brne	8000c05a <__avr32_umod64+0x52>
8000c056:	18 16       	sub	r6,r12
8000c058:	c3 68       	rjmp	8000c0c4 <__avr32_umod64+0xbc>
8000c05a:	f0 03 11 20 	rsub	r3,r8,32
8000c05e:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c062:	f8 08 09 4c 	lsl	r12,r12,r8
8000c066:	ec 08 09 49 	lsl	r9,r6,r8
8000c06a:	ec 03 0a 43 	lsr	r3,r6,r3
8000c06e:	f7 e9 10 09 	or	r9,r11,r9
8000c072:	f8 05 16 10 	lsr	r5,r12,0x10
8000c076:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c07a:	e6 05 0d 02 	divu	r2,r3,r5
8000c07e:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c082:	ec 02 02 4b 	mul	r11,r6,r2
8000c086:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c08a:	16 3e       	cp.w	lr,r11
8000c08c:	c0 72       	brcc	8000c09a <__avr32_umod64+0x92>
8000c08e:	18 0e       	add	lr,r12
8000c090:	18 3e       	cp.w	lr,r12
8000c092:	c0 43       	brcs	8000c09a <__avr32_umod64+0x92>
8000c094:	16 3e       	cp.w	lr,r11
8000c096:	fd dc e3 0e 	addcs	lr,lr,r12
8000c09a:	fc 0b 01 03 	sub	r3,lr,r11
8000c09e:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c0a2:	e6 05 0d 02 	divu	r2,r3,r5
8000c0a6:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c0aa:	a5 36       	mul	r6,r2
8000c0ac:	0c 39       	cp.w	r9,r6
8000c0ae:	c0 72       	brcc	8000c0bc <__avr32_umod64+0xb4>
8000c0b0:	18 09       	add	r9,r12
8000c0b2:	18 39       	cp.w	r9,r12
8000c0b4:	c0 43       	brcs	8000c0bc <__avr32_umod64+0xb4>
8000c0b6:	0c 39       	cp.w	r9,r6
8000c0b8:	f3 dc e3 09 	addcs	r9,r9,r12
8000c0bc:	f2 06 01 06 	sub	r6,r9,r6
8000c0c0:	f4 08 09 4e 	lsl	lr,r10,r8
8000c0c4:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c0c8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c0cc:	ec 0a 0d 02 	divu	r2,r6,r10
8000c0d0:	fc 09 16 10 	lsr	r9,lr,0x10
8000c0d4:	ea 02 02 4b 	mul	r11,r5,r2
8000c0d8:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c0dc:	16 39       	cp.w	r9,r11
8000c0de:	c0 72       	brcc	8000c0ec <__avr32_umod64+0xe4>
8000c0e0:	18 09       	add	r9,r12
8000c0e2:	18 39       	cp.w	r9,r12
8000c0e4:	c0 43       	brcs	8000c0ec <__avr32_umod64+0xe4>
8000c0e6:	16 39       	cp.w	r9,r11
8000c0e8:	f3 dc e3 09 	addcs	r9,r9,r12
8000c0ec:	f2 0b 01 0b 	sub	r11,r9,r11
8000c0f0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c0f4:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c0f8:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c0fc:	ea 0a 02 4a 	mul	r10,r5,r10
8000c100:	14 3e       	cp.w	lr,r10
8000c102:	c0 72       	brcc	8000c110 <__avr32_umod64+0x108>
8000c104:	18 0e       	add	lr,r12
8000c106:	18 3e       	cp.w	lr,r12
8000c108:	c0 43       	brcs	8000c110 <__avr32_umod64+0x108>
8000c10a:	14 3e       	cp.w	lr,r10
8000c10c:	fd dc e3 0e 	addcs	lr,lr,r12
8000c110:	fc 0a 01 0a 	sub	r10,lr,r10
8000c114:	30 0b       	mov	r11,0
8000c116:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c11a:	c7 b8       	rjmp	8000c210 <__avr32_umod64+0x208>
8000c11c:	16 39       	cp.w	r9,r11
8000c11e:	e0 8b 00 79 	brhi	8000c210 <__avr32_umod64+0x208>
8000c122:	f2 09 12 00 	clz	r9,r9
8000c126:	c1 21       	brne	8000c14a <__avr32_umod64+0x142>
8000c128:	10 3a       	cp.w	r10,r8
8000c12a:	5f 2b       	srhs	r11
8000c12c:	0a 31       	cp.w	r1,r5
8000c12e:	5f ba       	srhi	r10
8000c130:	f7 ea 10 0a 	or	r10,r11,r10
8000c134:	f2 0a 18 00 	cp.b	r10,r9
8000c138:	c0 60       	breq	8000c144 <__avr32_umod64+0x13c>
8000c13a:	fc 08 01 0c 	sub	r12,lr,r8
8000c13e:	e2 05 01 46 	sbc	r6,r1,r5
8000c142:	18 9e       	mov	lr,r12
8000c144:	0c 9b       	mov	r11,r6
8000c146:	1c 9a       	mov	r10,lr
8000c148:	c6 48       	rjmp	8000c210 <__avr32_umod64+0x208>
8000c14a:	ea 09 09 4c 	lsl	r12,r5,r9
8000c14e:	f2 06 11 20 	rsub	r6,r9,32
8000c152:	f6 09 09 4b 	lsl	r11,r11,r9
8000c156:	f0 09 09 42 	lsl	r2,r8,r9
8000c15a:	ef 46 ff f4 	st.w	r7[-12],r6
8000c15e:	f0 06 0a 48 	lsr	r8,r8,r6
8000c162:	18 48       	or	r8,r12
8000c164:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c168:	f4 09 09 43 	lsl	r3,r10,r9
8000c16c:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c170:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c174:	16 4a       	or	r10,r11
8000c176:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c17a:	f8 0b 0d 04 	divu	r4,r12,r11
8000c17e:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c182:	08 91       	mov	r1,r4
8000c184:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c188:	e8 0e 02 46 	mul	r6,r4,lr
8000c18c:	0c 3c       	cp.w	r12,r6
8000c18e:	c0 a2       	brcc	8000c1a2 <__avr32_umod64+0x19a>
8000c190:	20 11       	sub	r1,1
8000c192:	10 0c       	add	r12,r8
8000c194:	10 3c       	cp.w	r12,r8
8000c196:	c0 63       	brcs	8000c1a2 <__avr32_umod64+0x19a>
8000c198:	0c 3c       	cp.w	r12,r6
8000c19a:	f7 b1 03 01 	sublo	r1,1
8000c19e:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c1a2:	0c 1c       	sub	r12,r6
8000c1a4:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c1a8:	f8 0b 0d 04 	divu	r4,r12,r11
8000c1ac:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c1b0:	08 96       	mov	r6,r4
8000c1b2:	e8 0e 02 4e 	mul	lr,r4,lr
8000c1b6:	1c 3b       	cp.w	r11,lr
8000c1b8:	c0 a2       	brcc	8000c1cc <__avr32_umod64+0x1c4>
8000c1ba:	20 16       	sub	r6,1
8000c1bc:	10 0b       	add	r11,r8
8000c1be:	10 3b       	cp.w	r11,r8
8000c1c0:	c0 63       	brcs	8000c1cc <__avr32_umod64+0x1c4>
8000c1c2:	1c 3b       	cp.w	r11,lr
8000c1c4:	f7 b6 03 01 	sublo	r6,1
8000c1c8:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c1cc:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c1d0:	1c 1b       	sub	r11,lr
8000c1d2:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c1d6:	00 9e       	mov	lr,r0
8000c1d8:	02 9c       	mov	r12,r1
8000c1da:	16 3c       	cp.w	r12,r11
8000c1dc:	e0 8b 00 08 	brhi	8000c1ec <__avr32_umod64+0x1e4>
8000c1e0:	5f 06       	sreq	r6
8000c1e2:	06 30       	cp.w	r0,r3
8000c1e4:	5f ba       	srhi	r10
8000c1e6:	ed ea 00 0a 	and	r10,r6,r10
8000c1ea:	c0 60       	breq	8000c1f6 <__avr32_umod64+0x1ee>
8000c1ec:	fc 02 01 04 	sub	r4,lr,r2
8000c1f0:	f8 08 01 4c 	sbc	r12,r12,r8
8000c1f4:	08 9e       	mov	lr,r4
8000c1f6:	e6 0e 01 0a 	sub	r10,r3,lr
8000c1fa:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c1fe:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c202:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c206:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c20a:	f8 01 09 4c 	lsl	r12,r12,r1
8000c20e:	18 4a       	or	r10,r12
8000c210:	2f dd       	sub	sp,-12
8000c212:	d8 32       	popm	r0-r7,pc

8000c214 <__do_global_ctors_aux>:
8000c214:	d4 21       	pushm	r4-r7,lr
8000c216:	30 c7       	mov	r7,12
8000c218:	c0 28       	rjmp	8000c21c <__do_global_ctors_aux+0x8>
8000c21a:	5d 18       	icall	r8
8000c21c:	20 47       	sub	r7,4
8000c21e:	6e 08       	ld.w	r8,r7[0x0]
8000c220:	5b f8       	cp.w	r8,-1
8000c222:	cf c1       	brne	8000c21a <__do_global_ctors_aux+0x6>
8000c224:	d8 22       	popm	r4-r7,pc
8000c226:	d7 03       	nop

Disassembly of section .exception:

8000c400 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
8000c400:	c0 08       	rjmp	8000c400 <_evba>
	...

8000c404 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
8000c404:	c0 08       	rjmp	8000c404 <_handle_TLB_Multiple_Hit>
	...

8000c408 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
8000c408:	c0 08       	rjmp	8000c408 <_handle_Bus_Error_Data_Fetch>
	...

8000c40c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000c40c:	c0 08       	rjmp	8000c40c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c410 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
8000c410:	c0 08       	rjmp	8000c410 <_handle_NMI>
	...

8000c414 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
8000c414:	c0 08       	rjmp	8000c414 <_handle_Instruction_Address>
	...

8000c418 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
8000c418:	c0 08       	rjmp	8000c418 <_handle_ITLB_Protection>
	...

8000c41c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000c41c:	c0 08       	rjmp	8000c41c <_handle_Breakpoint>
	...

8000c420 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
8000c420:	c0 08       	rjmp	8000c420 <_handle_Illegal_Opcode>
	...

8000c424 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
8000c424:	c0 08       	rjmp	8000c424 <_handle_Unimplemented_Instruction>
	...

8000c428 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
8000c428:	c0 08       	rjmp	8000c428 <_handle_Privilege_Violation>
	...

8000c42c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000c42c:	c0 08       	rjmp	8000c42c <_handle_Floating_Point>
	...

8000c430 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
8000c430:	c0 08       	rjmp	8000c430 <_handle_Coprocessor_Absent>
	...

8000c434 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
8000c434:	c0 08       	rjmp	8000c434 <_handle_Data_Address_Read>
	...

8000c438 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
8000c438:	c0 08       	rjmp	8000c438 <_handle_Data_Address_Write>
	...

8000c43c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000c43c:	c0 08       	rjmp	8000c43c <_handle_DTLB_Protection_Read>
	...

8000c440 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
8000c440:	c0 08       	rjmp	8000c440 <_handle_DTLB_Protection_Write>
	...

8000c444 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
8000c444:	c0 08       	rjmp	8000c444 <_handle_DTLB_Modified>
	...

8000c450 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
8000c450:	c0 08       	rjmp	8000c450 <_handle_ITLB_Miss>
	...

8000c460 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
8000c460:	c0 08       	rjmp	8000c460 <_handle_DTLB_Miss_Read>
	...

8000c470 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
8000c470:	c0 08       	rjmp	8000c470 <_handle_DTLB_Miss_Write>
	...

8000c500 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c500:	fe cf 77 e0 	sub	pc,pc,30688

8000c504 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c504:	30 0c       	mov	r12,0
8000c506:	fe b0 be 9d 	rcall	80004240 <_get_interrupt_handler>
8000c50a:	58 0c       	cp.w	r12,0
8000c50c:	f8 0f 17 10 	movne	pc,r12
8000c510:	d6 03       	rete

8000c512 <_int1>:
8000c512:	30 1c       	mov	r12,1
8000c514:	fe b0 be 96 	rcall	80004240 <_get_interrupt_handler>
8000c518:	58 0c       	cp.w	r12,0
8000c51a:	f8 0f 17 10 	movne	pc,r12
8000c51e:	d6 03       	rete

8000c520 <_int2>:
8000c520:	30 2c       	mov	r12,2
8000c522:	fe b0 be 8f 	rcall	80004240 <_get_interrupt_handler>
8000c526:	58 0c       	cp.w	r12,0
8000c528:	f8 0f 17 10 	movne	pc,r12
8000c52c:	d6 03       	rete

8000c52e <_int3>:
8000c52e:	30 3c       	mov	r12,3
8000c530:	fe b0 be 88 	rcall	80004240 <_get_interrupt_handler>
8000c534:	58 0c       	cp.w	r12,0
8000c536:	f8 0f 17 10 	movne	pc,r12
8000c53a:	d6 03       	rete
8000c53c:	d7 03       	nop
8000c53e:	d7 03       	nop
8000c540:	d7 03       	nop
8000c542:	d7 03       	nop
8000c544:	d7 03       	nop
8000c546:	d7 03       	nop
8000c548:	d7 03       	nop
8000c54a:	d7 03       	nop
8000c54c:	d7 03       	nop
8000c54e:	d7 03       	nop
8000c550:	d7 03       	nop
8000c552:	d7 03       	nop
8000c554:	d7 03       	nop
8000c556:	d7 03       	nop
8000c558:	d7 03       	nop
8000c55a:	d7 03       	nop
8000c55c:	d7 03       	nop
8000c55e:	d7 03       	nop
8000c560:	d7 03       	nop
8000c562:	d7 03       	nop
8000c564:	d7 03       	nop
8000c566:	d7 03       	nop
8000c568:	d7 03       	nop
8000c56a:	d7 03       	nop
8000c56c:	d7 03       	nop
8000c56e:	d7 03       	nop
8000c570:	d7 03       	nop
8000c572:	d7 03       	nop
8000c574:	d7 03       	nop
8000c576:	d7 03       	nop
8000c578:	d7 03       	nop
8000c57a:	d7 03       	nop
8000c57c:	d7 03       	nop
8000c57e:	d7 03       	nop
8000c580:	d7 03       	nop
8000c582:	d7 03       	nop
8000c584:	d7 03       	nop
8000c586:	d7 03       	nop
8000c588:	d7 03       	nop
8000c58a:	d7 03       	nop
8000c58c:	d7 03       	nop
8000c58e:	d7 03       	nop
8000c590:	d7 03       	nop
8000c592:	d7 03       	nop
8000c594:	d7 03       	nop
8000c596:	d7 03       	nop
8000c598:	d7 03       	nop
8000c59a:	d7 03       	nop
8000c59c:	d7 03       	nop
8000c59e:	d7 03       	nop
8000c5a0:	d7 03       	nop
8000c5a2:	d7 03       	nop
8000c5a4:	d7 03       	nop
8000c5a6:	d7 03       	nop
8000c5a8:	d7 03       	nop
8000c5aa:	d7 03       	nop
8000c5ac:	d7 03       	nop
8000c5ae:	d7 03       	nop
8000c5b0:	d7 03       	nop
8000c5b2:	d7 03       	nop
8000c5b4:	d7 03       	nop
8000c5b6:	d7 03       	nop
8000c5b8:	d7 03       	nop
8000c5ba:	d7 03       	nop
8000c5bc:	d7 03       	nop
8000c5be:	d7 03       	nop
8000c5c0:	d7 03       	nop
8000c5c2:	d7 03       	nop
8000c5c4:	d7 03       	nop
8000c5c6:	d7 03       	nop
8000c5c8:	d7 03       	nop
8000c5ca:	d7 03       	nop
8000c5cc:	d7 03       	nop
8000c5ce:	d7 03       	nop
8000c5d0:	d7 03       	nop
8000c5d2:	d7 03       	nop
8000c5d4:	d7 03       	nop
8000c5d6:	d7 03       	nop
8000c5d8:	d7 03       	nop
8000c5da:	d7 03       	nop
8000c5dc:	d7 03       	nop
8000c5de:	d7 03       	nop
8000c5e0:	d7 03       	nop
8000c5e2:	d7 03       	nop
8000c5e4:	d7 03       	nop
8000c5e6:	d7 03       	nop
8000c5e8:	d7 03       	nop
8000c5ea:	d7 03       	nop
8000c5ec:	d7 03       	nop
8000c5ee:	d7 03       	nop
8000c5f0:	d7 03       	nop
8000c5f2:	d7 03       	nop
8000c5f4:	d7 03       	nop
8000c5f6:	d7 03       	nop
8000c5f8:	d7 03       	nop
8000c5fa:	d7 03       	nop
8000c5fc:	d7 03       	nop
8000c5fe:	d7 03       	nop

Disassembly of section .fini:

8000c600 <_fini>:
8000c600:	eb cd 40 40 	pushm	r6,lr
8000c604:	48 26       	lddpc	r6,8000c60c <_fini+0xc>
8000c606:	1e 26       	rsub	r6,pc
8000c608:	c0 48       	rjmp	8000c610 <_fini+0x10>
8000c60a:	d7 03       	nop
8000c60c:	80 00       	ld.sh	r0,r0[0x0]
8000c60e:	c5 ea       	rjmp	8000c2ca <__do_global_ctors_aux+0xb6>
8000c610:	fe b0 ad 3e 	rcall	8000208c <__do_global_dtors_aux>
8000c614:	e3 cd 80 40 	ldm	sp++,r6,pc
