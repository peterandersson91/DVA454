
Lab61b.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         00002fb4  80002028  80002028  00002428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  80005000  80005000  00005400  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  80005200  80005200  00005600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       00000150  80005218  80005218  00005618  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  8 .ctors        00000008  00000008  80005368  00005808  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .dtors        00000008  00000010  80005370  00005810  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .jcr          00000004  00000018  80005378  00005818  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got          00000000  0000001c  8000537c  0000581c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         0000050c  0000001c  8000537c  0000581c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .balign       00000000  00000528  80005888  00005d28  2**0
                  ALLOC
 14 .bss          00000288  00000528  00000528  00000000  2**2
                  ALLOC
 15 .heap         0000e850  000007b0  000007b0  00000000  2**0
                  ALLOC
 16 .comment      00000030  00000000  00000000  00005d28  2**0
                  CONTENTS, READONLY
 17 .debug_aranges 00000a78  00000000  00000000  00005d58  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_pubnames 00001516  00000000  00000000  000067d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_info   00013109  00000000  00000000  00007ce6  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_abbrev 00002941  00000000  00000000  0001adef  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_line   00009595  00000000  00000000  0001d730  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_frame  00001c68  00000000  00000000  00026cc8  2**2
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_str    00003697  00000000  00000000  00028930  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_loc    00003133  00000000  00000000  0002bfc7  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_macinfo 00b3c3e6  00000000  00000000  0002f0fa  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 27 .debug_ranges 000009a0  00000000  00000000  00b6b4e0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	20 28       	sub	r8,2

80000008 <_trampoline>:
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:
80002008:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

8000200c <_init>:
8000200c:	eb cd 40 40 	pushm	r6,lr
80002010:	48 26       	lddpc	r6,80002018 <_init+0xc>
80002012:	1e 26       	rsub	r6,pc
80002014:	c0 48       	rjmp	8000201c <_init+0x10>
80002016:	d7 03       	nop
80002018:	80 00       	ld.sh	r0,r0[0x0]
8000201a:	1f f6       	ld.ub	r6,pc[0x7]
8000201c:	c5 2c       	rcall	800020c0 <frame_dummy>
8000201e:	e0 a0 17 d5 	rcall	80004fc8 <__do_global_ctors_aux>
80002022:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002028 <_stext>:
80002028:	30 07       	mov	r7,0
8000202a:	e0 7a 00 00 	mov	r10,65536
8000202e:	5b fa       	cp.w	r10,-1
80002030:	f4 0d 17 10 	movne	sp,r10
80002034:	fe cb cc cc 	sub	r11,pc,-13108
80002038:	30 8c       	mov	r12,8
8000203a:	18 3b       	cp.w	r11,r12
8000203c:	c0 70       	breq	8000204a <_stext+0x22>
8000203e:	e0 6a 05 28 	mov	r10,1320
80002042:	b7 09       	ld.d	r8,r11++
80002044:	b9 28       	st.d	r12++,r8
80002046:	14 3c       	cp.w	r12,r10
80002048:	cf d5       	brlt	80002042 <_stext+0x1a>
8000204a:	e0 6a 07 b0 	mov	r10,1968
8000204e:	e0 6c 05 28 	mov	r12,1320
80002052:	30 08       	mov	r8,0
80002054:	30 09       	mov	r9,0
80002056:	b9 28       	st.d	r12++,r8
80002058:	14 3c       	cp.w	r12,r10
8000205a:	cf e5       	brlt	80002056 <_stext+0x2e>
8000205c:	e0 a0 07 52 	rcall	80002f00 <_init_startup>
80002060:	fe cc ce 60 	sub	r12,pc,-12704
80002064:	e0 a0 12 a8 	rcall	800045b4 <atexit>
80002068:	cd 2f       	rcall	8000200c <_init>
8000206a:	1a 9c       	mov	r12,sp
8000206c:	30 0b       	mov	r11,0
8000206e:	e0 a0 15 bb 	rcall	80004be4 <_init_argv>
80002072:	5b fc       	cp.w	r12,-1
80002074:	f9 bc 00 00 	moveq	r12,0
80002078:	f9 ba 00 00 	moveq	r10,0
8000207c:	14 1d       	sub	sp,r10
8000207e:	c6 7d       	rcall	8000234c <main>
80002080:	e0 a0 12 a2 	rcall	800045c4 <exit>

80002084 <__do_global_dtors_aux>:
80002084:	d4 21       	pushm	r4-r7,lr
80002086:	e0 68 05 28 	mov	r8,1320
8000208a:	11 89       	ld.ub	r9,r8[0x0]
8000208c:	30 08       	mov	r8,0
8000208e:	f0 09 18 00 	cp.b	r9,r8
80002092:	c1 61       	brne	800020be <__do_global_dtors_aux+0x3a>
80002094:	31 08       	mov	r8,16
80002096:	31 46       	mov	r6,20
80002098:	10 95       	mov	r5,r8
8000209a:	10 16       	sub	r6,r8
8000209c:	e0 67 05 2c 	mov	r7,1324
800020a0:	a3 46       	asr	r6,0x2
800020a2:	20 16       	sub	r6,1
800020a4:	c0 68       	rjmp	800020b0 <__do_global_dtors_aux+0x2c>
800020a6:	2f f8       	sub	r8,-1
800020a8:	8f 08       	st.w	r7[0x0],r8
800020aa:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020ae:	5d 18       	icall	r8
800020b0:	6e 08       	ld.w	r8,r7[0x0]
800020b2:	0c 38       	cp.w	r8,r6
800020b4:	cf 93       	brcs	800020a6 <__do_global_dtors_aux+0x22>
800020b6:	30 19       	mov	r9,1
800020b8:	e0 68 05 28 	mov	r8,1320
800020bc:	b0 89       	st.b	r8[0x0],r9
800020be:	d8 22       	popm	r4-r7,pc

800020c0 <frame_dummy>:
800020c0:	d4 01       	pushm	lr
800020c2:	31 8c       	mov	r12,24
800020c4:	78 08       	ld.w	r8,r12[0x0]
800020c6:	58 08       	cp.w	r8,0
800020c8:	c0 50       	breq	800020d2 <frame_dummy+0x12>
800020ca:	48 38       	lddpc	r8,800020d4 <frame_dummy+0x14>
800020cc:	58 08       	cp.w	r8,0
800020ce:	c0 20       	breq	800020d2 <frame_dummy+0x12>
800020d0:	5d 18       	icall	r8
800020d2:	d8 02       	popm	pc
800020d4:	00 00       	add	r0,r0
	...

800020d8 <initLED>:
800020d8:	eb cd 40 80 	pushm	r7,lr
800020dc:	1a 97       	mov	r7,sp
800020de:	20 1d       	sub	sp,4
800020e0:	fe 78 11 00 	mov	r8,-61184
800020e4:	ef 48 ff fc 	st.w	r7[-4],r8
800020e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800020ec:	fc 19 08 00 	movh	r9,0x800
800020f0:	91 19       	st.w	r8[0x4],r9
800020f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800020f6:	fc 19 10 00 	movh	r9,0x1000
800020fa:	91 19       	st.w	r8[0x4],r9
800020fc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002100:	fc 19 20 00 	movh	r9,0x2000
80002104:	91 19       	st.w	r8[0x4],r9
80002106:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000210a:	fc 19 08 00 	movh	r9,0x800
8000210e:	f1 49 00 54 	st.w	r8[84],r9
80002112:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002116:	fc 19 10 00 	movh	r9,0x1000
8000211a:	f1 49 00 54 	st.w	r8[84],r9
8000211e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002122:	fc 19 20 00 	movh	r9,0x2000
80002126:	f1 49 00 54 	st.w	r8[84],r9
8000212a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000212e:	fc 19 08 00 	movh	r9,0x800
80002132:	f1 49 00 44 	st.w	r8[68],r9
80002136:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000213a:	fc 19 10 00 	movh	r9,0x1000
8000213e:	f1 49 00 44 	st.w	r8[68],r9
80002142:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002146:	fc 19 20 00 	movh	r9,0x2000
8000214a:	f1 49 00 44 	st.w	r8[68],r9
8000214e:	2f fd       	sub	sp,-4
80002150:	e3 cd 80 80 	ldm	sp++,r7,pc

80002154 <onLED>:
80002154:	eb cd 40 80 	pushm	r7,lr
80002158:	1a 97       	mov	r7,sp
8000215a:	20 1d       	sub	sp,4
8000215c:	ef 4c ff fc 	st.w	r7[-4],r12
80002160:	fe 78 10 00 	mov	r8,-61440
80002164:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002168:	f1 49 01 58 	st.w	r8[344],r9
8000216c:	2f fd       	sub	sp,-4
8000216e:	e3 cd 80 80 	ldm	sp++,r7,pc

80002172 <offLED>:
80002172:	eb cd 40 80 	pushm	r7,lr
80002176:	1a 97       	mov	r7,sp
80002178:	20 1d       	sub	sp,4
8000217a:	ef 4c ff fc 	st.w	r7[-4],r12
8000217e:	fe 78 10 00 	mov	r8,-61440
80002182:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002186:	f1 49 01 54 	st.w	r8[340],r9
8000218a:	2f fd       	sub	sp,-4
8000218c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002190:	76 50       	ld.w	r0,r11[0x14]
80002192:	72 6f       	ld.w	pc,r9[0x18]
80002194:	64 75       	ld.w	r5,r2[0x1c]
80002196:	63 65       	ld.w	r5,r1[0x58]
80002198:	72 00       	ld.w	r0,r9[0x0]
8000219a:	00 00       	add	r0,r0
8000219c:	76 43       	ld.w	r3,r11[0x10]
8000219e:	6f 6e       	ld.w	lr,r7[0x58]
800021a0:	73 75       	ld.w	r5,r9[0x5c]
800021a2:	6d 65       	ld.w	r5,r6[0x58]
800021a4:	72 00       	ld.w	r0,r9[0x0]
	...

800021a8 <init_usart>:
		cycles--;
	}
}

void init_usart ( void )
{
800021a8:	eb cd 40 80 	pushm	r7,lr
800021ac:	1a 97       	mov	r7,sp
		. charlength = 8,
		. paritytype = USART_NO_PARITY ,
		. stopbits = USART_1_STOPBIT ,
		. channelmode = USART_NORMAL_CHMODE
	};
	pm_switch_to_osc0 (& AVR32_PM , FOSC0 , OSC0_STARTUP );
800021ae:	30 3a       	mov	r10,3
800021b0:	e0 6b 1b 00 	mov	r11,6912
800021b4:	ea 1b 00 b7 	orh	r11,0xb7
800021b8:	fe 7c 0c 00 	mov	r12,-62464
800021bc:	f0 1f 00 0f 	mcall	800021f8 <init_usart+0x50>
	gpio_enable_module ( USART_SERIAL_GPIO_MAP , 2);
800021c0:	30 2b       	mov	r11,2
800021c2:	48 fc       	lddpc	r12,800021fc <init_usart+0x54>
800021c4:	f0 1f 00 0f 	mcall	80002200 <init_usart+0x58>
	gpio_enable_module ( USART_DEBUG_GPIO_MAP , 2);
800021c8:	30 2b       	mov	r11,2
800021ca:	48 fc       	lddpc	r12,80002204 <init_usart+0x5c>
800021cc:	f0 1f 00 0d 	mcall	80002200 <init_usart+0x58>
	usart_init_rs232 ( serialPORT_USART , & USART_OPTIONS , FOSC0 );
800021d0:	e0 6a 1b 00 	mov	r10,6912
800021d4:	ea 1a 00 b7 	orh	r10,0xb7
800021d8:	48 cb       	lddpc	r11,80002208 <init_usart+0x60>
800021da:	fe 7c 18 00 	mov	r12,-59392
800021de:	f0 1f 00 0c 	mcall	8000220c <init_usart+0x64>
	usart_init_rs232 ( configDBG_USART , & USART_OPTIONS , FOSC0 );
800021e2:	e0 6a 1b 00 	mov	r10,6912
800021e6:	ea 1a 00 b7 	orh	r10,0xb7
800021ea:	48 8b       	lddpc	r11,80002208 <init_usart+0x60>
800021ec:	fe 7c 18 00 	mov	r12,-59392
800021f0:	f0 1f 00 07 	mcall	8000220c <init_usart+0x64>
}
800021f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800021f8:	80 00       	ld.sh	r0,r0[0x0]
800021fa:	29 24       	sub	r4,-110
800021fc:	80 00       	ld.sh	r0,r0[0x0]
800021fe:	52 18       	stdsp	sp[0x84],r8
80002200:	80 00       	ld.sh	r0,r0[0x0]
80002202:	24 04       	sub	r4,64
80002204:	80 00       	ld.sh	r0,r0[0x0]
80002206:	52 28       	stdsp	sp[0x88],r8
80002208:	80 00       	ld.sh	r0,r0[0x0]
8000220a:	52 38       	stdsp	sp[0x8c],r8
8000220c:	80 00       	ld.sh	r0,r0[0x0]
8000220e:	2a d4       	sub	r4,-83

80002210 <vProducer>:

void vProducer(void *pvParameters)
{	
80002210:	eb cd 40 80 	pushm	r7,lr
80002214:	1a 97       	mov	r7,sp
80002216:	20 ad       	sub	sp,40
80002218:	ef 4c ff d8 	st.w	r7[-40],r12
	struct msg message;
	message.id = 0;
8000221c:	30 08       	mov	r8,0
8000221e:	ef 48 ff ec 	st.w	r7[-20],r8
	//message.data = 0;
	message.timestamp = 0;
80002222:	30 08       	mov	r8,0
80002224:	ef 48 ff fc 	st.w	r7[-4],r8
	
	struct msg *pMesg = &message;
80002228:	ee c8 00 14 	sub	r8,r7,20
8000222c:	ef 48 ff e8 	st.w	r7[-24],r8
	
	char data[DATALEN] = "hej\n";
80002230:	30 08       	mov	r8,0
80002232:	e0 69 6a 0a 	mov	r9,27146
80002236:	ea 19 68 65 	orh	r9,0x6865
8000223a:	ee e9 ff dc 	st.d	r7[-36],r8
8000223e:	30 08       	mov	r8,0
80002240:	ef 58 ff e4 	st.h	r7[-28],r8
	//int i = byteCount;
	
	onLED(LED0_BIT_VALUE);
80002244:	fc 1c 08 00 	movh	r12,0x800
80002248:	f0 1f 00 17 	mcall	800022a4 <vProducer+0x94>
	
	while(1)
	{
		offLED(LED0_BIT_VALUE);
8000224c:	fc 1c 08 00 	movh	r12,0x800
80002250:	f0 1f 00 16 	mcall	800022a8 <vProducer+0x98>
		if(xSemaphoreTake(xEmptyCount, (portTickType)portMAX_DELAY) == pdTRUE)
80002254:	49 68       	lddpc	r8,800022ac <vProducer+0x9c>
80002256:	70 08       	ld.w	r8,r8[0x0]
80002258:	30 09       	mov	r9,0
8000225a:	3f fa       	mov	r10,-1
8000225c:	30 0b       	mov	r11,0
8000225e:	10 9c       	mov	r12,r8
80002260:	f0 1f 00 14 	mcall	800022b0 <vProducer+0xa0>
		{
			// Semaphore taken
		}
		onLED(LED0_BIT_VALUE);
80002264:	fc 1c 08 00 	movh	r12,0x800
80002268:	f0 1f 00 0f 	mcall	800022a4 <vProducer+0x94>
		
		strcpy(pMesg->data, data);
8000226c:	ee f8 ff e8 	ld.w	r8,r7[-24]
80002270:	2f c8       	sub	r8,-4
80002272:	ee c9 00 24 	sub	r9,r7,36
80002276:	12 9b       	mov	r11,r9
80002278:	10 9c       	mov	r12,r8
8000227a:	f0 1f 00 0f 	mcall	800022b4 <vProducer+0xa4>
		xQueueSendToBack(xQHandle, &pMesg, (portTickType)10);
8000227e:	48 f8       	lddpc	r8,800022b8 <vProducer+0xa8>
80002280:	70 08       	ld.w	r8,r8[0x0]
80002282:	ee cb 00 18 	sub	r11,r7,24
80002286:	30 09       	mov	r9,0
80002288:	30 aa       	mov	r10,10
8000228a:	10 9c       	mov	r12,r8
8000228c:	f0 1f 00 0c 	mcall	800022bc <vProducer+0xac>
		
		if(xSemaphoreGive(xFillCount) == pdTRUE)
80002290:	48 c8       	lddpc	r8,800022c0 <vProducer+0xb0>
80002292:	70 08       	ld.w	r8,r8[0x0]
80002294:	30 09       	mov	r9,0
80002296:	30 0a       	mov	r10,0
80002298:	30 0b       	mov	r11,0
8000229a:	10 9c       	mov	r12,r8
8000229c:	f0 1f 00 08 	mcall	800022bc <vProducer+0xac>
		{
			// Semaphore given
		}
	}
800022a0:	cd 6b       	rjmp	8000224c <vProducer+0x3c>
800022a2:	00 00       	add	r0,r0
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	21 54       	sub	r4,21
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	21 72       	sub	r2,23
800022ac:	00 00       	add	r0,r0
800022ae:	07 a0       	ld.ub	r0,r3[0x2]
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	36 70       	mov	r0,103
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	4b b0       	lddpc	r0,800023a0 <main+0x54>
800022b8:	00 00       	add	r0,r0
800022ba:	07 94       	ld.ub	r4,r3[0x1]
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	35 08       	mov	r8,80
800022c0:	00 00       	add	r0,r0
800022c2:	07 90       	ld.ub	r0,r3[0x1]

800022c4 <vConsumer>:
}

void vConsumer( void *pvParameters )
{
800022c4:	eb cd 40 80 	pushm	r7,lr
800022c8:	1a 97       	mov	r7,sp
800022ca:	20 2d       	sub	sp,8
800022cc:	ef 4c ff f8 	st.w	r7[-8],r12
	struct msg *pMesg;
	
	onLED(LED1_BIT_VALUE);
800022d0:	fc 1c 10 00 	movh	r12,0x1000
800022d4:	f0 1f 00 16 	mcall	8000232c <vConsumer+0x68>
	
	while(1)
	{
		offLED(LED1_BIT_VALUE);
800022d8:	fc 1c 10 00 	movh	r12,0x1000
800022dc:	f0 1f 00 15 	mcall	80002330 <vConsumer+0x6c>
		if(xSemaphoreTake(xFillCount, (portTickType)portMAX_DELAY) == pdTRUE)
800022e0:	49 58       	lddpc	r8,80002334 <vConsumer+0x70>
800022e2:	70 08       	ld.w	r8,r8[0x0]
800022e4:	30 09       	mov	r9,0
800022e6:	3f fa       	mov	r10,-1
800022e8:	30 0b       	mov	r11,0
800022ea:	10 9c       	mov	r12,r8
800022ec:	f0 1f 00 13 	mcall	80002338 <vConsumer+0x74>
		{
			// Semaphore taken
		}
		onLED(LED1_BIT_VALUE);
800022f0:	fc 1c 10 00 	movh	r12,0x1000
800022f4:	f0 1f 00 0e 	mcall	8000232c <vConsumer+0x68>
		
		xQueueReceive(xQHandle, &pMesg, (portTickType)10);
800022f8:	49 18       	lddpc	r8,8000233c <vConsumer+0x78>
800022fa:	70 08       	ld.w	r8,r8[0x0]
800022fc:	ee cb 00 04 	sub	r11,r7,4
80002300:	30 09       	mov	r9,0
80002302:	30 aa       	mov	r10,10
80002304:	10 9c       	mov	r12,r8
80002306:	f0 1f 00 0d 	mcall	80002338 <vConsumer+0x74>
		usart_write_line(serialPORT_USART, pMesg->data);
8000230a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000230e:	2f c8       	sub	r8,-4
80002310:	10 9b       	mov	r11,r8
80002312:	fe 7c 18 00 	mov	r12,-59392
80002316:	f0 1f 00 0b 	mcall	80002340 <vConsumer+0x7c>
		
		if(xSemaphoreGive(xEmptyCount) == pdTRUE)
8000231a:	48 b8       	lddpc	r8,80002344 <vConsumer+0x80>
8000231c:	70 08       	ld.w	r8,r8[0x0]
8000231e:	30 09       	mov	r9,0
80002320:	30 0a       	mov	r10,0
80002322:	30 0b       	mov	r11,0
80002324:	10 9c       	mov	r12,r8
80002326:	f0 1f 00 09 	mcall	80002348 <vConsumer+0x84>
		{
			// Semaphore given
		}
	}
8000232a:	cd 7b       	rjmp	800022d8 <vConsumer+0x14>
8000232c:	80 00       	ld.sh	r0,r0[0x0]
8000232e:	21 54       	sub	r4,21
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	21 72       	sub	r2,23
80002334:	00 00       	add	r0,r0
80002336:	07 90       	ld.ub	r0,r3[0x1]
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	36 70       	mov	r0,103
8000233c:	00 00       	add	r0,r0
8000233e:	07 94       	ld.ub	r4,r3[0x1]
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	2c dc       	sub	r12,-51
80002344:	00 00       	add	r0,r0
80002346:	07 a0       	ld.ub	r0,r3[0x2]
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	35 08       	mov	r8,80

8000234c <main>:
}

int main(void)
{
8000234c:	eb cd 40 80 	pushm	r7,lr
80002350:	1a 97       	mov	r7,sp
	initLED();
80002352:	f0 1f 00 1e 	mcall	800023c8 <main+0x7c>
	init_usart();
80002356:	f0 1f 00 1e 	mcall	800023cc <main+0x80>
	
	xFillCount = xSemaphoreCreateCounting(BUFFER_SIZE, 0);
8000235a:	30 0b       	mov	r11,0
8000235c:	30 ac       	mov	r12,10
8000235e:	f0 1f 00 1d 	mcall	800023d0 <main+0x84>
80002362:	18 99       	mov	r9,r12
80002364:	49 c8       	lddpc	r8,800023d4 <main+0x88>
80002366:	91 09       	st.w	r8[0x0],r9
	xEmptyCount = xSemaphoreCreateCounting(BUFFER_SIZE, BUFFER_SIZE);
80002368:	30 ab       	mov	r11,10
8000236a:	30 ac       	mov	r12,10
8000236c:	f0 1f 00 19 	mcall	800023d0 <main+0x84>
80002370:	18 99       	mov	r9,r12
80002372:	49 a8       	lddpc	r8,800023d8 <main+0x8c>
80002374:	91 09       	st.w	r8[0x0],r9
	
	xQHandle = xQueueCreate(10, sizeof(struct msg*));
80002376:	30 4b       	mov	r11,4
80002378:	30 ac       	mov	r12,10
8000237a:	f0 1f 00 19 	mcall	800023dc <main+0x90>
8000237e:	18 99       	mov	r9,r12
80002380:	49 88       	lddpc	r8,800023e0 <main+0x94>
80002382:	91 09       	st.w	r8[0x0],r9
	{
		//ERROR!
	}
	
	// Create the task , store the handle .
	xTaskCreate(	vProducer,
80002384:	49 8b       	lddpc	r11,800023e4 <main+0x98>
80002386:	30 08       	mov	r8,0
80002388:	1a d8       	st.w	--sp,r8
8000238a:	30 08       	mov	r8,0
8000238c:	1a d8       	st.w	--sp,r8
8000238e:	49 78       	lddpc	r8,800023e8 <main+0x9c>
80002390:	1a d8       	st.w	--sp,r8
80002392:	30 18       	mov	r8,1
80002394:	30 09       	mov	r9,0
80002396:	e0 6a 01 00 	mov	r10,256
8000239a:	49 5c       	lddpc	r12,800023ec <main+0xa0>
8000239c:	f0 1f 00 15 	mcall	800023f0 <main+0xa4>
800023a0:	2f dd       	sub	sp,-12
					"vProducer",
					configMINIMAL_STACK_SIZE,
					NULL,
					1,
					&xHandleProducer);
	xTaskCreate(	vConsumer, "vConsumer", configMINIMAL_STACK_SIZE, NULL, 1, &xHandleConsumer);
800023a2:	49 5b       	lddpc	r11,800023f4 <main+0xa8>
800023a4:	30 08       	mov	r8,0
800023a6:	1a d8       	st.w	--sp,r8
800023a8:	30 08       	mov	r8,0
800023aa:	1a d8       	st.w	--sp,r8
800023ac:	49 38       	lddpc	r8,800023f8 <main+0xac>
800023ae:	1a d8       	st.w	--sp,r8
800023b0:	30 18       	mov	r8,1
800023b2:	30 09       	mov	r9,0
800023b4:	e0 6a 01 00 	mov	r10,256
800023b8:	49 1c       	lddpc	r12,800023fc <main+0xb0>
800023ba:	f0 1f 00 0e 	mcall	800023f0 <main+0xa4>
800023be:	2f dd       	sub	sp,-12
	
	vTaskStartScheduler();
800023c0:	f0 1f 00 10 	mcall	80002400 <main+0xb4>
	
	for( ;; )
	{
		
	}
800023c4:	c0 08       	rjmp	800023c4 <main+0x78>
800023c6:	00 00       	add	r0,r0
800023c8:	80 00       	ld.sh	r0,r0[0x0]
800023ca:	20 d8       	sub	r8,13
800023cc:	80 00       	ld.sh	r0,r0[0x0]
800023ce:	21 a8       	sub	r8,26
800023d0:	80 00       	ld.sh	r0,r0[0x0]
800023d2:	34 c4       	mov	r4,76
800023d4:	00 00       	add	r0,r0
800023d6:	07 90       	ld.ub	r0,r3[0x1]
800023d8:	00 00       	add	r0,r0
800023da:	07 a0       	ld.ub	r0,r3[0x2]
800023dc:	80 00       	ld.sh	r0,r0[0x0]
800023de:	33 ac       	mov	r12,58
800023e0:	00 00       	add	r0,r0
800023e2:	07 94       	ld.ub	r4,r3[0x1]
800023e4:	80 00       	ld.sh	r0,r0[0x0]
800023e6:	21 90       	sub	r0,25
800023e8:	00 00       	add	r0,r0
800023ea:	07 9c       	ld.ub	r12,r3[0x1]
800023ec:	80 00       	ld.sh	r0,r0[0x0]
800023ee:	22 10       	sub	r0,33
800023f0:	80 00       	ld.sh	r0,r0[0x0]
800023f2:	3a b4       	mov	r4,-85
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	21 9c       	sub	r12,25
800023f8:	00 00       	add	r0,r0
800023fa:	07 98       	ld.ub	r8,r3[0x1]
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	22 c4       	sub	r4,44
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	3c 7c       	mov	r12,-57

80002404 <gpio_enable_module>:
80002404:	eb cd 40 80 	pushm	r7,lr
80002408:	1a 97       	mov	r7,sp
8000240a:	20 4d       	sub	sp,16
8000240c:	ef 4c ff f4 	st.w	r7[-12],r12
80002410:	ef 4b ff f0 	st.w	r7[-16],r11
80002414:	30 08       	mov	r8,0
80002416:	ef 48 ff f8 	st.w	r7[-8],r8
8000241a:	30 08       	mov	r8,0
8000241c:	ef 48 ff fc 	st.w	r7[-4],r8
80002420:	c1 c8       	rjmp	80002458 <gpio_enable_module+0x54>
80002422:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002426:	70 19       	ld.w	r9,r8[0x4]
80002428:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000242c:	70 08       	ld.w	r8,r8[0x0]
8000242e:	12 9b       	mov	r11,r9
80002430:	10 9c       	mov	r12,r8
80002432:	f0 1f 00 10 	mcall	80002470 <gpio_enable_module+0x6c>
80002436:	18 98       	mov	r8,r12
80002438:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000243c:	f3 e8 10 08 	or	r8,r9,r8
80002440:	ef 48 ff f8 	st.w	r7[-8],r8
80002444:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002448:	2f 88       	sub	r8,-8
8000244a:	ef 48 ff f4 	st.w	r7[-12],r8
8000244e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002452:	2f f8       	sub	r8,-1
80002454:	ef 48 ff fc 	st.w	r7[-4],r8
80002458:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000245c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002460:	10 39       	cp.w	r9,r8
80002462:	ce 03       	brcs	80002422 <gpio_enable_module+0x1e>
80002464:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002468:	10 9c       	mov	r12,r8
8000246a:	2f cd       	sub	sp,-16
8000246c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	24 74       	sub	r4,71

80002474 <gpio_enable_module_pin>:
80002474:	eb cd 40 80 	pushm	r7,lr
80002478:	1a 97       	mov	r7,sp
8000247a:	20 3d       	sub	sp,12
8000247c:	ef 4c ff f8 	st.w	r7[-8],r12
80002480:	ef 4b ff f4 	st.w	r7[-12],r11
80002484:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002488:	a5 98       	lsr	r8,0x5
8000248a:	a9 68       	lsl	r8,0x8
8000248c:	e0 28 f0 00 	sub	r8,61440
80002490:	ef 48 ff fc 	st.w	r7[-4],r8
80002494:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002498:	58 18       	cp.w	r8,1
8000249a:	c1 e0       	breq	800024d6 <gpio_enable_module_pin+0x62>
8000249c:	c0 63       	brcs	800024a8 <gpio_enable_module_pin+0x34>
8000249e:	58 28       	cp.w	r8,2
800024a0:	c3 20       	breq	80002504 <gpio_enable_module_pin+0x90>
800024a2:	58 38       	cp.w	r8,3
800024a4:	c4 70       	breq	80002532 <gpio_enable_module_pin+0xbe>
800024a6:	c5 d8       	rjmp	80002560 <gpio_enable_module_pin+0xec>
800024a8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800024ac:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800024b0:	30 19       	mov	r9,1
800024b2:	f2 08 09 48 	lsl	r8,r9,r8
800024b6:	10 99       	mov	r9,r8
800024b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800024bc:	91 69       	st.w	r8[0x18],r9
800024be:	ee f8 ff f8 	ld.w	r8,r7[-8]
800024c2:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800024c6:	30 19       	mov	r9,1
800024c8:	f2 08 09 48 	lsl	r8,r9,r8
800024cc:	10 99       	mov	r9,r8
800024ce:	ee f8 ff fc 	ld.w	r8,r7[-4]
800024d2:	91 a9       	st.w	r8[0x28],r9
800024d4:	c4 88       	rjmp	80002564 <gpio_enable_module_pin+0xf0>
800024d6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800024da:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800024de:	30 19       	mov	r9,1
800024e0:	f2 08 09 48 	lsl	r8,r9,r8
800024e4:	10 99       	mov	r9,r8
800024e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800024ea:	91 59       	st.w	r8[0x14],r9
800024ec:	ee f8 ff f8 	ld.w	r8,r7[-8]
800024f0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800024f4:	30 19       	mov	r9,1
800024f6:	f2 08 09 48 	lsl	r8,r9,r8
800024fa:	10 99       	mov	r9,r8
800024fc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002500:	91 a9       	st.w	r8[0x28],r9
80002502:	c3 18       	rjmp	80002564 <gpio_enable_module_pin+0xf0>
80002504:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002508:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000250c:	30 19       	mov	r9,1
8000250e:	f2 08 09 48 	lsl	r8,r9,r8
80002512:	10 99       	mov	r9,r8
80002514:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002518:	91 69       	st.w	r8[0x18],r9
8000251a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000251e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002522:	30 19       	mov	r9,1
80002524:	f2 08 09 48 	lsl	r8,r9,r8
80002528:	10 99       	mov	r9,r8
8000252a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000252e:	91 99       	st.w	r8[0x24],r9
80002530:	c1 a8       	rjmp	80002564 <gpio_enable_module_pin+0xf0>
80002532:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002536:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000253a:	30 19       	mov	r9,1
8000253c:	f2 08 09 48 	lsl	r8,r9,r8
80002540:	10 99       	mov	r9,r8
80002542:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002546:	91 59       	st.w	r8[0x14],r9
80002548:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000254c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002550:	30 19       	mov	r9,1
80002552:	f2 08 09 48 	lsl	r8,r9,r8
80002556:	10 99       	mov	r9,r8
80002558:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000255c:	91 99       	st.w	r8[0x24],r9
8000255e:	c0 38       	rjmp	80002564 <gpio_enable_module_pin+0xf0>
80002560:	30 18       	mov	r8,1
80002562:	c0 d8       	rjmp	8000257c <gpio_enable_module_pin+0x108>
80002564:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002568:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000256c:	30 19       	mov	r9,1
8000256e:	f2 08 09 48 	lsl	r8,r9,r8
80002572:	10 99       	mov	r9,r8
80002574:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002578:	91 29       	st.w	r8[0x8],r9
8000257a:	30 08       	mov	r8,0
8000257c:	10 9c       	mov	r12,r8
8000257e:	2f dd       	sub	sp,-12
80002580:	e3 cd 80 80 	ldm	sp++,r7,pc

80002584 <_unhandled_interrupt>:
80002584:	eb cd 40 80 	pushm	r7,lr
80002588:	1a 97       	mov	r7,sp
8000258a:	c0 08       	rjmp	8000258a <_unhandled_interrupt+0x6>

8000258c <_get_interrupt_handler>:
8000258c:	eb cd 40 80 	pushm	r7,lr
80002590:	1a 97       	mov	r7,sp
80002592:	20 3d       	sub	sp,12
80002594:	ef 4c ff f4 	st.w	r7[-12],r12
80002598:	fe 78 08 00 	mov	r8,-63488
8000259c:	ee f9 ff f4 	ld.w	r9,r7[-12]
800025a0:	f2 09 11 03 	rsub	r9,r9,3
800025a4:	28 09       	sub	r9,-128
800025a6:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800025aa:	ef 48 ff f8 	st.w	r7[-8],r8
800025ae:	fe 78 08 00 	mov	r8,-63488
800025b2:	ee f9 ff f8 	ld.w	r9,r7[-8]
800025b6:	2c 09       	sub	r9,-64
800025b8:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800025bc:	ef 48 ff fc 	st.w	r7[-4],r8
800025c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800025c4:	58 08       	cp.w	r8,0
800025c6:	c1 30       	breq	800025ec <_get_interrupt_handler+0x60>
800025c8:	ee f9 ff f8 	ld.w	r9,r7[-8]
800025cc:	48 b8       	lddpc	r8,800025f8 <_get_interrupt_handler+0x6c>
800025ce:	a1 79       	lsl	r9,0x1
800025d0:	2f f9       	sub	r9,-1
800025d2:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
800025d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800025da:	f0 08 12 00 	clz	r8,r8
800025de:	f0 08 11 1f 	rsub	r8,r8,31
800025e2:	a3 68       	lsl	r8,0x2
800025e4:	f2 08 00 08 	add	r8,r9,r8
800025e8:	70 08       	ld.w	r8,r8[0x0]
800025ea:	c0 28       	rjmp	800025ee <_get_interrupt_handler+0x62>
800025ec:	30 08       	mov	r8,0
800025ee:	10 9c       	mov	r12,r8
800025f0:	2f dd       	sub	sp,-12
800025f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800025f6:	00 00       	add	r0,r0
800025f8:	80 00       	ld.sh	r0,r0[0x0]
800025fa:	52 44       	stdsp	sp[0x90],r4

800025fc <INTC_init_evba>:
800025fc:	eb cd 40 80 	pushm	r7,lr
80002600:	1a 97       	mov	r7,sp
80002602:	48 38       	lddpc	r8,8000260c <INTC_init_evba+0x10>
80002604:	e3 b8 00 01 	mtsr	0x4,r8
80002608:	e3 cd 80 80 	ldm	sp++,r7,pc
8000260c:	80 00       	ld.sh	r0,r0[0x0]
8000260e:	50 00       	stdsp	sp[0x0],r0

80002610 <INTC_init_interrupts>:
80002610:	eb cd 40 80 	pushm	r7,lr
80002614:	1a 97       	mov	r7,sp
80002616:	20 2d       	sub	sp,8
80002618:	f0 1f 00 1f 	mcall	80002694 <INTC_init_interrupts+0x84>
8000261c:	30 08       	mov	r8,0
8000261e:	ef 48 ff f8 	st.w	r7[-8],r8
80002622:	c3 18       	rjmp	80002684 <INTC_init_interrupts+0x74>
80002624:	30 08       	mov	r8,0
80002626:	ef 48 ff fc 	st.w	r7[-4],r8
8000262a:	c1 48       	rjmp	80002652 <INTC_init_interrupts+0x42>
8000262c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002630:	49 a8       	lddpc	r8,80002698 <INTC_init_interrupts+0x88>
80002632:	a1 79       	lsl	r9,0x1
80002634:	2f f9       	sub	r9,-1
80002636:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
8000263a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000263e:	a3 68       	lsl	r8,0x2
80002640:	f2 08 00 08 	add	r8,r9,r8
80002644:	49 69       	lddpc	r9,8000269c <INTC_init_interrupts+0x8c>
80002646:	91 09       	st.w	r8[0x0],r9
80002648:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000264c:	2f f8       	sub	r8,-1
8000264e:	ef 48 ff fc 	st.w	r7[-4],r8
80002652:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002656:	49 18       	lddpc	r8,80002698 <INTC_init_interrupts+0x88>
80002658:	f0 09 03 39 	ld.w	r9,r8[r9<<0x3]
8000265c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002660:	10 39       	cp.w	r9,r8
80002662:	fe 9b ff e5 	brhi	8000262c <INTC_init_interrupts+0x1c>
80002666:	fe 78 08 00 	mov	r8,-63488
8000266a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000266e:	48 db       	lddpc	r11,800026a0 <INTC_init_interrupts+0x90>
80002670:	48 da       	lddpc	r10,800026a4 <INTC_init_interrupts+0x94>
80002672:	f6 0a 01 0a 	sub	r10,r11,r10
80002676:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
8000267a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000267e:	2f f8       	sub	r8,-1
80002680:	ef 48 ff f8 	st.w	r7[-8],r8
80002684:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002688:	59 38       	cp.w	r8,19
8000268a:	fe 98 ff cd 	brls	80002624 <INTC_init_interrupts+0x14>
8000268e:	2f ed       	sub	sp,-8
80002690:	e3 cd 80 80 	ldm	sp++,r7,pc
80002694:	80 00       	ld.sh	r0,r0[0x0]
80002696:	25 fc       	sub	r12,95
80002698:	80 00       	ld.sh	r0,r0[0x0]
8000269a:	52 44       	stdsp	sp[0x90],r4
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	25 84       	sub	r4,88
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	51 04       	stdsp	sp[0x40],r4
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	50 00       	stdsp	sp[0x0],r0

800026a8 <INTC_register_interrupt>:
800026a8:	eb cd 40 80 	pushm	r7,lr
800026ac:	1a 97       	mov	r7,sp
800026ae:	20 4d       	sub	sp,16
800026b0:	ef 4c ff f8 	st.w	r7[-8],r12
800026b4:	ef 4b ff f4 	st.w	r7[-12],r11
800026b8:	ef 4a ff f0 	st.w	r7[-16],r10
800026bc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800026c0:	a5 98       	lsr	r8,0x5
800026c2:	ef 48 ff fc 	st.w	r7[-4],r8
800026c6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800026ca:	4a 78       	lddpc	r8,80002764 <INTC_register_interrupt+0xbc>
800026cc:	a1 79       	lsl	r9,0x1
800026ce:	2f f9       	sub	r9,-1
800026d0:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
800026d4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800026d8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800026dc:	a3 68       	lsl	r8,0x2
800026de:	f2 08 00 08 	add	r8,r9,r8
800026e2:	ee f9 ff f8 	ld.w	r9,r7[-8]
800026e6:	91 09       	st.w	r8[0x0],r9
800026e8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800026ec:	58 08       	cp.w	r8,0
800026ee:	c0 c1       	brne	80002706 <INTC_register_interrupt+0x5e>
800026f0:	fe 78 08 00 	mov	r8,-63488
800026f4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800026f8:	49 cb       	lddpc	r11,80002768 <INTC_register_interrupt+0xc0>
800026fa:	49 da       	lddpc	r10,8000276c <INTC_register_interrupt+0xc4>
800026fc:	f6 0a 01 0a 	sub	r10,r11,r10
80002700:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80002704:	c2 d8       	rjmp	8000275e <INTC_register_interrupt+0xb6>
80002706:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000270a:	58 18       	cp.w	r8,1
8000270c:	c0 d1       	brne	80002726 <INTC_register_interrupt+0x7e>
8000270e:	fe 78 08 00 	mov	r8,-63488
80002712:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002716:	49 7b       	lddpc	r11,80002770 <INTC_register_interrupt+0xc8>
80002718:	49 5a       	lddpc	r10,8000276c <INTC_register_interrupt+0xc4>
8000271a:	f6 0a 01 0a 	sub	r10,r11,r10
8000271e:	bf aa       	sbr	r10,0x1e
80002720:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80002724:	c1 d8       	rjmp	8000275e <INTC_register_interrupt+0xb6>
80002726:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000272a:	58 28       	cp.w	r8,2
8000272c:	c0 d1       	brne	80002746 <INTC_register_interrupt+0x9e>
8000272e:	fe 78 08 00 	mov	r8,-63488
80002732:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002736:	49 0b       	lddpc	r11,80002774 <INTC_register_interrupt+0xcc>
80002738:	48 da       	lddpc	r10,8000276c <INTC_register_interrupt+0xc4>
8000273a:	f6 0a 01 0a 	sub	r10,r11,r10
8000273e:	bf ba       	sbr	r10,0x1f
80002740:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80002744:	c0 d8       	rjmp	8000275e <INTC_register_interrupt+0xb6>
80002746:	fe 78 08 00 	mov	r8,-63488
8000274a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000274e:	48 bb       	lddpc	r11,80002778 <INTC_register_interrupt+0xd0>
80002750:	48 7a       	lddpc	r10,8000276c <INTC_register_interrupt+0xc4>
80002752:	f6 0a 01 0a 	sub	r10,r11,r10
80002756:	ea 1a c0 00 	orh	r10,0xc000
8000275a:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
8000275e:	2f cd       	sub	sp,-16
80002760:	e3 cd 80 80 	ldm	sp++,r7,pc
80002764:	80 00       	ld.sh	r0,r0[0x0]
80002766:	52 44       	stdsp	sp[0x90],r4
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	51 04       	stdsp	sp[0x40],r4
8000276c:	80 00       	ld.sh	r0,r0[0x0]
8000276e:	50 00       	stdsp	sp[0x0],r0
80002770:	80 00       	ld.sh	r0,r0[0x0]
80002772:	51 12       	stdsp	sp[0x44],r2
80002774:	80 00       	ld.sh	r0,r0[0x0]
80002776:	51 20       	stdsp	sp[0x48],r0
80002778:	80 00       	ld.sh	r0,r0[0x0]
8000277a:	51 2e       	stdsp	sp[0x48],lr

8000277c <pm_set_osc0_mode>:
8000277c:	eb cd 40 80 	pushm	r7,lr
80002780:	1a 97       	mov	r7,sp
80002782:	20 3d       	sub	sp,12
80002784:	ef 4c ff f8 	st.w	r7[-8],r12
80002788:	ef 4b ff f4 	st.w	r7[-12],r11
8000278c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002790:	70 a8       	ld.w	r8,r8[0x28]
80002792:	30 09       	mov	r9,0
80002794:	ef 49 ff fc 	st.w	r7[-4],r9
80002798:	ef 48 ff fc 	st.w	r7[-4],r8
8000279c:	ee f8 ff f4 	ld.w	r8,r7[-12]
800027a0:	5c 58       	castu.b	r8
800027a2:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800027a6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800027aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800027ae:	f1 d9 d0 03 	bfins	r8,r9,0x0,0x3
800027b2:	ef 48 ff fc 	st.w	r7[-4],r8
800027b6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800027ba:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027be:	91 a9       	st.w	r8[0x28],r9
800027c0:	2f dd       	sub	sp,-12
800027c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800027c6:	d7 03       	nop

800027c8 <pm_enable_osc0_crystal>:
800027c8:	eb cd 40 80 	pushm	r7,lr
800027cc:	1a 97       	mov	r7,sp
800027ce:	20 2d       	sub	sp,8
800027d0:	ef 4c ff fc 	st.w	r7[-4],r12
800027d4:	ef 4b ff f8 	st.w	r7[-8],r11
800027d8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027dc:	ec 58 bb 9f 	cp.w	r8,899999
800027e0:	e0 88 00 1a 	brls	80002814 <pm_enable_osc0_crystal+0x4c>
800027e4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027e8:	e0 69 c6 bf 	mov	r9,50879
800027ec:	ea 19 00 2d 	orh	r9,0x2d
800027f0:	12 38       	cp.w	r8,r9
800027f2:	e0 88 00 0f 	brls	80002810 <pm_enable_osc0_crystal+0x48>
800027f6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027fa:	e0 69 11 ff 	mov	r9,4607
800027fe:	ea 19 00 7a 	orh	r9,0x7a
80002802:	12 38       	cp.w	r8,r9
80002804:	e0 8b 00 04 	brhi	8000280c <pm_enable_osc0_crystal+0x44>
80002808:	30 68       	mov	r8,6
8000280a:	c0 28       	rjmp	8000280e <pm_enable_osc0_crystal+0x46>
8000280c:	30 78       	mov	r8,7
8000280e:	c0 28       	rjmp	80002812 <pm_enable_osc0_crystal+0x4a>
80002810:	30 58       	mov	r8,5
80002812:	c0 28       	rjmp	80002816 <pm_enable_osc0_crystal+0x4e>
80002814:	30 48       	mov	r8,4
80002816:	10 9b       	mov	r11,r8
80002818:	ee fc ff fc 	ld.w	r12,r7[-4]
8000281c:	f0 1f 00 03 	mcall	80002828 <pm_enable_osc0_crystal+0x60>
80002820:	2f ed       	sub	sp,-8
80002822:	e3 cd 80 80 	ldm	sp++,r7,pc
80002826:	00 00       	add	r0,r0
80002828:	80 00       	ld.sh	r0,r0[0x0]
8000282a:	27 7c       	sub	r12,119

8000282c <pm_enable_clk0>:
8000282c:	eb cd 40 80 	pushm	r7,lr
80002830:	1a 97       	mov	r7,sp
80002832:	20 2d       	sub	sp,8
80002834:	ef 4c ff fc 	st.w	r7[-4],r12
80002838:	ef 4b ff f8 	st.w	r7[-8],r11
8000283c:	ee fb ff f8 	ld.w	r11,r7[-8]
80002840:	ee fc ff fc 	ld.w	r12,r7[-4]
80002844:	f0 1f 00 05 	mcall	80002858 <pm_enable_clk0+0x2c>
80002848:	ee fc ff fc 	ld.w	r12,r7[-4]
8000284c:	f0 1f 00 04 	mcall	8000285c <pm_enable_clk0+0x30>
80002850:	2f ed       	sub	sp,-8
80002852:	e3 cd 80 80 	ldm	sp++,r7,pc
80002856:	00 00       	add	r0,r0
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	28 60       	sub	r0,-122
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	28 ba       	sub	r10,-117

80002860 <pm_enable_clk0_no_wait>:
80002860:	eb cd 40 80 	pushm	r7,lr
80002864:	1a 97       	mov	r7,sp
80002866:	20 3d       	sub	sp,12
80002868:	ef 4c ff f8 	st.w	r7[-8],r12
8000286c:	ef 4b ff f4 	st.w	r7[-12],r11
80002870:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002874:	70 a8       	ld.w	r8,r8[0x28]
80002876:	30 09       	mov	r9,0
80002878:	ef 49 ff fc 	st.w	r7[-4],r9
8000287c:	ef 48 ff fc 	st.w	r7[-4],r8
80002880:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002884:	5c 58       	castu.b	r8
80002886:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000288a:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000288e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002892:	f1 d9 d1 03 	bfins	r8,r9,0x8,0x3
80002896:	ef 48 ff fc 	st.w	r7[-4],r8
8000289a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000289e:	ee f8 ff f8 	ld.w	r8,r7[-8]
800028a2:	91 a9       	st.w	r8[0x28],r9
800028a4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800028a8:	70 08       	ld.w	r8,r8[0x0]
800028aa:	10 99       	mov	r9,r8
800028ac:	a3 a9       	sbr	r9,0x2
800028ae:	ee f8 ff f8 	ld.w	r8,r7[-8]
800028b2:	91 09       	st.w	r8[0x0],r9
800028b4:	2f dd       	sub	sp,-12
800028b6:	e3 cd 80 80 	ldm	sp++,r7,pc

800028ba <pm_wait_for_clk0_ready>:
800028ba:	eb cd 40 80 	pushm	r7,lr
800028be:	1a 97       	mov	r7,sp
800028c0:	20 1d       	sub	sp,4
800028c2:	ef 4c ff fc 	st.w	r7[-4],r12
800028c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800028ca:	71 58       	ld.w	r8,r8[0x54]
800028cc:	e2 18 00 80 	andl	r8,0x80,COH
800028d0:	cf b0       	breq	800028c6 <pm_wait_for_clk0_ready+0xc>
800028d2:	2f fd       	sub	sp,-4
800028d4:	e3 cd 80 80 	ldm	sp++,r7,pc

800028d8 <pm_switch_to_clock>:
800028d8:	eb cd 40 80 	pushm	r7,lr
800028dc:	1a 97       	mov	r7,sp
800028de:	20 3d       	sub	sp,12
800028e0:	ef 4c ff f8 	st.w	r7[-8],r12
800028e4:	ef 4b ff f4 	st.w	r7[-12],r11
800028e8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800028ec:	70 08       	ld.w	r8,r8[0x0]
800028ee:	30 09       	mov	r9,0
800028f0:	ef 49 ff fc 	st.w	r7[-4],r9
800028f4:	ef 48 ff fc 	st.w	r7[-4],r8
800028f8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800028fc:	5c 58       	castu.b	r8
800028fe:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002902:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80002906:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000290a:	f1 d9 d0 02 	bfins	r8,r9,0x0,0x2
8000290e:	ef 48 ff fc 	st.w	r7[-4],r8
80002912:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002916:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000291a:	91 09       	st.w	r8[0x0],r9
8000291c:	2f dd       	sub	sp,-12
8000291e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002922:	d7 03       	nop

80002924 <pm_switch_to_osc0>:
80002924:	eb cd 40 80 	pushm	r7,lr
80002928:	1a 97       	mov	r7,sp
8000292a:	20 3d       	sub	sp,12
8000292c:	ef 4c ff fc 	st.w	r7[-4],r12
80002930:	ef 4b ff f8 	st.w	r7[-8],r11
80002934:	ef 4a ff f4 	st.w	r7[-12],r10
80002938:	ee fb ff f8 	ld.w	r11,r7[-8]
8000293c:	ee fc ff fc 	ld.w	r12,r7[-4]
80002940:	f0 1f 00 08 	mcall	80002960 <pm_switch_to_osc0+0x3c>
80002944:	ee fb ff f4 	ld.w	r11,r7[-12]
80002948:	ee fc ff fc 	ld.w	r12,r7[-4]
8000294c:	f0 1f 00 06 	mcall	80002964 <pm_switch_to_osc0+0x40>
80002950:	30 1b       	mov	r11,1
80002952:	ee fc ff fc 	ld.w	r12,r7[-4]
80002956:	f0 1f 00 05 	mcall	80002968 <pm_switch_to_osc0+0x44>
8000295a:	2f dd       	sub	sp,-12
8000295c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002960:	80 00       	ld.sh	r0,r0[0x0]
80002962:	27 c8       	sub	r8,124
80002964:	80 00       	ld.sh	r0,r0[0x0]
80002966:	28 2c       	sub	r12,-126
80002968:	80 00       	ld.sh	r0,r0[0x0]
8000296a:	28 d8       	sub	r8,-115

8000296c <cpu_irq_is_enabled_flags>:
8000296c:	eb cd 40 80 	pushm	r7,lr
80002970:	1a 97       	mov	r7,sp
80002972:	20 1d       	sub	sp,4
80002974:	ef 4c ff fc 	st.w	r7[-4],r12
80002978:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000297c:	e6 18 00 01 	andh	r8,0x1,COH
80002980:	5f 08       	sreq	r8
80002982:	5c 58       	castu.b	r8
80002984:	10 9c       	mov	r12,r8
80002986:	2f fd       	sub	sp,-4
80002988:	e3 cd 80 80 	ldm	sp++,r7,pc

8000298c <usart_set_async_baudrate>:
8000298c:	eb cd 40 80 	pushm	r7,lr
80002990:	1a 97       	mov	r7,sp
80002992:	20 7d       	sub	sp,28
80002994:	ef 4c ff ec 	st.w	r7[-20],r12
80002998:	ef 4b ff e8 	st.w	r7[-24],r11
8000299c:	ef 4a ff e4 	st.w	r7[-28],r10
800029a0:	ee f8 ff e8 	ld.w	r8,r7[-24]
800029a4:	f0 09 15 04 	lsl	r9,r8,0x4
800029a8:	ee f8 ff e4 	ld.w	r8,r7[-28]
800029ac:	10 39       	cp.w	r9,r8
800029ae:	e0 8b 00 04 	brhi	800029b6 <usart_set_async_baudrate+0x2a>
800029b2:	31 08       	mov	r8,16
800029b4:	c0 28       	rjmp	800029b8 <usart_set_async_baudrate+0x2c>
800029b6:	30 88       	mov	r8,8
800029b8:	ef 48 ff f0 	st.w	r7[-16],r8
800029bc:	ee f8 ff e4 	ld.w	r8,r7[-28]
800029c0:	f0 09 15 03 	lsl	r9,r8,0x3
800029c4:	ee fa ff f0 	ld.w	r10,r7[-16]
800029c8:	ee f8 ff e8 	ld.w	r8,r7[-24]
800029cc:	f4 08 02 48 	mul	r8,r10,r8
800029d0:	a1 98       	lsr	r8,0x1
800029d2:	f2 08 00 08 	add	r8,r9,r8
800029d6:	ee fa ff f0 	ld.w	r10,r7[-16]
800029da:	ee f9 ff e8 	ld.w	r9,r7[-24]
800029de:	f4 09 02 49 	mul	r9,r10,r9
800029e2:	f0 09 0d 08 	divu	r8,r8,r9
800029e6:	ef 48 ff f4 	st.w	r7[-12],r8
800029ea:	ee f8 ff f4 	ld.w	r8,r7[-12]
800029ee:	a3 98       	lsr	r8,0x3
800029f0:	ef 48 ff f8 	st.w	r7[-8],r8
800029f4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800029f8:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800029fc:	ef 48 ff fc 	st.w	r7[-4],r8
80002a00:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a04:	58 08       	cp.w	r8,0
80002a06:	c0 70       	breq	80002a14 <usart_set_async_baudrate+0x88>
80002a08:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a0c:	e0 48 ff ff 	cp.w	r8,65535
80002a10:	e0 88 00 04 	brls	80002a18 <usart_set_async_baudrate+0x8c>
80002a14:	30 18       	mov	r8,1
80002a16:	c2 08       	rjmp	80002a56 <usart_set_async_baudrate+0xca>
80002a18:	ee f8 ff ec 	ld.w	r8,r7[-20]
80002a1c:	70 18       	ld.w	r8,r8[0x4]
80002a1e:	10 99       	mov	r9,r8
80002a20:	e4 19 ff f7 	andh	r9,0xfff7
80002a24:	e0 19 fe cf 	andl	r9,0xfecf
80002a28:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002a2c:	59 08       	cp.w	r8,16
80002a2e:	c0 40       	breq	80002a36 <usart_set_async_baudrate+0xaa>
80002a30:	e8 68 00 00 	mov	r8,524288
80002a34:	c0 28       	rjmp	80002a38 <usart_set_async_baudrate+0xac>
80002a36:	30 08       	mov	r8,0
80002a38:	10 49       	or	r9,r8
80002a3a:	ee f8 ff ec 	ld.w	r8,r7[-20]
80002a3e:	91 19       	st.w	r8[0x4],r9
80002a40:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a44:	f0 09 15 10 	lsl	r9,r8,0x10
80002a48:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a4c:	10 49       	or	r9,r8
80002a4e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80002a52:	91 89       	st.w	r8[0x20],r9
80002a54:	30 08       	mov	r8,0
80002a56:	10 9c       	mov	r12,r8
80002a58:	2f 9d       	sub	sp,-28
80002a5a:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a5e:	d7 03       	nop

80002a60 <usart_reset>:
80002a60:	eb cd 40 80 	pushm	r7,lr
80002a64:	1a 97       	mov	r7,sp
80002a66:	20 2d       	sub	sp,8
80002a68:	ef 4c ff f8 	st.w	r7[-8],r12
80002a6c:	e1 b8 00 00 	mfsr	r8,0x0
80002a70:	10 9c       	mov	r12,r8
80002a72:	f0 1f 00 18 	mcall	80002ad0 <usart_reset+0x70>
80002a76:	18 98       	mov	r8,r12
80002a78:	ef 68 ff ff 	st.b	r7[-1],r8
80002a7c:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80002a80:	30 08       	mov	r8,0
80002a82:	f0 09 18 00 	cp.b	r9,r8
80002a86:	c0 20       	breq	80002a8a <usart_reset+0x2a>
80002a88:	d3 03       	ssrf	0x10
80002a8a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a8e:	3f f9       	mov	r9,-1
80002a90:	91 39       	st.w	r8[0xc],r9
80002a92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a96:	70 58       	ld.w	r8,r8[0x14]
80002a98:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80002a9c:	30 08       	mov	r8,0
80002a9e:	f0 09 18 00 	cp.b	r9,r8
80002aa2:	c0 20       	breq	80002aa6 <usart_reset+0x46>
80002aa4:	d5 03       	csrf	0x10
80002aa6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002aaa:	30 09       	mov	r9,0
80002aac:	91 19       	st.w	r8[0x4],r9
80002aae:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ab2:	30 09       	mov	r9,0
80002ab4:	91 99       	st.w	r8[0x24],r9
80002ab6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002aba:	30 09       	mov	r9,0
80002abc:	91 a9       	st.w	r8[0x28],r9
80002abe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ac2:	ea 69 61 0c 	mov	r9,680204
80002ac6:	91 09       	st.w	r8[0x0],r9
80002ac8:	2f ed       	sub	sp,-8
80002aca:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ace:	00 00       	add	r0,r0
80002ad0:	80 00       	ld.sh	r0,r0[0x0]
80002ad2:	29 6c       	sub	r12,-106

80002ad4 <usart_init_rs232>:
80002ad4:	eb cd 40 80 	pushm	r7,lr
80002ad8:	1a 97       	mov	r7,sp
80002ada:	20 3d       	sub	sp,12
80002adc:	ef 4c ff fc 	st.w	r7[-4],r12
80002ae0:	ef 4b ff f8 	st.w	r7[-8],r11
80002ae4:	ef 4a ff f4 	st.w	r7[-12],r10
80002ae8:	ee fc ff fc 	ld.w	r12,r7[-4]
80002aec:	f0 1f 00 54 	mcall	80002c3c <usart_init_rs232+0x168>
80002af0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002af4:	58 08       	cp.w	r8,0
80002af6:	c3 90       	breq	80002b68 <usart_init_rs232+0x94>
80002af8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002afc:	11 c9       	ld.ub	r9,r8[0x4]
80002afe:	30 48       	mov	r8,4
80002b00:	f0 09 18 00 	cp.b	r9,r8
80002b04:	e0 88 00 32 	brls	80002b68 <usart_init_rs232+0x94>
80002b08:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b0c:	11 c9       	ld.ub	r9,r8[0x4]
80002b0e:	30 98       	mov	r8,9
80002b10:	f0 09 18 00 	cp.b	r9,r8
80002b14:	e0 8b 00 2a 	brhi	80002b68 <usart_init_rs232+0x94>
80002b18:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b1c:	11 d9       	ld.ub	r9,r8[0x5]
80002b1e:	30 78       	mov	r8,7
80002b20:	f0 09 18 00 	cp.b	r9,r8
80002b24:	e0 8b 00 22 	brhi	80002b68 <usart_init_rs232+0x94>
80002b28:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b2c:	90 39       	ld.sh	r9,r8[0x6]
80002b2e:	e0 68 01 01 	mov	r8,257
80002b32:	f0 09 19 00 	cp.h	r9,r8
80002b36:	e0 8b 00 19 	brhi	80002b68 <usart_init_rs232+0x94>
80002b3a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b3e:	f1 39 00 08 	ld.ub	r9,r8[8]
80002b42:	30 38       	mov	r8,3
80002b44:	f0 09 18 00 	cp.b	r9,r8
80002b48:	e0 8b 00 10 	brhi	80002b68 <usart_init_rs232+0x94>
80002b4c:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002b50:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b54:	70 08       	ld.w	r8,r8[0x0]
80002b56:	12 9a       	mov	r10,r9
80002b58:	10 9b       	mov	r11,r8
80002b5a:	ee fc ff fc 	ld.w	r12,r7[-4]
80002b5e:	f0 1f 00 39 	mcall	80002c40 <usart_init_rs232+0x16c>
80002b62:	18 98       	mov	r8,r12
80002b64:	58 18       	cp.w	r8,1
80002b66:	c0 31       	brne	80002b6c <usart_init_rs232+0x98>
80002b68:	30 18       	mov	r8,1
80002b6a:	c6 48       	rjmp	80002c32 <usart_init_rs232+0x15e>
80002b6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b70:	11 c9       	ld.ub	r9,r8[0x4]
80002b72:	30 98       	mov	r8,9
80002b74:	f0 09 18 00 	cp.b	r9,r8
80002b78:	c0 a1       	brne	80002b8c <usart_init_rs232+0xb8>
80002b7a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b7e:	70 18       	ld.w	r8,r8[0x4]
80002b80:	10 99       	mov	r9,r8
80002b82:	b1 b9       	sbr	r9,0x11
80002b84:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b88:	91 19       	st.w	r8[0x4],r9
80002b8a:	c0 d8       	rjmp	80002ba4 <usart_init_rs232+0xd0>
80002b8c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b90:	70 19       	ld.w	r9,r8[0x4]
80002b92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b96:	11 c8       	ld.ub	r8,r8[0x4]
80002b98:	20 58       	sub	r8,5
80002b9a:	a7 68       	lsl	r8,0x6
80002b9c:	10 49       	or	r9,r8
80002b9e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ba2:	91 19       	st.w	r8[0x4],r9
80002ba4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ba8:	70 19       	ld.w	r9,r8[0x4]
80002baa:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bae:	11 d8       	ld.ub	r8,r8[0x5]
80002bb0:	f0 0a 15 09 	lsl	r10,r8,0x9
80002bb4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bb8:	f1 38 00 08 	ld.ub	r8,r8[8]
80002bbc:	af 68       	lsl	r8,0xe
80002bbe:	f5 e8 10 08 	or	r8,r10,r8
80002bc2:	10 49       	or	r9,r8
80002bc4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002bc8:	91 19       	st.w	r8[0x4],r9
80002bca:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bce:	90 39       	ld.sh	r9,r8[0x6]
80002bd0:	30 28       	mov	r8,2
80002bd2:	f0 09 19 00 	cp.h	r9,r8
80002bd6:	e0 88 00 14 	brls	80002bfe <usart_init_rs232+0x12a>
80002bda:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002bde:	70 18       	ld.w	r8,r8[0x4]
80002be0:	10 99       	mov	r9,r8
80002be2:	ad b9       	sbr	r9,0xd
80002be4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002be8:	91 19       	st.w	r8[0x4],r9
80002bea:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bee:	90 38       	ld.sh	r8,r8[0x6]
80002bf0:	5c 78       	castu.h	r8
80002bf2:	20 28       	sub	r8,2
80002bf4:	10 99       	mov	r9,r8
80002bf6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002bfa:	91 a9       	st.w	r8[0x28],r9
80002bfc:	c0 d8       	rjmp	80002c16 <usart_init_rs232+0x142>
80002bfe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c02:	70 19       	ld.w	r9,r8[0x4]
80002c04:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c08:	90 38       	ld.sh	r8,r8[0x6]
80002c0a:	5c 78       	castu.h	r8
80002c0c:	ad 68       	lsl	r8,0xc
80002c0e:	10 49       	or	r9,r8
80002c10:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c14:	91 19       	st.w	r8[0x4],r9
80002c16:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c1a:	70 18       	ld.w	r8,r8[0x4]
80002c1c:	10 99       	mov	r9,r8
80002c1e:	e0 19 ff f0 	andl	r9,0xfff0
80002c22:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c26:	91 19       	st.w	r8[0x4],r9
80002c28:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c2c:	35 09       	mov	r9,80
80002c2e:	91 09       	st.w	r8[0x0],r9
80002c30:	30 08       	mov	r8,0
80002c32:	10 9c       	mov	r12,r8
80002c34:	2f dd       	sub	sp,-12
80002c36:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c3a:	00 00       	add	r0,r0
80002c3c:	80 00       	ld.sh	r0,r0[0x0]
80002c3e:	2a 60       	sub	r0,-90
80002c40:	80 00       	ld.sh	r0,r0[0x0]
80002c42:	29 8c       	sub	r12,-104

80002c44 <usart_write_char>:
80002c44:	eb cd 40 80 	pushm	r7,lr
80002c48:	1a 97       	mov	r7,sp
80002c4a:	20 3d       	sub	sp,12
80002c4c:	ef 4c ff f8 	st.w	r7[-8],r12
80002c50:	ef 4b ff f4 	st.w	r7[-12],r11
80002c54:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c58:	ef 48 ff fc 	st.w	r7[-4],r8
80002c5c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c60:	70 58       	ld.w	r8,r8[0x14]
80002c62:	e2 18 00 02 	andl	r8,0x2,COH
80002c66:	5f 18       	srne	r8
80002c68:	58 08       	cp.w	r8,0
80002c6a:	c0 a0       	breq	80002c7e <usart_write_char+0x3a>
80002c6c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002c70:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80002c74:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c78:	91 79       	st.w	r8[0x1c],r9
80002c7a:	30 08       	mov	r8,0
80002c7c:	c0 28       	rjmp	80002c80 <usart_write_char+0x3c>
80002c7e:	30 28       	mov	r8,2
80002c80:	10 9c       	mov	r12,r8
80002c82:	2f dd       	sub	sp,-12
80002c84:	e3 cd 80 80 	ldm	sp++,r7,pc

80002c88 <usart_putchar>:
80002c88:	eb cd 40 80 	pushm	r7,lr
80002c8c:	1a 97       	mov	r7,sp
80002c8e:	20 3d       	sub	sp,12
80002c90:	ef 4c ff f8 	st.w	r7[-8],r12
80002c94:	ef 4b ff f4 	st.w	r7[-12],r11
80002c98:	e0 68 27 10 	mov	r8,10000
80002c9c:	ef 48 ff fc 	st.w	r7[-4],r8
80002ca0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ca4:	58 08       	cp.w	r8,0
80002ca6:	5f 08       	sreq	r8
80002ca8:	5c 58       	castu.b	r8
80002caa:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002cae:	20 19       	sub	r9,1
80002cb0:	ef 49 ff fc 	st.w	r7[-4],r9
80002cb4:	58 08       	cp.w	r8,0
80002cb6:	c0 30       	breq	80002cbc <usart_putchar+0x34>
80002cb8:	3f f8       	mov	r8,-1
80002cba:	c0 b8       	rjmp	80002cd0 <usart_putchar+0x48>
80002cbc:	ee fb ff f4 	ld.w	r11,r7[-12]
80002cc0:	ee fc ff f8 	ld.w	r12,r7[-8]
80002cc4:	f0 1f 00 05 	mcall	80002cd8 <usart_putchar+0x50>
80002cc8:	18 98       	mov	r8,r12
80002cca:	58 08       	cp.w	r8,0
80002ccc:	ce a1       	brne	80002ca0 <usart_putchar+0x18>
80002cce:	30 08       	mov	r8,0
80002cd0:	10 9c       	mov	r12,r8
80002cd2:	2f dd       	sub	sp,-12
80002cd4:	e3 cd 80 80 	ldm	sp++,r7,pc
80002cd8:	80 00       	ld.sh	r0,r0[0x0]
80002cda:	2c 44       	sub	r4,-60

80002cdc <usart_write_line>:
80002cdc:	eb cd 40 80 	pushm	r7,lr
80002ce0:	1a 97       	mov	r7,sp
80002ce2:	20 2d       	sub	sp,8
80002ce4:	ef 4c ff fc 	st.w	r7[-4],r12
80002ce8:	ef 4b ff f8 	st.w	r7[-8],r11
80002cec:	c0 e8       	rjmp	80002d08 <usart_write_line+0x2c>
80002cee:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002cf2:	11 88       	ld.ub	r8,r8[0x0]
80002cf4:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002cf8:	2f f9       	sub	r9,-1
80002cfa:	ef 49 ff f8 	st.w	r7[-8],r9
80002cfe:	10 9b       	mov	r11,r8
80002d00:	ee fc ff fc 	ld.w	r12,r7[-4]
80002d04:	f0 1f 00 05 	mcall	80002d18 <usart_write_line+0x3c>
80002d08:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d0c:	11 88       	ld.ub	r8,r8[0x0]
80002d0e:	58 08       	cp.w	r8,0
80002d10:	ce f1       	brne	80002cee <usart_write_line+0x12>
80002d12:	2f ed       	sub	sp,-8
80002d14:	e3 cd 80 80 	ldm	sp++,r7,pc
80002d18:	80 00       	ld.sh	r0,r0[0x0]
80002d1a:	2c 88       	sub	r8,-56

80002d1c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
80002d1c:	eb cd 40 80 	pushm	r7,lr
80002d20:	1a 97       	mov	r7,sp
80002d22:	20 1d       	sub	sp,4
80002d24:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80002d28:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d2c:	2f 88       	sub	r8,-8
80002d2e:	10 99       	mov	r9,r8
80002d30:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d34:	91 19       	st.w	r8[0x4],r9

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80002d36:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d3a:	3f f9       	mov	r9,-1
80002d3c:	91 29       	st.w	r8[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80002d3e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d42:	2f 88       	sub	r8,-8
80002d44:	10 99       	mov	r9,r8
80002d46:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d4a:	91 39       	st.w	r8[0xc],r9
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80002d4c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d50:	2f 88       	sub	r8,-8
80002d52:	10 99       	mov	r9,r8
80002d54:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d58:	91 49       	st.w	r8[0x10],r9

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80002d5a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d5e:	30 09       	mov	r9,0
80002d60:	91 09       	st.w	r8[0x0],r9
}
80002d62:	2f fd       	sub	sp,-4
80002d64:	e3 cd 80 80 	ldm	sp++,r7,pc

80002d68 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
80002d68:	eb cd 40 80 	pushm	r7,lr
80002d6c:	1a 97       	mov	r7,sp
80002d6e:	20 1d       	sub	sp,4
80002d70:	ef 4c ff fc 	st.w	r7[-4],r12
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80002d74:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d78:	30 09       	mov	r9,0
80002d7a:	91 49       	st.w	r8[0x10],r9
}
80002d7c:	2f fd       	sub	sp,-4
80002d7e:	e3 cd 80 80 	ldm	sp++,r7,pc

80002d82 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
80002d82:	eb cd 40 80 	pushm	r7,lr
80002d86:	1a 97       	mov	r7,sp
80002d88:	20 3d       	sub	sp,12
80002d8a:	ef 4c ff f8 	st.w	r7[-8],r12
80002d8e:	ef 4b ff f4 	st.w	r7[-12],r11

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80002d92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d96:	70 18       	ld.w	r8,r8[0x4]
80002d98:	ef 48 ff fc 	st.w	r7[-4],r8

	pxNewListItem->pxNext = pxIndex->pxNext;
80002d9c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002da0:	70 19       	ld.w	r9,r8[0x4]
80002da2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002da6:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80002da8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dac:	70 19       	ld.w	r9,r8[0x4]
80002dae:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002db2:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80002db4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002db8:	70 18       	ld.w	r8,r8[0x4]
80002dba:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002dbe:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80002dc0:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002dc4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002dc8:	91 19       	st.w	r8[0x4],r9
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80002dca:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002dce:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dd2:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80002dd4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002dd8:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002ddc:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80002dde:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002de2:	70 08       	ld.w	r8,r8[0x0]
80002de4:	f0 c9 ff ff 	sub	r9,r8,-1
80002de8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dec:	91 09       	st.w	r8[0x0],r9
}
80002dee:	2f dd       	sub	sp,-12
80002df0:	e3 cd 80 80 	ldm	sp++,r7,pc

80002df4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
80002df4:	eb cd 40 80 	pushm	r7,lr
80002df8:	1a 97       	mov	r7,sp
80002dfa:	20 4d       	sub	sp,16
80002dfc:	ef 4c ff f4 	st.w	r7[-12],r12
80002e00:	ef 4b ff f0 	st.w	r7[-16],r11
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80002e04:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002e08:	70 08       	ld.w	r8,r8[0x0]
80002e0a:	ef 48 ff fc 	st.w	r7[-4],r8
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80002e0e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e12:	5b f8       	cp.w	r8,-1
80002e14:	c0 71       	brne	80002e22 <vListInsert+0x2e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80002e16:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002e1a:	70 48       	ld.w	r8,r8[0x10]
80002e1c:	ef 48 ff f8 	st.w	r7[-8],r8
80002e20:	c1 58       	rjmp	80002e4a <vListInsert+0x56>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80002e22:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002e26:	2f 88       	sub	r8,-8
80002e28:	ef 48 ff f8 	st.w	r7[-8],r8
80002e2c:	c0 68       	rjmp	80002e38 <vListInsert+0x44>
80002e2e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e32:	70 18       	ld.w	r8,r8[0x4]
80002e34:	ef 48 ff f8 	st.w	r7[-8],r8
80002e38:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e3c:	70 18       	ld.w	r8,r8[0x4]
80002e3e:	70 09       	ld.w	r9,r8[0x0]
80002e40:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e44:	10 39       	cp.w	r9,r8
80002e46:	fe 98 ff f4 	brls	80002e2e <vListInsert+0x3a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80002e4a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e4e:	70 19       	ld.w	r9,r8[0x4]
80002e50:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002e54:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80002e56:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002e5a:	70 18       	ld.w	r8,r8[0x4]
80002e5c:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002e60:	91 29       	st.w	r8[0x8],r9
	pxNewListItem->pxPrevious = pxIterator;
80002e62:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002e66:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002e6a:	91 29       	st.w	r8[0x8],r9
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80002e6c:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002e70:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e74:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80002e76:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002e7a:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002e7e:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80002e80:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002e84:	70 08       	ld.w	r8,r8[0x0]
80002e86:	f0 c9 ff ff 	sub	r9,r8,-1
80002e8a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002e8e:	91 09       	st.w	r8[0x0],r9
}
80002e90:	2f cd       	sub	sp,-16
80002e92:	e3 cd 80 80 	ldm	sp++,r7,pc

80002e96 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
80002e96:	eb cd 40 80 	pushm	r7,lr
80002e9a:	1a 97       	mov	r7,sp
80002e9c:	20 2d       	sub	sp,8
80002e9e:	ef 4c ff f8 	st.w	r7[-8],r12
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80002ea2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ea6:	70 18       	ld.w	r8,r8[0x4]
80002ea8:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002eac:	72 29       	ld.w	r9,r9[0x8]
80002eae:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80002eb0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002eb4:	70 28       	ld.w	r8,r8[0x8]
80002eb6:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002eba:	72 19       	ld.w	r9,r9[0x4]
80002ebc:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80002ebe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ec2:	70 48       	ld.w	r8,r8[0x10]
80002ec4:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80002ec8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ecc:	70 19       	ld.w	r9,r8[0x4]
80002ece:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ed2:	10 39       	cp.w	r9,r8
80002ed4:	c0 71       	brne	80002ee2 <vListRemove+0x4c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80002ed6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002eda:	70 29       	ld.w	r9,r8[0x8]
80002edc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ee0:	91 19       	st.w	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80002ee2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ee6:	30 09       	mov	r9,0
80002ee8:	91 49       	st.w	r8[0x10],r9
	( pxList->uxNumberOfItems )--;
80002eea:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002eee:	70 08       	ld.w	r8,r8[0x0]
80002ef0:	f0 c9 00 01 	sub	r9,r8,1
80002ef4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ef8:	91 09       	st.w	r8[0x0],r9
}
80002efa:	2f ed       	sub	sp,-8
80002efc:	e3 cd 80 80 	ldm	sp++,r7,pc

80002f00 <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80002f00:	eb cd 40 80 	pushm	r7,lr
80002f04:	1a 97       	mov	r7,sp
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
80002f06:	48 e8       	lddpc	r8,80002f3c <_init_startup+0x3c>
80002f08:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
80002f0c:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
80002f0e:	f0 1f 00 0d 	mcall	80002f40 <_init_startup+0x40>
			.channelmode = USART_NORMAL_CHMODE
		};

		/* Initialize the USART used for the debug trace with the configured parameters. */
		extern volatile avr32_usart_t *volatile stdio_usart_base;
		stdio_usart_base = configDBG_USART;
80002f12:	48 d8       	lddpc	r8,80002f44 <_init_startup+0x44>
80002f14:	fe 79 18 00 	mov	r9,-59392
80002f18:	91 09       	st.w	r8[0x0],r9
		gpio_enable_module( DBG_USART_GPIO_MAP,
80002f1a:	30 2b       	mov	r11,2
80002f1c:	48 bc       	lddpc	r12,80002f48 <_init_startup+0x48>
80002f1e:	f0 1f 00 0c 	mcall	80002f4c <_init_startup+0x4c>
		                    sizeof( DBG_USART_GPIO_MAP ) / sizeof( DBG_USART_GPIO_MAP[0] ) );
		usart_init_rs232(configDBG_USART, &DBG_USART_OPTIONS, configPBA_CLOCK_HZ);
80002f22:	e0 6a 1b 00 	mov	r10,6912
80002f26:	ea 1a 00 b7 	orh	r10,0xb7
80002f2a:	48 ab       	lddpc	r11,80002f50 <_init_startup+0x50>
80002f2c:	fe 7c 18 00 	mov	r12,-59392
80002f30:	f0 1f 00 09 	mcall	80002f54 <_init_startup+0x54>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
80002f34:	30 18       	mov	r8,1
}
80002f36:	10 9c       	mov	r12,r8
80002f38:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f3c:	80 00       	ld.sh	r0,r0[0x0]
80002f3e:	50 00       	stdsp	sp[0x0],r0
80002f40:	80 00       	ld.sh	r0,r0[0x0]
80002f42:	26 10       	sub	r0,97
80002f44:	00 00       	add	r0,r0
80002f46:	07 a4       	ld.ub	r4,r3[0x2]
80002f48:	80 00       	ld.sh	r0,r0[0x0]
80002f4a:	52 e4       	stdsp	sp[0xb8],r4
80002f4c:	80 00       	ld.sh	r0,r0[0x0]
80002f4e:	24 04       	sub	r4,64
80002f50:	80 00       	ld.sh	r0,r0[0x0]
80002f52:	52 f4       	stdsp	sp[0xbc],r4
80002f54:	80 00       	ld.sh	r0,r0[0x0]
80002f56:	2a d4       	sub	r4,-83

80002f58 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80002f58:	eb cd 40 80 	pushm	r7,lr
80002f5c:	1a 97       	mov	r7,sp
80002f5e:	20 1d       	sub	sp,4
80002f60:	ef 4c ff fc 	st.w	r7[-4],r12
	vTaskSuspendAll();
80002f64:	f0 1f 00 03 	mcall	80002f70 <__malloc_lock+0x18>
}
80002f68:	2f fd       	sub	sp,-4
80002f6a:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f6e:	00 00       	add	r0,r0
80002f70:	80 00       	ld.sh	r0,r0[0x0]
80002f72:	3c e0       	mov	r0,-50

80002f74 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80002f74:	eb cd 40 80 	pushm	r7,lr
80002f78:	1a 97       	mov	r7,sp
80002f7a:	20 1d       	sub	sp,4
80002f7c:	ef 4c ff fc 	st.w	r7[-4],r12
	xTaskResumeAll();
80002f80:	f0 1f 00 03 	mcall	80002f8c <__malloc_unlock+0x18>
}
80002f84:	2f fd       	sub	sp,-4
80002f86:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f8a:	00 00       	add	r0,r0
80002f8c:	80 00       	ld.sh	r0,r0[0x0]
80002f8e:	3c fc       	mov	r12,-49

80002f90 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80002f90:	eb cd 00 ff 	pushm	r0-r7
80002f94:	e0 68 00 1c 	mov	r8,28
80002f98:	ea 18 00 00 	orh	r8,0x0
80002f9c:	70 00       	ld.w	r0,r8[0x0]
80002f9e:	1a d0       	st.w	--sp,r0
80002fa0:	7a 90       	ld.w	r0,sp[0x24]
80002fa2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80002fa6:	58 10       	cp.w	r0,1
80002fa8:	e0 8b 00 08 	brhi	80002fb8 <LABEL_INT_SKIP_SAVE_CONTEXT_234>
80002fac:	e0 68 06 1c 	mov	r8,1564
80002fb0:	ea 18 00 00 	orh	r8,0x0
80002fb4:	70 00       	ld.w	r0,r8[0x0]
80002fb6:	81 0d       	st.w	r0[0x0],sp

80002fb8 <LABEL_INT_SKIP_SAVE_CONTEXT_234>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80002fb8:	f0 1f 00 12 	mcall	80003000 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80002fbc:	f0 1f 00 12 	mcall	80003004 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
		vTaskIncrementTick();
80002fc0:	f0 1f 00 12 	mcall	80003008 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x1c>
	portEXIT_CRITICAL();
80002fc4:	f0 1f 00 12 	mcall	8000300c <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80002fc8:	7a 90       	ld.w	r0,sp[0x24]
80002fca:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80002fce:	58 10       	cp.w	r0,1
80002fd0:	e0 8b 00 0e 	brhi	80002fec <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
80002fd4:	f0 1f 00 0c 	mcall	80003004 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
80002fd8:	f0 1f 00 0e 	mcall	80003010 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x24>
80002fdc:	f0 1f 00 0c 	mcall	8000300c <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>
80002fe0:	e0 68 06 1c 	mov	r8,1564
80002fe4:	ea 18 00 00 	orh	r8,0x0
80002fe8:	70 00       	ld.w	r0,r8[0x0]
80002fea:	60 0d       	ld.w	sp,r0[0x0]

80002fec <LABEL_INT_SKIP_RESTORE_CONTEXT_251>:
80002fec:	1b 00       	ld.w	r0,sp++
80002fee:	e0 68 00 1c 	mov	r8,28
80002ff2:	ea 18 00 00 	orh	r8,0x0
80002ff6:	91 00       	st.w	r8[0x0],r0
80002ff8:	e3 cd 00 ff 	ldm	sp++,r0-r7
80002ffc:	d6 03       	rete
80002ffe:	00 00       	add	r0,r0
80003000:	80 00       	ld.sh	r0,r0[0x0]
80003002:	32 fc       	mov	r12,47
80003004:	80 00       	ld.sh	r0,r0[0x0]
80003006:	30 ac       	mov	r12,10
80003008:	80 00       	ld.sh	r0,r0[0x0]
8000300a:	3e 24       	mov	r4,-30
8000300c:	80 00       	ld.sh	r0,r0[0x0]
8000300e:	30 c8       	mov	r8,12
80003010:	80 00       	ld.sh	r0,r0[0x0]
80003012:	3f 84       	mov	r4,-8

80003014 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80003014:	20 6d       	sub	sp,24
80003016:	eb cd 00 ff 	pushm	r0-r7
8000301a:	fa c7 ff c0 	sub	r7,sp,-64
8000301e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80003022:	ef 40 ff e0 	st.w	r7[-32],r0
80003026:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000302a:	ef 40 ff e4 	st.w	r7[-28],r0
8000302e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80003032:	e0 68 00 1c 	mov	r8,28
80003036:	ea 18 00 00 	orh	r8,0x0
8000303a:	70 00       	ld.w	r0,r8[0x0]
8000303c:	1a d0       	st.w	--sp,r0
8000303e:	f0 1f 00 1a 	mcall	800030a4 <LABEL_RET_SCALL_260+0x14>
80003042:	e0 68 06 1c 	mov	r8,1564
80003046:	ea 18 00 00 	orh	r8,0x0
8000304a:	70 00       	ld.w	r0,r8[0x0]
8000304c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
8000304e:	f0 1f 00 17 	mcall	800030a8 <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
80003052:	e0 68 06 1c 	mov	r8,1564
80003056:	ea 18 00 00 	orh	r8,0x0
8000305a:	70 00       	ld.w	r0,r8[0x0]
8000305c:	60 0d       	ld.w	sp,r0[0x0]
8000305e:	1b 00       	ld.w	r0,sp++
80003060:	e0 68 00 1c 	mov	r8,28
80003064:	ea 18 00 00 	orh	r8,0x0
80003068:	91 00       	st.w	r8[0x0],r0
8000306a:	fa c7 ff d8 	sub	r7,sp,-40
8000306e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80003072:	ee f0 ff e0 	ld.w	r0,r7[-32]
80003076:	e0 61 00 1c 	mov	r1,28
8000307a:	ea 11 00 00 	orh	r1,0x0
8000307e:	62 02       	ld.w	r2,r1[0x0]
80003080:	58 02       	cp.w	r2,0
80003082:	c0 70       	breq	80003090 <LABEL_RET_SCALL_260>
80003084:	e4 c2 00 01 	sub	r2,r2,1
80003088:	83 02       	st.w	r1[0x0],r2
8000308a:	58 02       	cp.w	r2,0
8000308c:	c0 21       	brne	80003090 <LABEL_RET_SCALL_260>
8000308e:	b1 c0       	cbr	r0,0x10

80003090 <LABEL_RET_SCALL_260>:
80003090:	ef 40 ff f8 	st.w	r7[-8],r0
80003094:	ee f0 ff e4 	ld.w	r0,r7[-28]
80003098:	ef 40 ff fc 	st.w	r7[-4],r0
8000309c:	e3 cd 00 ff 	ldm	sp++,r0-r7
800030a0:	2f ad       	sub	sp,-24
800030a2:	d6 13       	rets
800030a4:	80 00       	ld.sh	r0,r0[0x0]
800030a6:	30 ac       	mov	r12,10
800030a8:	80 00       	ld.sh	r0,r0[0x0]
800030aa:	3f 84       	mov	r4,-8

800030ac <vPortEnterCritical>:
/* The code generated by the GCC compiler uses the stack in different ways at
different optimisation levels.  The interrupt flags can therefore not always
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
800030ac:	eb cd 40 80 	pushm	r7,lr
800030b0:	1a 97       	mov	r7,sp
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
800030b2:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
800030b4:	48 48       	lddpc	r8,800030c4 <vPortEnterCritical+0x18>
800030b6:	70 08       	ld.w	r8,r8[0x0]
800030b8:	f0 c9 ff ff 	sub	r9,r8,-1
800030bc:	48 28       	lddpc	r8,800030c4 <vPortEnterCritical+0x18>
800030be:	91 09       	st.w	r8[0x0],r9
}
800030c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800030c4:	00 00       	add	r0,r0
800030c6:	00 1c       	sub	r12,r0

800030c8 <vPortExitCritical>:
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
800030c8:	eb cd 40 80 	pushm	r7,lr
800030cc:	1a 97       	mov	r7,sp
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
800030ce:	48 98       	lddpc	r8,800030f0 <vPortExitCritical+0x28>
800030d0:	70 08       	ld.w	r8,r8[0x0]
800030d2:	58 08       	cp.w	r8,0
800030d4:	c0 c0       	breq	800030ec <vPortExitCritical+0x24>
	{
		ulCriticalNesting--;
800030d6:	48 78       	lddpc	r8,800030f0 <vPortExitCritical+0x28>
800030d8:	70 08       	ld.w	r8,r8[0x0]
800030da:	f0 c9 00 01 	sub	r9,r8,1
800030de:	48 58       	lddpc	r8,800030f0 <vPortExitCritical+0x28>
800030e0:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800030e2:	48 48       	lddpc	r8,800030f0 <vPortExitCritical+0x28>
800030e4:	70 08       	ld.w	r8,r8[0x0]
800030e6:	58 08       	cp.w	r8,0
800030e8:	c0 21       	brne	800030ec <vPortExitCritical+0x24>
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
800030ea:	d5 03       	csrf	0x10
		}
	}
}
800030ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800030f0:	00 00       	add	r0,r0
800030f2:	00 1c       	sub	r12,r0

800030f4 <pxPortInitialiseStack>:
 * portSAVE_CONTEXT had been called.
 *
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
800030f4:	eb cd 40 80 	pushm	r7,lr
800030f8:	1a 97       	mov	r7,sp
800030fa:	20 3d       	sub	sp,12
800030fc:	ef 4c ff fc 	st.w	r7[-4],r12
80003100:	ef 4b ff f8 	st.w	r7[-8],r11
80003104:	ef 4a ff f4 	st.w	r7[-12],r10
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
80003108:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000310c:	20 48       	sub	r8,4
8000310e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80003112:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003116:	e0 69 08 08 	mov	r9,2056
8000311a:	ea 19 08 08 	orh	r9,0x808
8000311e:	91 09       	st.w	r8[0x0],r9
80003120:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003124:	20 48       	sub	r8,4
80003126:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000312a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000312e:	e0 69 09 09 	mov	r9,2313
80003132:	ea 19 09 09 	orh	r9,0x909
80003136:	91 09       	st.w	r8[0x0],r9
80003138:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000313c:	20 48       	sub	r8,4
8000313e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80003142:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003146:	e0 69 0a 0a 	mov	r9,2570
8000314a:	ea 19 0a 0a 	orh	r9,0xa0a
8000314e:	91 09       	st.w	r8[0x0],r9
80003150:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003154:	20 48       	sub	r8,4
80003156:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
8000315a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000315e:	e0 69 0b 0b 	mov	r9,2827
80003162:	ea 19 0b 0b 	orh	r9,0xb0b
80003166:	91 09       	st.w	r8[0x0],r9
80003168:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000316c:	20 48       	sub	r8,4
8000316e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80003172:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003176:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000317a:	91 09       	st.w	r8[0x0],r9
8000317c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003180:	20 48       	sub	r8,4
80003182:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80003186:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000318a:	e0 69 be ef 	mov	r9,48879
8000318e:	ea 19 de ad 	orh	r9,0xdead
80003192:	91 09       	st.w	r8[0x0],r9
80003194:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003198:	20 48       	sub	r8,4
8000319a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
8000319e:	ee f9 ff f8 	ld.w	r9,r7[-8]
800031a2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031a6:	91 09       	st.w	r8[0x0],r9
800031a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031ac:	20 48       	sub	r8,4
800031ae:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800031b2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031b6:	fc 19 00 40 	movh	r9,0x40
800031ba:	91 09       	st.w	r8[0x0],r9
800031bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031c0:	20 48       	sub	r8,4
800031c2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
800031c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031ca:	e0 69 00 ff 	mov	r9,255
800031ce:	ea 19 ff 00 	orh	r9,0xff00
800031d2:	91 09       	st.w	r8[0x0],r9
800031d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031d8:	20 48       	sub	r8,4
800031da:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800031de:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031e2:	e0 69 01 01 	mov	r9,257
800031e6:	ea 19 01 01 	orh	r9,0x101
800031ea:	91 09       	st.w	r8[0x0],r9
800031ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031f0:	20 48       	sub	r8,4
800031f2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
800031f6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031fa:	e0 69 02 02 	mov	r9,514
800031fe:	ea 19 02 02 	orh	r9,0x202
80003202:	91 09       	st.w	r8[0x0],r9
80003204:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003208:	20 48       	sub	r8,4
8000320a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
8000320e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003212:	e0 69 03 03 	mov	r9,771
80003216:	ea 19 03 03 	orh	r9,0x303
8000321a:	91 09       	st.w	r8[0x0],r9
8000321c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003220:	20 48       	sub	r8,4
80003222:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80003226:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000322a:	e0 69 04 04 	mov	r9,1028
8000322e:	ea 19 04 04 	orh	r9,0x404
80003232:	91 09       	st.w	r8[0x0],r9
80003234:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003238:	20 48       	sub	r8,4
8000323a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
8000323e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003242:	e0 69 05 05 	mov	r9,1285
80003246:	ea 19 05 05 	orh	r9,0x505
8000324a:	91 09       	st.w	r8[0x0],r9
8000324c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003250:	20 48       	sub	r8,4
80003252:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80003256:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000325a:	e0 69 06 06 	mov	r9,1542
8000325e:	ea 19 06 06 	orh	r9,0x606
80003262:	91 09       	st.w	r8[0x0],r9
80003264:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003268:	20 48       	sub	r8,4
8000326a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
8000326e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003272:	e0 69 07 07 	mov	r9,1799
80003276:	ea 19 07 07 	orh	r9,0x707
8000327a:	91 09       	st.w	r8[0x0],r9
8000327c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003280:	20 48       	sub	r8,4
80003282:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80003286:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000328a:	30 09       	mov	r9,0
8000328c:	91 09       	st.w	r8[0x0],r9

	return pxTopOfStack;
8000328e:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80003292:	10 9c       	mov	r12,r8
80003294:	2f dd       	sub	sp,-12
80003296:	e3 cd 80 80 	ldm	sp++,r7,pc
8000329a:	d7 03       	nop

8000329c <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
8000329c:	eb cd 40 80 	pushm	r7,lr
800032a0:	1a 97       	mov	r7,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
800032a2:	f0 1f 00 10 	mcall	800032e0 <xPortStartScheduler+0x44>

	/* Start the first task. */
	portRESTORE_CONTEXT();
800032a6:	e0 68 06 1c 	mov	r8,1564
800032aa:	ea 18 00 00 	orh	r8,0x0
800032ae:	70 00       	ld.w	r0,r8[0x0]
800032b0:	60 0d       	ld.w	sp,r0[0x0]
800032b2:	1b 00       	ld.w	r0,sp++
800032b4:	e0 68 00 1c 	mov	r8,28
800032b8:	ea 18 00 00 	orh	r8,0x0
800032bc:	91 00       	st.w	r8[0x0],r0
800032be:	e3 cd 00 ff 	ldm	sp++,r0-r7
800032c2:	2f ed       	sub	sp,-8
800032c4:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800032c8:	fa f0 ff e0 	ld.w	r0,sp[-32]
800032cc:	e3 b0 00 00 	mtsr	0x0,r0
800032d0:	fa f0 ff dc 	ld.w	r0,sp[-36]
800032d4:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
800032d8:	30 08       	mov	r8,0
}
800032da:	10 9c       	mov	r12,r8
800032dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800032e0:	80 00       	ld.sh	r0,r0[0x0]
800032e2:	33 10       	mov	r0,49

800032e4 <prvScheduleFirstTick>:

/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
800032e4:	eb cd 40 80 	pushm	r7,lr
800032e8:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
800032ea:	e0 68 2e e0 	mov	r8,12000
800032ee:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800032f2:	30 08       	mov	r8,0
800032f4:	e3 b8 00 42 	mtsr	0x108,r8
	}
800032f8:	e3 cd 80 80 	ldm	sp++,r7,pc

800032fc <prvClearCcInt>:

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
800032fc:	eb cd 40 80 	pushm	r7,lr
80003300:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80003302:	e1 b8 00 43 	mfsr	r8,0x10c
80003306:	e3 b8 00 43 	mtsr	0x10c,r8
	}
8000330a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000330e:	d7 03       	nop

80003310 <prvSetupTimerInterrupt>:
#endif
/*-----------------------------------------------------------*/

/* Setup the timer to generate the tick interrupts. */
static void prvSetupTimerInterrupt(void)
{
80003310:	eb cd 40 80 	pushm	r7,lr
80003314:	1a 97       	mov	r7,sp
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80003316:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80003318:	30 0a       	mov	r10,0
8000331a:	30 0b       	mov	r11,0
8000331c:	48 4c       	lddpc	r12,8000332c <prvSetupTimerInterrupt+0x1c>
8000331e:	f0 1f 00 05 	mcall	80003330 <prvSetupTimerInterrupt+0x20>
		prvScheduleFirstTick();
80003322:	f0 1f 00 05 	mcall	80003334 <prvSetupTimerInterrupt+0x24>
	}
	#endif
}
80003326:	e3 cd 80 80 	ldm	sp++,r7,pc
8000332a:	00 00       	add	r0,r0
8000332c:	80 00       	ld.sh	r0,r0[0x0]
8000332e:	2f 90       	sub	r0,-7
80003330:	80 00       	ld.sh	r0,r0[0x0]
80003332:	26 a8       	sub	r8,106
80003334:	80 00       	ld.sh	r0,r0[0x0]
80003336:	32 e4       	mov	r4,46

80003338 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80003338:	eb cd 40 80 	pushm	r7,lr
8000333c:	1a 97       	mov	r7,sp
8000333e:	20 2d       	sub	sp,8
80003340:	ef 4c ff f8 	st.w	r7[-8],r12
void *pvReturn;

	vTaskSuspendAll();
80003344:	f0 1f 00 09 	mcall	80003368 <pvPortMalloc+0x30>
	{
		pvReturn = malloc( xWantedSize );
80003348:	ee fc ff f8 	ld.w	r12,r7[-8]
8000334c:	f0 1f 00 08 	mcall	8000336c <pvPortMalloc+0x34>
80003350:	18 98       	mov	r8,r12
80003352:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	xTaskResumeAll();
80003356:	f0 1f 00 07 	mcall	80003370 <pvPortMalloc+0x38>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
8000335a:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000335e:	10 9c       	mov	r12,r8
80003360:	2f ed       	sub	sp,-8
80003362:	e3 cd 80 80 	ldm	sp++,r7,pc
80003366:	00 00       	add	r0,r0
80003368:	80 00       	ld.sh	r0,r0[0x0]
8000336a:	3c e0       	mov	r0,-50
8000336c:	80 00       	ld.sh	r0,r0[0x0]
8000336e:	45 f4       	lddsp	r4,sp[0x17c]
80003370:	80 00       	ld.sh	r0,r0[0x0]
80003372:	3c fc       	mov	r12,-49

80003374 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80003374:	eb cd 40 80 	pushm	r7,lr
80003378:	1a 97       	mov	r7,sp
8000337a:	20 1d       	sub	sp,4
8000337c:	ef 4c ff fc 	st.w	r7[-4],r12
	if( pv )
80003380:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003384:	58 08       	cp.w	r8,0
80003386:	c0 90       	breq	80003398 <vPortFree+0x24>
	{
		vTaskSuspendAll();
80003388:	f0 1f 00 06 	mcall	800033a0 <vPortFree+0x2c>
		{
			free( pv );
8000338c:	ee fc ff fc 	ld.w	r12,r7[-4]
80003390:	f0 1f 00 05 	mcall	800033a4 <vPortFree+0x30>
		}
		xTaskResumeAll();
80003394:	f0 1f 00 05 	mcall	800033a8 <vPortFree+0x34>
	}
}
80003398:	2f fd       	sub	sp,-4
8000339a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000339e:	00 00       	add	r0,r0
800033a0:	80 00       	ld.sh	r0,r0[0x0]
800033a2:	3c e0       	mov	r0,-50
800033a4:	80 00       	ld.sh	r0,r0[0x0]
800033a6:	45 e4       	lddsp	r4,sp[0x178]
800033a8:	80 00       	ld.sh	r0,r0[0x0]
800033aa:	3c fc       	mov	r12,-49

800033ac <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800033ac:	eb cd 40 80 	pushm	r7,lr
800033b0:	1a 97       	mov	r7,sp
800033b2:	20 5d       	sub	sp,20
800033b4:	ef 4c ff f0 	st.w	r7[-16],r12
800033b8:	ef 4b ff ec 	st.w	r7[-20],r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
800033bc:	30 08       	mov	r8,0
800033be:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800033c2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800033c6:	58 08       	cp.w	r8,0
800033c8:	c7 20       	breq	800034ac <xQueueCreate+0x100>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800033ca:	34 cc       	mov	r12,76
800033cc:	f0 1f 00 3b 	mcall	800034b8 <xQueueCreate+0x10c>
800033d0:	18 98       	mov	r8,r12
800033d2:	ef 48 ff f4 	st.w	r7[-12],r8
		if( pxNewQueue != NULL )
800033d6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800033da:	58 08       	cp.w	r8,0
800033dc:	c6 80       	breq	800034ac <xQueueCreate+0x100>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800033de:	ee f9 ff f0 	ld.w	r9,r7[-16]
800033e2:	ee f8 ff ec 	ld.w	r8,r7[-20]
800033e6:	f2 08 02 48 	mul	r8,r9,r8
800033ea:	2f f8       	sub	r8,-1
800033ec:	ef 48 ff f8 	st.w	r7[-8],r8

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800033f0:	ee fc ff f8 	ld.w	r12,r7[-8]
800033f4:	f0 1f 00 31 	mcall	800034b8 <xQueueCreate+0x10c>
800033f8:	18 98       	mov	r8,r12
800033fa:	10 99       	mov	r9,r8
800033fc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003400:	91 09       	st.w	r8[0x0],r9
			if( pxNewQueue->pcHead != NULL )
80003402:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003406:	70 08       	ld.w	r8,r8[0x0]
80003408:	58 08       	cp.w	r8,0
8000340a:	c4 d0       	breq	800034a4 <xQueueCreate+0xf8>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000340c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003410:	70 09       	ld.w	r9,r8[0x0]
80003412:	ee fa ff f0 	ld.w	r10,r7[-16]
80003416:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000341a:	f4 08 02 48 	mul	r8,r10,r8
8000341e:	10 09       	add	r9,r8
80003420:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003424:	91 19       	st.w	r8[0x4],r9
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80003426:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000342a:	30 09       	mov	r9,0
8000342c:	91 e9       	st.w	r8[0x38],r9
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000342e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003432:	70 09       	ld.w	r9,r8[0x0]
80003434:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003438:	91 29       	st.w	r8[0x8],r9
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000343a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000343e:	70 09       	ld.w	r9,r8[0x0]
80003440:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003444:	f0 ca 00 01 	sub	r10,r8,1
80003448:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000344c:	f4 08 02 48 	mul	r8,r10,r8
80003450:	10 09       	add	r9,r8
80003452:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003456:	91 39       	st.w	r8[0xc],r9
				pxNewQueue->uxLength = uxQueueLength;
80003458:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000345c:	ee f9 ff f0 	ld.w	r9,r7[-16]
80003460:	91 f9       	st.w	r8[0x3c],r9
				pxNewQueue->uxItemSize = uxItemSize;
80003462:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003466:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000346a:	f1 49 00 40 	st.w	r8[64],r9
				pxNewQueue->xRxLock = queueUNLOCKED;
8000346e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003472:	3f f9       	mov	r9,-1
80003474:	f1 49 00 44 	st.w	r8[68],r9
				pxNewQueue->xTxLock = queueUNLOCKED;
80003478:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000347c:	3f f9       	mov	r9,-1
8000347e:	f1 49 00 48 	st.w	r8[72],r9

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80003482:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003486:	2f 08       	sub	r8,-16
80003488:	10 9c       	mov	r12,r8
8000348a:	f0 1f 00 0d 	mcall	800034bc <xQueueCreate+0x110>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000348e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003492:	2d c8       	sub	r8,-36
80003494:	10 9c       	mov	r12,r8
80003496:	f0 1f 00 0a 	mcall	800034bc <xQueueCreate+0x110>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
8000349a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000349e:	ef 48 ff fc 	st.w	r7[-4],r8
800034a2:	c0 58       	rjmp	800034ac <xQueueCreate+0x100>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800034a4:	ee fc ff f4 	ld.w	r12,r7[-12]
800034a8:	f0 1f 00 06 	mcall	800034c0 <xQueueCreate+0x114>
		}
	}

	configASSERT( xReturn );

	return xReturn;
800034ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800034b0:	10 9c       	mov	r12,r8
800034b2:	2f bd       	sub	sp,-20
800034b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800034b8:	80 00       	ld.sh	r0,r0[0x0]
800034ba:	33 38       	mov	r8,51
800034bc:	80 00       	ld.sh	r0,r0[0x0]
800034be:	2d 1c       	sub	r12,-47
800034c0:	80 00       	ld.sh	r0,r0[0x0]
800034c2:	33 74       	mov	r4,55

800034c4 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
800034c4:	eb cd 40 80 	pushm	r7,lr
800034c8:	1a 97       	mov	r7,sp
800034ca:	20 3d       	sub	sp,12
800034cc:	ef 4c ff f8 	st.w	r7[-8],r12
800034d0:	ef 4b ff f4 	st.w	r7[-12],r11
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
800034d4:	30 0b       	mov	r11,0
800034d6:	ee fc ff f8 	ld.w	r12,r7[-8]
800034da:	f0 1f 00 0b 	mcall	80003504 <xQueueCreateCountingSemaphore+0x40>
800034de:	18 98       	mov	r8,r12
800034e0:	ef 48 ff fc 	st.w	r7[-4],r8

		if( pxHandle != NULL )
800034e4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034e8:	58 08       	cp.w	r8,0
800034ea:	c0 60       	breq	800034f6 <xQueueCreateCountingSemaphore+0x32>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
800034ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034f0:	ee f9 ff f4 	ld.w	r9,r7[-12]
800034f4:	91 e9       	st.w	r8[0x38],r9
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
800034f6:	ee f8 ff fc 	ld.w	r8,r7[-4]
	}
800034fa:	10 9c       	mov	r12,r8
800034fc:	2f dd       	sub	sp,-12
800034fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80003502:	00 00       	add	r0,r0
80003504:	80 00       	ld.sh	r0,r0[0x0]
80003506:	33 ac       	mov	r12,58

80003508 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80003508:	eb cd 40 80 	pushm	r7,lr
8000350c:	1a 97       	mov	r7,sp
8000350e:	20 7d       	sub	sp,28
80003510:	ef 4c ff f0 	st.w	r7[-16],r12
80003514:	ef 4b ff ec 	st.w	r7[-20],r11
80003518:	ef 4a ff e8 	st.w	r7[-24],r10
8000351c:	ef 49 ff e4 	st.w	r7[-28],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
80003520:	30 08       	mov	r8,0
80003522:	ef 48 ff fc 	st.w	r7[-4],r8
80003526:	c0 28       	rjmp	8000352a <xQueueGenericSend+0x22>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80003528:	d7 03       	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000352a:	f0 1f 00 47 	mcall	80003644 <xQueueGenericSend+0x13c>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000352e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003532:	70 e9       	ld.w	r9,r8[0x38]
80003534:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003538:	70 f8       	ld.w	r8,r8[0x3c]
8000353a:	10 39       	cp.w	r9,r8
8000353c:	c1 c2       	brcc	80003574 <xQueueGenericSend+0x6c>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000353e:	ee fa ff e4 	ld.w	r10,r7[-28]
80003542:	ee fb ff ec 	ld.w	r11,r7[-20]
80003546:	ee fc ff f0 	ld.w	r12,r7[-16]
8000354a:	f0 1f 00 40 	mcall	80003648 <xQueueGenericSend+0x140>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000354e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003552:	70 98       	ld.w	r8,r8[0x24]
80003554:	58 08       	cp.w	r8,0
80003556:	c0 b0       	breq	8000356c <xQueueGenericSend+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80003558:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000355c:	2d c8       	sub	r8,-36
8000355e:	10 9c       	mov	r12,r8
80003560:	f0 1f 00 3b 	mcall	8000364c <xQueueGenericSend+0x144>
80003564:	18 98       	mov	r8,r12
80003566:	58 18       	cp.w	r8,1
80003568:	c0 21       	brne	8000356c <xQueueGenericSend+0x64>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
8000356a:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
8000356c:	f0 1f 00 39 	mcall	80003650 <xQueueGenericSend+0x148>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80003570:	30 18       	mov	r8,1
80003572:	c6 58       	rjmp	8000363c <xQueueGenericSend+0x134>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80003574:	ee f8 ff e8 	ld.w	r8,r7[-24]
80003578:	58 08       	cp.w	r8,0
8000357a:	c0 51       	brne	80003584 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000357c:	f0 1f 00 35 	mcall	80003650 <xQueueGenericSend+0x148>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80003580:	30 08       	mov	r8,0
80003582:	c5 d8       	rjmp	8000363c <xQueueGenericSend+0x134>
				}
				else if( xEntryTimeSet == pdFALSE )
80003584:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003588:	58 08       	cp.w	r8,0
8000358a:	c0 91       	brne	8000359c <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000358c:	ee c8 00 0c 	sub	r8,r7,12
80003590:	10 9c       	mov	r12,r8
80003592:	f0 1f 00 31 	mcall	80003654 <xQueueGenericSend+0x14c>
					xEntryTimeSet = pdTRUE;
80003596:	30 18       	mov	r8,1
80003598:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}
		}
		taskEXIT_CRITICAL();
8000359c:	f0 1f 00 2d 	mcall	80003650 <xQueueGenericSend+0x148>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800035a0:	f0 1f 00 2e 	mcall	80003658 <xQueueGenericSend+0x150>
		prvLockQueue( pxQueue );
800035a4:	f0 1f 00 28 	mcall	80003644 <xQueueGenericSend+0x13c>
800035a8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035ac:	71 18       	ld.w	r8,r8[0x44]
800035ae:	5b f8       	cp.w	r8,-1
800035b0:	c0 61       	brne	800035bc <xQueueGenericSend+0xb4>
800035b2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035b6:	30 09       	mov	r9,0
800035b8:	f1 49 00 44 	st.w	r8[68],r9
800035bc:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035c0:	71 28       	ld.w	r8,r8[0x48]
800035c2:	5b f8       	cp.w	r8,-1
800035c4:	c0 61       	brne	800035d0 <xQueueGenericSend+0xc8>
800035c6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035ca:	30 09       	mov	r9,0
800035cc:	f1 49 00 48 	st.w	r8[72],r9
800035d0:	f0 1f 00 20 	mcall	80003650 <xQueueGenericSend+0x148>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800035d4:	ee c9 00 18 	sub	r9,r7,24
800035d8:	ee c8 00 0c 	sub	r8,r7,12
800035dc:	12 9b       	mov	r11,r9
800035de:	10 9c       	mov	r12,r8
800035e0:	f0 1f 00 1f 	mcall	8000365c <xQueueGenericSend+0x154>
800035e4:	18 98       	mov	r8,r12
800035e6:	58 08       	cp.w	r8,0
800035e8:	c2 31       	brne	8000362e <xQueueGenericSend+0x126>
		{
			if( prvIsQueueFull( pxQueue ) )
800035ea:	ee fc ff f0 	ld.w	r12,r7[-16]
800035ee:	f0 1f 00 1d 	mcall	80003660 <xQueueGenericSend+0x158>
800035f2:	18 98       	mov	r8,r12
800035f4:	58 08       	cp.w	r8,0
800035f6:	c1 50       	breq	80003620 <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800035f8:	ee f9 ff e8 	ld.w	r9,r7[-24]
800035fc:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003600:	2f 08       	sub	r8,-16
80003602:	12 9b       	mov	r11,r9
80003604:	10 9c       	mov	r12,r8
80003606:	f0 1f 00 18 	mcall	80003664 <xQueueGenericSend+0x15c>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000360a:	ee fc ff f0 	ld.w	r12,r7[-16]
8000360e:	f0 1f 00 17 	mcall	80003668 <xQueueGenericSend+0x160>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80003612:	f0 1f 00 17 	mcall	8000366c <xQueueGenericSend+0x164>
80003616:	18 98       	mov	r8,r12
80003618:	58 08       	cp.w	r8,0
8000361a:	c8 71       	brne	80003528 <xQueueGenericSend+0x20>
				{
					portYIELD_WITHIN_API();
8000361c:	d7 33       	scall
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
8000361e:	c8 6b       	rjmp	8000352a <xQueueGenericSend+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80003620:	ee fc ff f0 	ld.w	r12,r7[-16]
80003624:	f0 1f 00 11 	mcall	80003668 <xQueueGenericSend+0x160>
				( void ) xTaskResumeAll();
80003628:	f0 1f 00 11 	mcall	8000366c <xQueueGenericSend+0x164>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
8000362c:	c7 fb       	rjmp	8000352a <xQueueGenericSend+0x22>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000362e:	ee fc ff f0 	ld.w	r12,r7[-16]
80003632:	f0 1f 00 0e 	mcall	80003668 <xQueueGenericSend+0x160>
			( void ) xTaskResumeAll();
80003636:	f0 1f 00 0e 	mcall	8000366c <xQueueGenericSend+0x164>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
8000363a:	30 08       	mov	r8,0
		}
	}
}
8000363c:	10 9c       	mov	r12,r8
8000363e:	2f 9d       	sub	sp,-28
80003640:	e3 cd 80 80 	ldm	sp++,r7,pc
80003644:	80 00       	ld.sh	r0,r0[0x0]
80003646:	30 ac       	mov	r12,10
80003648:	80 00       	ld.sh	r0,r0[0x0]
8000364a:	38 1c       	mov	r12,-127
8000364c:	80 00       	ld.sh	r0,r0[0x0]
8000364e:	40 b4       	lddsp	r4,sp[0x2c]
80003650:	80 00       	ld.sh	r0,r0[0x0]
80003652:	30 c8       	mov	r8,12
80003654:	80 00       	ld.sh	r0,r0[0x0]
80003656:	41 84       	lddsp	r4,sp[0x60]
80003658:	80 00       	ld.sh	r0,r0[0x0]
8000365a:	3c e0       	mov	r0,-50
8000365c:	80 00       	ld.sh	r0,r0[0x0]
8000365e:	41 b4       	lddsp	r4,sp[0x6c]
80003660:	80 00       	ld.sh	r0,r0[0x0]
80003662:	3a 70       	mov	r0,-89
80003664:	80 00       	ld.sh	r0,r0[0x0]
80003666:	40 34       	lddsp	r4,sp[0xc]
80003668:	80 00       	ld.sh	r0,r0[0x0]
8000366a:	39 68       	mov	r8,-106
8000366c:	80 00       	ld.sh	r0,r0[0x0]
8000366e:	3c fc       	mov	r12,-49

80003670 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80003670:	eb cd 40 80 	pushm	r7,lr
80003674:	1a 97       	mov	r7,sp
80003676:	20 8d       	sub	sp,32
80003678:	ef 4c ff ec 	st.w	r7[-20],r12
8000367c:	ef 4b ff e8 	st.w	r7[-24],r11
80003680:	ef 4a ff e4 	st.w	r7[-28],r10
80003684:	ef 49 ff e0 	st.w	r7[-32],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
80003688:	30 08       	mov	r8,0
8000368a:	ef 48 ff f8 	st.w	r7[-8],r8
8000368e:	c0 28       	rjmp	80003692 <xQueueGenericReceive+0x22>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
80003690:	d7 03       	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80003692:	f0 1f 00 58 	mcall	800037f0 <xQueueGenericReceive+0x180>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80003696:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000369a:	70 e8       	ld.w	r8,r8[0x38]
8000369c:	58 08       	cp.w	r8,0
8000369e:	c4 00       	breq	8000371e <xQueueGenericReceive+0xae>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800036a0:	ee f8 ff ec 	ld.w	r8,r7[-20]
800036a4:	70 38       	ld.w	r8,r8[0xc]
800036a6:	ef 48 ff fc 	st.w	r7[-4],r8

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800036aa:	ee fb ff e8 	ld.w	r11,r7[-24]
800036ae:	ee fc ff ec 	ld.w	r12,r7[-20]
800036b2:	f0 1f 00 51 	mcall	800037f4 <xQueueGenericReceive+0x184>

				if( xJustPeeking == pdFALSE )
800036b6:	ee f8 ff e0 	ld.w	r8,r7[-32]
800036ba:	58 08       	cp.w	r8,0
800036bc:	c1 91       	brne	800036ee <xQueueGenericReceive+0x7e>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800036be:	ee f8 ff ec 	ld.w	r8,r7[-20]
800036c2:	70 e8       	ld.w	r8,r8[0x38]
800036c4:	f0 c9 00 01 	sub	r9,r8,1
800036c8:	ee f8 ff ec 	ld.w	r8,r7[-20]
800036cc:	91 e9       	st.w	r8[0x38],r9
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800036ce:	ee f8 ff ec 	ld.w	r8,r7[-20]
800036d2:	70 48       	ld.w	r8,r8[0x10]
800036d4:	58 08       	cp.w	r8,0
800036d6:	c2 00       	breq	80003716 <xQueueGenericReceive+0xa6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800036d8:	ee f8 ff ec 	ld.w	r8,r7[-20]
800036dc:	2f 08       	sub	r8,-16
800036de:	10 9c       	mov	r12,r8
800036e0:	f0 1f 00 46 	mcall	800037f8 <xQueueGenericReceive+0x188>
800036e4:	18 98       	mov	r8,r12
800036e6:	58 18       	cp.w	r8,1
800036e8:	c1 71       	brne	80003716 <xQueueGenericReceive+0xa6>
						{
							portYIELD_WITHIN_API();
800036ea:	d7 33       	scall
800036ec:	c1 58       	rjmp	80003716 <xQueueGenericReceive+0xa6>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800036ee:	ee f8 ff ec 	ld.w	r8,r7[-20]
800036f2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800036f6:	91 39       	st.w	r8[0xc],r9

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800036f8:	ee f8 ff ec 	ld.w	r8,r7[-20]
800036fc:	70 98       	ld.w	r8,r8[0x24]
800036fe:	58 08       	cp.w	r8,0
80003700:	c0 b0       	breq	80003716 <xQueueGenericReceive+0xa6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80003702:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003706:	2d c8       	sub	r8,-36
80003708:	10 9c       	mov	r12,r8
8000370a:	f0 1f 00 3c 	mcall	800037f8 <xQueueGenericReceive+0x188>
8000370e:	18 98       	mov	r8,r12
80003710:	58 08       	cp.w	r8,0
80003712:	c0 20       	breq	80003716 <xQueueGenericReceive+0xa6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80003714:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80003716:	f0 1f 00 3a 	mcall	800037fc <xQueueGenericReceive+0x18c>
				return pdPASS;
8000371a:	30 18       	mov	r8,1
8000371c:	c6 68       	rjmp	800037e8 <xQueueGenericReceive+0x178>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000371e:	ee f8 ff e4 	ld.w	r8,r7[-28]
80003722:	58 08       	cp.w	r8,0
80003724:	c0 51       	brne	8000372e <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80003726:	f0 1f 00 36 	mcall	800037fc <xQueueGenericReceive+0x18c>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000372a:	30 08       	mov	r8,0
8000372c:	c5 e8       	rjmp	800037e8 <xQueueGenericReceive+0x178>
				}
				else if( xEntryTimeSet == pdFALSE )
8000372e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003732:	58 08       	cp.w	r8,0
80003734:	c0 91       	brne	80003746 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80003736:	ee c8 00 10 	sub	r8,r7,16
8000373a:	10 9c       	mov	r12,r8
8000373c:	f0 1f 00 31 	mcall	80003800 <xQueueGenericReceive+0x190>
					xEntryTimeSet = pdTRUE;
80003740:	30 18       	mov	r8,1
80003742:	ef 48 ff f8 	st.w	r7[-8],r8
				}
			}
		}
		taskEXIT_CRITICAL();
80003746:	f0 1f 00 2e 	mcall	800037fc <xQueueGenericReceive+0x18c>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000374a:	f0 1f 00 2f 	mcall	80003804 <xQueueGenericReceive+0x194>
		prvLockQueue( pxQueue );
8000374e:	f0 1f 00 29 	mcall	800037f0 <xQueueGenericReceive+0x180>
80003752:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003756:	71 18       	ld.w	r8,r8[0x44]
80003758:	5b f8       	cp.w	r8,-1
8000375a:	c0 61       	brne	80003766 <xQueueGenericReceive+0xf6>
8000375c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003760:	30 09       	mov	r9,0
80003762:	f1 49 00 44 	st.w	r8[68],r9
80003766:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000376a:	71 28       	ld.w	r8,r8[0x48]
8000376c:	5b f8       	cp.w	r8,-1
8000376e:	c0 61       	brne	8000377a <xQueueGenericReceive+0x10a>
80003770:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003774:	30 09       	mov	r9,0
80003776:	f1 49 00 48 	st.w	r8[72],r9
8000377a:	f0 1f 00 21 	mcall	800037fc <xQueueGenericReceive+0x18c>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000377e:	ee c9 00 1c 	sub	r9,r7,28
80003782:	ee c8 00 10 	sub	r8,r7,16
80003786:	12 9b       	mov	r11,r9
80003788:	10 9c       	mov	r12,r8
8000378a:	f0 1f 00 20 	mcall	80003808 <xQueueGenericReceive+0x198>
8000378e:	18 98       	mov	r8,r12
80003790:	58 08       	cp.w	r8,0
80003792:	c2 41       	brne	800037da <xQueueGenericReceive+0x16a>
		{
			if( prvIsQueueEmpty( pxQueue ) )
80003794:	ee fc ff ec 	ld.w	r12,r7[-20]
80003798:	f0 1f 00 1d 	mcall	8000380c <xQueueGenericReceive+0x19c>
8000379c:	18 98       	mov	r8,r12
8000379e:	58 08       	cp.w	r8,0
800037a0:	c1 60       	breq	800037cc <xQueueGenericReceive+0x15c>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800037a2:	ee f9 ff e4 	ld.w	r9,r7[-28]
800037a6:	ee f8 ff ec 	ld.w	r8,r7[-20]
800037aa:	2d c8       	sub	r8,-36
800037ac:	12 9b       	mov	r11,r9
800037ae:	10 9c       	mov	r12,r8
800037b0:	f0 1f 00 18 	mcall	80003810 <xQueueGenericReceive+0x1a0>
				prvUnlockQueue( pxQueue );
800037b4:	ee fc ff ec 	ld.w	r12,r7[-20]
800037b8:	f0 1f 00 17 	mcall	80003814 <xQueueGenericReceive+0x1a4>
				if( !xTaskResumeAll() )
800037bc:	f0 1f 00 17 	mcall	80003818 <xQueueGenericReceive+0x1a8>
800037c0:	18 98       	mov	r8,r12
800037c2:	58 08       	cp.w	r8,0
800037c4:	fe 91 ff 66 	brne	80003690 <xQueueGenericReceive+0x20>
				{
					portYIELD_WITHIN_API();
800037c8:	d7 33       	scall
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800037ca:	c6 4b       	rjmp	80003692 <xQueueGenericReceive+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800037cc:	ee fc ff ec 	ld.w	r12,r7[-20]
800037d0:	f0 1f 00 11 	mcall	80003814 <xQueueGenericReceive+0x1a4>
				( void ) xTaskResumeAll();
800037d4:	f0 1f 00 11 	mcall	80003818 <xQueueGenericReceive+0x1a8>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800037d8:	c5 db       	rjmp	80003692 <xQueueGenericReceive+0x22>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800037da:	ee fc ff ec 	ld.w	r12,r7[-20]
800037de:	f0 1f 00 0e 	mcall	80003814 <xQueueGenericReceive+0x1a4>
			( void ) xTaskResumeAll();
800037e2:	f0 1f 00 0e 	mcall	80003818 <xQueueGenericReceive+0x1a8>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
800037e6:	30 08       	mov	r8,0
		}
	}
}
800037e8:	10 9c       	mov	r12,r8
800037ea:	2f 8d       	sub	sp,-32
800037ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800037f0:	80 00       	ld.sh	r0,r0[0x0]
800037f2:	30 ac       	mov	r12,10
800037f4:	80 00       	ld.sh	r0,r0[0x0]
800037f6:	38 fc       	mov	r12,-113
800037f8:	80 00       	ld.sh	r0,r0[0x0]
800037fa:	40 b4       	lddsp	r4,sp[0x2c]
800037fc:	80 00       	ld.sh	r0,r0[0x0]
800037fe:	30 c8       	mov	r8,12
80003800:	80 00       	ld.sh	r0,r0[0x0]
80003802:	41 84       	lddsp	r4,sp[0x60]
80003804:	80 00       	ld.sh	r0,r0[0x0]
80003806:	3c e0       	mov	r0,-50
80003808:	80 00       	ld.sh	r0,r0[0x0]
8000380a:	41 b4       	lddsp	r4,sp[0x6c]
8000380c:	80 00       	ld.sh	r0,r0[0x0]
8000380e:	3a 38       	mov	r8,-93
80003810:	80 00       	ld.sh	r0,r0[0x0]
80003812:	40 34       	lddsp	r4,sp[0xc]
80003814:	80 00       	ld.sh	r0,r0[0x0]
80003816:	39 68       	mov	r8,-106
80003818:	80 00       	ld.sh	r0,r0[0x0]
8000381a:	3c fc       	mov	r12,-49

8000381c <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
8000381c:	eb cd 40 80 	pushm	r7,lr
80003820:	1a 97       	mov	r7,sp
80003822:	20 3d       	sub	sp,12
80003824:	ef 4c ff fc 	st.w	r7[-4],r12
80003828:	ef 4b ff f8 	st.w	r7[-8],r11
8000382c:	ef 4a ff f4 	st.w	r7[-12],r10
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80003830:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003834:	71 08       	ld.w	r8,r8[0x40]
80003836:	58 08       	cp.w	r8,0
80003838:	c5 40       	breq	800038e0 <prvCopyDataToQueue+0xc4>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000383a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000383e:	58 08       	cp.w	r8,0
80003840:	c2 61       	brne	8000388c <prvCopyDataToQueue+0x70>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80003842:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003846:	71 09       	ld.w	r9,r8[0x40]
80003848:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000384c:	70 28       	ld.w	r8,r8[0x8]
8000384e:	12 9a       	mov	r10,r9
80003850:	ee fb ff f8 	ld.w	r11,r7[-8]
80003854:	10 9c       	mov	r12,r8
80003856:	f0 1f 00 29 	mcall	800038f8 <prvCopyDataToQueue+0xdc>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000385a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000385e:	70 29       	ld.w	r9,r8[0x8]
80003860:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003864:	71 08       	ld.w	r8,r8[0x40]
80003866:	10 09       	add	r9,r8
80003868:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000386c:	91 29       	st.w	r8[0x8],r9
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000386e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003872:	70 29       	ld.w	r9,r8[0x8]
80003874:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003878:	70 18       	ld.w	r8,r8[0x4]
8000387a:	10 39       	cp.w	r9,r8
8000387c:	c3 23       	brcs	800038e0 <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000387e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003882:	70 09       	ld.w	r9,r8[0x0]
80003884:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003888:	91 29       	st.w	r8[0x8],r9
8000388a:	c2 b8       	rjmp	800038e0 <prvCopyDataToQueue+0xc4>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000388c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003890:	71 09       	ld.w	r9,r8[0x40]
80003892:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003896:	70 38       	ld.w	r8,r8[0xc]
80003898:	12 9a       	mov	r10,r9
8000389a:	ee fb ff f8 	ld.w	r11,r7[-8]
8000389e:	10 9c       	mov	r12,r8
800038a0:	f0 1f 00 16 	mcall	800038f8 <prvCopyDataToQueue+0xdc>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800038a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038a8:	70 39       	ld.w	r9,r8[0xc]
800038aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038ae:	71 08       	ld.w	r8,r8[0x40]
800038b0:	5c 38       	neg	r8
800038b2:	10 09       	add	r9,r8
800038b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038b8:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800038ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038be:	70 39       	ld.w	r9,r8[0xc]
800038c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038c4:	70 08       	ld.w	r8,r8[0x0]
800038c6:	10 39       	cp.w	r9,r8
800038c8:	c0 c2       	brcc	800038e0 <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800038ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038ce:	70 19       	ld.w	r9,r8[0x4]
800038d0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038d4:	71 08       	ld.w	r8,r8[0x40]
800038d6:	5c 38       	neg	r8
800038d8:	10 09       	add	r9,r8
800038da:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038de:	91 39       	st.w	r8[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800038e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038e4:	70 e8       	ld.w	r8,r8[0x38]
800038e6:	f0 c9 ff ff 	sub	r9,r8,-1
800038ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038ee:	91 e9       	st.w	r8[0x38],r9
}
800038f0:	2f dd       	sub	sp,-12
800038f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800038f6:	00 00       	add	r0,r0
800038f8:	80 00       	ld.sh	r0,r0[0x0]
800038fa:	4a 38       	lddpc	r8,80003984 <prvUnlockQueue+0x1c>

800038fc <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800038fc:	eb cd 40 80 	pushm	r7,lr
80003900:	1a 97       	mov	r7,sp
80003902:	20 2d       	sub	sp,8
80003904:	ef 4c ff fc 	st.w	r7[-4],r12
80003908:	ef 4b ff f8 	st.w	r7[-8],r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
8000390c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003910:	70 08       	ld.w	r8,r8[0x0]
80003912:	58 08       	cp.w	r8,0
80003914:	c2 50       	breq	8000395e <prvCopyDataFromQueue+0x62>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80003916:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000391a:	70 39       	ld.w	r9,r8[0xc]
8000391c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003920:	71 08       	ld.w	r8,r8[0x40]
80003922:	10 09       	add	r9,r8
80003924:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003928:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
8000392a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000392e:	70 39       	ld.w	r9,r8[0xc]
80003930:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003934:	70 18       	ld.w	r8,r8[0x4]
80003936:	10 39       	cp.w	r9,r8
80003938:	c0 73       	brcs	80003946 <prvCopyDataFromQueue+0x4a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000393a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000393e:	70 09       	ld.w	r9,r8[0x0]
80003940:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003944:	91 39       	st.w	r8[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80003946:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000394a:	71 09       	ld.w	r9,r8[0x40]
8000394c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003950:	70 38       	ld.w	r8,r8[0xc]
80003952:	12 9a       	mov	r10,r9
80003954:	10 9b       	mov	r11,r8
80003956:	ee fc ff f8 	ld.w	r12,r7[-8]
8000395a:	f0 1f 00 03 	mcall	80003964 <prvCopyDataFromQueue+0x68>
	}
}
8000395e:	2f ed       	sub	sp,-8
80003960:	e3 cd 80 80 	ldm	sp++,r7,pc
80003964:	80 00       	ld.sh	r0,r0[0x0]
80003966:	4a 38       	lddpc	r8,800039f0 <prvUnlockQueue+0x88>

80003968 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80003968:	eb cd 40 80 	pushm	r7,lr
8000396c:	1a 97       	mov	r7,sp
8000396e:	20 1d       	sub	sp,4
80003970:	ef 4c ff fc 	st.w	r7[-4],r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80003974:	f0 1f 00 2d 	mcall	80003a28 <prvUnlockQueue+0xc0>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80003978:	c1 a8       	rjmp	800039ac <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000397a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000397e:	70 98       	ld.w	r8,r8[0x24]
80003980:	58 08       	cp.w	r8,0
80003982:	c1 c0       	breq	800039ba <prvUnlockQueue+0x52>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80003984:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003988:	2d c8       	sub	r8,-36
8000398a:	10 9c       	mov	r12,r8
8000398c:	f0 1f 00 28 	mcall	80003a2c <prvUnlockQueue+0xc4>
80003990:	18 98       	mov	r8,r12
80003992:	58 08       	cp.w	r8,0
80003994:	c0 30       	breq	8000399a <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80003996:	f0 1f 00 27 	mcall	80003a30 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xTxLock );
8000399a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000399e:	71 28       	ld.w	r8,r8[0x48]
800039a0:	f0 c9 00 01 	sub	r9,r8,1
800039a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039a8:	f1 49 00 48 	st.w	r8[72],r9
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800039ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039b0:	71 28       	ld.w	r8,r8[0x48]
800039b2:	58 08       	cp.w	r8,0
800039b4:	fe 99 ff e3 	brgt	8000397a <prvUnlockQueue+0x12>
800039b8:	c0 28       	rjmp	800039bc <prvUnlockQueue+0x54>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
800039ba:	d7 03       	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800039bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039c0:	3f f9       	mov	r9,-1
800039c2:	f1 49 00 48 	st.w	r8[72],r9
	}
	taskEXIT_CRITICAL();
800039c6:	f0 1f 00 1c 	mcall	80003a34 <prvUnlockQueue+0xcc>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800039ca:	f0 1f 00 18 	mcall	80003a28 <prvUnlockQueue+0xc0>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800039ce:	c1 a8       	rjmp	80003a02 <prvUnlockQueue+0x9a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800039d0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039d4:	70 48       	ld.w	r8,r8[0x10]
800039d6:	58 08       	cp.w	r8,0
800039d8:	c1 c0       	breq	80003a10 <prvUnlockQueue+0xa8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800039da:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039de:	2f 08       	sub	r8,-16
800039e0:	10 9c       	mov	r12,r8
800039e2:	f0 1f 00 13 	mcall	80003a2c <prvUnlockQueue+0xc4>
800039e6:	18 98       	mov	r8,r12
800039e8:	58 08       	cp.w	r8,0
800039ea:	c0 30       	breq	800039f0 <prvUnlockQueue+0x88>
				{
					vTaskMissedYield();
800039ec:	f0 1f 00 11 	mcall	80003a30 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xRxLock );
800039f0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039f4:	71 18       	ld.w	r8,r8[0x44]
800039f6:	f0 c9 00 01 	sub	r9,r8,1
800039fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039fe:	f1 49 00 44 	st.w	r8[68],r9
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80003a02:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a06:	71 18       	ld.w	r8,r8[0x44]
80003a08:	58 08       	cp.w	r8,0
80003a0a:	fe 99 ff e3 	brgt	800039d0 <prvUnlockQueue+0x68>
80003a0e:	c0 28       	rjmp	80003a12 <prvUnlockQueue+0xaa>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
80003a10:	d7 03       	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80003a12:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a16:	3f f9       	mov	r9,-1
80003a18:	f1 49 00 44 	st.w	r8[68],r9
	}
	taskEXIT_CRITICAL();
80003a1c:	f0 1f 00 06 	mcall	80003a34 <prvUnlockQueue+0xcc>
}
80003a20:	2f fd       	sub	sp,-4
80003a22:	e3 cd 80 80 	ldm	sp++,r7,pc
80003a26:	00 00       	add	r0,r0
80003a28:	80 00       	ld.sh	r0,r0[0x0]
80003a2a:	30 ac       	mov	r12,10
80003a2c:	80 00       	ld.sh	r0,r0[0x0]
80003a2e:	40 b4       	lddsp	r4,sp[0x2c]
80003a30:	80 00       	ld.sh	r0,r0[0x0]
80003a32:	42 6c       	lddsp	r12,sp[0x98]
80003a34:	80 00       	ld.sh	r0,r0[0x0]
80003a36:	30 c8       	mov	r8,12

80003a38 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
80003a38:	eb cd 40 80 	pushm	r7,lr
80003a3c:	1a 97       	mov	r7,sp
80003a3e:	20 2d       	sub	sp,8
80003a40:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80003a44:	f0 1f 00 09 	mcall	80003a68 <prvIsQueueEmpty+0x30>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80003a48:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003a4c:	70 e8       	ld.w	r8,r8[0x38]
80003a4e:	58 08       	cp.w	r8,0
80003a50:	5f 08       	sreq	r8
80003a52:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80003a56:	f0 1f 00 06 	mcall	80003a6c <prvIsQueueEmpty+0x34>

	return xReturn;
80003a5a:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80003a5e:	10 9c       	mov	r12,r8
80003a60:	2f ed       	sub	sp,-8
80003a62:	e3 cd 80 80 	ldm	sp++,r7,pc
80003a66:	00 00       	add	r0,r0
80003a68:	80 00       	ld.sh	r0,r0[0x0]
80003a6a:	30 ac       	mov	r12,10
80003a6c:	80 00       	ld.sh	r0,r0[0x0]
80003a6e:	30 c8       	mov	r8,12

80003a70 <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
80003a70:	eb cd 40 80 	pushm	r7,lr
80003a74:	1a 97       	mov	r7,sp
80003a76:	20 2d       	sub	sp,8
80003a78:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80003a7c:	f0 1f 00 0a 	mcall	80003aa4 <prvIsQueueFull+0x34>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80003a80:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003a84:	70 e9       	ld.w	r9,r8[0x38]
80003a86:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003a8a:	70 f8       	ld.w	r8,r8[0x3c]
80003a8c:	10 39       	cp.w	r9,r8
80003a8e:	5f 08       	sreq	r8
80003a90:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80003a94:	f0 1f 00 05 	mcall	80003aa8 <prvIsQueueFull+0x38>

	return xReturn;
80003a98:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80003a9c:	10 9c       	mov	r12,r8
80003a9e:	2f ed       	sub	sp,-8
80003aa0:	e3 cd 80 80 	ldm	sp++,r7,pc
80003aa4:	80 00       	ld.sh	r0,r0[0x0]
80003aa6:	30 ac       	mov	r12,10
80003aa8:	80 00       	ld.sh	r0,r0[0x0]
80003aaa:	30 c8       	mov	r8,12
80003aac:	49 44       	lddpc	r4,80003afc <xTaskGenericCreate+0x48>
80003aae:	4c 45       	lddpc	r5,80003bbc <xTaskGenericCreate+0x108>
80003ab0:	00 00       	add	r0,r0
	...

80003ab4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80003ab4:	eb cd 40 c0 	pushm	r6-r7,lr
80003ab8:	1a 97       	mov	r7,sp
80003aba:	20 8d       	sub	sp,32
80003abc:	ee c6 ff f4 	sub	r6,r7,-12
80003ac0:	ef 4c ff f0 	st.w	r7[-16],r12
80003ac4:	ef 4b ff ec 	st.w	r7[-20],r11
80003ac8:	ef 49 ff e4 	st.w	r7[-28],r9
80003acc:	ef 48 ff e0 	st.w	r7[-32],r8
80003ad0:	14 98       	mov	r8,r10
80003ad2:	ef 58 ff e8 	st.h	r7[-24],r8
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
80003ad6:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80003ada:	6c 1b       	ld.w	r11,r6[0x4]
80003adc:	10 9c       	mov	r12,r8
80003ade:	f0 1f 00 5a 	mcall	80003c44 <xTaskGenericCreate+0x190>
80003ae2:	18 98       	mov	r8,r12
80003ae4:	ef 48 ff f8 	st.w	r7[-8],r8

	if( pxNewTCB != NULL )
80003ae8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003aec:	58 08       	cp.w	r8,0
80003aee:	e0 80 00 92 	breq	80003c12 <xTaskGenericCreate+0x15e>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
80003af2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003af6:	70 c9       	ld.w	r9,r8[0x30]
80003af8:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80003afc:	20 18       	sub	r8,1
80003afe:	a3 68       	lsl	r8,0x2
80003b00:	f2 08 00 08 	add	r8,r9,r8
80003b04:	ef 48 ff fc 	st.w	r7[-4],r8
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80003b08:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b0c:	e0 18 ff fc 	andl	r8,0xfffc
80003b10:	ef 48 ff fc 	st.w	r7[-4],r8
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
80003b14:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80003b18:	6c 29       	ld.w	r9,r6[0x8]
80003b1a:	ee fa ff e0 	ld.w	r10,r7[-32]
80003b1e:	ee fb ff ec 	ld.w	r11,r7[-20]
80003b22:	ee fc ff f8 	ld.w	r12,r7[-8]
80003b26:	f0 1f 00 49 	mcall	80003c48 <xTaskGenericCreate+0x194>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80003b2a:	ee fa ff e4 	ld.w	r10,r7[-28]
80003b2e:	ee fb ff f0 	ld.w	r11,r7[-16]
80003b32:	ee fc ff fc 	ld.w	r12,r7[-4]
80003b36:	f0 1f 00 46 	mcall	80003c4c <xTaskGenericCreate+0x198>
80003b3a:	18 98       	mov	r8,r12
80003b3c:	10 99       	mov	r9,r8
80003b3e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003b42:	91 09       	st.w	r8[0x0],r9
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
80003b44:	6c 08       	ld.w	r8,r6[0x0]
80003b46:	58 08       	cp.w	r8,0
80003b48:	c0 50       	breq	80003b52 <xTaskGenericCreate+0x9e>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80003b4a:	6c 08       	ld.w	r8,r6[0x0]
80003b4c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003b50:	91 09       	st.w	r8[0x0],r9
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80003b52:	f0 1f 00 40 	mcall	80003c50 <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
80003b56:	4c 08       	lddpc	r8,80003c54 <xTaskGenericCreate+0x1a0>
80003b58:	70 08       	ld.w	r8,r8[0x0]
80003b5a:	f0 c9 ff ff 	sub	r9,r8,-1
80003b5e:	4b e8       	lddpc	r8,80003c54 <xTaskGenericCreate+0x1a0>
80003b60:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80003b62:	4b e8       	lddpc	r8,80003c58 <xTaskGenericCreate+0x1a4>
80003b64:	70 08       	ld.w	r8,r8[0x0]
80003b66:	58 08       	cp.w	r8,0
80003b68:	c0 c1       	brne	80003b80 <xTaskGenericCreate+0xcc>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80003b6a:	4b c8       	lddpc	r8,80003c58 <xTaskGenericCreate+0x1a4>
80003b6c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003b70:	91 09       	st.w	r8[0x0],r9

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80003b72:	4b 98       	lddpc	r8,80003c54 <xTaskGenericCreate+0x1a0>
80003b74:	70 08       	ld.w	r8,r8[0x0]
80003b76:	58 18       	cp.w	r8,1
80003b78:	c1 41       	brne	80003ba0 <xTaskGenericCreate+0xec>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
80003b7a:	f0 1f 00 39 	mcall	80003c5c <xTaskGenericCreate+0x1a8>
80003b7e:	c1 18       	rjmp	80003ba0 <xTaskGenericCreate+0xec>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80003b80:	4b 88       	lddpc	r8,80003c60 <xTaskGenericCreate+0x1ac>
80003b82:	70 08       	ld.w	r8,r8[0x0]
80003b84:	58 08       	cp.w	r8,0
80003b86:	c0 d1       	brne	80003ba0 <xTaskGenericCreate+0xec>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80003b88:	4b 48       	lddpc	r8,80003c58 <xTaskGenericCreate+0x1a4>
80003b8a:	70 08       	ld.w	r8,r8[0x0]
80003b8c:	70 b9       	ld.w	r9,r8[0x2c]
80003b8e:	ee f8 ff e0 	ld.w	r8,r7[-32]
80003b92:	10 39       	cp.w	r9,r8
80003b94:	e0 8b 00 06 	brhi	80003ba0 <xTaskGenericCreate+0xec>
					{
						pxCurrentTCB = pxNewTCB;
80003b98:	4b 08       	lddpc	r8,80003c58 <xTaskGenericCreate+0x1a4>
80003b9a:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003b9e:	91 09       	st.w	r8[0x0],r9
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80003ba0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003ba4:	70 b9       	ld.w	r9,r8[0x2c]
80003ba6:	4b 08       	lddpc	r8,80003c64 <xTaskGenericCreate+0x1b0>
80003ba8:	70 08       	ld.w	r8,r8[0x0]
80003baa:	10 39       	cp.w	r9,r8
80003bac:	e0 88 00 07 	brls	80003bba <xTaskGenericCreate+0x106>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80003bb0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003bb4:	70 b9       	ld.w	r9,r8[0x2c]
80003bb6:	4a c8       	lddpc	r8,80003c64 <xTaskGenericCreate+0x1b0>
80003bb8:	91 09       	st.w	r8[0x0],r9
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80003bba:	4a c8       	lddpc	r8,80003c68 <xTaskGenericCreate+0x1b4>
80003bbc:	70 08       	ld.w	r8,r8[0x0]
80003bbe:	f0 c9 ff ff 	sub	r9,r8,-1
80003bc2:	4a a8       	lddpc	r8,80003c68 <xTaskGenericCreate+0x1b4>
80003bc4:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80003bc6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003bca:	70 b9       	ld.w	r9,r8[0x2c]
80003bcc:	4a 88       	lddpc	r8,80003c6c <xTaskGenericCreate+0x1b8>
80003bce:	70 08       	ld.w	r8,r8[0x0]
80003bd0:	10 39       	cp.w	r9,r8
80003bd2:	e0 88 00 07 	brls	80003be0 <xTaskGenericCreate+0x12c>
80003bd6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003bda:	70 b9       	ld.w	r9,r8[0x2c]
80003bdc:	4a 48       	lddpc	r8,80003c6c <xTaskGenericCreate+0x1b8>
80003bde:	91 09       	st.w	r8[0x0],r9
80003be0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003be4:	f0 ca ff fc 	sub	r10,r8,-4
80003be8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003bec:	70 b9       	ld.w	r9,r8[0x2c]
80003bee:	12 98       	mov	r8,r9
80003bf0:	a3 68       	lsl	r8,0x2
80003bf2:	12 08       	add	r8,r9
80003bf4:	a3 68       	lsl	r8,0x2
80003bf6:	10 99       	mov	r9,r8
80003bf8:	49 e8       	lddpc	r8,80003c70 <xTaskGenericCreate+0x1bc>
80003bfa:	f2 08 00 08 	add	r8,r9,r8
80003bfe:	14 9b       	mov	r11,r10
80003c00:	10 9c       	mov	r12,r8
80003c02:	f0 1f 00 1d 	mcall	80003c74 <xTaskGenericCreate+0x1c0>

			xReturn = pdPASS;
80003c06:	30 18       	mov	r8,1
80003c08:	ef 48 ff f4 	st.w	r7[-12],r8
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80003c0c:	f0 1f 00 1b 	mcall	80003c78 <xTaskGenericCreate+0x1c4>
80003c10:	c0 48       	rjmp	80003c18 <xTaskGenericCreate+0x164>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
80003c12:	3f f8       	mov	r8,-1
80003c14:	ef 48 ff f4 	st.w	r7[-12],r8
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
80003c18:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003c1c:	58 18       	cp.w	r8,1
80003c1e:	c0 d1       	brne	80003c38 <xTaskGenericCreate+0x184>
	{
		if( xSchedulerRunning != pdFALSE )
80003c20:	49 08       	lddpc	r8,80003c60 <xTaskGenericCreate+0x1ac>
80003c22:	70 08       	ld.w	r8,r8[0x0]
80003c24:	58 08       	cp.w	r8,0
80003c26:	c0 90       	breq	80003c38 <xTaskGenericCreate+0x184>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80003c28:	48 c8       	lddpc	r8,80003c58 <xTaskGenericCreate+0x1a4>
80003c2a:	70 08       	ld.w	r8,r8[0x0]
80003c2c:	70 b9       	ld.w	r9,r8[0x2c]
80003c2e:	ee f8 ff e0 	ld.w	r8,r7[-32]
80003c32:	10 39       	cp.w	r9,r8
80003c34:	c0 22       	brcc	80003c38 <xTaskGenericCreate+0x184>
			{
				portYIELD_WITHIN_API();
80003c36:	d7 33       	scall
			}
		}
	}

	return xReturn;
80003c38:	ee f8 ff f4 	ld.w	r8,r7[-12]
}
80003c3c:	10 9c       	mov	r12,r8
80003c3e:	2f 8d       	sub	sp,-32
80003c40:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003c44:	80 00       	ld.sh	r0,r0[0x0]
80003c46:	44 f4       	lddsp	r4,sp[0x13c]
80003c48:	80 00       	ld.sh	r0,r0[0x0]
80003c4a:	42 ac       	lddsp	r12,sp[0xa8]
80003c4c:	80 00       	ld.sh	r0,r0[0x0]
80003c4e:	30 f4       	mov	r4,15
80003c50:	80 00       	ld.sh	r0,r0[0x0]
80003c52:	30 ac       	mov	r12,10
80003c54:	00 00       	add	r0,r0
80003c56:	07 30       	ld.ub	r0,r3++
80003c58:	00 00       	add	r0,r0
80003c5a:	06 1c       	sub	r12,r3
80003c5c:	80 00       	ld.sh	r0,r0[0x0]
80003c5e:	43 48       	lddsp	r8,sp[0xd0]
80003c60:	00 00       	add	r0,r0
80003c62:	07 40       	ld.w	r0,--r3
80003c64:	00 00       	add	r0,r0
80003c66:	07 38       	ld.ub	r8,r3++
80003c68:	00 00       	add	r0,r0
80003c6a:	07 54       	ld.sh	r4,--r3
80003c6c:	00 00       	add	r0,r0
80003c6e:	07 3c       	ld.ub	r12,r3++
80003c70:	00 00       	add	r0,r0
80003c72:	06 20       	rsub	r0,r3
80003c74:	80 00       	ld.sh	r0,r0[0x0]
80003c76:	2d 82       	sub	r2,-40
80003c78:	80 00       	ld.sh	r0,r0[0x0]
80003c7a:	30 c8       	mov	r8,12

80003c7c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80003c7c:	eb cd 40 80 	pushm	r7,lr
80003c80:	1a 97       	mov	r7,sp
80003c82:	20 1d       	sub	sp,4
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80003c84:	49 1b       	lddpc	r11,80003cc8 <vTaskStartScheduler+0x4c>
80003c86:	30 08       	mov	r8,0
80003c88:	1a d8       	st.w	--sp,r8
80003c8a:	30 08       	mov	r8,0
80003c8c:	1a d8       	st.w	--sp,r8
80003c8e:	30 08       	mov	r8,0
80003c90:	1a d8       	st.w	--sp,r8
80003c92:	30 08       	mov	r8,0
80003c94:	30 09       	mov	r9,0
80003c96:	e0 6a 01 00 	mov	r10,256
80003c9a:	48 dc       	lddpc	r12,80003ccc <vTaskStartScheduler+0x50>
80003c9c:	f0 1f 00 0d 	mcall	80003cd0 <vTaskStartScheduler+0x54>
80003ca0:	2f dd       	sub	sp,-12
80003ca2:	18 98       	mov	r8,r12
80003ca4:	ef 48 ff fc 	st.w	r7[-4],r8
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80003ca8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003cac:	58 18       	cp.w	r8,1
80003cae:	c0 a1       	brne	80003cc2 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80003cb0:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80003cb2:	48 98       	lddpc	r8,80003cd4 <vTaskStartScheduler+0x58>
80003cb4:	30 19       	mov	r9,1
80003cb6:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80003cb8:	48 88       	lddpc	r8,80003cd8 <vTaskStartScheduler+0x5c>
80003cba:	30 09       	mov	r9,0
80003cbc:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80003cbe:	f0 1f 00 08 	mcall	80003cdc <vTaskStartScheduler+0x60>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
80003cc2:	2f fd       	sub	sp,-4
80003cc4:	e3 cd 80 80 	ldm	sp++,r7,pc
80003cc8:	80 00       	ld.sh	r0,r0[0x0]
80003cca:	3a ac       	mov	r12,-86
80003ccc:	80 00       	ld.sh	r0,r0[0x0]
80003cce:	42 80       	lddsp	r0,sp[0xa0]
80003cd0:	80 00       	ld.sh	r0,r0[0x0]
80003cd2:	3a b4       	mov	r4,-85
80003cd4:	00 00       	add	r0,r0
80003cd6:	07 40       	ld.w	r0,--r3
80003cd8:	00 00       	add	r0,r0
80003cda:	07 34       	ld.ub	r4,r3++
80003cdc:	80 00       	ld.sh	r0,r0[0x0]
80003cde:	32 9c       	mov	r12,41

80003ce0 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
80003ce0:	eb cd 40 80 	pushm	r7,lr
80003ce4:	1a 97       	mov	r7,sp
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80003ce6:	48 58       	lddpc	r8,80003cf8 <vTaskSuspendAll+0x18>
80003ce8:	70 08       	ld.w	r8,r8[0x0]
80003cea:	f0 c9 ff ff 	sub	r9,r8,-1
80003cee:	48 38       	lddpc	r8,80003cf8 <vTaskSuspendAll+0x18>
80003cf0:	91 09       	st.w	r8[0x0],r9
}
80003cf2:	e3 cd 80 80 	ldm	sp++,r7,pc
80003cf6:	00 00       	add	r0,r0
80003cf8:	00 00       	add	r0,r0
80003cfa:	07 44       	ld.w	r4,--r3

80003cfc <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80003cfc:	eb cd 40 c0 	pushm	r6-r7,lr
80003d00:	1a 97       	mov	r7,sp
80003d02:	20 2d       	sub	sp,8
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
80003d04:	30 08       	mov	r8,0
80003d06:	ef 48 ff f8 	st.w	r7[-8],r8
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80003d0a:	f0 1f 00 3a 	mcall	80003df0 <xTaskResumeAll+0xf4>
	{
		--uxSchedulerSuspended;
80003d0e:	4b a8       	lddpc	r8,80003df4 <xTaskResumeAll+0xf8>
80003d10:	70 08       	ld.w	r8,r8[0x0]
80003d12:	f0 c9 00 01 	sub	r9,r8,1
80003d16:	4b 88       	lddpc	r8,80003df4 <xTaskResumeAll+0xf8>
80003d18:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80003d1a:	4b 78       	lddpc	r8,80003df4 <xTaskResumeAll+0xf8>
80003d1c:	70 08       	ld.w	r8,r8[0x0]
80003d1e:	58 08       	cp.w	r8,0
80003d20:	c5 f1       	brne	80003dde <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80003d22:	4b 68       	lddpc	r8,80003df8 <xTaskResumeAll+0xfc>
80003d24:	70 08       	ld.w	r8,r8[0x0]
80003d26:	58 08       	cp.w	r8,0
80003d28:	c5 b0       	breq	80003dde <xTaskResumeAll+0xe2>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
80003d2a:	30 08       	mov	r8,0
80003d2c:	ef 48 ff fc 	st.w	r7[-4],r8

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80003d30:	c3 08       	rjmp	80003d90 <xTaskResumeAll+0x94>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80003d32:	4b 38       	lddpc	r8,80003dfc <xTaskResumeAll+0x100>
80003d34:	70 38       	ld.w	r8,r8[0xc]
80003d36:	70 38       	ld.w	r8,r8[0xc]
80003d38:	10 96       	mov	r6,r8
					vListRemove( &( pxTCB->xEventListItem ) );
80003d3a:	ec c8 ff e8 	sub	r8,r6,-24
80003d3e:	10 9c       	mov	r12,r8
80003d40:	f0 1f 00 30 	mcall	80003e00 <xTaskResumeAll+0x104>
					vListRemove( &( pxTCB->xGenericListItem ) );
80003d44:	ec c8 ff fc 	sub	r8,r6,-4
80003d48:	10 9c       	mov	r12,r8
80003d4a:	f0 1f 00 2e 	mcall	80003e00 <xTaskResumeAll+0x104>
					prvAddTaskToReadyQueue( pxTCB );
80003d4e:	6c b9       	ld.w	r9,r6[0x2c]
80003d50:	4a d8       	lddpc	r8,80003e04 <xTaskResumeAll+0x108>
80003d52:	70 08       	ld.w	r8,r8[0x0]
80003d54:	10 39       	cp.w	r9,r8
80003d56:	e0 88 00 05 	brls	80003d60 <xTaskResumeAll+0x64>
80003d5a:	6c b9       	ld.w	r9,r6[0x2c]
80003d5c:	4a a8       	lddpc	r8,80003e04 <xTaskResumeAll+0x108>
80003d5e:	91 09       	st.w	r8[0x0],r9
80003d60:	ec ca ff fc 	sub	r10,r6,-4
80003d64:	6c b9       	ld.w	r9,r6[0x2c]
80003d66:	12 98       	mov	r8,r9
80003d68:	a3 68       	lsl	r8,0x2
80003d6a:	12 08       	add	r8,r9
80003d6c:	a3 68       	lsl	r8,0x2
80003d6e:	10 99       	mov	r9,r8
80003d70:	4a 68       	lddpc	r8,80003e08 <xTaskResumeAll+0x10c>
80003d72:	f2 08 00 08 	add	r8,r9,r8
80003d76:	14 9b       	mov	r11,r10
80003d78:	10 9c       	mov	r12,r8
80003d7a:	f0 1f 00 25 	mcall	80003e0c <xTaskResumeAll+0x110>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80003d7e:	6c b9       	ld.w	r9,r6[0x2c]
80003d80:	4a 48       	lddpc	r8,80003e10 <xTaskResumeAll+0x114>
80003d82:	70 08       	ld.w	r8,r8[0x0]
80003d84:	70 b8       	ld.w	r8,r8[0x2c]
80003d86:	10 39       	cp.w	r9,r8
80003d88:	c0 43       	brcs	80003d90 <xTaskResumeAll+0x94>
					{
						xYieldRequired = pdTRUE;
80003d8a:	30 18       	mov	r8,1
80003d8c:	ef 48 ff fc 	st.w	r7[-4],r8
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80003d90:	49 b8       	lddpc	r8,80003dfc <xTaskResumeAll+0x100>
80003d92:	70 08       	ld.w	r8,r8[0x0]
80003d94:	58 08       	cp.w	r8,0
80003d96:	cc e1       	brne	80003d32 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80003d98:	49 f8       	lddpc	r8,80003e14 <xTaskResumeAll+0x118>
80003d9a:	70 08       	ld.w	r8,r8[0x0]
80003d9c:	58 08       	cp.w	r8,0
80003d9e:	c1 10       	breq	80003dc0 <xTaskResumeAll+0xc4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80003da0:	c0 98       	rjmp	80003db2 <xTaskResumeAll+0xb6>
					{
						vTaskIncrementTick();
80003da2:	f0 1f 00 1e 	mcall	80003e18 <xTaskResumeAll+0x11c>
						--uxMissedTicks;
80003da6:	49 c8       	lddpc	r8,80003e14 <xTaskResumeAll+0x118>
80003da8:	70 08       	ld.w	r8,r8[0x0]
80003daa:	f0 c9 00 01 	sub	r9,r8,1
80003dae:	49 a8       	lddpc	r8,80003e14 <xTaskResumeAll+0x118>
80003db0:	91 09       	st.w	r8[0x0],r9
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80003db2:	49 98       	lddpc	r8,80003e14 <xTaskResumeAll+0x118>
80003db4:	70 08       	ld.w	r8,r8[0x0]
80003db6:	58 08       	cp.w	r8,0
80003db8:	cf 51       	brne	80003da2 <xTaskResumeAll+0xa6>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
80003dba:	30 18       	mov	r8,1
80003dbc:	ef 48 ff fc 	st.w	r7[-4],r8
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80003dc0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003dc4:	58 18       	cp.w	r8,1
80003dc6:	c0 50       	breq	80003dd0 <xTaskResumeAll+0xd4>
80003dc8:	49 58       	lddpc	r8,80003e1c <xTaskResumeAll+0x120>
80003dca:	70 08       	ld.w	r8,r8[0x0]
80003dcc:	58 18       	cp.w	r8,1
80003dce:	c0 81       	brne	80003dde <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
80003dd0:	30 18       	mov	r8,1
80003dd2:	ef 48 ff f8 	st.w	r7[-8],r8
					xMissedYield = pdFALSE;
80003dd6:	49 28       	lddpc	r8,80003e1c <xTaskResumeAll+0x120>
80003dd8:	30 09       	mov	r9,0
80003dda:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80003ddc:	d7 33       	scall
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80003dde:	f0 1f 00 11 	mcall	80003e20 <xTaskResumeAll+0x124>

	return xAlreadyYielded;
80003de2:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80003de6:	10 9c       	mov	r12,r8
80003de8:	2f ed       	sub	sp,-8
80003dea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003dee:	00 00       	add	r0,r0
80003df0:	80 00       	ld.sh	r0,r0[0x0]
80003df2:	30 ac       	mov	r12,10
80003df4:	00 00       	add	r0,r0
80003df6:	07 44       	ld.w	r4,--r3
80003df8:	00 00       	add	r0,r0
80003dfa:	07 30       	ld.ub	r0,r3++
80003dfc:	00 00       	add	r0,r0
80003dfe:	06 f0       	st.b	--r3,r0
80003e00:	80 00       	ld.sh	r0,r0[0x0]
80003e02:	2e 96       	sub	r6,-23
80003e04:	00 00       	add	r0,r0
80003e06:	07 3c       	ld.ub	r12,r3++
80003e08:	00 00       	add	r0,r0
80003e0a:	06 20       	rsub	r0,r3
80003e0c:	80 00       	ld.sh	r0,r0[0x0]
80003e0e:	2d 82       	sub	r2,-40
80003e10:	00 00       	add	r0,r0
80003e12:	06 1c       	sub	r12,r3
80003e14:	00 00       	add	r0,r0
80003e16:	07 48       	ld.w	r8,--r3
80003e18:	80 00       	ld.sh	r0,r0[0x0]
80003e1a:	3e 24       	mov	r4,-30
80003e1c:	00 00       	add	r0,r0
80003e1e:	07 4c       	ld.w	r12,--r3
80003e20:	80 00       	ld.sh	r0,r0[0x0]
80003e22:	30 c8       	mov	r8,12

80003e24 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80003e24:	eb cd 40 80 	pushm	r7,lr
80003e28:	1a 97       	mov	r7,sp
80003e2a:	20 3d       	sub	sp,12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80003e2c:	4c b8       	lddpc	r8,80003f58 <vTaskIncrementTick+0x134>
80003e2e:	70 08       	ld.w	r8,r8[0x0]
80003e30:	58 08       	cp.w	r8,0
80003e32:	e0 81 00 89 	brne	80003f44 <vTaskIncrementTick+0x120>
	{
		++xTickCount;
80003e36:	4c a8       	lddpc	r8,80003f5c <vTaskIncrementTick+0x138>
80003e38:	70 08       	ld.w	r8,r8[0x0]
80003e3a:	f0 c9 ff ff 	sub	r9,r8,-1
80003e3e:	4c 88       	lddpc	r8,80003f5c <vTaskIncrementTick+0x138>
80003e40:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80003e42:	4c 78       	lddpc	r8,80003f5c <vTaskIncrementTick+0x138>
80003e44:	70 08       	ld.w	r8,r8[0x0]
80003e46:	58 08       	cp.w	r8,0
80003e48:	c2 71       	brne	80003e96 <vTaskIncrementTick+0x72>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80003e4a:	4c 68       	lddpc	r8,80003f60 <vTaskIncrementTick+0x13c>
80003e4c:	70 08       	ld.w	r8,r8[0x0]
80003e4e:	ef 48 ff f8 	st.w	r7[-8],r8
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80003e52:	4c 58       	lddpc	r8,80003f64 <vTaskIncrementTick+0x140>
80003e54:	70 09       	ld.w	r9,r8[0x0]
80003e56:	4c 38       	lddpc	r8,80003f60 <vTaskIncrementTick+0x13c>
80003e58:	91 09       	st.w	r8[0x0],r9
			pxOverflowDelayedTaskList = pxTemp;
80003e5a:	4c 38       	lddpc	r8,80003f64 <vTaskIncrementTick+0x140>
80003e5c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003e60:	91 09       	st.w	r8[0x0],r9
			xNumOfOverflows++;
80003e62:	4c 28       	lddpc	r8,80003f68 <vTaskIncrementTick+0x144>
80003e64:	70 08       	ld.w	r8,r8[0x0]
80003e66:	f0 c9 ff ff 	sub	r9,r8,-1
80003e6a:	4c 08       	lddpc	r8,80003f68 <vTaskIncrementTick+0x144>
80003e6c:	91 09       	st.w	r8[0x0],r9

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80003e6e:	4b d8       	lddpc	r8,80003f60 <vTaskIncrementTick+0x13c>
80003e70:	70 08       	ld.w	r8,r8[0x0]
80003e72:	70 08       	ld.w	r8,r8[0x0]
80003e74:	58 08       	cp.w	r8,0
80003e76:	c0 51       	brne	80003e80 <vTaskIncrementTick+0x5c>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80003e78:	4b d8       	lddpc	r8,80003f6c <vTaskIncrementTick+0x148>
80003e7a:	3f f9       	mov	r9,-1
80003e7c:	91 09       	st.w	r8[0x0],r9
80003e7e:	c0 c8       	rjmp	80003e96 <vTaskIncrementTick+0x72>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80003e80:	4b 88       	lddpc	r8,80003f60 <vTaskIncrementTick+0x13c>
80003e82:	70 08       	ld.w	r8,r8[0x0]
80003e84:	70 38       	ld.w	r8,r8[0xc]
80003e86:	70 38       	ld.w	r8,r8[0xc]
80003e88:	ef 48 ff f4 	st.w	r7[-12],r8
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80003e8c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003e90:	70 19       	ld.w	r9,r8[0x4]
80003e92:	4b 78       	lddpc	r8,80003f6c <vTaskIncrementTick+0x148>
80003e94:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80003e96:	4b 28       	lddpc	r8,80003f5c <vTaskIncrementTick+0x138>
80003e98:	70 09       	ld.w	r9,r8[0x0]
80003e9a:	4b 58       	lddpc	r8,80003f6c <vTaskIncrementTick+0x148>
80003e9c:	70 08       	ld.w	r8,r8[0x0]
80003e9e:	10 39       	cp.w	r9,r8
80003ea0:	c5 83       	brcs	80003f50 <vTaskIncrementTick+0x12c>
80003ea2:	4b 08       	lddpc	r8,80003f60 <vTaskIncrementTick+0x13c>
80003ea4:	70 08       	ld.w	r8,r8[0x0]
80003ea6:	70 08       	ld.w	r8,r8[0x0]
80003ea8:	58 08       	cp.w	r8,0
80003eaa:	c0 51       	brne	80003eb4 <vTaskIncrementTick+0x90>
80003eac:	4b 08       	lddpc	r8,80003f6c <vTaskIncrementTick+0x148>
80003eae:	3f f9       	mov	r9,-1
80003eb0:	91 09       	st.w	r8[0x0],r9
80003eb2:	c4 f8       	rjmp	80003f50 <vTaskIncrementTick+0x12c>
80003eb4:	4a b8       	lddpc	r8,80003f60 <vTaskIncrementTick+0x13c>
80003eb6:	70 08       	ld.w	r8,r8[0x0]
80003eb8:	70 38       	ld.w	r8,r8[0xc]
80003eba:	70 38       	ld.w	r8,r8[0xc]
80003ebc:	ef 48 ff f4 	st.w	r7[-12],r8
80003ec0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003ec4:	70 18       	ld.w	r8,r8[0x4]
80003ec6:	ef 48 ff fc 	st.w	r7[-4],r8
80003eca:	4a 58       	lddpc	r8,80003f5c <vTaskIncrementTick+0x138>
80003ecc:	70 09       	ld.w	r9,r8[0x0]
80003ece:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ed2:	10 39       	cp.w	r9,r8
80003ed4:	c0 62       	brcc	80003ee0 <vTaskIncrementTick+0xbc>
80003ed6:	4a 68       	lddpc	r8,80003f6c <vTaskIncrementTick+0x148>
80003ed8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003edc:	91 09       	st.w	r8[0x0],r9
80003ede:	c3 98       	rjmp	80003f50 <vTaskIncrementTick+0x12c>
80003ee0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003ee4:	2f c8       	sub	r8,-4
80003ee6:	10 9c       	mov	r12,r8
80003ee8:	f0 1f 00 22 	mcall	80003f70 <vTaskIncrementTick+0x14c>
80003eec:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003ef0:	70 a8       	ld.w	r8,r8[0x28]
80003ef2:	58 08       	cp.w	r8,0
80003ef4:	c0 70       	breq	80003f02 <vTaskIncrementTick+0xde>
80003ef6:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003efa:	2e 88       	sub	r8,-24
80003efc:	10 9c       	mov	r12,r8
80003efe:	f0 1f 00 1d 	mcall	80003f70 <vTaskIncrementTick+0x14c>
80003f02:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003f06:	70 b9       	ld.w	r9,r8[0x2c]
80003f08:	49 b8       	lddpc	r8,80003f74 <vTaskIncrementTick+0x150>
80003f0a:	70 08       	ld.w	r8,r8[0x0]
80003f0c:	10 39       	cp.w	r9,r8
80003f0e:	e0 88 00 07 	brls	80003f1c <vTaskIncrementTick+0xf8>
80003f12:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003f16:	70 b9       	ld.w	r9,r8[0x2c]
80003f18:	49 78       	lddpc	r8,80003f74 <vTaskIncrementTick+0x150>
80003f1a:	91 09       	st.w	r8[0x0],r9
80003f1c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003f20:	f0 ca ff fc 	sub	r10,r8,-4
80003f24:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003f28:	70 b9       	ld.w	r9,r8[0x2c]
80003f2a:	12 98       	mov	r8,r9
80003f2c:	a3 68       	lsl	r8,0x2
80003f2e:	12 08       	add	r8,r9
80003f30:	a3 68       	lsl	r8,0x2
80003f32:	10 99       	mov	r9,r8
80003f34:	49 18       	lddpc	r8,80003f78 <vTaskIncrementTick+0x154>
80003f36:	f2 08 00 08 	add	r8,r9,r8
80003f3a:	14 9b       	mov	r11,r10
80003f3c:	10 9c       	mov	r12,r8
80003f3e:	f0 1f 00 10 	mcall	80003f7c <vTaskIncrementTick+0x158>
80003f42:	cb 0b       	rjmp	80003ea2 <vTaskIncrementTick+0x7e>
	}
	else
	{
		++uxMissedTicks;
80003f44:	48 f8       	lddpc	r8,80003f80 <vTaskIncrementTick+0x15c>
80003f46:	70 08       	ld.w	r8,r8[0x0]
80003f48:	f0 c9 ff ff 	sub	r9,r8,-1
80003f4c:	48 d8       	lddpc	r8,80003f80 <vTaskIncrementTick+0x15c>
80003f4e:	91 09       	st.w	r8[0x0],r9
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
80003f50:	2f dd       	sub	sp,-12
80003f52:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f56:	00 00       	add	r0,r0
80003f58:	00 00       	add	r0,r0
80003f5a:	07 44       	ld.w	r4,--r3
80003f5c:	00 00       	add	r0,r0
80003f5e:	07 34       	ld.ub	r4,r3++
80003f60:	00 00       	add	r0,r0
80003f62:	06 e8       	st.h	--r3,r8
80003f64:	00 00       	add	r0,r0
80003f66:	06 ec       	st.h	--r3,r12
80003f68:	00 00       	add	r0,r0
80003f6a:	07 50       	ld.sh	r0,--r3
80003f6c:	00 00       	add	r0,r0
80003f6e:	00 20       	rsub	r0,r0
80003f70:	80 00       	ld.sh	r0,r0[0x0]
80003f72:	2e 96       	sub	r6,-23
80003f74:	00 00       	add	r0,r0
80003f76:	07 3c       	ld.ub	r12,r3++
80003f78:	00 00       	add	r0,r0
80003f7a:	06 20       	rsub	r0,r3
80003f7c:	80 00       	ld.sh	r0,r0[0x0]
80003f7e:	2d 82       	sub	r2,-40
80003f80:	00 00       	add	r0,r0
80003f82:	07 48       	ld.w	r8,--r3

80003f84 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
80003f84:	eb cd 40 80 	pushm	r7,lr
80003f88:	1a 97       	mov	r7,sp
80003f8a:	20 1d       	sub	sp,4
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80003f8c:	4a 58       	lddpc	r8,80004020 <vTaskSwitchContext+0x9c>
80003f8e:	70 08       	ld.w	r8,r8[0x0]
80003f90:	58 08       	cp.w	r8,0
80003f92:	c0 c0       	breq	80003faa <vTaskSwitchContext+0x26>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80003f94:	4a 48       	lddpc	r8,80004024 <vTaskSwitchContext+0xa0>
80003f96:	30 19       	mov	r9,1
80003f98:	91 09       	st.w	r8[0x0],r9
80003f9a:	c3 f8       	rjmp	80004018 <vTaskSwitchContext+0x94>

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80003f9c:	4a 38       	lddpc	r8,80004028 <vTaskSwitchContext+0xa4>
80003f9e:	70 08       	ld.w	r8,r8[0x0]
80003fa0:	f0 c9 00 01 	sub	r9,r8,1
80003fa4:	4a 18       	lddpc	r8,80004028 <vTaskSwitchContext+0xa4>
80003fa6:	91 09       	st.w	r8[0x0],r9
80003fa8:	c0 28       	rjmp	80003fac <vTaskSwitchContext+0x28>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80003faa:	d7 03       	nop
80003fac:	49 f8       	lddpc	r8,80004028 <vTaskSwitchContext+0xa4>
80003fae:	70 09       	ld.w	r9,r8[0x0]
80003fb0:	12 98       	mov	r8,r9
80003fb2:	a3 68       	lsl	r8,0x2
80003fb4:	12 08       	add	r8,r9
80003fb6:	a3 68       	lsl	r8,0x2
80003fb8:	10 99       	mov	r9,r8
80003fba:	49 d8       	lddpc	r8,8000402c <vTaskSwitchContext+0xa8>
80003fbc:	f2 08 00 08 	add	r8,r9,r8
80003fc0:	70 08       	ld.w	r8,r8[0x0]
80003fc2:	58 08       	cp.w	r8,0
80003fc4:	ce c0       	breq	80003f9c <vTaskSwitchContext+0x18>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80003fc6:	49 98       	lddpc	r8,80004028 <vTaskSwitchContext+0xa4>
80003fc8:	70 09       	ld.w	r9,r8[0x0]
80003fca:	12 98       	mov	r8,r9
80003fcc:	a3 68       	lsl	r8,0x2
80003fce:	12 08       	add	r8,r9
80003fd0:	a3 68       	lsl	r8,0x2
80003fd2:	10 99       	mov	r9,r8
80003fd4:	49 68       	lddpc	r8,8000402c <vTaskSwitchContext+0xa8>
80003fd6:	f2 08 00 08 	add	r8,r9,r8
80003fda:	ef 48 ff fc 	st.w	r7[-4],r8
80003fde:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003fe2:	70 18       	ld.w	r8,r8[0x4]
80003fe4:	70 19       	ld.w	r9,r8[0x4]
80003fe6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003fea:	91 19       	st.w	r8[0x4],r9
80003fec:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ff0:	70 19       	ld.w	r9,r8[0x4]
80003ff2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ff6:	2f 88       	sub	r8,-8
80003ff8:	10 39       	cp.w	r9,r8
80003ffa:	c0 81       	brne	8000400a <vTaskSwitchContext+0x86>
80003ffc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004000:	70 18       	ld.w	r8,r8[0x4]
80004002:	70 19       	ld.w	r9,r8[0x4]
80004004:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004008:	91 19       	st.w	r8[0x4],r9
8000400a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000400e:	70 18       	ld.w	r8,r8[0x4]
80004010:	70 38       	ld.w	r8,r8[0xc]
80004012:	10 99       	mov	r9,r8
80004014:	48 78       	lddpc	r8,80004030 <vTaskSwitchContext+0xac>
80004016:	91 09       	st.w	r8[0x0],r9

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
80004018:	2f fd       	sub	sp,-4
8000401a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000401e:	00 00       	add	r0,r0
80004020:	00 00       	add	r0,r0
80004022:	07 44       	ld.w	r4,--r3
80004024:	00 00       	add	r0,r0
80004026:	07 4c       	ld.w	r12,--r3
80004028:	00 00       	add	r0,r0
8000402a:	07 3c       	ld.ub	r12,r3++
8000402c:	00 00       	add	r0,r0
8000402e:	06 20       	rsub	r0,r3
80004030:	00 00       	add	r0,r0
80004032:	06 1c       	sub	r12,r3

80004034 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80004034:	eb cd 40 80 	pushm	r7,lr
80004038:	1a 97       	mov	r7,sp
8000403a:	20 3d       	sub	sp,12
8000403c:	ef 4c ff f8 	st.w	r7[-8],r12
80004040:	ef 4b ff f4 	st.w	r7[-12],r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80004044:	49 58       	lddpc	r8,80004098 <vTaskPlaceOnEventList+0x64>
80004046:	70 08       	ld.w	r8,r8[0x0]
80004048:	2e 88       	sub	r8,-24
8000404a:	10 9b       	mov	r11,r8
8000404c:	ee fc ff f8 	ld.w	r12,r7[-8]
80004050:	f0 1f 00 13 	mcall	8000409c <vTaskPlaceOnEventList+0x68>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004054:	49 18       	lddpc	r8,80004098 <vTaskPlaceOnEventList+0x64>
80004056:	70 08       	ld.w	r8,r8[0x0]
80004058:	2f c8       	sub	r8,-4
8000405a:	10 9c       	mov	r12,r8
8000405c:	f0 1f 00 11 	mcall	800040a0 <vTaskPlaceOnEventList+0x6c>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80004060:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004064:	5b f8       	cp.w	r8,-1
80004066:	c0 91       	brne	80004078 <vTaskPlaceOnEventList+0x44>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004068:	48 c8       	lddpc	r8,80004098 <vTaskPlaceOnEventList+0x64>
8000406a:	70 08       	ld.w	r8,r8[0x0]
8000406c:	2f c8       	sub	r8,-4
8000406e:	10 9b       	mov	r11,r8
80004070:	48 dc       	lddpc	r12,800040a4 <vTaskPlaceOnEventList+0x70>
80004072:	f0 1f 00 0e 	mcall	800040a8 <vTaskPlaceOnEventList+0x74>
80004076:	c0 d8       	rjmp	80004090 <vTaskPlaceOnEventList+0x5c>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80004078:	48 d8       	lddpc	r8,800040ac <vTaskPlaceOnEventList+0x78>
8000407a:	70 09       	ld.w	r9,r8[0x0]
8000407c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004080:	f2 08 00 08 	add	r8,r9,r8
80004084:	ef 48 ff fc 	st.w	r7[-4],r8
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80004088:	ee fc ff fc 	ld.w	r12,r7[-4]
8000408c:	f0 1f 00 09 	mcall	800040b0 <vTaskPlaceOnEventList+0x7c>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
80004090:	2f dd       	sub	sp,-12
80004092:	e3 cd 80 80 	ldm	sp++,r7,pc
80004096:	00 00       	add	r0,r0
80004098:	00 00       	add	r0,r0
8000409a:	06 1c       	sub	r12,r3
8000409c:	80 00       	ld.sh	r0,r0[0x0]
8000409e:	2d f4       	sub	r4,-33
800040a0:	80 00       	ld.sh	r0,r0[0x0]
800040a2:	2e 96       	sub	r6,-23
800040a4:	00 00       	add	r0,r0
800040a6:	07 1c       	ld.sh	r12,r3++
800040a8:	80 00       	ld.sh	r0,r0[0x0]
800040aa:	2d 82       	sub	r2,-40
800040ac:	00 00       	add	r0,r0
800040ae:	07 34       	ld.ub	r4,r3++
800040b0:	80 00       	ld.sh	r0,r0[0x0]
800040b2:	44 74       	lddsp	r4,sp[0x11c]

800040b4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800040b4:	eb cd 40 80 	pushm	r7,lr
800040b8:	1a 97       	mov	r7,sp
800040ba:	20 3d       	sub	sp,12
800040bc:	ef 4c ff f4 	st.w	r7[-12],r12
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800040c0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800040c4:	70 38       	ld.w	r8,r8[0xc]
800040c6:	70 38       	ld.w	r8,r8[0xc]
800040c8:	ef 48 ff f8 	st.w	r7[-8],r8
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800040cc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800040d0:	2e 88       	sub	r8,-24
800040d2:	10 9c       	mov	r12,r8
800040d4:	f0 1f 00 25 	mcall	80004168 <xTaskRemoveFromEventList+0xb4>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800040d8:	4a 58       	lddpc	r8,8000416c <xTaskRemoveFromEventList+0xb8>
800040da:	70 08       	ld.w	r8,r8[0x0]
800040dc:	58 08       	cp.w	r8,0
800040de:	c2 81       	brne	8000412e <xTaskRemoveFromEventList+0x7a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800040e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800040e4:	2f c8       	sub	r8,-4
800040e6:	10 9c       	mov	r12,r8
800040e8:	f0 1f 00 20 	mcall	80004168 <xTaskRemoveFromEventList+0xb4>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800040ec:	ee f8 ff f8 	ld.w	r8,r7[-8]
800040f0:	70 b9       	ld.w	r9,r8[0x2c]
800040f2:	4a 08       	lddpc	r8,80004170 <xTaskRemoveFromEventList+0xbc>
800040f4:	70 08       	ld.w	r8,r8[0x0]
800040f6:	10 39       	cp.w	r9,r8
800040f8:	e0 88 00 07 	brls	80004106 <xTaskRemoveFromEventList+0x52>
800040fc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004100:	70 b9       	ld.w	r9,r8[0x2c]
80004102:	49 c8       	lddpc	r8,80004170 <xTaskRemoveFromEventList+0xbc>
80004104:	91 09       	st.w	r8[0x0],r9
80004106:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000410a:	f0 ca ff fc 	sub	r10,r8,-4
8000410e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004112:	70 b9       	ld.w	r9,r8[0x2c]
80004114:	12 98       	mov	r8,r9
80004116:	a3 68       	lsl	r8,0x2
80004118:	12 08       	add	r8,r9
8000411a:	a3 68       	lsl	r8,0x2
8000411c:	10 99       	mov	r9,r8
8000411e:	49 68       	lddpc	r8,80004174 <xTaskRemoveFromEventList+0xc0>
80004120:	f2 08 00 08 	add	r8,r9,r8
80004124:	14 9b       	mov	r11,r10
80004126:	10 9c       	mov	r12,r8
80004128:	f0 1f 00 14 	mcall	80004178 <xTaskRemoveFromEventList+0xc4>
8000412c:	c0 88       	rjmp	8000413c <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000412e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004132:	2e 88       	sub	r8,-24
80004134:	10 9b       	mov	r11,r8
80004136:	49 2c       	lddpc	r12,8000417c <xTaskRemoveFromEventList+0xc8>
80004138:	f0 1f 00 10 	mcall	80004178 <xTaskRemoveFromEventList+0xc4>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000413c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004140:	70 b9       	ld.w	r9,r8[0x2c]
80004142:	49 08       	lddpc	r8,80004180 <xTaskRemoveFromEventList+0xcc>
80004144:	70 08       	ld.w	r8,r8[0x0]
80004146:	70 b8       	ld.w	r8,r8[0x2c]
80004148:	10 39       	cp.w	r9,r8
8000414a:	c0 53       	brcs	80004154 <xTaskRemoveFromEventList+0xa0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
8000414c:	30 18       	mov	r8,1
8000414e:	ef 48 ff fc 	st.w	r7[-4],r8
80004152:	c0 48       	rjmp	8000415a <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		xReturn = pdFALSE;
80004154:	30 08       	mov	r8,0
80004156:	ef 48 ff fc 	st.w	r7[-4],r8
	}

	return xReturn;
8000415a:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000415e:	10 9c       	mov	r12,r8
80004160:	2f dd       	sub	sp,-12
80004162:	e3 cd 80 80 	ldm	sp++,r7,pc
80004166:	00 00       	add	r0,r0
80004168:	80 00       	ld.sh	r0,r0[0x0]
8000416a:	2e 96       	sub	r6,-23
8000416c:	00 00       	add	r0,r0
8000416e:	07 44       	ld.w	r4,--r3
80004170:	00 00       	add	r0,r0
80004172:	07 3c       	ld.ub	r12,r3++
80004174:	00 00       	add	r0,r0
80004176:	06 20       	rsub	r0,r3
80004178:	80 00       	ld.sh	r0,r0[0x0]
8000417a:	2d 82       	sub	r2,-40
8000417c:	00 00       	add	r0,r0
8000417e:	06 f0       	st.b	--r3,r0
80004180:	00 00       	add	r0,r0
80004182:	06 1c       	sub	r12,r3

80004184 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
80004184:	eb cd 40 80 	pushm	r7,lr
80004188:	1a 97       	mov	r7,sp
8000418a:	20 1d       	sub	sp,4
8000418c:	ef 4c ff fc 	st.w	r7[-4],r12
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80004190:	48 78       	lddpc	r8,800041ac <vTaskSetTimeOutState+0x28>
80004192:	70 09       	ld.w	r9,r8[0x0]
80004194:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004198:	91 09       	st.w	r8[0x0],r9
	pxTimeOut->xTimeOnEntering = xTickCount;
8000419a:	48 68       	lddpc	r8,800041b0 <vTaskSetTimeOutState+0x2c>
8000419c:	70 09       	ld.w	r9,r8[0x0]
8000419e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800041a2:	91 19       	st.w	r8[0x4],r9
}
800041a4:	2f fd       	sub	sp,-4
800041a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800041aa:	00 00       	add	r0,r0
800041ac:	00 00       	add	r0,r0
800041ae:	07 50       	ld.sh	r0,--r3
800041b0:	00 00       	add	r0,r0
800041b2:	07 34       	ld.ub	r4,r3++

800041b4 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800041b4:	eb cd 40 80 	pushm	r7,lr
800041b8:	1a 97       	mov	r7,sp
800041ba:	20 3d       	sub	sp,12
800041bc:	ef 4c ff f8 	st.w	r7[-8],r12
800041c0:	ef 4b ff f4 	st.w	r7[-12],r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800041c4:	f0 1f 00 25 	mcall	80004258 <xTaskCheckForTimeOut+0xa4>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800041c8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800041cc:	70 08       	ld.w	r8,r8[0x0]
800041ce:	5b f8       	cp.w	r8,-1
800041d0:	c0 51       	brne	800041da <xTaskCheckForTimeOut+0x26>
			{
				xReturn = pdFALSE;
800041d2:	30 08       	mov	r8,0
800041d4:	ef 48 ff fc 	st.w	r7[-4],r8
800041d8:	c3 88       	rjmp	80004248 <xTaskCheckForTimeOut+0x94>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800041da:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041de:	70 09       	ld.w	r9,r8[0x0]
800041e0:	49 f8       	lddpc	r8,8000425c <xTaskCheckForTimeOut+0xa8>
800041e2:	70 08       	ld.w	r8,r8[0x0]
800041e4:	10 39       	cp.w	r9,r8
800041e6:	c0 d0       	breq	80004200 <xTaskCheckForTimeOut+0x4c>
800041e8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041ec:	70 19       	ld.w	r9,r8[0x4]
800041ee:	49 d8       	lddpc	r8,80004260 <xTaskCheckForTimeOut+0xac>
800041f0:	70 08       	ld.w	r8,r8[0x0]
800041f2:	10 39       	cp.w	r9,r8
800041f4:	e0 8b 00 06 	brhi	80004200 <xTaskCheckForTimeOut+0x4c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
800041f8:	30 18       	mov	r8,1
800041fa:	ef 48 ff fc 	st.w	r7[-4],r8
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800041fe:	c2 58       	rjmp	80004248 <xTaskCheckForTimeOut+0x94>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80004200:	49 88       	lddpc	r8,80004260 <xTaskCheckForTimeOut+0xac>
80004202:	70 09       	ld.w	r9,r8[0x0]
80004204:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004208:	70 18       	ld.w	r8,r8[0x4]
8000420a:	10 19       	sub	r9,r8
8000420c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004210:	70 08       	ld.w	r8,r8[0x0]
80004212:	10 39       	cp.w	r9,r8
80004214:	c1 72       	brcc	80004242 <xTaskCheckForTimeOut+0x8e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80004216:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000421a:	70 09       	ld.w	r9,r8[0x0]
8000421c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004220:	70 1a       	ld.w	r10,r8[0x4]
80004222:	49 08       	lddpc	r8,80004260 <xTaskCheckForTimeOut+0xac>
80004224:	70 08       	ld.w	r8,r8[0x0]
80004226:	f4 08 01 08 	sub	r8,r10,r8
8000422a:	10 09       	add	r9,r8
8000422c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004230:	91 09       	st.w	r8[0x0],r9
			vTaskSetTimeOutState( pxTimeOut );
80004232:	ee fc ff f8 	ld.w	r12,r7[-8]
80004236:	f0 1f 00 0c 	mcall	80004264 <xTaskCheckForTimeOut+0xb0>
			xReturn = pdFALSE;
8000423a:	30 08       	mov	r8,0
8000423c:	ef 48 ff fc 	st.w	r7[-4],r8
80004240:	c0 48       	rjmp	80004248 <xTaskCheckForTimeOut+0x94>
		}
		else
		{
			xReturn = pdTRUE;
80004242:	30 18       	mov	r8,1
80004244:	ef 48 ff fc 	st.w	r7[-4],r8
		}
	}
	taskEXIT_CRITICAL();
80004248:	f0 1f 00 08 	mcall	80004268 <xTaskCheckForTimeOut+0xb4>

	return xReturn;
8000424c:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80004250:	10 9c       	mov	r12,r8
80004252:	2f dd       	sub	sp,-12
80004254:	e3 cd 80 80 	ldm	sp++,r7,pc
80004258:	80 00       	ld.sh	r0,r0[0x0]
8000425a:	30 ac       	mov	r12,10
8000425c:	00 00       	add	r0,r0
8000425e:	07 50       	ld.sh	r0,--r3
80004260:	00 00       	add	r0,r0
80004262:	07 34       	ld.ub	r4,r3++
80004264:	80 00       	ld.sh	r0,r0[0x0]
80004266:	41 84       	lddsp	r4,sp[0x60]
80004268:	80 00       	ld.sh	r0,r0[0x0]
8000426a:	30 c8       	mov	r8,12

8000426c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
8000426c:	eb cd 40 80 	pushm	r7,lr
80004270:	1a 97       	mov	r7,sp
	xMissedYield = pdTRUE;
80004272:	48 38       	lddpc	r8,8000427c <vTaskMissedYield+0x10>
80004274:	30 19       	mov	r9,1
80004276:	91 09       	st.w	r8[0x0],r9
}
80004278:	e3 cd 80 80 	ldm	sp++,r7,pc
8000427c:	00 00       	add	r0,r0
8000427e:	07 4c       	ld.w	r12,--r3

80004280 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80004280:	eb cd 40 80 	pushm	r7,lr
80004284:	1a 97       	mov	r7,sp
80004286:	20 1d       	sub	sp,4
80004288:	ef 4c ff fc 	st.w	r7[-4],r12
8000428c:	c0 28       	rjmp	80004290 <prvIdleTask+0x10>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
8000428e:	d7 03       	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
80004290:	f0 1f 00 05 	mcall	800042a4 <prvIdleTask+0x24>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80004294:	48 58       	lddpc	r8,800042a8 <prvIdleTask+0x28>
80004296:	70 08       	ld.w	r8,r8[0x0]
80004298:	58 18       	cp.w	r8,1
8000429a:	fe 98 ff fa 	brls	8000428e <prvIdleTask+0xe>
			{
				taskYIELD();
8000429e:	d7 33       	scall
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
800042a0:	cf 8b       	rjmp	80004290 <prvIdleTask+0x10>
800042a2:	00 00       	add	r0,r0
800042a4:	80 00       	ld.sh	r0,r0[0x0]
800042a6:	43 dc       	lddsp	r12,sp[0xf4]
800042a8:	00 00       	add	r0,r0
800042aa:	06 20       	rsub	r0,r3

800042ac <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
800042ac:	eb cd 40 80 	pushm	r7,lr
800042b0:	1a 97       	mov	r7,sp
800042b2:	20 5d       	sub	sp,20
800042b4:	ef 4c ff fc 	st.w	r7[-4],r12
800042b8:	ef 4b ff f8 	st.w	r7[-8],r11
800042bc:	ef 4a ff f4 	st.w	r7[-12],r10
800042c0:	ef 49 ff f0 	st.w	r7[-16],r9
800042c4:	ef 58 ff ec 	st.h	r7[-20],r8
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800042c8:	ee f9 ff f8 	ld.w	r9,r7[-8]
800042cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042d0:	2c c8       	sub	r8,-52
800042d2:	31 0a       	mov	r10,16
800042d4:	12 9b       	mov	r11,r9
800042d6:	10 9c       	mov	r12,r8
800042d8:	f0 1f 00 1a 	mcall	80004340 <prvInitialiseTCBVariables+0x94>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800042dc:	ee f9 ff fc 	ld.w	r9,r7[-4]
800042e0:	30 08       	mov	r8,0
800042e2:	f3 68 00 43 	st.b	r9[67],r8

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
800042e6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800042ea:	58 78       	cp.w	r8,7
800042ec:	e0 88 00 05 	brls	800042f6 <prvInitialiseTCBVariables+0x4a>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
800042f0:	30 78       	mov	r8,7
800042f2:	ef 48 ff f4 	st.w	r7[-12],r8
	}

	pxTCB->uxPriority = uxPriority;
800042f6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042fa:	ee f9 ff f4 	ld.w	r9,r7[-12]
800042fe:	91 b9       	st.w	r8[0x2c],r9
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80004300:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004304:	2f c8       	sub	r8,-4
80004306:	10 9c       	mov	r12,r8
80004308:	f0 1f 00 0f 	mcall	80004344 <prvInitialiseTCBVariables+0x98>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
8000430c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004310:	2e 88       	sub	r8,-24
80004312:	10 9c       	mov	r12,r8
80004314:	f0 1f 00 0c 	mcall	80004344 <prvInitialiseTCBVariables+0x98>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80004318:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000431c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004320:	91 49       	st.w	r8[0x10],r9

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80004322:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004326:	f0 09 11 08 	rsub	r9,r8,8
8000432a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000432e:	91 69       	st.w	r8[0x18],r9
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80004330:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004334:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004338:	91 99       	st.w	r8[0x24],r9
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
8000433a:	2f bd       	sub	sp,-20
8000433c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004340:	80 00       	ld.sh	r0,r0[0x0]
80004342:	4b c4       	lddpc	r4,80004430 <prvCheckTasksWaitingTermination+0x54>
80004344:	80 00       	ld.sh	r0,r0[0x0]
80004346:	2d 68       	sub	r8,-42

80004348 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
80004348:	eb cd 40 80 	pushm	r7,lr
8000434c:	1a 97       	mov	r7,sp
8000434e:	20 1d       	sub	sp,4
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80004350:	30 08       	mov	r8,0
80004352:	ef 48 ff fc 	st.w	r7[-4],r8
80004356:	c1 38       	rjmp	8000437c <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80004358:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000435c:	12 98       	mov	r8,r9
8000435e:	a3 68       	lsl	r8,0x2
80004360:	12 08       	add	r8,r9
80004362:	a3 68       	lsl	r8,0x2
80004364:	10 99       	mov	r9,r8
80004366:	49 58       	lddpc	r8,800043b8 <prvInitialiseTaskLists+0x70>
80004368:	f2 08 00 08 	add	r8,r9,r8
8000436c:	10 9c       	mov	r12,r8
8000436e:	f0 1f 00 14 	mcall	800043bc <prvInitialiseTaskLists+0x74>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80004372:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004376:	2f f8       	sub	r8,-1
80004378:	ef 48 ff fc 	st.w	r7[-4],r8
8000437c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004380:	58 78       	cp.w	r8,7
80004382:	fe 98 ff eb 	brls	80004358 <prvInitialiseTaskLists+0x10>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80004386:	48 fc       	lddpc	r12,800043c0 <prvInitialiseTaskLists+0x78>
80004388:	f0 1f 00 0d 	mcall	800043bc <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
8000438c:	48 ec       	lddpc	r12,800043c4 <prvInitialiseTaskLists+0x7c>
8000438e:	f0 1f 00 0c 	mcall	800043bc <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xPendingReadyList );
80004392:	48 ec       	lddpc	r12,800043c8 <prvInitialiseTaskLists+0x80>
80004394:	f0 1f 00 0a 	mcall	800043bc <prvInitialiseTaskLists+0x74>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80004398:	48 dc       	lddpc	r12,800043cc <prvInitialiseTaskLists+0x84>
8000439a:	f0 1f 00 09 	mcall	800043bc <prvInitialiseTaskLists+0x74>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
8000439e:	48 dc       	lddpc	r12,800043d0 <prvInitialiseTaskLists+0x88>
800043a0:	f0 1f 00 07 	mcall	800043bc <prvInitialiseTaskLists+0x74>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800043a4:	48 c8       	lddpc	r8,800043d4 <prvInitialiseTaskLists+0x8c>
800043a6:	48 79       	lddpc	r9,800043c0 <prvInitialiseTaskLists+0x78>
800043a8:	91 09       	st.w	r8[0x0],r9
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800043aa:	48 c8       	lddpc	r8,800043d8 <prvInitialiseTaskLists+0x90>
800043ac:	48 69       	lddpc	r9,800043c4 <prvInitialiseTaskLists+0x7c>
800043ae:	91 09       	st.w	r8[0x0],r9
}
800043b0:	2f fd       	sub	sp,-4
800043b2:	e3 cd 80 80 	ldm	sp++,r7,pc
800043b6:	00 00       	add	r0,r0
800043b8:	00 00       	add	r0,r0
800043ba:	06 20       	rsub	r0,r3
800043bc:	80 00       	ld.sh	r0,r0[0x0]
800043be:	2d 1c       	sub	r12,-47
800043c0:	00 00       	add	r0,r0
800043c2:	06 c0       	st.b	r3++,r0
800043c4:	00 00       	add	r0,r0
800043c6:	06 d4       	st.w	--r3,r4
800043c8:	00 00       	add	r0,r0
800043ca:	06 f0       	st.b	--r3,r0
800043cc:	00 00       	add	r0,r0
800043ce:	07 04       	ld.w	r4,r3++
800043d0:	00 00       	add	r0,r0
800043d2:	07 1c       	ld.sh	r12,r3++
800043d4:	00 00       	add	r0,r0
800043d6:	06 e8       	st.h	--r3,r8
800043d8:	00 00       	add	r0,r0
800043da:	06 ec       	st.h	--r3,r12

800043dc <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
800043dc:	eb cd 40 80 	pushm	r7,lr
800043e0:	1a 97       	mov	r7,sp
800043e2:	20 2d       	sub	sp,8
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800043e4:	49 b8       	lddpc	r8,80004450 <prvCheckTasksWaitingTermination+0x74>
800043e6:	70 08       	ld.w	r8,r8[0x0]
800043e8:	58 08       	cp.w	r8,0
800043ea:	c2 f0       	breq	80004448 <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
800043ec:	f0 1f 00 1a 	mcall	80004454 <prvCheckTasksWaitingTermination+0x78>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800043f0:	49 a8       	lddpc	r8,80004458 <prvCheckTasksWaitingTermination+0x7c>
800043f2:	70 08       	ld.w	r8,r8[0x0]
800043f4:	58 08       	cp.w	r8,0
800043f6:	5f 08       	sreq	r8
800043f8:	ef 48 ff f8 	st.w	r7[-8],r8
			xTaskResumeAll();
800043fc:	f0 1f 00 18 	mcall	8000445c <prvCheckTasksWaitingTermination+0x80>

			if( xListIsEmpty == pdFALSE )
80004400:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004404:	58 08       	cp.w	r8,0
80004406:	c2 11       	brne	80004448 <prvCheckTasksWaitingTermination+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80004408:	f0 1f 00 16 	mcall	80004460 <prvCheckTasksWaitingTermination+0x84>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
8000440c:	49 38       	lddpc	r8,80004458 <prvCheckTasksWaitingTermination+0x7c>
8000440e:	2f 88       	sub	r8,-8
80004410:	70 18       	ld.w	r8,r8[0x4]
80004412:	70 38       	ld.w	r8,r8[0xc]
80004414:	ef 48 ff fc 	st.w	r7[-4],r8
					vListRemove( &( pxTCB->xGenericListItem ) );
80004418:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000441c:	2f c8       	sub	r8,-4
8000441e:	10 9c       	mov	r12,r8
80004420:	f0 1f 00 11 	mcall	80004464 <prvCheckTasksWaitingTermination+0x88>
					--uxCurrentNumberOfTasks;
80004424:	49 18       	lddpc	r8,80004468 <prvCheckTasksWaitingTermination+0x8c>
80004426:	70 08       	ld.w	r8,r8[0x0]
80004428:	f0 c9 00 01 	sub	r9,r8,1
8000442c:	48 f8       	lddpc	r8,80004468 <prvCheckTasksWaitingTermination+0x8c>
8000442e:	91 09       	st.w	r8[0x0],r9
					--uxTasksDeleted;
80004430:	48 88       	lddpc	r8,80004450 <prvCheckTasksWaitingTermination+0x74>
80004432:	70 08       	ld.w	r8,r8[0x0]
80004434:	f0 c9 00 01 	sub	r9,r8,1
80004438:	48 68       	lddpc	r8,80004450 <prvCheckTasksWaitingTermination+0x74>
8000443a:	91 09       	st.w	r8[0x0],r9
				}
				taskEXIT_CRITICAL();
8000443c:	f0 1f 00 0c 	mcall	8000446c <prvCheckTasksWaitingTermination+0x90>

				prvDeleteTCB( pxTCB );
80004440:	ee fc ff fc 	ld.w	r12,r7[-4]
80004444:	f0 1f 00 0b 	mcall	80004470 <prvCheckTasksWaitingTermination+0x94>
			}
		}
	}
	#endif
}
80004448:	2f ed       	sub	sp,-8
8000444a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000444e:	00 00       	add	r0,r0
80004450:	00 00       	add	r0,r0
80004452:	07 18       	ld.sh	r8,r3++
80004454:	80 00       	ld.sh	r0,r0[0x0]
80004456:	3c e0       	mov	r0,-50
80004458:	00 00       	add	r0,r0
8000445a:	07 04       	ld.w	r4,r3++
8000445c:	80 00       	ld.sh	r0,r0[0x0]
8000445e:	3c fc       	mov	r12,-49
80004460:	80 00       	ld.sh	r0,r0[0x0]
80004462:	30 ac       	mov	r12,10
80004464:	80 00       	ld.sh	r0,r0[0x0]
80004466:	2e 96       	sub	r6,-23
80004468:	00 00       	add	r0,r0
8000446a:	07 30       	ld.ub	r0,r3++
8000446c:	80 00       	ld.sh	r0,r0[0x0]
8000446e:	30 c8       	mov	r8,12
80004470:	80 00       	ld.sh	r0,r0[0x0]
80004472:	45 88       	lddsp	r8,sp[0x160]

80004474 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80004474:	eb cd 40 80 	pushm	r7,lr
80004478:	1a 97       	mov	r7,sp
8000447a:	20 1d       	sub	sp,4
8000447c:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80004480:	49 78       	lddpc	r8,800044dc <prvAddCurrentTaskToDelayedList+0x68>
80004482:	70 08       	ld.w	r8,r8[0x0]
80004484:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004488:	91 19       	st.w	r8[0x4],r9

	if( xTimeToWake < xTickCount )
8000448a:	49 68       	lddpc	r8,800044e0 <prvAddCurrentTaskToDelayedList+0x6c>
8000448c:	70 08       	ld.w	r8,r8[0x0]
8000448e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004492:	10 39       	cp.w	r9,r8
80004494:	c0 c2       	brcc	800044ac <prvAddCurrentTaskToDelayedList+0x38>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004496:	49 28       	lddpc	r8,800044dc <prvAddCurrentTaskToDelayedList+0x68>
80004498:	70 08       	ld.w	r8,r8[0x0]
8000449a:	f0 c9 ff fc 	sub	r9,r8,-4
8000449e:	49 28       	lddpc	r8,800044e4 <prvAddCurrentTaskToDelayedList+0x70>
800044a0:	70 08       	ld.w	r8,r8[0x0]
800044a2:	12 9b       	mov	r11,r9
800044a4:	10 9c       	mov	r12,r8
800044a6:	f0 1f 00 11 	mcall	800044e8 <prvAddCurrentTaskToDelayedList+0x74>
800044aa:	c1 58       	rjmp	800044d4 <prvAddCurrentTaskToDelayedList+0x60>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800044ac:	48 c8       	lddpc	r8,800044dc <prvAddCurrentTaskToDelayedList+0x68>
800044ae:	70 08       	ld.w	r8,r8[0x0]
800044b0:	f0 c9 ff fc 	sub	r9,r8,-4
800044b4:	48 e8       	lddpc	r8,800044ec <prvAddCurrentTaskToDelayedList+0x78>
800044b6:	70 08       	ld.w	r8,r8[0x0]
800044b8:	12 9b       	mov	r11,r9
800044ba:	10 9c       	mov	r12,r8
800044bc:	f0 1f 00 0b 	mcall	800044e8 <prvAddCurrentTaskToDelayedList+0x74>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800044c0:	48 c8       	lddpc	r8,800044f0 <prvAddCurrentTaskToDelayedList+0x7c>
800044c2:	70 08       	ld.w	r8,r8[0x0]
800044c4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800044c8:	10 39       	cp.w	r9,r8
800044ca:	c0 52       	brcc	800044d4 <prvAddCurrentTaskToDelayedList+0x60>
		{
			xNextTaskUnblockTime = xTimeToWake;
800044cc:	48 98       	lddpc	r8,800044f0 <prvAddCurrentTaskToDelayedList+0x7c>
800044ce:	ee f9 ff fc 	ld.w	r9,r7[-4]
800044d2:	91 09       	st.w	r8[0x0],r9
		}
	}
}
800044d4:	2f fd       	sub	sp,-4
800044d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800044da:	00 00       	add	r0,r0
800044dc:	00 00       	add	r0,r0
800044de:	06 1c       	sub	r12,r3
800044e0:	00 00       	add	r0,r0
800044e2:	07 34       	ld.ub	r4,r3++
800044e4:	00 00       	add	r0,r0
800044e6:	06 ec       	st.h	--r3,r12
800044e8:	80 00       	ld.sh	r0,r0[0x0]
800044ea:	2d f4       	sub	r4,-33
800044ec:	00 00       	add	r0,r0
800044ee:	06 e8       	st.h	--r3,r8
800044f0:	00 00       	add	r0,r0
800044f2:	00 20       	rsub	r0,r0

800044f4 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
800044f4:	eb cd 40 80 	pushm	r7,lr
800044f8:	1a 97       	mov	r7,sp
800044fa:	20 3d       	sub	sp,12
800044fc:	18 98       	mov	r8,r12
800044fe:	ef 4b ff f4 	st.w	r7[-12],r11
80004502:	ef 58 ff f8 	st.h	r7[-8],r8
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80004506:	34 4c       	mov	r12,68
80004508:	f0 1f 00 1d 	mcall	8000457c <prvAllocateTCBAndStack+0x88>
8000450c:	18 98       	mov	r8,r12
8000450e:	ef 48 ff fc 	st.w	r7[-4],r8

	if( pxNewTCB != NULL )
80004512:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004516:	58 08       	cp.w	r8,0
80004518:	c2 c0       	breq	80004570 <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
8000451a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000451e:	58 08       	cp.w	r8,0
80004520:	c0 91       	brne	80004532 <prvAllocateTCBAndStack+0x3e>
80004522:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80004526:	a3 68       	lsl	r8,0x2
80004528:	10 9c       	mov	r12,r8
8000452a:	f0 1f 00 15 	mcall	8000457c <prvAllocateTCBAndStack+0x88>
8000452e:	18 98       	mov	r8,r12
80004530:	c0 38       	rjmp	80004536 <prvAllocateTCBAndStack+0x42>
80004532:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004536:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000453a:	93 c8       	st.w	r9[0x30],r8

		if( pxNewTCB->pxStack == NULL )
8000453c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004540:	70 c8       	ld.w	r8,r8[0x30]
80004542:	58 08       	cp.w	r8,0
80004544:	c0 91       	brne	80004556 <prvAllocateTCBAndStack+0x62>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80004546:	ee fc ff fc 	ld.w	r12,r7[-4]
8000454a:	f0 1f 00 0e 	mcall	80004580 <prvAllocateTCBAndStack+0x8c>
			pxNewTCB = NULL;
8000454e:	30 08       	mov	r8,0
80004550:	ef 48 ff fc 	st.w	r7[-4],r8
80004554:	c0 e8       	rjmp	80004570 <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80004556:	ef 18 ff f8 	ld.uh	r8,r7[-8]
8000455a:	f0 09 15 02 	lsl	r9,r8,0x2
8000455e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004562:	70 c8       	ld.w	r8,r8[0x30]
80004564:	12 9a       	mov	r10,r9
80004566:	e0 6b 00 a5 	mov	r11,165
8000456a:	10 9c       	mov	r12,r8
8000456c:	f0 1f 00 06 	mcall	80004584 <prvAllocateTCBAndStack+0x90>
		}
	}

	return pxNewTCB;
80004570:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80004574:	10 9c       	mov	r12,r8
80004576:	2f dd       	sub	sp,-12
80004578:	e3 cd 80 80 	ldm	sp++,r7,pc
8000457c:	80 00       	ld.sh	r0,r0[0x0]
8000457e:	33 38       	mov	r8,51
80004580:	80 00       	ld.sh	r0,r0[0x0]
80004582:	33 74       	mov	r4,55
80004584:	80 00       	ld.sh	r0,r0[0x0]
80004586:	4b 80       	lddpc	r0,80004664 <_malloc_r+0x60>

80004588 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
80004588:	eb cd 40 80 	pushm	r7,lr
8000458c:	1a 97       	mov	r7,sp
8000458e:	20 1d       	sub	sp,4
80004590:	ef 4c ff fc 	st.w	r7[-4],r12
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80004594:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004598:	70 c8       	ld.w	r8,r8[0x30]
8000459a:	10 9c       	mov	r12,r8
8000459c:	f0 1f 00 05 	mcall	800045b0 <prvDeleteTCB+0x28>
		vPortFree( pxTCB );
800045a0:	ee fc ff fc 	ld.w	r12,r7[-4]
800045a4:	f0 1f 00 03 	mcall	800045b0 <prvDeleteTCB+0x28>
	}
800045a8:	2f fd       	sub	sp,-4
800045aa:	e3 cd 80 80 	ldm	sp++,r7,pc
800045ae:	00 00       	add	r0,r0
800045b0:	80 00       	ld.sh	r0,r0[0x0]
800045b2:	33 74       	mov	r4,55

800045b4 <atexit>:
800045b4:	d4 01       	pushm	lr
800045b6:	30 09       	mov	r9,0
800045b8:	18 9b       	mov	r11,r12
800045ba:	12 9a       	mov	r10,r9
800045bc:	12 9c       	mov	r12,r9
800045be:	e0 a0 03 39 	rcall	80004c30 <__register_exitproc>
800045c2:	d8 02       	popm	pc

800045c4 <exit>:
800045c4:	d4 21       	pushm	r4-r7,lr
800045c6:	30 0b       	mov	r11,0
800045c8:	18 97       	mov	r7,r12
800045ca:	e0 a0 03 85 	rcall	80004cd4 <__call_exitprocs>
800045ce:	fe c8 f2 ca 	sub	r8,pc,-3382
800045d2:	70 0c       	ld.w	r12,r8[0x0]
800045d4:	78 a8       	ld.w	r8,r12[0x28]
800045d6:	58 08       	cp.w	r8,0
800045d8:	c0 20       	breq	800045dc <exit+0x18>
800045da:	5d 18       	icall	r8
800045dc:	0e 9c       	mov	r12,r7
800045de:	e0 a0 03 08 	rcall	80004bee <_exit>
800045e2:	d7 03       	nop

800045e4 <free>:
800045e4:	d4 01       	pushm	lr
800045e6:	e0 68 01 14 	mov	r8,276
800045ea:	18 9b       	mov	r11,r12
800045ec:	70 0c       	ld.w	r12,r8[0x0]
800045ee:	e0 a0 04 27 	rcall	80004e3c <_free_r>
800045f2:	d8 02       	popm	pc

800045f4 <malloc>:
800045f4:	d4 01       	pushm	lr
800045f6:	e0 68 01 14 	mov	r8,276
800045fa:	18 9b       	mov	r11,r12
800045fc:	70 0c       	ld.w	r12,r8[0x0]
800045fe:	c0 3c       	rcall	80004604 <_malloc_r>
80004600:	d8 02       	popm	pc
80004602:	d7 03       	nop

80004604 <_malloc_r>:
80004604:	d4 31       	pushm	r0-r7,lr
80004606:	f6 c8 ff f5 	sub	r8,r11,-11
8000460a:	18 95       	mov	r5,r12
8000460c:	10 97       	mov	r7,r8
8000460e:	e0 17 ff f8 	andl	r7,0xfff8
80004612:	59 68       	cp.w	r8,22
80004614:	f9 b7 08 10 	movls	r7,16
80004618:	16 37       	cp.w	r7,r11
8000461a:	5f 38       	srlo	r8
8000461c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80004620:	c0 50       	breq	8000462a <_malloc_r+0x26>
80004622:	30 c8       	mov	r8,12
80004624:	99 38       	st.w	r12[0xc],r8
80004626:	e0 8f 01 f8 	bral	80004a16 <_malloc_r+0x412>
8000462a:	fe b0 f4 97 	rcall	80002f58 <__malloc_lock>
8000462e:	e0 47 01 f7 	cp.w	r7,503
80004632:	e0 8b 00 1d 	brhi	8000466c <_malloc_r+0x68>
80004636:	ee 03 16 03 	lsr	r3,r7,0x3
8000463a:	e0 68 01 18 	mov	r8,280
8000463e:	f0 03 00 38 	add	r8,r8,r3<<0x3
80004642:	70 36       	ld.w	r6,r8[0xc]
80004644:	10 36       	cp.w	r6,r8
80004646:	c0 61       	brne	80004652 <_malloc_r+0x4e>
80004648:	ec c8 ff f8 	sub	r8,r6,-8
8000464c:	70 36       	ld.w	r6,r8[0xc]
8000464e:	10 36       	cp.w	r6,r8
80004650:	c0 c0       	breq	80004668 <_malloc_r+0x64>
80004652:	6c 18       	ld.w	r8,r6[0x4]
80004654:	e0 18 ff fc 	andl	r8,0xfffc
80004658:	6c 3a       	ld.w	r10,r6[0xc]
8000465a:	ec 08 00 09 	add	r9,r6,r8
8000465e:	0a 9c       	mov	r12,r5
80004660:	6c 28       	ld.w	r8,r6[0x8]
80004662:	95 28       	st.w	r10[0x8],r8
80004664:	91 3a       	st.w	r8[0xc],r10
80004666:	c4 78       	rjmp	800046f4 <_malloc_r+0xf0>
80004668:	2f e3       	sub	r3,-2
8000466a:	c4 d8       	rjmp	80004704 <_malloc_r+0x100>
8000466c:	ee 03 16 09 	lsr	r3,r7,0x9
80004670:	c0 41       	brne	80004678 <_malloc_r+0x74>
80004672:	ee 03 16 03 	lsr	r3,r7,0x3
80004676:	c2 68       	rjmp	800046c2 <_malloc_r+0xbe>
80004678:	58 43       	cp.w	r3,4
8000467a:	e0 8b 00 06 	brhi	80004686 <_malloc_r+0x82>
8000467e:	ee 03 16 06 	lsr	r3,r7,0x6
80004682:	2c 83       	sub	r3,-56
80004684:	c1 f8       	rjmp	800046c2 <_malloc_r+0xbe>
80004686:	59 43       	cp.w	r3,20
80004688:	e0 8b 00 04 	brhi	80004690 <_malloc_r+0x8c>
8000468c:	2a 53       	sub	r3,-91
8000468e:	c1 a8       	rjmp	800046c2 <_malloc_r+0xbe>
80004690:	e0 43 00 54 	cp.w	r3,84
80004694:	e0 8b 00 06 	brhi	800046a0 <_malloc_r+0x9c>
80004698:	ee 03 16 0c 	lsr	r3,r7,0xc
8000469c:	29 23       	sub	r3,-110
8000469e:	c1 28       	rjmp	800046c2 <_malloc_r+0xbe>
800046a0:	e0 43 01 54 	cp.w	r3,340
800046a4:	e0 8b 00 06 	brhi	800046b0 <_malloc_r+0xac>
800046a8:	ee 03 16 0f 	lsr	r3,r7,0xf
800046ac:	28 93       	sub	r3,-119
800046ae:	c0 a8       	rjmp	800046c2 <_malloc_r+0xbe>
800046b0:	e0 43 05 54 	cp.w	r3,1364
800046b4:	e0 88 00 04 	brls	800046bc <_malloc_r+0xb8>
800046b8:	37 e3       	mov	r3,126
800046ba:	c0 48       	rjmp	800046c2 <_malloc_r+0xbe>
800046bc:	ee 03 16 12 	lsr	r3,r7,0x12
800046c0:	28 43       	sub	r3,-124
800046c2:	e0 6a 01 18 	mov	r10,280
800046c6:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800046ca:	74 36       	ld.w	r6,r10[0xc]
800046cc:	c1 98       	rjmp	800046fe <_malloc_r+0xfa>
800046ce:	6c 19       	ld.w	r9,r6[0x4]
800046d0:	e0 19 ff fc 	andl	r9,0xfffc
800046d4:	f2 07 01 0b 	sub	r11,r9,r7
800046d8:	58 fb       	cp.w	r11,15
800046da:	e0 8a 00 04 	brle	800046e2 <_malloc_r+0xde>
800046de:	20 13       	sub	r3,1
800046e0:	c1 18       	rjmp	80004702 <_malloc_r+0xfe>
800046e2:	6c 38       	ld.w	r8,r6[0xc]
800046e4:	58 0b       	cp.w	r11,0
800046e6:	c0 b5       	brlt	800046fc <_malloc_r+0xf8>
800046e8:	6c 2a       	ld.w	r10,r6[0x8]
800046ea:	ec 09 00 09 	add	r9,r6,r9
800046ee:	0a 9c       	mov	r12,r5
800046f0:	91 2a       	st.w	r8[0x8],r10
800046f2:	95 38       	st.w	r10[0xc],r8
800046f4:	72 18       	ld.w	r8,r9[0x4]
800046f6:	a1 a8       	sbr	r8,0x0
800046f8:	93 18       	st.w	r9[0x4],r8
800046fa:	cb c8       	rjmp	80004872 <_malloc_r+0x26e>
800046fc:	10 96       	mov	r6,r8
800046fe:	14 36       	cp.w	r6,r10
80004700:	ce 71       	brne	800046ce <_malloc_r+0xca>
80004702:	2f f3       	sub	r3,-1
80004704:	e0 6a 01 18 	mov	r10,280
80004708:	f4 cc ff f8 	sub	r12,r10,-8
8000470c:	78 26       	ld.w	r6,r12[0x8]
8000470e:	18 36       	cp.w	r6,r12
80004710:	c6 c0       	breq	800047e8 <_malloc_r+0x1e4>
80004712:	6c 19       	ld.w	r9,r6[0x4]
80004714:	e0 19 ff fc 	andl	r9,0xfffc
80004718:	f2 07 01 08 	sub	r8,r9,r7
8000471c:	58 f8       	cp.w	r8,15
8000471e:	e0 89 00 8f 	brgt	8000483c <_malloc_r+0x238>
80004722:	99 3c       	st.w	r12[0xc],r12
80004724:	99 2c       	st.w	r12[0x8],r12
80004726:	58 08       	cp.w	r8,0
80004728:	c0 55       	brlt	80004732 <_malloc_r+0x12e>
8000472a:	ec 09 00 09 	add	r9,r6,r9
8000472e:	0a 9c       	mov	r12,r5
80004730:	ce 2b       	rjmp	800046f4 <_malloc_r+0xf0>
80004732:	e0 49 01 ff 	cp.w	r9,511
80004736:	e0 8b 00 13 	brhi	8000475c <_malloc_r+0x158>
8000473a:	a3 99       	lsr	r9,0x3
8000473c:	f4 09 00 38 	add	r8,r10,r9<<0x3
80004740:	70 2b       	ld.w	r11,r8[0x8]
80004742:	8d 38       	st.w	r6[0xc],r8
80004744:	8d 2b       	st.w	r6[0x8],r11
80004746:	97 36       	st.w	r11[0xc],r6
80004748:	91 26       	st.w	r8[0x8],r6
8000474a:	a3 49       	asr	r9,0x2
8000474c:	74 18       	ld.w	r8,r10[0x4]
8000474e:	30 1b       	mov	r11,1
80004750:	f6 09 09 49 	lsl	r9,r11,r9
80004754:	f1 e9 10 09 	or	r9,r8,r9
80004758:	95 19       	st.w	r10[0x4],r9
8000475a:	c4 78       	rjmp	800047e8 <_malloc_r+0x1e4>
8000475c:	f2 0a 16 09 	lsr	r10,r9,0x9
80004760:	58 4a       	cp.w	r10,4
80004762:	e0 8b 00 07 	brhi	80004770 <_malloc_r+0x16c>
80004766:	f2 0a 16 06 	lsr	r10,r9,0x6
8000476a:	2c 8a       	sub	r10,-56
8000476c:	c2 08       	rjmp	800047ac <_malloc_r+0x1a8>
8000476e:	d7 03       	nop
80004770:	59 4a       	cp.w	r10,20
80004772:	e0 8b 00 04 	brhi	8000477a <_malloc_r+0x176>
80004776:	2a 5a       	sub	r10,-91
80004778:	c1 a8       	rjmp	800047ac <_malloc_r+0x1a8>
8000477a:	e0 4a 00 54 	cp.w	r10,84
8000477e:	e0 8b 00 06 	brhi	8000478a <_malloc_r+0x186>
80004782:	f2 0a 16 0c 	lsr	r10,r9,0xc
80004786:	29 2a       	sub	r10,-110
80004788:	c1 28       	rjmp	800047ac <_malloc_r+0x1a8>
8000478a:	e0 4a 01 54 	cp.w	r10,340
8000478e:	e0 8b 00 06 	brhi	8000479a <_malloc_r+0x196>
80004792:	f2 0a 16 0f 	lsr	r10,r9,0xf
80004796:	28 9a       	sub	r10,-119
80004798:	c0 a8       	rjmp	800047ac <_malloc_r+0x1a8>
8000479a:	e0 4a 05 54 	cp.w	r10,1364
8000479e:	e0 88 00 04 	brls	800047a6 <_malloc_r+0x1a2>
800047a2:	37 ea       	mov	r10,126
800047a4:	c0 48       	rjmp	800047ac <_malloc_r+0x1a8>
800047a6:	f2 0a 16 12 	lsr	r10,r9,0x12
800047aa:	28 4a       	sub	r10,-124
800047ac:	e0 6b 01 18 	mov	r11,280
800047b0:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800047b4:	68 28       	ld.w	r8,r4[0x8]
800047b6:	08 38       	cp.w	r8,r4
800047b8:	c0 e1       	brne	800047d4 <_malloc_r+0x1d0>
800047ba:	76 19       	ld.w	r9,r11[0x4]
800047bc:	a3 4a       	asr	r10,0x2
800047be:	30 1e       	mov	lr,1
800047c0:	fc 0a 09 4a 	lsl	r10,lr,r10
800047c4:	f3 ea 10 0a 	or	r10,r9,r10
800047c8:	10 99       	mov	r9,r8
800047ca:	97 1a       	st.w	r11[0x4],r10
800047cc:	c0 a8       	rjmp	800047e0 <_malloc_r+0x1dc>
800047ce:	70 28       	ld.w	r8,r8[0x8]
800047d0:	08 38       	cp.w	r8,r4
800047d2:	c0 60       	breq	800047de <_malloc_r+0x1da>
800047d4:	70 1a       	ld.w	r10,r8[0x4]
800047d6:	e0 1a ff fc 	andl	r10,0xfffc
800047da:	14 39       	cp.w	r9,r10
800047dc:	cf 93       	brcs	800047ce <_malloc_r+0x1ca>
800047de:	70 39       	ld.w	r9,r8[0xc]
800047e0:	8d 39       	st.w	r6[0xc],r9
800047e2:	8d 28       	st.w	r6[0x8],r8
800047e4:	91 36       	st.w	r8[0xc],r6
800047e6:	93 26       	st.w	r9[0x8],r6
800047e8:	e6 08 14 02 	asr	r8,r3,0x2
800047ec:	30 1b       	mov	r11,1
800047ee:	e0 64 01 18 	mov	r4,280
800047f2:	f6 08 09 4b 	lsl	r11,r11,r8
800047f6:	68 18       	ld.w	r8,r4[0x4]
800047f8:	10 3b       	cp.w	r11,r8
800047fa:	e0 8b 00 6b 	brhi	800048d0 <_malloc_r+0x2cc>
800047fe:	f7 e8 00 09 	and	r9,r11,r8
80004802:	c0 b1       	brne	80004818 <_malloc_r+0x214>
80004804:	e0 13 ff fc 	andl	r3,0xfffc
80004808:	a1 7b       	lsl	r11,0x1
8000480a:	2f c3       	sub	r3,-4
8000480c:	c0 38       	rjmp	80004812 <_malloc_r+0x20e>
8000480e:	2f c3       	sub	r3,-4
80004810:	a1 7b       	lsl	r11,0x1
80004812:	f7 e8 00 09 	and	r9,r11,r8
80004816:	cf c0       	breq	8000480e <_malloc_r+0x20a>
80004818:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000481c:	06 92       	mov	r2,r3
8000481e:	1c 91       	mov	r1,lr
80004820:	62 36       	ld.w	r6,r1[0xc]
80004822:	c2 e8       	rjmp	8000487e <_malloc_r+0x27a>
80004824:	6c 1a       	ld.w	r10,r6[0x4]
80004826:	e0 1a ff fc 	andl	r10,0xfffc
8000482a:	f4 07 01 08 	sub	r8,r10,r7
8000482e:	58 f8       	cp.w	r8,15
80004830:	e0 8a 00 15 	brle	8000485a <_malloc_r+0x256>
80004834:	6c 3a       	ld.w	r10,r6[0xc]
80004836:	6c 29       	ld.w	r9,r6[0x8]
80004838:	95 29       	st.w	r10[0x8],r9
8000483a:	93 3a       	st.w	r9[0xc],r10
8000483c:	0e 99       	mov	r9,r7
8000483e:	ec 07 00 07 	add	r7,r6,r7
80004842:	a1 a9       	sbr	r9,0x0
80004844:	99 37       	st.w	r12[0xc],r7
80004846:	99 27       	st.w	r12[0x8],r7
80004848:	8d 19       	st.w	r6[0x4],r9
8000484a:	ee 08 09 08 	st.w	r7[r8],r8
8000484e:	8f 2c       	st.w	r7[0x8],r12
80004850:	8f 3c       	st.w	r7[0xc],r12
80004852:	a1 a8       	sbr	r8,0x0
80004854:	0a 9c       	mov	r12,r5
80004856:	8f 18       	st.w	r7[0x4],r8
80004858:	c0 d8       	rjmp	80004872 <_malloc_r+0x26e>
8000485a:	6c 39       	ld.w	r9,r6[0xc]
8000485c:	58 08       	cp.w	r8,0
8000485e:	c0 f5       	brlt	8000487c <_malloc_r+0x278>
80004860:	ec 0a 00 0a 	add	r10,r6,r10
80004864:	74 18       	ld.w	r8,r10[0x4]
80004866:	a1 a8       	sbr	r8,0x0
80004868:	0a 9c       	mov	r12,r5
8000486a:	95 18       	st.w	r10[0x4],r8
8000486c:	6c 28       	ld.w	r8,r6[0x8]
8000486e:	93 28       	st.w	r9[0x8],r8
80004870:	91 39       	st.w	r8[0xc],r9
80004872:	fe b0 f3 81 	rcall	80002f74 <__malloc_unlock>
80004876:	ec cc ff f8 	sub	r12,r6,-8
8000487a:	d8 32       	popm	r0-r7,pc
8000487c:	12 96       	mov	r6,r9
8000487e:	02 36       	cp.w	r6,r1
80004880:	cd 21       	brne	80004824 <_malloc_r+0x220>
80004882:	2f f2       	sub	r2,-1
80004884:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80004888:	c0 30       	breq	8000488e <_malloc_r+0x28a>
8000488a:	2f 81       	sub	r1,-8
8000488c:	cc ab       	rjmp	80004820 <_malloc_r+0x21c>
8000488e:	1c 98       	mov	r8,lr
80004890:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80004894:	c0 81       	brne	800048a4 <_malloc_r+0x2a0>
80004896:	68 19       	ld.w	r9,r4[0x4]
80004898:	f6 08 11 ff 	rsub	r8,r11,-1
8000489c:	f3 e8 00 08 	and	r8,r9,r8
800048a0:	89 18       	st.w	r4[0x4],r8
800048a2:	c0 78       	rjmp	800048b0 <_malloc_r+0x2ac>
800048a4:	f0 c9 00 08 	sub	r9,r8,8
800048a8:	20 13       	sub	r3,1
800048aa:	70 08       	ld.w	r8,r8[0x0]
800048ac:	12 38       	cp.w	r8,r9
800048ae:	cf 10       	breq	80004890 <_malloc_r+0x28c>
800048b0:	a1 7b       	lsl	r11,0x1
800048b2:	68 18       	ld.w	r8,r4[0x4]
800048b4:	10 3b       	cp.w	r11,r8
800048b6:	e0 8b 00 0d 	brhi	800048d0 <_malloc_r+0x2cc>
800048ba:	58 0b       	cp.w	r11,0
800048bc:	c0 a0       	breq	800048d0 <_malloc_r+0x2cc>
800048be:	04 93       	mov	r3,r2
800048c0:	c0 38       	rjmp	800048c6 <_malloc_r+0x2c2>
800048c2:	2f c3       	sub	r3,-4
800048c4:	a1 7b       	lsl	r11,0x1
800048c6:	f7 e8 00 09 	and	r9,r11,r8
800048ca:	ca 71       	brne	80004818 <_malloc_r+0x214>
800048cc:	cf bb       	rjmp	800048c2 <_malloc_r+0x2be>
800048ce:	d7 03       	nop
800048d0:	68 23       	ld.w	r3,r4[0x8]
800048d2:	66 12       	ld.w	r2,r3[0x4]
800048d4:	e0 12 ff fc 	andl	r2,0xfffc
800048d8:	0e 32       	cp.w	r2,r7
800048da:	5f 39       	srlo	r9
800048dc:	e4 07 01 08 	sub	r8,r2,r7
800048e0:	58 f8       	cp.w	r8,15
800048e2:	5f aa       	srle	r10
800048e4:	f5 e9 10 09 	or	r9,r10,r9
800048e8:	e0 80 00 98 	breq	80004a18 <_malloc_r+0x414>
800048ec:	e0 68 07 60 	mov	r8,1888
800048f0:	70 01       	ld.w	r1,r8[0x0]
800048f2:	e0 68 05 24 	mov	r8,1316
800048f6:	2f 01       	sub	r1,-16
800048f8:	70 08       	ld.w	r8,r8[0x0]
800048fa:	0e 01       	add	r1,r7
800048fc:	5b f8       	cp.w	r8,-1
800048fe:	c0 40       	breq	80004906 <_malloc_r+0x302>
80004900:	28 11       	sub	r1,-127
80004902:	e0 11 ff 80 	andl	r1,0xff80
80004906:	02 9b       	mov	r11,r1
80004908:	0a 9c       	mov	r12,r5
8000490a:	c4 3d       	rcall	80004b90 <_sbrk_r>
8000490c:	18 96       	mov	r6,r12
8000490e:	5b fc       	cp.w	r12,-1
80004910:	c7 40       	breq	800049f8 <_malloc_r+0x3f4>
80004912:	e6 02 00 08 	add	r8,r3,r2
80004916:	10 3c       	cp.w	r12,r8
80004918:	c0 32       	brcc	8000491e <_malloc_r+0x31a>
8000491a:	08 33       	cp.w	r3,r4
8000491c:	c6 e1       	brne	800049f8 <_malloc_r+0x3f4>
8000491e:	e0 6a 07 64 	mov	r10,1892
80004922:	74 09       	ld.w	r9,r10[0x0]
80004924:	e2 09 00 09 	add	r9,r1,r9
80004928:	95 09       	st.w	r10[0x0],r9
8000492a:	10 36       	cp.w	r6,r8
8000492c:	c0 a1       	brne	80004940 <_malloc_r+0x33c>
8000492e:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80004932:	c0 71       	brne	80004940 <_malloc_r+0x33c>
80004934:	e2 02 00 02 	add	r2,r1,r2
80004938:	68 28       	ld.w	r8,r4[0x8]
8000493a:	a1 a2       	sbr	r2,0x0
8000493c:	91 12       	st.w	r8[0x4],r2
8000493e:	c4 e8       	rjmp	800049da <_malloc_r+0x3d6>
80004940:	e0 6a 05 24 	mov	r10,1316
80004944:	74 0b       	ld.w	r11,r10[0x0]
80004946:	5b fb       	cp.w	r11,-1
80004948:	c0 31       	brne	8000494e <_malloc_r+0x34a>
8000494a:	95 06       	st.w	r10[0x0],r6
8000494c:	c0 78       	rjmp	8000495a <_malloc_r+0x356>
8000494e:	ec 09 00 09 	add	r9,r6,r9
80004952:	e0 6a 07 64 	mov	r10,1892
80004956:	10 19       	sub	r9,r8
80004958:	95 09       	st.w	r10[0x0],r9
8000495a:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000495e:	f0 09 11 08 	rsub	r9,r8,8
80004962:	58 08       	cp.w	r8,0
80004964:	f2 08 17 10 	movne	r8,r9
80004968:	ed d8 e1 06 	addne	r6,r6,r8
8000496c:	28 08       	sub	r8,-128
8000496e:	ec 01 00 01 	add	r1,r6,r1
80004972:	0a 9c       	mov	r12,r5
80004974:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80004978:	f0 01 01 01 	sub	r1,r8,r1
8000497c:	02 9b       	mov	r11,r1
8000497e:	c0 9d       	rcall	80004b90 <_sbrk_r>
80004980:	e0 68 07 64 	mov	r8,1892
80004984:	5b fc       	cp.w	r12,-1
80004986:	ec 0c 17 00 	moveq	r12,r6
8000498a:	f9 b1 00 00 	moveq	r1,0
8000498e:	70 09       	ld.w	r9,r8[0x0]
80004990:	0c 1c       	sub	r12,r6
80004992:	89 26       	st.w	r4[0x8],r6
80004994:	02 0c       	add	r12,r1
80004996:	12 01       	add	r1,r9
80004998:	a1 ac       	sbr	r12,0x0
8000499a:	91 01       	st.w	r8[0x0],r1
8000499c:	8d 1c       	st.w	r6[0x4],r12
8000499e:	08 33       	cp.w	r3,r4
800049a0:	c1 d0       	breq	800049da <_malloc_r+0x3d6>
800049a2:	58 f2       	cp.w	r2,15
800049a4:	e0 8b 00 05 	brhi	800049ae <_malloc_r+0x3aa>
800049a8:	30 18       	mov	r8,1
800049aa:	8d 18       	st.w	r6[0x4],r8
800049ac:	c2 68       	rjmp	800049f8 <_malloc_r+0x3f4>
800049ae:	30 59       	mov	r9,5
800049b0:	20 c2       	sub	r2,12
800049b2:	e0 12 ff f8 	andl	r2,0xfff8
800049b6:	e6 02 00 08 	add	r8,r3,r2
800049ba:	91 29       	st.w	r8[0x8],r9
800049bc:	91 19       	st.w	r8[0x4],r9
800049be:	66 18       	ld.w	r8,r3[0x4]
800049c0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800049c4:	e5 e8 10 08 	or	r8,r2,r8
800049c8:	87 18       	st.w	r3[0x4],r8
800049ca:	58 f2       	cp.w	r2,15
800049cc:	e0 88 00 07 	brls	800049da <_malloc_r+0x3d6>
800049d0:	e6 cb ff f8 	sub	r11,r3,-8
800049d4:	0a 9c       	mov	r12,r5
800049d6:	e0 a0 02 33 	rcall	80004e3c <_free_r>
800049da:	e0 69 07 5c 	mov	r9,1884
800049de:	72 0a       	ld.w	r10,r9[0x0]
800049e0:	e0 68 07 64 	mov	r8,1892
800049e4:	70 08       	ld.w	r8,r8[0x0]
800049e6:	14 38       	cp.w	r8,r10
800049e8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800049ec:	e0 69 07 58 	mov	r9,1880
800049f0:	72 0a       	ld.w	r10,r9[0x0]
800049f2:	14 38       	cp.w	r8,r10
800049f4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800049f8:	68 28       	ld.w	r8,r4[0x8]
800049fa:	70 18       	ld.w	r8,r8[0x4]
800049fc:	e0 18 ff fc 	andl	r8,0xfffc
80004a00:	0e 38       	cp.w	r8,r7
80004a02:	5f 39       	srlo	r9
80004a04:	0e 18       	sub	r8,r7
80004a06:	58 f8       	cp.w	r8,15
80004a08:	5f aa       	srle	r10
80004a0a:	f5 e9 10 09 	or	r9,r10,r9
80004a0e:	c0 50       	breq	80004a18 <_malloc_r+0x414>
80004a10:	0a 9c       	mov	r12,r5
80004a12:	fe b0 f2 b1 	rcall	80002f74 <__malloc_unlock>
80004a16:	d8 3a       	popm	r0-r7,pc,r12=0
80004a18:	68 26       	ld.w	r6,r4[0x8]
80004a1a:	a1 a8       	sbr	r8,0x0
80004a1c:	0e 99       	mov	r9,r7
80004a1e:	a1 a9       	sbr	r9,0x0
80004a20:	8d 19       	st.w	r6[0x4],r9
80004a22:	ec 07 00 07 	add	r7,r6,r7
80004a26:	0a 9c       	mov	r12,r5
80004a28:	89 27       	st.w	r4[0x8],r7
80004a2a:	8f 18       	st.w	r7[0x4],r8
80004a2c:	fe b0 f2 a4 	rcall	80002f74 <__malloc_unlock>
80004a30:	ec cc ff f8 	sub	r12,r6,-8
80004a34:	d8 32       	popm	r0-r7,pc
80004a36:	d7 03       	nop

80004a38 <memcpy>:
80004a38:	58 8a       	cp.w	r10,8
80004a3a:	c2 f5       	brlt	80004a98 <memcpy+0x60>
80004a3c:	f9 eb 10 09 	or	r9,r12,r11
80004a40:	e2 19 00 03 	andl	r9,0x3,COH
80004a44:	e0 81 00 97 	brne	80004b72 <memcpy+0x13a>
80004a48:	e0 4a 00 20 	cp.w	r10,32
80004a4c:	c3 b4       	brge	80004ac2 <memcpy+0x8a>
80004a4e:	f4 08 14 02 	asr	r8,r10,0x2
80004a52:	f0 09 11 08 	rsub	r9,r8,8
80004a56:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80004a5a:	76 69       	ld.w	r9,r11[0x18]
80004a5c:	99 69       	st.w	r12[0x18],r9
80004a5e:	76 59       	ld.w	r9,r11[0x14]
80004a60:	99 59       	st.w	r12[0x14],r9
80004a62:	76 49       	ld.w	r9,r11[0x10]
80004a64:	99 49       	st.w	r12[0x10],r9
80004a66:	76 39       	ld.w	r9,r11[0xc]
80004a68:	99 39       	st.w	r12[0xc],r9
80004a6a:	76 29       	ld.w	r9,r11[0x8]
80004a6c:	99 29       	st.w	r12[0x8],r9
80004a6e:	76 19       	ld.w	r9,r11[0x4]
80004a70:	99 19       	st.w	r12[0x4],r9
80004a72:	76 09       	ld.w	r9,r11[0x0]
80004a74:	99 09       	st.w	r12[0x0],r9
80004a76:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80004a7a:	f8 08 00 28 	add	r8,r12,r8<<0x2
80004a7e:	e0 1a 00 03 	andl	r10,0x3
80004a82:	f4 0a 11 04 	rsub	r10,r10,4
80004a86:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80004a8a:	17 a9       	ld.ub	r9,r11[0x2]
80004a8c:	b0 a9       	st.b	r8[0x2],r9
80004a8e:	17 99       	ld.ub	r9,r11[0x1]
80004a90:	b0 99       	st.b	r8[0x1],r9
80004a92:	17 89       	ld.ub	r9,r11[0x0]
80004a94:	b0 89       	st.b	r8[0x0],r9
80004a96:	5e fc       	retal	r12
80004a98:	f4 0a 11 09 	rsub	r10,r10,9
80004a9c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80004aa0:	17 f9       	ld.ub	r9,r11[0x7]
80004aa2:	b8 f9       	st.b	r12[0x7],r9
80004aa4:	17 e9       	ld.ub	r9,r11[0x6]
80004aa6:	b8 e9       	st.b	r12[0x6],r9
80004aa8:	17 d9       	ld.ub	r9,r11[0x5]
80004aaa:	b8 d9       	st.b	r12[0x5],r9
80004aac:	17 c9       	ld.ub	r9,r11[0x4]
80004aae:	b8 c9       	st.b	r12[0x4],r9
80004ab0:	17 b9       	ld.ub	r9,r11[0x3]
80004ab2:	b8 b9       	st.b	r12[0x3],r9
80004ab4:	17 a9       	ld.ub	r9,r11[0x2]
80004ab6:	b8 a9       	st.b	r12[0x2],r9
80004ab8:	17 99       	ld.ub	r9,r11[0x1]
80004aba:	b8 99       	st.b	r12[0x1],r9
80004abc:	17 89       	ld.ub	r9,r11[0x0]
80004abe:	b8 89       	st.b	r12[0x0],r9
80004ac0:	5e fc       	retal	r12
80004ac2:	eb cd 40 c0 	pushm	r6-r7,lr
80004ac6:	18 99       	mov	r9,r12
80004ac8:	22 0a       	sub	r10,32
80004aca:	b7 07       	ld.d	r6,r11++
80004acc:	b3 26       	st.d	r9++,r6
80004ace:	b7 07       	ld.d	r6,r11++
80004ad0:	b3 26       	st.d	r9++,r6
80004ad2:	b7 07       	ld.d	r6,r11++
80004ad4:	b3 26       	st.d	r9++,r6
80004ad6:	b7 07       	ld.d	r6,r11++
80004ad8:	b3 26       	st.d	r9++,r6
80004ada:	22 0a       	sub	r10,32
80004adc:	cf 74       	brge	80004aca <memcpy+0x92>
80004ade:	2f 0a       	sub	r10,-16
80004ae0:	c0 65       	brlt	80004aec <memcpy+0xb4>
80004ae2:	b7 07       	ld.d	r6,r11++
80004ae4:	b3 26       	st.d	r9++,r6
80004ae6:	b7 07       	ld.d	r6,r11++
80004ae8:	b3 26       	st.d	r9++,r6
80004aea:	21 0a       	sub	r10,16
80004aec:	5c 3a       	neg	r10
80004aee:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80004af2:	d7 03       	nop
80004af4:	d7 03       	nop
80004af6:	f7 36 00 0e 	ld.ub	r6,r11[14]
80004afa:	f3 66 00 0e 	st.b	r9[14],r6
80004afe:	f7 36 00 0d 	ld.ub	r6,r11[13]
80004b02:	f3 66 00 0d 	st.b	r9[13],r6
80004b06:	f7 36 00 0c 	ld.ub	r6,r11[12]
80004b0a:	f3 66 00 0c 	st.b	r9[12],r6
80004b0e:	f7 36 00 0b 	ld.ub	r6,r11[11]
80004b12:	f3 66 00 0b 	st.b	r9[11],r6
80004b16:	f7 36 00 0a 	ld.ub	r6,r11[10]
80004b1a:	f3 66 00 0a 	st.b	r9[10],r6
80004b1e:	f7 36 00 09 	ld.ub	r6,r11[9]
80004b22:	f3 66 00 09 	st.b	r9[9],r6
80004b26:	f7 36 00 08 	ld.ub	r6,r11[8]
80004b2a:	f3 66 00 08 	st.b	r9[8],r6
80004b2e:	f7 36 00 07 	ld.ub	r6,r11[7]
80004b32:	f3 66 00 07 	st.b	r9[7],r6
80004b36:	f7 36 00 06 	ld.ub	r6,r11[6]
80004b3a:	f3 66 00 06 	st.b	r9[6],r6
80004b3e:	f7 36 00 05 	ld.ub	r6,r11[5]
80004b42:	f3 66 00 05 	st.b	r9[5],r6
80004b46:	f7 36 00 04 	ld.ub	r6,r11[4]
80004b4a:	f3 66 00 04 	st.b	r9[4],r6
80004b4e:	f7 36 00 03 	ld.ub	r6,r11[3]
80004b52:	f3 66 00 03 	st.b	r9[3],r6
80004b56:	f7 36 00 02 	ld.ub	r6,r11[2]
80004b5a:	f3 66 00 02 	st.b	r9[2],r6
80004b5e:	f7 36 00 01 	ld.ub	r6,r11[1]
80004b62:	f3 66 00 01 	st.b	r9[1],r6
80004b66:	f7 36 00 00 	ld.ub	r6,r11[0]
80004b6a:	f3 66 00 00 	st.b	r9[0],r6
80004b6e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b72:	20 1a       	sub	r10,1
80004b74:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80004b78:	f8 0a 0b 09 	st.b	r12[r10],r9
80004b7c:	cf b1       	brne	80004b72 <memcpy+0x13a>
80004b7e:	5e fc       	retal	r12

80004b80 <memset>:
80004b80:	18 98       	mov	r8,r12
80004b82:	c0 38       	rjmp	80004b88 <memset+0x8>
80004b84:	10 cb       	st.b	r8++,r11
80004b86:	20 1a       	sub	r10,1
80004b88:	58 0a       	cp.w	r10,0
80004b8a:	cf d1       	brne	80004b84 <memset+0x4>
80004b8c:	5e fc       	retal	r12
80004b8e:	d7 03       	nop

80004b90 <_sbrk_r>:
80004b90:	d4 21       	pushm	r4-r7,lr
80004b92:	30 08       	mov	r8,0
80004b94:	18 97       	mov	r7,r12
80004b96:	e0 66 07 a8 	mov	r6,1960
80004b9a:	16 9c       	mov	r12,r11
80004b9c:	8d 08       	st.w	r6[0x0],r8
80004b9e:	c2 dc       	rcall	80004bf8 <_sbrk>
80004ba0:	5b fc       	cp.w	r12,-1
80004ba2:	c0 51       	brne	80004bac <_sbrk_r+0x1c>
80004ba4:	6c 08       	ld.w	r8,r6[0x0]
80004ba6:	58 08       	cp.w	r8,0
80004ba8:	ef f8 1a 03 	st.wne	r7[0xc],r8
80004bac:	d8 22       	popm	r4-r7,pc
80004bae:	d7 03       	nop

80004bb0 <strcpy>:
80004bb0:	30 08       	mov	r8,0
80004bb2:	f6 08 07 09 	ld.ub	r9,r11[r8]
80004bb6:	f8 08 0b 09 	st.b	r12[r8],r9
80004bba:	2f f8       	sub	r8,-1
80004bbc:	58 09       	cp.w	r9,0
80004bbe:	cf a1       	brne	80004bb2 <strcpy+0x2>
80004bc0:	5e fc       	retal	r12
80004bc2:	d7 03       	nop

80004bc4 <strncpy>:
80004bc4:	30 08       	mov	r8,0
80004bc6:	10 3a       	cp.w	r10,r8
80004bc8:	5e 0c       	reteq	r12
80004bca:	f6 08 07 09 	ld.ub	r9,r11[r8]
80004bce:	f8 08 0b 09 	st.b	r12[r8],r9
80004bd2:	2f f8       	sub	r8,-1
80004bd4:	58 09       	cp.w	r9,0
80004bd6:	cf 81       	brne	80004bc6 <strncpy+0x2>
80004bd8:	10 3a       	cp.w	r10,r8
80004bda:	5e 0c       	reteq	r12
80004bdc:	f8 08 0b 09 	st.b	r12[r8],r9
80004be0:	2f f8       	sub	r8,-1
80004be2:	cf bb       	rjmp	80004bd8 <strncpy+0x14>

80004be4 <_init_argv>:
80004be4:	30 e8       	mov	r8,14
80004be6:	d6 73       	breakpoint
80004be8:	3f fc       	mov	r12,-1
80004bea:	35 8b       	mov	r11,88
80004bec:	5e fc       	retal	r12

80004bee <_exit>:
80004bee:	30 d8       	mov	r8,13
80004bf0:	d6 73       	breakpoint
80004bf2:	3f fc       	mov	r12,-1
80004bf4:	35 8b       	mov	r11,88
80004bf6:	c0 08       	rjmp	80004bf6 <_exit+0x8>

80004bf8 <_sbrk>:
80004bf8:	d4 01       	pushm	lr
80004bfa:	e0 68 07 8c 	mov	r8,1932
80004bfe:	70 09       	ld.w	r9,r8[0x0]
80004c00:	58 09       	cp.w	r9,0
80004c02:	c0 41       	brne	80004c0a <_sbrk+0x12>
80004c04:	e0 69 07 b0 	mov	r9,1968
80004c08:	91 09       	st.w	r8[0x0],r9
80004c0a:	e0 69 07 8c 	mov	r9,1932
80004c0e:	e0 6a f0 00 	mov	r10,61440
80004c12:	72 08       	ld.w	r8,r9[0x0]
80004c14:	f0 0c 00 0c 	add	r12,r8,r12
80004c18:	14 3c       	cp.w	r12,r10
80004c1a:	e0 8b 00 04 	brhi	80004c22 <_sbrk+0x2a>
80004c1e:	93 0c       	st.w	r9[0x0],r12
80004c20:	c0 58       	rjmp	80004c2a <_sbrk+0x32>
80004c22:	cb fc       	rcall	80004da0 <__errno>
80004c24:	30 c8       	mov	r8,12
80004c26:	99 08       	st.w	r12[0x0],r8
80004c28:	3f f8       	mov	r8,-1
80004c2a:	10 9c       	mov	r12,r8
80004c2c:	d8 02       	popm	pc
80004c2e:	d7 03       	nop

80004c30 <__register_exitproc>:
80004c30:	d4 31       	pushm	r0-r7,lr
80004c32:	fe c8 f9 2e 	sub	r8,pc,-1746
80004c36:	70 03       	ld.w	r3,r8[0x0]
80004c38:	67 24       	ld.w	r4,r3[0x48]
80004c3a:	e6 c8 ff b4 	sub	r8,r3,-76
80004c3e:	58 04       	cp.w	r4,0
80004c40:	f0 04 17 00 	moveq	r4,r8
80004c44:	e7 f4 0a 12 	st.weq	r3[0x48],r4
80004c48:	18 97       	mov	r7,r12
80004c4a:	16 96       	mov	r6,r11
80004c4c:	14 95       	mov	r5,r10
80004c4e:	12 92       	mov	r2,r9
80004c50:	68 18       	ld.w	r8,r4[0x4]
80004c52:	59 f8       	cp.w	r8,31
80004c54:	e0 8a 00 0e 	brle	80004c70 <__register_exitproc+0x40>
80004c58:	e0 6c 00 8c 	mov	r12,140
80004c5c:	fe b0 fc cc 	rcall	800045f4 <malloc>
80004c60:	18 94       	mov	r4,r12
80004c62:	c3 80       	breq	80004cd2 <__register_exitproc+0xa2>
80004c64:	67 28       	ld.w	r8,r3[0x48]
80004c66:	99 08       	st.w	r12[0x0],r8
80004c68:	e7 4c 00 48 	st.w	r3[72],r12
80004c6c:	30 08       	mov	r8,0
80004c6e:	99 18       	st.w	r12[0x4],r8
80004c70:	58 07       	cp.w	r7,0
80004c72:	c2 70       	breq	80004cc0 <__register_exitproc+0x90>
80004c74:	e8 fc 00 88 	ld.w	r12,r4[136]
80004c78:	58 0c       	cp.w	r12,0
80004c7a:	c0 d1       	brne	80004c94 <__register_exitproc+0x64>
80004c7c:	e0 6c 01 08 	mov	r12,264
80004c80:	fe b0 fc ba 	rcall	800045f4 <malloc>
80004c84:	c2 70       	breq	80004cd2 <__register_exitproc+0xa2>
80004c86:	30 08       	mov	r8,0
80004c88:	e9 4c 00 88 	st.w	r4[136],r12
80004c8c:	f9 48 01 04 	st.w	r12[260],r8
80004c90:	f9 48 01 00 	st.w	r12[256],r8
80004c94:	68 18       	ld.w	r8,r4[0x4]
80004c96:	f0 c9 ff e0 	sub	r9,r8,-32
80004c9a:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
80004c9e:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
80004ca2:	30 1a       	mov	r10,1
80004ca4:	f8 f9 01 00 	ld.w	r9,r12[256]
80004ca8:	f4 08 09 48 	lsl	r8,r10,r8
80004cac:	10 49       	or	r9,r8
80004cae:	f9 49 01 00 	st.w	r12[256],r9
80004cb2:	58 27       	cp.w	r7,2
80004cb4:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
80004cb8:	f3 d8 e0 38 	oreq	r8,r9,r8
80004cbc:	f9 f8 0a 41 	st.weq	r12[0x104],r8
80004cc0:	68 18       	ld.w	r8,r4[0x4]
80004cc2:	30 0c       	mov	r12,0
80004cc4:	f0 c9 ff ff 	sub	r9,r8,-1
80004cc8:	2f e8       	sub	r8,-2
80004cca:	89 19       	st.w	r4[0x4],r9
80004ccc:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
80004cd0:	d8 32       	popm	r0-r7,pc
80004cd2:	dc 3a       	popm	r0-r7,pc,r12=-1

80004cd4 <__call_exitprocs>:
80004cd4:	d4 31       	pushm	r0-r7,lr
80004cd6:	20 3d       	sub	sp,12
80004cd8:	fe c8 f9 d4 	sub	r8,pc,-1580
80004cdc:	50 2c       	stdsp	sp[0x8],r12
80004cde:	70 08       	ld.w	r8,r8[0x0]
80004ce0:	16 91       	mov	r1,r11
80004ce2:	50 08       	stdsp	sp[0x0],r8
80004ce4:	2b 88       	sub	r8,-72
80004ce6:	50 18       	stdsp	sp[0x4],r8
80004ce8:	40 0a       	lddsp	r10,sp[0x0]
80004cea:	40 14       	lddsp	r4,sp[0x4]
80004cec:	75 27       	ld.w	r7,r10[0x48]
80004cee:	c5 58       	rjmp	80004d98 <__call_exitprocs+0xc4>
80004cf0:	6e 15       	ld.w	r5,r7[0x4]
80004cf2:	ee f6 00 88 	ld.w	r6,r7[136]
80004cf6:	ea c2 ff ff 	sub	r2,r5,-1
80004cfa:	20 15       	sub	r5,1
80004cfc:	ee 02 00 22 	add	r2,r7,r2<<0x2
80004d00:	ec 05 00 23 	add	r3,r6,r5<<0x2
80004d04:	c3 58       	rjmp	80004d6e <__call_exitprocs+0x9a>
80004d06:	58 01       	cp.w	r1,0
80004d08:	c0 70       	breq	80004d16 <__call_exitprocs+0x42>
80004d0a:	58 06       	cp.w	r6,0
80004d0c:	c2 e0       	breq	80004d68 <__call_exitprocs+0x94>
80004d0e:	e6 f8 00 80 	ld.w	r8,r3[128]
80004d12:	02 38       	cp.w	r8,r1
80004d14:	c2 a1       	brne	80004d68 <__call_exitprocs+0x94>
80004d16:	6e 19       	ld.w	r9,r7[0x4]
80004d18:	64 08       	ld.w	r8,r2[0x0]
80004d1a:	20 19       	sub	r9,1
80004d1c:	12 35       	cp.w	r5,r9
80004d1e:	ef f5 0a 01 	st.weq	r7[0x4],r5
80004d22:	f9 b9 01 00 	movne	r9,0
80004d26:	e5 f9 1a 00 	st.wne	r2[0x0],r9
80004d2a:	58 08       	cp.w	r8,0
80004d2c:	c1 e0       	breq	80004d68 <__call_exitprocs+0x94>
80004d2e:	6e 10       	ld.w	r0,r7[0x4]
80004d30:	58 06       	cp.w	r6,0
80004d32:	c0 90       	breq	80004d44 <__call_exitprocs+0x70>
80004d34:	30 1a       	mov	r10,1
80004d36:	f4 05 09 49 	lsl	r9,r10,r5
80004d3a:	ec fa 01 00 	ld.w	r10,r6[256]
80004d3e:	f3 ea 00 0a 	and	r10,r9,r10
80004d42:	c0 31       	brne	80004d48 <__call_exitprocs+0x74>
80004d44:	5d 18       	icall	r8
80004d46:	c0 b8       	rjmp	80004d5c <__call_exitprocs+0x88>
80004d48:	ec fa 01 04 	ld.w	r10,r6[260]
80004d4c:	66 0b       	ld.w	r11,r3[0x0]
80004d4e:	14 69       	and	r9,r10
80004d50:	c0 41       	brne	80004d58 <__call_exitprocs+0x84>
80004d52:	40 2c       	lddsp	r12,sp[0x8]
80004d54:	5d 18       	icall	r8
80004d56:	c0 38       	rjmp	80004d5c <__call_exitprocs+0x88>
80004d58:	16 9c       	mov	r12,r11
80004d5a:	5d 18       	icall	r8
80004d5c:	6e 18       	ld.w	r8,r7[0x4]
80004d5e:	10 30       	cp.w	r0,r8
80004d60:	cc 41       	brne	80004ce8 <__call_exitprocs+0x14>
80004d62:	68 08       	ld.w	r8,r4[0x0]
80004d64:	0e 38       	cp.w	r8,r7
80004d66:	cc 11       	brne	80004ce8 <__call_exitprocs+0x14>
80004d68:	20 15       	sub	r5,1
80004d6a:	20 43       	sub	r3,4
80004d6c:	20 42       	sub	r2,4
80004d6e:	58 05       	cp.w	r5,0
80004d70:	cc b4       	brge	80004d06 <__call_exitprocs+0x32>
80004d72:	6e 18       	ld.w	r8,r7[0x4]
80004d74:	58 08       	cp.w	r8,0
80004d76:	c0 f1       	brne	80004d94 <__call_exitprocs+0xc0>
80004d78:	6e 08       	ld.w	r8,r7[0x0]
80004d7a:	58 08       	cp.w	r8,0
80004d7c:	c0 c0       	breq	80004d94 <__call_exitprocs+0xc0>
80004d7e:	89 08       	st.w	r4[0x0],r8
80004d80:	58 06       	cp.w	r6,0
80004d82:	c0 40       	breq	80004d8a <__call_exitprocs+0xb6>
80004d84:	0c 9c       	mov	r12,r6
80004d86:	fe b0 fc 2f 	rcall	800045e4 <free>
80004d8a:	0e 9c       	mov	r12,r7
80004d8c:	fe b0 fc 2c 	rcall	800045e4 <free>
80004d90:	68 07       	ld.w	r7,r4[0x0]
80004d92:	c0 38       	rjmp	80004d98 <__call_exitprocs+0xc4>
80004d94:	0e 94       	mov	r4,r7
80004d96:	6e 07       	ld.w	r7,r7[0x0]
80004d98:	58 07       	cp.w	r7,0
80004d9a:	ca b1       	brne	80004cf0 <__call_exitprocs+0x1c>
80004d9c:	2f dd       	sub	sp,-12
80004d9e:	d8 32       	popm	r0-r7,pc

80004da0 <__errno>:
80004da0:	e0 68 01 14 	mov	r8,276
80004da4:	70 0c       	ld.w	r12,r8[0x0]
80004da6:	2f 4c       	sub	r12,-12
80004da8:	5e fc       	retal	r12
80004daa:	d7 03       	nop

80004dac <_malloc_trim_r>:
80004dac:	d4 21       	pushm	r4-r7,lr
80004dae:	16 95       	mov	r5,r11
80004db0:	18 97       	mov	r7,r12
80004db2:	fe b0 f0 d3 	rcall	80002f58 <__malloc_lock>
80004db6:	e0 64 01 18 	mov	r4,280
80004dba:	68 28       	ld.w	r8,r4[0x8]
80004dbc:	70 16       	ld.w	r6,r8[0x4]
80004dbe:	e0 16 ff fc 	andl	r6,0xfffc
80004dc2:	ec c8 ff 91 	sub	r8,r6,-111
80004dc6:	f0 05 01 05 	sub	r5,r8,r5
80004dca:	e0 15 ff 80 	andl	r5,0xff80
80004dce:	ea c5 00 80 	sub	r5,r5,128
80004dd2:	e0 45 00 7f 	cp.w	r5,127
80004dd6:	e0 8a 00 22 	brle	80004e1a <_malloc_trim_r+0x6e>
80004dda:	30 0b       	mov	r11,0
80004ddc:	0e 9c       	mov	r12,r7
80004dde:	cd 9e       	rcall	80004b90 <_sbrk_r>
80004de0:	68 28       	ld.w	r8,r4[0x8]
80004de2:	0c 08       	add	r8,r6
80004de4:	10 3c       	cp.w	r12,r8
80004de6:	c1 a1       	brne	80004e1a <_malloc_trim_r+0x6e>
80004de8:	ea 0b 11 00 	rsub	r11,r5,0
80004dec:	0e 9c       	mov	r12,r7
80004dee:	cd 1e       	rcall	80004b90 <_sbrk_r>
80004df0:	5b fc       	cp.w	r12,-1
80004df2:	c1 81       	brne	80004e22 <_malloc_trim_r+0x76>
80004df4:	30 0b       	mov	r11,0
80004df6:	0e 9c       	mov	r12,r7
80004df8:	cc ce       	rcall	80004b90 <_sbrk_r>
80004dfa:	68 28       	ld.w	r8,r4[0x8]
80004dfc:	f8 08 01 09 	sub	r9,r12,r8
80004e00:	58 f9       	cp.w	r9,15
80004e02:	e0 8a 00 0c 	brle	80004e1a <_malloc_trim_r+0x6e>
80004e06:	a1 a9       	sbr	r9,0x0
80004e08:	91 19       	st.w	r8[0x4],r9
80004e0a:	e0 68 05 24 	mov	r8,1316
80004e0e:	70 09       	ld.w	r9,r8[0x0]
80004e10:	e0 68 07 64 	mov	r8,1892
80004e14:	f8 09 01 09 	sub	r9,r12,r9
80004e18:	91 09       	st.w	r8[0x0],r9
80004e1a:	0e 9c       	mov	r12,r7
80004e1c:	fe b0 f0 ac 	rcall	80002f74 <__malloc_unlock>
80004e20:	d8 2a       	popm	r4-r7,pc,r12=0
80004e22:	68 28       	ld.w	r8,r4[0x8]
80004e24:	0a 16       	sub	r6,r5
80004e26:	a1 a6       	sbr	r6,0x0
80004e28:	91 16       	st.w	r8[0x4],r6
80004e2a:	e0 68 07 64 	mov	r8,1892
80004e2e:	70 09       	ld.w	r9,r8[0x0]
80004e30:	0a 19       	sub	r9,r5
80004e32:	0e 9c       	mov	r12,r7
80004e34:	91 09       	st.w	r8[0x0],r9
80004e36:	fe b0 f0 9f 	rcall	80002f74 <__malloc_unlock>
80004e3a:	da 2a       	popm	r4-r7,pc,r12=1

80004e3c <_free_r>:
80004e3c:	d4 21       	pushm	r4-r7,lr
80004e3e:	16 96       	mov	r6,r11
80004e40:	18 97       	mov	r7,r12
80004e42:	58 0b       	cp.w	r11,0
80004e44:	e0 80 00 c0 	breq	80004fc4 <_free_r+0x188>
80004e48:	fe b0 f0 88 	rcall	80002f58 <__malloc_lock>
80004e4c:	20 86       	sub	r6,8
80004e4e:	e0 6a 01 18 	mov	r10,280
80004e52:	6c 18       	ld.w	r8,r6[0x4]
80004e54:	74 2e       	ld.w	lr,r10[0x8]
80004e56:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004e5a:	a1 c8       	cbr	r8,0x0
80004e5c:	ec 08 00 09 	add	r9,r6,r8
80004e60:	72 1b       	ld.w	r11,r9[0x4]
80004e62:	e0 1b ff fc 	andl	r11,0xfffc
80004e66:	1c 39       	cp.w	r9,lr
80004e68:	c1 e1       	brne	80004ea4 <_free_r+0x68>
80004e6a:	f6 08 00 08 	add	r8,r11,r8
80004e6e:	58 0c       	cp.w	r12,0
80004e70:	c0 81       	brne	80004e80 <_free_r+0x44>
80004e72:	6c 09       	ld.w	r9,r6[0x0]
80004e74:	12 16       	sub	r6,r9
80004e76:	12 08       	add	r8,r9
80004e78:	6c 3b       	ld.w	r11,r6[0xc]
80004e7a:	6c 29       	ld.w	r9,r6[0x8]
80004e7c:	97 29       	st.w	r11[0x8],r9
80004e7e:	93 3b       	st.w	r9[0xc],r11
80004e80:	10 99       	mov	r9,r8
80004e82:	95 26       	st.w	r10[0x8],r6
80004e84:	a1 a9       	sbr	r9,0x0
80004e86:	8d 19       	st.w	r6[0x4],r9
80004e88:	e0 69 05 20 	mov	r9,1312
80004e8c:	72 09       	ld.w	r9,r9[0x0]
80004e8e:	12 38       	cp.w	r8,r9
80004e90:	c0 63       	brcs	80004e9c <_free_r+0x60>
80004e92:	e0 68 07 60 	mov	r8,1888
80004e96:	0e 9c       	mov	r12,r7
80004e98:	70 0b       	ld.w	r11,r8[0x0]
80004e9a:	c8 9f       	rcall	80004dac <_malloc_trim_r>
80004e9c:	0e 9c       	mov	r12,r7
80004e9e:	fe b0 f0 6b 	rcall	80002f74 <__malloc_unlock>
80004ea2:	d8 22       	popm	r4-r7,pc
80004ea4:	93 1b       	st.w	r9[0x4],r11
80004ea6:	58 0c       	cp.w	r12,0
80004ea8:	c0 30       	breq	80004eae <_free_r+0x72>
80004eaa:	30 0c       	mov	r12,0
80004eac:	c1 08       	rjmp	80004ecc <_free_r+0x90>
80004eae:	6c 0e       	ld.w	lr,r6[0x0]
80004eb0:	f4 c5 ff f8 	sub	r5,r10,-8
80004eb4:	1c 16       	sub	r6,lr
80004eb6:	1c 08       	add	r8,lr
80004eb8:	6c 2e       	ld.w	lr,r6[0x8]
80004eba:	0a 3e       	cp.w	lr,r5
80004ebc:	f9 bc 00 01 	moveq	r12,1
80004ec0:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80004ec4:	eb fe 1a 02 	st.wne	r5[0x8],lr
80004ec8:	fd f5 1a 03 	st.wne	lr[0xc],r5
80004ecc:	f2 0b 00 0e 	add	lr,r9,r11
80004ed0:	7c 1e       	ld.w	lr,lr[0x4]
80004ed2:	ed be 00 00 	bld	lr,0x0
80004ed6:	c1 40       	breq	80004efe <_free_r+0xc2>
80004ed8:	16 08       	add	r8,r11
80004eda:	58 0c       	cp.w	r12,0
80004edc:	c0 d1       	brne	80004ef6 <_free_r+0xba>
80004ede:	e0 6e 01 18 	mov	lr,280
80004ee2:	72 2b       	ld.w	r11,r9[0x8]
80004ee4:	2f 8e       	sub	lr,-8
80004ee6:	1c 3b       	cp.w	r11,lr
80004ee8:	c0 71       	brne	80004ef6 <_free_r+0xba>
80004eea:	97 36       	st.w	r11[0xc],r6
80004eec:	97 26       	st.w	r11[0x8],r6
80004eee:	8d 2b       	st.w	r6[0x8],r11
80004ef0:	8d 3b       	st.w	r6[0xc],r11
80004ef2:	30 1c       	mov	r12,1
80004ef4:	c0 58       	rjmp	80004efe <_free_r+0xc2>
80004ef6:	72 2b       	ld.w	r11,r9[0x8]
80004ef8:	72 39       	ld.w	r9,r9[0xc]
80004efa:	93 2b       	st.w	r9[0x8],r11
80004efc:	97 39       	st.w	r11[0xc],r9
80004efe:	10 99       	mov	r9,r8
80004f00:	ec 08 09 08 	st.w	r6[r8],r8
80004f04:	a1 a9       	sbr	r9,0x0
80004f06:	8d 19       	st.w	r6[0x4],r9
80004f08:	58 0c       	cp.w	r12,0
80004f0a:	c5 a1       	brne	80004fbe <_free_r+0x182>
80004f0c:	e0 48 01 ff 	cp.w	r8,511
80004f10:	e0 8b 00 13 	brhi	80004f36 <_free_r+0xfa>
80004f14:	a3 98       	lsr	r8,0x3
80004f16:	f4 08 00 39 	add	r9,r10,r8<<0x3
80004f1a:	72 2b       	ld.w	r11,r9[0x8]
80004f1c:	8d 39       	st.w	r6[0xc],r9
80004f1e:	8d 2b       	st.w	r6[0x8],r11
80004f20:	97 36       	st.w	r11[0xc],r6
80004f22:	93 26       	st.w	r9[0x8],r6
80004f24:	a3 48       	asr	r8,0x2
80004f26:	74 19       	ld.w	r9,r10[0x4]
80004f28:	30 1b       	mov	r11,1
80004f2a:	f6 08 09 48 	lsl	r8,r11,r8
80004f2e:	f3 e8 10 08 	or	r8,r9,r8
80004f32:	95 18       	st.w	r10[0x4],r8
80004f34:	c4 58       	rjmp	80004fbe <_free_r+0x182>
80004f36:	f0 0b 16 09 	lsr	r11,r8,0x9
80004f3a:	58 4b       	cp.w	r11,4
80004f3c:	e0 8b 00 06 	brhi	80004f48 <_free_r+0x10c>
80004f40:	f0 0b 16 06 	lsr	r11,r8,0x6
80004f44:	2c 8b       	sub	r11,-56
80004f46:	c2 08       	rjmp	80004f86 <_free_r+0x14a>
80004f48:	59 4b       	cp.w	r11,20
80004f4a:	e0 8b 00 04 	brhi	80004f52 <_free_r+0x116>
80004f4e:	2a 5b       	sub	r11,-91
80004f50:	c1 b8       	rjmp	80004f86 <_free_r+0x14a>
80004f52:	e0 4b 00 54 	cp.w	r11,84
80004f56:	e0 8b 00 06 	brhi	80004f62 <_free_r+0x126>
80004f5a:	f0 0b 16 0c 	lsr	r11,r8,0xc
80004f5e:	29 2b       	sub	r11,-110
80004f60:	c1 38       	rjmp	80004f86 <_free_r+0x14a>
80004f62:	e0 4b 01 54 	cp.w	r11,340
80004f66:	e0 8b 00 06 	brhi	80004f72 <_free_r+0x136>
80004f6a:	f0 0b 16 0f 	lsr	r11,r8,0xf
80004f6e:	28 9b       	sub	r11,-119
80004f70:	c0 b8       	rjmp	80004f86 <_free_r+0x14a>
80004f72:	e0 4b 05 54 	cp.w	r11,1364
80004f76:	e0 88 00 05 	brls	80004f80 <_free_r+0x144>
80004f7a:	37 eb       	mov	r11,126
80004f7c:	c0 58       	rjmp	80004f86 <_free_r+0x14a>
80004f7e:	d7 03       	nop
80004f80:	f0 0b 16 12 	lsr	r11,r8,0x12
80004f84:	28 4b       	sub	r11,-124
80004f86:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80004f8a:	78 29       	ld.w	r9,r12[0x8]
80004f8c:	18 39       	cp.w	r9,r12
80004f8e:	c0 e1       	brne	80004faa <_free_r+0x16e>
80004f90:	74 18       	ld.w	r8,r10[0x4]
80004f92:	a3 4b       	asr	r11,0x2
80004f94:	30 1c       	mov	r12,1
80004f96:	f8 0b 09 4b 	lsl	r11,r12,r11
80004f9a:	f1 eb 10 0b 	or	r11,r8,r11
80004f9e:	12 98       	mov	r8,r9
80004fa0:	95 1b       	st.w	r10[0x4],r11
80004fa2:	c0 a8       	rjmp	80004fb6 <_free_r+0x17a>
80004fa4:	72 29       	ld.w	r9,r9[0x8]
80004fa6:	18 39       	cp.w	r9,r12
80004fa8:	c0 60       	breq	80004fb4 <_free_r+0x178>
80004faa:	72 1a       	ld.w	r10,r9[0x4]
80004fac:	e0 1a ff fc 	andl	r10,0xfffc
80004fb0:	14 38       	cp.w	r8,r10
80004fb2:	cf 93       	brcs	80004fa4 <_free_r+0x168>
80004fb4:	72 38       	ld.w	r8,r9[0xc]
80004fb6:	8d 38       	st.w	r6[0xc],r8
80004fb8:	8d 29       	st.w	r6[0x8],r9
80004fba:	93 36       	st.w	r9[0xc],r6
80004fbc:	91 26       	st.w	r8[0x8],r6
80004fbe:	0e 9c       	mov	r12,r7
80004fc0:	fe b0 ef da 	rcall	80002f74 <__malloc_unlock>
80004fc4:	d8 22       	popm	r4-r7,pc
80004fc6:	d7 03       	nop

80004fc8 <__do_global_ctors_aux>:
80004fc8:	d4 21       	pushm	r4-r7,lr
80004fca:	30 c7       	mov	r7,12
80004fcc:	c0 28       	rjmp	80004fd0 <__do_global_ctors_aux+0x8>
80004fce:	5d 18       	icall	r8
80004fd0:	20 47       	sub	r7,4
80004fd2:	6e 08       	ld.w	r8,r7[0x0]
80004fd4:	5b f8       	cp.w	r8,-1
80004fd6:	cf c1       	brne	80004fce <__do_global_ctors_aux+0x6>
80004fd8:	d8 22       	popm	r4-r7,pc
80004fda:	d7 03       	nop

Disassembly of section .exception:

80005000 <_evba>:
80005000:	c0 08       	rjmp	80005000 <_evba>
	...

80005004 <_handle_TLB_Multiple_Hit>:
80005004:	c0 08       	rjmp	80005004 <_handle_TLB_Multiple_Hit>
	...

80005008 <_handle_Bus_Error_Data_Fetch>:
80005008:	c0 08       	rjmp	80005008 <_handle_Bus_Error_Data_Fetch>
	...

8000500c <_handle_Bus_Error_Instruction_Fetch>:
8000500c:	c0 08       	rjmp	8000500c <_handle_Bus_Error_Instruction_Fetch>
	...

80005010 <_handle_NMI>:
80005010:	c0 08       	rjmp	80005010 <_handle_NMI>
	...

80005014 <_handle_Instruction_Address>:
80005014:	c0 08       	rjmp	80005014 <_handle_Instruction_Address>
	...

80005018 <_handle_ITLB_Protection>:
80005018:	c0 08       	rjmp	80005018 <_handle_ITLB_Protection>
	...

8000501c <_handle_Breakpoint>:
8000501c:	c0 08       	rjmp	8000501c <_handle_Breakpoint>
	...

80005020 <_handle_Illegal_Opcode>:
80005020:	c0 08       	rjmp	80005020 <_handle_Illegal_Opcode>
	...

80005024 <_handle_Unimplemented_Instruction>:
80005024:	c0 08       	rjmp	80005024 <_handle_Unimplemented_Instruction>
	...

80005028 <_handle_Privilege_Violation>:
80005028:	c0 08       	rjmp	80005028 <_handle_Privilege_Violation>
	...

8000502c <_handle_Floating_Point>:
8000502c:	c0 08       	rjmp	8000502c <_handle_Floating_Point>
	...

80005030 <_handle_Coprocessor_Absent>:
80005030:	c0 08       	rjmp	80005030 <_handle_Coprocessor_Absent>
	...

80005034 <_handle_Data_Address_Read>:
80005034:	c0 08       	rjmp	80005034 <_handle_Data_Address_Read>
	...

80005038 <_handle_Data_Address_Write>:
80005038:	c0 08       	rjmp	80005038 <_handle_Data_Address_Write>
	...

8000503c <_handle_DTLB_Protection_Read>:
8000503c:	c0 08       	rjmp	8000503c <_handle_DTLB_Protection_Read>
	...

80005040 <_handle_DTLB_Protection_Write>:
80005040:	c0 08       	rjmp	80005040 <_handle_DTLB_Protection_Write>
	...

80005044 <_handle_DTLB_Modified>:
80005044:	c0 08       	rjmp	80005044 <_handle_DTLB_Modified>
	...

80005050 <_handle_ITLB_Miss>:
80005050:	c0 08       	rjmp	80005050 <_handle_ITLB_Miss>
	...

80005060 <_handle_DTLB_Miss_Read>:
80005060:	c0 08       	rjmp	80005060 <_handle_DTLB_Miss_Read>
	...

80005070 <_handle_DTLB_Miss_Write>:
80005070:	c0 08       	rjmp	80005070 <_handle_DTLB_Miss_Write>
	...

80005100 <_handle_Supervisor_Call>:
80005100:	fe cf 20 ec 	sub	pc,pc,8428

80005104 <_int0>:
80005104:	30 0c       	mov	r12,0
80005106:	fe b0 ea 43 	rcall	8000258c <_get_interrupt_handler>
8000510a:	58 0c       	cp.w	r12,0
8000510c:	f8 0f 17 10 	movne	pc,r12
80005110:	d6 03       	rete

80005112 <_int1>:
80005112:	30 1c       	mov	r12,1
80005114:	fe b0 ea 3c 	rcall	8000258c <_get_interrupt_handler>
80005118:	58 0c       	cp.w	r12,0
8000511a:	f8 0f 17 10 	movne	pc,r12
8000511e:	d6 03       	rete

80005120 <_int2>:
80005120:	30 2c       	mov	r12,2
80005122:	fe b0 ea 35 	rcall	8000258c <_get_interrupt_handler>
80005126:	58 0c       	cp.w	r12,0
80005128:	f8 0f 17 10 	movne	pc,r12
8000512c:	d6 03       	rete

8000512e <_int3>:
8000512e:	30 3c       	mov	r12,3
80005130:	fe b0 ea 2e 	rcall	8000258c <_get_interrupt_handler>
80005134:	58 0c       	cp.w	r12,0
80005136:	f8 0f 17 10 	movne	pc,r12
8000513a:	d6 03       	rete
8000513c:	d7 03       	nop
8000513e:	d7 03       	nop
80005140:	d7 03       	nop
80005142:	d7 03       	nop
80005144:	d7 03       	nop
80005146:	d7 03       	nop
80005148:	d7 03       	nop
8000514a:	d7 03       	nop
8000514c:	d7 03       	nop
8000514e:	d7 03       	nop
80005150:	d7 03       	nop
80005152:	d7 03       	nop
80005154:	d7 03       	nop
80005156:	d7 03       	nop
80005158:	d7 03       	nop
8000515a:	d7 03       	nop
8000515c:	d7 03       	nop
8000515e:	d7 03       	nop
80005160:	d7 03       	nop
80005162:	d7 03       	nop
80005164:	d7 03       	nop
80005166:	d7 03       	nop
80005168:	d7 03       	nop
8000516a:	d7 03       	nop
8000516c:	d7 03       	nop
8000516e:	d7 03       	nop
80005170:	d7 03       	nop
80005172:	d7 03       	nop
80005174:	d7 03       	nop
80005176:	d7 03       	nop
80005178:	d7 03       	nop
8000517a:	d7 03       	nop
8000517c:	d7 03       	nop
8000517e:	d7 03       	nop
80005180:	d7 03       	nop
80005182:	d7 03       	nop
80005184:	d7 03       	nop
80005186:	d7 03       	nop
80005188:	d7 03       	nop
8000518a:	d7 03       	nop
8000518c:	d7 03       	nop
8000518e:	d7 03       	nop
80005190:	d7 03       	nop
80005192:	d7 03       	nop
80005194:	d7 03       	nop
80005196:	d7 03       	nop
80005198:	d7 03       	nop
8000519a:	d7 03       	nop
8000519c:	d7 03       	nop
8000519e:	d7 03       	nop
800051a0:	d7 03       	nop
800051a2:	d7 03       	nop
800051a4:	d7 03       	nop
800051a6:	d7 03       	nop
800051a8:	d7 03       	nop
800051aa:	d7 03       	nop
800051ac:	d7 03       	nop
800051ae:	d7 03       	nop
800051b0:	d7 03       	nop
800051b2:	d7 03       	nop
800051b4:	d7 03       	nop
800051b6:	d7 03       	nop
800051b8:	d7 03       	nop
800051ba:	d7 03       	nop
800051bc:	d7 03       	nop
800051be:	d7 03       	nop
800051c0:	d7 03       	nop
800051c2:	d7 03       	nop
800051c4:	d7 03       	nop
800051c6:	d7 03       	nop
800051c8:	d7 03       	nop
800051ca:	d7 03       	nop
800051cc:	d7 03       	nop
800051ce:	d7 03       	nop
800051d0:	d7 03       	nop
800051d2:	d7 03       	nop
800051d4:	d7 03       	nop
800051d6:	d7 03       	nop
800051d8:	d7 03       	nop
800051da:	d7 03       	nop
800051dc:	d7 03       	nop
800051de:	d7 03       	nop
800051e0:	d7 03       	nop
800051e2:	d7 03       	nop
800051e4:	d7 03       	nop
800051e6:	d7 03       	nop
800051e8:	d7 03       	nop
800051ea:	d7 03       	nop
800051ec:	d7 03       	nop
800051ee:	d7 03       	nop
800051f0:	d7 03       	nop
800051f2:	d7 03       	nop
800051f4:	d7 03       	nop
800051f6:	d7 03       	nop
800051f8:	d7 03       	nop
800051fa:	d7 03       	nop
800051fc:	d7 03       	nop
800051fe:	d7 03       	nop

Disassembly of section .fini:

80005200 <_fini>:
80005200:	eb cd 40 40 	pushm	r6,lr
80005204:	48 26       	lddpc	r6,8000520c <_fini+0xc>
80005206:	1e 26       	rsub	r6,pc
80005208:	c0 48       	rjmp	80005210 <_fini+0x10>
8000520a:	d7 03       	nop
8000520c:	80 00       	ld.sh	r0,r0[0x0]
8000520e:	51 ea       	stdsp	sp[0x78],r10
80005210:	fe b0 e7 3a 	rcall	80002084 <__do_global_dtors_aux>
80005214:	e3 cd 80 40 	ldm	sp++,r6,pc
