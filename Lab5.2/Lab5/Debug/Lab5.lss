
Lab5.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         00003344  80002028  80002028  00002428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  80005400  80005400  00005800  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  80005600  80005600  00005a00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       00000150  80005618  80005618  00005a18  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  8 .ctors        00000008  00000008  80005768  00005c08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .dtors        00000008  00000010  80005770  00005c10  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .jcr          00000004  00000018  80005778  00005c18  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got          00000000  0000001c  8000577c  00005c1c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         0000050c  0000001c  8000577c  00005c1c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .balign       00000000  00000528  80005c88  00006128  2**0
                  ALLOC
 14 .bss          00000278  00000528  00000528  00000000  2**2
                  ALLOC
 15 .heap         0000e860  000007a0  000007a0  00000000  2**0
                  ALLOC
 16 .comment      00000030  00000000  00000000  00006128  2**0
                  CONTENTS, READONLY
 17 .debug_aranges 00000a78  00000000  00000000  00006158  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_pubnames 000014d0  00000000  00000000  00006bd0  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_info   00013404  00000000  00000000  000080a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_abbrev 000029e0  00000000  00000000  0001b4a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_line   00009b1a  00000000  00000000  0001de84  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_frame  00001c74  00000000  00000000  000279a0  2**2
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_str    000035cd  00000000  00000000  00029614  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_loc    0000315e  00000000  00000000  0002cbe1  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_macinfo 00c2ac3b  00000000  00000000  0002fd3f  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 27 .debug_ranges 000009a0  00000000  00000000  00c5a97a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	20 28       	sub	r8,2

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

8000200c <_init>:
8000200c:	eb cd 40 40 	pushm	r6,lr
80002010:	48 26       	lddpc	r6,80002018 <_init+0xc>
80002012:	1e 26       	rsub	r6,pc
80002014:	c0 48       	rjmp	8000201c <_init+0x10>
80002016:	d7 03       	nop
80002018:	80 00       	ld.sh	r0,r0[0x0]
8000201a:	1f f6       	ld.ub	r6,pc[0x7]
8000201c:	c5 4c       	rcall	800020c4 <frame_dummy>
8000201e:	e0 a0 19 9d 	rcall	80005358 <__do_global_ctors_aux>
80002022:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002028 <_stext>:
80002028:	30 07       	mov	r7,0
8000202a:	e0 7a 00 00 	mov	r10,65536
8000202e:	5b fa       	cp.w	r10,-1
80002030:	f4 0d 17 10 	movne	sp,r10
80002034:	fe cb c8 cc 	sub	r11,pc,-14132
80002038:	30 8c       	mov	r12,8
8000203a:	18 3b       	cp.w	r11,r12
8000203c:	c0 70       	breq	8000204a <_stext+0x22>
8000203e:	e0 6a 05 28 	mov	r10,1320
80002042:	b7 09       	ld.d	r8,r11++
80002044:	b9 28       	st.d	r12++,r8
80002046:	14 3c       	cp.w	r12,r10
80002048:	cf d5       	brlt	80002042 <_stext+0x1a>
8000204a:	e0 6a 07 a0 	mov	r10,1952
8000204e:	e0 6c 05 28 	mov	r12,1320
80002052:	30 08       	mov	r8,0
80002054:	30 09       	mov	r9,0
80002056:	b9 28       	st.d	r12++,r8
80002058:	14 3c       	cp.w	r12,r10
8000205a:	cf e5       	brlt	80002056 <_stext+0x2e>
8000205c:	e0 a0 08 84 	rcall	80003164 <_init_startup>
80002060:	fe cc ca 60 	sub	r12,pc,-13728
80002064:	e0 a0 14 7a 	rcall	80004958 <atexit>
80002068:	cd 2f       	rcall	8000200c <_init>
8000206a:	1a 9c       	mov	r12,sp
8000206c:	30 0b       	mov	r11,0
8000206e:	e0 a0 17 83 	rcall	80004f74 <_init_argv>
80002072:	5b fc       	cp.w	r12,-1
80002074:	f9 bc 00 00 	moveq	r12,0
80002078:	f9 ba 00 00 	moveq	r10,0
8000207c:	14 1d       	sub	sp,r10
8000207e:	e0 a0 02 8d 	rcall	80002598 <main>
80002082:	e0 a0 14 73 	rcall	80004968 <exit>
80002086:	d7 03       	nop

80002088 <__do_global_dtors_aux>:
80002088:	d4 21       	pushm	r4-r7,lr
8000208a:	e0 68 05 28 	mov	r8,1320
8000208e:	11 89       	ld.ub	r9,r8[0x0]
80002090:	30 08       	mov	r8,0
80002092:	f0 09 18 00 	cp.b	r9,r8
80002096:	c1 61       	brne	800020c2 <__do_global_dtors_aux+0x3a>
80002098:	31 08       	mov	r8,16
8000209a:	31 46       	mov	r6,20
8000209c:	10 95       	mov	r5,r8
8000209e:	10 16       	sub	r6,r8
800020a0:	e0 67 05 2c 	mov	r7,1324
800020a4:	a3 46       	asr	r6,0x2
800020a6:	20 16       	sub	r6,1
800020a8:	c0 68       	rjmp	800020b4 <__do_global_dtors_aux+0x2c>
800020aa:	2f f8       	sub	r8,-1
800020ac:	8f 08       	st.w	r7[0x0],r8
800020ae:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020b2:	5d 18       	icall	r8
800020b4:	6e 08       	ld.w	r8,r7[0x0]
800020b6:	0c 38       	cp.w	r8,r6
800020b8:	cf 93       	brcs	800020aa <__do_global_dtors_aux+0x22>
800020ba:	30 19       	mov	r9,1
800020bc:	e0 68 05 28 	mov	r8,1320
800020c0:	b0 89       	st.b	r8[0x0],r9
800020c2:	d8 22       	popm	r4-r7,pc

800020c4 <frame_dummy>:
800020c4:	d4 01       	pushm	lr
800020c6:	31 8c       	mov	r12,24
800020c8:	78 08       	ld.w	r8,r12[0x0]
800020ca:	58 08       	cp.w	r8,0
800020cc:	c0 50       	breq	800020d6 <frame_dummy+0x12>
800020ce:	48 38       	lddpc	r8,800020d8 <frame_dummy+0x14>
800020d0:	58 08       	cp.w	r8,0
800020d2:	c0 20       	breq	800020d6 <frame_dummy+0x12>
800020d4:	5d 18       	icall	r8
800020d6:	d8 02       	popm	pc
800020d8:	00 00       	add	r0,r0
	...

800020dc <buttonIsPressed>:
	button_port->oderc = BUTTON2_PIN;
	
}

int buttonIsPressed(int buttonNr)
{
800020dc:	eb cd 40 80 	pushm	r7,lr
800020e0:	1a 97       	mov	r7,sp
800020e2:	20 2d       	sub	sp,8
800020e4:	ef 4c ff f8 	st.w	r7[-8],r12
	int buttonState = AVR32_GPIO.port[BUTTON_PORT].pvr & (buttonNr);
800020e8:	fe 78 10 00 	mov	r8,-61440
800020ec:	f0 f9 02 60 	ld.w	r9,r8[608]
800020f0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800020f4:	f3 e8 00 08 	and	r8,r9,r8
800020f8:	ef 48 ff fc 	st.w	r7[-4],r8
	
	if(buttonState == 0)
800020fc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002100:	58 08       	cp.w	r8,0
80002102:	c0 31       	brne	80002108 <buttonIsPressed+0x2c>
		return 1;
80002104:	30 18       	mov	r8,1
80002106:	c0 28       	rjmp	8000210a <buttonIsPressed+0x2e>
	else
		return 0;
80002108:	30 08       	mov	r8,0
8000210a:	10 9c       	mov	r12,r8
8000210c:	2f ed       	sub	sp,-8
8000210e:	e3 cd 80 80 	ldm	sp++,r7,pc

80002112 <initLED>:
#include "LED.h"

void initLED (void)
{
80002112:	eb cd 40 80 	pushm	r7,lr
80002116:	1a 97       	mov	r7,sp
80002118:	20 1d       	sub	sp,4
	/*
	* First make access to the GPIO port registers
	* shorter to type , just for our convenience
	*/
	volatile avr32_gpio_port_t * led0_port;
	led0_port = &AVR32_GPIO.port[LED0_PORT];
8000211a:	fe 78 11 00 	mov	r8,-61184
8000211e:	ef 48 ff fc 	st.w	r7[-4],r8
	/*
	* Choose GPIO peripheral function ,
	* by writing a 1 to gpers , GPIO Enable Register Set
	*/
	led0_port->gpers = LED0_BIT_VALUE;
80002122:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002126:	fc 19 08 00 	movh	r9,0x800
8000212a:	91 19       	st.w	r8[0x4],r9
	led0_port->gpers = LED1_BIT_VALUE;
8000212c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002130:	fc 19 10 00 	movh	r9,0x1000
80002134:	91 19       	st.w	r8[0x4],r9
	led0_port->gpers = LED2_BIT_VALUE;
80002136:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000213a:	fc 19 20 00 	movh	r9,0x2000
8000213e:	91 19       	st.w	r8[0x4],r9
	/*
	* Set the output value register to 1 in order to
	* turn the LED off (1= off , 0= on in this case ) ,
	* by writing a 1 to ovrs , Output Value Register Set
	*/
	led0_port->ovrs = LED0_BIT_VALUE;
80002140:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002144:	fc 19 08 00 	movh	r9,0x800
80002148:	f1 49 00 54 	st.w	r8[84],r9
	led0_port->ovrs = LED1_BIT_VALUE;
8000214c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002150:	fc 19 10 00 	movh	r9,0x1000
80002154:	f1 49 00 54 	st.w	r8[84],r9
	led0_port->ovrs = LED2_BIT_VALUE;
80002158:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000215c:	fc 19 20 00 	movh	r9,0x2000
80002160:	f1 49 00 54 	st.w	r8[84],r9
	/*
	* Set the output enable register ,
	* by writing a 1 to oders , Output Drive Enable
	* Register Set
	*/
	led0_port->oders = LED0_BIT_VALUE;
80002164:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002168:	fc 19 08 00 	movh	r9,0x800
8000216c:	f1 49 00 44 	st.w	r8[68],r9
	led0_port->oders = LED1_BIT_VALUE;
80002170:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002174:	fc 19 10 00 	movh	r9,0x1000
80002178:	f1 49 00 44 	st.w	r8[68],r9
	led0_port->oders = LED2_BIT_VALUE;
8000217c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002180:	fc 19 20 00 	movh	r9,0x2000
80002184:	f1 49 00 44 	st.w	r8[68],r9
}
80002188:	2f fd       	sub	sp,-4
8000218a:	e3 cd 80 80 	ldm	sp++,r7,pc

8000218e <toggleLED>:

void toggleLED(int ledNr)
{
8000218e:	eb cd 40 80 	pushm	r7,lr
80002192:	1a 97       	mov	r7,sp
80002194:	20 1d       	sub	sp,4
80002196:	ef 4c ff fc 	st.w	r7[-4],r12
	AVR32_GPIO.port[LED0_PORT].ovrt = ledNr;
8000219a:	fe 78 10 00 	mov	r8,-61440
8000219e:	ee f9 ff fc 	ld.w	r9,r7[-4]
800021a2:	f1 49 01 5c 	st.w	r8[348],r9
}
800021a6:	2f fd       	sub	sp,-4
800021a8:	e3 cd 80 80 	ldm	sp++,r7,pc

800021ac <onLED>:

void onLED(int ledNr)
{
800021ac:	eb cd 40 80 	pushm	r7,lr
800021b0:	1a 97       	mov	r7,sp
800021b2:	20 1d       	sub	sp,4
800021b4:	ef 4c ff fc 	st.w	r7[-4],r12
	AVR32_GPIO.port[LED0_PORT].ovrc = ledNr;
800021b8:	fe 78 10 00 	mov	r8,-61440
800021bc:	ee f9 ff fc 	ld.w	r9,r7[-4]
800021c0:	f1 49 01 58 	st.w	r8[344],r9
800021c4:	2f fd       	sub	sp,-4
800021c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ca:	d7 03       	nop
800021cc:	4c 45       	lddpc	r5,800022dc <mdelay+0xc>
800021ce:	44 31       	lddsp	r1,sp[0x10c]
800021d0:	20 54       	sub	r4,5
800021d2:	4f 47       	lddpc	r7,800023a0 <vLED0Task+0x1c>
800021d4:	47 4c       	lddsp	r12,sp[0x1d0]
800021d6:	45 2c       	lddsp	r12,sp[0x148]
800021d8:	20 53       	sub	r3,5
800021da:	45 4d       	lddsp	sp,sp[0x150]
800021dc:	41 50       	lddsp	r0,sp[0x54]
800021de:	48 4f       	lddpc	pc,800021ec <onLED+0x40>
800021e0:	52 45       	stdsp	sp[0x90],r5
800021e2:	20 54       	sub	r4,5
800021e4:	41 4b       	lddsp	r11,sp[0x50]
800021e6:	45 4e       	lddsp	lr,sp[0x150]
800021e8:	0a 00       	add	r0,r5
800021ea:	00 00       	add	r0,r0
800021ec:	4c 45       	lddpc	r5,800022fc <mdelay+0x2c>
800021ee:	44 20       	lddsp	r0,sp[0x108]
800021f0:	31 2c       	mov	r12,18
800021f2:	20 53       	sub	r3,5
800021f4:	45 4d       	lddsp	sp,sp[0x150]
800021f6:	41 50       	lddsp	r0,sp[0x54]
800021f8:	48 4f       	lddpc	pc,80002208 <onLED+0x5c>
800021fa:	52 45       	stdsp	sp[0x90],r5
800021fc:	20 47       	sub	r7,4
800021fe:	49 56       	lddpc	r6,80002250 <onLED+0xa4>
80002200:	45 4e       	lddsp	lr,sp[0x150]
80002202:	0a 00       	add	r0,r5
80002204:	4c 45       	lddpc	r5,80002314 <mdelay+0x44>
80002206:	44 30       	lddsp	r0,sp[0x10c]
80002208:	20 44       	sub	r4,4
8000220a:	45 41       	lddsp	r1,sp[0x150]
8000220c:	44 4c       	lddsp	r12,sp[0x110]
8000220e:	49 4e       	lddpc	lr,8000225c <onLED+0xb0>
80002210:	45 20       	lddsp	r0,sp[0x148]
80002212:	4d 49       	lddpc	r9,80002360 <init_usart+0x44>
80002214:	53 53       	stdsp	sp[0xd4],r3
80002216:	45 44       	lddsp	r4,sp[0x150]
80002218:	0a 00       	add	r0,r5
8000221a:	00 00       	add	r0,r0
8000221c:	42 55       	lddsp	r5,sp[0x94]
8000221e:	54 54       	stdsp	sp[0x114],r4
80002220:	4f 4e       	lddpc	lr,800023f0 <vLED0Task+0x6c>
80002222:	20 31       	sub	r1,3
80002224:	20 50       	sub	r0,5
80002226:	52 45       	stdsp	sp[0x90],r5
80002228:	53 53       	stdsp	sp[0xd4],r3
8000222a:	45 44       	lddsp	r4,sp[0x150]
8000222c:	2c 20       	sub	r0,-62
8000222e:	53 45       	stdsp	sp[0xd0],r5
80002230:	4d 41       	lddpc	r1,80002380 <init_usart+0x64>
80002232:	50 48       	stdsp	sp[0x10],r8
80002234:	4f 52       	lddpc	r2,80002408 <vLED0Task+0x84>
80002236:	45 20       	lddsp	r0,sp[0x148]
80002238:	54 41       	stdsp	sp[0x110],r1
8000223a:	4b 45       	lddpc	r5,80002308 <mdelay+0x38>
8000223c:	4e 2c       	lddpc	r12,800023c4 <vLED0Task+0x40>
8000223e:	20 4c       	sub	r12,4
80002240:	45 44       	lddsp	r4,sp[0x150]
80002242:	20 31       	sub	r1,3
80002244:	20 6f       	sub	pc,6
80002246:	6e 20       	ld.w	r0,r7[0x8]
80002248:	66 6f       	ld.w	pc,r3[0x18]
8000224a:	72 20       	ld.w	r0,r9[0x8]
8000224c:	33 73       	mov	r3,55
8000224e:	65 63       	ld.w	r3,r2[0x58]
80002250:	0a 00       	add	r0,r5
80002252:	00 00       	add	r0,r0
80002254:	42 55       	lddsp	r5,sp[0x94]
80002256:	54 54       	stdsp	sp[0x114],r4
80002258:	4f 4e       	lddpc	lr,80002428 <vLED0Task+0xa4>
8000225a:	20 31       	sub	r1,3
8000225c:	2c 20       	sub	r0,-62
8000225e:	53 45       	stdsp	sp[0xd0],r5
80002260:	4d 41       	lddpc	r1,800023b0 <vLED0Task+0x2c>
80002262:	50 48       	stdsp	sp[0x10],r8
80002264:	4f 52       	lddpc	r2,80002438 <vLED0Task+0xb4>
80002266:	45 20       	lddsp	r0,sp[0x148]
80002268:	47 49       	lddsp	r9,sp[0x1d0]
8000226a:	56 45       	stdsp	sp[0x190],r5
8000226c:	4e 0a       	lddpc	r10,800023ec <vLED0Task+0x68>
8000226e:	00 00       	add	r0,r0
80002270:	42 55       	lddsp	r5,sp[0x94]
80002272:	54 54       	stdsp	sp[0x114],r4
80002274:	4f 4e       	lddpc	lr,80002444 <vLED0Task+0xc0>
80002276:	20 31       	sub	r1,3
80002278:	20 43       	sub	r3,4
8000227a:	41 4e       	lddsp	lr,sp[0x50]
8000227c:	54 20       	stdsp	sp[0x108],r0
8000227e:	54 41       	stdsp	sp[0x110],r1
80002280:	4b 45       	lddpc	r5,80002350 <init_usart+0x34>
80002282:	20 53       	sub	r3,5
80002284:	45 4d       	lddsp	sp,sp[0x150]
80002286:	41 50       	lddsp	r0,sp[0x54]
80002288:	48 4f       	lddpc	pc,80002298 <onLED+0xec>
8000228a:	52 45       	stdsp	sp[0x90],r5
8000228c:	0a 00       	add	r0,r5
8000228e:	00 00       	add	r0,r0
80002290:	42 55       	lddsp	r5,sp[0x94]
80002292:	54 54       	stdsp	sp[0x114],r4
80002294:	4f 4e       	lddpc	lr,80002464 <vButton0Task+0x8>
80002296:	20 32       	sub	r2,3
80002298:	20 50       	sub	r0,5
8000229a:	52 45       	stdsp	sp[0x90],r5
8000229c:	53 53       	stdsp	sp[0xd4],r3
8000229e:	45 44       	lddsp	r4,sp[0x150]
800022a0:	0a 00       	add	r0,r5
800022a2:	00 00       	add	r0,r0
800022a4:	76 4c       	ld.w	r12,r11[0x10]
800022a6:	45 44       	lddsp	r4,sp[0x150]
800022a8:	30 54       	mov	r4,5
800022aa:	61 73       	ld.w	r3,r0[0x5c]
800022ac:	6b 00       	ld.w	r0,r5[0x40]
800022ae:	00 00       	add	r0,r0
800022b0:	76 42       	ld.w	r2,r11[0x10]
800022b2:	75 74       	ld.w	r4,r10[0x5c]
800022b4:	74 6f       	ld.w	pc,r10[0x18]
800022b6:	6e 30       	ld.w	r0,r7[0xc]
800022b8:	54 61       	stdsp	sp[0x118],r1
800022ba:	73 6b       	ld.w	r11,r9[0x58]
800022bc:	00 00       	add	r0,r0
800022be:	00 00       	add	r0,r0
800022c0:	76 42       	ld.w	r2,r11[0x10]
800022c2:	75 74       	ld.w	r4,r10[0x5c]
800022c4:	74 6f       	ld.w	pc,r10[0x18]
800022c6:	6e 31       	ld.w	r1,r7[0xc]
800022c8:	54 61       	stdsp	sp[0x118],r1
800022ca:	73 6b       	ld.w	r11,r9[0x58]
800022cc:	00 00       	add	r0,r0
	...

800022d0 <mdelay>:
// Semaphore for all tasks
xSemaphoreHandle xSemaphore;

// Delay function, uses 12MHz clock
void mdelay(int msec)
{
800022d0:	eb cd 40 80 	pushm	r7,lr
800022d4:	1a 97       	mov	r7,sp
800022d6:	20 2d       	sub	sp,8
800022d8:	ef 4c ff f8 	st.w	r7[-8],r12
	long volatile cycles = msec * 12000/11;
800022dc:	ee f9 ff f8 	ld.w	r9,r7[-8]
800022e0:	e0 68 2e e0 	mov	r8,12000
800022e4:	f2 08 02 4a 	mul	r10,r9,r8
800022e8:	e0 68 a2 e9 	mov	r8,41705
800022ec:	ea 18 2e 8b 	orh	r8,0x2e8b
800022f0:	f4 08 04 48 	muls.d	r8,r10,r8
800022f4:	a1 59       	asr	r9,0x1
800022f6:	f4 08 14 1f 	asr	r8,r10,0x1f
800022fa:	f2 08 01 08 	sub	r8,r9,r8
800022fe:	ef 48 ff fc 	st.w	r7[-4],r8
	while(cycles != 0)
80002302:	c0 68       	rjmp	8000230e <mdelay+0x3e>
	{
		cycles--;
80002304:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002308:	20 18       	sub	r8,1
8000230a:	ef 48 ff fc 	st.w	r7[-4],r8

// Delay function, uses 12MHz clock
void mdelay(int msec)
{
	long volatile cycles = msec * 12000/11;
	while(cycles != 0)
8000230e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002312:	58 08       	cp.w	r8,0
80002314:	cf 81       	brne	80002304 <mdelay+0x34>
	{
		cycles--;
	}
}
80002316:	2f ed       	sub	sp,-8
80002318:	e3 cd 80 80 	ldm	sp++,r7,pc

8000231c <init_usart>:

// Initialize USART
void init_usart ( void )
{
8000231c:	eb cd 40 80 	pushm	r7,lr
80002320:	1a 97       	mov	r7,sp
		. charlength = 8,
		. paritytype = USART_NO_PARITY ,
		. stopbits = USART_1_STOPBIT ,
		. channelmode = USART_NORMAL_CHMODE
	};
	pm_switch_to_osc0 (& AVR32_PM , FOSC0 , OSC0_STARTUP );
80002322:	30 3a       	mov	r10,3
80002324:	e0 6b 1b 00 	mov	r11,6912
80002328:	ea 1b 00 b7 	orh	r11,0xb7
8000232c:	fe 7c 0c 00 	mov	r12,-62464
80002330:	f0 1f 00 0f 	mcall	8000236c <init_usart+0x50>
	gpio_enable_module ( USART_SERIAL_GPIO_MAP , 2);
80002334:	30 2b       	mov	r11,2
80002336:	48 fc       	lddpc	r12,80002370 <init_usart+0x54>
80002338:	f0 1f 00 0f 	mcall	80002374 <init_usart+0x58>
	gpio_enable_module ( USART_DEBUG_GPIO_MAP , 2);
8000233c:	30 2b       	mov	r11,2
8000233e:	48 fc       	lddpc	r12,80002378 <init_usart+0x5c>
80002340:	f0 1f 00 0d 	mcall	80002374 <init_usart+0x58>
	usart_init_rs232 ( serialPORT_USART , & USART_OPTIONS , FOSC0 );
80002344:	e0 6a 1b 00 	mov	r10,6912
80002348:	ea 1a 00 b7 	orh	r10,0xb7
8000234c:	48 cb       	lddpc	r11,8000237c <init_usart+0x60>
8000234e:	fe 7c 18 00 	mov	r12,-59392
80002352:	f0 1f 00 0c 	mcall	80002380 <init_usart+0x64>
	usart_init_rs232 ( configDBG_USART , & USART_OPTIONS , FOSC0 );
80002356:	e0 6a 1b 00 	mov	r10,6912
8000235a:	ea 1a 00 b7 	orh	r10,0xb7
8000235e:	48 8b       	lddpc	r11,8000237c <init_usart+0x60>
80002360:	fe 7c 18 00 	mov	r12,-59392
80002364:	f0 1f 00 07 	mcall	80002380 <init_usart+0x64>
}
80002368:	e3 cd 80 80 	ldm	sp++,r7,pc
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	2b 88       	sub	r8,-72
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	56 18       	stdsp	sp[0x184],r8
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	26 68       	sub	r8,102
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	56 28       	stdsp	sp[0x188],r8
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	56 38       	stdsp	sp[0x18c],r8
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	2d 38       	sub	r8,-45

80002384 <vLED0Task>:

// LED 0 blinks every second
void vLED0Task(void *pvParameters)
{	
80002384:	eb cd 40 80 	pushm	r7,lr
80002388:	1a 97       	mov	r7,sp
8000238a:	20 4d       	sub	sp,16
8000238c:	ef 4c ff f0 	st.w	r7[-16],r12
	volatile portTickType xLastWakeTime; // Holds tick count last led toggle
	volatile const portTickType xFreq = TASK_DELAY_MS(1000); // Holds the period
80002390:	e0 68 03 e8 	mov	r8,1000
80002394:	ef 48 ff f4 	st.w	r7[-12],r8
	
	xLastWakeTime = xTaskGetTickCount(); // Sets current tick count
80002398:	f0 1f 00 27 	mcall	80002434 <vLED0Task+0xb0>
8000239c:	18 98       	mov	r8,r12
8000239e:	ef 48 ff f8 	st.w	r7[-8],r8
	
	while(1)
	{
		// Takes semaphore to be able to blink
		if(xSemaphoreTake(xSemaphore, (portTickType)portMAX_DELAY) == pdTRUE)
800023a2:	4a 68       	lddpc	r8,80002438 <vLED0Task+0xb4>
800023a4:	70 08       	ld.w	r8,r8[0x0]
800023a6:	30 09       	mov	r9,0
800023a8:	3f fa       	mov	r10,-1
800023aa:	30 0b       	mov	r11,0
800023ac:	10 9c       	mov	r12,r8
800023ae:	f0 1f 00 24 	mcall	8000243c <vLED0Task+0xb8>
800023b2:	18 98       	mov	r8,r12
800023b4:	58 18       	cp.w	r8,1
800023b6:	c1 a1       	brne	800023ea <vLED0Task+0x66>
		{
			toggleLED(LED0_BIT_VALUE);
800023b8:	fc 1c 08 00 	movh	r12,0x800
800023bc:	f0 1f 00 21 	mcall	80002440 <vLED0Task+0xbc>
			usart_write_line (serialPORT_USART, "LED1 TOGGLE, SEMAPHORE TAKEN\n");
800023c0:	4a 1b       	lddpc	r11,80002444 <vLED0Task+0xc0>
800023c2:	fe 7c 18 00 	mov	r12,-59392
800023c6:	f0 1f 00 21 	mcall	80002448 <vLED0Task+0xc4>
			
			// Gives back semaphore when the LED has toggled
			if(xSemaphoreGive(xSemaphore) == pdTRUE)
800023ca:	49 c8       	lddpc	r8,80002438 <vLED0Task+0xb4>
800023cc:	70 08       	ld.w	r8,r8[0x0]
800023ce:	30 09       	mov	r9,0
800023d0:	30 0a       	mov	r10,0
800023d2:	30 0b       	mov	r11,0
800023d4:	10 9c       	mov	r12,r8
800023d6:	f0 1f 00 1e 	mcall	8000244c <vLED0Task+0xc8>
800023da:	18 98       	mov	r8,r12
800023dc:	58 18       	cp.w	r8,1
800023de:	c0 61       	brne	800023ea <vLED0Task+0x66>
			{
				usart_write_line (serialPORT_USART, "LED 1, SEMAPHORE GIVEN\n");
800023e0:	49 cb       	lddpc	r11,80002450 <vLED0Task+0xcc>
800023e2:	fe 7c 18 00 	mov	r12,-59392
800023e6:	f0 1f 00 19 	mcall	80002448 <vLED0Task+0xc4>
			}
			
		}
		
		portTickType currentTick = xTaskGetTickCount();
800023ea:	f0 1f 00 13 	mcall	80002434 <vLED0Task+0xb0>
800023ee:	18 98       	mov	r8,r12
800023f0:	ef 48 ff fc 	st.w	r7[-4],r8
		// Detects deadline misses
		while(currentTick > xLastWakeTime + xFreq)
800023f4:	c0 e8       	rjmp	80002410 <vLED0Task+0x8c>
		{
			usart_write_line (serialPORT_USART, "LED0 DEADLINE MISSED\n");
800023f6:	49 8b       	lddpc	r11,80002454 <vLED0Task+0xd0>
800023f8:	fe 7c 18 00 	mov	r12,-59392
800023fc:	f0 1f 00 13 	mcall	80002448 <vLED0Task+0xc4>
			xLastWakeTime += xFreq;
80002400:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002404:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002408:	f2 08 00 08 	add	r8,r9,r8
8000240c:	ef 48 ff f8 	st.w	r7[-8],r8
			
		}
		
		portTickType currentTick = xTaskGetTickCount();
		// Detects deadline misses
		while(currentTick > xLastWakeTime + xFreq)
80002410:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002414:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002418:	10 09       	add	r9,r8
8000241a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000241e:	10 39       	cp.w	r9,r8
80002420:	ce b3       	brcs	800023f6 <vLED0Task+0x72>
		{
			usart_write_line (serialPORT_USART, "LED0 DEADLINE MISSED\n");
			xLastWakeTime += xFreq;
		}
		vTaskDelayUntil(&xLastWakeTime, xFreq );
80002422:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002426:	ee c8 00 08 	sub	r8,r7,8
8000242a:	12 9b       	mov	r11,r9
8000242c:	10 9c       	mov	r12,r8
8000242e:	f0 1f 00 0b 	mcall	80002458 <vLED0Task+0xd4>
	}
80002432:	cb 8b       	rjmp	800023a2 <vLED0Task+0x1e>
80002434:	80 00       	ld.sh	r0,r0[0x0]
80002436:	41 98       	lddsp	r8,sp[0x64]
80002438:	00 00       	add	r0,r0
8000243a:	07 90       	ld.ub	r0,r3[0x1]
8000243c:	80 00       	ld.sh	r0,r0[0x0]
8000243e:	38 90       	mov	r0,-119
80002440:	80 00       	ld.sh	r0,r0[0x0]
80002442:	21 8e       	sub	lr,24
80002444:	80 00       	ld.sh	r0,r0[0x0]
80002446:	21 cc       	sub	r12,28
80002448:	80 00       	ld.sh	r0,r0[0x0]
8000244a:	2f 40       	sub	r0,-12
8000244c:	80 00       	ld.sh	r0,r0[0x0]
8000244e:	37 28       	mov	r8,114
80002450:	80 00       	ld.sh	r0,r0[0x0]
80002452:	21 ec       	sub	r12,30
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	22 04       	sub	r4,32
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	3e 9c       	mov	r12,-23

8000245c <vButton0Task>:
}

void vButton0Task( void *pvParameters )
{
8000245c:	eb cd 40 80 	pushm	r7,lr
80002460:	1a 97       	mov	r7,sp
80002462:	20 5d       	sub	sp,20
80002464:	ef 4c ff ec 	st.w	r7[-20],r12
	portTickType xLastWakeTime; // Holds tick count last led toggle
	const portTickType xFreq = TASK_DELAY_MS(10000); // Holds the period
80002468:	e0 68 27 10 	mov	r8,10000
8000246c:	ef 48 ff f8 	st.w	r7[-8],r8
	volatile portTickType elapsed; // Elapsed time of the work
	
	int x = 3000;
80002470:	e0 68 0b b8 	mov	r8,3000
80002474:	ef 48 ff fc 	st.w	r7[-4],r8
80002478:	c0 48       	rjmp	80002480 <vButton0Task+0x24>
				usart_write_line (serialPORT_USART, "BUTTON 1 CANT TAKE SEMAPHORE\n");
			}
		}
		
		
	}
8000247a:	d7 03       	nop
8000247c:	c0 28       	rjmp	80002480 <vButton0Task+0x24>
8000247e:	d7 03       	nop
	
	int x = 3000;
	
	while(1)
	{
		if(buttonIsPressed(BUTTON0_PIN))
80002480:	fc 1c 01 00 	movh	r12,0x100
80002484:	f0 1f 00 21 	mcall	80002508 <vButton0Task+0xac>
80002488:	18 98       	mov	r8,r12
8000248a:	58 08       	cp.w	r8,0
8000248c:	cf 70       	breq	8000247a <vButton0Task+0x1e>
		{
			// Takes the semaphore to turn LED 0 on for x seconds
			if(xSemaphoreTake(xSemaphore, (portTickType)10) == pdTRUE)
8000248e:	4a 08       	lddpc	r8,8000250c <vButton0Task+0xb0>
80002490:	70 08       	ld.w	r8,r8[0x0]
80002492:	30 09       	mov	r9,0
80002494:	30 aa       	mov	r10,10
80002496:	30 0b       	mov	r11,0
80002498:	10 9c       	mov	r12,r8
8000249a:	f0 1f 00 1e 	mcall	80002510 <vButton0Task+0xb4>
8000249e:	18 98       	mov	r8,r12
800024a0:	58 18       	cp.w	r8,1
800024a2:	c2 d1       	brne	800024fc <vButton0Task+0xa0>
			{
				xLastWakeTime = xTaskGetTickCount();
800024a4:	f0 1f 00 1c 	mcall	80002514 <vButton0Task+0xb8>
800024a8:	18 98       	mov	r8,r12
800024aa:	ef 48 ff f4 	st.w	r7[-12],r8
				onLED(LED0_BIT_VALUE);
800024ae:	fc 1c 08 00 	movh	r12,0x800
800024b2:	f0 1f 00 1a 	mcall	80002518 <vButton0Task+0xbc>
				usart_write_line (serialPORT_USART, "BUTTON 1 PRESSED, SEMAPHORE TAKEN, LED 1 on for 3sec\n");
800024b6:	49 ab       	lddpc	r11,8000251c <vButton0Task+0xc0>
800024b8:	fe 7c 18 00 	mov	r12,-59392
800024bc:	f0 1f 00 19 	mcall	80002520 <vButton0Task+0xc4>
				
				mdelay(x); // Busy wait for x seconds
800024c0:	ee fc ff fc 	ld.w	r12,r7[-4]
800024c4:	f0 1f 00 18 	mcall	80002524 <vButton0Task+0xc8>
				
				// Gives back the semaphore when work is done
				if(xSemaphoreGive(xSemaphore) == pdTRUE)
800024c8:	49 18       	lddpc	r8,8000250c <vButton0Task+0xb0>
800024ca:	70 08       	ld.w	r8,r8[0x0]
800024cc:	30 09       	mov	r9,0
800024ce:	30 0a       	mov	r10,0
800024d0:	30 0b       	mov	r11,0
800024d2:	10 9c       	mov	r12,r8
800024d4:	f0 1f 00 15 	mcall	80002528 <vButton0Task+0xcc>
800024d8:	18 98       	mov	r8,r12
800024da:	58 18       	cp.w	r8,1
800024dc:	cd 11       	brne	8000247e <vButton0Task+0x22>
				{
					usart_write_line(serialPORT_USART, "BUTTON 1, SEMAPHORE GIVEN\n");
800024de:	49 4b       	lddpc	r11,8000252c <vButton0Task+0xd0>
800024e0:	fe 7c 18 00 	mov	r12,-59392
800024e4:	f0 1f 00 0f 	mcall	80002520 <vButton0Task+0xc4>
					elapsed = xTaskGetTickCount()-xLastWakeTime; // Elapsed time of the work
800024e8:	f0 1f 00 0b 	mcall	80002514 <vButton0Task+0xb8>
800024ec:	18 99       	mov	r9,r12
800024ee:	ee f8 ff f4 	ld.w	r8,r7[-12]
800024f2:	f2 08 01 08 	sub	r8,r9,r8
800024f6:	ef 48 ff f0 	st.w	r7[-16],r8
				usart_write_line (serialPORT_USART, "BUTTON 1 CANT TAKE SEMAPHORE\n");
			}
		}
		
		
	}
800024fa:	cc 3b       	rjmp	80002480 <vButton0Task+0x24>
					elapsed = xTaskGetTickCount()-xLastWakeTime; // Elapsed time of the work
				}
			}
			else
			{
				usart_write_line (serialPORT_USART, "BUTTON 1 CANT TAKE SEMAPHORE\n");
800024fc:	48 db       	lddpc	r11,80002530 <vButton0Task+0xd4>
800024fe:	fe 7c 18 00 	mov	r12,-59392
80002502:	f0 1f 00 08 	mcall	80002520 <vButton0Task+0xc4>
			}
		}
		
		
	}
80002506:	cb db       	rjmp	80002480 <vButton0Task+0x24>
80002508:	80 00       	ld.sh	r0,r0[0x0]
8000250a:	20 dc       	sub	r12,13
8000250c:	00 00       	add	r0,r0
8000250e:	07 90       	ld.ub	r0,r3[0x1]
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	38 90       	mov	r0,-119
80002514:	80 00       	ld.sh	r0,r0[0x0]
80002516:	41 98       	lddsp	r8,sp[0x64]
80002518:	80 00       	ld.sh	r0,r0[0x0]
8000251a:	21 ac       	sub	r12,26
8000251c:	80 00       	ld.sh	r0,r0[0x0]
8000251e:	22 1c       	sub	r12,33
80002520:	80 00       	ld.sh	r0,r0[0x0]
80002522:	2f 40       	sub	r0,-12
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	22 d0       	sub	r0,45
80002528:	80 00       	ld.sh	r0,r0[0x0]
8000252a:	37 28       	mov	r8,114
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	22 54       	sub	r4,37
80002530:	80 00       	ld.sh	r0,r0[0x0]
80002532:	22 70       	sub	r0,39

80002534 <vButton1Task>:
}

// Lights LED1 as long as button1 is pressed
void vButton1Task( void *pvParameters )
{
80002534:	eb cd 40 80 	pushm	r7,lr
80002538:	1a 97       	mov	r7,sp
8000253a:	20 1d       	sub	sp,4
8000253c:	ef 4c ff fc 	st.w	r7[-4],r12
	//portTickType xLastWakeTime;
	//const portTickType xFreq = TASK_DELAY_MS(10000);
	
	while(1)
	{
		if(buttonIsPressed(BUTTON1_PIN))
80002540:	fc 1c 00 20 	movh	r12,0x20
80002544:	f0 1f 00 0f 	mcall	80002580 <vButton1Task+0x4c>
80002548:	18 98       	mov	r8,r12
8000254a:	58 08       	cp.w	r8,0
8000254c:	c1 60       	breq	80002578 <vButton1Task+0x44>
		{
			//xLastWakeTime = xTaskGetTickCount();
			
			onLED(LED1_BIT_VALUE);
8000254e:	fc 1c 10 00 	movh	r12,0x1000
80002552:	f0 1f 00 0d 	mcall	80002584 <vButton1Task+0x50>
			usart_write_line (serialPORT_USART, "BUTTON 2 PRESSED\n");
80002556:	48 db       	lddpc	r11,80002588 <vButton1Task+0x54>
80002558:	fe 7c 18 00 	mov	r12,-59392
8000255c:	f0 1f 00 0c 	mcall	8000258c <vButton1Task+0x58>
			
			// Busy wait while button is pressed
			while(buttonIsPressed(BUTTON1_PIN))
80002560:	fc 1c 00 20 	movh	r12,0x20
80002564:	f0 1f 00 07 	mcall	80002580 <vButton1Task+0x4c>
80002568:	18 98       	mov	r8,r12
8000256a:	58 08       	cp.w	r8,0
8000256c:	cf a1       	brne	80002560 <vButton1Task+0x2c>
			{
				
			}
			
			toggleLED(LED1_BIT_VALUE);
8000256e:	fc 1c 10 00 	movh	r12,0x1000
80002572:	f0 1f 00 08 	mcall	80002590 <vButton1Task+0x5c>
		else
		{
			vTaskDelay(TASK_DELAY_MS(10)); // delays the task so it doesn't poll for input
		}
		
	}
80002576:	ce 5b       	rjmp	80002540 <vButton1Task+0xc>
			
			toggleLED(LED1_BIT_VALUE);
		}
		else
		{
			vTaskDelay(TASK_DELAY_MS(10)); // delays the task so it doesn't poll for input
80002578:	30 ac       	mov	r12,10
8000257a:	f0 1f 00 07 	mcall	80002594 <vButton1Task+0x60>
		}
		
	}
8000257e:	ce 1b       	rjmp	80002540 <vButton1Task+0xc>
80002580:	80 00       	ld.sh	r0,r0[0x0]
80002582:	20 dc       	sub	r12,13
80002584:	80 00       	ld.sh	r0,r0[0x0]
80002586:	21 ac       	sub	r12,26
80002588:	80 00       	ld.sh	r0,r0[0x0]
8000258a:	22 90       	sub	r0,41
8000258c:	80 00       	ld.sh	r0,r0[0x0]
8000258e:	2f 40       	sub	r0,-12
80002590:	80 00       	ld.sh	r0,r0[0x0]
80002592:	21 8e       	sub	lr,24
80002594:	80 00       	ld.sh	r0,r0[0x0]
80002596:	3f 7c       	mov	r12,-9

80002598 <main>:
}

int main(void)
{
80002598:	eb cd 40 80 	pushm	r7,lr
8000259c:	1a 97       	mov	r7,sp
8000259e:	20 1d       	sub	sp,4
	initLED();
800025a0:	f0 1f 00 25 	mcall	80002634 <main+0x9c>
	init_usart();
800025a4:	f0 1f 00 25 	mcall	80002638 <main+0xa0>

	static unsigned char ucParameterToPass ;
	xTaskHandle xHandle1;
	
	vSemaphoreCreateBinary(xSemaphore);
800025a8:	30 0b       	mov	r11,0
800025aa:	30 1c       	mov	r12,1
800025ac:	f0 1f 00 24 	mcall	8000263c <main+0xa4>
800025b0:	18 99       	mov	r9,r12
800025b2:	4a 48       	lddpc	r8,80002640 <main+0xa8>
800025b4:	91 09       	st.w	r8[0x0],r9
800025b6:	4a 38       	lddpc	r8,80002640 <main+0xa8>
800025b8:	70 08       	ld.w	r8,r8[0x0]
800025ba:	58 08       	cp.w	r8,0
800025bc:	c0 90       	breq	800025ce <main+0x36>
800025be:	4a 18       	lddpc	r8,80002640 <main+0xa8>
800025c0:	70 08       	ld.w	r8,r8[0x0]
800025c2:	30 09       	mov	r9,0
800025c4:	30 0a       	mov	r10,0
800025c6:	30 0b       	mov	r11,0
800025c8:	10 9c       	mov	r12,r8
800025ca:	f0 1f 00 1f 	mcall	80002644 <main+0xac>
		
	// Create the task , store the handle .
	xTaskCreate(	vLED0Task,
800025ce:	49 fb       	lddpc	r11,80002648 <main+0xb0>
800025d0:	30 08       	mov	r8,0
800025d2:	1a d8       	st.w	--sp,r8
800025d4:	30 08       	mov	r8,0
800025d6:	1a d8       	st.w	--sp,r8
800025d8:	ee c8 00 04 	sub	r8,r7,4
800025dc:	1a d8       	st.w	--sp,r8
800025de:	30 38       	mov	r8,3
800025e0:	30 09       	mov	r9,0
800025e2:	e0 6a 01 00 	mov	r10,256
800025e6:	49 ac       	lddpc	r12,8000264c <main+0xb4>
800025e8:	f0 1f 00 1a 	mcall	80002650 <main+0xb8>
800025ec:	2f dd       	sub	sp,-12
					configMINIMAL_STACK_SIZE,
					NULL,
					3,
					&xHandle1);
	
	xTaskCreate(	vButton0Task, "vButton0Task", configMINIMAL_STACK_SIZE, xHandle1, 1, NULL);
800025ee:	ee f9 ff fc 	ld.w	r9,r7[-4]
800025f2:	49 9b       	lddpc	r11,80002654 <main+0xbc>
800025f4:	30 08       	mov	r8,0
800025f6:	1a d8       	st.w	--sp,r8
800025f8:	30 08       	mov	r8,0
800025fa:	1a d8       	st.w	--sp,r8
800025fc:	30 08       	mov	r8,0
800025fe:	1a d8       	st.w	--sp,r8
80002600:	30 18       	mov	r8,1
80002602:	e0 6a 01 00 	mov	r10,256
80002606:	49 5c       	lddpc	r12,80002658 <main+0xc0>
80002608:	f0 1f 00 12 	mcall	80002650 <main+0xb8>
8000260c:	2f dd       	sub	sp,-12
	
	xTaskCreate(	vButton1Task, "vButton1Task", configMINIMAL_STACK_SIZE, NULL, 2, NULL);
8000260e:	49 4b       	lddpc	r11,8000265c <main+0xc4>
80002610:	30 08       	mov	r8,0
80002612:	1a d8       	st.w	--sp,r8
80002614:	30 08       	mov	r8,0
80002616:	1a d8       	st.w	--sp,r8
80002618:	30 08       	mov	r8,0
8000261a:	1a d8       	st.w	--sp,r8
8000261c:	30 28       	mov	r8,2
8000261e:	30 09       	mov	r9,0
80002620:	e0 6a 01 00 	mov	r10,256
80002624:	48 fc       	lddpc	r12,80002660 <main+0xc8>
80002626:	f0 1f 00 0b 	mcall	80002650 <main+0xb8>
8000262a:	2f dd       	sub	sp,-12
	
	vTaskStartScheduler();
8000262c:	f0 1f 00 0e 	mcall	80002664 <main+0xcc>

	
	for( ;; )
	{
		
	}
80002630:	c0 08       	rjmp	80002630 <main+0x98>
80002632:	00 00       	add	r0,r0
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	21 12       	sub	r2,17
80002638:	80 00       	ld.sh	r0,r0[0x0]
8000263a:	23 1c       	sub	r12,49
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	36 10       	mov	r0,97
80002640:	00 00       	add	r0,r0
80002642:	07 90       	ld.ub	r0,r3[0x1]
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	37 28       	mov	r8,114
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	22 a4       	sub	r4,42
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	23 84       	sub	r4,56
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	3c d4       	mov	r4,-51
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	22 b0       	sub	r0,43
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	24 5c       	sub	r12,69
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	22 c0       	sub	r0,44
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	25 34       	sub	r4,83
80002664:	80 00       	ld.sh	r0,r0[0x0]
80002666:	3f f0       	mov	r0,-1

80002668 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80002668:	eb cd 40 80 	pushm	r7,lr
8000266c:	1a 97       	mov	r7,sp
8000266e:	20 4d       	sub	sp,16
80002670:	ef 4c ff f4 	st.w	r7[-12],r12
80002674:	ef 4b ff f0 	st.w	r7[-16],r11
	uint32_t status = GPIO_SUCCESS;
80002678:	30 08       	mov	r8,0
8000267a:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t i;

	for (i = 0; i < size; i++) {
8000267e:	30 08       	mov	r8,0
80002680:	ef 48 ff fc 	st.w	r7[-4],r8
80002684:	c1 c8       	rjmp	800026bc <gpio_enable_module+0x54>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80002686:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000268a:	70 19       	ld.w	r9,r8[0x4]
8000268c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002690:	70 08       	ld.w	r8,r8[0x0]
80002692:	12 9b       	mov	r11,r9
80002694:	10 9c       	mov	r12,r8
80002696:	f0 1f 00 10 	mcall	800026d4 <gpio_enable_module+0x6c>
8000269a:	18 98       	mov	r8,r12
8000269c:	ee f9 ff f8 	ld.w	r9,r7[-8]
800026a0:	f3 e8 10 08 	or	r8,r9,r8
800026a4:	ef 48 ff f8 	st.w	r7[-8],r8
		gpiomap++;
800026a8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800026ac:	2f 88       	sub	r8,-8
800026ae:	ef 48 ff f4 	st.w	r7[-12],r8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800026b2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800026b6:	2f f8       	sub	r8,-1
800026b8:	ef 48 ff fc 	st.w	r7[-4],r8
800026bc:	ee f9 ff fc 	ld.w	r9,r7[-4]
800026c0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800026c4:	10 39       	cp.w	r9,r8
800026c6:	ce 03       	brcs	80002686 <gpio_enable_module+0x1e>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
800026c8:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800026cc:	10 9c       	mov	r12,r8
800026ce:	2f cd       	sub	sp,-16
800026d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	26 d8       	sub	r8,109

800026d8 <gpio_enable_module_pin>:
 * \param function The pin function.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
800026d8:	eb cd 40 80 	pushm	r7,lr
800026dc:	1a 97       	mov	r7,sp
800026de:	20 3d       	sub	sp,12
800026e0:	ef 4c ff f8 	st.w	r7[-8],r12
800026e4:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800026e8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800026ec:	a5 98       	lsr	r8,0x5
800026ee:	a9 68       	lsl	r8,0x8
800026f0:	e0 28 f0 00 	sub	r8,61440
800026f4:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Enable the correct function. */
	switch (function) {
800026f8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800026fc:	58 18       	cp.w	r8,1
800026fe:	c1 e0       	breq	8000273a <gpio_enable_module_pin+0x62>
80002700:	c0 63       	brcs	8000270c <gpio_enable_module_pin+0x34>
80002702:	58 28       	cp.w	r8,2
80002704:	c3 20       	breq	80002768 <gpio_enable_module_pin+0x90>
80002706:	58 38       	cp.w	r8,3
80002708:	c4 70       	breq	80002796 <gpio_enable_module_pin+0xbe>
8000270a:	c5 d8       	rjmp	800027c4 <gpio_enable_module_pin+0xec>
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000270c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002710:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002714:	30 19       	mov	r9,1
80002716:	f2 08 09 48 	lsl	r8,r9,r8
8000271a:	10 99       	mov	r9,r8
8000271c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002720:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80002722:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002726:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000272a:	30 19       	mov	r9,1
8000272c:	f2 08 09 48 	lsl	r8,r9,r8
80002730:	10 99       	mov	r9,r8
80002732:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002736:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002738:	c4 88       	rjmp	800027c8 <gpio_enable_module_pin+0xf0>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000273a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000273e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002742:	30 19       	mov	r9,1
80002744:	f2 08 09 48 	lsl	r8,r9,r8
80002748:	10 99       	mov	r9,r8
8000274a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000274e:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80002750:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002754:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002758:	30 19       	mov	r9,1
8000275a:	f2 08 09 48 	lsl	r8,r9,r8
8000275e:	10 99       	mov	r9,r8
80002760:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002764:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002766:	c3 18       	rjmp	800027c8 <gpio_enable_module_pin+0xf0>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80002768:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000276c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002770:	30 19       	mov	r9,1
80002772:	f2 08 09 48 	lsl	r8,r9,r8
80002776:	10 99       	mov	r9,r8
80002778:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000277c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000277e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002782:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002786:	30 19       	mov	r9,1
80002788:	f2 08 09 48 	lsl	r8,r9,r8
8000278c:	10 99       	mov	r9,r8
8000278e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002792:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002794:	c1 a8       	rjmp	800027c8 <gpio_enable_module_pin+0xf0>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80002796:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000279a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000279e:	30 19       	mov	r9,1
800027a0:	f2 08 09 48 	lsl	r8,r9,r8
800027a4:	10 99       	mov	r9,r8
800027a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800027aa:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800027ac:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027b0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800027b4:	30 19       	mov	r9,1
800027b6:	f2 08 09 48 	lsl	r8,r9,r8
800027ba:	10 99       	mov	r9,r8
800027bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800027c0:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800027c2:	c0 38       	rjmp	800027c8 <gpio_enable_module_pin+0xf0>
		gpio_port->pmr2s = 1 << (pin & 0x1F);
		break;
#endif

	default:
		return GPIO_INVALID_ARGUMENT;
800027c4:	30 18       	mov	r8,1
800027c6:	c0 d8       	rjmp	800027e0 <gpio_enable_module_pin+0x108>
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800027c8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027cc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800027d0:	30 19       	mov	r9,1
800027d2:	f2 08 09 48 	lsl	r8,r9,r8
800027d6:	10 99       	mov	r9,r8
800027d8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800027dc:	91 29       	st.w	r8[0x8],r9

	return GPIO_SUCCESS;
800027de:	30 08       	mov	r8,0
}
800027e0:	10 9c       	mov	r12,r8
800027e2:	2f dd       	sub	sp,-12
800027e4:	e3 cd 80 80 	ldm	sp++,r7,pc

800027e8 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800027e8:	eb cd 40 80 	pushm	r7,lr
800027ec:	1a 97       	mov	r7,sp
	// Catch unregistered interrupts.
	while (true);
800027ee:	c0 08       	rjmp	800027ee <_unhandled_interrupt+0x6>

800027f0 <_get_interrupt_handler>:
 *
 * \return Interrupt handler to execute.
 */
__int_handler _get_interrupt_handler(uint32_t int_level);
__int_handler _get_interrupt_handler(uint32_t int_level)
{
800027f0:	eb cd 40 80 	pushm	r7,lr
800027f4:	1a 97       	mov	r7,sp
800027f6:	20 3d       	sub	sp,12
800027f8:	ef 4c ff f4 	st.w	r7[-12],r12
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800027fc:	fe 78 08 00 	mov	r8,-63488
80002800:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002804:	f2 09 11 03 	rsub	r9,r9,3
80002808:	28 09       	sub	r9,-128
8000280a:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
8000280e:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80002812:	fe 78 08 00 	mov	r8,-63488
80002816:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000281a:	2c 09       	sub	r9,-64
8000281c:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80002820:	ef 48 ff fc 	st.w	r7[-4],r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002824:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002828:	58 08       	cp.w	r8,0
8000282a:	c1 30       	breq	80002850 <_get_interrupt_handler+0x60>
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000282c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002830:	48 b8       	lddpc	r8,8000285c <_get_interrupt_handler+0x6c>
80002832:	a1 79       	lsl	r9,0x1
80002834:	2f f9       	sub	r9,-1
80002836:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
8000283a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000283e:	f0 08 12 00 	clz	r8,r8
80002842:	f0 08 11 1f 	rsub	r8,r8,31
			- clz(int_req) - 1]
80002846:	a3 68       	lsl	r8,0x2
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
80002848:	f2 08 00 08 	add	r8,r9,r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000284c:	70 08       	ld.w	r8,r8[0x0]
8000284e:	c0 28       	rjmp	80002852 <_get_interrupt_handler+0x62>
80002850:	30 08       	mov	r8,0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80002852:	10 9c       	mov	r12,r8
80002854:	2f dd       	sub	sp,-12
80002856:	e3 cd 80 80 	ldm	sp++,r7,pc
8000285a:	00 00       	add	r0,r0
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	56 44       	stdsp	sp[0x190],r4

80002860 <INTC_init_evba>:
 * \internal
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
80002860:	eb cd 40 80 	pushm	r7,lr
80002864:	1a 97       	mov	r7,sp
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80002866:	48 38       	lddpc	r8,80002870 <INTC_init_evba+0x10>
80002868:	e3 b8 00 01 	mtsr	0x4,r8
}
8000286c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	54 00       	stdsp	sp[0x100],r0

80002874 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80002874:	eb cd 40 80 	pushm	r7,lr
80002878:	1a 97       	mov	r7,sp
8000287a:	20 2d       	sub	sp,8
	uint32_t int_grp, int_req;

	INTC_init_evba();
8000287c:	f0 1f 00 1f 	mcall	800028f8 <INTC_init_interrupts+0x84>

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80002880:	30 08       	mov	r8,0
80002882:	ef 48 ff f8 	st.w	r7[-8],r8
80002886:	c3 18       	rjmp	800028e8 <INTC_init_interrupts+0x74>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80002888:	30 08       	mov	r8,0
8000288a:	ef 48 ff fc 	st.w	r7[-4],r8
8000288e:	c1 48       	rjmp	800028b6 <INTC_init_interrupts+0x42>
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80002890:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002894:	49 a8       	lddpc	r8,800028fc <INTC_init_interrupts+0x88>
80002896:	a1 79       	lsl	r9,0x1
80002898:	2f f9       	sub	r9,-1
8000289a:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
8000289e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800028a2:	a3 68       	lsl	r8,0x2
800028a4:	f2 08 00 08 	add	r8,r9,r8
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800028a8:	49 69       	lddpc	r9,80002900 <INTC_init_interrupts+0x8c>
800028aa:	91 09       	st.w	r8[0x0],r9
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800028ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800028b0:	2f f8       	sub	r8,-1
800028b2:	ef 48 ff fc 	st.w	r7[-4],r8
	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
800028b6:	ee f9 ff f8 	ld.w	r9,r7[-8]
800028ba:	49 18       	lddpc	r8,800028fc <INTC_init_interrupts+0x88>
800028bc:	f0 09 03 39 	ld.w	r9,r8[r9<<0x3]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800028c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800028c4:	10 39       	cp.w	r9,r8
800028c6:	fe 9b ff e5 	brhi	80002890 <INTC_init_interrupts+0x1c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800028ca:	fe 78 08 00 	mov	r8,-63488
800028ce:	ee f9 ff f8 	ld.w	r9,r7[-8]
800028d2:	48 db       	lddpc	r11,80002904 <INTC_init_interrupts+0x90>
800028d4:	48 da       	lddpc	r10,80002908 <INTC_init_interrupts+0x94>
800028d6:	f6 0a 01 0a 	sub	r10,r11,r10
800028da:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800028de:	ee f8 ff f8 	ld.w	r8,r7[-8]
800028e2:	2f f8       	sub	r8,-1
800028e4:	ef 48 ff f8 	st.w	r7[-8],r8
800028e8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800028ec:	59 38       	cp.w	r8,19
800028ee:	fe 98 ff cd 	brls	80002888 <INTC_init_interrupts+0x14>
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	}
}
800028f2:	2f ed       	sub	sp,-8
800028f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	28 60       	sub	r0,-122
800028fc:	80 00       	ld.sh	r0,r0[0x0]
800028fe:	56 44       	stdsp	sp[0x190],r4
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	27 e8       	sub	r8,126
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	55 04       	stdsp	sp[0x140],r4
80002908:	80 00       	ld.sh	r0,r0[0x0]
8000290a:	54 00       	stdsp	sp[0x100],r0

8000290c <INTC_register_interrupt>:
 *          be effective.
 *
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
8000290c:	eb cd 40 80 	pushm	r7,lr
80002910:	1a 97       	mov	r7,sp
80002912:	20 4d       	sub	sp,16
80002914:	ef 4c ff f8 	st.w	r7[-8],r12
80002918:	ef 4b ff f4 	st.w	r7[-12],r11
8000291c:	ef 4a ff f0 	st.w	r7[-16],r10
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80002920:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002924:	a5 98       	lsr	r8,0x5
80002926:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
8000292a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000292e:	4a 78       	lddpc	r8,800029c8 <INTC_register_interrupt+0xbc>
80002930:	a1 79       	lsl	r9,0x1
80002932:	2f f9       	sub	r9,-1
80002934:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80002938:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000293c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002940:	a3 68       	lsl	r8,0x2
80002942:	f2 08 00 08 	add	r8,r9,r8
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80002946:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000294a:	91 09       	st.w	r8[0x0],r9
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
8000294c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002950:	58 08       	cp.w	r8,0
80002952:	c0 c1       	brne	8000296a <INTC_register_interrupt+0x5e>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002954:	fe 78 08 00 	mov	r8,-63488
80002958:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000295c:	49 cb       	lddpc	r11,800029cc <INTC_register_interrupt+0xc0>
8000295e:	49 da       	lddpc	r10,800029d0 <INTC_register_interrupt+0xc4>
80002960:	f6 0a 01 0a 	sub	r10,r11,r10
80002964:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80002968:	c2 d8       	rjmp	800029c2 <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT1) {
8000296a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000296e:	58 18       	cp.w	r8,1
80002970:	c0 d1       	brne	8000298a <INTC_register_interrupt+0x7e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80002972:	fe 78 08 00 	mov	r8,-63488
80002976:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000297a:	49 7b       	lddpc	r11,800029d4 <INTC_register_interrupt+0xc8>
8000297c:	49 5a       	lddpc	r10,800029d0 <INTC_register_interrupt+0xc4>
8000297e:	f6 0a 01 0a 	sub	r10,r11,r10
80002982:	bf aa       	sbr	r10,0x1e
80002984:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80002988:	c1 d8       	rjmp	800029c2 <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT2) {
8000298a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000298e:	58 28       	cp.w	r8,2
80002990:	c0 d1       	brne	800029aa <INTC_register_interrupt+0x9e>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80002992:	fe 78 08 00 	mov	r8,-63488
80002996:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000299a:	49 0b       	lddpc	r11,800029d8 <INTC_register_interrupt+0xcc>
8000299c:	48 da       	lddpc	r10,800029d0 <INTC_register_interrupt+0xc4>
8000299e:	f6 0a 01 0a 	sub	r10,r11,r10
800029a2:	bf ba       	sbr	r10,0x1f
800029a4:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
800029a8:	c0 d8       	rjmp	800029c2 <INTC_register_interrupt+0xb6>
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800029aa:	fe 78 08 00 	mov	r8,-63488
800029ae:	ee f9 ff fc 	ld.w	r9,r7[-4]
800029b2:	48 bb       	lddpc	r11,800029dc <INTC_register_interrupt+0xd0>
800029b4:	48 7a       	lddpc	r10,800029d0 <INTC_register_interrupt+0xc4>
800029b6:	f6 0a 01 0a 	sub	r10,r11,r10
800029ba:	ea 1a c0 00 	orh	r10,0xc000
800029be:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	}
}
800029c2:	2f cd       	sub	sp,-16
800029c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800029c8:	80 00       	ld.sh	r0,r0[0x0]
800029ca:	56 44       	stdsp	sp[0x190],r4
800029cc:	80 00       	ld.sh	r0,r0[0x0]
800029ce:	55 04       	stdsp	sp[0x140],r4
800029d0:	80 00       	ld.sh	r0,r0[0x0]
800029d2:	54 00       	stdsp	sp[0x100],r0
800029d4:	80 00       	ld.sh	r0,r0[0x0]
800029d6:	55 12       	stdsp	sp[0x144],r2
800029d8:	80 00       	ld.sh	r0,r0[0x0]
800029da:	55 20       	stdsp	sp[0x148],r0
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	55 2e       	stdsp	sp[0x148],lr

800029e0 <pm_set_osc0_mode>:
 *
 * \param pm Base address of the Power Manager (i.e. &AVR32_PM).
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
800029e0:	eb cd 40 80 	pushm	r7,lr
800029e4:	1a 97       	mov	r7,sp
800029e6:	20 3d       	sub	sp,12
800029e8:	ef 4c ff f8 	st.w	r7[-8],r12
800029ec:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800029f0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800029f4:	70 a8       	ld.w	r8,r8[0x28]
800029f6:	30 09       	mov	r9,0
800029f8:	ef 49 ff fc 	st.w	r7[-4],r9
800029fc:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80002a00:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002a04:	5c 58       	castu.b	r8
80002a06:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80002a0a:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80002a0e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a12:	f1 d9 d0 03 	bfins	r8,r9,0x0,0x3
80002a16:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002a1a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002a1e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a22:	91 a9       	st.w	r8[0x28],r9
}
80002a24:	2f dd       	sub	sp,-12
80002a26:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a2a:	d7 03       	nop

80002a2c <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80002a2c:	eb cd 40 80 	pushm	r7,lr
80002a30:	1a 97       	mov	r7,sp
80002a32:	20 2d       	sub	sp,8
80002a34:	ef 4c ff fc 	st.w	r7[-4],r12
80002a38:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80002a3c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a40:	ec 58 bb 9f 	cp.w	r8,899999
80002a44:	e0 88 00 1a 	brls	80002a78 <pm_enable_osc0_crystal+0x4c>
80002a48:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a4c:	e0 69 c6 bf 	mov	r9,50879
80002a50:	ea 19 00 2d 	orh	r9,0x2d
80002a54:	12 38       	cp.w	r8,r9
80002a56:	e0 88 00 0f 	brls	80002a74 <pm_enable_osc0_crystal+0x48>
80002a5a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002a5e:	e0 69 11 ff 	mov	r9,4607
80002a62:	ea 19 00 7a 	orh	r9,0x7a
80002a66:	12 38       	cp.w	r8,r9
80002a68:	e0 8b 00 04 	brhi	80002a70 <pm_enable_osc0_crystal+0x44>
80002a6c:	30 68       	mov	r8,6
80002a6e:	c0 28       	rjmp	80002a72 <pm_enable_osc0_crystal+0x46>
80002a70:	30 78       	mov	r8,7
80002a72:	c0 28       	rjmp	80002a76 <pm_enable_osc0_crystal+0x4a>
80002a74:	30 58       	mov	r8,5
80002a76:	c0 28       	rjmp	80002a7a <pm_enable_osc0_crystal+0x4e>
80002a78:	30 48       	mov	r8,4
80002a7a:	10 9b       	mov	r11,r8
80002a7c:	ee fc ff fc 	ld.w	r12,r7[-4]
80002a80:	f0 1f 00 03 	mcall	80002a8c <pm_enable_osc0_crystal+0x60>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80002a84:	2f ed       	sub	sp,-8
80002a86:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a8a:	00 00       	add	r0,r0
80002a8c:	80 00       	ld.sh	r0,r0[0x0]
80002a8e:	29 e0       	sub	r0,-98

80002a90 <pm_enable_clk0>:


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80002a90:	eb cd 40 80 	pushm	r7,lr
80002a94:	1a 97       	mov	r7,sp
80002a96:	20 2d       	sub	sp,8
80002a98:	ef 4c ff fc 	st.w	r7[-4],r12
80002a9c:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_enable_clk0_no_wait(pm, startup);
80002aa0:	ee fb ff f8 	ld.w	r11,r7[-8]
80002aa4:	ee fc ff fc 	ld.w	r12,r7[-4]
80002aa8:	f0 1f 00 05 	mcall	80002abc <pm_enable_clk0+0x2c>
  pm_wait_for_clk0_ready(pm);
80002aac:	ee fc ff fc 	ld.w	r12,r7[-4]
80002ab0:	f0 1f 00 04 	mcall	80002ac0 <pm_enable_clk0+0x30>
}
80002ab4:	2f ed       	sub	sp,-8
80002ab6:	e3 cd 80 80 	ldm	sp++,r7,pc
80002aba:	00 00       	add	r0,r0
80002abc:	80 00       	ld.sh	r0,r0[0x0]
80002abe:	2a c4       	sub	r4,-84
80002ac0:	80 00       	ld.sh	r0,r0[0x0]
80002ac2:	2b 1e       	sub	lr,-79

80002ac4 <pm_enable_clk0_no_wait>:
  pm->mcctrl &= ~AVR32_PM_MCCTRL_OSC0EN_MASK;
}


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
80002ac4:	eb cd 40 80 	pushm	r7,lr
80002ac8:	1a 97       	mov	r7,sp
80002aca:	20 3d       	sub	sp,12
80002acc:	ef 4c ff f8 	st.w	r7[-8],r12
80002ad0:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002ad4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ad8:	70 a8       	ld.w	r8,r8[0x28]
80002ada:	30 09       	mov	r9,0
80002adc:	ef 49 ff fc 	st.w	r7[-4],r9
80002ae0:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80002ae4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002ae8:	5c 58       	castu.b	r8
80002aea:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80002aee:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80002af2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002af6:	f1 d9 d1 03 	bfins	r8,r9,0x8,0x3
80002afa:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002afe:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b02:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b06:	91 a9       	st.w	r8[0x28],r9

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80002b08:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b0c:	70 08       	ld.w	r8,r8[0x0]
80002b0e:	10 99       	mov	r9,r8
80002b10:	a3 a9       	sbr	r9,0x2
80002b12:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b16:	91 09       	st.w	r8[0x0],r9
}
80002b18:	2f dd       	sub	sp,-12
80002b1a:	e3 cd 80 80 	ldm	sp++,r7,pc

80002b1e <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
80002b1e:	eb cd 40 80 	pushm	r7,lr
80002b22:	1a 97       	mov	r7,sp
80002b24:	20 1d       	sub	sp,4
80002b26:	ef 4c ff fc 	st.w	r7[-4],r12
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80002b2a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b2e:	71 58       	ld.w	r8,r8[0x54]
80002b30:	e2 18 00 80 	andl	r8,0x80,COH
80002b34:	cf b0       	breq	80002b2a <pm_wait_for_clk0_ready+0xc>
}
80002b36:	2f fd       	sub	sp,-4
80002b38:	e3 cd 80 80 	ldm	sp++,r7,pc

80002b3c <pm_switch_to_clock>:
  return u_avr32_pm_mcctrl.MCCTRL.mcsel;
}


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
80002b3c:	eb cd 40 80 	pushm	r7,lr
80002b40:	1a 97       	mov	r7,sp
80002b42:	20 3d       	sub	sp,12
80002b44:	ef 4c ff f8 	st.w	r7[-8],r12
80002b48:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80002b4c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b50:	70 08       	ld.w	r8,r8[0x0]
80002b52:	30 09       	mov	r9,0
80002b54:	ef 49 ff fc 	st.w	r7[-4],r9
80002b58:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80002b5c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002b60:	5c 58       	castu.b	r8
80002b62:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002b66:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80002b6a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b6e:	f1 d9 d0 02 	bfins	r8,r9,0x0,0x2
80002b72:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80002b76:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b7a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b7e:	91 09       	st.w	r8[0x0],r9
}
80002b80:	2f dd       	sub	sp,-12
80002b82:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b86:	d7 03       	nop

80002b88 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80002b88:	eb cd 40 80 	pushm	r7,lr
80002b8c:	1a 97       	mov	r7,sp
80002b8e:	20 3d       	sub	sp,12
80002b90:	ef 4c ff fc 	st.w	r7[-4],r12
80002b94:	ef 4b ff f8 	st.w	r7[-8],r11
80002b98:	ef 4a ff f4 	st.w	r7[-12],r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80002b9c:	ee fb ff f8 	ld.w	r11,r7[-8]
80002ba0:	ee fc ff fc 	ld.w	r12,r7[-4]
80002ba4:	f0 1f 00 08 	mcall	80002bc4 <pm_switch_to_osc0+0x3c>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80002ba8:	ee fb ff f4 	ld.w	r11,r7[-12]
80002bac:	ee fc ff fc 	ld.w	r12,r7[-4]
80002bb0:	f0 1f 00 06 	mcall	80002bc8 <pm_switch_to_osc0+0x40>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80002bb4:	30 1b       	mov	r11,1
80002bb6:	ee fc ff fc 	ld.w	r12,r7[-4]
80002bba:	f0 1f 00 05 	mcall	80002bcc <pm_switch_to_osc0+0x44>
}
80002bbe:	2f dd       	sub	sp,-12
80002bc0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002bc4:	80 00       	ld.sh	r0,r0[0x0]
80002bc6:	2a 2c       	sub	r12,-94
80002bc8:	80 00       	ld.sh	r0,r0[0x0]
80002bca:	2a 90       	sub	r0,-87
80002bcc:	80 00       	ld.sh	r0,r0[0x0]
80002bce:	2b 3c       	sub	r12,-77

80002bd0 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80002bd0:	eb cd 40 80 	pushm	r7,lr
80002bd4:	1a 97       	mov	r7,sp
80002bd6:	20 1d       	sub	sp,4
80002bd8:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80002bdc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002be0:	e6 18 00 01 	andh	r8,0x1,COH
80002be4:	5f 08       	sreq	r8
80002be6:	5c 58       	castu.b	r8
}
80002be8:	10 9c       	mov	r12,r8
80002bea:	2f fd       	sub	sp,-4
80002bec:	e3 cd 80 80 	ldm	sp++,r7,pc

80002bf0 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80002bf0:	eb cd 40 80 	pushm	r7,lr
80002bf4:	1a 97       	mov	r7,sp
80002bf6:	20 7d       	sub	sp,28
80002bf8:	ef 4c ff ec 	st.w	r7[-20],r12
80002bfc:	ef 4b ff e8 	st.w	r7[-24],r11
80002c00:	ef 4a ff e4 	st.w	r7[-28],r10
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80002c04:	ee f8 ff e8 	ld.w	r8,r7[-24]
80002c08:	f0 09 15 04 	lsl	r9,r8,0x4
80002c0c:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002c10:	10 39       	cp.w	r9,r8
80002c12:	e0 8b 00 04 	brhi	80002c1a <usart_set_async_baudrate+0x2a>
80002c16:	31 08       	mov	r8,16
80002c18:	c0 28       	rjmp	80002c1c <usart_set_async_baudrate+0x2c>
80002c1a:	30 88       	mov	r8,8
80002c1c:	ef 48 ff f0 	st.w	r7[-16],r8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80002c20:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002c24:	f0 09 15 03 	lsl	r9,r8,0x3
80002c28:	ee fa ff f0 	ld.w	r10,r7[-16]
80002c2c:	ee f8 ff e8 	ld.w	r8,r7[-24]
80002c30:	f4 08 02 48 	mul	r8,r10,r8
80002c34:	a1 98       	lsr	r8,0x1
80002c36:	f2 08 00 08 	add	r8,r9,r8
80002c3a:	ee fa ff f0 	ld.w	r10,r7[-16]
80002c3e:	ee f9 ff e8 	ld.w	r9,r7[-24]
80002c42:	f4 09 02 49 	mul	r9,r10,r9
80002c46:	f0 09 0d 08 	divu	r8,r8,r9
80002c4a:	ef 48 ff f4 	st.w	r7[-12],r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80002c4e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002c52:	a3 98       	lsr	r8,0x3
80002c54:	ef 48 ff f8 	st.w	r7[-8],r8
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);
80002c58:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002c5c:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80002c60:	ef 48 ff fc 	st.w	r7[-4],r8

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80002c64:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c68:	58 08       	cp.w	r8,0
80002c6a:	c0 70       	breq	80002c78 <usart_set_async_baudrate+0x88>
80002c6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c70:	e0 48 ff ff 	cp.w	r8,65535
80002c74:	e0 88 00 04 	brls	80002c7c <usart_set_async_baudrate+0x8c>
    return USART_INVALID_INPUT;
80002c78:	30 18       	mov	r8,1
80002c7a:	c2 08       	rjmp	80002cba <usart_set_async_baudrate+0xca>

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80002c7c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80002c80:	70 18       	ld.w	r8,r8[0x4]
80002c82:	10 99       	mov	r9,r8
80002c84:	e4 19 ff f7 	andh	r9,0xfff7
80002c88:	e0 19 fe cf 	andl	r9,0xfecf
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80002c8c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002c90:	59 08       	cp.w	r8,16
80002c92:	c0 40       	breq	80002c9a <usart_set_async_baudrate+0xaa>
80002c94:	e8 68 00 00 	mov	r8,524288
80002c98:	c0 28       	rjmp	80002c9c <usart_set_async_baudrate+0xac>
80002c9a:	30 08       	mov	r8,0
80002c9c:	10 49       	or	r9,r8
80002c9e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80002ca2:	91 19       	st.w	r8[0x4],r9
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
                fp << AVR32_USART_BRGR_FP_OFFSET;
80002ca4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ca8:	f0 09 15 10 	lsl	r9,r8,0x10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80002cac:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002cb0:	10 49       	or	r9,r8
80002cb2:	ee f8 ff ec 	ld.w	r8,r7[-20]
80002cb6:	91 89       	st.w	r8[0x20],r9
                fp << AVR32_USART_BRGR_FP_OFFSET;

  return USART_SUCCESS;
80002cb8:	30 08       	mov	r8,0
}
80002cba:	10 9c       	mov	r12,r8
80002cbc:	2f 9d       	sub	sp,-28
80002cbe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002cc2:	d7 03       	nop

80002cc4 <usart_reset>:
 */
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
80002cc4:	eb cd 40 80 	pushm	r7,lr
80002cc8:	1a 97       	mov	r7,sp
80002cca:	20 2d       	sub	sp,8
80002ccc:	ef 4c ff f8 	st.w	r7[-8],r12
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80002cd0:	e1 b8 00 00 	mfsr	r8,0x0
80002cd4:	10 9c       	mov	r12,r8
80002cd6:	f0 1f 00 18 	mcall	80002d34 <usart_reset+0x70>
80002cda:	18 98       	mov	r8,r12
80002cdc:	ef 68 ff ff 	st.b	r7[-1],r8

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80002ce0:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80002ce4:	30 08       	mov	r8,0
80002ce6:	f0 09 18 00 	cp.b	r9,r8
80002cea:	c0 20       	breq	80002cee <usart_reset+0x2a>
80002cec:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80002cee:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002cf2:	3f f9       	mov	r9,-1
80002cf4:	91 39       	st.w	r8[0xc],r9
  usart->csr;
80002cf6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002cfa:	70 58       	ld.w	r8,r8[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80002cfc:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80002d00:	30 08       	mov	r8,0
80002d02:	f0 09 18 00 	cp.b	r9,r8
80002d06:	c0 20       	breq	80002d0a <usart_reset+0x46>
80002d08:	d5 03       	csrf	0x10

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80002d0a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d0e:	30 09       	mov	r9,0
80002d10:	91 19       	st.w	r8[0x4],r9
  usart->rtor = 0;
80002d12:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d16:	30 09       	mov	r9,0
80002d18:	91 99       	st.w	r8[0x24],r9
  usart->ttgr = 0;
80002d1a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d1e:	30 09       	mov	r9,0
80002d20:	91 a9       	st.w	r8[0x28],r9

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80002d22:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d26:	ea 69 61 0c 	mov	r9,680204
80002d2a:	91 09       	st.w	r8[0x0],r9
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80002d2c:	2f ed       	sub	sp,-8
80002d2e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002d32:	00 00       	add	r0,r0
80002d34:	80 00       	ld.sh	r0,r0[0x0]
80002d36:	2b d0       	sub	r0,-67

80002d38 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80002d38:	eb cd 40 80 	pushm	r7,lr
80002d3c:	1a 97       	mov	r7,sp
80002d3e:	20 3d       	sub	sp,12
80002d40:	ef 4c ff fc 	st.w	r7[-4],r12
80002d44:	ef 4b ff f8 	st.w	r7[-8],r11
80002d48:	ef 4a ff f4 	st.w	r7[-12],r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80002d4c:	ee fc ff fc 	ld.w	r12,r7[-4]
80002d50:	f0 1f 00 54 	mcall	80002ea0 <usart_init_rs232+0x168>

  // Check input values.
  if (!opt || // Null pointer.
80002d54:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d58:	58 08       	cp.w	r8,0
80002d5a:	c3 90       	breq	80002dcc <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80002d5c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d60:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002d62:	30 48       	mov	r8,4
80002d64:	f0 09 18 00 	cp.b	r9,r8
80002d68:	e0 88 00 32 	brls	80002dcc <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80002d6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d70:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002d72:	30 98       	mov	r8,9
80002d74:	f0 09 18 00 	cp.b	r9,r8
80002d78:	e0 8b 00 2a 	brhi	80002dcc <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80002d7c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d80:	11 d9       	ld.ub	r9,r8[0x5]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002d82:	30 78       	mov	r8,7
80002d84:	f0 09 18 00 	cp.b	r9,r8
80002d88:	e0 8b 00 22 	brhi	80002dcc <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
80002d8c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d90:	90 39       	ld.sh	r9,r8[0x6]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002d92:	e0 68 01 01 	mov	r8,257
80002d96:	f0 09 19 00 	cp.h	r9,r8
80002d9a:	e0 8b 00 19 	brhi	80002dcc <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
80002d9e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002da2:	f1 39 00 08 	ld.ub	r9,r8[8]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002da6:	30 38       	mov	r8,3
80002da8:	f0 09 18 00 	cp.b	r9,r8
80002dac:	e0 8b 00 10 	brhi	80002dcc <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80002db0:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002db4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002db8:	70 08       	ld.w	r8,r8[0x0]
80002dba:	12 9a       	mov	r10,r9
80002dbc:	10 9b       	mov	r11,r8
80002dbe:	ee fc ff fc 	ld.w	r12,r7[-4]
80002dc2:	f0 1f 00 39 	mcall	80002ea4 <usart_init_rs232+0x16c>
80002dc6:	18 98       	mov	r8,r12
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002dc8:	58 18       	cp.w	r8,1
80002dca:	c0 31       	brne	80002dd0 <usart_init_rs232+0x98>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;
80002dcc:	30 18       	mov	r8,1
80002dce:	c6 48       	rjmp	80002e96 <usart_init_rs232+0x15e>

  if (opt->charlength == 9)
80002dd0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dd4:	11 c9       	ld.ub	r9,r8[0x4]
80002dd6:	30 98       	mov	r8,9
80002dd8:	f0 09 18 00 	cp.b	r9,r8
80002ddc:	c0 a1       	brne	80002df0 <usart_init_rs232+0xb8>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80002dde:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002de2:	70 18       	ld.w	r8,r8[0x4]
80002de4:	10 99       	mov	r9,r8
80002de6:	b1 b9       	sbr	r9,0x11
80002de8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002dec:	91 19       	st.w	r8[0x4],r9
80002dee:	c0 d8       	rjmp	80002e08 <usart_init_rs232+0xd0>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80002df0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002df4:	70 19       	ld.w	r9,r8[0x4]
80002df6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dfa:	11 c8       	ld.ub	r8,r8[0x4]
80002dfc:	20 58       	sub	r8,5
80002dfe:	a7 68       	lsl	r8,0x6
80002e00:	10 49       	or	r9,r8
80002e02:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e06:	91 19       	st.w	r8[0x4],r9
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80002e08:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e0c:	70 19       	ld.w	r9,r8[0x4]
80002e0e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e12:	11 d8       	ld.ub	r8,r8[0x5]
80002e14:	f0 0a 15 09 	lsl	r10,r8,0x9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;
80002e18:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e1c:	f1 38 00 08 	ld.ub	r8,r8[8]
80002e20:	af 68       	lsl	r8,0xe
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80002e22:	f5 e8 10 08 	or	r8,r10,r8
80002e26:	10 49       	or	r9,r8
80002e28:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e2c:	91 19       	st.w	r8[0x4],r9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80002e2e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e32:	90 39       	ld.sh	r9,r8[0x6]
80002e34:	30 28       	mov	r8,2
80002e36:	f0 09 19 00 	cp.h	r9,r8
80002e3a:	e0 88 00 14 	brls	80002e62 <usart_init_rs232+0x12a>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80002e3e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e42:	70 18       	ld.w	r8,r8[0x4]
80002e44:	10 99       	mov	r9,r8
80002e46:	ad b9       	sbr	r9,0xd
80002e48:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e4c:	91 19       	st.w	r8[0x4],r9
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80002e4e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e52:	90 38       	ld.sh	r8,r8[0x6]
80002e54:	5c 78       	castu.h	r8
80002e56:	20 28       	sub	r8,2
80002e58:	10 99       	mov	r9,r8
80002e5a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e5e:	91 a9       	st.w	r8[0x28],r9
80002e60:	c0 d8       	rjmp	80002e7a <usart_init_rs232+0x142>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80002e62:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e66:	70 19       	ld.w	r9,r8[0x4]
80002e68:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e6c:	90 38       	ld.sh	r8,r8[0x6]
80002e6e:	5c 78       	castu.h	r8
80002e70:	ad 68       	lsl	r8,0xc
80002e72:	10 49       	or	r9,r8
80002e74:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e78:	91 19       	st.w	r8[0x4],r9

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80002e7a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e7e:	70 18       	ld.w	r8,r8[0x4]
80002e80:	10 99       	mov	r9,r8
80002e82:	e0 19 ff f0 	andl	r9,0xfff0
80002e86:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e8a:	91 19       	st.w	r8[0x4],r9
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80002e8c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e90:	35 09       	mov	r9,80
80002e92:	91 09       	st.w	r8[0x0],r9
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80002e94:	30 08       	mov	r8,0
}
80002e96:	10 9c       	mov	r12,r8
80002e98:	2f dd       	sub	sp,-12
80002e9a:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e9e:	00 00       	add	r0,r0
80002ea0:	80 00       	ld.sh	r0,r0[0x0]
80002ea2:	2c c4       	sub	r4,-52
80002ea4:	80 00       	ld.sh	r0,r0[0x0]
80002ea6:	2b f0       	sub	r0,-65

80002ea8 <usart_write_char>:
  return USART_SUCCESS;
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
80002ea8:	eb cd 40 80 	pushm	r7,lr
80002eac:	1a 97       	mov	r7,sp
80002eae:	20 3d       	sub	sp,12
80002eb0:	ef 4c ff f8 	st.w	r7[-8],r12
80002eb4:	ef 4b ff f4 	st.w	r7[-12],r11
80002eb8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ebc:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80002ec0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ec4:	70 58       	ld.w	r8,r8[0x14]
80002ec6:	e2 18 00 02 	andl	r8,0x2,COH
80002eca:	5f 18       	srne	r8
  if (usart_tx_ready(usart))
80002ecc:	58 08       	cp.w	r8,0
80002ece:	c0 a0       	breq	80002ee2 <usart_write_char+0x3a>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80002ed0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002ed4:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80002ed8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002edc:	91 79       	st.w	r8[0x1c],r9
    return USART_SUCCESS;
80002ede:	30 08       	mov	r8,0
80002ee0:	c0 28       	rjmp	80002ee4 <usart_write_char+0x3c>
  }
  else
    return USART_TX_BUSY;
80002ee2:	30 28       	mov	r8,2
}
80002ee4:	10 9c       	mov	r12,r8
80002ee6:	2f dd       	sub	sp,-12
80002ee8:	e3 cd 80 80 	ldm	sp++,r7,pc

80002eec <usart_putchar>:


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80002eec:	eb cd 40 80 	pushm	r7,lr
80002ef0:	1a 97       	mov	r7,sp
80002ef2:	20 3d       	sub	sp,12
80002ef4:	ef 4c ff f8 	st.w	r7[-8],r12
80002ef8:	ef 4b ff f4 	st.w	r7[-12],r11
  int timeout = USART_DEFAULT_TIMEOUT;
80002efc:	e0 68 27 10 	mov	r8,10000
80002f00:	ef 48 ff fc 	st.w	r7[-4],r8

  do
  {
    if (!timeout--) return USART_FAILURE;
80002f04:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002f08:	58 08       	cp.w	r8,0
80002f0a:	5f 08       	sreq	r8
80002f0c:	5c 58       	castu.b	r8
80002f0e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002f12:	20 19       	sub	r9,1
80002f14:	ef 49 ff fc 	st.w	r7[-4],r9
80002f18:	58 08       	cp.w	r8,0
80002f1a:	c0 30       	breq	80002f20 <usart_putchar+0x34>
80002f1c:	3f f8       	mov	r8,-1
80002f1e:	c0 b8       	rjmp	80002f34 <usart_putchar+0x48>
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80002f20:	ee fb ff f4 	ld.w	r11,r7[-12]
80002f24:	ee fc ff f8 	ld.w	r12,r7[-8]
80002f28:	f0 1f 00 05 	mcall	80002f3c <usart_putchar+0x50>
80002f2c:	18 98       	mov	r8,r12
80002f2e:	58 08       	cp.w	r8,0
80002f30:	ce a1       	brne	80002f04 <usart_putchar+0x18>

  return USART_SUCCESS;
80002f32:	30 08       	mov	r8,0
}
80002f34:	10 9c       	mov	r12,r8
80002f36:	2f dd       	sub	sp,-12
80002f38:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f3c:	80 00       	ld.sh	r0,r0[0x0]
80002f3e:	2e a8       	sub	r8,-22

80002f40 <usart_write_line>:
  return c;
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80002f40:	eb cd 40 80 	pushm	r7,lr
80002f44:	1a 97       	mov	r7,sp
80002f46:	20 2d       	sub	sp,8
80002f48:	ef 4c ff fc 	st.w	r7[-4],r12
80002f4c:	ef 4b ff f8 	st.w	r7[-8],r11
  while (*string != '\0')
80002f50:	c0 e8       	rjmp	80002f6c <usart_write_line+0x2c>
    usart_putchar(usart, *string++);
80002f52:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002f56:	11 88       	ld.ub	r8,r8[0x0]
80002f58:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002f5c:	2f f9       	sub	r9,-1
80002f5e:	ef 49 ff f8 	st.w	r7[-8],r9
80002f62:	10 9b       	mov	r11,r8
80002f64:	ee fc ff fc 	ld.w	r12,r7[-4]
80002f68:	f0 1f 00 05 	mcall	80002f7c <usart_write_line+0x3c>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80002f6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002f70:	11 88       	ld.ub	r8,r8[0x0]
80002f72:	58 08       	cp.w	r8,0
80002f74:	ce f1       	brne	80002f52 <usart_write_line+0x12>
    usart_putchar(usart, *string++);
}
80002f76:	2f ed       	sub	sp,-8
80002f78:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f7c:	80 00       	ld.sh	r0,r0[0x0]
80002f7e:	2e ec       	sub	r12,-18

80002f80 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
80002f80:	eb cd 40 80 	pushm	r7,lr
80002f84:	1a 97       	mov	r7,sp
80002f86:	20 1d       	sub	sp,4
80002f88:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80002f8c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002f90:	2f 88       	sub	r8,-8
80002f92:	10 99       	mov	r9,r8
80002f94:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002f98:	91 19       	st.w	r8[0x4],r9

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80002f9a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002f9e:	3f f9       	mov	r9,-1
80002fa0:	91 29       	st.w	r8[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80002fa2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fa6:	2f 88       	sub	r8,-8
80002fa8:	10 99       	mov	r9,r8
80002faa:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fae:	91 39       	st.w	r8[0xc],r9
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80002fb0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fb4:	2f 88       	sub	r8,-8
80002fb6:	10 99       	mov	r9,r8
80002fb8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fbc:	91 49       	st.w	r8[0x10],r9

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80002fbe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fc2:	30 09       	mov	r9,0
80002fc4:	91 09       	st.w	r8[0x0],r9
}
80002fc6:	2f fd       	sub	sp,-4
80002fc8:	e3 cd 80 80 	ldm	sp++,r7,pc

80002fcc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
80002fcc:	eb cd 40 80 	pushm	r7,lr
80002fd0:	1a 97       	mov	r7,sp
80002fd2:	20 1d       	sub	sp,4
80002fd4:	ef 4c ff fc 	st.w	r7[-4],r12
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80002fd8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fdc:	30 09       	mov	r9,0
80002fde:	91 49       	st.w	r8[0x10],r9
}
80002fe0:	2f fd       	sub	sp,-4
80002fe2:	e3 cd 80 80 	ldm	sp++,r7,pc

80002fe6 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
80002fe6:	eb cd 40 80 	pushm	r7,lr
80002fea:	1a 97       	mov	r7,sp
80002fec:	20 3d       	sub	sp,12
80002fee:	ef 4c ff f8 	st.w	r7[-8],r12
80002ff2:	ef 4b ff f4 	st.w	r7[-12],r11

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80002ff6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ffa:	70 18       	ld.w	r8,r8[0x4]
80002ffc:	ef 48 ff fc 	st.w	r7[-4],r8

	pxNewListItem->pxNext = pxIndex->pxNext;
80003000:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003004:	70 19       	ld.w	r9,r8[0x4]
80003006:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000300a:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
8000300c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003010:	70 19       	ld.w	r9,r8[0x4]
80003012:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003016:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80003018:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000301c:	70 18       	ld.w	r8,r8[0x4]
8000301e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003022:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80003024:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003028:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000302c:	91 19       	st.w	r8[0x4],r9
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
8000302e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003032:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003036:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80003038:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000303c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003040:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80003042:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003046:	70 08       	ld.w	r8,r8[0x0]
80003048:	f0 c9 ff ff 	sub	r9,r8,-1
8000304c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003050:	91 09       	st.w	r8[0x0],r9
}
80003052:	2f dd       	sub	sp,-12
80003054:	e3 cd 80 80 	ldm	sp++,r7,pc

80003058 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
80003058:	eb cd 40 80 	pushm	r7,lr
8000305c:	1a 97       	mov	r7,sp
8000305e:	20 4d       	sub	sp,16
80003060:	ef 4c ff f4 	st.w	r7[-12],r12
80003064:	ef 4b ff f0 	st.w	r7[-16],r11
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80003068:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000306c:	70 08       	ld.w	r8,r8[0x0]
8000306e:	ef 48 ff fc 	st.w	r7[-4],r8
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80003072:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003076:	5b f8       	cp.w	r8,-1
80003078:	c0 71       	brne	80003086 <vListInsert+0x2e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
8000307a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000307e:	70 48       	ld.w	r8,r8[0x10]
80003080:	ef 48 ff f8 	st.w	r7[-8],r8
80003084:	c1 58       	rjmp	800030ae <vListInsert+0x56>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80003086:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000308a:	2f 88       	sub	r8,-8
8000308c:	ef 48 ff f8 	st.w	r7[-8],r8
80003090:	c0 68       	rjmp	8000309c <vListInsert+0x44>
80003092:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003096:	70 18       	ld.w	r8,r8[0x4]
80003098:	ef 48 ff f8 	st.w	r7[-8],r8
8000309c:	ee f8 ff f8 	ld.w	r8,r7[-8]
800030a0:	70 18       	ld.w	r8,r8[0x4]
800030a2:	70 09       	ld.w	r9,r8[0x0]
800030a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030a8:	10 39       	cp.w	r9,r8
800030aa:	fe 98 ff f4 	brls	80003092 <vListInsert+0x3a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
800030ae:	ee f8 ff f8 	ld.w	r8,r7[-8]
800030b2:	70 19       	ld.w	r9,r8[0x4]
800030b4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800030b8:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800030ba:	ee f8 ff f0 	ld.w	r8,r7[-16]
800030be:	70 18       	ld.w	r8,r8[0x4]
800030c0:	ee f9 ff f0 	ld.w	r9,r7[-16]
800030c4:	91 29       	st.w	r8[0x8],r9
	pxNewListItem->pxPrevious = pxIterator;
800030c6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800030ca:	ee f9 ff f8 	ld.w	r9,r7[-8]
800030ce:	91 29       	st.w	r8[0x8],r9
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
800030d0:	ee f9 ff f0 	ld.w	r9,r7[-16]
800030d4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800030d8:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800030da:	ee f8 ff f0 	ld.w	r8,r7[-16]
800030de:	ee f9 ff f4 	ld.w	r9,r7[-12]
800030e2:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
800030e4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800030e8:	70 08       	ld.w	r8,r8[0x0]
800030ea:	f0 c9 ff ff 	sub	r9,r8,-1
800030ee:	ee f8 ff f4 	ld.w	r8,r7[-12]
800030f2:	91 09       	st.w	r8[0x0],r9
}
800030f4:	2f cd       	sub	sp,-16
800030f6:	e3 cd 80 80 	ldm	sp++,r7,pc

800030fa <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
800030fa:	eb cd 40 80 	pushm	r7,lr
800030fe:	1a 97       	mov	r7,sp
80003100:	20 2d       	sub	sp,8
80003102:	ef 4c ff f8 	st.w	r7[-8],r12
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80003106:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000310a:	70 18       	ld.w	r8,r8[0x4]
8000310c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003110:	72 29       	ld.w	r9,r9[0x8]
80003112:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80003114:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003118:	70 28       	ld.w	r8,r8[0x8]
8000311a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000311e:	72 19       	ld.w	r9,r9[0x4]
80003120:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80003122:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003126:	70 48       	ld.w	r8,r8[0x10]
80003128:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
8000312c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003130:	70 19       	ld.w	r9,r8[0x4]
80003132:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003136:	10 39       	cp.w	r9,r8
80003138:	c0 71       	brne	80003146 <vListRemove+0x4c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
8000313a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000313e:	70 29       	ld.w	r9,r8[0x8]
80003140:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003144:	91 19       	st.w	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80003146:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000314a:	30 09       	mov	r9,0
8000314c:	91 49       	st.w	r8[0x10],r9
	( pxList->uxNumberOfItems )--;
8000314e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003152:	70 08       	ld.w	r8,r8[0x0]
80003154:	f0 c9 00 01 	sub	r9,r8,1
80003158:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000315c:	91 09       	st.w	r8[0x0],r9
}
8000315e:	2f ed       	sub	sp,-8
80003160:	e3 cd 80 80 	ldm	sp++,r7,pc

80003164 <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80003164:	eb cd 40 80 	pushm	r7,lr
80003168:	1a 97       	mov	r7,sp
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
8000316a:	48 e8       	lddpc	r8,800031a0 <_init_startup+0x3c>
8000316c:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
80003170:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
80003172:	f0 1f 00 0d 	mcall	800031a4 <_init_startup+0x40>
			.channelmode = USART_NORMAL_CHMODE
		};

		/* Initialize the USART used for the debug trace with the configured parameters. */
		extern volatile avr32_usart_t *volatile stdio_usart_base;
		stdio_usart_base = configDBG_USART;
80003176:	48 d8       	lddpc	r8,800031a8 <_init_startup+0x44>
80003178:	fe 79 18 00 	mov	r9,-59392
8000317c:	91 09       	st.w	r8[0x0],r9
		gpio_enable_module( DBG_USART_GPIO_MAP,
8000317e:	30 2b       	mov	r11,2
80003180:	48 bc       	lddpc	r12,800031ac <_init_startup+0x48>
80003182:	f0 1f 00 0c 	mcall	800031b0 <_init_startup+0x4c>
		                    sizeof( DBG_USART_GPIO_MAP ) / sizeof( DBG_USART_GPIO_MAP[0] ) );
		usart_init_rs232(configDBG_USART, &DBG_USART_OPTIONS, configPBA_CLOCK_HZ);
80003186:	e0 6a 1b 00 	mov	r10,6912
8000318a:	ea 1a 00 b7 	orh	r10,0xb7
8000318e:	48 ab       	lddpc	r11,800031b4 <_init_startup+0x50>
80003190:	fe 7c 18 00 	mov	r12,-59392
80003194:	f0 1f 00 09 	mcall	800031b8 <_init_startup+0x54>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
80003198:	30 18       	mov	r8,1
}
8000319a:	10 9c       	mov	r12,r8
8000319c:	e3 cd 80 80 	ldm	sp++,r7,pc
800031a0:	80 00       	ld.sh	r0,r0[0x0]
800031a2:	54 00       	stdsp	sp[0x100],r0
800031a4:	80 00       	ld.sh	r0,r0[0x0]
800031a6:	28 74       	sub	r4,-121
800031a8:	00 00       	add	r0,r0
800031aa:	07 94       	ld.ub	r4,r3[0x1]
800031ac:	80 00       	ld.sh	r0,r0[0x0]
800031ae:	56 e4       	stdsp	sp[0x1b8],r4
800031b0:	80 00       	ld.sh	r0,r0[0x0]
800031b2:	26 68       	sub	r8,102
800031b4:	80 00       	ld.sh	r0,r0[0x0]
800031b6:	56 f4       	stdsp	sp[0x1bc],r4
800031b8:	80 00       	ld.sh	r0,r0[0x0]
800031ba:	2d 38       	sub	r8,-45

800031bc <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800031bc:	eb cd 40 80 	pushm	r7,lr
800031c0:	1a 97       	mov	r7,sp
800031c2:	20 1d       	sub	sp,4
800031c4:	ef 4c ff fc 	st.w	r7[-4],r12
	vTaskSuspendAll();
800031c8:	f0 1f 00 03 	mcall	800031d4 <__malloc_lock+0x18>
}
800031cc:	2f fd       	sub	sp,-4
800031ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800031d2:	00 00       	add	r0,r0
800031d4:	80 00       	ld.sh	r0,r0[0x0]
800031d6:	40 54       	lddsp	r4,sp[0x14]

800031d8 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800031d8:	eb cd 40 80 	pushm	r7,lr
800031dc:	1a 97       	mov	r7,sp
800031de:	20 1d       	sub	sp,4
800031e0:	ef 4c ff fc 	st.w	r7[-4],r12
	xTaskResumeAll();
800031e4:	f0 1f 00 03 	mcall	800031f0 <__malloc_unlock+0x18>
}
800031e8:	2f fd       	sub	sp,-4
800031ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800031ee:	00 00       	add	r0,r0
800031f0:	80 00       	ld.sh	r0,r0[0x0]
800031f2:	40 70       	lddsp	r0,sp[0x1c]

800031f4 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800031f4:	eb cd 00 ff 	pushm	r0-r7
800031f8:	e0 68 00 1c 	mov	r8,28
800031fc:	ea 18 00 00 	orh	r8,0x0
80003200:	70 00       	ld.w	r0,r8[0x0]
80003202:	1a d0       	st.w	--sp,r0
80003204:	7a 90       	ld.w	r0,sp[0x24]
80003206:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000320a:	58 10       	cp.w	r0,1
8000320c:	e0 8b 00 08 	brhi	8000321c <LABEL_INT_SKIP_SAVE_CONTEXT_234>
80003210:	e0 68 06 1c 	mov	r8,1564
80003214:	ea 18 00 00 	orh	r8,0x0
80003218:	70 00       	ld.w	r0,r8[0x0]
8000321a:	81 0d       	st.w	r0[0x0],sp

8000321c <LABEL_INT_SKIP_SAVE_CONTEXT_234>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
8000321c:	f0 1f 00 12 	mcall	80003264 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80003220:	f0 1f 00 12 	mcall	80003268 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
		vTaskIncrementTick();
80003224:	f0 1f 00 12 	mcall	8000326c <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x1c>
	portEXIT_CRITICAL();
80003228:	f0 1f 00 12 	mcall	80003270 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
8000322c:	7a 90       	ld.w	r0,sp[0x24]
8000322e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80003232:	58 10       	cp.w	r0,1
80003234:	e0 8b 00 0e 	brhi	80003250 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
80003238:	f0 1f 00 0c 	mcall	80003268 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
8000323c:	f0 1f 00 0e 	mcall	80003274 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x24>
80003240:	f0 1f 00 0c 	mcall	80003270 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>
80003244:	e0 68 06 1c 	mov	r8,1564
80003248:	ea 18 00 00 	orh	r8,0x0
8000324c:	70 00       	ld.w	r0,r8[0x0]
8000324e:	60 0d       	ld.w	sp,r0[0x0]

80003250 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>:
80003250:	1b 00       	ld.w	r0,sp++
80003252:	e0 68 00 1c 	mov	r8,28
80003256:	ea 18 00 00 	orh	r8,0x0
8000325a:	91 00       	st.w	r8[0x0],r0
8000325c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80003260:	d6 03       	rete
80003262:	00 00       	add	r0,r0
80003264:	80 00       	ld.sh	r0,r0[0x0]
80003266:	35 60       	mov	r0,86
80003268:	80 00       	ld.sh	r0,r0[0x0]
8000326a:	33 10       	mov	r0,49
8000326c:	80 00       	ld.sh	r0,r0[0x0]
8000326e:	41 c8       	lddsp	r8,sp[0x70]
80003270:	80 00       	ld.sh	r0,r0[0x0]
80003272:	33 2c       	mov	r12,50
80003274:	80 00       	ld.sh	r0,r0[0x0]
80003276:	43 28       	lddsp	r8,sp[0xc8]

80003278 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80003278:	20 6d       	sub	sp,24
8000327a:	eb cd 00 ff 	pushm	r0-r7
8000327e:	fa c7 ff c0 	sub	r7,sp,-64
80003282:	ee f0 ff f8 	ld.w	r0,r7[-8]
80003286:	ef 40 ff e0 	st.w	r7[-32],r0
8000328a:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000328e:	ef 40 ff e4 	st.w	r7[-28],r0
80003292:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80003296:	e0 68 00 1c 	mov	r8,28
8000329a:	ea 18 00 00 	orh	r8,0x0
8000329e:	70 00       	ld.w	r0,r8[0x0]
800032a0:	1a d0       	st.w	--sp,r0
800032a2:	f0 1f 00 1a 	mcall	80003308 <LABEL_RET_SCALL_260+0x14>
800032a6:	e0 68 06 1c 	mov	r8,1564
800032aa:	ea 18 00 00 	orh	r8,0x0
800032ae:	70 00       	ld.w	r0,r8[0x0]
800032b0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800032b2:	f0 1f 00 17 	mcall	8000330c <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
800032b6:	e0 68 06 1c 	mov	r8,1564
800032ba:	ea 18 00 00 	orh	r8,0x0
800032be:	70 00       	ld.w	r0,r8[0x0]
800032c0:	60 0d       	ld.w	sp,r0[0x0]
800032c2:	1b 00       	ld.w	r0,sp++
800032c4:	e0 68 00 1c 	mov	r8,28
800032c8:	ea 18 00 00 	orh	r8,0x0
800032cc:	91 00       	st.w	r8[0x0],r0
800032ce:	fa c7 ff d8 	sub	r7,sp,-40
800032d2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800032d6:	ee f0 ff e0 	ld.w	r0,r7[-32]
800032da:	e0 61 00 1c 	mov	r1,28
800032de:	ea 11 00 00 	orh	r1,0x0
800032e2:	62 02       	ld.w	r2,r1[0x0]
800032e4:	58 02       	cp.w	r2,0
800032e6:	c0 70       	breq	800032f4 <LABEL_RET_SCALL_260>
800032e8:	e4 c2 00 01 	sub	r2,r2,1
800032ec:	83 02       	st.w	r1[0x0],r2
800032ee:	58 02       	cp.w	r2,0
800032f0:	c0 21       	brne	800032f4 <LABEL_RET_SCALL_260>
800032f2:	b1 c0       	cbr	r0,0x10

800032f4 <LABEL_RET_SCALL_260>:
800032f4:	ef 40 ff f8 	st.w	r7[-8],r0
800032f8:	ee f0 ff e4 	ld.w	r0,r7[-28]
800032fc:	ef 40 ff fc 	st.w	r7[-4],r0
80003300:	e3 cd 00 ff 	ldm	sp++,r0-r7
80003304:	2f ad       	sub	sp,-24
80003306:	d6 13       	rets
80003308:	80 00       	ld.sh	r0,r0[0x0]
8000330a:	33 10       	mov	r0,49
8000330c:	80 00       	ld.sh	r0,r0[0x0]
8000330e:	43 28       	lddsp	r8,sp[0xc8]

80003310 <vPortEnterCritical>:
/* The code generated by the GCC compiler uses the stack in different ways at
different optimisation levels.  The interrupt flags can therefore not always
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
80003310:	eb cd 40 80 	pushm	r7,lr
80003314:	1a 97       	mov	r7,sp
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80003316:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80003318:	48 48       	lddpc	r8,80003328 <vPortEnterCritical+0x18>
8000331a:	70 08       	ld.w	r8,r8[0x0]
8000331c:	f0 c9 ff ff 	sub	r9,r8,-1
80003320:	48 28       	lddpc	r8,80003328 <vPortEnterCritical+0x18>
80003322:	91 09       	st.w	r8[0x0],r9
}
80003324:	e3 cd 80 80 	ldm	sp++,r7,pc
80003328:	00 00       	add	r0,r0
8000332a:	00 1c       	sub	r12,r0

8000332c <vPortExitCritical>:
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
8000332c:	eb cd 40 80 	pushm	r7,lr
80003330:	1a 97       	mov	r7,sp
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80003332:	48 98       	lddpc	r8,80003354 <vPortExitCritical+0x28>
80003334:	70 08       	ld.w	r8,r8[0x0]
80003336:	58 08       	cp.w	r8,0
80003338:	c0 c0       	breq	80003350 <vPortExitCritical+0x24>
	{
		ulCriticalNesting--;
8000333a:	48 78       	lddpc	r8,80003354 <vPortExitCritical+0x28>
8000333c:	70 08       	ld.w	r8,r8[0x0]
8000333e:	f0 c9 00 01 	sub	r9,r8,1
80003342:	48 58       	lddpc	r8,80003354 <vPortExitCritical+0x28>
80003344:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80003346:	48 48       	lddpc	r8,80003354 <vPortExitCritical+0x28>
80003348:	70 08       	ld.w	r8,r8[0x0]
8000334a:	58 08       	cp.w	r8,0
8000334c:	c0 21       	brne	80003350 <vPortExitCritical+0x24>
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000334e:	d5 03       	csrf	0x10
		}
	}
}
80003350:	e3 cd 80 80 	ldm	sp++,r7,pc
80003354:	00 00       	add	r0,r0
80003356:	00 1c       	sub	r12,r0

80003358 <pxPortInitialiseStack>:
 * portSAVE_CONTEXT had been called.
 *
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
80003358:	eb cd 40 80 	pushm	r7,lr
8000335c:	1a 97       	mov	r7,sp
8000335e:	20 3d       	sub	sp,12
80003360:	ef 4c ff fc 	st.w	r7[-4],r12
80003364:	ef 4b ff f8 	st.w	r7[-8],r11
80003368:	ef 4a ff f4 	st.w	r7[-12],r10
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
8000336c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003370:	20 48       	sub	r8,4
80003372:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80003376:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000337a:	e0 69 08 08 	mov	r9,2056
8000337e:	ea 19 08 08 	orh	r9,0x808
80003382:	91 09       	st.w	r8[0x0],r9
80003384:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003388:	20 48       	sub	r8,4
8000338a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000338e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003392:	e0 69 09 09 	mov	r9,2313
80003396:	ea 19 09 09 	orh	r9,0x909
8000339a:	91 09       	st.w	r8[0x0],r9
8000339c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033a0:	20 48       	sub	r8,4
800033a2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800033a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033aa:	e0 69 0a 0a 	mov	r9,2570
800033ae:	ea 19 0a 0a 	orh	r9,0xa0a
800033b2:	91 09       	st.w	r8[0x0],r9
800033b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033b8:	20 48       	sub	r8,4
800033ba:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800033be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033c2:	e0 69 0b 0b 	mov	r9,2827
800033c6:	ea 19 0b 0b 	orh	r9,0xb0b
800033ca:	91 09       	st.w	r8[0x0],r9
800033cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033d0:	20 48       	sub	r8,4
800033d2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800033d6:	ee f9 ff f4 	ld.w	r9,r7[-12]
800033da:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033de:	91 09       	st.w	r8[0x0],r9
800033e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033e4:	20 48       	sub	r8,4
800033e6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800033ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033ee:	e0 69 be ef 	mov	r9,48879
800033f2:	ea 19 de ad 	orh	r9,0xdead
800033f6:	91 09       	st.w	r8[0x0],r9
800033f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033fc:	20 48       	sub	r8,4
800033fe:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80003402:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003406:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000340a:	91 09       	st.w	r8[0x0],r9
8000340c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003410:	20 48       	sub	r8,4
80003412:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80003416:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000341a:	fc 19 00 40 	movh	r9,0x40
8000341e:	91 09       	st.w	r8[0x0],r9
80003420:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003424:	20 48       	sub	r8,4
80003426:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
8000342a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000342e:	e0 69 00 ff 	mov	r9,255
80003432:	ea 19 ff 00 	orh	r9,0xff00
80003436:	91 09       	st.w	r8[0x0],r9
80003438:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000343c:	20 48       	sub	r8,4
8000343e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80003442:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003446:	e0 69 01 01 	mov	r9,257
8000344a:	ea 19 01 01 	orh	r9,0x101
8000344e:	91 09       	st.w	r8[0x0],r9
80003450:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003454:	20 48       	sub	r8,4
80003456:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
8000345a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000345e:	e0 69 02 02 	mov	r9,514
80003462:	ea 19 02 02 	orh	r9,0x202
80003466:	91 09       	st.w	r8[0x0],r9
80003468:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000346c:	20 48       	sub	r8,4
8000346e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80003472:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003476:	e0 69 03 03 	mov	r9,771
8000347a:	ea 19 03 03 	orh	r9,0x303
8000347e:	91 09       	st.w	r8[0x0],r9
80003480:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003484:	20 48       	sub	r8,4
80003486:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
8000348a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000348e:	e0 69 04 04 	mov	r9,1028
80003492:	ea 19 04 04 	orh	r9,0x404
80003496:	91 09       	st.w	r8[0x0],r9
80003498:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000349c:	20 48       	sub	r8,4
8000349e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800034a2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034a6:	e0 69 05 05 	mov	r9,1285
800034aa:	ea 19 05 05 	orh	r9,0x505
800034ae:	91 09       	st.w	r8[0x0],r9
800034b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034b4:	20 48       	sub	r8,4
800034b6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800034ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034be:	e0 69 06 06 	mov	r9,1542
800034c2:	ea 19 06 06 	orh	r9,0x606
800034c6:	91 09       	st.w	r8[0x0],r9
800034c8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034cc:	20 48       	sub	r8,4
800034ce:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800034d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034d6:	e0 69 07 07 	mov	r9,1799
800034da:	ea 19 07 07 	orh	r9,0x707
800034de:	91 09       	st.w	r8[0x0],r9
800034e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034e4:	20 48       	sub	r8,4
800034e6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800034ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034ee:	30 09       	mov	r9,0
800034f0:	91 09       	st.w	r8[0x0],r9

	return pxTopOfStack;
800034f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800034f6:	10 9c       	mov	r12,r8
800034f8:	2f dd       	sub	sp,-12
800034fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800034fe:	d7 03       	nop

80003500 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80003500:	eb cd 40 80 	pushm	r7,lr
80003504:	1a 97       	mov	r7,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
80003506:	f0 1f 00 10 	mcall	80003544 <xPortStartScheduler+0x44>

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000350a:	e0 68 06 1c 	mov	r8,1564
8000350e:	ea 18 00 00 	orh	r8,0x0
80003512:	70 00       	ld.w	r0,r8[0x0]
80003514:	60 0d       	ld.w	sp,r0[0x0]
80003516:	1b 00       	ld.w	r0,sp++
80003518:	e0 68 00 1c 	mov	r8,28
8000351c:	ea 18 00 00 	orh	r8,0x0
80003520:	91 00       	st.w	r8[0x0],r0
80003522:	e3 cd 00 ff 	ldm	sp++,r0-r7
80003526:	2f ed       	sub	sp,-8
80003528:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000352c:	fa f0 ff e0 	ld.w	r0,sp[-32]
80003530:	e3 b0 00 00 	mtsr	0x0,r0
80003534:	fa f0 ff dc 	ld.w	r0,sp[-36]
80003538:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
8000353c:	30 08       	mov	r8,0
}
8000353e:	10 9c       	mov	r12,r8
80003540:	e3 cd 80 80 	ldm	sp++,r7,pc
80003544:	80 00       	ld.sh	r0,r0[0x0]
80003546:	35 74       	mov	r4,87

80003548 <prvScheduleFirstTick>:

/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
80003548:	eb cd 40 80 	pushm	r7,lr
8000354c:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
8000354e:	e0 68 2e e0 	mov	r8,12000
80003552:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80003556:	30 08       	mov	r8,0
80003558:	e3 b8 00 42 	mtsr	0x108,r8
	}
8000355c:	e3 cd 80 80 	ldm	sp++,r7,pc

80003560 <prvClearCcInt>:

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
80003560:	eb cd 40 80 	pushm	r7,lr
80003564:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80003566:	e1 b8 00 43 	mfsr	r8,0x10c
8000356a:	e3 b8 00 43 	mtsr	0x10c,r8
	}
8000356e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003572:	d7 03       	nop

80003574 <prvSetupTimerInterrupt>:
#endif
/*-----------------------------------------------------------*/

/* Setup the timer to generate the tick interrupts. */
static void prvSetupTimerInterrupt(void)
{
80003574:	eb cd 40 80 	pushm	r7,lr
80003578:	1a 97       	mov	r7,sp
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000357a:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
8000357c:	30 0a       	mov	r10,0
8000357e:	30 0b       	mov	r11,0
80003580:	48 4c       	lddpc	r12,80003590 <prvSetupTimerInterrupt+0x1c>
80003582:	f0 1f 00 05 	mcall	80003594 <prvSetupTimerInterrupt+0x20>
		prvScheduleFirstTick();
80003586:	f0 1f 00 05 	mcall	80003598 <prvSetupTimerInterrupt+0x24>
	}
	#endif
}
8000358a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000358e:	00 00       	add	r0,r0
80003590:	80 00       	ld.sh	r0,r0[0x0]
80003592:	31 f4       	mov	r4,31
80003594:	80 00       	ld.sh	r0,r0[0x0]
80003596:	29 0c       	sub	r12,-112
80003598:	80 00       	ld.sh	r0,r0[0x0]
8000359a:	35 48       	mov	r8,84

8000359c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
8000359c:	eb cd 40 80 	pushm	r7,lr
800035a0:	1a 97       	mov	r7,sp
800035a2:	20 2d       	sub	sp,8
800035a4:	ef 4c ff f8 	st.w	r7[-8],r12
void *pvReturn;

	vTaskSuspendAll();
800035a8:	f0 1f 00 09 	mcall	800035cc <pvPortMalloc+0x30>
	{
		pvReturn = malloc( xWantedSize );
800035ac:	ee fc ff f8 	ld.w	r12,r7[-8]
800035b0:	f0 1f 00 08 	mcall	800035d0 <pvPortMalloc+0x34>
800035b4:	18 98       	mov	r8,r12
800035b6:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	xTaskResumeAll();
800035ba:	f0 1f 00 07 	mcall	800035d4 <pvPortMalloc+0x38>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
800035be:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800035c2:	10 9c       	mov	r12,r8
800035c4:	2f ed       	sub	sp,-8
800035c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800035ca:	00 00       	add	r0,r0
800035cc:	80 00       	ld.sh	r0,r0[0x0]
800035ce:	40 54       	lddsp	r4,sp[0x14]
800035d0:	80 00       	ld.sh	r0,r0[0x0]
800035d2:	49 98       	lddpc	r8,80003634 <xQueueCreate+0x24>
800035d4:	80 00       	ld.sh	r0,r0[0x0]
800035d6:	40 70       	lddsp	r0,sp[0x1c]

800035d8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800035d8:	eb cd 40 80 	pushm	r7,lr
800035dc:	1a 97       	mov	r7,sp
800035de:	20 1d       	sub	sp,4
800035e0:	ef 4c ff fc 	st.w	r7[-4],r12
	if( pv )
800035e4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800035e8:	58 08       	cp.w	r8,0
800035ea:	c0 90       	breq	800035fc <vPortFree+0x24>
	{
		vTaskSuspendAll();
800035ec:	f0 1f 00 06 	mcall	80003604 <vPortFree+0x2c>
		{
			free( pv );
800035f0:	ee fc ff fc 	ld.w	r12,r7[-4]
800035f4:	f0 1f 00 05 	mcall	80003608 <vPortFree+0x30>
		}
		xTaskResumeAll();
800035f8:	f0 1f 00 05 	mcall	8000360c <vPortFree+0x34>
	}
}
800035fc:	2f fd       	sub	sp,-4
800035fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80003602:	00 00       	add	r0,r0
80003604:	80 00       	ld.sh	r0,r0[0x0]
80003606:	40 54       	lddsp	r4,sp[0x14]
80003608:	80 00       	ld.sh	r0,r0[0x0]
8000360a:	49 88       	lddpc	r8,80003668 <xQueueCreate+0x58>
8000360c:	80 00       	ld.sh	r0,r0[0x0]
8000360e:	40 70       	lddsp	r0,sp[0x1c]

80003610 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80003610:	eb cd 40 80 	pushm	r7,lr
80003614:	1a 97       	mov	r7,sp
80003616:	20 5d       	sub	sp,20
80003618:	ef 4c ff f0 	st.w	r7[-16],r12
8000361c:	ef 4b ff ec 	st.w	r7[-20],r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
80003620:	30 08       	mov	r8,0
80003622:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80003626:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000362a:	58 08       	cp.w	r8,0
8000362c:	c7 20       	breq	80003710 <xQueueCreate+0x100>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000362e:	34 cc       	mov	r12,76
80003630:	f0 1f 00 3b 	mcall	8000371c <xQueueCreate+0x10c>
80003634:	18 98       	mov	r8,r12
80003636:	ef 48 ff f4 	st.w	r7[-12],r8
		if( pxNewQueue != NULL )
8000363a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000363e:	58 08       	cp.w	r8,0
80003640:	c6 80       	breq	80003710 <xQueueCreate+0x100>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80003642:	ee f9 ff f0 	ld.w	r9,r7[-16]
80003646:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000364a:	f2 08 02 48 	mul	r8,r9,r8
8000364e:	2f f8       	sub	r8,-1
80003650:	ef 48 ff f8 	st.w	r7[-8],r8

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80003654:	ee fc ff f8 	ld.w	r12,r7[-8]
80003658:	f0 1f 00 31 	mcall	8000371c <xQueueCreate+0x10c>
8000365c:	18 98       	mov	r8,r12
8000365e:	10 99       	mov	r9,r8
80003660:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003664:	91 09       	st.w	r8[0x0],r9
			if( pxNewQueue->pcHead != NULL )
80003666:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000366a:	70 08       	ld.w	r8,r8[0x0]
8000366c:	58 08       	cp.w	r8,0
8000366e:	c4 d0       	breq	80003708 <xQueueCreate+0xf8>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80003670:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003674:	70 09       	ld.w	r9,r8[0x0]
80003676:	ee fa ff f0 	ld.w	r10,r7[-16]
8000367a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000367e:	f4 08 02 48 	mul	r8,r10,r8
80003682:	10 09       	add	r9,r8
80003684:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003688:	91 19       	st.w	r8[0x4],r9
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000368a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000368e:	30 09       	mov	r9,0
80003690:	91 e9       	st.w	r8[0x38],r9
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80003692:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003696:	70 09       	ld.w	r9,r8[0x0]
80003698:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000369c:	91 29       	st.w	r8[0x8],r9
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000369e:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036a2:	70 09       	ld.w	r9,r8[0x0]
800036a4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800036a8:	f0 ca 00 01 	sub	r10,r8,1
800036ac:	ee f8 ff ec 	ld.w	r8,r7[-20]
800036b0:	f4 08 02 48 	mul	r8,r10,r8
800036b4:	10 09       	add	r9,r8
800036b6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036ba:	91 39       	st.w	r8[0xc],r9
				pxNewQueue->uxLength = uxQueueLength;
800036bc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036c0:	ee f9 ff f0 	ld.w	r9,r7[-16]
800036c4:	91 f9       	st.w	r8[0x3c],r9
				pxNewQueue->uxItemSize = uxItemSize;
800036c6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036ca:	ee f9 ff ec 	ld.w	r9,r7[-20]
800036ce:	f1 49 00 40 	st.w	r8[64],r9
				pxNewQueue->xRxLock = queueUNLOCKED;
800036d2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036d6:	3f f9       	mov	r9,-1
800036d8:	f1 49 00 44 	st.w	r8[68],r9
				pxNewQueue->xTxLock = queueUNLOCKED;
800036dc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036e0:	3f f9       	mov	r9,-1
800036e2:	f1 49 00 48 	st.w	r8[72],r9

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800036e6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036ea:	2f 08       	sub	r8,-16
800036ec:	10 9c       	mov	r12,r8
800036ee:	f0 1f 00 0d 	mcall	80003720 <xQueueCreate+0x110>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800036f2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036f6:	2d c8       	sub	r8,-36
800036f8:	10 9c       	mov	r12,r8
800036fa:	f0 1f 00 0a 	mcall	80003720 <xQueueCreate+0x110>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
800036fe:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003702:	ef 48 ff fc 	st.w	r7[-4],r8
80003706:	c0 58       	rjmp	80003710 <xQueueCreate+0x100>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80003708:	ee fc ff f4 	ld.w	r12,r7[-12]
8000370c:	f0 1f 00 06 	mcall	80003724 <xQueueCreate+0x114>
		}
	}

	configASSERT( xReturn );

	return xReturn;
80003710:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80003714:	10 9c       	mov	r12,r8
80003716:	2f bd       	sub	sp,-20
80003718:	e3 cd 80 80 	ldm	sp++,r7,pc
8000371c:	80 00       	ld.sh	r0,r0[0x0]
8000371e:	35 9c       	mov	r12,89
80003720:	80 00       	ld.sh	r0,r0[0x0]
80003722:	2f 80       	sub	r0,-8
80003724:	80 00       	ld.sh	r0,r0[0x0]
80003726:	35 d8       	mov	r8,93

80003728 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80003728:	eb cd 40 80 	pushm	r7,lr
8000372c:	1a 97       	mov	r7,sp
8000372e:	20 7d       	sub	sp,28
80003730:	ef 4c ff f0 	st.w	r7[-16],r12
80003734:	ef 4b ff ec 	st.w	r7[-20],r11
80003738:	ef 4a ff e8 	st.w	r7[-24],r10
8000373c:	ef 49 ff e4 	st.w	r7[-28],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
80003740:	30 08       	mov	r8,0
80003742:	ef 48 ff fc 	st.w	r7[-4],r8
80003746:	c0 28       	rjmp	8000374a <xQueueGenericSend+0x22>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80003748:	d7 03       	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000374a:	f0 1f 00 47 	mcall	80003864 <xQueueGenericSend+0x13c>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000374e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003752:	70 e9       	ld.w	r9,r8[0x38]
80003754:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003758:	70 f8       	ld.w	r8,r8[0x3c]
8000375a:	10 39       	cp.w	r9,r8
8000375c:	c1 c2       	brcc	80003794 <xQueueGenericSend+0x6c>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000375e:	ee fa ff e4 	ld.w	r10,r7[-28]
80003762:	ee fb ff ec 	ld.w	r11,r7[-20]
80003766:	ee fc ff f0 	ld.w	r12,r7[-16]
8000376a:	f0 1f 00 40 	mcall	80003868 <xQueueGenericSend+0x140>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000376e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003772:	70 98       	ld.w	r8,r8[0x24]
80003774:	58 08       	cp.w	r8,0
80003776:	c0 b0       	breq	8000378c <xQueueGenericSend+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80003778:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000377c:	2d c8       	sub	r8,-36
8000377e:	10 9c       	mov	r12,r8
80003780:	f0 1f 00 3b 	mcall	8000386c <xQueueGenericSend+0x144>
80003784:	18 98       	mov	r8,r12
80003786:	58 18       	cp.w	r8,1
80003788:	c0 21       	brne	8000378c <xQueueGenericSend+0x64>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
8000378a:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
8000378c:	f0 1f 00 39 	mcall	80003870 <xQueueGenericSend+0x148>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80003790:	30 18       	mov	r8,1
80003792:	c6 58       	rjmp	8000385c <xQueueGenericSend+0x134>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80003794:	ee f8 ff e8 	ld.w	r8,r7[-24]
80003798:	58 08       	cp.w	r8,0
8000379a:	c0 51       	brne	800037a4 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000379c:	f0 1f 00 35 	mcall	80003870 <xQueueGenericSend+0x148>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800037a0:	30 08       	mov	r8,0
800037a2:	c5 d8       	rjmp	8000385c <xQueueGenericSend+0x134>
				}
				else if( xEntryTimeSet == pdFALSE )
800037a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800037a8:	58 08       	cp.w	r8,0
800037aa:	c0 91       	brne	800037bc <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800037ac:	ee c8 00 0c 	sub	r8,r7,12
800037b0:	10 9c       	mov	r12,r8
800037b2:	f0 1f 00 31 	mcall	80003874 <xQueueGenericSend+0x14c>
					xEntryTimeSet = pdTRUE;
800037b6:	30 18       	mov	r8,1
800037b8:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}
		}
		taskEXIT_CRITICAL();
800037bc:	f0 1f 00 2d 	mcall	80003870 <xQueueGenericSend+0x148>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800037c0:	f0 1f 00 2e 	mcall	80003878 <xQueueGenericSend+0x150>
		prvLockQueue( pxQueue );
800037c4:	f0 1f 00 28 	mcall	80003864 <xQueueGenericSend+0x13c>
800037c8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800037cc:	71 18       	ld.w	r8,r8[0x44]
800037ce:	5b f8       	cp.w	r8,-1
800037d0:	c0 61       	brne	800037dc <xQueueGenericSend+0xb4>
800037d2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800037d6:	30 09       	mov	r9,0
800037d8:	f1 49 00 44 	st.w	r8[68],r9
800037dc:	ee f8 ff f0 	ld.w	r8,r7[-16]
800037e0:	71 28       	ld.w	r8,r8[0x48]
800037e2:	5b f8       	cp.w	r8,-1
800037e4:	c0 61       	brne	800037f0 <xQueueGenericSend+0xc8>
800037e6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800037ea:	30 09       	mov	r9,0
800037ec:	f1 49 00 48 	st.w	r8[72],r9
800037f0:	f0 1f 00 20 	mcall	80003870 <xQueueGenericSend+0x148>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800037f4:	ee c9 00 18 	sub	r9,r7,24
800037f8:	ee c8 00 0c 	sub	r8,r7,12
800037fc:	12 9b       	mov	r11,r9
800037fe:	10 9c       	mov	r12,r8
80003800:	f0 1f 00 1f 	mcall	8000387c <xQueueGenericSend+0x154>
80003804:	18 98       	mov	r8,r12
80003806:	58 08       	cp.w	r8,0
80003808:	c2 31       	brne	8000384e <xQueueGenericSend+0x126>
		{
			if( prvIsQueueFull( pxQueue ) )
8000380a:	ee fc ff f0 	ld.w	r12,r7[-16]
8000380e:	f0 1f 00 1d 	mcall	80003880 <xQueueGenericSend+0x158>
80003812:	18 98       	mov	r8,r12
80003814:	58 08       	cp.w	r8,0
80003816:	c1 50       	breq	80003840 <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80003818:	ee f9 ff e8 	ld.w	r9,r7[-24]
8000381c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003820:	2f 08       	sub	r8,-16
80003822:	12 9b       	mov	r11,r9
80003824:	10 9c       	mov	r12,r8
80003826:	f0 1f 00 18 	mcall	80003884 <xQueueGenericSend+0x15c>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000382a:	ee fc ff f0 	ld.w	r12,r7[-16]
8000382e:	f0 1f 00 17 	mcall	80003888 <xQueueGenericSend+0x160>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80003832:	f0 1f 00 17 	mcall	8000388c <xQueueGenericSend+0x164>
80003836:	18 98       	mov	r8,r12
80003838:	58 08       	cp.w	r8,0
8000383a:	c8 71       	brne	80003748 <xQueueGenericSend+0x20>
				{
					portYIELD_WITHIN_API();
8000383c:	d7 33       	scall
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
8000383e:	c8 6b       	rjmp	8000374a <xQueueGenericSend+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80003840:	ee fc ff f0 	ld.w	r12,r7[-16]
80003844:	f0 1f 00 11 	mcall	80003888 <xQueueGenericSend+0x160>
				( void ) xTaskResumeAll();
80003848:	f0 1f 00 11 	mcall	8000388c <xQueueGenericSend+0x164>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
8000384c:	c7 fb       	rjmp	8000374a <xQueueGenericSend+0x22>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000384e:	ee fc ff f0 	ld.w	r12,r7[-16]
80003852:	f0 1f 00 0e 	mcall	80003888 <xQueueGenericSend+0x160>
			( void ) xTaskResumeAll();
80003856:	f0 1f 00 0e 	mcall	8000388c <xQueueGenericSend+0x164>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
8000385a:	30 08       	mov	r8,0
		}
	}
}
8000385c:	10 9c       	mov	r12,r8
8000385e:	2f 9d       	sub	sp,-28
80003860:	e3 cd 80 80 	ldm	sp++,r7,pc
80003864:	80 00       	ld.sh	r0,r0[0x0]
80003866:	33 10       	mov	r0,49
80003868:	80 00       	ld.sh	r0,r0[0x0]
8000386a:	3a 3c       	mov	r12,-93
8000386c:	80 00       	ld.sh	r0,r0[0x0]
8000386e:	44 58       	lddsp	r8,sp[0x114]
80003870:	80 00       	ld.sh	r0,r0[0x0]
80003872:	33 2c       	mov	r12,50
80003874:	80 00       	ld.sh	r0,r0[0x0]
80003876:	45 28       	lddsp	r8,sp[0x148]
80003878:	80 00       	ld.sh	r0,r0[0x0]
8000387a:	40 54       	lddsp	r4,sp[0x14]
8000387c:	80 00       	ld.sh	r0,r0[0x0]
8000387e:	45 58       	lddsp	r8,sp[0x154]
80003880:	80 00       	ld.sh	r0,r0[0x0]
80003882:	3c 90       	mov	r0,-55
80003884:	80 00       	ld.sh	r0,r0[0x0]
80003886:	43 d8       	lddsp	r8,sp[0xf4]
80003888:	80 00       	ld.sh	r0,r0[0x0]
8000388a:	3b 88       	mov	r8,-72
8000388c:	80 00       	ld.sh	r0,r0[0x0]
8000388e:	40 70       	lddsp	r0,sp[0x1c]

80003890 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80003890:	eb cd 40 80 	pushm	r7,lr
80003894:	1a 97       	mov	r7,sp
80003896:	20 8d       	sub	sp,32
80003898:	ef 4c ff ec 	st.w	r7[-20],r12
8000389c:	ef 4b ff e8 	st.w	r7[-24],r11
800038a0:	ef 4a ff e4 	st.w	r7[-28],r10
800038a4:	ef 49 ff e0 	st.w	r7[-32],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
800038a8:	30 08       	mov	r8,0
800038aa:	ef 48 ff f8 	st.w	r7[-8],r8
800038ae:	c0 28       	rjmp	800038b2 <xQueueGenericReceive+0x22>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800038b0:	d7 03       	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800038b2:	f0 1f 00 58 	mcall	80003a10 <xQueueGenericReceive+0x180>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800038b6:	ee f8 ff ec 	ld.w	r8,r7[-20]
800038ba:	70 e8       	ld.w	r8,r8[0x38]
800038bc:	58 08       	cp.w	r8,0
800038be:	c4 00       	breq	8000393e <xQueueGenericReceive+0xae>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800038c0:	ee f8 ff ec 	ld.w	r8,r7[-20]
800038c4:	70 38       	ld.w	r8,r8[0xc]
800038c6:	ef 48 ff fc 	st.w	r7[-4],r8

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800038ca:	ee fb ff e8 	ld.w	r11,r7[-24]
800038ce:	ee fc ff ec 	ld.w	r12,r7[-20]
800038d2:	f0 1f 00 51 	mcall	80003a14 <xQueueGenericReceive+0x184>

				if( xJustPeeking == pdFALSE )
800038d6:	ee f8 ff e0 	ld.w	r8,r7[-32]
800038da:	58 08       	cp.w	r8,0
800038dc:	c1 91       	brne	8000390e <xQueueGenericReceive+0x7e>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800038de:	ee f8 ff ec 	ld.w	r8,r7[-20]
800038e2:	70 e8       	ld.w	r8,r8[0x38]
800038e4:	f0 c9 00 01 	sub	r9,r8,1
800038e8:	ee f8 ff ec 	ld.w	r8,r7[-20]
800038ec:	91 e9       	st.w	r8[0x38],r9
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800038ee:	ee f8 ff ec 	ld.w	r8,r7[-20]
800038f2:	70 48       	ld.w	r8,r8[0x10]
800038f4:	58 08       	cp.w	r8,0
800038f6:	c2 00       	breq	80003936 <xQueueGenericReceive+0xa6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800038f8:	ee f8 ff ec 	ld.w	r8,r7[-20]
800038fc:	2f 08       	sub	r8,-16
800038fe:	10 9c       	mov	r12,r8
80003900:	f0 1f 00 46 	mcall	80003a18 <xQueueGenericReceive+0x188>
80003904:	18 98       	mov	r8,r12
80003906:	58 18       	cp.w	r8,1
80003908:	c1 71       	brne	80003936 <xQueueGenericReceive+0xa6>
						{
							portYIELD_WITHIN_API();
8000390a:	d7 33       	scall
8000390c:	c1 58       	rjmp	80003936 <xQueueGenericReceive+0xa6>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
8000390e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003912:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003916:	91 39       	st.w	r8[0xc],r9

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80003918:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000391c:	70 98       	ld.w	r8,r8[0x24]
8000391e:	58 08       	cp.w	r8,0
80003920:	c0 b0       	breq	80003936 <xQueueGenericReceive+0xa6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80003922:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003926:	2d c8       	sub	r8,-36
80003928:	10 9c       	mov	r12,r8
8000392a:	f0 1f 00 3c 	mcall	80003a18 <xQueueGenericReceive+0x188>
8000392e:	18 98       	mov	r8,r12
80003930:	58 08       	cp.w	r8,0
80003932:	c0 20       	breq	80003936 <xQueueGenericReceive+0xa6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80003934:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80003936:	f0 1f 00 3a 	mcall	80003a1c <xQueueGenericReceive+0x18c>
				return pdPASS;
8000393a:	30 18       	mov	r8,1
8000393c:	c6 68       	rjmp	80003a08 <xQueueGenericReceive+0x178>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000393e:	ee f8 ff e4 	ld.w	r8,r7[-28]
80003942:	58 08       	cp.w	r8,0
80003944:	c0 51       	brne	8000394e <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80003946:	f0 1f 00 36 	mcall	80003a1c <xQueueGenericReceive+0x18c>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000394a:	30 08       	mov	r8,0
8000394c:	c5 e8       	rjmp	80003a08 <xQueueGenericReceive+0x178>
				}
				else if( xEntryTimeSet == pdFALSE )
8000394e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003952:	58 08       	cp.w	r8,0
80003954:	c0 91       	brne	80003966 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80003956:	ee c8 00 10 	sub	r8,r7,16
8000395a:	10 9c       	mov	r12,r8
8000395c:	f0 1f 00 31 	mcall	80003a20 <xQueueGenericReceive+0x190>
					xEntryTimeSet = pdTRUE;
80003960:	30 18       	mov	r8,1
80003962:	ef 48 ff f8 	st.w	r7[-8],r8
				}
			}
		}
		taskEXIT_CRITICAL();
80003966:	f0 1f 00 2e 	mcall	80003a1c <xQueueGenericReceive+0x18c>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000396a:	f0 1f 00 2f 	mcall	80003a24 <xQueueGenericReceive+0x194>
		prvLockQueue( pxQueue );
8000396e:	f0 1f 00 29 	mcall	80003a10 <xQueueGenericReceive+0x180>
80003972:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003976:	71 18       	ld.w	r8,r8[0x44]
80003978:	5b f8       	cp.w	r8,-1
8000397a:	c0 61       	brne	80003986 <xQueueGenericReceive+0xf6>
8000397c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003980:	30 09       	mov	r9,0
80003982:	f1 49 00 44 	st.w	r8[68],r9
80003986:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000398a:	71 28       	ld.w	r8,r8[0x48]
8000398c:	5b f8       	cp.w	r8,-1
8000398e:	c0 61       	brne	8000399a <xQueueGenericReceive+0x10a>
80003990:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003994:	30 09       	mov	r9,0
80003996:	f1 49 00 48 	st.w	r8[72],r9
8000399a:	f0 1f 00 21 	mcall	80003a1c <xQueueGenericReceive+0x18c>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000399e:	ee c9 00 1c 	sub	r9,r7,28
800039a2:	ee c8 00 10 	sub	r8,r7,16
800039a6:	12 9b       	mov	r11,r9
800039a8:	10 9c       	mov	r12,r8
800039aa:	f0 1f 00 20 	mcall	80003a28 <xQueueGenericReceive+0x198>
800039ae:	18 98       	mov	r8,r12
800039b0:	58 08       	cp.w	r8,0
800039b2:	c2 41       	brne	800039fa <xQueueGenericReceive+0x16a>
		{
			if( prvIsQueueEmpty( pxQueue ) )
800039b4:	ee fc ff ec 	ld.w	r12,r7[-20]
800039b8:	f0 1f 00 1d 	mcall	80003a2c <xQueueGenericReceive+0x19c>
800039bc:	18 98       	mov	r8,r12
800039be:	58 08       	cp.w	r8,0
800039c0:	c1 60       	breq	800039ec <xQueueGenericReceive+0x15c>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800039c2:	ee f9 ff e4 	ld.w	r9,r7[-28]
800039c6:	ee f8 ff ec 	ld.w	r8,r7[-20]
800039ca:	2d c8       	sub	r8,-36
800039cc:	12 9b       	mov	r11,r9
800039ce:	10 9c       	mov	r12,r8
800039d0:	f0 1f 00 18 	mcall	80003a30 <xQueueGenericReceive+0x1a0>
				prvUnlockQueue( pxQueue );
800039d4:	ee fc ff ec 	ld.w	r12,r7[-20]
800039d8:	f0 1f 00 17 	mcall	80003a34 <xQueueGenericReceive+0x1a4>
				if( !xTaskResumeAll() )
800039dc:	f0 1f 00 17 	mcall	80003a38 <xQueueGenericReceive+0x1a8>
800039e0:	18 98       	mov	r8,r12
800039e2:	58 08       	cp.w	r8,0
800039e4:	fe 91 ff 66 	brne	800038b0 <xQueueGenericReceive+0x20>
				{
					portYIELD_WITHIN_API();
800039e8:	d7 33       	scall
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800039ea:	c6 4b       	rjmp	800038b2 <xQueueGenericReceive+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800039ec:	ee fc ff ec 	ld.w	r12,r7[-20]
800039f0:	f0 1f 00 11 	mcall	80003a34 <xQueueGenericReceive+0x1a4>
				( void ) xTaskResumeAll();
800039f4:	f0 1f 00 11 	mcall	80003a38 <xQueueGenericReceive+0x1a8>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800039f8:	c5 db       	rjmp	800038b2 <xQueueGenericReceive+0x22>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800039fa:	ee fc ff ec 	ld.w	r12,r7[-20]
800039fe:	f0 1f 00 0e 	mcall	80003a34 <xQueueGenericReceive+0x1a4>
			( void ) xTaskResumeAll();
80003a02:	f0 1f 00 0e 	mcall	80003a38 <xQueueGenericReceive+0x1a8>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
80003a06:	30 08       	mov	r8,0
		}
	}
}
80003a08:	10 9c       	mov	r12,r8
80003a0a:	2f 8d       	sub	sp,-32
80003a0c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003a10:	80 00       	ld.sh	r0,r0[0x0]
80003a12:	33 10       	mov	r0,49
80003a14:	80 00       	ld.sh	r0,r0[0x0]
80003a16:	3b 1c       	mov	r12,-79
80003a18:	80 00       	ld.sh	r0,r0[0x0]
80003a1a:	44 58       	lddsp	r8,sp[0x114]
80003a1c:	80 00       	ld.sh	r0,r0[0x0]
80003a1e:	33 2c       	mov	r12,50
80003a20:	80 00       	ld.sh	r0,r0[0x0]
80003a22:	45 28       	lddsp	r8,sp[0x148]
80003a24:	80 00       	ld.sh	r0,r0[0x0]
80003a26:	40 54       	lddsp	r4,sp[0x14]
80003a28:	80 00       	ld.sh	r0,r0[0x0]
80003a2a:	45 58       	lddsp	r8,sp[0x154]
80003a2c:	80 00       	ld.sh	r0,r0[0x0]
80003a2e:	3c 58       	mov	r8,-59
80003a30:	80 00       	ld.sh	r0,r0[0x0]
80003a32:	43 d8       	lddsp	r8,sp[0xf4]
80003a34:	80 00       	ld.sh	r0,r0[0x0]
80003a36:	3b 88       	mov	r8,-72
80003a38:	80 00       	ld.sh	r0,r0[0x0]
80003a3a:	40 70       	lddsp	r0,sp[0x1c]

80003a3c <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80003a3c:	eb cd 40 80 	pushm	r7,lr
80003a40:	1a 97       	mov	r7,sp
80003a42:	20 3d       	sub	sp,12
80003a44:	ef 4c ff fc 	st.w	r7[-4],r12
80003a48:	ef 4b ff f8 	st.w	r7[-8],r11
80003a4c:	ef 4a ff f4 	st.w	r7[-12],r10
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80003a50:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a54:	71 08       	ld.w	r8,r8[0x40]
80003a56:	58 08       	cp.w	r8,0
80003a58:	c5 40       	breq	80003b00 <prvCopyDataToQueue+0xc4>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80003a5a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003a5e:	58 08       	cp.w	r8,0
80003a60:	c2 61       	brne	80003aac <prvCopyDataToQueue+0x70>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80003a62:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a66:	71 09       	ld.w	r9,r8[0x40]
80003a68:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a6c:	70 28       	ld.w	r8,r8[0x8]
80003a6e:	12 9a       	mov	r10,r9
80003a70:	ee fb ff f8 	ld.w	r11,r7[-8]
80003a74:	10 9c       	mov	r12,r8
80003a76:	f0 1f 00 29 	mcall	80003b18 <prvCopyDataToQueue+0xdc>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80003a7a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a7e:	70 29       	ld.w	r9,r8[0x8]
80003a80:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a84:	71 08       	ld.w	r8,r8[0x40]
80003a86:	10 09       	add	r9,r8
80003a88:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a8c:	91 29       	st.w	r8[0x8],r9
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80003a8e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a92:	70 29       	ld.w	r9,r8[0x8]
80003a94:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a98:	70 18       	ld.w	r8,r8[0x4]
80003a9a:	10 39       	cp.w	r9,r8
80003a9c:	c3 23       	brcs	80003b00 <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80003a9e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003aa2:	70 09       	ld.w	r9,r8[0x0]
80003aa4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003aa8:	91 29       	st.w	r8[0x8],r9
80003aaa:	c2 b8       	rjmp	80003b00 <prvCopyDataToQueue+0xc4>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80003aac:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ab0:	71 09       	ld.w	r9,r8[0x40]
80003ab2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ab6:	70 38       	ld.w	r8,r8[0xc]
80003ab8:	12 9a       	mov	r10,r9
80003aba:	ee fb ff f8 	ld.w	r11,r7[-8]
80003abe:	10 9c       	mov	r12,r8
80003ac0:	f0 1f 00 16 	mcall	80003b18 <prvCopyDataToQueue+0xdc>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80003ac4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ac8:	70 39       	ld.w	r9,r8[0xc]
80003aca:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ace:	71 08       	ld.w	r8,r8[0x40]
80003ad0:	5c 38       	neg	r8
80003ad2:	10 09       	add	r9,r8
80003ad4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ad8:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80003ada:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ade:	70 39       	ld.w	r9,r8[0xc]
80003ae0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ae4:	70 08       	ld.w	r8,r8[0x0]
80003ae6:	10 39       	cp.w	r9,r8
80003ae8:	c0 c2       	brcc	80003b00 <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80003aea:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003aee:	70 19       	ld.w	r9,r8[0x4]
80003af0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003af4:	71 08       	ld.w	r8,r8[0x40]
80003af6:	5c 38       	neg	r8
80003af8:	10 09       	add	r9,r8
80003afa:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003afe:	91 39       	st.w	r8[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80003b00:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b04:	70 e8       	ld.w	r8,r8[0x38]
80003b06:	f0 c9 ff ff 	sub	r9,r8,-1
80003b0a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b0e:	91 e9       	st.w	r8[0x38],r9
}
80003b10:	2f dd       	sub	sp,-12
80003b12:	e3 cd 80 80 	ldm	sp++,r7,pc
80003b16:	00 00       	add	r0,r0
80003b18:	80 00       	ld.sh	r0,r0[0x0]
80003b1a:	4d dc       	lddpc	r12,80003c8c <prvIsQueueEmpty+0x34>

80003b1c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80003b1c:	eb cd 40 80 	pushm	r7,lr
80003b20:	1a 97       	mov	r7,sp
80003b22:	20 2d       	sub	sp,8
80003b24:	ef 4c ff fc 	st.w	r7[-4],r12
80003b28:	ef 4b ff f8 	st.w	r7[-8],r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80003b2c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b30:	70 08       	ld.w	r8,r8[0x0]
80003b32:	58 08       	cp.w	r8,0
80003b34:	c2 50       	breq	80003b7e <prvCopyDataFromQueue+0x62>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80003b36:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b3a:	70 39       	ld.w	r9,r8[0xc]
80003b3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b40:	71 08       	ld.w	r8,r8[0x40]
80003b42:	10 09       	add	r9,r8
80003b44:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b48:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80003b4a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b4e:	70 39       	ld.w	r9,r8[0xc]
80003b50:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b54:	70 18       	ld.w	r8,r8[0x4]
80003b56:	10 39       	cp.w	r9,r8
80003b58:	c0 73       	brcs	80003b66 <prvCopyDataFromQueue+0x4a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80003b5a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b5e:	70 09       	ld.w	r9,r8[0x0]
80003b60:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b64:	91 39       	st.w	r8[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80003b66:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b6a:	71 09       	ld.w	r9,r8[0x40]
80003b6c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b70:	70 38       	ld.w	r8,r8[0xc]
80003b72:	12 9a       	mov	r10,r9
80003b74:	10 9b       	mov	r11,r8
80003b76:	ee fc ff f8 	ld.w	r12,r7[-8]
80003b7a:	f0 1f 00 03 	mcall	80003b84 <prvCopyDataFromQueue+0x68>
	}
}
80003b7e:	2f ed       	sub	sp,-8
80003b80:	e3 cd 80 80 	ldm	sp++,r7,pc
80003b84:	80 00       	ld.sh	r0,r0[0x0]
80003b86:	4d dc       	lddpc	r12,80003cf8 <xTaskGenericCreate+0x24>

80003b88 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80003b88:	eb cd 40 80 	pushm	r7,lr
80003b8c:	1a 97       	mov	r7,sp
80003b8e:	20 1d       	sub	sp,4
80003b90:	ef 4c ff fc 	st.w	r7[-4],r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80003b94:	f0 1f 00 2d 	mcall	80003c48 <prvUnlockQueue+0xc0>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80003b98:	c1 a8       	rjmp	80003bcc <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80003b9a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b9e:	70 98       	ld.w	r8,r8[0x24]
80003ba0:	58 08       	cp.w	r8,0
80003ba2:	c1 c0       	breq	80003bda <prvUnlockQueue+0x52>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80003ba4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ba8:	2d c8       	sub	r8,-36
80003baa:	10 9c       	mov	r12,r8
80003bac:	f0 1f 00 28 	mcall	80003c4c <prvUnlockQueue+0xc4>
80003bb0:	18 98       	mov	r8,r12
80003bb2:	58 08       	cp.w	r8,0
80003bb4:	c0 30       	breq	80003bba <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80003bb6:	f0 1f 00 27 	mcall	80003c50 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xTxLock );
80003bba:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003bbe:	71 28       	ld.w	r8,r8[0x48]
80003bc0:	f0 c9 00 01 	sub	r9,r8,1
80003bc4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003bc8:	f1 49 00 48 	st.w	r8[72],r9
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80003bcc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003bd0:	71 28       	ld.w	r8,r8[0x48]
80003bd2:	58 08       	cp.w	r8,0
80003bd4:	fe 99 ff e3 	brgt	80003b9a <prvUnlockQueue+0x12>
80003bd8:	c0 28       	rjmp	80003bdc <prvUnlockQueue+0x54>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
80003bda:	d7 03       	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80003bdc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003be0:	3f f9       	mov	r9,-1
80003be2:	f1 49 00 48 	st.w	r8[72],r9
	}
	taskEXIT_CRITICAL();
80003be6:	f0 1f 00 1c 	mcall	80003c54 <prvUnlockQueue+0xcc>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80003bea:	f0 1f 00 18 	mcall	80003c48 <prvUnlockQueue+0xc0>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80003bee:	c1 a8       	rjmp	80003c22 <prvUnlockQueue+0x9a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80003bf0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003bf4:	70 48       	ld.w	r8,r8[0x10]
80003bf6:	58 08       	cp.w	r8,0
80003bf8:	c1 c0       	breq	80003c30 <prvUnlockQueue+0xa8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80003bfa:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003bfe:	2f 08       	sub	r8,-16
80003c00:	10 9c       	mov	r12,r8
80003c02:	f0 1f 00 13 	mcall	80003c4c <prvUnlockQueue+0xc4>
80003c06:	18 98       	mov	r8,r12
80003c08:	58 08       	cp.w	r8,0
80003c0a:	c0 30       	breq	80003c10 <prvUnlockQueue+0x88>
				{
					vTaskMissedYield();
80003c0c:	f0 1f 00 11 	mcall	80003c50 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xRxLock );
80003c10:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003c14:	71 18       	ld.w	r8,r8[0x44]
80003c16:	f0 c9 00 01 	sub	r9,r8,1
80003c1a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003c1e:	f1 49 00 44 	st.w	r8[68],r9
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80003c22:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003c26:	71 18       	ld.w	r8,r8[0x44]
80003c28:	58 08       	cp.w	r8,0
80003c2a:	fe 99 ff e3 	brgt	80003bf0 <prvUnlockQueue+0x68>
80003c2e:	c0 28       	rjmp	80003c32 <prvUnlockQueue+0xaa>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
80003c30:	d7 03       	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80003c32:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003c36:	3f f9       	mov	r9,-1
80003c38:	f1 49 00 44 	st.w	r8[68],r9
	}
	taskEXIT_CRITICAL();
80003c3c:	f0 1f 00 06 	mcall	80003c54 <prvUnlockQueue+0xcc>
}
80003c40:	2f fd       	sub	sp,-4
80003c42:	e3 cd 80 80 	ldm	sp++,r7,pc
80003c46:	00 00       	add	r0,r0
80003c48:	80 00       	ld.sh	r0,r0[0x0]
80003c4a:	33 10       	mov	r0,49
80003c4c:	80 00       	ld.sh	r0,r0[0x0]
80003c4e:	44 58       	lddsp	r8,sp[0x114]
80003c50:	80 00       	ld.sh	r0,r0[0x0]
80003c52:	46 10       	lddsp	r0,sp[0x184]
80003c54:	80 00       	ld.sh	r0,r0[0x0]
80003c56:	33 2c       	mov	r12,50

80003c58 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
80003c58:	eb cd 40 80 	pushm	r7,lr
80003c5c:	1a 97       	mov	r7,sp
80003c5e:	20 2d       	sub	sp,8
80003c60:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80003c64:	f0 1f 00 09 	mcall	80003c88 <prvIsQueueEmpty+0x30>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80003c68:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003c6c:	70 e8       	ld.w	r8,r8[0x38]
80003c6e:	58 08       	cp.w	r8,0
80003c70:	5f 08       	sreq	r8
80003c72:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80003c76:	f0 1f 00 06 	mcall	80003c8c <prvIsQueueEmpty+0x34>

	return xReturn;
80003c7a:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80003c7e:	10 9c       	mov	r12,r8
80003c80:	2f ed       	sub	sp,-8
80003c82:	e3 cd 80 80 	ldm	sp++,r7,pc
80003c86:	00 00       	add	r0,r0
80003c88:	80 00       	ld.sh	r0,r0[0x0]
80003c8a:	33 10       	mov	r0,49
80003c8c:	80 00       	ld.sh	r0,r0[0x0]
80003c8e:	33 2c       	mov	r12,50

80003c90 <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
80003c90:	eb cd 40 80 	pushm	r7,lr
80003c94:	1a 97       	mov	r7,sp
80003c96:	20 2d       	sub	sp,8
80003c98:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80003c9c:	f0 1f 00 0a 	mcall	80003cc4 <prvIsQueueFull+0x34>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80003ca0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003ca4:	70 e9       	ld.w	r9,r8[0x38]
80003ca6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003caa:	70 f8       	ld.w	r8,r8[0x3c]
80003cac:	10 39       	cp.w	r9,r8
80003cae:	5f 08       	sreq	r8
80003cb0:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80003cb4:	f0 1f 00 05 	mcall	80003cc8 <prvIsQueueFull+0x38>

	return xReturn;
80003cb8:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80003cbc:	10 9c       	mov	r12,r8
80003cbe:	2f ed       	sub	sp,-8
80003cc0:	e3 cd 80 80 	ldm	sp++,r7,pc
80003cc4:	80 00       	ld.sh	r0,r0[0x0]
80003cc6:	33 10       	mov	r0,49
80003cc8:	80 00       	ld.sh	r0,r0[0x0]
80003cca:	33 2c       	mov	r12,50
80003ccc:	49 44       	lddpc	r4,80003d1c <xTaskGenericCreate+0x48>
80003cce:	4c 45       	lddpc	r5,80003ddc <xTaskGenericCreate+0x108>
80003cd0:	00 00       	add	r0,r0
	...

80003cd4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80003cd4:	eb cd 40 c0 	pushm	r6-r7,lr
80003cd8:	1a 97       	mov	r7,sp
80003cda:	20 8d       	sub	sp,32
80003cdc:	ee c6 ff f4 	sub	r6,r7,-12
80003ce0:	ef 4c ff f0 	st.w	r7[-16],r12
80003ce4:	ef 4b ff ec 	st.w	r7[-20],r11
80003ce8:	ef 49 ff e4 	st.w	r7[-28],r9
80003cec:	ef 48 ff e0 	st.w	r7[-32],r8
80003cf0:	14 98       	mov	r8,r10
80003cf2:	ef 58 ff e8 	st.h	r7[-24],r8
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
80003cf6:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80003cfa:	6c 1b       	ld.w	r11,r6[0x4]
80003cfc:	10 9c       	mov	r12,r8
80003cfe:	f0 1f 00 5a 	mcall	80003e64 <xTaskGenericCreate+0x190>
80003d02:	18 98       	mov	r8,r12
80003d04:	ef 48 ff f8 	st.w	r7[-8],r8

	if( pxNewTCB != NULL )
80003d08:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d0c:	58 08       	cp.w	r8,0
80003d0e:	e0 80 00 92 	breq	80003e32 <xTaskGenericCreate+0x15e>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
80003d12:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d16:	70 c9       	ld.w	r9,r8[0x30]
80003d18:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80003d1c:	20 18       	sub	r8,1
80003d1e:	a3 68       	lsl	r8,0x2
80003d20:	f2 08 00 08 	add	r8,r9,r8
80003d24:	ef 48 ff fc 	st.w	r7[-4],r8
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80003d28:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d2c:	e0 18 ff fc 	andl	r8,0xfffc
80003d30:	ef 48 ff fc 	st.w	r7[-4],r8
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
80003d34:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80003d38:	6c 29       	ld.w	r9,r6[0x8]
80003d3a:	ee fa ff e0 	ld.w	r10,r7[-32]
80003d3e:	ee fb ff ec 	ld.w	r11,r7[-20]
80003d42:	ee fc ff f8 	ld.w	r12,r7[-8]
80003d46:	f0 1f 00 49 	mcall	80003e68 <xTaskGenericCreate+0x194>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80003d4a:	ee fa ff e4 	ld.w	r10,r7[-28]
80003d4e:	ee fb ff f0 	ld.w	r11,r7[-16]
80003d52:	ee fc ff fc 	ld.w	r12,r7[-4]
80003d56:	f0 1f 00 46 	mcall	80003e6c <xTaskGenericCreate+0x198>
80003d5a:	18 98       	mov	r8,r12
80003d5c:	10 99       	mov	r9,r8
80003d5e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d62:	91 09       	st.w	r8[0x0],r9
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
80003d64:	6c 08       	ld.w	r8,r6[0x0]
80003d66:	58 08       	cp.w	r8,0
80003d68:	c0 50       	breq	80003d72 <xTaskGenericCreate+0x9e>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80003d6a:	6c 08       	ld.w	r8,r6[0x0]
80003d6c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003d70:	91 09       	st.w	r8[0x0],r9
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80003d72:	f0 1f 00 40 	mcall	80003e70 <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
80003d76:	4c 08       	lddpc	r8,80003e74 <xTaskGenericCreate+0x1a0>
80003d78:	70 08       	ld.w	r8,r8[0x0]
80003d7a:	f0 c9 ff ff 	sub	r9,r8,-1
80003d7e:	4b e8       	lddpc	r8,80003e74 <xTaskGenericCreate+0x1a0>
80003d80:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80003d82:	4b e8       	lddpc	r8,80003e78 <xTaskGenericCreate+0x1a4>
80003d84:	70 08       	ld.w	r8,r8[0x0]
80003d86:	58 08       	cp.w	r8,0
80003d88:	c0 c1       	brne	80003da0 <xTaskGenericCreate+0xcc>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80003d8a:	4b c8       	lddpc	r8,80003e78 <xTaskGenericCreate+0x1a4>
80003d8c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003d90:	91 09       	st.w	r8[0x0],r9

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80003d92:	4b 98       	lddpc	r8,80003e74 <xTaskGenericCreate+0x1a0>
80003d94:	70 08       	ld.w	r8,r8[0x0]
80003d96:	58 18       	cp.w	r8,1
80003d98:	c1 41       	brne	80003dc0 <xTaskGenericCreate+0xec>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
80003d9a:	f0 1f 00 39 	mcall	80003e7c <xTaskGenericCreate+0x1a8>
80003d9e:	c1 18       	rjmp	80003dc0 <xTaskGenericCreate+0xec>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80003da0:	4b 88       	lddpc	r8,80003e80 <xTaskGenericCreate+0x1ac>
80003da2:	70 08       	ld.w	r8,r8[0x0]
80003da4:	58 08       	cp.w	r8,0
80003da6:	c0 d1       	brne	80003dc0 <xTaskGenericCreate+0xec>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80003da8:	4b 48       	lddpc	r8,80003e78 <xTaskGenericCreate+0x1a4>
80003daa:	70 08       	ld.w	r8,r8[0x0]
80003dac:	70 b9       	ld.w	r9,r8[0x2c]
80003dae:	ee f8 ff e0 	ld.w	r8,r7[-32]
80003db2:	10 39       	cp.w	r9,r8
80003db4:	e0 8b 00 06 	brhi	80003dc0 <xTaskGenericCreate+0xec>
					{
						pxCurrentTCB = pxNewTCB;
80003db8:	4b 08       	lddpc	r8,80003e78 <xTaskGenericCreate+0x1a4>
80003dba:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003dbe:	91 09       	st.w	r8[0x0],r9
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80003dc0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003dc4:	70 b9       	ld.w	r9,r8[0x2c]
80003dc6:	4b 08       	lddpc	r8,80003e84 <xTaskGenericCreate+0x1b0>
80003dc8:	70 08       	ld.w	r8,r8[0x0]
80003dca:	10 39       	cp.w	r9,r8
80003dcc:	e0 88 00 07 	brls	80003dda <xTaskGenericCreate+0x106>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80003dd0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003dd4:	70 b9       	ld.w	r9,r8[0x2c]
80003dd6:	4a c8       	lddpc	r8,80003e84 <xTaskGenericCreate+0x1b0>
80003dd8:	91 09       	st.w	r8[0x0],r9
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80003dda:	4a c8       	lddpc	r8,80003e88 <xTaskGenericCreate+0x1b4>
80003ddc:	70 08       	ld.w	r8,r8[0x0]
80003dde:	f0 c9 ff ff 	sub	r9,r8,-1
80003de2:	4a a8       	lddpc	r8,80003e88 <xTaskGenericCreate+0x1b4>
80003de4:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80003de6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003dea:	70 b9       	ld.w	r9,r8[0x2c]
80003dec:	4a 88       	lddpc	r8,80003e8c <xTaskGenericCreate+0x1b8>
80003dee:	70 08       	ld.w	r8,r8[0x0]
80003df0:	10 39       	cp.w	r9,r8
80003df2:	e0 88 00 07 	brls	80003e00 <xTaskGenericCreate+0x12c>
80003df6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003dfa:	70 b9       	ld.w	r9,r8[0x2c]
80003dfc:	4a 48       	lddpc	r8,80003e8c <xTaskGenericCreate+0x1b8>
80003dfe:	91 09       	st.w	r8[0x0],r9
80003e00:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e04:	f0 ca ff fc 	sub	r10,r8,-4
80003e08:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e0c:	70 b9       	ld.w	r9,r8[0x2c]
80003e0e:	12 98       	mov	r8,r9
80003e10:	a3 68       	lsl	r8,0x2
80003e12:	12 08       	add	r8,r9
80003e14:	a3 68       	lsl	r8,0x2
80003e16:	10 99       	mov	r9,r8
80003e18:	49 e8       	lddpc	r8,80003e90 <xTaskGenericCreate+0x1bc>
80003e1a:	f2 08 00 08 	add	r8,r9,r8
80003e1e:	14 9b       	mov	r11,r10
80003e20:	10 9c       	mov	r12,r8
80003e22:	f0 1f 00 1d 	mcall	80003e94 <xTaskGenericCreate+0x1c0>

			xReturn = pdPASS;
80003e26:	30 18       	mov	r8,1
80003e28:	ef 48 ff f4 	st.w	r7[-12],r8
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80003e2c:	f0 1f 00 1b 	mcall	80003e98 <xTaskGenericCreate+0x1c4>
80003e30:	c0 48       	rjmp	80003e38 <xTaskGenericCreate+0x164>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
80003e32:	3f f8       	mov	r8,-1
80003e34:	ef 48 ff f4 	st.w	r7[-12],r8
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
80003e38:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003e3c:	58 18       	cp.w	r8,1
80003e3e:	c0 d1       	brne	80003e58 <xTaskGenericCreate+0x184>
	{
		if( xSchedulerRunning != pdFALSE )
80003e40:	49 08       	lddpc	r8,80003e80 <xTaskGenericCreate+0x1ac>
80003e42:	70 08       	ld.w	r8,r8[0x0]
80003e44:	58 08       	cp.w	r8,0
80003e46:	c0 90       	breq	80003e58 <xTaskGenericCreate+0x184>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80003e48:	48 c8       	lddpc	r8,80003e78 <xTaskGenericCreate+0x1a4>
80003e4a:	70 08       	ld.w	r8,r8[0x0]
80003e4c:	70 b9       	ld.w	r9,r8[0x2c]
80003e4e:	ee f8 ff e0 	ld.w	r8,r7[-32]
80003e52:	10 39       	cp.w	r9,r8
80003e54:	c0 22       	brcc	80003e58 <xTaskGenericCreate+0x184>
			{
				portYIELD_WITHIN_API();
80003e56:	d7 33       	scall
			}
		}
	}

	return xReturn;
80003e58:	ee f8 ff f4 	ld.w	r8,r7[-12]
}
80003e5c:	10 9c       	mov	r12,r8
80003e5e:	2f 8d       	sub	sp,-32
80003e60:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003e64:	80 00       	ld.sh	r0,r0[0x0]
80003e66:	48 98       	lddpc	r8,80003e88 <xTaskGenericCreate+0x1b4>
80003e68:	80 00       	ld.sh	r0,r0[0x0]
80003e6a:	46 50       	lddsp	r0,sp[0x194]
80003e6c:	80 00       	ld.sh	r0,r0[0x0]
80003e6e:	33 58       	mov	r8,53
80003e70:	80 00       	ld.sh	r0,r0[0x0]
80003e72:	33 10       	mov	r0,49
80003e74:	00 00       	add	r0,r0
80003e76:	07 30       	ld.ub	r0,r3++
80003e78:	00 00       	add	r0,r0
80003e7a:	06 1c       	sub	r12,r3
80003e7c:	80 00       	ld.sh	r0,r0[0x0]
80003e7e:	46 ec       	lddsp	r12,sp[0x1b8]
80003e80:	00 00       	add	r0,r0
80003e82:	07 40       	ld.w	r0,--r3
80003e84:	00 00       	add	r0,r0
80003e86:	07 38       	ld.ub	r8,r3++
80003e88:	00 00       	add	r0,r0
80003e8a:	07 54       	ld.sh	r4,--r3
80003e8c:	00 00       	add	r0,r0
80003e8e:	07 3c       	ld.ub	r12,r3++
80003e90:	00 00       	add	r0,r0
80003e92:	06 20       	rsub	r0,r3
80003e94:	80 00       	ld.sh	r0,r0[0x0]
80003e96:	2f e6       	sub	r6,-2
80003e98:	80 00       	ld.sh	r0,r0[0x0]
80003e9a:	33 2c       	mov	r12,50

80003e9c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80003e9c:	eb cd 40 80 	pushm	r7,lr
80003ea0:	1a 97       	mov	r7,sp
80003ea2:	20 5d       	sub	sp,20
80003ea4:	ef 4c ff f0 	st.w	r7[-16],r12
80003ea8:	ef 4b ff ec 	st.w	r7[-20],r11
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
80003eac:	30 08       	mov	r8,0
80003eae:	ef 48 ff fc 	st.w	r7[-4],r8

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80003eb2:	f0 1f 00 2d 	mcall	80003f64 <vTaskDelayUntil+0xc8>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80003eb6:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003eba:	70 09       	ld.w	r9,r8[0x0]
80003ebc:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003ec0:	f2 08 00 08 	add	r8,r9,r8
80003ec4:	ef 48 ff f4 	st.w	r7[-12],r8

			if( xTickCount < *pxPreviousWakeTime )
80003ec8:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003ecc:	70 09       	ld.w	r9,r8[0x0]
80003ece:	4a 78       	lddpc	r8,80003f68 <vTaskDelayUntil+0xcc>
80003ed0:	70 08       	ld.w	r8,r8[0x0]
80003ed2:	10 39       	cp.w	r9,r8
80003ed4:	e0 88 00 15 	brls	80003efe <vTaskDelayUntil+0x62>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80003ed8:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003edc:	70 09       	ld.w	r9,r8[0x0]
80003ede:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003ee2:	10 39       	cp.w	r9,r8
80003ee4:	e0 88 00 1f 	brls	80003f22 <vTaskDelayUntil+0x86>
80003ee8:	4a 08       	lddpc	r8,80003f68 <vTaskDelayUntil+0xcc>
80003eea:	70 08       	ld.w	r8,r8[0x0]
80003eec:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003ef0:	10 39       	cp.w	r9,r8
80003ef2:	e0 88 00 18 	brls	80003f22 <vTaskDelayUntil+0x86>
				{
					xShouldDelay = pdTRUE;
80003ef6:	30 18       	mov	r8,1
80003ef8:	ef 48 ff fc 	st.w	r7[-4],r8
80003efc:	c1 38       	rjmp	80003f22 <vTaskDelayUntil+0x86>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80003efe:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003f02:	70 09       	ld.w	r9,r8[0x0]
80003f04:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003f08:	10 39       	cp.w	r9,r8
80003f0a:	e0 8b 00 09 	brhi	80003f1c <vTaskDelayUntil+0x80>
80003f0e:	49 78       	lddpc	r8,80003f68 <vTaskDelayUntil+0xcc>
80003f10:	70 08       	ld.w	r8,r8[0x0]
80003f12:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003f16:	10 39       	cp.w	r9,r8
80003f18:	e0 88 00 05 	brls	80003f22 <vTaskDelayUntil+0x86>
				{
					xShouldDelay = pdTRUE;
80003f1c:	30 18       	mov	r8,1
80003f1e:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80003f22:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003f26:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003f2a:	91 09       	st.w	r8[0x0],r9

			if( xShouldDelay != pdFALSE )
80003f2c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f30:	58 08       	cp.w	r8,0
80003f32:	c0 b0       	breq	80003f48 <vTaskDelayUntil+0xac>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80003f34:	48 e8       	lddpc	r8,80003f6c <vTaskDelayUntil+0xd0>
80003f36:	70 08       	ld.w	r8,r8[0x0]
80003f38:	2f c8       	sub	r8,-4
80003f3a:	10 9c       	mov	r12,r8
80003f3c:	f0 1f 00 0d 	mcall	80003f70 <vTaskDelayUntil+0xd4>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80003f40:	ee fc ff f4 	ld.w	r12,r7[-12]
80003f44:	f0 1f 00 0c 	mcall	80003f74 <vTaskDelayUntil+0xd8>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80003f48:	f0 1f 00 0c 	mcall	80003f78 <vTaskDelayUntil+0xdc>
80003f4c:	18 98       	mov	r8,r12
80003f4e:	ef 48 ff f8 	st.w	r7[-8],r8

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80003f52:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f56:	58 08       	cp.w	r8,0
80003f58:	c0 21       	brne	80003f5c <vTaskDelayUntil+0xc0>
		{
			portYIELD_WITHIN_API();
80003f5a:	d7 33       	scall
		}
	}
80003f5c:	2f bd       	sub	sp,-20
80003f5e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f62:	00 00       	add	r0,r0
80003f64:	80 00       	ld.sh	r0,r0[0x0]
80003f66:	40 54       	lddsp	r4,sp[0x14]
80003f68:	00 00       	add	r0,r0
80003f6a:	07 34       	ld.ub	r4,r3++
80003f6c:	00 00       	add	r0,r0
80003f6e:	06 1c       	sub	r12,r3
80003f70:	80 00       	ld.sh	r0,r0[0x0]
80003f72:	30 fa       	mov	r10,15
80003f74:	80 00       	ld.sh	r0,r0[0x0]
80003f76:	48 18       	lddpc	r8,80003f78 <vTaskDelayUntil+0xdc>
80003f78:	80 00       	ld.sh	r0,r0[0x0]
80003f7a:	40 70       	lddsp	r0,sp[0x1c]

80003f7c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80003f7c:	eb cd 40 80 	pushm	r7,lr
80003f80:	1a 97       	mov	r7,sp
80003f82:	20 3d       	sub	sp,12
80003f84:	ef 4c ff f4 	st.w	r7[-12],r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
80003f88:	30 08       	mov	r8,0
80003f8a:	ef 48 ff fc 	st.w	r7[-4],r8

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80003f8e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003f92:	58 08       	cp.w	r8,0
80003f94:	c1 a0       	breq	80003fc8 <vTaskDelay+0x4c>
		{
			vTaskSuspendAll();
80003f96:	f0 1f 00 11 	mcall	80003fd8 <vTaskDelay+0x5c>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80003f9a:	49 18       	lddpc	r8,80003fdc <vTaskDelay+0x60>
80003f9c:	70 09       	ld.w	r9,r8[0x0]
80003f9e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003fa2:	f2 08 00 08 	add	r8,r9,r8
80003fa6:	ef 48 ff f8 	st.w	r7[-8],r8

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80003faa:	48 e8       	lddpc	r8,80003fe0 <vTaskDelay+0x64>
80003fac:	70 08       	ld.w	r8,r8[0x0]
80003fae:	2f c8       	sub	r8,-4
80003fb0:	10 9c       	mov	r12,r8
80003fb2:	f0 1f 00 0d 	mcall	80003fe4 <vTaskDelay+0x68>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80003fb6:	ee fc ff f8 	ld.w	r12,r7[-8]
80003fba:	f0 1f 00 0c 	mcall	80003fe8 <vTaskDelay+0x6c>
			}
			xAlreadyYielded = xTaskResumeAll();
80003fbe:	f0 1f 00 0c 	mcall	80003fec <vTaskDelay+0x70>
80003fc2:	18 98       	mov	r8,r12
80003fc4:	ef 48 ff fc 	st.w	r7[-4],r8
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80003fc8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003fcc:	58 08       	cp.w	r8,0
80003fce:	c0 21       	brne	80003fd2 <vTaskDelay+0x56>
		{
			portYIELD_WITHIN_API();
80003fd0:	d7 33       	scall
		}
	}
80003fd2:	2f dd       	sub	sp,-12
80003fd4:	e3 cd 80 80 	ldm	sp++,r7,pc
80003fd8:	80 00       	ld.sh	r0,r0[0x0]
80003fda:	40 54       	lddsp	r4,sp[0x14]
80003fdc:	00 00       	add	r0,r0
80003fde:	07 34       	ld.ub	r4,r3++
80003fe0:	00 00       	add	r0,r0
80003fe2:	06 1c       	sub	r12,r3
80003fe4:	80 00       	ld.sh	r0,r0[0x0]
80003fe6:	30 fa       	mov	r10,15
80003fe8:	80 00       	ld.sh	r0,r0[0x0]
80003fea:	48 18       	lddpc	r8,80003fec <vTaskDelay+0x70>
80003fec:	80 00       	ld.sh	r0,r0[0x0]
80003fee:	40 70       	lddsp	r0,sp[0x1c]

80003ff0 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80003ff0:	eb cd 40 80 	pushm	r7,lr
80003ff4:	1a 97       	mov	r7,sp
80003ff6:	20 1d       	sub	sp,4
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80003ff8:	49 1b       	lddpc	r11,8000403c <vTaskStartScheduler+0x4c>
80003ffa:	30 08       	mov	r8,0
80003ffc:	1a d8       	st.w	--sp,r8
80003ffe:	30 08       	mov	r8,0
80004000:	1a d8       	st.w	--sp,r8
80004002:	30 08       	mov	r8,0
80004004:	1a d8       	st.w	--sp,r8
80004006:	30 08       	mov	r8,0
80004008:	30 09       	mov	r9,0
8000400a:	e0 6a 01 00 	mov	r10,256
8000400e:	48 dc       	lddpc	r12,80004040 <vTaskStartScheduler+0x50>
80004010:	f0 1f 00 0d 	mcall	80004044 <vTaskStartScheduler+0x54>
80004014:	2f dd       	sub	sp,-12
80004016:	18 98       	mov	r8,r12
80004018:	ef 48 ff fc 	st.w	r7[-4],r8
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
8000401c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004020:	58 18       	cp.w	r8,1
80004022:	c0 a1       	brne	80004036 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80004024:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80004026:	48 98       	lddpc	r8,80004048 <vTaskStartScheduler+0x58>
80004028:	30 19       	mov	r9,1
8000402a:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
8000402c:	48 88       	lddpc	r8,8000404c <vTaskStartScheduler+0x5c>
8000402e:	30 09       	mov	r9,0
80004030:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80004032:	f0 1f 00 08 	mcall	80004050 <vTaskStartScheduler+0x60>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
80004036:	2f fd       	sub	sp,-4
80004038:	e3 cd 80 80 	ldm	sp++,r7,pc
8000403c:	80 00       	ld.sh	r0,r0[0x0]
8000403e:	3c cc       	mov	r12,-52
80004040:	80 00       	ld.sh	r0,r0[0x0]
80004042:	46 24       	lddsp	r4,sp[0x188]
80004044:	80 00       	ld.sh	r0,r0[0x0]
80004046:	3c d4       	mov	r4,-51
80004048:	00 00       	add	r0,r0
8000404a:	07 40       	ld.w	r0,--r3
8000404c:	00 00       	add	r0,r0
8000404e:	07 34       	ld.ub	r4,r3++
80004050:	80 00       	ld.sh	r0,r0[0x0]
80004052:	35 00       	mov	r0,80

80004054 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
80004054:	eb cd 40 80 	pushm	r7,lr
80004058:	1a 97       	mov	r7,sp
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
8000405a:	48 58       	lddpc	r8,8000406c <vTaskSuspendAll+0x18>
8000405c:	70 08       	ld.w	r8,r8[0x0]
8000405e:	f0 c9 ff ff 	sub	r9,r8,-1
80004062:	48 38       	lddpc	r8,8000406c <vTaskSuspendAll+0x18>
80004064:	91 09       	st.w	r8[0x0],r9
}
80004066:	e3 cd 80 80 	ldm	sp++,r7,pc
8000406a:	00 00       	add	r0,r0
8000406c:	00 00       	add	r0,r0
8000406e:	07 44       	ld.w	r4,--r3

80004070 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80004070:	eb cd 40 c0 	pushm	r6-r7,lr
80004074:	1a 97       	mov	r7,sp
80004076:	20 2d       	sub	sp,8
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
80004078:	30 08       	mov	r8,0
8000407a:	ef 48 ff f8 	st.w	r7[-8],r8
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
8000407e:	f0 1f 00 3a 	mcall	80004164 <xTaskResumeAll+0xf4>
	{
		--uxSchedulerSuspended;
80004082:	4b a8       	lddpc	r8,80004168 <xTaskResumeAll+0xf8>
80004084:	70 08       	ld.w	r8,r8[0x0]
80004086:	f0 c9 00 01 	sub	r9,r8,1
8000408a:	4b 88       	lddpc	r8,80004168 <xTaskResumeAll+0xf8>
8000408c:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000408e:	4b 78       	lddpc	r8,80004168 <xTaskResumeAll+0xf8>
80004090:	70 08       	ld.w	r8,r8[0x0]
80004092:	58 08       	cp.w	r8,0
80004094:	c5 f1       	brne	80004152 <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80004096:	4b 68       	lddpc	r8,8000416c <xTaskResumeAll+0xfc>
80004098:	70 08       	ld.w	r8,r8[0x0]
8000409a:	58 08       	cp.w	r8,0
8000409c:	c5 b0       	breq	80004152 <xTaskResumeAll+0xe2>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
8000409e:	30 08       	mov	r8,0
800040a0:	ef 48 ff fc 	st.w	r7[-4],r8

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800040a4:	c3 08       	rjmp	80004104 <xTaskResumeAll+0x94>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800040a6:	4b 38       	lddpc	r8,80004170 <xTaskResumeAll+0x100>
800040a8:	70 38       	ld.w	r8,r8[0xc]
800040aa:	70 38       	ld.w	r8,r8[0xc]
800040ac:	10 96       	mov	r6,r8
					vListRemove( &( pxTCB->xEventListItem ) );
800040ae:	ec c8 ff e8 	sub	r8,r6,-24
800040b2:	10 9c       	mov	r12,r8
800040b4:	f0 1f 00 30 	mcall	80004174 <xTaskResumeAll+0x104>
					vListRemove( &( pxTCB->xGenericListItem ) );
800040b8:	ec c8 ff fc 	sub	r8,r6,-4
800040bc:	10 9c       	mov	r12,r8
800040be:	f0 1f 00 2e 	mcall	80004174 <xTaskResumeAll+0x104>
					prvAddTaskToReadyQueue( pxTCB );
800040c2:	6c b9       	ld.w	r9,r6[0x2c]
800040c4:	4a d8       	lddpc	r8,80004178 <xTaskResumeAll+0x108>
800040c6:	70 08       	ld.w	r8,r8[0x0]
800040c8:	10 39       	cp.w	r9,r8
800040ca:	e0 88 00 05 	brls	800040d4 <xTaskResumeAll+0x64>
800040ce:	6c b9       	ld.w	r9,r6[0x2c]
800040d0:	4a a8       	lddpc	r8,80004178 <xTaskResumeAll+0x108>
800040d2:	91 09       	st.w	r8[0x0],r9
800040d4:	ec ca ff fc 	sub	r10,r6,-4
800040d8:	6c b9       	ld.w	r9,r6[0x2c]
800040da:	12 98       	mov	r8,r9
800040dc:	a3 68       	lsl	r8,0x2
800040de:	12 08       	add	r8,r9
800040e0:	a3 68       	lsl	r8,0x2
800040e2:	10 99       	mov	r9,r8
800040e4:	4a 68       	lddpc	r8,8000417c <xTaskResumeAll+0x10c>
800040e6:	f2 08 00 08 	add	r8,r9,r8
800040ea:	14 9b       	mov	r11,r10
800040ec:	10 9c       	mov	r12,r8
800040ee:	f0 1f 00 25 	mcall	80004180 <xTaskResumeAll+0x110>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800040f2:	6c b9       	ld.w	r9,r6[0x2c]
800040f4:	4a 48       	lddpc	r8,80004184 <xTaskResumeAll+0x114>
800040f6:	70 08       	ld.w	r8,r8[0x0]
800040f8:	70 b8       	ld.w	r8,r8[0x2c]
800040fa:	10 39       	cp.w	r9,r8
800040fc:	c0 43       	brcs	80004104 <xTaskResumeAll+0x94>
					{
						xYieldRequired = pdTRUE;
800040fe:	30 18       	mov	r8,1
80004100:	ef 48 ff fc 	st.w	r7[-4],r8
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80004104:	49 b8       	lddpc	r8,80004170 <xTaskResumeAll+0x100>
80004106:	70 08       	ld.w	r8,r8[0x0]
80004108:	58 08       	cp.w	r8,0
8000410a:	cc e1       	brne	800040a6 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000410c:	49 f8       	lddpc	r8,80004188 <xTaskResumeAll+0x118>
8000410e:	70 08       	ld.w	r8,r8[0x0]
80004110:	58 08       	cp.w	r8,0
80004112:	c1 10       	breq	80004134 <xTaskResumeAll+0xc4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80004114:	c0 98       	rjmp	80004126 <xTaskResumeAll+0xb6>
					{
						vTaskIncrementTick();
80004116:	f0 1f 00 1e 	mcall	8000418c <xTaskResumeAll+0x11c>
						--uxMissedTicks;
8000411a:	49 c8       	lddpc	r8,80004188 <xTaskResumeAll+0x118>
8000411c:	70 08       	ld.w	r8,r8[0x0]
8000411e:	f0 c9 00 01 	sub	r9,r8,1
80004122:	49 a8       	lddpc	r8,80004188 <xTaskResumeAll+0x118>
80004124:	91 09       	st.w	r8[0x0],r9
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80004126:	49 98       	lddpc	r8,80004188 <xTaskResumeAll+0x118>
80004128:	70 08       	ld.w	r8,r8[0x0]
8000412a:	58 08       	cp.w	r8,0
8000412c:	cf 51       	brne	80004116 <xTaskResumeAll+0xa6>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
8000412e:	30 18       	mov	r8,1
80004130:	ef 48 ff fc 	st.w	r7[-4],r8
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80004134:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004138:	58 18       	cp.w	r8,1
8000413a:	c0 50       	breq	80004144 <xTaskResumeAll+0xd4>
8000413c:	49 58       	lddpc	r8,80004190 <xTaskResumeAll+0x120>
8000413e:	70 08       	ld.w	r8,r8[0x0]
80004140:	58 18       	cp.w	r8,1
80004142:	c0 81       	brne	80004152 <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
80004144:	30 18       	mov	r8,1
80004146:	ef 48 ff f8 	st.w	r7[-8],r8
					xMissedYield = pdFALSE;
8000414a:	49 28       	lddpc	r8,80004190 <xTaskResumeAll+0x120>
8000414c:	30 09       	mov	r9,0
8000414e:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80004150:	d7 33       	scall
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80004152:	f0 1f 00 11 	mcall	80004194 <xTaskResumeAll+0x124>

	return xAlreadyYielded;
80004156:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
8000415a:	10 9c       	mov	r12,r8
8000415c:	2f ed       	sub	sp,-8
8000415e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004162:	00 00       	add	r0,r0
80004164:	80 00       	ld.sh	r0,r0[0x0]
80004166:	33 10       	mov	r0,49
80004168:	00 00       	add	r0,r0
8000416a:	07 44       	ld.w	r4,--r3
8000416c:	00 00       	add	r0,r0
8000416e:	07 30       	ld.ub	r0,r3++
80004170:	00 00       	add	r0,r0
80004172:	06 f0       	st.b	--r3,r0
80004174:	80 00       	ld.sh	r0,r0[0x0]
80004176:	30 fa       	mov	r10,15
80004178:	00 00       	add	r0,r0
8000417a:	07 3c       	ld.ub	r12,r3++
8000417c:	00 00       	add	r0,r0
8000417e:	06 20       	rsub	r0,r3
80004180:	80 00       	ld.sh	r0,r0[0x0]
80004182:	2f e6       	sub	r6,-2
80004184:	00 00       	add	r0,r0
80004186:	06 1c       	sub	r12,r3
80004188:	00 00       	add	r0,r0
8000418a:	07 48       	ld.w	r8,--r3
8000418c:	80 00       	ld.sh	r0,r0[0x0]
8000418e:	41 c8       	lddsp	r8,sp[0x70]
80004190:	00 00       	add	r0,r0
80004192:	07 4c       	ld.w	r12,--r3
80004194:	80 00       	ld.sh	r0,r0[0x0]
80004196:	33 2c       	mov	r12,50

80004198 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80004198:	eb cd 40 80 	pushm	r7,lr
8000419c:	1a 97       	mov	r7,sp
8000419e:	20 1d       	sub	sp,4
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800041a0:	f0 1f 00 07 	mcall	800041bc <xTaskGetTickCount+0x24>
	{
		xTicks = xTickCount;
800041a4:	48 78       	lddpc	r8,800041c0 <xTaskGetTickCount+0x28>
800041a6:	70 08       	ld.w	r8,r8[0x0]
800041a8:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	taskEXIT_CRITICAL();
800041ac:	f0 1f 00 06 	mcall	800041c4 <xTaskGetTickCount+0x2c>

	return xTicks;
800041b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800041b4:	10 9c       	mov	r12,r8
800041b6:	2f fd       	sub	sp,-4
800041b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800041bc:	80 00       	ld.sh	r0,r0[0x0]
800041be:	33 10       	mov	r0,49
800041c0:	00 00       	add	r0,r0
800041c2:	07 34       	ld.ub	r4,r3++
800041c4:	80 00       	ld.sh	r0,r0[0x0]
800041c6:	33 2c       	mov	r12,50

800041c8 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800041c8:	eb cd 40 80 	pushm	r7,lr
800041cc:	1a 97       	mov	r7,sp
800041ce:	20 3d       	sub	sp,12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800041d0:	4c b8       	lddpc	r8,800042fc <vTaskIncrementTick+0x134>
800041d2:	70 08       	ld.w	r8,r8[0x0]
800041d4:	58 08       	cp.w	r8,0
800041d6:	e0 81 00 89 	brne	800042e8 <vTaskIncrementTick+0x120>
	{
		++xTickCount;
800041da:	4c a8       	lddpc	r8,80004300 <vTaskIncrementTick+0x138>
800041dc:	70 08       	ld.w	r8,r8[0x0]
800041de:	f0 c9 ff ff 	sub	r9,r8,-1
800041e2:	4c 88       	lddpc	r8,80004300 <vTaskIncrementTick+0x138>
800041e4:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800041e6:	4c 78       	lddpc	r8,80004300 <vTaskIncrementTick+0x138>
800041e8:	70 08       	ld.w	r8,r8[0x0]
800041ea:	58 08       	cp.w	r8,0
800041ec:	c2 71       	brne	8000423a <vTaskIncrementTick+0x72>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800041ee:	4c 68       	lddpc	r8,80004304 <vTaskIncrementTick+0x13c>
800041f0:	70 08       	ld.w	r8,r8[0x0]
800041f2:	ef 48 ff f8 	st.w	r7[-8],r8
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800041f6:	4c 58       	lddpc	r8,80004308 <vTaskIncrementTick+0x140>
800041f8:	70 09       	ld.w	r9,r8[0x0]
800041fa:	4c 38       	lddpc	r8,80004304 <vTaskIncrementTick+0x13c>
800041fc:	91 09       	st.w	r8[0x0],r9
			pxOverflowDelayedTaskList = pxTemp;
800041fe:	4c 38       	lddpc	r8,80004308 <vTaskIncrementTick+0x140>
80004200:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004204:	91 09       	st.w	r8[0x0],r9
			xNumOfOverflows++;
80004206:	4c 28       	lddpc	r8,8000430c <vTaskIncrementTick+0x144>
80004208:	70 08       	ld.w	r8,r8[0x0]
8000420a:	f0 c9 ff ff 	sub	r9,r8,-1
8000420e:	4c 08       	lddpc	r8,8000430c <vTaskIncrementTick+0x144>
80004210:	91 09       	st.w	r8[0x0],r9

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80004212:	4b d8       	lddpc	r8,80004304 <vTaskIncrementTick+0x13c>
80004214:	70 08       	ld.w	r8,r8[0x0]
80004216:	70 08       	ld.w	r8,r8[0x0]
80004218:	58 08       	cp.w	r8,0
8000421a:	c0 51       	brne	80004224 <vTaskIncrementTick+0x5c>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000421c:	4b d8       	lddpc	r8,80004310 <vTaskIncrementTick+0x148>
8000421e:	3f f9       	mov	r9,-1
80004220:	91 09       	st.w	r8[0x0],r9
80004222:	c0 c8       	rjmp	8000423a <vTaskIncrementTick+0x72>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80004224:	4b 88       	lddpc	r8,80004304 <vTaskIncrementTick+0x13c>
80004226:	70 08       	ld.w	r8,r8[0x0]
80004228:	70 38       	ld.w	r8,r8[0xc]
8000422a:	70 38       	ld.w	r8,r8[0xc]
8000422c:	ef 48 ff f4 	st.w	r7[-12],r8
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80004230:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004234:	70 19       	ld.w	r9,r8[0x4]
80004236:	4b 78       	lddpc	r8,80004310 <vTaskIncrementTick+0x148>
80004238:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
8000423a:	4b 28       	lddpc	r8,80004300 <vTaskIncrementTick+0x138>
8000423c:	70 09       	ld.w	r9,r8[0x0]
8000423e:	4b 58       	lddpc	r8,80004310 <vTaskIncrementTick+0x148>
80004240:	70 08       	ld.w	r8,r8[0x0]
80004242:	10 39       	cp.w	r9,r8
80004244:	c5 83       	brcs	800042f4 <vTaskIncrementTick+0x12c>
80004246:	4b 08       	lddpc	r8,80004304 <vTaskIncrementTick+0x13c>
80004248:	70 08       	ld.w	r8,r8[0x0]
8000424a:	70 08       	ld.w	r8,r8[0x0]
8000424c:	58 08       	cp.w	r8,0
8000424e:	c0 51       	brne	80004258 <vTaskIncrementTick+0x90>
80004250:	4b 08       	lddpc	r8,80004310 <vTaskIncrementTick+0x148>
80004252:	3f f9       	mov	r9,-1
80004254:	91 09       	st.w	r8[0x0],r9
80004256:	c4 f8       	rjmp	800042f4 <vTaskIncrementTick+0x12c>
80004258:	4a b8       	lddpc	r8,80004304 <vTaskIncrementTick+0x13c>
8000425a:	70 08       	ld.w	r8,r8[0x0]
8000425c:	70 38       	ld.w	r8,r8[0xc]
8000425e:	70 38       	ld.w	r8,r8[0xc]
80004260:	ef 48 ff f4 	st.w	r7[-12],r8
80004264:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004268:	70 18       	ld.w	r8,r8[0x4]
8000426a:	ef 48 ff fc 	st.w	r7[-4],r8
8000426e:	4a 58       	lddpc	r8,80004300 <vTaskIncrementTick+0x138>
80004270:	70 09       	ld.w	r9,r8[0x0]
80004272:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004276:	10 39       	cp.w	r9,r8
80004278:	c0 62       	brcc	80004284 <vTaskIncrementTick+0xbc>
8000427a:	4a 68       	lddpc	r8,80004310 <vTaskIncrementTick+0x148>
8000427c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004280:	91 09       	st.w	r8[0x0],r9
80004282:	c3 98       	rjmp	800042f4 <vTaskIncrementTick+0x12c>
80004284:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004288:	2f c8       	sub	r8,-4
8000428a:	10 9c       	mov	r12,r8
8000428c:	f0 1f 00 22 	mcall	80004314 <vTaskIncrementTick+0x14c>
80004290:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004294:	70 a8       	ld.w	r8,r8[0x28]
80004296:	58 08       	cp.w	r8,0
80004298:	c0 70       	breq	800042a6 <vTaskIncrementTick+0xde>
8000429a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000429e:	2e 88       	sub	r8,-24
800042a0:	10 9c       	mov	r12,r8
800042a2:	f0 1f 00 1d 	mcall	80004314 <vTaskIncrementTick+0x14c>
800042a6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800042aa:	70 b9       	ld.w	r9,r8[0x2c]
800042ac:	49 b8       	lddpc	r8,80004318 <vTaskIncrementTick+0x150>
800042ae:	70 08       	ld.w	r8,r8[0x0]
800042b0:	10 39       	cp.w	r9,r8
800042b2:	e0 88 00 07 	brls	800042c0 <vTaskIncrementTick+0xf8>
800042b6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800042ba:	70 b9       	ld.w	r9,r8[0x2c]
800042bc:	49 78       	lddpc	r8,80004318 <vTaskIncrementTick+0x150>
800042be:	91 09       	st.w	r8[0x0],r9
800042c0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800042c4:	f0 ca ff fc 	sub	r10,r8,-4
800042c8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800042cc:	70 b9       	ld.w	r9,r8[0x2c]
800042ce:	12 98       	mov	r8,r9
800042d0:	a3 68       	lsl	r8,0x2
800042d2:	12 08       	add	r8,r9
800042d4:	a3 68       	lsl	r8,0x2
800042d6:	10 99       	mov	r9,r8
800042d8:	49 18       	lddpc	r8,8000431c <vTaskIncrementTick+0x154>
800042da:	f2 08 00 08 	add	r8,r9,r8
800042de:	14 9b       	mov	r11,r10
800042e0:	10 9c       	mov	r12,r8
800042e2:	f0 1f 00 10 	mcall	80004320 <vTaskIncrementTick+0x158>
800042e6:	cb 0b       	rjmp	80004246 <vTaskIncrementTick+0x7e>
	}
	else
	{
		++uxMissedTicks;
800042e8:	48 f8       	lddpc	r8,80004324 <vTaskIncrementTick+0x15c>
800042ea:	70 08       	ld.w	r8,r8[0x0]
800042ec:	f0 c9 ff ff 	sub	r9,r8,-1
800042f0:	48 d8       	lddpc	r8,80004324 <vTaskIncrementTick+0x15c>
800042f2:	91 09       	st.w	r8[0x0],r9
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
800042f4:	2f dd       	sub	sp,-12
800042f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800042fa:	00 00       	add	r0,r0
800042fc:	00 00       	add	r0,r0
800042fe:	07 44       	ld.w	r4,--r3
80004300:	00 00       	add	r0,r0
80004302:	07 34       	ld.ub	r4,r3++
80004304:	00 00       	add	r0,r0
80004306:	06 e8       	st.h	--r3,r8
80004308:	00 00       	add	r0,r0
8000430a:	06 ec       	st.h	--r3,r12
8000430c:	00 00       	add	r0,r0
8000430e:	07 50       	ld.sh	r0,--r3
80004310:	00 00       	add	r0,r0
80004312:	00 20       	rsub	r0,r0
80004314:	80 00       	ld.sh	r0,r0[0x0]
80004316:	30 fa       	mov	r10,15
80004318:	00 00       	add	r0,r0
8000431a:	07 3c       	ld.ub	r12,r3++
8000431c:	00 00       	add	r0,r0
8000431e:	06 20       	rsub	r0,r3
80004320:	80 00       	ld.sh	r0,r0[0x0]
80004322:	2f e6       	sub	r6,-2
80004324:	00 00       	add	r0,r0
80004326:	07 48       	ld.w	r8,--r3

80004328 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
80004328:	eb cd 40 80 	pushm	r7,lr
8000432c:	1a 97       	mov	r7,sp
8000432e:	20 1d       	sub	sp,4
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80004330:	4a 58       	lddpc	r8,800043c4 <vTaskSwitchContext+0x9c>
80004332:	70 08       	ld.w	r8,r8[0x0]
80004334:	58 08       	cp.w	r8,0
80004336:	c0 c0       	breq	8000434e <vTaskSwitchContext+0x26>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80004338:	4a 48       	lddpc	r8,800043c8 <vTaskSwitchContext+0xa0>
8000433a:	30 19       	mov	r9,1
8000433c:	91 09       	st.w	r8[0x0],r9
8000433e:	c3 f8       	rjmp	800043bc <vTaskSwitchContext+0x94>

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80004340:	4a 38       	lddpc	r8,800043cc <vTaskSwitchContext+0xa4>
80004342:	70 08       	ld.w	r8,r8[0x0]
80004344:	f0 c9 00 01 	sub	r9,r8,1
80004348:	4a 18       	lddpc	r8,800043cc <vTaskSwitchContext+0xa4>
8000434a:	91 09       	st.w	r8[0x0],r9
8000434c:	c0 28       	rjmp	80004350 <vTaskSwitchContext+0x28>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000434e:	d7 03       	nop
80004350:	49 f8       	lddpc	r8,800043cc <vTaskSwitchContext+0xa4>
80004352:	70 09       	ld.w	r9,r8[0x0]
80004354:	12 98       	mov	r8,r9
80004356:	a3 68       	lsl	r8,0x2
80004358:	12 08       	add	r8,r9
8000435a:	a3 68       	lsl	r8,0x2
8000435c:	10 99       	mov	r9,r8
8000435e:	49 d8       	lddpc	r8,800043d0 <vTaskSwitchContext+0xa8>
80004360:	f2 08 00 08 	add	r8,r9,r8
80004364:	70 08       	ld.w	r8,r8[0x0]
80004366:	58 08       	cp.w	r8,0
80004368:	ce c0       	breq	80004340 <vTaskSwitchContext+0x18>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
8000436a:	49 98       	lddpc	r8,800043cc <vTaskSwitchContext+0xa4>
8000436c:	70 09       	ld.w	r9,r8[0x0]
8000436e:	12 98       	mov	r8,r9
80004370:	a3 68       	lsl	r8,0x2
80004372:	12 08       	add	r8,r9
80004374:	a3 68       	lsl	r8,0x2
80004376:	10 99       	mov	r9,r8
80004378:	49 68       	lddpc	r8,800043d0 <vTaskSwitchContext+0xa8>
8000437a:	f2 08 00 08 	add	r8,r9,r8
8000437e:	ef 48 ff fc 	st.w	r7[-4],r8
80004382:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004386:	70 18       	ld.w	r8,r8[0x4]
80004388:	70 19       	ld.w	r9,r8[0x4]
8000438a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000438e:	91 19       	st.w	r8[0x4],r9
80004390:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004394:	70 19       	ld.w	r9,r8[0x4]
80004396:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000439a:	2f 88       	sub	r8,-8
8000439c:	10 39       	cp.w	r9,r8
8000439e:	c0 81       	brne	800043ae <vTaskSwitchContext+0x86>
800043a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043a4:	70 18       	ld.w	r8,r8[0x4]
800043a6:	70 19       	ld.w	r9,r8[0x4]
800043a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043ac:	91 19       	st.w	r8[0x4],r9
800043ae:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043b2:	70 18       	ld.w	r8,r8[0x4]
800043b4:	70 38       	ld.w	r8,r8[0xc]
800043b6:	10 99       	mov	r9,r8
800043b8:	48 78       	lddpc	r8,800043d4 <vTaskSwitchContext+0xac>
800043ba:	91 09       	st.w	r8[0x0],r9

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
800043bc:	2f fd       	sub	sp,-4
800043be:	e3 cd 80 80 	ldm	sp++,r7,pc
800043c2:	00 00       	add	r0,r0
800043c4:	00 00       	add	r0,r0
800043c6:	07 44       	ld.w	r4,--r3
800043c8:	00 00       	add	r0,r0
800043ca:	07 4c       	ld.w	r12,--r3
800043cc:	00 00       	add	r0,r0
800043ce:	07 3c       	ld.ub	r12,r3++
800043d0:	00 00       	add	r0,r0
800043d2:	06 20       	rsub	r0,r3
800043d4:	00 00       	add	r0,r0
800043d6:	06 1c       	sub	r12,r3

800043d8 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800043d8:	eb cd 40 80 	pushm	r7,lr
800043dc:	1a 97       	mov	r7,sp
800043de:	20 3d       	sub	sp,12
800043e0:	ef 4c ff f8 	st.w	r7[-8],r12
800043e4:	ef 4b ff f4 	st.w	r7[-12],r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800043e8:	49 58       	lddpc	r8,8000443c <vTaskPlaceOnEventList+0x64>
800043ea:	70 08       	ld.w	r8,r8[0x0]
800043ec:	2e 88       	sub	r8,-24
800043ee:	10 9b       	mov	r11,r8
800043f0:	ee fc ff f8 	ld.w	r12,r7[-8]
800043f4:	f0 1f 00 13 	mcall	80004440 <vTaskPlaceOnEventList+0x68>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800043f8:	49 18       	lddpc	r8,8000443c <vTaskPlaceOnEventList+0x64>
800043fa:	70 08       	ld.w	r8,r8[0x0]
800043fc:	2f c8       	sub	r8,-4
800043fe:	10 9c       	mov	r12,r8
80004400:	f0 1f 00 11 	mcall	80004444 <vTaskPlaceOnEventList+0x6c>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80004404:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004408:	5b f8       	cp.w	r8,-1
8000440a:	c0 91       	brne	8000441c <vTaskPlaceOnEventList+0x44>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000440c:	48 c8       	lddpc	r8,8000443c <vTaskPlaceOnEventList+0x64>
8000440e:	70 08       	ld.w	r8,r8[0x0]
80004410:	2f c8       	sub	r8,-4
80004412:	10 9b       	mov	r11,r8
80004414:	48 dc       	lddpc	r12,80004448 <vTaskPlaceOnEventList+0x70>
80004416:	f0 1f 00 0e 	mcall	8000444c <vTaskPlaceOnEventList+0x74>
8000441a:	c0 d8       	rjmp	80004434 <vTaskPlaceOnEventList+0x5c>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
8000441c:	48 d8       	lddpc	r8,80004450 <vTaskPlaceOnEventList+0x78>
8000441e:	70 09       	ld.w	r9,r8[0x0]
80004420:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004424:	f2 08 00 08 	add	r8,r9,r8
80004428:	ef 48 ff fc 	st.w	r7[-4],r8
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000442c:	ee fc ff fc 	ld.w	r12,r7[-4]
80004430:	f0 1f 00 09 	mcall	80004454 <vTaskPlaceOnEventList+0x7c>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
80004434:	2f dd       	sub	sp,-12
80004436:	e3 cd 80 80 	ldm	sp++,r7,pc
8000443a:	00 00       	add	r0,r0
8000443c:	00 00       	add	r0,r0
8000443e:	06 1c       	sub	r12,r3
80004440:	80 00       	ld.sh	r0,r0[0x0]
80004442:	30 58       	mov	r8,5
80004444:	80 00       	ld.sh	r0,r0[0x0]
80004446:	30 fa       	mov	r10,15
80004448:	00 00       	add	r0,r0
8000444a:	07 1c       	ld.sh	r12,r3++
8000444c:	80 00       	ld.sh	r0,r0[0x0]
8000444e:	2f e6       	sub	r6,-2
80004450:	00 00       	add	r0,r0
80004452:	07 34       	ld.ub	r4,r3++
80004454:	80 00       	ld.sh	r0,r0[0x0]
80004456:	48 18       	lddpc	r8,80004458 <xTaskRemoveFromEventList>

80004458 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80004458:	eb cd 40 80 	pushm	r7,lr
8000445c:	1a 97       	mov	r7,sp
8000445e:	20 3d       	sub	sp,12
80004460:	ef 4c ff f4 	st.w	r7[-12],r12
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80004464:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004468:	70 38       	ld.w	r8,r8[0xc]
8000446a:	70 38       	ld.w	r8,r8[0xc]
8000446c:	ef 48 ff f8 	st.w	r7[-8],r8
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80004470:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004474:	2e 88       	sub	r8,-24
80004476:	10 9c       	mov	r12,r8
80004478:	f0 1f 00 25 	mcall	8000450c <xTaskRemoveFromEventList+0xb4>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000447c:	4a 58       	lddpc	r8,80004510 <xTaskRemoveFromEventList+0xb8>
8000447e:	70 08       	ld.w	r8,r8[0x0]
80004480:	58 08       	cp.w	r8,0
80004482:	c2 81       	brne	800044d2 <xTaskRemoveFromEventList+0x7a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80004484:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004488:	2f c8       	sub	r8,-4
8000448a:	10 9c       	mov	r12,r8
8000448c:	f0 1f 00 20 	mcall	8000450c <xTaskRemoveFromEventList+0xb4>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80004490:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004494:	70 b9       	ld.w	r9,r8[0x2c]
80004496:	4a 08       	lddpc	r8,80004514 <xTaskRemoveFromEventList+0xbc>
80004498:	70 08       	ld.w	r8,r8[0x0]
8000449a:	10 39       	cp.w	r9,r8
8000449c:	e0 88 00 07 	brls	800044aa <xTaskRemoveFromEventList+0x52>
800044a0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044a4:	70 b9       	ld.w	r9,r8[0x2c]
800044a6:	49 c8       	lddpc	r8,80004514 <xTaskRemoveFromEventList+0xbc>
800044a8:	91 09       	st.w	r8[0x0],r9
800044aa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044ae:	f0 ca ff fc 	sub	r10,r8,-4
800044b2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044b6:	70 b9       	ld.w	r9,r8[0x2c]
800044b8:	12 98       	mov	r8,r9
800044ba:	a3 68       	lsl	r8,0x2
800044bc:	12 08       	add	r8,r9
800044be:	a3 68       	lsl	r8,0x2
800044c0:	10 99       	mov	r9,r8
800044c2:	49 68       	lddpc	r8,80004518 <xTaskRemoveFromEventList+0xc0>
800044c4:	f2 08 00 08 	add	r8,r9,r8
800044c8:	14 9b       	mov	r11,r10
800044ca:	10 9c       	mov	r12,r8
800044cc:	f0 1f 00 14 	mcall	8000451c <xTaskRemoveFromEventList+0xc4>
800044d0:	c0 88       	rjmp	800044e0 <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800044d2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044d6:	2e 88       	sub	r8,-24
800044d8:	10 9b       	mov	r11,r8
800044da:	49 2c       	lddpc	r12,80004520 <xTaskRemoveFromEventList+0xc8>
800044dc:	f0 1f 00 10 	mcall	8000451c <xTaskRemoveFromEventList+0xc4>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800044e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044e4:	70 b9       	ld.w	r9,r8[0x2c]
800044e6:	49 08       	lddpc	r8,80004524 <xTaskRemoveFromEventList+0xcc>
800044e8:	70 08       	ld.w	r8,r8[0x0]
800044ea:	70 b8       	ld.w	r8,r8[0x2c]
800044ec:	10 39       	cp.w	r9,r8
800044ee:	c0 53       	brcs	800044f8 <xTaskRemoveFromEventList+0xa0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
800044f0:	30 18       	mov	r8,1
800044f2:	ef 48 ff fc 	st.w	r7[-4],r8
800044f6:	c0 48       	rjmp	800044fe <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		xReturn = pdFALSE;
800044f8:	30 08       	mov	r8,0
800044fa:	ef 48 ff fc 	st.w	r7[-4],r8
	}

	return xReturn;
800044fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80004502:	10 9c       	mov	r12,r8
80004504:	2f dd       	sub	sp,-12
80004506:	e3 cd 80 80 	ldm	sp++,r7,pc
8000450a:	00 00       	add	r0,r0
8000450c:	80 00       	ld.sh	r0,r0[0x0]
8000450e:	30 fa       	mov	r10,15
80004510:	00 00       	add	r0,r0
80004512:	07 44       	ld.w	r4,--r3
80004514:	00 00       	add	r0,r0
80004516:	07 3c       	ld.ub	r12,r3++
80004518:	00 00       	add	r0,r0
8000451a:	06 20       	rsub	r0,r3
8000451c:	80 00       	ld.sh	r0,r0[0x0]
8000451e:	2f e6       	sub	r6,-2
80004520:	00 00       	add	r0,r0
80004522:	06 f0       	st.b	--r3,r0
80004524:	00 00       	add	r0,r0
80004526:	06 1c       	sub	r12,r3

80004528 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
80004528:	eb cd 40 80 	pushm	r7,lr
8000452c:	1a 97       	mov	r7,sp
8000452e:	20 1d       	sub	sp,4
80004530:	ef 4c ff fc 	st.w	r7[-4],r12
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80004534:	48 78       	lddpc	r8,80004550 <vTaskSetTimeOutState+0x28>
80004536:	70 09       	ld.w	r9,r8[0x0]
80004538:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000453c:	91 09       	st.w	r8[0x0],r9
	pxTimeOut->xTimeOnEntering = xTickCount;
8000453e:	48 68       	lddpc	r8,80004554 <vTaskSetTimeOutState+0x2c>
80004540:	70 09       	ld.w	r9,r8[0x0]
80004542:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004546:	91 19       	st.w	r8[0x4],r9
}
80004548:	2f fd       	sub	sp,-4
8000454a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000454e:	00 00       	add	r0,r0
80004550:	00 00       	add	r0,r0
80004552:	07 50       	ld.sh	r0,--r3
80004554:	00 00       	add	r0,r0
80004556:	07 34       	ld.ub	r4,r3++

80004558 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80004558:	eb cd 40 80 	pushm	r7,lr
8000455c:	1a 97       	mov	r7,sp
8000455e:	20 3d       	sub	sp,12
80004560:	ef 4c ff f8 	st.w	r7[-8],r12
80004564:	ef 4b ff f4 	st.w	r7[-12],r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80004568:	f0 1f 00 25 	mcall	800045fc <xTaskCheckForTimeOut+0xa4>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
8000456c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004570:	70 08       	ld.w	r8,r8[0x0]
80004572:	5b f8       	cp.w	r8,-1
80004574:	c0 51       	brne	8000457e <xTaskCheckForTimeOut+0x26>
			{
				xReturn = pdFALSE;
80004576:	30 08       	mov	r8,0
80004578:	ef 48 ff fc 	st.w	r7[-4],r8
8000457c:	c3 88       	rjmp	800045ec <xTaskCheckForTimeOut+0x94>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000457e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004582:	70 09       	ld.w	r9,r8[0x0]
80004584:	49 f8       	lddpc	r8,80004600 <xTaskCheckForTimeOut+0xa8>
80004586:	70 08       	ld.w	r8,r8[0x0]
80004588:	10 39       	cp.w	r9,r8
8000458a:	c0 d0       	breq	800045a4 <xTaskCheckForTimeOut+0x4c>
8000458c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004590:	70 19       	ld.w	r9,r8[0x4]
80004592:	49 d8       	lddpc	r8,80004604 <xTaskCheckForTimeOut+0xac>
80004594:	70 08       	ld.w	r8,r8[0x0]
80004596:	10 39       	cp.w	r9,r8
80004598:	e0 8b 00 06 	brhi	800045a4 <xTaskCheckForTimeOut+0x4c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
8000459c:	30 18       	mov	r8,1
8000459e:	ef 48 ff fc 	st.w	r7[-4],r8
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800045a2:	c2 58       	rjmp	800045ec <xTaskCheckForTimeOut+0x94>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800045a4:	49 88       	lddpc	r8,80004604 <xTaskCheckForTimeOut+0xac>
800045a6:	70 09       	ld.w	r9,r8[0x0]
800045a8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045ac:	70 18       	ld.w	r8,r8[0x4]
800045ae:	10 19       	sub	r9,r8
800045b0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800045b4:	70 08       	ld.w	r8,r8[0x0]
800045b6:	10 39       	cp.w	r9,r8
800045b8:	c1 72       	brcc	800045e6 <xTaskCheckForTimeOut+0x8e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800045ba:	ee f8 ff f4 	ld.w	r8,r7[-12]
800045be:	70 09       	ld.w	r9,r8[0x0]
800045c0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045c4:	70 1a       	ld.w	r10,r8[0x4]
800045c6:	49 08       	lddpc	r8,80004604 <xTaskCheckForTimeOut+0xac>
800045c8:	70 08       	ld.w	r8,r8[0x0]
800045ca:	f4 08 01 08 	sub	r8,r10,r8
800045ce:	10 09       	add	r9,r8
800045d0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800045d4:	91 09       	st.w	r8[0x0],r9
			vTaskSetTimeOutState( pxTimeOut );
800045d6:	ee fc ff f8 	ld.w	r12,r7[-8]
800045da:	f0 1f 00 0c 	mcall	80004608 <xTaskCheckForTimeOut+0xb0>
			xReturn = pdFALSE;
800045de:	30 08       	mov	r8,0
800045e0:	ef 48 ff fc 	st.w	r7[-4],r8
800045e4:	c0 48       	rjmp	800045ec <xTaskCheckForTimeOut+0x94>
		}
		else
		{
			xReturn = pdTRUE;
800045e6:	30 18       	mov	r8,1
800045e8:	ef 48 ff fc 	st.w	r7[-4],r8
		}
	}
	taskEXIT_CRITICAL();
800045ec:	f0 1f 00 08 	mcall	8000460c <xTaskCheckForTimeOut+0xb4>

	return xReturn;
800045f0:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800045f4:	10 9c       	mov	r12,r8
800045f6:	2f dd       	sub	sp,-12
800045f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800045fc:	80 00       	ld.sh	r0,r0[0x0]
800045fe:	33 10       	mov	r0,49
80004600:	00 00       	add	r0,r0
80004602:	07 50       	ld.sh	r0,--r3
80004604:	00 00       	add	r0,r0
80004606:	07 34       	ld.ub	r4,r3++
80004608:	80 00       	ld.sh	r0,r0[0x0]
8000460a:	45 28       	lddsp	r8,sp[0x148]
8000460c:	80 00       	ld.sh	r0,r0[0x0]
8000460e:	33 2c       	mov	r12,50

80004610 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
80004610:	eb cd 40 80 	pushm	r7,lr
80004614:	1a 97       	mov	r7,sp
	xMissedYield = pdTRUE;
80004616:	48 38       	lddpc	r8,80004620 <vTaskMissedYield+0x10>
80004618:	30 19       	mov	r9,1
8000461a:	91 09       	st.w	r8[0x0],r9
}
8000461c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004620:	00 00       	add	r0,r0
80004622:	07 4c       	ld.w	r12,--r3

80004624 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80004624:	eb cd 40 80 	pushm	r7,lr
80004628:	1a 97       	mov	r7,sp
8000462a:	20 1d       	sub	sp,4
8000462c:	ef 4c ff fc 	st.w	r7[-4],r12
80004630:	c0 28       	rjmp	80004634 <prvIdleTask+0x10>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
80004632:	d7 03       	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
80004634:	f0 1f 00 05 	mcall	80004648 <prvIdleTask+0x24>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80004638:	48 58       	lddpc	r8,8000464c <prvIdleTask+0x28>
8000463a:	70 08       	ld.w	r8,r8[0x0]
8000463c:	58 18       	cp.w	r8,1
8000463e:	fe 98 ff fa 	brls	80004632 <prvIdleTask+0xe>
			{
				taskYIELD();
80004642:	d7 33       	scall
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
80004644:	cf 8b       	rjmp	80004634 <prvIdleTask+0x10>
80004646:	00 00       	add	r0,r0
80004648:	80 00       	ld.sh	r0,r0[0x0]
8000464a:	47 80       	lddsp	r0,sp[0x1e0]
8000464c:	00 00       	add	r0,r0
8000464e:	06 20       	rsub	r0,r3

80004650 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
80004650:	eb cd 40 80 	pushm	r7,lr
80004654:	1a 97       	mov	r7,sp
80004656:	20 5d       	sub	sp,20
80004658:	ef 4c ff fc 	st.w	r7[-4],r12
8000465c:	ef 4b ff f8 	st.w	r7[-8],r11
80004660:	ef 4a ff f4 	st.w	r7[-12],r10
80004664:	ef 49 ff f0 	st.w	r7[-16],r9
80004668:	ef 58 ff ec 	st.h	r7[-20],r8
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
8000466c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004670:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004674:	2c c8       	sub	r8,-52
80004676:	31 0a       	mov	r10,16
80004678:	12 9b       	mov	r11,r9
8000467a:	10 9c       	mov	r12,r8
8000467c:	f0 1f 00 1a 	mcall	800046e4 <prvInitialiseTCBVariables+0x94>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80004680:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004684:	30 08       	mov	r8,0
80004686:	f3 68 00 43 	st.b	r9[67],r8

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
8000468a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000468e:	58 78       	cp.w	r8,7
80004690:	e0 88 00 05 	brls	8000469a <prvInitialiseTCBVariables+0x4a>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
80004694:	30 78       	mov	r8,7
80004696:	ef 48 ff f4 	st.w	r7[-12],r8
	}

	pxTCB->uxPriority = uxPriority;
8000469a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000469e:	ee f9 ff f4 	ld.w	r9,r7[-12]
800046a2:	91 b9       	st.w	r8[0x2c],r9
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800046a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046a8:	2f c8       	sub	r8,-4
800046aa:	10 9c       	mov	r12,r8
800046ac:	f0 1f 00 0f 	mcall	800046e8 <prvInitialiseTCBVariables+0x98>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800046b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046b4:	2e 88       	sub	r8,-24
800046b6:	10 9c       	mov	r12,r8
800046b8:	f0 1f 00 0c 	mcall	800046e8 <prvInitialiseTCBVariables+0x98>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800046bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046c0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800046c4:	91 49       	st.w	r8[0x10],r9

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800046c6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800046ca:	f0 09 11 08 	rsub	r9,r8,8
800046ce:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046d2:	91 69       	st.w	r8[0x18],r9
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800046d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046d8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800046dc:	91 99       	st.w	r8[0x24],r9
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
800046de:	2f bd       	sub	sp,-20
800046e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800046e4:	80 00       	ld.sh	r0,r0[0x0]
800046e6:	4f 54       	lddpc	r4,800048b8 <prvAllocateTCBAndStack+0x20>
800046e8:	80 00       	ld.sh	r0,r0[0x0]
800046ea:	2f cc       	sub	r12,-4

800046ec <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
800046ec:	eb cd 40 80 	pushm	r7,lr
800046f0:	1a 97       	mov	r7,sp
800046f2:	20 1d       	sub	sp,4
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800046f4:	30 08       	mov	r8,0
800046f6:	ef 48 ff fc 	st.w	r7[-4],r8
800046fa:	c1 38       	rjmp	80004720 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800046fc:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004700:	12 98       	mov	r8,r9
80004702:	a3 68       	lsl	r8,0x2
80004704:	12 08       	add	r8,r9
80004706:	a3 68       	lsl	r8,0x2
80004708:	10 99       	mov	r9,r8
8000470a:	49 58       	lddpc	r8,8000475c <prvInitialiseTaskLists+0x70>
8000470c:	f2 08 00 08 	add	r8,r9,r8
80004710:	10 9c       	mov	r12,r8
80004712:	f0 1f 00 14 	mcall	80004760 <prvInitialiseTaskLists+0x74>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80004716:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000471a:	2f f8       	sub	r8,-1
8000471c:	ef 48 ff fc 	st.w	r7[-4],r8
80004720:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004724:	58 78       	cp.w	r8,7
80004726:	fe 98 ff eb 	brls	800046fc <prvInitialiseTaskLists+0x10>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
8000472a:	48 fc       	lddpc	r12,80004764 <prvInitialiseTaskLists+0x78>
8000472c:	f0 1f 00 0d 	mcall	80004760 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80004730:	48 ec       	lddpc	r12,80004768 <prvInitialiseTaskLists+0x7c>
80004732:	f0 1f 00 0c 	mcall	80004760 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xPendingReadyList );
80004736:	48 ec       	lddpc	r12,8000476c <prvInitialiseTaskLists+0x80>
80004738:	f0 1f 00 0a 	mcall	80004760 <prvInitialiseTaskLists+0x74>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
8000473c:	48 dc       	lddpc	r12,80004770 <prvInitialiseTaskLists+0x84>
8000473e:	f0 1f 00 09 	mcall	80004760 <prvInitialiseTaskLists+0x74>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80004742:	48 dc       	lddpc	r12,80004774 <prvInitialiseTaskLists+0x88>
80004744:	f0 1f 00 07 	mcall	80004760 <prvInitialiseTaskLists+0x74>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80004748:	48 c8       	lddpc	r8,80004778 <prvInitialiseTaskLists+0x8c>
8000474a:	48 79       	lddpc	r9,80004764 <prvInitialiseTaskLists+0x78>
8000474c:	91 09       	st.w	r8[0x0],r9
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000474e:	48 c8       	lddpc	r8,8000477c <prvInitialiseTaskLists+0x90>
80004750:	48 69       	lddpc	r9,80004768 <prvInitialiseTaskLists+0x7c>
80004752:	91 09       	st.w	r8[0x0],r9
}
80004754:	2f fd       	sub	sp,-4
80004756:	e3 cd 80 80 	ldm	sp++,r7,pc
8000475a:	00 00       	add	r0,r0
8000475c:	00 00       	add	r0,r0
8000475e:	06 20       	rsub	r0,r3
80004760:	80 00       	ld.sh	r0,r0[0x0]
80004762:	2f 80       	sub	r0,-8
80004764:	00 00       	add	r0,r0
80004766:	06 c0       	st.b	r3++,r0
80004768:	00 00       	add	r0,r0
8000476a:	06 d4       	st.w	--r3,r4
8000476c:	00 00       	add	r0,r0
8000476e:	06 f0       	st.b	--r3,r0
80004770:	00 00       	add	r0,r0
80004772:	07 04       	ld.w	r4,r3++
80004774:	00 00       	add	r0,r0
80004776:	07 1c       	ld.sh	r12,r3++
80004778:	00 00       	add	r0,r0
8000477a:	06 e8       	st.h	--r3,r8
8000477c:	00 00       	add	r0,r0
8000477e:	06 ec       	st.h	--r3,r12

80004780 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
80004780:	eb cd 40 80 	pushm	r7,lr
80004784:	1a 97       	mov	r7,sp
80004786:	20 2d       	sub	sp,8
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80004788:	49 b8       	lddpc	r8,800047f4 <prvCheckTasksWaitingTermination+0x74>
8000478a:	70 08       	ld.w	r8,r8[0x0]
8000478c:	58 08       	cp.w	r8,0
8000478e:	c2 f0       	breq	800047ec <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
80004790:	f0 1f 00 1a 	mcall	800047f8 <prvCheckTasksWaitingTermination+0x78>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80004794:	49 a8       	lddpc	r8,800047fc <prvCheckTasksWaitingTermination+0x7c>
80004796:	70 08       	ld.w	r8,r8[0x0]
80004798:	58 08       	cp.w	r8,0
8000479a:	5f 08       	sreq	r8
8000479c:	ef 48 ff f8 	st.w	r7[-8],r8
			xTaskResumeAll();
800047a0:	f0 1f 00 18 	mcall	80004800 <prvCheckTasksWaitingTermination+0x80>

			if( xListIsEmpty == pdFALSE )
800047a4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047a8:	58 08       	cp.w	r8,0
800047aa:	c2 11       	brne	800047ec <prvCheckTasksWaitingTermination+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800047ac:	f0 1f 00 16 	mcall	80004804 <prvCheckTasksWaitingTermination+0x84>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800047b0:	49 38       	lddpc	r8,800047fc <prvCheckTasksWaitingTermination+0x7c>
800047b2:	2f 88       	sub	r8,-8
800047b4:	70 18       	ld.w	r8,r8[0x4]
800047b6:	70 38       	ld.w	r8,r8[0xc]
800047b8:	ef 48 ff fc 	st.w	r7[-4],r8
					vListRemove( &( pxTCB->xGenericListItem ) );
800047bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800047c0:	2f c8       	sub	r8,-4
800047c2:	10 9c       	mov	r12,r8
800047c4:	f0 1f 00 11 	mcall	80004808 <prvCheckTasksWaitingTermination+0x88>
					--uxCurrentNumberOfTasks;
800047c8:	49 18       	lddpc	r8,8000480c <prvCheckTasksWaitingTermination+0x8c>
800047ca:	70 08       	ld.w	r8,r8[0x0]
800047cc:	f0 c9 00 01 	sub	r9,r8,1
800047d0:	48 f8       	lddpc	r8,8000480c <prvCheckTasksWaitingTermination+0x8c>
800047d2:	91 09       	st.w	r8[0x0],r9
					--uxTasksDeleted;
800047d4:	48 88       	lddpc	r8,800047f4 <prvCheckTasksWaitingTermination+0x74>
800047d6:	70 08       	ld.w	r8,r8[0x0]
800047d8:	f0 c9 00 01 	sub	r9,r8,1
800047dc:	48 68       	lddpc	r8,800047f4 <prvCheckTasksWaitingTermination+0x74>
800047de:	91 09       	st.w	r8[0x0],r9
				}
				taskEXIT_CRITICAL();
800047e0:	f0 1f 00 0c 	mcall	80004810 <prvCheckTasksWaitingTermination+0x90>

				prvDeleteTCB( pxTCB );
800047e4:	ee fc ff fc 	ld.w	r12,r7[-4]
800047e8:	f0 1f 00 0b 	mcall	80004814 <prvCheckTasksWaitingTermination+0x94>
			}
		}
	}
	#endif
}
800047ec:	2f ed       	sub	sp,-8
800047ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800047f2:	00 00       	add	r0,r0
800047f4:	00 00       	add	r0,r0
800047f6:	07 18       	ld.sh	r8,r3++
800047f8:	80 00       	ld.sh	r0,r0[0x0]
800047fa:	40 54       	lddsp	r4,sp[0x14]
800047fc:	00 00       	add	r0,r0
800047fe:	07 04       	ld.w	r4,r3++
80004800:	80 00       	ld.sh	r0,r0[0x0]
80004802:	40 70       	lddsp	r0,sp[0x1c]
80004804:	80 00       	ld.sh	r0,r0[0x0]
80004806:	33 10       	mov	r0,49
80004808:	80 00       	ld.sh	r0,r0[0x0]
8000480a:	30 fa       	mov	r10,15
8000480c:	00 00       	add	r0,r0
8000480e:	07 30       	ld.ub	r0,r3++
80004810:	80 00       	ld.sh	r0,r0[0x0]
80004812:	33 2c       	mov	r12,50
80004814:	80 00       	ld.sh	r0,r0[0x0]
80004816:	49 2c       	lddpc	r12,8000485c <prvAddCurrentTaskToDelayedList+0x44>

80004818 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80004818:	eb cd 40 80 	pushm	r7,lr
8000481c:	1a 97       	mov	r7,sp
8000481e:	20 1d       	sub	sp,4
80004820:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80004824:	49 78       	lddpc	r8,80004880 <prvAddCurrentTaskToDelayedList+0x68>
80004826:	70 08       	ld.w	r8,r8[0x0]
80004828:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000482c:	91 19       	st.w	r8[0x4],r9

	if( xTimeToWake < xTickCount )
8000482e:	49 68       	lddpc	r8,80004884 <prvAddCurrentTaskToDelayedList+0x6c>
80004830:	70 08       	ld.w	r8,r8[0x0]
80004832:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004836:	10 39       	cp.w	r9,r8
80004838:	c0 c2       	brcc	80004850 <prvAddCurrentTaskToDelayedList+0x38>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000483a:	49 28       	lddpc	r8,80004880 <prvAddCurrentTaskToDelayedList+0x68>
8000483c:	70 08       	ld.w	r8,r8[0x0]
8000483e:	f0 c9 ff fc 	sub	r9,r8,-4
80004842:	49 28       	lddpc	r8,80004888 <prvAddCurrentTaskToDelayedList+0x70>
80004844:	70 08       	ld.w	r8,r8[0x0]
80004846:	12 9b       	mov	r11,r9
80004848:	10 9c       	mov	r12,r8
8000484a:	f0 1f 00 11 	mcall	8000488c <prvAddCurrentTaskToDelayedList+0x74>
8000484e:	c1 58       	rjmp	80004878 <prvAddCurrentTaskToDelayedList+0x60>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004850:	48 c8       	lddpc	r8,80004880 <prvAddCurrentTaskToDelayedList+0x68>
80004852:	70 08       	ld.w	r8,r8[0x0]
80004854:	f0 c9 ff fc 	sub	r9,r8,-4
80004858:	48 e8       	lddpc	r8,80004890 <prvAddCurrentTaskToDelayedList+0x78>
8000485a:	70 08       	ld.w	r8,r8[0x0]
8000485c:	12 9b       	mov	r11,r9
8000485e:	10 9c       	mov	r12,r8
80004860:	f0 1f 00 0b 	mcall	8000488c <prvAddCurrentTaskToDelayedList+0x74>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80004864:	48 c8       	lddpc	r8,80004894 <prvAddCurrentTaskToDelayedList+0x7c>
80004866:	70 08       	ld.w	r8,r8[0x0]
80004868:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000486c:	10 39       	cp.w	r9,r8
8000486e:	c0 52       	brcc	80004878 <prvAddCurrentTaskToDelayedList+0x60>
		{
			xNextTaskUnblockTime = xTimeToWake;
80004870:	48 98       	lddpc	r8,80004894 <prvAddCurrentTaskToDelayedList+0x7c>
80004872:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004876:	91 09       	st.w	r8[0x0],r9
		}
	}
}
80004878:	2f fd       	sub	sp,-4
8000487a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000487e:	00 00       	add	r0,r0
80004880:	00 00       	add	r0,r0
80004882:	06 1c       	sub	r12,r3
80004884:	00 00       	add	r0,r0
80004886:	07 34       	ld.ub	r4,r3++
80004888:	00 00       	add	r0,r0
8000488a:	06 ec       	st.h	--r3,r12
8000488c:	80 00       	ld.sh	r0,r0[0x0]
8000488e:	30 58       	mov	r8,5
80004890:	00 00       	add	r0,r0
80004892:	06 e8       	st.h	--r3,r8
80004894:	00 00       	add	r0,r0
80004896:	00 20       	rsub	r0,r0

80004898 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
80004898:	eb cd 40 80 	pushm	r7,lr
8000489c:	1a 97       	mov	r7,sp
8000489e:	20 3d       	sub	sp,12
800048a0:	18 98       	mov	r8,r12
800048a2:	ef 4b ff f4 	st.w	r7[-12],r11
800048a6:	ef 58 ff f8 	st.h	r7[-8],r8
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800048aa:	34 4c       	mov	r12,68
800048ac:	f0 1f 00 1d 	mcall	80004920 <prvAllocateTCBAndStack+0x88>
800048b0:	18 98       	mov	r8,r12
800048b2:	ef 48 ff fc 	st.w	r7[-4],r8

	if( pxNewTCB != NULL )
800048b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800048ba:	58 08       	cp.w	r8,0
800048bc:	c2 c0       	breq	80004914 <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800048be:	ee f8 ff f4 	ld.w	r8,r7[-12]
800048c2:	58 08       	cp.w	r8,0
800048c4:	c0 91       	brne	800048d6 <prvAllocateTCBAndStack+0x3e>
800048c6:	ef 18 ff f8 	ld.uh	r8,r7[-8]
800048ca:	a3 68       	lsl	r8,0x2
800048cc:	10 9c       	mov	r12,r8
800048ce:	f0 1f 00 15 	mcall	80004920 <prvAllocateTCBAndStack+0x88>
800048d2:	18 98       	mov	r8,r12
800048d4:	c0 38       	rjmp	800048da <prvAllocateTCBAndStack+0x42>
800048d6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800048da:	ee f9 ff fc 	ld.w	r9,r7[-4]
800048de:	93 c8       	st.w	r9[0x30],r8

		if( pxNewTCB->pxStack == NULL )
800048e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800048e4:	70 c8       	ld.w	r8,r8[0x30]
800048e6:	58 08       	cp.w	r8,0
800048e8:	c0 91       	brne	800048fa <prvAllocateTCBAndStack+0x62>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800048ea:	ee fc ff fc 	ld.w	r12,r7[-4]
800048ee:	f0 1f 00 0e 	mcall	80004924 <prvAllocateTCBAndStack+0x8c>
			pxNewTCB = NULL;
800048f2:	30 08       	mov	r8,0
800048f4:	ef 48 ff fc 	st.w	r7[-4],r8
800048f8:	c0 e8       	rjmp	80004914 <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800048fa:	ef 18 ff f8 	ld.uh	r8,r7[-8]
800048fe:	f0 09 15 02 	lsl	r9,r8,0x2
80004902:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004906:	70 c8       	ld.w	r8,r8[0x30]
80004908:	12 9a       	mov	r10,r9
8000490a:	e0 6b 00 a5 	mov	r11,165
8000490e:	10 9c       	mov	r12,r8
80004910:	f0 1f 00 06 	mcall	80004928 <prvAllocateTCBAndStack+0x90>
		}
	}

	return pxNewTCB;
80004914:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80004918:	10 9c       	mov	r12,r8
8000491a:	2f dd       	sub	sp,-12
8000491c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004920:	80 00       	ld.sh	r0,r0[0x0]
80004922:	35 9c       	mov	r12,89
80004924:	80 00       	ld.sh	r0,r0[0x0]
80004926:	35 d8       	mov	r8,93
80004928:	80 00       	ld.sh	r0,r0[0x0]
8000492a:	4f 24       	lddpc	r4,80004af0 <_malloc_r+0x148>

8000492c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
8000492c:	eb cd 40 80 	pushm	r7,lr
80004930:	1a 97       	mov	r7,sp
80004932:	20 1d       	sub	sp,4
80004934:	ef 4c ff fc 	st.w	r7[-4],r12
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80004938:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000493c:	70 c8       	ld.w	r8,r8[0x30]
8000493e:	10 9c       	mov	r12,r8
80004940:	f0 1f 00 05 	mcall	80004954 <prvDeleteTCB+0x28>
		vPortFree( pxTCB );
80004944:	ee fc ff fc 	ld.w	r12,r7[-4]
80004948:	f0 1f 00 03 	mcall	80004954 <prvDeleteTCB+0x28>
	}
8000494c:	2f fd       	sub	sp,-4
8000494e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004952:	00 00       	add	r0,r0
80004954:	80 00       	ld.sh	r0,r0[0x0]
80004956:	35 d8       	mov	r8,93

80004958 <atexit>:
80004958:	d4 01       	pushm	lr
8000495a:	30 09       	mov	r9,0
8000495c:	18 9b       	mov	r11,r12
8000495e:	12 9a       	mov	r10,r9
80004960:	12 9c       	mov	r12,r9
80004962:	e0 a0 03 2f 	rcall	80004fc0 <__register_exitproc>
80004966:	d8 02       	popm	pc

80004968 <exit>:
80004968:	d4 21       	pushm	r4-r7,lr
8000496a:	30 0b       	mov	r11,0
8000496c:	18 97       	mov	r7,r12
8000496e:	e0 a0 03 7b 	rcall	80005064 <__call_exitprocs>
80004972:	fe c8 f2 6e 	sub	r8,pc,-3474
80004976:	70 0c       	ld.w	r12,r8[0x0]
80004978:	78 a8       	ld.w	r8,r12[0x28]
8000497a:	58 08       	cp.w	r8,0
8000497c:	c0 20       	breq	80004980 <exit+0x18>
8000497e:	5d 18       	icall	r8
80004980:	0e 9c       	mov	r12,r7
80004982:	e0 a0 02 fe 	rcall	80004f7e <_exit>
80004986:	d7 03       	nop

80004988 <free>:
80004988:	d4 01       	pushm	lr
8000498a:	e0 68 01 14 	mov	r8,276
8000498e:	18 9b       	mov	r11,r12
80004990:	70 0c       	ld.w	r12,r8[0x0]
80004992:	e0 a0 04 1d 	rcall	800051cc <_free_r>
80004996:	d8 02       	popm	pc

80004998 <malloc>:
80004998:	d4 01       	pushm	lr
8000499a:	e0 68 01 14 	mov	r8,276
8000499e:	18 9b       	mov	r11,r12
800049a0:	70 0c       	ld.w	r12,r8[0x0]
800049a2:	c0 3c       	rcall	800049a8 <_malloc_r>
800049a4:	d8 02       	popm	pc
800049a6:	d7 03       	nop

800049a8 <_malloc_r>:
800049a8:	d4 31       	pushm	r0-r7,lr
800049aa:	f6 c8 ff f5 	sub	r8,r11,-11
800049ae:	18 95       	mov	r5,r12
800049b0:	10 97       	mov	r7,r8
800049b2:	e0 17 ff f8 	andl	r7,0xfff8
800049b6:	59 68       	cp.w	r8,22
800049b8:	f9 b7 08 10 	movls	r7,16
800049bc:	16 37       	cp.w	r7,r11
800049be:	5f 38       	srlo	r8
800049c0:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800049c4:	c0 50       	breq	800049ce <_malloc_r+0x26>
800049c6:	30 c8       	mov	r8,12
800049c8:	99 38       	st.w	r12[0xc],r8
800049ca:	e0 8f 01 f8 	bral	80004dba <_malloc_r+0x412>
800049ce:	fe b0 f3 f7 	rcall	800031bc <__malloc_lock>
800049d2:	e0 47 01 f7 	cp.w	r7,503
800049d6:	e0 8b 00 1d 	brhi	80004a10 <_malloc_r+0x68>
800049da:	ee 03 16 03 	lsr	r3,r7,0x3
800049de:	e0 68 01 18 	mov	r8,280
800049e2:	f0 03 00 38 	add	r8,r8,r3<<0x3
800049e6:	70 36       	ld.w	r6,r8[0xc]
800049e8:	10 36       	cp.w	r6,r8
800049ea:	c0 61       	brne	800049f6 <_malloc_r+0x4e>
800049ec:	ec c8 ff f8 	sub	r8,r6,-8
800049f0:	70 36       	ld.w	r6,r8[0xc]
800049f2:	10 36       	cp.w	r6,r8
800049f4:	c0 c0       	breq	80004a0c <_malloc_r+0x64>
800049f6:	6c 18       	ld.w	r8,r6[0x4]
800049f8:	e0 18 ff fc 	andl	r8,0xfffc
800049fc:	6c 3a       	ld.w	r10,r6[0xc]
800049fe:	ec 08 00 09 	add	r9,r6,r8
80004a02:	0a 9c       	mov	r12,r5
80004a04:	6c 28       	ld.w	r8,r6[0x8]
80004a06:	95 28       	st.w	r10[0x8],r8
80004a08:	91 3a       	st.w	r8[0xc],r10
80004a0a:	c4 78       	rjmp	80004a98 <_malloc_r+0xf0>
80004a0c:	2f e3       	sub	r3,-2
80004a0e:	c4 d8       	rjmp	80004aa8 <_malloc_r+0x100>
80004a10:	ee 03 16 09 	lsr	r3,r7,0x9
80004a14:	c0 41       	brne	80004a1c <_malloc_r+0x74>
80004a16:	ee 03 16 03 	lsr	r3,r7,0x3
80004a1a:	c2 68       	rjmp	80004a66 <_malloc_r+0xbe>
80004a1c:	58 43       	cp.w	r3,4
80004a1e:	e0 8b 00 06 	brhi	80004a2a <_malloc_r+0x82>
80004a22:	ee 03 16 06 	lsr	r3,r7,0x6
80004a26:	2c 83       	sub	r3,-56
80004a28:	c1 f8       	rjmp	80004a66 <_malloc_r+0xbe>
80004a2a:	59 43       	cp.w	r3,20
80004a2c:	e0 8b 00 04 	brhi	80004a34 <_malloc_r+0x8c>
80004a30:	2a 53       	sub	r3,-91
80004a32:	c1 a8       	rjmp	80004a66 <_malloc_r+0xbe>
80004a34:	e0 43 00 54 	cp.w	r3,84
80004a38:	e0 8b 00 06 	brhi	80004a44 <_malloc_r+0x9c>
80004a3c:	ee 03 16 0c 	lsr	r3,r7,0xc
80004a40:	29 23       	sub	r3,-110
80004a42:	c1 28       	rjmp	80004a66 <_malloc_r+0xbe>
80004a44:	e0 43 01 54 	cp.w	r3,340
80004a48:	e0 8b 00 06 	brhi	80004a54 <_malloc_r+0xac>
80004a4c:	ee 03 16 0f 	lsr	r3,r7,0xf
80004a50:	28 93       	sub	r3,-119
80004a52:	c0 a8       	rjmp	80004a66 <_malloc_r+0xbe>
80004a54:	e0 43 05 54 	cp.w	r3,1364
80004a58:	e0 88 00 04 	brls	80004a60 <_malloc_r+0xb8>
80004a5c:	37 e3       	mov	r3,126
80004a5e:	c0 48       	rjmp	80004a66 <_malloc_r+0xbe>
80004a60:	ee 03 16 12 	lsr	r3,r7,0x12
80004a64:	28 43       	sub	r3,-124
80004a66:	e0 6a 01 18 	mov	r10,280
80004a6a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80004a6e:	74 36       	ld.w	r6,r10[0xc]
80004a70:	c1 98       	rjmp	80004aa2 <_malloc_r+0xfa>
80004a72:	6c 19       	ld.w	r9,r6[0x4]
80004a74:	e0 19 ff fc 	andl	r9,0xfffc
80004a78:	f2 07 01 0b 	sub	r11,r9,r7
80004a7c:	58 fb       	cp.w	r11,15
80004a7e:	e0 8a 00 04 	brle	80004a86 <_malloc_r+0xde>
80004a82:	20 13       	sub	r3,1
80004a84:	c1 18       	rjmp	80004aa6 <_malloc_r+0xfe>
80004a86:	6c 38       	ld.w	r8,r6[0xc]
80004a88:	58 0b       	cp.w	r11,0
80004a8a:	c0 b5       	brlt	80004aa0 <_malloc_r+0xf8>
80004a8c:	6c 2a       	ld.w	r10,r6[0x8]
80004a8e:	ec 09 00 09 	add	r9,r6,r9
80004a92:	0a 9c       	mov	r12,r5
80004a94:	91 2a       	st.w	r8[0x8],r10
80004a96:	95 38       	st.w	r10[0xc],r8
80004a98:	72 18       	ld.w	r8,r9[0x4]
80004a9a:	a1 a8       	sbr	r8,0x0
80004a9c:	93 18       	st.w	r9[0x4],r8
80004a9e:	cb c8       	rjmp	80004c16 <_malloc_r+0x26e>
80004aa0:	10 96       	mov	r6,r8
80004aa2:	14 36       	cp.w	r6,r10
80004aa4:	ce 71       	brne	80004a72 <_malloc_r+0xca>
80004aa6:	2f f3       	sub	r3,-1
80004aa8:	e0 6a 01 18 	mov	r10,280
80004aac:	f4 cc ff f8 	sub	r12,r10,-8
80004ab0:	78 26       	ld.w	r6,r12[0x8]
80004ab2:	18 36       	cp.w	r6,r12
80004ab4:	c6 c0       	breq	80004b8c <_malloc_r+0x1e4>
80004ab6:	6c 19       	ld.w	r9,r6[0x4]
80004ab8:	e0 19 ff fc 	andl	r9,0xfffc
80004abc:	f2 07 01 08 	sub	r8,r9,r7
80004ac0:	58 f8       	cp.w	r8,15
80004ac2:	e0 89 00 8f 	brgt	80004be0 <_malloc_r+0x238>
80004ac6:	99 3c       	st.w	r12[0xc],r12
80004ac8:	99 2c       	st.w	r12[0x8],r12
80004aca:	58 08       	cp.w	r8,0
80004acc:	c0 55       	brlt	80004ad6 <_malloc_r+0x12e>
80004ace:	ec 09 00 09 	add	r9,r6,r9
80004ad2:	0a 9c       	mov	r12,r5
80004ad4:	ce 2b       	rjmp	80004a98 <_malloc_r+0xf0>
80004ad6:	e0 49 01 ff 	cp.w	r9,511
80004ada:	e0 8b 00 13 	brhi	80004b00 <_malloc_r+0x158>
80004ade:	a3 99       	lsr	r9,0x3
80004ae0:	f4 09 00 38 	add	r8,r10,r9<<0x3
80004ae4:	70 2b       	ld.w	r11,r8[0x8]
80004ae6:	8d 38       	st.w	r6[0xc],r8
80004ae8:	8d 2b       	st.w	r6[0x8],r11
80004aea:	97 36       	st.w	r11[0xc],r6
80004aec:	91 26       	st.w	r8[0x8],r6
80004aee:	a3 49       	asr	r9,0x2
80004af0:	74 18       	ld.w	r8,r10[0x4]
80004af2:	30 1b       	mov	r11,1
80004af4:	f6 09 09 49 	lsl	r9,r11,r9
80004af8:	f1 e9 10 09 	or	r9,r8,r9
80004afc:	95 19       	st.w	r10[0x4],r9
80004afe:	c4 78       	rjmp	80004b8c <_malloc_r+0x1e4>
80004b00:	f2 0a 16 09 	lsr	r10,r9,0x9
80004b04:	58 4a       	cp.w	r10,4
80004b06:	e0 8b 00 07 	brhi	80004b14 <_malloc_r+0x16c>
80004b0a:	f2 0a 16 06 	lsr	r10,r9,0x6
80004b0e:	2c 8a       	sub	r10,-56
80004b10:	c2 08       	rjmp	80004b50 <_malloc_r+0x1a8>
80004b12:	d7 03       	nop
80004b14:	59 4a       	cp.w	r10,20
80004b16:	e0 8b 00 04 	brhi	80004b1e <_malloc_r+0x176>
80004b1a:	2a 5a       	sub	r10,-91
80004b1c:	c1 a8       	rjmp	80004b50 <_malloc_r+0x1a8>
80004b1e:	e0 4a 00 54 	cp.w	r10,84
80004b22:	e0 8b 00 06 	brhi	80004b2e <_malloc_r+0x186>
80004b26:	f2 0a 16 0c 	lsr	r10,r9,0xc
80004b2a:	29 2a       	sub	r10,-110
80004b2c:	c1 28       	rjmp	80004b50 <_malloc_r+0x1a8>
80004b2e:	e0 4a 01 54 	cp.w	r10,340
80004b32:	e0 8b 00 06 	brhi	80004b3e <_malloc_r+0x196>
80004b36:	f2 0a 16 0f 	lsr	r10,r9,0xf
80004b3a:	28 9a       	sub	r10,-119
80004b3c:	c0 a8       	rjmp	80004b50 <_malloc_r+0x1a8>
80004b3e:	e0 4a 05 54 	cp.w	r10,1364
80004b42:	e0 88 00 04 	brls	80004b4a <_malloc_r+0x1a2>
80004b46:	37 ea       	mov	r10,126
80004b48:	c0 48       	rjmp	80004b50 <_malloc_r+0x1a8>
80004b4a:	f2 0a 16 12 	lsr	r10,r9,0x12
80004b4e:	28 4a       	sub	r10,-124
80004b50:	e0 6b 01 18 	mov	r11,280
80004b54:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80004b58:	68 28       	ld.w	r8,r4[0x8]
80004b5a:	08 38       	cp.w	r8,r4
80004b5c:	c0 e1       	brne	80004b78 <_malloc_r+0x1d0>
80004b5e:	76 19       	ld.w	r9,r11[0x4]
80004b60:	a3 4a       	asr	r10,0x2
80004b62:	30 1e       	mov	lr,1
80004b64:	fc 0a 09 4a 	lsl	r10,lr,r10
80004b68:	f3 ea 10 0a 	or	r10,r9,r10
80004b6c:	10 99       	mov	r9,r8
80004b6e:	97 1a       	st.w	r11[0x4],r10
80004b70:	c0 a8       	rjmp	80004b84 <_malloc_r+0x1dc>
80004b72:	70 28       	ld.w	r8,r8[0x8]
80004b74:	08 38       	cp.w	r8,r4
80004b76:	c0 60       	breq	80004b82 <_malloc_r+0x1da>
80004b78:	70 1a       	ld.w	r10,r8[0x4]
80004b7a:	e0 1a ff fc 	andl	r10,0xfffc
80004b7e:	14 39       	cp.w	r9,r10
80004b80:	cf 93       	brcs	80004b72 <_malloc_r+0x1ca>
80004b82:	70 39       	ld.w	r9,r8[0xc]
80004b84:	8d 39       	st.w	r6[0xc],r9
80004b86:	8d 28       	st.w	r6[0x8],r8
80004b88:	91 36       	st.w	r8[0xc],r6
80004b8a:	93 26       	st.w	r9[0x8],r6
80004b8c:	e6 08 14 02 	asr	r8,r3,0x2
80004b90:	30 1b       	mov	r11,1
80004b92:	e0 64 01 18 	mov	r4,280
80004b96:	f6 08 09 4b 	lsl	r11,r11,r8
80004b9a:	68 18       	ld.w	r8,r4[0x4]
80004b9c:	10 3b       	cp.w	r11,r8
80004b9e:	e0 8b 00 6b 	brhi	80004c74 <_malloc_r+0x2cc>
80004ba2:	f7 e8 00 09 	and	r9,r11,r8
80004ba6:	c0 b1       	brne	80004bbc <_malloc_r+0x214>
80004ba8:	e0 13 ff fc 	andl	r3,0xfffc
80004bac:	a1 7b       	lsl	r11,0x1
80004bae:	2f c3       	sub	r3,-4
80004bb0:	c0 38       	rjmp	80004bb6 <_malloc_r+0x20e>
80004bb2:	2f c3       	sub	r3,-4
80004bb4:	a1 7b       	lsl	r11,0x1
80004bb6:	f7 e8 00 09 	and	r9,r11,r8
80004bba:	cf c0       	breq	80004bb2 <_malloc_r+0x20a>
80004bbc:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80004bc0:	06 92       	mov	r2,r3
80004bc2:	1c 91       	mov	r1,lr
80004bc4:	62 36       	ld.w	r6,r1[0xc]
80004bc6:	c2 e8       	rjmp	80004c22 <_malloc_r+0x27a>
80004bc8:	6c 1a       	ld.w	r10,r6[0x4]
80004bca:	e0 1a ff fc 	andl	r10,0xfffc
80004bce:	f4 07 01 08 	sub	r8,r10,r7
80004bd2:	58 f8       	cp.w	r8,15
80004bd4:	e0 8a 00 15 	brle	80004bfe <_malloc_r+0x256>
80004bd8:	6c 3a       	ld.w	r10,r6[0xc]
80004bda:	6c 29       	ld.w	r9,r6[0x8]
80004bdc:	95 29       	st.w	r10[0x8],r9
80004bde:	93 3a       	st.w	r9[0xc],r10
80004be0:	0e 99       	mov	r9,r7
80004be2:	ec 07 00 07 	add	r7,r6,r7
80004be6:	a1 a9       	sbr	r9,0x0
80004be8:	99 37       	st.w	r12[0xc],r7
80004bea:	99 27       	st.w	r12[0x8],r7
80004bec:	8d 19       	st.w	r6[0x4],r9
80004bee:	ee 08 09 08 	st.w	r7[r8],r8
80004bf2:	8f 2c       	st.w	r7[0x8],r12
80004bf4:	8f 3c       	st.w	r7[0xc],r12
80004bf6:	a1 a8       	sbr	r8,0x0
80004bf8:	0a 9c       	mov	r12,r5
80004bfa:	8f 18       	st.w	r7[0x4],r8
80004bfc:	c0 d8       	rjmp	80004c16 <_malloc_r+0x26e>
80004bfe:	6c 39       	ld.w	r9,r6[0xc]
80004c00:	58 08       	cp.w	r8,0
80004c02:	c0 f5       	brlt	80004c20 <_malloc_r+0x278>
80004c04:	ec 0a 00 0a 	add	r10,r6,r10
80004c08:	74 18       	ld.w	r8,r10[0x4]
80004c0a:	a1 a8       	sbr	r8,0x0
80004c0c:	0a 9c       	mov	r12,r5
80004c0e:	95 18       	st.w	r10[0x4],r8
80004c10:	6c 28       	ld.w	r8,r6[0x8]
80004c12:	93 28       	st.w	r9[0x8],r8
80004c14:	91 39       	st.w	r8[0xc],r9
80004c16:	fe b0 f2 e1 	rcall	800031d8 <__malloc_unlock>
80004c1a:	ec cc ff f8 	sub	r12,r6,-8
80004c1e:	d8 32       	popm	r0-r7,pc
80004c20:	12 96       	mov	r6,r9
80004c22:	02 36       	cp.w	r6,r1
80004c24:	cd 21       	brne	80004bc8 <_malloc_r+0x220>
80004c26:	2f f2       	sub	r2,-1
80004c28:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80004c2c:	c0 30       	breq	80004c32 <_malloc_r+0x28a>
80004c2e:	2f 81       	sub	r1,-8
80004c30:	cc ab       	rjmp	80004bc4 <_malloc_r+0x21c>
80004c32:	1c 98       	mov	r8,lr
80004c34:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80004c38:	c0 81       	brne	80004c48 <_malloc_r+0x2a0>
80004c3a:	68 19       	ld.w	r9,r4[0x4]
80004c3c:	f6 08 11 ff 	rsub	r8,r11,-1
80004c40:	f3 e8 00 08 	and	r8,r9,r8
80004c44:	89 18       	st.w	r4[0x4],r8
80004c46:	c0 78       	rjmp	80004c54 <_malloc_r+0x2ac>
80004c48:	f0 c9 00 08 	sub	r9,r8,8
80004c4c:	20 13       	sub	r3,1
80004c4e:	70 08       	ld.w	r8,r8[0x0]
80004c50:	12 38       	cp.w	r8,r9
80004c52:	cf 10       	breq	80004c34 <_malloc_r+0x28c>
80004c54:	a1 7b       	lsl	r11,0x1
80004c56:	68 18       	ld.w	r8,r4[0x4]
80004c58:	10 3b       	cp.w	r11,r8
80004c5a:	e0 8b 00 0d 	brhi	80004c74 <_malloc_r+0x2cc>
80004c5e:	58 0b       	cp.w	r11,0
80004c60:	c0 a0       	breq	80004c74 <_malloc_r+0x2cc>
80004c62:	04 93       	mov	r3,r2
80004c64:	c0 38       	rjmp	80004c6a <_malloc_r+0x2c2>
80004c66:	2f c3       	sub	r3,-4
80004c68:	a1 7b       	lsl	r11,0x1
80004c6a:	f7 e8 00 09 	and	r9,r11,r8
80004c6e:	ca 71       	brne	80004bbc <_malloc_r+0x214>
80004c70:	cf bb       	rjmp	80004c66 <_malloc_r+0x2be>
80004c72:	d7 03       	nop
80004c74:	68 23       	ld.w	r3,r4[0x8]
80004c76:	66 12       	ld.w	r2,r3[0x4]
80004c78:	e0 12 ff fc 	andl	r2,0xfffc
80004c7c:	0e 32       	cp.w	r2,r7
80004c7e:	5f 39       	srlo	r9
80004c80:	e4 07 01 08 	sub	r8,r2,r7
80004c84:	58 f8       	cp.w	r8,15
80004c86:	5f aa       	srle	r10
80004c88:	f5 e9 10 09 	or	r9,r10,r9
80004c8c:	e0 80 00 98 	breq	80004dbc <_malloc_r+0x414>
80004c90:	e0 68 07 60 	mov	r8,1888
80004c94:	70 01       	ld.w	r1,r8[0x0]
80004c96:	e0 68 05 24 	mov	r8,1316
80004c9a:	2f 01       	sub	r1,-16
80004c9c:	70 08       	ld.w	r8,r8[0x0]
80004c9e:	0e 01       	add	r1,r7
80004ca0:	5b f8       	cp.w	r8,-1
80004ca2:	c0 40       	breq	80004caa <_malloc_r+0x302>
80004ca4:	28 11       	sub	r1,-127
80004ca6:	e0 11 ff 80 	andl	r1,0xff80
80004caa:	02 9b       	mov	r11,r1
80004cac:	0a 9c       	mov	r12,r5
80004cae:	c4 3d       	rcall	80004f34 <_sbrk_r>
80004cb0:	18 96       	mov	r6,r12
80004cb2:	5b fc       	cp.w	r12,-1
80004cb4:	c7 40       	breq	80004d9c <_malloc_r+0x3f4>
80004cb6:	e6 02 00 08 	add	r8,r3,r2
80004cba:	10 3c       	cp.w	r12,r8
80004cbc:	c0 32       	brcc	80004cc2 <_malloc_r+0x31a>
80004cbe:	08 33       	cp.w	r3,r4
80004cc0:	c6 e1       	brne	80004d9c <_malloc_r+0x3f4>
80004cc2:	e0 6a 07 64 	mov	r10,1892
80004cc6:	74 09       	ld.w	r9,r10[0x0]
80004cc8:	e2 09 00 09 	add	r9,r1,r9
80004ccc:	95 09       	st.w	r10[0x0],r9
80004cce:	10 36       	cp.w	r6,r8
80004cd0:	c0 a1       	brne	80004ce4 <_malloc_r+0x33c>
80004cd2:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80004cd6:	c0 71       	brne	80004ce4 <_malloc_r+0x33c>
80004cd8:	e2 02 00 02 	add	r2,r1,r2
80004cdc:	68 28       	ld.w	r8,r4[0x8]
80004cde:	a1 a2       	sbr	r2,0x0
80004ce0:	91 12       	st.w	r8[0x4],r2
80004ce2:	c4 e8       	rjmp	80004d7e <_malloc_r+0x3d6>
80004ce4:	e0 6a 05 24 	mov	r10,1316
80004ce8:	74 0b       	ld.w	r11,r10[0x0]
80004cea:	5b fb       	cp.w	r11,-1
80004cec:	c0 31       	brne	80004cf2 <_malloc_r+0x34a>
80004cee:	95 06       	st.w	r10[0x0],r6
80004cf0:	c0 78       	rjmp	80004cfe <_malloc_r+0x356>
80004cf2:	ec 09 00 09 	add	r9,r6,r9
80004cf6:	e0 6a 07 64 	mov	r10,1892
80004cfa:	10 19       	sub	r9,r8
80004cfc:	95 09       	st.w	r10[0x0],r9
80004cfe:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80004d02:	f0 09 11 08 	rsub	r9,r8,8
80004d06:	58 08       	cp.w	r8,0
80004d08:	f2 08 17 10 	movne	r8,r9
80004d0c:	ed d8 e1 06 	addne	r6,r6,r8
80004d10:	28 08       	sub	r8,-128
80004d12:	ec 01 00 01 	add	r1,r6,r1
80004d16:	0a 9c       	mov	r12,r5
80004d18:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80004d1c:	f0 01 01 01 	sub	r1,r8,r1
80004d20:	02 9b       	mov	r11,r1
80004d22:	c0 9d       	rcall	80004f34 <_sbrk_r>
80004d24:	e0 68 07 64 	mov	r8,1892
80004d28:	5b fc       	cp.w	r12,-1
80004d2a:	ec 0c 17 00 	moveq	r12,r6
80004d2e:	f9 b1 00 00 	moveq	r1,0
80004d32:	70 09       	ld.w	r9,r8[0x0]
80004d34:	0c 1c       	sub	r12,r6
80004d36:	89 26       	st.w	r4[0x8],r6
80004d38:	02 0c       	add	r12,r1
80004d3a:	12 01       	add	r1,r9
80004d3c:	a1 ac       	sbr	r12,0x0
80004d3e:	91 01       	st.w	r8[0x0],r1
80004d40:	8d 1c       	st.w	r6[0x4],r12
80004d42:	08 33       	cp.w	r3,r4
80004d44:	c1 d0       	breq	80004d7e <_malloc_r+0x3d6>
80004d46:	58 f2       	cp.w	r2,15
80004d48:	e0 8b 00 05 	brhi	80004d52 <_malloc_r+0x3aa>
80004d4c:	30 18       	mov	r8,1
80004d4e:	8d 18       	st.w	r6[0x4],r8
80004d50:	c2 68       	rjmp	80004d9c <_malloc_r+0x3f4>
80004d52:	30 59       	mov	r9,5
80004d54:	20 c2       	sub	r2,12
80004d56:	e0 12 ff f8 	andl	r2,0xfff8
80004d5a:	e6 02 00 08 	add	r8,r3,r2
80004d5e:	91 29       	st.w	r8[0x8],r9
80004d60:	91 19       	st.w	r8[0x4],r9
80004d62:	66 18       	ld.w	r8,r3[0x4]
80004d64:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004d68:	e5 e8 10 08 	or	r8,r2,r8
80004d6c:	87 18       	st.w	r3[0x4],r8
80004d6e:	58 f2       	cp.w	r2,15
80004d70:	e0 88 00 07 	brls	80004d7e <_malloc_r+0x3d6>
80004d74:	e6 cb ff f8 	sub	r11,r3,-8
80004d78:	0a 9c       	mov	r12,r5
80004d7a:	e0 a0 02 29 	rcall	800051cc <_free_r>
80004d7e:	e0 69 07 5c 	mov	r9,1884
80004d82:	72 0a       	ld.w	r10,r9[0x0]
80004d84:	e0 68 07 64 	mov	r8,1892
80004d88:	70 08       	ld.w	r8,r8[0x0]
80004d8a:	14 38       	cp.w	r8,r10
80004d8c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80004d90:	e0 69 07 58 	mov	r9,1880
80004d94:	72 0a       	ld.w	r10,r9[0x0]
80004d96:	14 38       	cp.w	r8,r10
80004d98:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80004d9c:	68 28       	ld.w	r8,r4[0x8]
80004d9e:	70 18       	ld.w	r8,r8[0x4]
80004da0:	e0 18 ff fc 	andl	r8,0xfffc
80004da4:	0e 38       	cp.w	r8,r7
80004da6:	5f 39       	srlo	r9
80004da8:	0e 18       	sub	r8,r7
80004daa:	58 f8       	cp.w	r8,15
80004dac:	5f aa       	srle	r10
80004dae:	f5 e9 10 09 	or	r9,r10,r9
80004db2:	c0 50       	breq	80004dbc <_malloc_r+0x414>
80004db4:	0a 9c       	mov	r12,r5
80004db6:	fe b0 f2 11 	rcall	800031d8 <__malloc_unlock>
80004dba:	d8 3a       	popm	r0-r7,pc,r12=0
80004dbc:	68 26       	ld.w	r6,r4[0x8]
80004dbe:	a1 a8       	sbr	r8,0x0
80004dc0:	0e 99       	mov	r9,r7
80004dc2:	a1 a9       	sbr	r9,0x0
80004dc4:	8d 19       	st.w	r6[0x4],r9
80004dc6:	ec 07 00 07 	add	r7,r6,r7
80004dca:	0a 9c       	mov	r12,r5
80004dcc:	89 27       	st.w	r4[0x8],r7
80004dce:	8f 18       	st.w	r7[0x4],r8
80004dd0:	fe b0 f2 04 	rcall	800031d8 <__malloc_unlock>
80004dd4:	ec cc ff f8 	sub	r12,r6,-8
80004dd8:	d8 32       	popm	r0-r7,pc
80004dda:	d7 03       	nop

80004ddc <memcpy>:
80004ddc:	58 8a       	cp.w	r10,8
80004dde:	c2 f5       	brlt	80004e3c <memcpy+0x60>
80004de0:	f9 eb 10 09 	or	r9,r12,r11
80004de4:	e2 19 00 03 	andl	r9,0x3,COH
80004de8:	e0 81 00 97 	brne	80004f16 <memcpy+0x13a>
80004dec:	e0 4a 00 20 	cp.w	r10,32
80004df0:	c3 b4       	brge	80004e66 <memcpy+0x8a>
80004df2:	f4 08 14 02 	asr	r8,r10,0x2
80004df6:	f0 09 11 08 	rsub	r9,r8,8
80004dfa:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80004dfe:	76 69       	ld.w	r9,r11[0x18]
80004e00:	99 69       	st.w	r12[0x18],r9
80004e02:	76 59       	ld.w	r9,r11[0x14]
80004e04:	99 59       	st.w	r12[0x14],r9
80004e06:	76 49       	ld.w	r9,r11[0x10]
80004e08:	99 49       	st.w	r12[0x10],r9
80004e0a:	76 39       	ld.w	r9,r11[0xc]
80004e0c:	99 39       	st.w	r12[0xc],r9
80004e0e:	76 29       	ld.w	r9,r11[0x8]
80004e10:	99 29       	st.w	r12[0x8],r9
80004e12:	76 19       	ld.w	r9,r11[0x4]
80004e14:	99 19       	st.w	r12[0x4],r9
80004e16:	76 09       	ld.w	r9,r11[0x0]
80004e18:	99 09       	st.w	r12[0x0],r9
80004e1a:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80004e1e:	f8 08 00 28 	add	r8,r12,r8<<0x2
80004e22:	e0 1a 00 03 	andl	r10,0x3
80004e26:	f4 0a 11 04 	rsub	r10,r10,4
80004e2a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80004e2e:	17 a9       	ld.ub	r9,r11[0x2]
80004e30:	b0 a9       	st.b	r8[0x2],r9
80004e32:	17 99       	ld.ub	r9,r11[0x1]
80004e34:	b0 99       	st.b	r8[0x1],r9
80004e36:	17 89       	ld.ub	r9,r11[0x0]
80004e38:	b0 89       	st.b	r8[0x0],r9
80004e3a:	5e fc       	retal	r12
80004e3c:	f4 0a 11 09 	rsub	r10,r10,9
80004e40:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80004e44:	17 f9       	ld.ub	r9,r11[0x7]
80004e46:	b8 f9       	st.b	r12[0x7],r9
80004e48:	17 e9       	ld.ub	r9,r11[0x6]
80004e4a:	b8 e9       	st.b	r12[0x6],r9
80004e4c:	17 d9       	ld.ub	r9,r11[0x5]
80004e4e:	b8 d9       	st.b	r12[0x5],r9
80004e50:	17 c9       	ld.ub	r9,r11[0x4]
80004e52:	b8 c9       	st.b	r12[0x4],r9
80004e54:	17 b9       	ld.ub	r9,r11[0x3]
80004e56:	b8 b9       	st.b	r12[0x3],r9
80004e58:	17 a9       	ld.ub	r9,r11[0x2]
80004e5a:	b8 a9       	st.b	r12[0x2],r9
80004e5c:	17 99       	ld.ub	r9,r11[0x1]
80004e5e:	b8 99       	st.b	r12[0x1],r9
80004e60:	17 89       	ld.ub	r9,r11[0x0]
80004e62:	b8 89       	st.b	r12[0x0],r9
80004e64:	5e fc       	retal	r12
80004e66:	eb cd 40 c0 	pushm	r6-r7,lr
80004e6a:	18 99       	mov	r9,r12
80004e6c:	22 0a       	sub	r10,32
80004e6e:	b7 07       	ld.d	r6,r11++
80004e70:	b3 26       	st.d	r9++,r6
80004e72:	b7 07       	ld.d	r6,r11++
80004e74:	b3 26       	st.d	r9++,r6
80004e76:	b7 07       	ld.d	r6,r11++
80004e78:	b3 26       	st.d	r9++,r6
80004e7a:	b7 07       	ld.d	r6,r11++
80004e7c:	b3 26       	st.d	r9++,r6
80004e7e:	22 0a       	sub	r10,32
80004e80:	cf 74       	brge	80004e6e <memcpy+0x92>
80004e82:	2f 0a       	sub	r10,-16
80004e84:	c0 65       	brlt	80004e90 <memcpy+0xb4>
80004e86:	b7 07       	ld.d	r6,r11++
80004e88:	b3 26       	st.d	r9++,r6
80004e8a:	b7 07       	ld.d	r6,r11++
80004e8c:	b3 26       	st.d	r9++,r6
80004e8e:	21 0a       	sub	r10,16
80004e90:	5c 3a       	neg	r10
80004e92:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80004e96:	d7 03       	nop
80004e98:	d7 03       	nop
80004e9a:	f7 36 00 0e 	ld.ub	r6,r11[14]
80004e9e:	f3 66 00 0e 	st.b	r9[14],r6
80004ea2:	f7 36 00 0d 	ld.ub	r6,r11[13]
80004ea6:	f3 66 00 0d 	st.b	r9[13],r6
80004eaa:	f7 36 00 0c 	ld.ub	r6,r11[12]
80004eae:	f3 66 00 0c 	st.b	r9[12],r6
80004eb2:	f7 36 00 0b 	ld.ub	r6,r11[11]
80004eb6:	f3 66 00 0b 	st.b	r9[11],r6
80004eba:	f7 36 00 0a 	ld.ub	r6,r11[10]
80004ebe:	f3 66 00 0a 	st.b	r9[10],r6
80004ec2:	f7 36 00 09 	ld.ub	r6,r11[9]
80004ec6:	f3 66 00 09 	st.b	r9[9],r6
80004eca:	f7 36 00 08 	ld.ub	r6,r11[8]
80004ece:	f3 66 00 08 	st.b	r9[8],r6
80004ed2:	f7 36 00 07 	ld.ub	r6,r11[7]
80004ed6:	f3 66 00 07 	st.b	r9[7],r6
80004eda:	f7 36 00 06 	ld.ub	r6,r11[6]
80004ede:	f3 66 00 06 	st.b	r9[6],r6
80004ee2:	f7 36 00 05 	ld.ub	r6,r11[5]
80004ee6:	f3 66 00 05 	st.b	r9[5],r6
80004eea:	f7 36 00 04 	ld.ub	r6,r11[4]
80004eee:	f3 66 00 04 	st.b	r9[4],r6
80004ef2:	f7 36 00 03 	ld.ub	r6,r11[3]
80004ef6:	f3 66 00 03 	st.b	r9[3],r6
80004efa:	f7 36 00 02 	ld.ub	r6,r11[2]
80004efe:	f3 66 00 02 	st.b	r9[2],r6
80004f02:	f7 36 00 01 	ld.ub	r6,r11[1]
80004f06:	f3 66 00 01 	st.b	r9[1],r6
80004f0a:	f7 36 00 00 	ld.ub	r6,r11[0]
80004f0e:	f3 66 00 00 	st.b	r9[0],r6
80004f12:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f16:	20 1a       	sub	r10,1
80004f18:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80004f1c:	f8 0a 0b 09 	st.b	r12[r10],r9
80004f20:	cf b1       	brne	80004f16 <memcpy+0x13a>
80004f22:	5e fc       	retal	r12

80004f24 <memset>:
80004f24:	18 98       	mov	r8,r12
80004f26:	c0 38       	rjmp	80004f2c <memset+0x8>
80004f28:	10 cb       	st.b	r8++,r11
80004f2a:	20 1a       	sub	r10,1
80004f2c:	58 0a       	cp.w	r10,0
80004f2e:	cf d1       	brne	80004f28 <memset+0x4>
80004f30:	5e fc       	retal	r12
80004f32:	d7 03       	nop

80004f34 <_sbrk_r>:
80004f34:	d4 21       	pushm	r4-r7,lr
80004f36:	30 08       	mov	r8,0
80004f38:	18 97       	mov	r7,r12
80004f3a:	e0 66 07 98 	mov	r6,1944
80004f3e:	16 9c       	mov	r12,r11
80004f40:	8d 08       	st.w	r6[0x0],r8
80004f42:	c2 3c       	rcall	80004f88 <_sbrk>
80004f44:	5b fc       	cp.w	r12,-1
80004f46:	c0 51       	brne	80004f50 <_sbrk_r+0x1c>
80004f48:	6c 08       	ld.w	r8,r6[0x0]
80004f4a:	58 08       	cp.w	r8,0
80004f4c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80004f50:	d8 22       	popm	r4-r7,pc
80004f52:	d7 03       	nop

80004f54 <strncpy>:
80004f54:	30 08       	mov	r8,0
80004f56:	10 3a       	cp.w	r10,r8
80004f58:	5e 0c       	reteq	r12
80004f5a:	f6 08 07 09 	ld.ub	r9,r11[r8]
80004f5e:	f8 08 0b 09 	st.b	r12[r8],r9
80004f62:	2f f8       	sub	r8,-1
80004f64:	58 09       	cp.w	r9,0
80004f66:	cf 81       	brne	80004f56 <strncpy+0x2>
80004f68:	10 3a       	cp.w	r10,r8
80004f6a:	5e 0c       	reteq	r12
80004f6c:	f8 08 0b 09 	st.b	r12[r8],r9
80004f70:	2f f8       	sub	r8,-1
80004f72:	cf bb       	rjmp	80004f68 <strncpy+0x14>

80004f74 <_init_argv>:
80004f74:	30 e8       	mov	r8,14
80004f76:	d6 73       	breakpoint
80004f78:	3f fc       	mov	r12,-1
80004f7a:	35 8b       	mov	r11,88
80004f7c:	5e fc       	retal	r12

80004f7e <_exit>:
80004f7e:	30 d8       	mov	r8,13
80004f80:	d6 73       	breakpoint
80004f82:	3f fc       	mov	r12,-1
80004f84:	35 8b       	mov	r11,88
80004f86:	c0 08       	rjmp	80004f86 <_exit+0x8>

80004f88 <_sbrk>:
80004f88:	d4 01       	pushm	lr
80004f8a:	e0 68 07 8c 	mov	r8,1932
80004f8e:	70 09       	ld.w	r9,r8[0x0]
80004f90:	58 09       	cp.w	r9,0
80004f92:	c0 41       	brne	80004f9a <_sbrk+0x12>
80004f94:	e0 69 07 a0 	mov	r9,1952
80004f98:	91 09       	st.w	r8[0x0],r9
80004f9a:	e0 69 07 8c 	mov	r9,1932
80004f9e:	e0 6a f0 00 	mov	r10,61440
80004fa2:	72 08       	ld.w	r8,r9[0x0]
80004fa4:	f0 0c 00 0c 	add	r12,r8,r12
80004fa8:	14 3c       	cp.w	r12,r10
80004faa:	e0 8b 00 04 	brhi	80004fb2 <_sbrk+0x2a>
80004fae:	93 0c       	st.w	r9[0x0],r12
80004fb0:	c0 58       	rjmp	80004fba <_sbrk+0x32>
80004fb2:	cb fc       	rcall	80005130 <__errno>
80004fb4:	30 c8       	mov	r8,12
80004fb6:	99 08       	st.w	r12[0x0],r8
80004fb8:	3f f8       	mov	r8,-1
80004fba:	10 9c       	mov	r12,r8
80004fbc:	d8 02       	popm	pc
80004fbe:	d7 03       	nop

80004fc0 <__register_exitproc>:
80004fc0:	d4 31       	pushm	r0-r7,lr
80004fc2:	fe c8 f8 be 	sub	r8,pc,-1858
80004fc6:	70 03       	ld.w	r3,r8[0x0]
80004fc8:	67 24       	ld.w	r4,r3[0x48]
80004fca:	e6 c8 ff b4 	sub	r8,r3,-76
80004fce:	58 04       	cp.w	r4,0
80004fd0:	f0 04 17 00 	moveq	r4,r8
80004fd4:	e7 f4 0a 12 	st.weq	r3[0x48],r4
80004fd8:	18 97       	mov	r7,r12
80004fda:	16 96       	mov	r6,r11
80004fdc:	14 95       	mov	r5,r10
80004fde:	12 92       	mov	r2,r9
80004fe0:	68 18       	ld.w	r8,r4[0x4]
80004fe2:	59 f8       	cp.w	r8,31
80004fe4:	e0 8a 00 0e 	brle	80005000 <__register_exitproc+0x40>
80004fe8:	e0 6c 00 8c 	mov	r12,140
80004fec:	fe b0 fc d6 	rcall	80004998 <malloc>
80004ff0:	18 94       	mov	r4,r12
80004ff2:	c3 80       	breq	80005062 <__register_exitproc+0xa2>
80004ff4:	67 28       	ld.w	r8,r3[0x48]
80004ff6:	99 08       	st.w	r12[0x0],r8
80004ff8:	e7 4c 00 48 	st.w	r3[72],r12
80004ffc:	30 08       	mov	r8,0
80004ffe:	99 18       	st.w	r12[0x4],r8
80005000:	58 07       	cp.w	r7,0
80005002:	c2 70       	breq	80005050 <__register_exitproc+0x90>
80005004:	e8 fc 00 88 	ld.w	r12,r4[136]
80005008:	58 0c       	cp.w	r12,0
8000500a:	c0 d1       	brne	80005024 <__register_exitproc+0x64>
8000500c:	e0 6c 01 08 	mov	r12,264
80005010:	fe b0 fc c4 	rcall	80004998 <malloc>
80005014:	c2 70       	breq	80005062 <__register_exitproc+0xa2>
80005016:	30 08       	mov	r8,0
80005018:	e9 4c 00 88 	st.w	r4[136],r12
8000501c:	f9 48 01 04 	st.w	r12[260],r8
80005020:	f9 48 01 00 	st.w	r12[256],r8
80005024:	68 18       	ld.w	r8,r4[0x4]
80005026:	f0 c9 ff e0 	sub	r9,r8,-32
8000502a:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
8000502e:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
80005032:	30 1a       	mov	r10,1
80005034:	f8 f9 01 00 	ld.w	r9,r12[256]
80005038:	f4 08 09 48 	lsl	r8,r10,r8
8000503c:	10 49       	or	r9,r8
8000503e:	f9 49 01 00 	st.w	r12[256],r9
80005042:	58 27       	cp.w	r7,2
80005044:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
80005048:	f3 d8 e0 38 	oreq	r8,r9,r8
8000504c:	f9 f8 0a 41 	st.weq	r12[0x104],r8
80005050:	68 18       	ld.w	r8,r4[0x4]
80005052:	30 0c       	mov	r12,0
80005054:	f0 c9 ff ff 	sub	r9,r8,-1
80005058:	2f e8       	sub	r8,-2
8000505a:	89 19       	st.w	r4[0x4],r9
8000505c:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
80005060:	d8 32       	popm	r0-r7,pc
80005062:	dc 3a       	popm	r0-r7,pc,r12=-1

80005064 <__call_exitprocs>:
80005064:	d4 31       	pushm	r0-r7,lr
80005066:	20 3d       	sub	sp,12
80005068:	fe c8 f9 64 	sub	r8,pc,-1692
8000506c:	50 2c       	stdsp	sp[0x8],r12
8000506e:	70 08       	ld.w	r8,r8[0x0]
80005070:	16 91       	mov	r1,r11
80005072:	50 08       	stdsp	sp[0x0],r8
80005074:	2b 88       	sub	r8,-72
80005076:	50 18       	stdsp	sp[0x4],r8
80005078:	40 0a       	lddsp	r10,sp[0x0]
8000507a:	40 14       	lddsp	r4,sp[0x4]
8000507c:	75 27       	ld.w	r7,r10[0x48]
8000507e:	c5 58       	rjmp	80005128 <__call_exitprocs+0xc4>
80005080:	6e 15       	ld.w	r5,r7[0x4]
80005082:	ee f6 00 88 	ld.w	r6,r7[136]
80005086:	ea c2 ff ff 	sub	r2,r5,-1
8000508a:	20 15       	sub	r5,1
8000508c:	ee 02 00 22 	add	r2,r7,r2<<0x2
80005090:	ec 05 00 23 	add	r3,r6,r5<<0x2
80005094:	c3 58       	rjmp	800050fe <__call_exitprocs+0x9a>
80005096:	58 01       	cp.w	r1,0
80005098:	c0 70       	breq	800050a6 <__call_exitprocs+0x42>
8000509a:	58 06       	cp.w	r6,0
8000509c:	c2 e0       	breq	800050f8 <__call_exitprocs+0x94>
8000509e:	e6 f8 00 80 	ld.w	r8,r3[128]
800050a2:	02 38       	cp.w	r8,r1
800050a4:	c2 a1       	brne	800050f8 <__call_exitprocs+0x94>
800050a6:	6e 19       	ld.w	r9,r7[0x4]
800050a8:	64 08       	ld.w	r8,r2[0x0]
800050aa:	20 19       	sub	r9,1
800050ac:	12 35       	cp.w	r5,r9
800050ae:	ef f5 0a 01 	st.weq	r7[0x4],r5
800050b2:	f9 b9 01 00 	movne	r9,0
800050b6:	e5 f9 1a 00 	st.wne	r2[0x0],r9
800050ba:	58 08       	cp.w	r8,0
800050bc:	c1 e0       	breq	800050f8 <__call_exitprocs+0x94>
800050be:	6e 10       	ld.w	r0,r7[0x4]
800050c0:	58 06       	cp.w	r6,0
800050c2:	c0 90       	breq	800050d4 <__call_exitprocs+0x70>
800050c4:	30 1a       	mov	r10,1
800050c6:	f4 05 09 49 	lsl	r9,r10,r5
800050ca:	ec fa 01 00 	ld.w	r10,r6[256]
800050ce:	f3 ea 00 0a 	and	r10,r9,r10
800050d2:	c0 31       	brne	800050d8 <__call_exitprocs+0x74>
800050d4:	5d 18       	icall	r8
800050d6:	c0 b8       	rjmp	800050ec <__call_exitprocs+0x88>
800050d8:	ec fa 01 04 	ld.w	r10,r6[260]
800050dc:	66 0b       	ld.w	r11,r3[0x0]
800050de:	14 69       	and	r9,r10
800050e0:	c0 41       	brne	800050e8 <__call_exitprocs+0x84>
800050e2:	40 2c       	lddsp	r12,sp[0x8]
800050e4:	5d 18       	icall	r8
800050e6:	c0 38       	rjmp	800050ec <__call_exitprocs+0x88>
800050e8:	16 9c       	mov	r12,r11
800050ea:	5d 18       	icall	r8
800050ec:	6e 18       	ld.w	r8,r7[0x4]
800050ee:	10 30       	cp.w	r0,r8
800050f0:	cc 41       	brne	80005078 <__call_exitprocs+0x14>
800050f2:	68 08       	ld.w	r8,r4[0x0]
800050f4:	0e 38       	cp.w	r8,r7
800050f6:	cc 11       	brne	80005078 <__call_exitprocs+0x14>
800050f8:	20 15       	sub	r5,1
800050fa:	20 43       	sub	r3,4
800050fc:	20 42       	sub	r2,4
800050fe:	58 05       	cp.w	r5,0
80005100:	cc b4       	brge	80005096 <__call_exitprocs+0x32>
80005102:	6e 18       	ld.w	r8,r7[0x4]
80005104:	58 08       	cp.w	r8,0
80005106:	c0 f1       	brne	80005124 <__call_exitprocs+0xc0>
80005108:	6e 08       	ld.w	r8,r7[0x0]
8000510a:	58 08       	cp.w	r8,0
8000510c:	c0 c0       	breq	80005124 <__call_exitprocs+0xc0>
8000510e:	89 08       	st.w	r4[0x0],r8
80005110:	58 06       	cp.w	r6,0
80005112:	c0 40       	breq	8000511a <__call_exitprocs+0xb6>
80005114:	0c 9c       	mov	r12,r6
80005116:	fe b0 fc 39 	rcall	80004988 <free>
8000511a:	0e 9c       	mov	r12,r7
8000511c:	fe b0 fc 36 	rcall	80004988 <free>
80005120:	68 07       	ld.w	r7,r4[0x0]
80005122:	c0 38       	rjmp	80005128 <__call_exitprocs+0xc4>
80005124:	0e 94       	mov	r4,r7
80005126:	6e 07       	ld.w	r7,r7[0x0]
80005128:	58 07       	cp.w	r7,0
8000512a:	ca b1       	brne	80005080 <__call_exitprocs+0x1c>
8000512c:	2f dd       	sub	sp,-12
8000512e:	d8 32       	popm	r0-r7,pc

80005130 <__errno>:
80005130:	e0 68 01 14 	mov	r8,276
80005134:	70 0c       	ld.w	r12,r8[0x0]
80005136:	2f 4c       	sub	r12,-12
80005138:	5e fc       	retal	r12
8000513a:	d7 03       	nop

8000513c <_malloc_trim_r>:
8000513c:	d4 21       	pushm	r4-r7,lr
8000513e:	16 95       	mov	r5,r11
80005140:	18 97       	mov	r7,r12
80005142:	fe b0 f0 3d 	rcall	800031bc <__malloc_lock>
80005146:	e0 64 01 18 	mov	r4,280
8000514a:	68 28       	ld.w	r8,r4[0x8]
8000514c:	70 16       	ld.w	r6,r8[0x4]
8000514e:	e0 16 ff fc 	andl	r6,0xfffc
80005152:	ec c8 ff 91 	sub	r8,r6,-111
80005156:	f0 05 01 05 	sub	r5,r8,r5
8000515a:	e0 15 ff 80 	andl	r5,0xff80
8000515e:	ea c5 00 80 	sub	r5,r5,128
80005162:	e0 45 00 7f 	cp.w	r5,127
80005166:	e0 8a 00 22 	brle	800051aa <_malloc_trim_r+0x6e>
8000516a:	30 0b       	mov	r11,0
8000516c:	0e 9c       	mov	r12,r7
8000516e:	ce 3e       	rcall	80004f34 <_sbrk_r>
80005170:	68 28       	ld.w	r8,r4[0x8]
80005172:	0c 08       	add	r8,r6
80005174:	10 3c       	cp.w	r12,r8
80005176:	c1 a1       	brne	800051aa <_malloc_trim_r+0x6e>
80005178:	ea 0b 11 00 	rsub	r11,r5,0
8000517c:	0e 9c       	mov	r12,r7
8000517e:	cd be       	rcall	80004f34 <_sbrk_r>
80005180:	5b fc       	cp.w	r12,-1
80005182:	c1 81       	brne	800051b2 <_malloc_trim_r+0x76>
80005184:	30 0b       	mov	r11,0
80005186:	0e 9c       	mov	r12,r7
80005188:	cd 6e       	rcall	80004f34 <_sbrk_r>
8000518a:	68 28       	ld.w	r8,r4[0x8]
8000518c:	f8 08 01 09 	sub	r9,r12,r8
80005190:	58 f9       	cp.w	r9,15
80005192:	e0 8a 00 0c 	brle	800051aa <_malloc_trim_r+0x6e>
80005196:	a1 a9       	sbr	r9,0x0
80005198:	91 19       	st.w	r8[0x4],r9
8000519a:	e0 68 05 24 	mov	r8,1316
8000519e:	70 09       	ld.w	r9,r8[0x0]
800051a0:	e0 68 07 64 	mov	r8,1892
800051a4:	f8 09 01 09 	sub	r9,r12,r9
800051a8:	91 09       	st.w	r8[0x0],r9
800051aa:	0e 9c       	mov	r12,r7
800051ac:	fe b0 f0 16 	rcall	800031d8 <__malloc_unlock>
800051b0:	d8 2a       	popm	r4-r7,pc,r12=0
800051b2:	68 28       	ld.w	r8,r4[0x8]
800051b4:	0a 16       	sub	r6,r5
800051b6:	a1 a6       	sbr	r6,0x0
800051b8:	91 16       	st.w	r8[0x4],r6
800051ba:	e0 68 07 64 	mov	r8,1892
800051be:	70 09       	ld.w	r9,r8[0x0]
800051c0:	0a 19       	sub	r9,r5
800051c2:	0e 9c       	mov	r12,r7
800051c4:	91 09       	st.w	r8[0x0],r9
800051c6:	fe b0 f0 09 	rcall	800031d8 <__malloc_unlock>
800051ca:	da 2a       	popm	r4-r7,pc,r12=1

800051cc <_free_r>:
800051cc:	d4 21       	pushm	r4-r7,lr
800051ce:	16 96       	mov	r6,r11
800051d0:	18 97       	mov	r7,r12
800051d2:	58 0b       	cp.w	r11,0
800051d4:	e0 80 00 c0 	breq	80005354 <_free_r+0x188>
800051d8:	fe b0 ef f2 	rcall	800031bc <__malloc_lock>
800051dc:	20 86       	sub	r6,8
800051de:	e0 6a 01 18 	mov	r10,280
800051e2:	6c 18       	ld.w	r8,r6[0x4]
800051e4:	74 2e       	ld.w	lr,r10[0x8]
800051e6:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800051ea:	a1 c8       	cbr	r8,0x0
800051ec:	ec 08 00 09 	add	r9,r6,r8
800051f0:	72 1b       	ld.w	r11,r9[0x4]
800051f2:	e0 1b ff fc 	andl	r11,0xfffc
800051f6:	1c 39       	cp.w	r9,lr
800051f8:	c1 e1       	brne	80005234 <_free_r+0x68>
800051fa:	f6 08 00 08 	add	r8,r11,r8
800051fe:	58 0c       	cp.w	r12,0
80005200:	c0 81       	brne	80005210 <_free_r+0x44>
80005202:	6c 09       	ld.w	r9,r6[0x0]
80005204:	12 16       	sub	r6,r9
80005206:	12 08       	add	r8,r9
80005208:	6c 3b       	ld.w	r11,r6[0xc]
8000520a:	6c 29       	ld.w	r9,r6[0x8]
8000520c:	97 29       	st.w	r11[0x8],r9
8000520e:	93 3b       	st.w	r9[0xc],r11
80005210:	10 99       	mov	r9,r8
80005212:	95 26       	st.w	r10[0x8],r6
80005214:	a1 a9       	sbr	r9,0x0
80005216:	8d 19       	st.w	r6[0x4],r9
80005218:	e0 69 05 20 	mov	r9,1312
8000521c:	72 09       	ld.w	r9,r9[0x0]
8000521e:	12 38       	cp.w	r8,r9
80005220:	c0 63       	brcs	8000522c <_free_r+0x60>
80005222:	e0 68 07 60 	mov	r8,1888
80005226:	0e 9c       	mov	r12,r7
80005228:	70 0b       	ld.w	r11,r8[0x0]
8000522a:	c8 9f       	rcall	8000513c <_malloc_trim_r>
8000522c:	0e 9c       	mov	r12,r7
8000522e:	fe b0 ef d5 	rcall	800031d8 <__malloc_unlock>
80005232:	d8 22       	popm	r4-r7,pc
80005234:	93 1b       	st.w	r9[0x4],r11
80005236:	58 0c       	cp.w	r12,0
80005238:	c0 30       	breq	8000523e <_free_r+0x72>
8000523a:	30 0c       	mov	r12,0
8000523c:	c1 08       	rjmp	8000525c <_free_r+0x90>
8000523e:	6c 0e       	ld.w	lr,r6[0x0]
80005240:	f4 c5 ff f8 	sub	r5,r10,-8
80005244:	1c 16       	sub	r6,lr
80005246:	1c 08       	add	r8,lr
80005248:	6c 2e       	ld.w	lr,r6[0x8]
8000524a:	0a 3e       	cp.w	lr,r5
8000524c:	f9 bc 00 01 	moveq	r12,1
80005250:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80005254:	eb fe 1a 02 	st.wne	r5[0x8],lr
80005258:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000525c:	f2 0b 00 0e 	add	lr,r9,r11
80005260:	7c 1e       	ld.w	lr,lr[0x4]
80005262:	ed be 00 00 	bld	lr,0x0
80005266:	c1 40       	breq	8000528e <_free_r+0xc2>
80005268:	16 08       	add	r8,r11
8000526a:	58 0c       	cp.w	r12,0
8000526c:	c0 d1       	brne	80005286 <_free_r+0xba>
8000526e:	e0 6e 01 18 	mov	lr,280
80005272:	72 2b       	ld.w	r11,r9[0x8]
80005274:	2f 8e       	sub	lr,-8
80005276:	1c 3b       	cp.w	r11,lr
80005278:	c0 71       	brne	80005286 <_free_r+0xba>
8000527a:	97 36       	st.w	r11[0xc],r6
8000527c:	97 26       	st.w	r11[0x8],r6
8000527e:	8d 2b       	st.w	r6[0x8],r11
80005280:	8d 3b       	st.w	r6[0xc],r11
80005282:	30 1c       	mov	r12,1
80005284:	c0 58       	rjmp	8000528e <_free_r+0xc2>
80005286:	72 2b       	ld.w	r11,r9[0x8]
80005288:	72 39       	ld.w	r9,r9[0xc]
8000528a:	93 2b       	st.w	r9[0x8],r11
8000528c:	97 39       	st.w	r11[0xc],r9
8000528e:	10 99       	mov	r9,r8
80005290:	ec 08 09 08 	st.w	r6[r8],r8
80005294:	a1 a9       	sbr	r9,0x0
80005296:	8d 19       	st.w	r6[0x4],r9
80005298:	58 0c       	cp.w	r12,0
8000529a:	c5 a1       	brne	8000534e <_free_r+0x182>
8000529c:	e0 48 01 ff 	cp.w	r8,511
800052a0:	e0 8b 00 13 	brhi	800052c6 <_free_r+0xfa>
800052a4:	a3 98       	lsr	r8,0x3
800052a6:	f4 08 00 39 	add	r9,r10,r8<<0x3
800052aa:	72 2b       	ld.w	r11,r9[0x8]
800052ac:	8d 39       	st.w	r6[0xc],r9
800052ae:	8d 2b       	st.w	r6[0x8],r11
800052b0:	97 36       	st.w	r11[0xc],r6
800052b2:	93 26       	st.w	r9[0x8],r6
800052b4:	a3 48       	asr	r8,0x2
800052b6:	74 19       	ld.w	r9,r10[0x4]
800052b8:	30 1b       	mov	r11,1
800052ba:	f6 08 09 48 	lsl	r8,r11,r8
800052be:	f3 e8 10 08 	or	r8,r9,r8
800052c2:	95 18       	st.w	r10[0x4],r8
800052c4:	c4 58       	rjmp	8000534e <_free_r+0x182>
800052c6:	f0 0b 16 09 	lsr	r11,r8,0x9
800052ca:	58 4b       	cp.w	r11,4
800052cc:	e0 8b 00 06 	brhi	800052d8 <_free_r+0x10c>
800052d0:	f0 0b 16 06 	lsr	r11,r8,0x6
800052d4:	2c 8b       	sub	r11,-56
800052d6:	c2 08       	rjmp	80005316 <_free_r+0x14a>
800052d8:	59 4b       	cp.w	r11,20
800052da:	e0 8b 00 04 	brhi	800052e2 <_free_r+0x116>
800052de:	2a 5b       	sub	r11,-91
800052e0:	c1 b8       	rjmp	80005316 <_free_r+0x14a>
800052e2:	e0 4b 00 54 	cp.w	r11,84
800052e6:	e0 8b 00 06 	brhi	800052f2 <_free_r+0x126>
800052ea:	f0 0b 16 0c 	lsr	r11,r8,0xc
800052ee:	29 2b       	sub	r11,-110
800052f0:	c1 38       	rjmp	80005316 <_free_r+0x14a>
800052f2:	e0 4b 01 54 	cp.w	r11,340
800052f6:	e0 8b 00 06 	brhi	80005302 <_free_r+0x136>
800052fa:	f0 0b 16 0f 	lsr	r11,r8,0xf
800052fe:	28 9b       	sub	r11,-119
80005300:	c0 b8       	rjmp	80005316 <_free_r+0x14a>
80005302:	e0 4b 05 54 	cp.w	r11,1364
80005306:	e0 88 00 05 	brls	80005310 <_free_r+0x144>
8000530a:	37 eb       	mov	r11,126
8000530c:	c0 58       	rjmp	80005316 <_free_r+0x14a>
8000530e:	d7 03       	nop
80005310:	f0 0b 16 12 	lsr	r11,r8,0x12
80005314:	28 4b       	sub	r11,-124
80005316:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000531a:	78 29       	ld.w	r9,r12[0x8]
8000531c:	18 39       	cp.w	r9,r12
8000531e:	c0 e1       	brne	8000533a <_free_r+0x16e>
80005320:	74 18       	ld.w	r8,r10[0x4]
80005322:	a3 4b       	asr	r11,0x2
80005324:	30 1c       	mov	r12,1
80005326:	f8 0b 09 4b 	lsl	r11,r12,r11
8000532a:	f1 eb 10 0b 	or	r11,r8,r11
8000532e:	12 98       	mov	r8,r9
80005330:	95 1b       	st.w	r10[0x4],r11
80005332:	c0 a8       	rjmp	80005346 <_free_r+0x17a>
80005334:	72 29       	ld.w	r9,r9[0x8]
80005336:	18 39       	cp.w	r9,r12
80005338:	c0 60       	breq	80005344 <_free_r+0x178>
8000533a:	72 1a       	ld.w	r10,r9[0x4]
8000533c:	e0 1a ff fc 	andl	r10,0xfffc
80005340:	14 38       	cp.w	r8,r10
80005342:	cf 93       	brcs	80005334 <_free_r+0x168>
80005344:	72 38       	ld.w	r8,r9[0xc]
80005346:	8d 38       	st.w	r6[0xc],r8
80005348:	8d 29       	st.w	r6[0x8],r9
8000534a:	93 36       	st.w	r9[0xc],r6
8000534c:	91 26       	st.w	r8[0x8],r6
8000534e:	0e 9c       	mov	r12,r7
80005350:	fe b0 ef 44 	rcall	800031d8 <__malloc_unlock>
80005354:	d8 22       	popm	r4-r7,pc
80005356:	d7 03       	nop

80005358 <__do_global_ctors_aux>:
80005358:	d4 21       	pushm	r4-r7,lr
8000535a:	30 c7       	mov	r7,12
8000535c:	c0 28       	rjmp	80005360 <__do_global_ctors_aux+0x8>
8000535e:	5d 18       	icall	r8
80005360:	20 47       	sub	r7,4
80005362:	6e 08       	ld.w	r8,r7[0x0]
80005364:	5b f8       	cp.w	r8,-1
80005366:	cf c1       	brne	8000535e <__do_global_ctors_aux+0x6>
80005368:	d8 22       	popm	r4-r7,pc
8000536a:	d7 03       	nop

Disassembly of section .exception:

80005400 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80005400:	c0 08       	rjmp	80005400 <_evba>
	...

80005404 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80005404:	c0 08       	rjmp	80005404 <_handle_TLB_Multiple_Hit>
	...

80005408 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80005408:	c0 08       	rjmp	80005408 <_handle_Bus_Error_Data_Fetch>
	...

8000540c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000540c:	c0 08       	rjmp	8000540c <_handle_Bus_Error_Instruction_Fetch>
	...

80005410 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80005410:	c0 08       	rjmp	80005410 <_handle_NMI>
	...

80005414 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80005414:	c0 08       	rjmp	80005414 <_handle_Instruction_Address>
	...

80005418 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80005418:	c0 08       	rjmp	80005418 <_handle_ITLB_Protection>
	...

8000541c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000541c:	c0 08       	rjmp	8000541c <_handle_Breakpoint>
	...

80005420 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80005420:	c0 08       	rjmp	80005420 <_handle_Illegal_Opcode>
	...

80005424 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80005424:	c0 08       	rjmp	80005424 <_handle_Unimplemented_Instruction>
	...

80005428 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80005428:	c0 08       	rjmp	80005428 <_handle_Privilege_Violation>
	...

8000542c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000542c:	c0 08       	rjmp	8000542c <_handle_Floating_Point>
	...

80005430 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
80005430:	c0 08       	rjmp	80005430 <_handle_Coprocessor_Absent>
	...

80005434 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80005434:	c0 08       	rjmp	80005434 <_handle_Data_Address_Read>
	...

80005438 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80005438:	c0 08       	rjmp	80005438 <_handle_Data_Address_Write>
	...

8000543c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000543c:	c0 08       	rjmp	8000543c <_handle_DTLB_Protection_Read>
	...

80005440 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80005440:	c0 08       	rjmp	80005440 <_handle_DTLB_Protection_Write>
	...

80005444 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80005444:	c0 08       	rjmp	80005444 <_handle_DTLB_Modified>
	...

80005450 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80005450:	c0 08       	rjmp	80005450 <_handle_ITLB_Miss>
	...

80005460 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80005460:	c0 08       	rjmp	80005460 <_handle_DTLB_Miss_Read>
	...

80005470 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80005470:	c0 08       	rjmp	80005470 <_handle_DTLB_Miss_Write>
	...

80005500 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80005500:	fe cf 22 88 	sub	pc,pc,8840

80005504 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80005504:	30 0c       	mov	r12,0
80005506:	fe b0 e9 75 	rcall	800027f0 <_get_interrupt_handler>
8000550a:	58 0c       	cp.w	r12,0
8000550c:	f8 0f 17 10 	movne	pc,r12
80005510:	d6 03       	rete

80005512 <_int1>:
80005512:	30 1c       	mov	r12,1
80005514:	fe b0 e9 6e 	rcall	800027f0 <_get_interrupt_handler>
80005518:	58 0c       	cp.w	r12,0
8000551a:	f8 0f 17 10 	movne	pc,r12
8000551e:	d6 03       	rete

80005520 <_int2>:
80005520:	30 2c       	mov	r12,2
80005522:	fe b0 e9 67 	rcall	800027f0 <_get_interrupt_handler>
80005526:	58 0c       	cp.w	r12,0
80005528:	f8 0f 17 10 	movne	pc,r12
8000552c:	d6 03       	rete

8000552e <_int3>:
8000552e:	30 3c       	mov	r12,3
80005530:	fe b0 e9 60 	rcall	800027f0 <_get_interrupt_handler>
80005534:	58 0c       	cp.w	r12,0
80005536:	f8 0f 17 10 	movne	pc,r12
8000553a:	d6 03       	rete
8000553c:	d7 03       	nop
8000553e:	d7 03       	nop
80005540:	d7 03       	nop
80005542:	d7 03       	nop
80005544:	d7 03       	nop
80005546:	d7 03       	nop
80005548:	d7 03       	nop
8000554a:	d7 03       	nop
8000554c:	d7 03       	nop
8000554e:	d7 03       	nop
80005550:	d7 03       	nop
80005552:	d7 03       	nop
80005554:	d7 03       	nop
80005556:	d7 03       	nop
80005558:	d7 03       	nop
8000555a:	d7 03       	nop
8000555c:	d7 03       	nop
8000555e:	d7 03       	nop
80005560:	d7 03       	nop
80005562:	d7 03       	nop
80005564:	d7 03       	nop
80005566:	d7 03       	nop
80005568:	d7 03       	nop
8000556a:	d7 03       	nop
8000556c:	d7 03       	nop
8000556e:	d7 03       	nop
80005570:	d7 03       	nop
80005572:	d7 03       	nop
80005574:	d7 03       	nop
80005576:	d7 03       	nop
80005578:	d7 03       	nop
8000557a:	d7 03       	nop
8000557c:	d7 03       	nop
8000557e:	d7 03       	nop
80005580:	d7 03       	nop
80005582:	d7 03       	nop
80005584:	d7 03       	nop
80005586:	d7 03       	nop
80005588:	d7 03       	nop
8000558a:	d7 03       	nop
8000558c:	d7 03       	nop
8000558e:	d7 03       	nop
80005590:	d7 03       	nop
80005592:	d7 03       	nop
80005594:	d7 03       	nop
80005596:	d7 03       	nop
80005598:	d7 03       	nop
8000559a:	d7 03       	nop
8000559c:	d7 03       	nop
8000559e:	d7 03       	nop
800055a0:	d7 03       	nop
800055a2:	d7 03       	nop
800055a4:	d7 03       	nop
800055a6:	d7 03       	nop
800055a8:	d7 03       	nop
800055aa:	d7 03       	nop
800055ac:	d7 03       	nop
800055ae:	d7 03       	nop
800055b0:	d7 03       	nop
800055b2:	d7 03       	nop
800055b4:	d7 03       	nop
800055b6:	d7 03       	nop
800055b8:	d7 03       	nop
800055ba:	d7 03       	nop
800055bc:	d7 03       	nop
800055be:	d7 03       	nop
800055c0:	d7 03       	nop
800055c2:	d7 03       	nop
800055c4:	d7 03       	nop
800055c6:	d7 03       	nop
800055c8:	d7 03       	nop
800055ca:	d7 03       	nop
800055cc:	d7 03       	nop
800055ce:	d7 03       	nop
800055d0:	d7 03       	nop
800055d2:	d7 03       	nop
800055d4:	d7 03       	nop
800055d6:	d7 03       	nop
800055d8:	d7 03       	nop
800055da:	d7 03       	nop
800055dc:	d7 03       	nop
800055de:	d7 03       	nop
800055e0:	d7 03       	nop
800055e2:	d7 03       	nop
800055e4:	d7 03       	nop
800055e6:	d7 03       	nop
800055e8:	d7 03       	nop
800055ea:	d7 03       	nop
800055ec:	d7 03       	nop
800055ee:	d7 03       	nop
800055f0:	d7 03       	nop
800055f2:	d7 03       	nop
800055f4:	d7 03       	nop
800055f6:	d7 03       	nop
800055f8:	d7 03       	nop
800055fa:	d7 03       	nop
800055fc:	d7 03       	nop
800055fe:	d7 03       	nop

Disassembly of section .fini:

80005600 <_fini>:
80005600:	eb cd 40 40 	pushm	r6,lr
80005604:	48 26       	lddpc	r6,8000560c <_fini+0xc>
80005606:	1e 26       	rsub	r6,pc
80005608:	c0 48       	rjmp	80005610 <_fini+0x10>
8000560a:	d7 03       	nop
8000560c:	80 00       	ld.sh	r0,r0[0x0]
8000560e:	55 ea       	stdsp	sp[0x178],r10
80005610:	fe b0 e5 3c 	rcall	80002088 <__do_global_dtors_aux>
80005614:	e3 cd 80 40 	ldm	sp++,r6,pc
