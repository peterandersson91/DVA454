
Lab61b.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         00004e58  80002028  80002028  00002428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  80007000  80007000  00007400  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  80007200  80007200  00007600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       00000180  80007218  80007218  00007618  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  8 .ctors        00000008  00000008  80007398  00007808  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .dtors        00000008  00000010  800073a0  00007810  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .jcr          00000004  00000018  800073a8  00007818  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got          00000000  0000001c  800073ac  0000781c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         00000510  0000001c  800073ac  0000781c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .bss          000002ac  00000544  00000544  00000000  2**2
                  ALLOC
 14 .heap         0000e810  000007f0  000007f0  00000000  2**0
                  ALLOC
 15 .comment      00000030  00000000  00000000  00007d2c  2**0
                  CONTENTS, READONLY
 16 .debug_aranges 00000c60  00000000  00000000  00007d60  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_pubnames 0000185b  00000000  00000000  000089c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_info   000182f6  00000000  00000000  0000a21b  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_abbrev 00003310  00000000  00000000  00022511  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_line   0000bd56  00000000  00000000  00025821  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_frame  000021fc  00000000  00000000  00031578  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_str    0000403c  00000000  00000000  00033774  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_loc    0000401f  00000000  00000000  000377b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_macinfo 00ef6f9f  00000000  00000000  0003b7cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 26 .debug_ranges 00000bc0  00000000  00000000  00f3276e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	20 28       	sub	r8,2

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

8000200c <_init>:
8000200c:	eb cd 40 40 	pushm	r6,lr
80002010:	48 26       	lddpc	r6,80002018 <_init+0xc>
80002012:	1e 26       	rsub	r6,pc
80002014:	c0 48       	rjmp	8000201c <_init+0x10>
80002016:	d7 03       	nop
80002018:	80 00       	ld.sh	r0,r0[0x0]
8000201a:	1f f6       	ld.ub	r6,pc[0x7]
8000201c:	c5 4c       	rcall	800020c4 <frame_dummy>
8000201e:	e0 a0 27 27 	rcall	80006e6c <__do_global_ctors_aux>
80002022:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002028 <_stext>:
80002028:	30 07       	mov	r7,0
8000202a:	e0 7a 00 00 	mov	r10,65536
8000202e:	5b fa       	cp.w	r10,-1
80002030:	f4 0d 17 10 	movne	sp,r10
80002034:	fe cb ac 9c 	sub	r11,pc,-21348
80002038:	30 8c       	mov	r12,8
8000203a:	18 3b       	cp.w	r11,r12
8000203c:	c0 70       	breq	8000204a <_stext+0x22>
8000203e:	e0 6a 05 30 	mov	r10,1328
80002042:	b7 09       	ld.d	r8,r11++
80002044:	b9 28       	st.d	r12++,r8
80002046:	14 3c       	cp.w	r12,r10
80002048:	cf d5       	brlt	80002042 <_stext+0x1a>
8000204a:	e0 6a 07 f0 	mov	r10,2032
8000204e:	e0 6c 05 30 	mov	r12,1328
80002052:	30 08       	mov	r8,0
80002054:	30 09       	mov	r9,0
80002056:	b9 28       	st.d	r12++,r8
80002058:	14 3c       	cp.w	r12,r10
8000205a:	cf e5       	brlt	80002056 <_stext+0x2e>
8000205c:	e0 a0 13 ea 	rcall	80004830 <_init_startup>
80002060:	fe cc ae 60 	sub	r12,pc,-20896
80002064:	e0 a0 21 fa 	rcall	80006458 <atexit>
80002068:	cd 2f       	rcall	8000200c <_init>
8000206a:	1a 9c       	mov	r12,sp
8000206c:	30 0b       	mov	r11,0
8000206e:	e0 a0 25 0d 	rcall	80006a88 <_init_argv>
80002072:	5b fc       	cp.w	r12,-1
80002074:	f9 bc 00 00 	moveq	r12,0
80002078:	f9 ba 00 00 	moveq	r10,0
8000207c:	14 1d       	sub	sp,r10
8000207e:	e0 a0 0d 91 	rcall	80003ba0 <main>
80002082:	e0 a0 21 f3 	rcall	80006468 <exit>
80002086:	d7 03       	nop

80002088 <__do_global_dtors_aux>:
80002088:	d4 21       	pushm	r4-r7,lr
8000208a:	e0 68 05 44 	mov	r8,1348
8000208e:	11 89       	ld.ub	r9,r8[0x0]
80002090:	30 08       	mov	r8,0
80002092:	f0 09 18 00 	cp.b	r9,r8
80002096:	c1 61       	brne	800020c2 <__do_global_dtors_aux+0x3a>
80002098:	31 08       	mov	r8,16
8000209a:	31 46       	mov	r6,20
8000209c:	10 95       	mov	r5,r8
8000209e:	10 16       	sub	r6,r8
800020a0:	e0 67 05 48 	mov	r7,1352
800020a4:	a3 46       	asr	r6,0x2
800020a6:	20 16       	sub	r6,1
800020a8:	c0 68       	rjmp	800020b4 <__do_global_dtors_aux+0x2c>
800020aa:	2f f8       	sub	r8,-1
800020ac:	8f 08       	st.w	r7[0x0],r8
800020ae:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020b2:	5d 18       	icall	r8
800020b4:	6e 08       	ld.w	r8,r7[0x0]
800020b6:	0c 38       	cp.w	r8,r6
800020b8:	cf 93       	brcs	800020aa <__do_global_dtors_aux+0x22>
800020ba:	30 19       	mov	r9,1
800020bc:	e0 68 05 44 	mov	r8,1348
800020c0:	b0 89       	st.b	r8[0x0],r9
800020c2:	d8 22       	popm	r4-r7,pc

800020c4 <frame_dummy>:
800020c4:	d4 01       	pushm	lr
800020c6:	31 8c       	mov	r12,24
800020c8:	78 08       	ld.w	r8,r12[0x0]
800020ca:	58 08       	cp.w	r8,0
800020cc:	c0 50       	breq	800020d6 <frame_dummy+0x12>
800020ce:	48 38       	lddpc	r8,800020d8 <frame_dummy+0x14>
800020d0:	58 08       	cp.w	r8,0
800020d2:	c0 20       	breq	800020d6 <frame_dummy+0x12>
800020d4:	5d 18       	icall	r8
800020d6:	d8 02       	popm	pc
800020d8:	00 00       	add	r0,r0
	...

800020dc <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern bool sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
800020dc:	eb cd 40 80 	pushm	r7,lr
800020e0:	1a 97       	mov	r7,sp
	}
#endif

	switch (CONFIG_SYSCLK_SOURCE) {
	case SYSCLK_SRC_RCSYS:
		return OSC_SLOW_NOMINAL_HZ;
800020e2:	e0 78 c2 00 	mov	r8,115200

	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
800020e6:	10 9c       	mov	r12,r8
800020e8:	e3 cd 80 80 	ldm	sp++,r7,pc

800020ec <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
800020ec:	eb cd 40 80 	pushm	r7,lr
800020f0:	1a 97       	mov	r7,sp
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_CPU_DIV;
800020f2:	f0 1f 00 04 	mcall	80002100 <sysclk_get_cpu_hz+0x14>
800020f6:	18 98       	mov	r8,r12
}
800020f8:	10 9c       	mov	r12,r8
800020fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800020fe:	00 00       	add	r0,r0
80002100:	80 00       	ld.sh	r0,r0[0x0]
80002102:	20 dc       	sub	r12,13

80002104 <dip204_init>:


/****************************** global functions *****************************/

void dip204_init(backlight_options option, bool backlight_on)
{
80002104:	eb cd 40 8f 	pushm	r0-r3,r7,lr
80002108:	1a 97       	mov	r7,sp
8000210a:	fa cd 01 ac 	sub	sp,sp,428
8000210e:	ef 4c fe b8 	st.w	r7[-328],r12
80002112:	16 98       	mov	r8,r11
80002114:	ef 68 fe b4 	st.b	r7[-332],r8
  pwm_opt_t pwm_opt;  // pwm option config

  if (option == backlight_PWM)
80002118:	ee f8 fe b8 	ld.w	r8,r7[-328]
8000211c:	58 18       	cp.w	r8,1
8000211e:	c6 41       	brne	800021e6 <dip204_init+0xe2>
  {
    channel_id = DIP204_PWM_CHANNEL;
80002120:	fe f9 0a 84 	ld.w	r9,pc[2692]
80002124:	30 68       	mov	r8,6
80002126:	93 08       	st.w	r9[0x0],r8
    gpio_enable_module_pin(DIP204_PWM_PIN, DIP204_PWM_FUNCTION);
80002128:	30 2b       	mov	r11,2
8000212a:	33 2c       	mov	r12,50
8000212c:	f0 1f 02 9f 	mcall	80002ba8 <dip204_init+0xaa4>

    // PWM controller configuration
    pwm_opt.diva=0;
80002130:	30 08       	mov	r8,0
80002132:	ef 48 ff 14 	st.w	r7[-236],r8
    pwm_opt.divb=0;
80002136:	30 08       	mov	r8,0
80002138:	ef 48 ff 10 	st.w	r7[-240],r8
    pwm_opt.prea=0;
8000213c:	30 08       	mov	r8,0
8000213e:	ef 48 ff 1c 	st.w	r7[-228],r8
    pwm_opt.preb=0;
80002142:	30 08       	mov	r8,0
80002144:	ef 48 ff 18 	st.w	r7[-232],r8

    pwm_init(&pwm_opt);
80002148:	ee c8 00 f0 	sub	r8,r7,240
8000214c:	10 9c       	mov	r12,r8
8000214e:	f0 1f 02 98 	mcall	80002bac <dip204_init+0xaa8>
    pwm_duty = (backlight_on) ? DIP204_PERIOD_MAX - 1 : 1;
80002152:	ef 39 fe b4 	ld.ub	r9,r7[-332]
80002156:	30 08       	mov	r8,0
80002158:	f0 09 18 00 	cp.b	r9,r8
8000215c:	c0 30       	breq	80002162 <dip204_init+0x5e>
8000215e:	33 18       	mov	r8,49
80002160:	c0 28       	rjmp	80002164 <dip204_init+0x60>
80002162:	30 18       	mov	r8,1
80002164:	fe f9 0a 4c 	ld.w	r9,pc[2636]
80002168:	b2 08       	st.h	r9[0x0],r8
    pwm_channel.CMR.calg = PWM_MODE_LEFT_ALIGNED;   // channel mode
8000216a:	fe fa 0a 4a 	ld.w	r10,pc[2634]
8000216e:	74 08       	ld.w	r8,r10[0x0]
80002170:	30 09       	mov	r9,0
80002172:	f1 d9 d1 01 	bfins	r8,r9,0x8,0x1
80002176:	95 08       	st.w	r10[0x0],r8
    pwm_channel.CMR.cpol = PWM_POLARITY_LOW;   // channel polarity
80002178:	fe fa 0a 3c 	ld.w	r10,pc[2620]
8000217c:	74 08       	ld.w	r8,r10[0x0]
8000217e:	30 09       	mov	r9,0
80002180:	f1 d9 d1 21 	bfins	r8,r9,0x9,0x1
80002184:	95 08       	st.w	r10[0x0],r8
    pwm_channel.CMR.cpd = PWM_UPDATE_PERIOD;   // not used the first time
80002186:	fe fa 0a 2e 	ld.w	r10,pc[2606]
8000218a:	74 08       	ld.w	r8,r10[0x0]
8000218c:	30 19       	mov	r9,1
8000218e:	f1 d9 d1 41 	bfins	r8,r9,0xa,0x1
80002192:	95 08       	st.w	r10[0x0],r8
    pwm_channel.CMR.cpre = AVR32_PWM_CPRE_MCK_DIV_256;   // channel prescaler
80002194:	fe fa 0a 20 	ld.w	r10,pc[2592]
80002198:	74 08       	ld.w	r8,r10[0x0]
8000219a:	30 89       	mov	r9,8
8000219c:	f1 d9 d0 04 	bfins	r8,r9,0x0,0x4
800021a0:	95 08       	st.w	r10[0x0],r8
    pwm_channel.cdty = pwm_duty;  // channel duty cycle, should be < CPRD
800021a2:	fe f8 0a 0e 	ld.w	r8,pc[2574]
800021a6:	90 08       	ld.sh	r8,r8[0x0]
800021a8:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800021ac:	fe f8 0a 08 	ld.w	r8,pc[2568]
800021b0:	91 19       	st.w	r8[0x4],r9
    pwm_channel.cprd = DIP204_PERIOD_MAX;  // channel period
800021b2:	fe f9 0a 02 	ld.w	r9,pc[2562]
800021b6:	33 28       	mov	r8,50
800021b8:	93 28       	st.w	r9[0x8],r8
    pwm_channel.cupd = 0;  // channel update is not used here.
800021ba:	fe f9 09 fa 	ld.w	r9,pc[2554]
800021be:	30 08       	mov	r8,0
800021c0:	93 48       	st.w	r9[0x10],r8

    pwm_channel_init(channel_id, &pwm_channel);
800021c2:	fe f8 09 e2 	ld.w	r8,pc[2530]
800021c6:	70 08       	ld.w	r8,r8[0x0]
800021c8:	fe fb 09 ec 	ld.w	r11,pc[2540]
800021cc:	10 9c       	mov	r12,r8
800021ce:	f0 1f 02 7b 	mcall	80002bb8 <dip204_init+0xab4>
    // start PWM
    pwm_start_channels(1 << channel_id);
800021d2:	fe f8 09 d2 	ld.w	r8,pc[2514]
800021d6:	70 09       	ld.w	r9,r8[0x0]
800021d8:	30 18       	mov	r8,1
800021da:	f0 09 09 48 	lsl	r8,r8,r9
800021de:	10 9c       	mov	r12,r8
800021e0:	f0 1f 02 77 	mcall	80002bbc <dip204_init+0xab8>
800021e4:	c0 e8       	rjmp	80002200 <dip204_init+0xfc>
  }
  else
  {
    if (backlight_on)
800021e6:	ef 39 fe b4 	ld.ub	r9,r7[-332]
800021ea:	30 08       	mov	r8,0
800021ec:	f0 09 18 00 	cp.b	r9,r8
800021f0:	c0 50       	breq	800021fa <dip204_init+0xf6>
    {
      gpio_clr_gpio_pin(DIP204_BACKLIGHT_PIN);
800021f2:	33 2c       	mov	r12,50
800021f4:	f0 1f 02 73 	mcall	80002bc0 <dip204_init+0xabc>
800021f8:	c0 48       	rjmp	80002200 <dip204_init+0xfc>
    }
    else
    {
      gpio_set_gpio_pin(DIP204_BACKLIGHT_PIN);
800021fa:	33 2c       	mov	r12,50
800021fc:	f0 1f 02 72 	mcall	80002bc4 <dip204_init+0xac0>
    }
  }
  // delay for power on
  delay_ms(20);
80002200:	f0 1f 02 72 	mcall	80002bc8 <dip204_init+0xac4>
80002204:	18 99       	mov	r9,r12
80002206:	31 48       	mov	r8,20
80002208:	ef 48 ff 24 	st.w	r7[-220],r8
8000220c:	ef 49 ff 20 	st.w	r7[-224],r9
80002210:	ee f8 ff 24 	ld.w	r8,r7[-220]
80002214:	ef 48 ff 2c 	st.w	r7[-212],r8
80002218:	ee f8 ff 20 	ld.w	r8,r7[-224]
8000221c:	ef 48 ff 28 	st.w	r7[-216],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002220:	ee f0 ff 2c 	ld.w	r0,r7[-212]
80002224:	30 01       	mov	r1,0
80002226:	ee f2 ff 28 	ld.w	r2,r7[-216]
8000222a:	30 03       	mov	r3,0
8000222c:	e2 02 02 49 	mul	r9,r1,r2
80002230:	e6 00 02 48 	mul	r8,r3,r0
80002234:	10 09       	add	r9,r8
80002236:	e0 02 06 4a 	mulu.d	r10,r0,r2
8000223a:	16 09       	add	r9,r11
8000223c:	12 9b       	mov	r11,r9
8000223e:	e0 68 03 e7 	mov	r8,999
80002242:	30 09       	mov	r9,0
80002244:	10 0a       	add	r10,r8
80002246:	f6 09 00 4b 	adc	r11,r11,r9
8000224a:	e0 68 03 e8 	mov	r8,1000
8000224e:	30 09       	mov	r9,0
80002250:	f0 1f 02 5f 	mcall	80002bcc <dip204_init+0xac8>
80002254:	14 98       	mov	r8,r10
80002256:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002258:	ef 48 ff 34 	st.w	r7[-204],r8
8000225c:	ee c8 01 44 	sub	r8,r7,324
80002260:	ef 48 ff 30 	st.w	r7[-208],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002264:	e1 b8 00 42 	mfsr	r8,0x108
80002268:	10 99       	mov	r9,r8
8000226a:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000226e:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002270:	ee f8 ff 30 	ld.w	r8,r7[-208]
80002274:	70 09       	ld.w	r9,r8[0x0]
80002276:	ee f8 ff 34 	ld.w	r8,r7[-204]
8000227a:	10 09       	add	r9,r8
8000227c:	ee f8 ff 30 	ld.w	r8,r7[-208]
80002280:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002282:	ee f9 ff 30 	ld.w	r9,r7[-208]
80002286:	30 08       	mov	r8,0
80002288:	f3 68 00 08 	st.b	r9[8],r8
8000228c:	ee c8 01 44 	sub	r8,r7,324
80002290:	ef 48 ff 38 	st.w	r7[-200],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002294:	e1 b8 00 42 	mfsr	r8,0x108
80002298:	ef 48 ff 3c 	st.w	r7[-196],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000229c:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022a0:	f1 39 00 08 	ld.ub	r9,r8[8]
800022a4:	30 28       	mov	r8,2
800022a6:	f0 09 18 00 	cp.b	r9,r8
800022aa:	c0 31       	brne	800022b0 <dip204_init+0x1ac>
    return false;
800022ac:	30 08       	mov	r8,0
800022ae:	c4 38       	rjmp	80002334 <dip204_init+0x230>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800022b0:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022b4:	f1 39 00 08 	ld.ub	r9,r8[8]
800022b8:	30 18       	mov	r8,1
800022ba:	f0 09 18 00 	cp.b	r9,r8
800022be:	c0 31       	brne	800022c4 <dip204_init+0x1c0>
    return true;
800022c0:	30 18       	mov	r8,1
800022c2:	c3 98       	rjmp	80002334 <dip204_init+0x230>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800022c4:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022c8:	70 09       	ld.w	r9,r8[0x0]
800022ca:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022ce:	70 18       	ld.w	r8,r8[0x4]
800022d0:	10 39       	cp.w	r9,r8
800022d2:	e0 88 00 1a 	brls	80002306 <dip204_init+0x202>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800022d6:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022da:	70 09       	ld.w	r9,r8[0x0]
800022dc:	ee f8 ff 3c 	ld.w	r8,r7[-196]
800022e0:	12 38       	cp.w	r8,r9
800022e2:	c1 02       	brcc	80002302 <dip204_init+0x1fe>
800022e4:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022e8:	70 19       	ld.w	r9,r8[0x4]
800022ea:	ee f8 ff 3c 	ld.w	r8,r7[-196]
800022ee:	12 38       	cp.w	r8,r9
800022f0:	e0 88 00 09 	brls	80002302 <dip204_init+0x1fe>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800022f4:	ee f9 ff 38 	ld.w	r9,r7[-200]
800022f8:	30 18       	mov	r8,1
800022fa:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800022fe:	30 18       	mov	r8,1
80002300:	c1 a8       	rjmp	80002334 <dip204_init+0x230>
    }
    return false;
80002302:	30 08       	mov	r8,0
80002304:	c1 88       	rjmp	80002334 <dip204_init+0x230>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002306:	ee f8 ff 38 	ld.w	r8,r7[-200]
8000230a:	70 09       	ld.w	r9,r8[0x0]
8000230c:	ee f8 ff 3c 	ld.w	r8,r7[-196]
80002310:	12 38       	cp.w	r8,r9
80002312:	c0 93       	brcs	80002324 <dip204_init+0x220>
80002314:	ee f8 ff 38 	ld.w	r8,r7[-200]
80002318:	70 19       	ld.w	r9,r8[0x4]
8000231a:	ee f8 ff 3c 	ld.w	r8,r7[-196]
8000231e:	12 38       	cp.w	r8,r9
80002320:	e0 88 00 09 	brls	80002332 <dip204_init+0x22e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002324:	ee f9 ff 38 	ld.w	r9,r7[-200]
80002328:	30 18       	mov	r8,1
8000232a:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000232e:	30 18       	mov	r8,1
80002330:	c0 28       	rjmp	80002334 <dip204_init+0x230>
    }
    return false;
80002332:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002334:	58 08       	cp.w	r8,0
80002336:	ca b0       	breq	8000228c <dip204_init+0x188>
  // select the LCD chip
  dip204_select();
80002338:	f0 1f 02 26 	mcall	80002bd0 <dip204_init+0xacc>
  // Send Command Start Byte
  dip204_write_byte(DIP204_WRITE_COMMAND);
8000233c:	e0 6c 00 f8 	mov	r12,248
80002340:	f0 1f 02 25 	mcall	80002bd4 <dip204_init+0xad0>
  // Send "extended Function Set" Command  (RE=1)
  dip204_write_byte(0x34);
80002344:	33 4c       	mov	r12,52
80002346:	f0 1f 02 24 	mcall	80002bd4 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
8000234a:	f0 1f 02 20 	mcall	80002bc8 <dip204_init+0xac4>
8000234e:	18 99       	mov	r9,r12
80002350:	30 18       	mov	r8,1
80002352:	ef 48 ff 44 	st.w	r7[-188],r8
80002356:	ef 49 ff 40 	st.w	r7[-192],r9
8000235a:	ee f8 ff 44 	ld.w	r8,r7[-188]
8000235e:	ef 48 ff 4c 	st.w	r7[-180],r8
80002362:	ee f8 ff 40 	ld.w	r8,r7[-192]
80002366:	ef 48 ff 48 	st.w	r7[-184],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000236a:	ee fc ff 4c 	ld.w	r12,r7[-180]
8000236e:	ef 4c fe 60 	st.w	r7[-416],r12
80002372:	30 0b       	mov	r11,0
80002374:	ef 4b fe 5c 	st.w	r7[-420],r11
80002378:	ee fa ff 48 	ld.w	r10,r7[-184]
8000237c:	ef 4a fe 58 	st.w	r7[-424],r10
80002380:	30 09       	mov	r9,0
80002382:	ef 49 fe 54 	st.w	r7[-428],r9
80002386:	ee f9 fe 5c 	ld.w	r9,r7[-420]
8000238a:	ee f8 fe 58 	ld.w	r8,r7[-424]
8000238e:	b1 39       	mul	r9,r8
80002390:	ee f8 fe 54 	ld.w	r8,r7[-428]
80002394:	ee fc fe 60 	ld.w	r12,r7[-416]
80002398:	b9 38       	mul	r8,r12
8000239a:	10 09       	add	r9,r8
8000239c:	ee f8 fe 60 	ld.w	r8,r7[-416]
800023a0:	ee fc fe 58 	ld.w	r12,r7[-424]
800023a4:	f0 0c 06 4a 	mulu.d	r10,r8,r12
800023a8:	16 09       	add	r9,r11
800023aa:	12 9b       	mov	r11,r9
800023ac:	e0 68 03 e7 	mov	r8,999
800023b0:	30 09       	mov	r9,0
800023b2:	10 0a       	add	r10,r8
800023b4:	f6 09 00 4b 	adc	r11,r11,r9
800023b8:	e0 68 03 e8 	mov	r8,1000
800023bc:	30 09       	mov	r9,0
800023be:	f0 1f 02 04 	mcall	80002bcc <dip204_init+0xac8>
800023c2:	14 98       	mov	r8,r10
800023c4:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
800023c6:	ef 48 ff 54 	st.w	r7[-172],r8
800023ca:	ee c8 01 38 	sub	r8,r7,312
800023ce:	ef 48 ff 50 	st.w	r7[-176],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800023d2:	e1 b8 00 42 	mfsr	r8,0x108
800023d6:	10 99       	mov	r9,r8
800023d8:	ee f8 ff 50 	ld.w	r8,r7[-176]
800023dc:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800023de:	ee f8 ff 50 	ld.w	r8,r7[-176]
800023e2:	70 09       	ld.w	r9,r8[0x0]
800023e4:	ee f8 ff 54 	ld.w	r8,r7[-172]
800023e8:	10 09       	add	r9,r8
800023ea:	ee f8 ff 50 	ld.w	r8,r7[-176]
800023ee:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800023f0:	ee f9 ff 50 	ld.w	r9,r7[-176]
800023f4:	30 08       	mov	r8,0
800023f6:	f3 68 00 08 	st.b	r9[8],r8
800023fa:	ee c8 01 38 	sub	r8,r7,312
800023fe:	ef 48 ff 58 	st.w	r7[-168],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002402:	e1 b8 00 42 	mfsr	r8,0x108
80002406:	ef 48 ff 5c 	st.w	r7[-164],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000240a:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000240e:	f1 39 00 08 	ld.ub	r9,r8[8]
80002412:	30 28       	mov	r8,2
80002414:	f0 09 18 00 	cp.b	r9,r8
80002418:	c0 31       	brne	8000241e <dip204_init+0x31a>
    return false;
8000241a:	30 08       	mov	r8,0
8000241c:	c4 38       	rjmp	800024a2 <dip204_init+0x39e>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
8000241e:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002422:	f1 39 00 08 	ld.ub	r9,r8[8]
80002426:	30 18       	mov	r8,1
80002428:	f0 09 18 00 	cp.b	r9,r8
8000242c:	c0 31       	brne	80002432 <dip204_init+0x32e>
    return true;
8000242e:	30 18       	mov	r8,1
80002430:	c3 98       	rjmp	800024a2 <dip204_init+0x39e>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002432:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002436:	70 09       	ld.w	r9,r8[0x0]
80002438:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000243c:	70 18       	ld.w	r8,r8[0x4]
8000243e:	10 39       	cp.w	r9,r8
80002440:	e0 88 00 1a 	brls	80002474 <dip204_init+0x370>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002444:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002448:	70 09       	ld.w	r9,r8[0x0]
8000244a:	ee f8 ff 5c 	ld.w	r8,r7[-164]
8000244e:	12 38       	cp.w	r8,r9
80002450:	c1 02       	brcc	80002470 <dip204_init+0x36c>
80002452:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002456:	70 19       	ld.w	r9,r8[0x4]
80002458:	ee f8 ff 5c 	ld.w	r8,r7[-164]
8000245c:	12 38       	cp.w	r8,r9
8000245e:	e0 88 00 09 	brls	80002470 <dip204_init+0x36c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002462:	ee f9 ff 58 	ld.w	r9,r7[-168]
80002466:	30 18       	mov	r8,1
80002468:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000246c:	30 18       	mov	r8,1
8000246e:	c1 a8       	rjmp	800024a2 <dip204_init+0x39e>
    }
    return false;
80002470:	30 08       	mov	r8,0
80002472:	c1 88       	rjmp	800024a2 <dip204_init+0x39e>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002474:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002478:	70 09       	ld.w	r9,r8[0x0]
8000247a:	ee f8 ff 5c 	ld.w	r8,r7[-164]
8000247e:	12 38       	cp.w	r8,r9
80002480:	c0 93       	brcs	80002492 <dip204_init+0x38e>
80002482:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002486:	70 19       	ld.w	r9,r8[0x4]
80002488:	ee f8 ff 5c 	ld.w	r8,r7[-164]
8000248c:	12 38       	cp.w	r8,r9
8000248e:	e0 88 00 09 	brls	800024a0 <dip204_init+0x39c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002492:	ee f9 ff 58 	ld.w	r9,r7[-168]
80002496:	30 18       	mov	r8,1
80002498:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000249c:	30 18       	mov	r8,1
8000249e:	c0 28       	rjmp	800024a2 <dip204_init+0x39e>
    }
    return false;
800024a0:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800024a2:	58 08       	cp.w	r8,0
800024a4:	ca b0       	breq	800023fa <dip204_init+0x2f6>
  // Send "Enter 4-Line Mode" Command
  dip204_write_byte(0x09);
800024a6:	30 9c       	mov	r12,9
800024a8:	f0 1f 01 cb 	mcall	80002bd4 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
800024ac:	f0 1f 01 c7 	mcall	80002bc8 <dip204_init+0xac4>
800024b0:	18 99       	mov	r9,r12
800024b2:	30 18       	mov	r8,1
800024b4:	ef 48 ff 64 	st.w	r7[-156],r8
800024b8:	ef 49 ff 60 	st.w	r7[-160],r9
800024bc:	ee f8 ff 64 	ld.w	r8,r7[-156]
800024c0:	ef 48 ff 6c 	st.w	r7[-148],r8
800024c4:	ee f8 ff 60 	ld.w	r8,r7[-160]
800024c8:	ef 48 ff 68 	st.w	r7[-152],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800024cc:	ee fb ff 6c 	ld.w	r11,r7[-148]
800024d0:	ef 4b fe 70 	st.w	r7[-400],r11
800024d4:	30 0a       	mov	r10,0
800024d6:	ef 4a fe 6c 	st.w	r7[-404],r10
800024da:	ee f9 ff 68 	ld.w	r9,r7[-152]
800024de:	ef 49 fe 68 	st.w	r7[-408],r9
800024e2:	30 08       	mov	r8,0
800024e4:	ef 48 fe 64 	st.w	r7[-412],r8
800024e8:	ee f9 fe 6c 	ld.w	r9,r7[-404]
800024ec:	ee fc fe 68 	ld.w	r12,r7[-408]
800024f0:	b9 39       	mul	r9,r12
800024f2:	ee f8 fe 64 	ld.w	r8,r7[-412]
800024f6:	ee fb fe 70 	ld.w	r11,r7[-400]
800024fa:	b7 38       	mul	r8,r11
800024fc:	10 09       	add	r9,r8
800024fe:	ee f8 fe 70 	ld.w	r8,r7[-400]
80002502:	ee fc fe 68 	ld.w	r12,r7[-408]
80002506:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000250a:	16 09       	add	r9,r11
8000250c:	12 9b       	mov	r11,r9
8000250e:	e0 68 03 e7 	mov	r8,999
80002512:	30 09       	mov	r9,0
80002514:	10 0a       	add	r10,r8
80002516:	f6 09 00 4b 	adc	r11,r11,r9
8000251a:	e0 68 03 e8 	mov	r8,1000
8000251e:	30 09       	mov	r9,0
80002520:	f0 1f 01 ab 	mcall	80002bcc <dip204_init+0xac8>
80002524:	14 98       	mov	r8,r10
80002526:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002528:	ef 48 ff 74 	st.w	r7[-140],r8
8000252c:	ee c8 01 2c 	sub	r8,r7,300
80002530:	ef 48 ff 70 	st.w	r7[-144],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002534:	e1 b8 00 42 	mfsr	r8,0x108
80002538:	10 99       	mov	r9,r8
8000253a:	ee f8 ff 70 	ld.w	r8,r7[-144]
8000253e:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002540:	ee f8 ff 70 	ld.w	r8,r7[-144]
80002544:	70 09       	ld.w	r9,r8[0x0]
80002546:	ee f8 ff 74 	ld.w	r8,r7[-140]
8000254a:	10 09       	add	r9,r8
8000254c:	ee f8 ff 70 	ld.w	r8,r7[-144]
80002550:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002552:	ee f9 ff 70 	ld.w	r9,r7[-144]
80002556:	30 08       	mov	r8,0
80002558:	f3 68 00 08 	st.b	r9[8],r8
8000255c:	ee c8 01 2c 	sub	r8,r7,300
80002560:	ef 48 ff 78 	st.w	r7[-136],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002564:	e1 b8 00 42 	mfsr	r8,0x108
80002568:	ef 48 ff 7c 	st.w	r7[-132],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000256c:	ee f8 ff 78 	ld.w	r8,r7[-136]
80002570:	f1 39 00 08 	ld.ub	r9,r8[8]
80002574:	30 28       	mov	r8,2
80002576:	f0 09 18 00 	cp.b	r9,r8
8000257a:	c0 31       	brne	80002580 <dip204_init+0x47c>
    return false;
8000257c:	30 08       	mov	r8,0
8000257e:	c4 38       	rjmp	80002604 <dip204_init+0x500>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002580:	ee f8 ff 78 	ld.w	r8,r7[-136]
80002584:	f1 39 00 08 	ld.ub	r9,r8[8]
80002588:	30 18       	mov	r8,1
8000258a:	f0 09 18 00 	cp.b	r9,r8
8000258e:	c0 31       	brne	80002594 <dip204_init+0x490>
    return true;
80002590:	30 18       	mov	r8,1
80002592:	c3 98       	rjmp	80002604 <dip204_init+0x500>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002594:	ee f8 ff 78 	ld.w	r8,r7[-136]
80002598:	70 09       	ld.w	r9,r8[0x0]
8000259a:	ee f8 ff 78 	ld.w	r8,r7[-136]
8000259e:	70 18       	ld.w	r8,r8[0x4]
800025a0:	10 39       	cp.w	r9,r8
800025a2:	e0 88 00 1a 	brls	800025d6 <dip204_init+0x4d2>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800025a6:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025aa:	70 09       	ld.w	r9,r8[0x0]
800025ac:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025b0:	12 38       	cp.w	r8,r9
800025b2:	c1 02       	brcc	800025d2 <dip204_init+0x4ce>
800025b4:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025b8:	70 19       	ld.w	r9,r8[0x4]
800025ba:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025be:	12 38       	cp.w	r8,r9
800025c0:	e0 88 00 09 	brls	800025d2 <dip204_init+0x4ce>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800025c4:	ee f9 ff 78 	ld.w	r9,r7[-136]
800025c8:	30 18       	mov	r8,1
800025ca:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800025ce:	30 18       	mov	r8,1
800025d0:	c1 a8       	rjmp	80002604 <dip204_init+0x500>
    }
    return false;
800025d2:	30 08       	mov	r8,0
800025d4:	c1 88       	rjmp	80002604 <dip204_init+0x500>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800025d6:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025da:	70 09       	ld.w	r9,r8[0x0]
800025dc:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025e0:	12 38       	cp.w	r8,r9
800025e2:	c0 93       	brcs	800025f4 <dip204_init+0x4f0>
800025e4:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025e8:	70 19       	ld.w	r9,r8[0x4]
800025ea:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025ee:	12 38       	cp.w	r8,r9
800025f0:	e0 88 00 09 	brls	80002602 <dip204_init+0x4fe>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800025f4:	ee f9 ff 78 	ld.w	r9,r7[-136]
800025f8:	30 18       	mov	r8,1
800025fa:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800025fe:	30 18       	mov	r8,1
80002600:	c0 28       	rjmp	80002604 <dip204_init+0x500>
    }
    return false;
80002602:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002604:	58 08       	cp.w	r8,0
80002606:	ca b0       	breq	8000255c <dip204_init+0x458>
  // Send "Function Set" Command (RE=0)
  dip204_write_byte(0x30);
80002608:	33 0c       	mov	r12,48
8000260a:	f0 1f 01 73 	mcall	80002bd4 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
8000260e:	f0 1f 01 6f 	mcall	80002bc8 <dip204_init+0xac4>
80002612:	18 99       	mov	r9,r12
80002614:	30 18       	mov	r8,1
80002616:	ef 48 ff 84 	st.w	r7[-124],r8
8000261a:	ef 49 ff 80 	st.w	r7[-128],r9
8000261e:	ee f8 ff 84 	ld.w	r8,r7[-124]
80002622:	ef 48 ff 8c 	st.w	r7[-116],r8
80002626:	ee f8 ff 80 	ld.w	r8,r7[-128]
8000262a:	ef 48 ff 88 	st.w	r7[-120],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000262e:	ee fb ff 8c 	ld.w	r11,r7[-116]
80002632:	ef 4b fe 80 	st.w	r7[-384],r11
80002636:	30 0a       	mov	r10,0
80002638:	ef 4a fe 7c 	st.w	r7[-388],r10
8000263c:	ee f9 ff 88 	ld.w	r9,r7[-120]
80002640:	ef 49 fe 78 	st.w	r7[-392],r9
80002644:	30 08       	mov	r8,0
80002646:	ef 48 fe 74 	st.w	r7[-396],r8
8000264a:	ee f9 fe 7c 	ld.w	r9,r7[-388]
8000264e:	ee fc fe 78 	ld.w	r12,r7[-392]
80002652:	b9 39       	mul	r9,r12
80002654:	ee f8 fe 74 	ld.w	r8,r7[-396]
80002658:	ee fb fe 80 	ld.w	r11,r7[-384]
8000265c:	b7 38       	mul	r8,r11
8000265e:	10 09       	add	r9,r8
80002660:	ee f8 fe 80 	ld.w	r8,r7[-384]
80002664:	ee fc fe 78 	ld.w	r12,r7[-392]
80002668:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000266c:	16 09       	add	r9,r11
8000266e:	12 9b       	mov	r11,r9
80002670:	e0 68 03 e7 	mov	r8,999
80002674:	30 09       	mov	r9,0
80002676:	10 0a       	add	r10,r8
80002678:	f6 09 00 4b 	adc	r11,r11,r9
8000267c:	e0 68 03 e8 	mov	r8,1000
80002680:	30 09       	mov	r9,0
80002682:	f0 1f 01 53 	mcall	80002bcc <dip204_init+0xac8>
80002686:	14 98       	mov	r8,r10
80002688:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000268a:	ef 48 ff 94 	st.w	r7[-108],r8
8000268e:	ee c8 01 20 	sub	r8,r7,288
80002692:	ef 48 ff 90 	st.w	r7[-112],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002696:	e1 b8 00 42 	mfsr	r8,0x108
8000269a:	10 99       	mov	r9,r8
8000269c:	ee f8 ff 90 	ld.w	r8,r7[-112]
800026a0:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800026a2:	ee f8 ff 90 	ld.w	r8,r7[-112]
800026a6:	70 09       	ld.w	r9,r8[0x0]
800026a8:	ee f8 ff 94 	ld.w	r8,r7[-108]
800026ac:	10 09       	add	r9,r8
800026ae:	ee f8 ff 90 	ld.w	r8,r7[-112]
800026b2:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800026b4:	ee f9 ff 90 	ld.w	r9,r7[-112]
800026b8:	30 08       	mov	r8,0
800026ba:	f3 68 00 08 	st.b	r9[8],r8
800026be:	ee c8 01 20 	sub	r8,r7,288
800026c2:	ef 48 ff 98 	st.w	r7[-104],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800026c6:	e1 b8 00 42 	mfsr	r8,0x108
800026ca:	ef 48 ff 9c 	st.w	r7[-100],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800026ce:	ee f8 ff 98 	ld.w	r8,r7[-104]
800026d2:	f1 39 00 08 	ld.ub	r9,r8[8]
800026d6:	30 28       	mov	r8,2
800026d8:	f0 09 18 00 	cp.b	r9,r8
800026dc:	c0 31       	brne	800026e2 <dip204_init+0x5de>
    return false;
800026de:	30 08       	mov	r8,0
800026e0:	c4 38       	rjmp	80002766 <dip204_init+0x662>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800026e2:	ee f8 ff 98 	ld.w	r8,r7[-104]
800026e6:	f1 39 00 08 	ld.ub	r9,r8[8]
800026ea:	30 18       	mov	r8,1
800026ec:	f0 09 18 00 	cp.b	r9,r8
800026f0:	c0 31       	brne	800026f6 <dip204_init+0x5f2>
    return true;
800026f2:	30 18       	mov	r8,1
800026f4:	c3 98       	rjmp	80002766 <dip204_init+0x662>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800026f6:	ee f8 ff 98 	ld.w	r8,r7[-104]
800026fa:	70 09       	ld.w	r9,r8[0x0]
800026fc:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002700:	70 18       	ld.w	r8,r8[0x4]
80002702:	10 39       	cp.w	r9,r8
80002704:	e0 88 00 1a 	brls	80002738 <dip204_init+0x634>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002708:	ee f8 ff 98 	ld.w	r8,r7[-104]
8000270c:	70 08       	ld.w	r8,r8[0x0]
8000270e:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002712:	10 39       	cp.w	r9,r8
80002714:	c1 02       	brcc	80002734 <dip204_init+0x630>
80002716:	ee f8 ff 98 	ld.w	r8,r7[-104]
8000271a:	70 18       	ld.w	r8,r8[0x4]
8000271c:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002720:	10 39       	cp.w	r9,r8
80002722:	e0 88 00 09 	brls	80002734 <dip204_init+0x630>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002726:	ee f9 ff 98 	ld.w	r9,r7[-104]
8000272a:	30 18       	mov	r8,1
8000272c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002730:	30 18       	mov	r8,1
80002732:	c1 a8       	rjmp	80002766 <dip204_init+0x662>
    }
    return false;
80002734:	30 08       	mov	r8,0
80002736:	c1 88       	rjmp	80002766 <dip204_init+0x662>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002738:	ee f8 ff 98 	ld.w	r8,r7[-104]
8000273c:	70 08       	ld.w	r8,r8[0x0]
8000273e:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002742:	10 39       	cp.w	r9,r8
80002744:	c0 93       	brcs	80002756 <dip204_init+0x652>
80002746:	ee f8 ff 98 	ld.w	r8,r7[-104]
8000274a:	70 18       	ld.w	r8,r8[0x4]
8000274c:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002750:	10 39       	cp.w	r9,r8
80002752:	e0 88 00 09 	brls	80002764 <dip204_init+0x660>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002756:	ee f9 ff 98 	ld.w	r9,r7[-104]
8000275a:	30 18       	mov	r8,1
8000275c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002760:	30 18       	mov	r8,1
80002762:	c0 28       	rjmp	80002766 <dip204_init+0x662>
    }
    return false;
80002764:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002766:	58 08       	cp.w	r8,0
80002768:	ca b0       	breq	800026be <dip204_init+0x5ba>
  // Send "Display On Command: Display On, Cursor On, Blink On"
  dip204_write_byte(0x0F);
8000276a:	30 fc       	mov	r12,15
8000276c:	f0 1f 01 1a 	mcall	80002bd4 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
80002770:	f0 1f 01 16 	mcall	80002bc8 <dip204_init+0xac4>
80002774:	18 98       	mov	r8,r12
80002776:	30 19       	mov	r9,1
80002778:	ef 49 ff a4 	st.w	r7[-92],r9
8000277c:	ef 48 ff a0 	st.w	r7[-96],r8
80002780:	ee f8 ff a4 	ld.w	r8,r7[-92]
80002784:	ef 48 ff ac 	st.w	r7[-84],r8
80002788:	ee f8 ff a0 	ld.w	r8,r7[-96]
8000278c:	ef 48 ff a8 	st.w	r7[-88],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002790:	ee fb ff ac 	ld.w	r11,r7[-84]
80002794:	ef 4b fe 90 	st.w	r7[-368],r11
80002798:	30 0a       	mov	r10,0
8000279a:	ef 4a fe 8c 	st.w	r7[-372],r10
8000279e:	ee f9 ff a8 	ld.w	r9,r7[-88]
800027a2:	ef 49 fe 88 	st.w	r7[-376],r9
800027a6:	30 08       	mov	r8,0
800027a8:	ef 48 fe 84 	st.w	r7[-380],r8
800027ac:	ee fa fe 8c 	ld.w	r10,r7[-372]
800027b0:	ee fc fe 88 	ld.w	r12,r7[-376]
800027b4:	b9 3a       	mul	r10,r12
800027b6:	ee f8 fe 84 	ld.w	r8,r7[-380]
800027ba:	ee fb fe 90 	ld.w	r11,r7[-368]
800027be:	b7 38       	mul	r8,r11
800027c0:	10 0a       	add	r10,r8
800027c2:	ee fc fe 90 	ld.w	r12,r7[-368]
800027c6:	ee fb fe 88 	ld.w	r11,r7[-376]
800027ca:	f8 0b 06 48 	mulu.d	r8,r12,r11
800027ce:	12 0a       	add	r10,r9
800027d0:	14 99       	mov	r9,r10
800027d2:	e0 6a 03 e7 	mov	r10,999
800027d6:	30 0b       	mov	r11,0
800027d8:	f0 0a 00 0a 	add	r10,r8,r10
800027dc:	f2 0b 00 4b 	adc	r11,r9,r11
800027e0:	e0 68 03 e8 	mov	r8,1000
800027e4:	30 09       	mov	r9,0
800027e6:	f0 1f 00 fa 	mcall	80002bcc <dip204_init+0xac8>
800027ea:	14 98       	mov	r8,r10
800027ec:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
800027ee:	ef 48 ff b4 	st.w	r7[-76],r8
800027f2:	ee c8 01 14 	sub	r8,r7,276
800027f6:	ef 48 ff b0 	st.w	r7[-80],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800027fa:	e1 b8 00 42 	mfsr	r8,0x108
800027fe:	10 99       	mov	r9,r8
80002800:	ee f8 ff b0 	ld.w	r8,r7[-80]
80002804:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002806:	ee f8 ff b0 	ld.w	r8,r7[-80]
8000280a:	70 09       	ld.w	r9,r8[0x0]
8000280c:	ee f8 ff b4 	ld.w	r8,r7[-76]
80002810:	10 09       	add	r9,r8
80002812:	ee f8 ff b0 	ld.w	r8,r7[-80]
80002816:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002818:	ee f9 ff b0 	ld.w	r9,r7[-80]
8000281c:	30 08       	mov	r8,0
8000281e:	f3 68 00 08 	st.b	r9[8],r8
80002822:	ee c8 01 14 	sub	r8,r7,276
80002826:	ef 48 ff b8 	st.w	r7[-72],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000282a:	e1 b8 00 42 	mfsr	r8,0x108
8000282e:	ef 48 ff bc 	st.w	r7[-68],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002832:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002836:	f1 39 00 08 	ld.ub	r9,r8[8]
8000283a:	30 28       	mov	r8,2
8000283c:	f0 09 18 00 	cp.b	r9,r8
80002840:	c0 31       	brne	80002846 <dip204_init+0x742>
    return false;
80002842:	30 08       	mov	r8,0
80002844:	c4 38       	rjmp	800028ca <dip204_init+0x7c6>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002846:	ee f8 ff b8 	ld.w	r8,r7[-72]
8000284a:	f1 39 00 08 	ld.ub	r9,r8[8]
8000284e:	30 18       	mov	r8,1
80002850:	f0 09 18 00 	cp.b	r9,r8
80002854:	c0 31       	brne	8000285a <dip204_init+0x756>
    return true;
80002856:	30 18       	mov	r8,1
80002858:	c3 98       	rjmp	800028ca <dip204_init+0x7c6>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000285a:	ee f8 ff b8 	ld.w	r8,r7[-72]
8000285e:	70 09       	ld.w	r9,r8[0x0]
80002860:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002864:	70 18       	ld.w	r8,r8[0x4]
80002866:	10 39       	cp.w	r9,r8
80002868:	e0 88 00 1a 	brls	8000289c <dip204_init+0x798>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000286c:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002870:	70 08       	ld.w	r8,r8[0x0]
80002872:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002876:	10 39       	cp.w	r9,r8
80002878:	c1 02       	brcc	80002898 <dip204_init+0x794>
8000287a:	ee f8 ff b8 	ld.w	r8,r7[-72]
8000287e:	70 18       	ld.w	r8,r8[0x4]
80002880:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002884:	10 39       	cp.w	r9,r8
80002886:	e0 88 00 09 	brls	80002898 <dip204_init+0x794>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000288a:	ee f9 ff b8 	ld.w	r9,r7[-72]
8000288e:	30 18       	mov	r8,1
80002890:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002894:	30 18       	mov	r8,1
80002896:	c1 a8       	rjmp	800028ca <dip204_init+0x7c6>
    }
    return false;
80002898:	30 08       	mov	r8,0
8000289a:	c1 88       	rjmp	800028ca <dip204_init+0x7c6>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000289c:	ee f8 ff b8 	ld.w	r8,r7[-72]
800028a0:	70 08       	ld.w	r8,r8[0x0]
800028a2:	ee f9 ff bc 	ld.w	r9,r7[-68]
800028a6:	10 39       	cp.w	r9,r8
800028a8:	c0 93       	brcs	800028ba <dip204_init+0x7b6>
800028aa:	ee f8 ff b8 	ld.w	r8,r7[-72]
800028ae:	70 18       	ld.w	r8,r8[0x4]
800028b0:	ee f9 ff bc 	ld.w	r9,r7[-68]
800028b4:	10 39       	cp.w	r9,r8
800028b6:	e0 88 00 09 	brls	800028c8 <dip204_init+0x7c4>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800028ba:	ee f9 ff b8 	ld.w	r9,r7[-72]
800028be:	30 18       	mov	r8,1
800028c0:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800028c4:	30 18       	mov	r8,1
800028c6:	c0 28       	rjmp	800028ca <dip204_init+0x7c6>
    }
    return false;
800028c8:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800028ca:	58 08       	cp.w	r8,0
800028cc:	ca b0       	breq	80002822 <dip204_init+0x71e>
  // Send "Display Clear" Command
  dip204_write_byte(0x01);
800028ce:	30 1c       	mov	r12,1
800028d0:	f0 1f 00 c1 	mcall	80002bd4 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(5);
800028d4:	f0 1f 00 bd 	mcall	80002bc8 <dip204_init+0xac4>
800028d8:	18 98       	mov	r8,r12
800028da:	30 59       	mov	r9,5
800028dc:	ef 49 ff c4 	st.w	r7[-60],r9
800028e0:	ef 48 ff c0 	st.w	r7[-64],r8
800028e4:	ee f8 ff c4 	ld.w	r8,r7[-60]
800028e8:	ef 48 ff cc 	st.w	r7[-52],r8
800028ec:	ee f8 ff c0 	ld.w	r8,r7[-64]
800028f0:	ef 48 ff c8 	st.w	r7[-56],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800028f4:	ee fa ff cc 	ld.w	r10,r7[-52]
800028f8:	ef 4a fe a0 	st.w	r7[-352],r10
800028fc:	30 09       	mov	r9,0
800028fe:	ef 49 fe 9c 	st.w	r7[-356],r9
80002902:	ee f8 ff c8 	ld.w	r8,r7[-56]
80002906:	ef 48 fe 98 	st.w	r7[-360],r8
8000290a:	30 0c       	mov	r12,0
8000290c:	ef 4c fe 94 	st.w	r7[-364],r12
80002910:	ee fa fe 9c 	ld.w	r10,r7[-356]
80002914:	ee fb fe 98 	ld.w	r11,r7[-360]
80002918:	b7 3a       	mul	r10,r11
8000291a:	ee f8 fe 94 	ld.w	r8,r7[-364]
8000291e:	ee f9 fe a0 	ld.w	r9,r7[-352]
80002922:	b3 38       	mul	r8,r9
80002924:	10 0a       	add	r10,r8
80002926:	ee fc fe a0 	ld.w	r12,r7[-352]
8000292a:	ee fb fe 98 	ld.w	r11,r7[-360]
8000292e:	f8 0b 06 48 	mulu.d	r8,r12,r11
80002932:	12 0a       	add	r10,r9
80002934:	14 99       	mov	r9,r10
80002936:	e0 6a 03 e7 	mov	r10,999
8000293a:	30 0b       	mov	r11,0
8000293c:	f0 0a 00 0a 	add	r10,r8,r10
80002940:	f2 0b 00 4b 	adc	r11,r9,r11
80002944:	e0 68 03 e8 	mov	r8,1000
80002948:	30 09       	mov	r9,0
8000294a:	f0 1f 00 a1 	mcall	80002bcc <dip204_init+0xac8>
8000294e:	14 98       	mov	r8,r10
80002950:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002952:	ef 48 ff d4 	st.w	r7[-44],r8
80002956:	ee c8 01 08 	sub	r8,r7,264
8000295a:	ef 48 ff d0 	st.w	r7[-48],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000295e:	e1 b8 00 42 	mfsr	r8,0x108
80002962:	10 99       	mov	r9,r8
80002964:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002968:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000296a:	ee f8 ff d0 	ld.w	r8,r7[-48]
8000296e:	70 09       	ld.w	r9,r8[0x0]
80002970:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002974:	10 09       	add	r9,r8
80002976:	ee f8 ff d0 	ld.w	r8,r7[-48]
8000297a:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000297c:	ee f9 ff d0 	ld.w	r9,r7[-48]
80002980:	30 08       	mov	r8,0
80002982:	f3 68 00 08 	st.b	r9[8],r8
80002986:	ee c8 01 08 	sub	r8,r7,264
8000298a:	ef 48 ff d8 	st.w	r7[-40],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000298e:	e1 b8 00 42 	mfsr	r8,0x108
80002992:	ef 48 ff dc 	st.w	r7[-36],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002996:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000299a:	f1 39 00 08 	ld.ub	r9,r8[8]
8000299e:	30 28       	mov	r8,2
800029a0:	f0 09 18 00 	cp.b	r9,r8
800029a4:	c0 31       	brne	800029aa <dip204_init+0x8a6>
    return false;
800029a6:	30 08       	mov	r8,0
800029a8:	c4 38       	rjmp	80002a2e <dip204_init+0x92a>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800029aa:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029ae:	f1 39 00 08 	ld.ub	r9,r8[8]
800029b2:	30 18       	mov	r8,1
800029b4:	f0 09 18 00 	cp.b	r9,r8
800029b8:	c0 31       	brne	800029be <dip204_init+0x8ba>
    return true;
800029ba:	30 18       	mov	r8,1
800029bc:	c3 98       	rjmp	80002a2e <dip204_init+0x92a>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800029be:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029c2:	70 09       	ld.w	r9,r8[0x0]
800029c4:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029c8:	70 18       	ld.w	r8,r8[0x4]
800029ca:	10 39       	cp.w	r9,r8
800029cc:	e0 88 00 1a 	brls	80002a00 <dip204_init+0x8fc>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800029d0:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029d4:	70 08       	ld.w	r8,r8[0x0]
800029d6:	ee f9 ff dc 	ld.w	r9,r7[-36]
800029da:	10 39       	cp.w	r9,r8
800029dc:	c1 02       	brcc	800029fc <dip204_init+0x8f8>
800029de:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029e2:	70 18       	ld.w	r8,r8[0x4]
800029e4:	ee f9 ff dc 	ld.w	r9,r7[-36]
800029e8:	10 39       	cp.w	r9,r8
800029ea:	e0 88 00 09 	brls	800029fc <dip204_init+0x8f8>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800029ee:	ee f9 ff d8 	ld.w	r9,r7[-40]
800029f2:	30 18       	mov	r8,1
800029f4:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800029f8:	30 18       	mov	r8,1
800029fa:	c1 a8       	rjmp	80002a2e <dip204_init+0x92a>
    }
    return false;
800029fc:	30 08       	mov	r8,0
800029fe:	c1 88       	rjmp	80002a2e <dip204_init+0x92a>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002a00:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002a04:	70 08       	ld.w	r8,r8[0x0]
80002a06:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002a0a:	10 39       	cp.w	r9,r8
80002a0c:	c0 93       	brcs	80002a1e <dip204_init+0x91a>
80002a0e:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002a12:	70 18       	ld.w	r8,r8[0x4]
80002a14:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002a18:	10 39       	cp.w	r9,r8
80002a1a:	e0 88 00 09 	brls	80002a2c <dip204_init+0x928>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002a1e:	ee f9 ff d8 	ld.w	r9,r7[-40]
80002a22:	30 18       	mov	r8,1
80002a24:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002a28:	30 18       	mov	r8,1
80002a2a:	c0 28       	rjmp	80002a2e <dip204_init+0x92a>
    }
    return false;
80002a2c:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002a2e:	58 08       	cp.w	r8,0
80002a30:	ca b0       	breq	80002986 <dip204_init+0x882>
  // Send "Entry Mode Set Command: Increment Mode, Entire Shift off"
  dip204_write_byte(0x06);
80002a32:	30 6c       	mov	r12,6
80002a34:	f0 1f 00 68 	mcall	80002bd4 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
80002a38:	f0 1f 00 64 	mcall	80002bc8 <dip204_init+0xac4>
80002a3c:	18 98       	mov	r8,r12
80002a3e:	30 19       	mov	r9,1
80002a40:	ef 49 ff e4 	st.w	r7[-28],r9
80002a44:	ef 48 ff e0 	st.w	r7[-32],r8
80002a48:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002a4c:	ef 48 ff ec 	st.w	r7[-20],r8
80002a50:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002a54:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002a58:	ee fa ff ec 	ld.w	r10,r7[-20]
80002a5c:	ef 4a fe b0 	st.w	r7[-336],r10
80002a60:	30 09       	mov	r9,0
80002a62:	ef 49 fe ac 	st.w	r7[-340],r9
80002a66:	ee f8 ff e8 	ld.w	r8,r7[-24]
80002a6a:	ef 48 fe a8 	st.w	r7[-344],r8
80002a6e:	30 0c       	mov	r12,0
80002a70:	ef 4c fe a4 	st.w	r7[-348],r12
80002a74:	ee fa fe ac 	ld.w	r10,r7[-340]
80002a78:	ee fb fe a8 	ld.w	r11,r7[-344]
80002a7c:	b7 3a       	mul	r10,r11
80002a7e:	ee f8 fe a4 	ld.w	r8,r7[-348]
80002a82:	ee f9 fe b0 	ld.w	r9,r7[-336]
80002a86:	b3 38       	mul	r8,r9
80002a88:	10 0a       	add	r10,r8
80002a8a:	ee fc fe b0 	ld.w	r12,r7[-336]
80002a8e:	ee fb fe a8 	ld.w	r11,r7[-344]
80002a92:	f8 0b 06 48 	mulu.d	r8,r12,r11
80002a96:	12 0a       	add	r10,r9
80002a98:	14 99       	mov	r9,r10
80002a9a:	e0 6a 03 e7 	mov	r10,999
80002a9e:	30 0b       	mov	r11,0
80002aa0:	f0 0a 00 0a 	add	r10,r8,r10
80002aa4:	f2 0b 00 4b 	adc	r11,r9,r11
80002aa8:	e0 68 03 e8 	mov	r8,1000
80002aac:	30 09       	mov	r9,0
80002aae:	f0 1f 00 48 	mcall	80002bcc <dip204_init+0xac8>
80002ab2:	14 98       	mov	r8,r10
80002ab4:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002ab6:	ef 48 ff f4 	st.w	r7[-12],r8
80002aba:	ee c8 00 fc 	sub	r8,r7,252
80002abe:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002ac2:	e1 b8 00 42 	mfsr	r8,0x108
80002ac6:	10 99       	mov	r9,r8
80002ac8:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002acc:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002ace:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ad2:	70 09       	ld.w	r9,r8[0x0]
80002ad4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002ad8:	10 09       	add	r9,r8
80002ada:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ade:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002ae0:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002ae4:	30 08       	mov	r8,0
80002ae6:	f3 68 00 08 	st.b	r9[8],r8
80002aea:	ee c8 00 fc 	sub	r8,r7,252
80002aee:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002af2:	e1 b8 00 42 	mfsr	r8,0x108
80002af6:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002afa:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002afe:	f1 39 00 08 	ld.ub	r9,r8[8]
80002b02:	30 28       	mov	r8,2
80002b04:	f0 09 18 00 	cp.b	r9,r8
80002b08:	c0 31       	brne	80002b0e <dip204_init+0xa0a>
    return false;
80002b0a:	30 08       	mov	r8,0
80002b0c:	c4 38       	rjmp	80002b92 <dip204_init+0xa8e>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002b0e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b12:	f1 39 00 08 	ld.ub	r9,r8[8]
80002b16:	30 18       	mov	r8,1
80002b18:	f0 09 18 00 	cp.b	r9,r8
80002b1c:	c0 31       	brne	80002b22 <dip204_init+0xa1e>
    return true;
80002b1e:	30 18       	mov	r8,1
80002b20:	c3 98       	rjmp	80002b92 <dip204_init+0xa8e>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002b22:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b26:	70 09       	ld.w	r9,r8[0x0]
80002b28:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b2c:	70 18       	ld.w	r8,r8[0x4]
80002b2e:	10 39       	cp.w	r9,r8
80002b30:	e0 88 00 1a 	brls	80002b64 <dip204_init+0xa60>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002b34:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b38:	70 08       	ld.w	r8,r8[0x0]
80002b3a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b3e:	10 39       	cp.w	r9,r8
80002b40:	c1 02       	brcc	80002b60 <dip204_init+0xa5c>
80002b42:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b46:	70 18       	ld.w	r8,r8[0x4]
80002b48:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b4c:	10 39       	cp.w	r9,r8
80002b4e:	e0 88 00 09 	brls	80002b60 <dip204_init+0xa5c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002b52:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002b56:	30 18       	mov	r8,1
80002b58:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002b5c:	30 18       	mov	r8,1
80002b5e:	c1 a8       	rjmp	80002b92 <dip204_init+0xa8e>
    }
    return false;
80002b60:	30 08       	mov	r8,0
80002b62:	c1 88       	rjmp	80002b92 <dip204_init+0xa8e>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002b64:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b68:	70 08       	ld.w	r8,r8[0x0]
80002b6a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b6e:	10 39       	cp.w	r9,r8
80002b70:	c0 93       	brcs	80002b82 <dip204_init+0xa7e>
80002b72:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b76:	70 18       	ld.w	r8,r8[0x4]
80002b78:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b7c:	10 39       	cp.w	r9,r8
80002b7e:	e0 88 00 09 	brls	80002b90 <dip204_init+0xa8c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002b82:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002b86:	30 18       	mov	r8,1
80002b88:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002b8c:	30 18       	mov	r8,1
80002b8e:	c0 28       	rjmp	80002b92 <dip204_init+0xa8e>
    }
    return false;
80002b90:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002b92:	58 08       	cp.w	r8,0
80002b94:	ca b0       	breq	80002aea <dip204_init+0x9e6>
  dip204_wait_busy();
80002b96:	f0 1f 00 11 	mcall	80002bd8 <dip204_init+0xad4>
  // unselect chip
  dip204_unselect();
80002b9a:	f0 1f 00 11 	mcall	80002bdc <dip204_init+0xad8>
}
80002b9e:	29 5d       	sub	sp,-428
80002ba0:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
80002ba4:	00 00       	add	r0,r0
80002ba6:	00 1c       	sub	r12,r0
80002ba8:	80 00       	ld.sh	r0,r0[0x0]
80002baa:	3c d4       	mov	r4,-51
80002bac:	80 00       	ld.sh	r0,r0[0x0]
80002bae:	2f 88       	sub	r8,-8
80002bb0:	00 00       	add	r0,r0
80002bb2:	05 4c       	ld.w	r12,--r2
80002bb4:	00 00       	add	r0,r0
80002bb6:	05 50       	ld.sh	r0,--r2
80002bb8:	80 00       	ld.sh	r0,r0[0x0]
80002bba:	30 1c       	mov	r12,1
80002bbc:	80 00       	ld.sh	r0,r0[0x0]
80002bbe:	30 a4       	mov	r4,10
80002bc0:	80 00       	ld.sh	r0,r0[0x0]
80002bc2:	3e 4c       	mov	r12,-28
80002bc4:	80 00       	ld.sh	r0,r0[0x0]
80002bc6:	3d e4       	mov	r4,-34
80002bc8:	80 00       	ld.sh	r0,r0[0x0]
80002bca:	20 ec       	sub	r12,14
80002bcc:	80 00       	ld.sh	r0,r0[0x0]
80002bce:	61 f4       	ld.w	r4,r0[0x7c]
80002bd0:	80 00       	ld.sh	r0,r0[0x0]
80002bd2:	2e 18       	sub	r8,-31
80002bd4:	80 00       	ld.sh	r0,r0[0x0]
80002bd6:	2e 48       	sub	r8,-28
80002bd8:	80 00       	ld.sh	r0,r0[0x0]
80002bda:	2f 2c       	sub	r12,-14
80002bdc:	80 00       	ld.sh	r0,r0[0x0]
80002bde:	2e 30       	sub	r0,-29

80002be0 <dip204_hide_cursor>:
  dip204_unselect();
}


void dip204_hide_cursor(void)
{
80002be0:	eb cd 40 80 	pushm	r7,lr
80002be4:	1a 97       	mov	r7,sp
  /* select the LCD chip */
  dip204_select();
80002be6:	f0 1f 00 08 	mcall	80002c04 <dip204_hide_cursor+0x24>
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002bea:	e0 6c 00 f8 	mov	r12,248
80002bee:	f0 1f 00 07 	mcall	80002c08 <dip204_hide_cursor+0x28>
  /* Send "Display On Command: Display On, Cursor On, Blink On" */
  dip204_write_byte(0x0C);
80002bf2:	30 cc       	mov	r12,12
80002bf4:	f0 1f 00 05 	mcall	80002c08 <dip204_hide_cursor+0x28>
  dip204_wait_busy();
80002bf8:	f0 1f 00 05 	mcall	80002c0c <dip204_hide_cursor+0x2c>
  /* unselect chip */
  dip204_unselect();
80002bfc:	f0 1f 00 05 	mcall	80002c10 <dip204_hide_cursor+0x30>
}
80002c00:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c04:	80 00       	ld.sh	r0,r0[0x0]
80002c06:	2e 18       	sub	r8,-31
80002c08:	80 00       	ld.sh	r0,r0[0x0]
80002c0a:	2e 48       	sub	r8,-28
80002c0c:	80 00       	ld.sh	r0,r0[0x0]
80002c0e:	2f 2c       	sub	r12,-14
80002c10:	80 00       	ld.sh	r0,r0[0x0]
80002c12:	2e 30       	sub	r0,-29

80002c14 <dip204_set_cursor_position>:
  dip204_set_cursor_position(column, line);
}


void dip204_set_cursor_position(unsigned char column, unsigned char line)
{
80002c14:	eb cd 40 80 	pushm	r7,lr
80002c18:	1a 97       	mov	r7,sp
80002c1a:	20 3d       	sub	sp,12
80002c1c:	18 99       	mov	r9,r12
80002c1e:	16 98       	mov	r8,r11
80002c20:	ef 69 ff f8 	st.b	r7[-8],r9
80002c24:	ef 68 ff f4 	st.b	r7[-12],r8
  unsigned char address = 0;
80002c28:	30 08       	mov	r8,0
80002c2a:	ef 68 ff ff 	st.b	r7[-1],r8

  dip204_select();
80002c2e:	f0 1f 00 18 	mcall	80002c8c <dip204_set_cursor_position+0x78>
  if ((column <= 20) && (line <= 4))
80002c32:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80002c36:	31 48       	mov	r8,20
80002c38:	f0 09 18 00 	cp.b	r9,r8
80002c3c:	e0 8b 00 17 	brhi	80002c6a <dip204_set_cursor_position+0x56>
80002c40:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80002c44:	30 48       	mov	r8,4
80002c46:	f0 09 18 00 	cp.b	r9,r8
80002c4a:	e0 8b 00 10 	brhi	80002c6a <dip204_set_cursor_position+0x56>
  {
    /* Calculate DDRAM address from line and row values */
    address = ( (line-1) * 32 ) + ( column-1 ) + 128;
80002c4e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002c52:	20 18       	sub	r8,1
80002c54:	5c 58       	castu.b	r8
80002c56:	a5 78       	lsl	r8,0x5
80002c58:	5c 58       	castu.b	r8
80002c5a:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80002c5e:	f2 08 00 08 	add	r8,r9,r8
80002c62:	5c 58       	castu.b	r8
80002c64:	28 18       	sub	r8,-127
80002c66:	ef 68 ff ff 	st.b	r7[-1],r8
  }
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002c6a:	e0 6c 00 f8 	mov	r12,248
80002c6e:	f0 1f 00 09 	mcall	80002c90 <dip204_set_cursor_position+0x7c>
  /* Send Address lower Nibble */
  dip204_write_byte(address);
80002c72:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002c76:	10 9c       	mov	r12,r8
80002c78:	f0 1f 00 06 	mcall	80002c90 <dip204_set_cursor_position+0x7c>
  dip204_wait_busy();
80002c7c:	f0 1f 00 06 	mcall	80002c94 <dip204_set_cursor_position+0x80>
  dip204_unselect();
80002c80:	f0 1f 00 06 	mcall	80002c98 <dip204_set_cursor_position+0x84>
}
80002c84:	2f dd       	sub	sp,-12
80002c86:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c8a:	00 00       	add	r0,r0
80002c8c:	80 00       	ld.sh	r0,r0[0x0]
80002c8e:	2e 18       	sub	r8,-31
80002c90:	80 00       	ld.sh	r0,r0[0x0]
80002c92:	2e 48       	sub	r8,-28
80002c94:	80 00       	ld.sh	r0,r0[0x0]
80002c96:	2f 2c       	sub	r12,-14
80002c98:	80 00       	ld.sh	r0,r0[0x0]
80002c9a:	2e 30       	sub	r0,-29

80002c9c <dip204_clear_display>:


void dip204_clear_display(void)
{
80002c9c:	eb cd 40 8f 	pushm	r0-r3,r7,lr
80002ca0:	1a 97       	mov	r7,sp
80002ca2:	20 bd       	sub	sp,44
  dip204_select();
80002ca4:	f0 1f 00 57 	mcall	80002e00 <dip204_clear_display+0x164>
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002ca8:	e0 6c 00 f8 	mov	r12,248
80002cac:	f0 1f 00 56 	mcall	80002e04 <dip204_clear_display+0x168>
  /* Send Display Clear Command */
  dip204_write_byte(0x01);
80002cb0:	30 1c       	mov	r12,1
80002cb2:	f0 1f 00 55 	mcall	80002e04 <dip204_clear_display+0x168>
  /* Wait for command execution */
  delay_ms(4);
80002cb6:	f0 1f 00 55 	mcall	80002e08 <dip204_clear_display+0x16c>
80002cba:	18 98       	mov	r8,r12
80002cbc:	30 49       	mov	r9,4
80002cbe:	ef 49 ff e4 	st.w	r7[-28],r9
80002cc2:	ef 48 ff e0 	st.w	r7[-32],r8
80002cc6:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002cca:	ef 48 ff ec 	st.w	r7[-20],r8
80002cce:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002cd2:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002cd6:	ee f0 ff ec 	ld.w	r0,r7[-20]
80002cda:	30 01       	mov	r1,0
80002cdc:	ee f2 ff e8 	ld.w	r2,r7[-24]
80002ce0:	30 03       	mov	r3,0
80002ce2:	e2 02 02 4a 	mul	r10,r1,r2
80002ce6:	e6 00 02 48 	mul	r8,r3,r0
80002cea:	10 0a       	add	r10,r8
80002cec:	e0 02 06 48 	mulu.d	r8,r0,r2
80002cf0:	12 0a       	add	r10,r9
80002cf2:	14 99       	mov	r9,r10
80002cf4:	e0 6a 03 e7 	mov	r10,999
80002cf8:	30 0b       	mov	r11,0
80002cfa:	f0 0a 00 0a 	add	r10,r8,r10
80002cfe:	f2 0b 00 4b 	adc	r11,r9,r11
80002d02:	e0 68 03 e8 	mov	r8,1000
80002d06:	30 09       	mov	r9,0
80002d08:	f0 1f 00 41 	mcall	80002e0c <dip204_clear_display+0x170>
80002d0c:	14 98       	mov	r8,r10
80002d0e:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002d10:	ef 48 ff f4 	st.w	r7[-12],r8
80002d14:	ee c8 00 2c 	sub	r8,r7,44
80002d18:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002d1c:	e1 b8 00 42 	mfsr	r8,0x108
80002d20:	10 99       	mov	r9,r8
80002d22:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d26:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002d28:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d2c:	70 09       	ld.w	r9,r8[0x0]
80002d2e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002d32:	10 09       	add	r9,r8
80002d34:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d38:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002d3a:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002d3e:	30 08       	mov	r8,0
80002d40:	f3 68 00 08 	st.b	r9[8],r8
80002d44:	ee c8 00 2c 	sub	r8,r7,44
80002d48:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002d4c:	e1 b8 00 42 	mfsr	r8,0x108
80002d50:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002d54:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d58:	f1 39 00 08 	ld.ub	r9,r8[8]
80002d5c:	30 28       	mov	r8,2
80002d5e:	f0 09 18 00 	cp.b	r9,r8
80002d62:	c0 31       	brne	80002d68 <dip204_clear_display+0xcc>
    return false;
80002d64:	30 08       	mov	r8,0
80002d66:	c4 38       	rjmp	80002dec <dip204_clear_display+0x150>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002d68:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d6c:	f1 39 00 08 	ld.ub	r9,r8[8]
80002d70:	30 18       	mov	r8,1
80002d72:	f0 09 18 00 	cp.b	r9,r8
80002d76:	c0 31       	brne	80002d7c <dip204_clear_display+0xe0>
    return true;
80002d78:	30 18       	mov	r8,1
80002d7a:	c3 98       	rjmp	80002dec <dip204_clear_display+0x150>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002d7c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d80:	70 09       	ld.w	r9,r8[0x0]
80002d82:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d86:	70 18       	ld.w	r8,r8[0x4]
80002d88:	10 39       	cp.w	r9,r8
80002d8a:	e0 88 00 1a 	brls	80002dbe <dip204_clear_display+0x122>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002d8e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d92:	70 08       	ld.w	r8,r8[0x0]
80002d94:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002d98:	10 39       	cp.w	r9,r8
80002d9a:	c1 02       	brcc	80002dba <dip204_clear_display+0x11e>
80002d9c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002da0:	70 18       	ld.w	r8,r8[0x4]
80002da2:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002da6:	10 39       	cp.w	r9,r8
80002da8:	e0 88 00 09 	brls	80002dba <dip204_clear_display+0x11e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002dac:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002db0:	30 18       	mov	r8,1
80002db2:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002db6:	30 18       	mov	r8,1
80002db8:	c1 a8       	rjmp	80002dec <dip204_clear_display+0x150>
    }
    return false;
80002dba:	30 08       	mov	r8,0
80002dbc:	c1 88       	rjmp	80002dec <dip204_clear_display+0x150>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002dbe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dc2:	70 08       	ld.w	r8,r8[0x0]
80002dc4:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002dc8:	10 39       	cp.w	r9,r8
80002dca:	c0 93       	brcs	80002ddc <dip204_clear_display+0x140>
80002dcc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dd0:	70 18       	ld.w	r8,r8[0x4]
80002dd2:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002dd6:	10 39       	cp.w	r9,r8
80002dd8:	e0 88 00 09 	brls	80002dea <dip204_clear_display+0x14e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002ddc:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002de0:	30 18       	mov	r8,1
80002de2:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002de6:	30 18       	mov	r8,1
80002de8:	c0 28       	rjmp	80002dec <dip204_clear_display+0x150>
    }
    return false;
80002dea:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002dec:	58 08       	cp.w	r8,0
80002dee:	ca b0       	breq	80002d44 <dip204_clear_display+0xa8>
  dip204_wait_busy();
80002df0:	f0 1f 00 08 	mcall	80002e10 <dip204_clear_display+0x174>
  dip204_unselect();
80002df4:	f0 1f 00 08 	mcall	80002e14 <dip204_clear_display+0x178>
}
80002df8:	2f 5d       	sub	sp,-44
80002dfa:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
80002dfe:	00 00       	add	r0,r0
80002e00:	80 00       	ld.sh	r0,r0[0x0]
80002e02:	2e 18       	sub	r8,-31
80002e04:	80 00       	ld.sh	r0,r0[0x0]
80002e06:	2e 48       	sub	r8,-28
80002e08:	80 00       	ld.sh	r0,r0[0x0]
80002e0a:	20 ec       	sub	r12,14
80002e0c:	80 00       	ld.sh	r0,r0[0x0]
80002e0e:	61 f4       	ld.w	r4,r0[0x7c]
80002e10:	80 00       	ld.sh	r0,r0[0x0]
80002e12:	2f 2c       	sub	r12,-14
80002e14:	80 00       	ld.sh	r0,r0[0x0]
80002e16:	2e 30       	sub	r0,-29

80002e18 <dip204_select>:

/*! \brief function to select the LCD
 *
 */
static void dip204_select(void)
{
80002e18:	eb cd 40 80 	pushm	r7,lr
80002e1c:	1a 97       	mov	r7,sp
  spi_selectChip(DIP204_SPI, DIP204_SPI_NPCS);
80002e1e:	30 2b       	mov	r11,2
80002e20:	fe 7c 28 00 	mov	r12,-55296
80002e24:	f0 1f 00 02 	mcall	80002e2c <dip204_select+0x14>
}
80002e28:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e2c:	80 00       	ld.sh	r0,r0[0x0]
80002e2e:	32 4a       	mov	r10,36

80002e30 <dip204_unselect>:

/*! \brief function to unselect the LCD
 *
 */
static void dip204_unselect(void)
{
80002e30:	eb cd 40 80 	pushm	r7,lr
80002e34:	1a 97       	mov	r7,sp
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_unselectChip(DIP204_SPI, DIP204_SPI_NPCS);
80002e36:	30 2b       	mov	r11,2
80002e38:	fe 7c 28 00 	mov	r12,-55296
80002e3c:	f0 1f 00 02 	mcall	80002e44 <dip204_unselect+0x14>
  Assert( SPI_OK==spi_status );
}
80002e40:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e44:	80 00       	ld.sh	r0,r0[0x0]
80002e46:	32 e2       	mov	r2,46

80002e48 <dip204_write_byte>:
 *
 *  \param  byte  Input. byte to write to the LCD (D7 .. D0)
 *
 */
static void dip204_write_byte(unsigned char byte)
{
80002e48:	eb cd 40 80 	pushm	r7,lr
80002e4c:	1a 97       	mov	r7,sp
80002e4e:	20 3d       	sub	sp,12
80002e50:	18 98       	mov	r8,r12
80002e52:	ef 68 ff f4 	st.b	r7[-12],r8
  unsigned char reverse;

  switch (byte)
80002e56:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002e5a:	f0 c8 00 f8 	sub	r8,r8,248
80002e5e:	58 68       	cp.w	r8,6
80002e60:	e0 8b 00 10 	brhi	80002e80 <dip204_write_byte+0x38>
80002e64:	30 19       	mov	r9,1
80002e66:	f2 08 09 48 	lsl	r8,r9,r8
80002e6a:	e2 18 00 55 	andl	r8,0x55,COH
80002e6e:	c0 90       	breq	80002e80 <dip204_write_byte+0x38>
    {
      /* send D7 to D0 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, byte);
80002e70:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002e74:	10 9b       	mov	r11,r8
80002e76:	fe 7c 28 00 	mov	r12,-55296
80002e7a:	f0 1f 00 15 	mcall	80002ecc <dip204_write_byte+0x84>
      Assert( SPI_OK==spi_status );
      break;
80002e7e:	c2 48       	rjmp	80002ec6 <dip204_write_byte+0x7e>
    }
    /* LSB first for all other data */
    default:
    {
      /* reverse byte */
      reverse = bit_reverse8(byte);
80002e80:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002e84:	ef 48 ff fc 	st.w	r7[-4],r8
80002e88:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e8c:	5c 98       	brev	r8
80002e8e:	ef 48 ff fc 	st.w	r7[-4],r8
80002e92:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e96:	b9 88       	lsr	r8,0x18
80002e98:	ef 68 ff fb 	st.b	r7[-5],r8
      /* send D0 to D3 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, (reverse & 0xF0));
80002e9c:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002ea0:	e2 18 00 f0 	andl	r8,0xf0,COH
80002ea4:	10 9b       	mov	r11,r8
80002ea6:	fe 7c 28 00 	mov	r12,-55296
80002eaa:	f0 1f 00 09 	mcall	80002ecc <dip204_write_byte+0x84>
      Assert( SPI_OK==spi_status );
      /* send D4 to D7 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, ((reverse << 4) & 0xF0));
80002eae:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002eb2:	a5 68       	lsl	r8,0x4
80002eb4:	5c 88       	casts.h	r8
80002eb6:	5c 78       	castu.h	r8
80002eb8:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002ebc:	10 9b       	mov	r11,r8
80002ebe:	fe 7c 28 00 	mov	r12,-55296
80002ec2:	f0 1f 00 03 	mcall	80002ecc <dip204_write_byte+0x84>
      Assert( SPI_OK==spi_status );
      break;
    }
  }
}
80002ec6:	2f dd       	sub	sp,-12
80002ec8:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ecc:	80 00       	ld.sh	r0,r0[0x0]
80002ece:	34 ea       	mov	r10,78

80002ed0 <dip204_read_byte>:
 *
 *  \param  byte  Input. byte read from the LCD (D7 .. D0)
 *
 */
static void dip204_read_byte(unsigned char *byte)
{
80002ed0:	eb cd 40 80 	pushm	r7,lr
80002ed4:	1a 97       	mov	r7,sp
80002ed6:	20 3d       	sub	sp,12
80002ed8:	ef 4c ff f4 	st.w	r7[-12],r12
  unsigned short reverse = 0x00;
80002edc:	30 08       	mov	r8,0
80002ede:	ef 58 ff fa 	st.h	r7[-6],r8

  /* dummy write */
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_write(DIP204_SPI, 0x00);
80002ee2:	30 0b       	mov	r11,0
80002ee4:	fe 7c 28 00 	mov	r12,-55296
80002ee8:	f0 1f 00 0f 	mcall	80002f24 <dip204_read_byte+0x54>
  Assert( SPI_OK==spi_status );
  /* read RSR register */
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_read(DIP204_SPI, &reverse);
80002eec:	ee c8 00 06 	sub	r8,r7,6
80002ef0:	10 9b       	mov	r11,r8
80002ef2:	fe 7c 28 00 	mov	r12,-55296
80002ef6:	f0 1f 00 0d 	mcall	80002f28 <dip204_read_byte+0x58>
  Assert( SPI_OK==spi_status );
  /* Revert received byte (issued LSB first by the LCD) */
  *byte = bit_reverse8(reverse);
80002efa:	ef 08 ff fa 	ld.sh	r8,r7[-6]
80002efe:	5c 58       	castu.b	r8
80002f00:	ef 48 ff fc 	st.w	r7[-4],r8
80002f04:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002f08:	5c 98       	brev	r8
80002f0a:	ef 48 ff fc 	st.w	r7[-4],r8
80002f0e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002f12:	b9 88       	lsr	r8,0x18
80002f14:	5c 58       	castu.b	r8
80002f16:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002f1a:	b2 88       	st.b	r9[0x0],r8
}
80002f1c:	2f dd       	sub	sp,-12
80002f1e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f22:	00 00       	add	r0,r0
80002f24:	80 00       	ld.sh	r0,r0[0x0]
80002f26:	34 ea       	mov	r10,78
80002f28:	80 00       	ld.sh	r0,r0[0x0]
80002f2a:	35 42       	mov	r2,84

80002f2c <dip204_wait_busy>:

/*! \brief function to wait for LCD becomes not busy
 *
 */
static void dip204_wait_busy(void)
{
80002f2c:	eb cd 40 80 	pushm	r7,lr
80002f30:	1a 97       	mov	r7,sp
80002f32:	20 1d       	sub	sp,4
  unsigned char status = 0x00;
80002f34:	30 08       	mov	r8,0
80002f36:	ef 68 ff ff 	st.b	r7[-1],r8

  /* send read command to LCD */
  dip204_write_byte(DIP204_READ_COMMAND);
80002f3a:	e0 6c 00 fc 	mov	r12,252
80002f3e:	f0 1f 00 09 	mcall	80002f60 <dip204_wait_busy+0x34>
  /* read next byte */
  do {
  dip204_read_byte(&status);
80002f42:	ee c8 00 01 	sub	r8,r7,1
80002f46:	10 9c       	mov	r12,r8
80002f48:	f0 1f 00 07 	mcall	80002f64 <dip204_wait_busy+0x38>
  /* keep D7 to know status */
  }while (status & 0x80);
80002f4c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002f50:	10 99       	mov	r9,r8
80002f52:	30 08       	mov	r8,0
80002f54:	f0 09 18 00 	cp.b	r9,r8
80002f58:	cf 55       	brlt	80002f42 <dip204_wait_busy+0x16>
}
80002f5a:	2f fd       	sub	sp,-4
80002f5c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f60:	80 00       	ld.sh	r0,r0[0x0]
80002f62:	2e 48       	sub	r8,-28
80002f64:	80 00       	ld.sh	r0,r0[0x0]
80002f66:	2e d0       	sub	r0,-19

80002f68 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80002f68:	eb cd 40 80 	pushm	r7,lr
80002f6c:	1a 97       	mov	r7,sp
80002f6e:	20 1d       	sub	sp,4
80002f70:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80002f74:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002f78:	e6 18 00 01 	andh	r8,0x1,COH
80002f7c:	5f 08       	sreq	r8
80002f7e:	5c 58       	castu.b	r8
}
80002f80:	10 9c       	mov	r12,r8
80002f82:	2f fd       	sub	sp,-4
80002f84:	e3 cd 80 80 	ldm	sp++,r7,pc

80002f88 <pwm_init>:
#include "compiler.h"
#include "pwm.h"


int pwm_init(const pwm_opt_t *opt)
{
80002f88:	eb cd 40 80 	pushm	r7,lr
80002f8c:	1a 97       	mov	r7,sp
80002f8e:	20 3d       	sub	sp,12
80002f90:	ef 4c ff f4 	st.w	r7[-12],r12
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
80002f94:	fe 78 30 00 	mov	r8,-53248
80002f98:	ef 48 ff f8 	st.w	r7[-8],r8
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80002f9c:	e1 b8 00 00 	mfsr	r8,0x0
80002fa0:	10 9c       	mov	r12,r8
80002fa2:	f0 1f 00 1e 	mcall	80003018 <pwm_init+0x90>
80002fa6:	18 98       	mov	r8,r12
80002fa8:	ef 68 ff ff 	st.b	r7[-1],r8

  if (opt == 0 ) // Null pointer.
80002fac:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002fb0:	58 08       	cp.w	r8,0
80002fb2:	c0 31       	brne	80002fb8 <pwm_init+0x30>
    return PWM_INVALID_INPUT;
80002fb4:	30 18       	mov	r8,1
80002fb6:	c2 c8       	rjmp	8000300e <pwm_init+0x86>

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
80002fb8:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80002fbc:	30 08       	mov	r8,0
80002fbe:	f0 09 18 00 	cp.b	r9,r8
80002fc2:	c0 20       	breq	80002fc6 <pwm_init+0x3e>
80002fc4:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
80002fc6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002fca:	37 f9       	mov	r9,127
80002fcc:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
80002fce:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002fd2:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
80002fd4:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80002fd8:	30 08       	mov	r8,0
80002fda:	f0 09 18 00 	cp.b	r9,r8
80002fde:	c0 20       	breq	80002fe2 <pwm_init+0x5a>
80002fe0:	d5 03       	csrf	0x10

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
80002fe2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002fe6:	70 19       	ld.w	r9,r8[0x4]
    ((opt->divb)<<AVR32_PWM_DIVB_OFFSET) |
80002fe8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002fec:	70 08       	ld.w	r8,r8[0x0]
80002fee:	b1 68       	lsl	r8,0x10
80002ff0:	10 49       	or	r9,r8
    ((opt->prea)<<AVR32_PWM_PREA_OFFSET) |
80002ff2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002ff6:	70 38       	ld.w	r8,r8[0xc]
80002ff8:	a9 68       	lsl	r8,0x8
80002ffa:	10 49       	or	r9,r8
    ((opt->preb)<<AVR32_PWM_PREB_OFFSET)
80002ffc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003000:	70 28       	ld.w	r8,r8[0x8]
80003002:	b9 68       	lsl	r8,0x18
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
80003004:	10 49       	or	r9,r8
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
80003006:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000300a:	91 09       	st.w	r8[0x0],r9
    ((opt->divb)<<AVR32_PWM_DIVB_OFFSET) |
    ((opt->prea)<<AVR32_PWM_PREA_OFFSET) |
    ((opt->preb)<<AVR32_PWM_PREB_OFFSET)
    ;

  return PWM_SUCCESS;
8000300c:	30 08       	mov	r8,0
}
8000300e:	10 9c       	mov	r12,r8
80003010:	2f dd       	sub	sp,-12
80003012:	e3 cd 80 80 	ldm	sp++,r7,pc
80003016:	00 00       	add	r0,r0
80003018:	80 00       	ld.sh	r0,r0[0x0]
8000301a:	2f 68       	sub	r8,-10

8000301c <pwm_channel_init>:


int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
8000301c:	eb cd 40 80 	pushm	r7,lr
80003020:	1a 97       	mov	r7,sp
80003022:	20 3d       	sub	sp,12
80003024:	ef 4c ff f8 	st.w	r7[-8],r12
80003028:	ef 4b ff f4 	st.w	r7[-12],r11
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
8000302c:	fe 78 30 00 	mov	r8,-53248
80003030:	ef 48 ff fc 	st.w	r7[-4],r8

  if (pwm_channel == 0) // Null pointer.
80003034:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003038:	58 08       	cp.w	r8,0
8000303a:	c0 31       	brne	80003040 <pwm_channel_init+0x24>
    return PWM_INVALID_ARGUMENT;
8000303c:	30 18       	mov	r8,1
8000303e:	c2 f8       	rjmp	8000309c <pwm_channel_init+0x80>
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
80003040:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003044:	58 68       	cp.w	r8,6
80003046:	e0 88 00 04 	brls	8000304e <pwm_channel_init+0x32>
    return PWM_INVALID_INPUT;
8000304a:	30 18       	mov	r8,1
8000304c:	c2 88       	rjmp	8000309c <pwm_channel_init+0x80>

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
8000304e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003052:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003056:	72 09       	ld.w	r9,r9[0x0]
80003058:	ee fa ff fc 	ld.w	r10,r7[-4]
8000305c:	2f 08       	sub	r8,-16
8000305e:	a5 78       	lsl	r8,0x5
80003060:	f4 08 00 08 	add	r8,r10,r8
80003064:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
80003066:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000306a:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000306e:	72 19       	ld.w	r9,r9[0x4]
80003070:	ee fa ff fc 	ld.w	r10,r7[-4]
80003074:	a5 78       	lsl	r8,0x5
80003076:	f4 08 00 08 	add	r8,r10,r8
8000307a:	f0 c8 fd fc 	sub	r8,r8,-516
8000307e:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
80003080:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003084:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003088:	72 29       	ld.w	r9,r9[0x8]
8000308a:	ee fa ff fc 	ld.w	r10,r7[-4]
8000308e:	a5 78       	lsl	r8,0x5
80003090:	f4 08 00 08 	add	r8,r10,r8
80003094:	f0 c8 fd f8 	sub	r8,r8,-520
80003098:	91 09       	st.w	r8[0x0],r9

  return PWM_SUCCESS;
8000309a:	30 08       	mov	r8,0
}
8000309c:	10 9c       	mov	r12,r8
8000309e:	2f dd       	sub	sp,-12
800030a0:	e3 cd 80 80 	ldm	sp++,r7,pc

800030a4 <pwm_start_channels>:


int pwm_start_channels(unsigned long channels_bitmask)
{
800030a4:	eb cd 40 80 	pushm	r7,lr
800030a8:	1a 97       	mov	r7,sp
800030aa:	20 1d       	sub	sp,4
800030ac:	ef 4c ff fc 	st.w	r7[-4],r12
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
800030b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030b4:	e0 18 ff 80 	andl	r8,0xff80
800030b8:	c0 30       	breq	800030be <pwm_start_channels+0x1a>
    return PWM_INVALID_INPUT;
800030ba:	30 18       	mov	r8,1
800030bc:	c0 78       	rjmp	800030ca <pwm_start_channels+0x26>

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
800030be:	fe 78 30 00 	mov	r8,-53248
800030c2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800030c6:	91 19       	st.w	r8[0x4],r9

  return PWM_SUCCESS;
800030c8:	30 08       	mov	r8,0
}
800030ca:	10 9c       	mov	r12,r8
800030cc:	2f fd       	sub	sp,-4
800030ce:	e3 cd 80 80 	ldm	sp++,r7,pc

800030d2 <getBaudDiv>:
/** The SPI mutex. */
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
800030d2:	eb cd 40 80 	pushm	r7,lr
800030d6:	1a 97       	mov	r7,sp
800030d8:	20 3d       	sub	sp,12
800030da:	ef 4c ff f8 	st.w	r7[-8],r12
800030de:	ef 4b ff f4 	st.w	r7[-12],r11
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800030e2:	ee f9 ff f4 	ld.w	r9,r7[-12]
800030e6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800030ea:	f2 08 00 08 	add	r8,r9,r8
800030ee:	20 18       	sub	r8,1
800030f0:	ee f9 ff f8 	ld.w	r9,r7[-8]
800030f4:	f0 09 0d 08 	divu	r8,r8,r9
800030f8:	ef 48 ff fc 	st.w	r7[-4],r8

	if (baudDiv <= 0 || baudDiv > 255) {
800030fc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003100:	58 08       	cp.w	r8,0
80003102:	c0 70       	breq	80003110 <getBaudDiv+0x3e>
80003104:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003108:	e0 48 00 ff 	cp.w	r8,255
8000310c:	e0 88 00 04 	brls	80003114 <getBaudDiv+0x42>
		return -1;
80003110:	3f f8       	mov	r8,-1
80003112:	c0 48       	rjmp	8000311a <getBaudDiv+0x48>
	}

	return baudDiv;
80003114:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003118:	5c 88       	casts.h	r8
}
8000311a:	10 9c       	mov	r12,r8
8000311c:	2f dd       	sub	sp,-12
8000311e:	e3 cd 80 80 	ldm	sp++,r7,pc

80003122 <spi_initMaster>:
	return SPI_OK;
}

spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
80003122:	eb cd 40 80 	pushm	r7,lr
80003126:	1a 97       	mov	r7,sp
80003128:	20 3d       	sub	sp,12
8000312a:	ef 4c ff f8 	st.w	r7[-8],r12
8000312e:	ef 4b ff f4 	st.w	r7[-12],r11
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80003132:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003136:	f1 39 00 0d 	ld.ub	r9,r8[13]
8000313a:	30 18       	mov	r8,1
8000313c:	f0 09 18 00 	cp.b	r9,r8
80003140:	e0 88 00 04 	brls	80003148 <spi_initMaster+0x26>
		return SPI_ERROR_ARGUMENT;
80003144:	30 28       	mov	r8,2
80003146:	c3 48       	rjmp	800031ae <spi_initMaster+0x8c>
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80003148:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000314c:	e0 69 00 80 	mov	r9,128
80003150:	91 09       	st.w	r8[0x0],r9

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80003152:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003156:	70 18       	ld.w	r8,r8[0x4]
80003158:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.mstr = 1;
8000315c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003160:	30 19       	mov	r9,1
80003162:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
80003166:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
8000316a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000316e:	f1 38 00 0d 	ld.ub	r8,r8[13]
80003172:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003176:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000317a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000317e:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
80003182:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.llb = 0;
80003186:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000318a:	30 09       	mov	r9,0
8000318c:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
80003190:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80003194:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003198:	30 f9       	mov	r9,15
8000319a:	f1 d9 d2 04 	bfins	r8,r9,0x10,0x4
8000319e:	ef 48 ff fc 	st.w	r7[-4],r8
	spi->mr = u_avr32_spi_mr.mr;
800031a2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800031a6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800031aa:	91 19       	st.w	r8[0x4],r9

	return SPI_OK;
800031ac:	30 08       	mov	r8,0
}
800031ae:	10 9c       	mov	r12,r8
800031b0:	2f dd       	sub	sp,-12
800031b2:	e3 cd 80 80 	ldm	sp++,r7,pc

800031b6 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800031b6:	eb cd 40 80 	pushm	r7,lr
800031ba:	1a 97       	mov	r7,sp
800031bc:	20 5d       	sub	sp,20
800031be:	ef 4c ff f8 	st.w	r7[-8],r12
800031c2:	12 98       	mov	r8,r9
800031c4:	16 99       	mov	r9,r11
800031c6:	ef 69 ff f4 	st.b	r7[-12],r9
800031ca:	14 99       	mov	r9,r10
800031cc:	ef 69 ff f0 	st.b	r7[-16],r9
800031d0:	ef 68 ff ec 	st.b	r7[-20],r8
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800031d4:	ef 39 ff f4 	ld.ub	r9,r7[-12]
800031d8:	30 18       	mov	r8,1
800031da:	f0 09 18 00 	cp.b	r9,r8
800031de:	e0 8b 00 09 	brhi	800031f0 <spi_selectionMode+0x3a>
800031e2:	ef 39 ff f0 	ld.ub	r9,r7[-16]
800031e6:	30 18       	mov	r8,1
800031e8:	f0 09 18 00 	cp.b	r9,r8
800031ec:	e0 88 00 04 	brls	800031f4 <spi_selectionMode+0x3e>
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
800031f0:	30 28       	mov	r8,2
800031f2:	c2 88       	rjmp	80003242 <spi_selectionMode+0x8c>
	}

	u_avr32_spi_mr.mr = spi->mr;
800031f4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800031f8:	70 18       	ld.w	r8,r8[0x4]
800031fa:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.ps = variable_ps;
800031fe:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003202:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003206:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000320a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000320e:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
80003212:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80003216:	ef 38 ff f0 	ld.ub	r8,r7[-16]
8000321a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000321e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003222:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003226:	f1 d9 d0 41 	bfins	r8,r9,0x2,0x1
8000322a:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.dlybcs = delay;
8000322e:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80003232:	ef 68 ff fc 	st.b	r7[-4],r8
	spi->mr = u_avr32_spi_mr.mr;
80003236:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000323a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000323e:	91 19       	st.w	r8[0x4],r9

	return SPI_OK;
80003240:	30 08       	mov	r8,0
}
80003242:	10 9c       	mov	r12,r8
80003244:	2f bd       	sub	sp,-20
80003246:	e3 cd 80 80 	ldm	sp++,r7,pc

8000324a <spi_selectChip>:

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000324a:	eb cd 40 80 	pushm	r7,lr
8000324e:	1a 97       	mov	r7,sp
80003250:	20 2d       	sub	sp,8
80003252:	ef 4c ff fc 	st.w	r7[-4],r12
80003256:	16 98       	mov	r8,r11
80003258:	ef 68 ff f8 	st.b	r7[-8],r8
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000325c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003260:	70 18       	ld.w	r8,r8[0x4]
80003262:	10 99       	mov	r9,r8
80003264:	ea 19 00 0f 	orh	r9,0xf
80003268:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000326c:	91 19       	st.w	r8[0x4],r9

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
8000326e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003272:	70 18       	ld.w	r8,r8[0x4]
80003274:	e2 18 00 04 	andl	r8,0x4,COH
80003278:	c1 90       	breq	800032aa <spi_selectChip+0x60>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
8000327a:	ef 39 ff f8 	ld.ub	r9,r7[-8]
8000327e:	30 e8       	mov	r8,14
80003280:	f0 09 18 00 	cp.b	r9,r8
80003284:	e0 88 00 04 	brls	8000328c <spi_selectChip+0x42>
			return SPI_ERROR_ARGUMENT;
80003288:	30 28       	mov	r8,2
8000328a:	c2 88       	rjmp	800032da <spi_selectChip+0x90>
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
8000328c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003290:	70 19       	ld.w	r9,r8[0x4]
				(chip << AVR32_SPI_MR_PCS_OFFSET);
80003292:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80003296:	b1 68       	lsl	r8,0x10
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80003298:	ea 18 ff f0 	orh	r8,0xfff0
8000329c:	e8 18 ff ff 	orl	r8,0xffff
800032a0:	10 69       	and	r9,r8
800032a2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032a6:	91 19       	st.w	r8[0x4],r9
800032a8:	c1 88       	rjmp	800032d8 <spi_selectChip+0x8e>
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800032aa:	ef 39 ff f8 	ld.ub	r9,r7[-8]
800032ae:	30 38       	mov	r8,3
800032b0:	f0 09 18 00 	cp.b	r9,r8
800032b4:	e0 88 00 04 	brls	800032bc <spi_selectChip+0x72>
			return SPI_ERROR_ARGUMENT;
800032b8:	30 28       	mov	r8,2
800032ba:	c1 08       	rjmp	800032da <spi_selectChip+0x90>
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800032bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032c0:	70 19       	ld.w	r9,r8[0x4]
800032c2:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800032c6:	2f 08       	sub	r8,-16
800032c8:	30 1a       	mov	r10,1
800032ca:	f4 08 09 48 	lsl	r8,r10,r8
800032ce:	5c d8       	com	r8
800032d0:	10 69       	and	r9,r8
800032d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032d6:	91 19       	st.w	r8[0x4],r9
	}

	return SPI_OK;
800032d8:	30 08       	mov	r8,0
}
800032da:	10 9c       	mov	r12,r8
800032dc:	2f ed       	sub	sp,-8
800032de:	e3 cd 80 80 	ldm	sp++,r7,pc

800032e2 <spi_unselectChip>:

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800032e2:	eb cd 40 80 	pushm	r7,lr
800032e6:	1a 97       	mov	r7,sp
800032e8:	20 3d       	sub	sp,12
800032ea:	ef 4c ff f8 	st.w	r7[-8],r12
800032ee:	16 98       	mov	r8,r11
800032f0:	ef 68 ff f4 	st.b	r7[-12],r8
	uint32_t timeout = SPI_TIMEOUT;
800032f4:	e0 68 3a 98 	mov	r8,15000
800032f8:	ef 48 ff fc 	st.w	r7[-4],r8

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800032fc:	c0 f8       	rjmp	8000331a <spi_unselectChip+0x38>
		if (!timeout--) {
800032fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003302:	58 08       	cp.w	r8,0
80003304:	5f 08       	sreq	r8
80003306:	5c 58       	castu.b	r8
80003308:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000330c:	20 19       	sub	r9,1
8000330e:	ef 49 ff fc 	st.w	r7[-4],r9
80003312:	58 08       	cp.w	r8,0
80003314:	c0 30       	breq	8000331a <spi_unselectChip+0x38>
			return SPI_ERROR_TIMEOUT;
80003316:	30 18       	mov	r8,1
80003318:	c1 68       	rjmp	80003344 <spi_unselectChip+0x62>

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000331a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000331e:	70 48       	ld.w	r8,r8[0x10]
80003320:	e2 18 02 00 	andl	r8,0x200,COH
80003324:	ce d0       	breq	800032fe <spi_unselectChip+0x1c>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80003326:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000332a:	70 18       	ld.w	r8,r8[0x4]
8000332c:	10 99       	mov	r9,r8
8000332e:	ea 19 00 0f 	orh	r9,0xf
80003332:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003336:	91 19       	st.w	r8[0x4],r9

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80003338:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000333c:	fc 19 01 00 	movh	r9,0x100
80003340:	91 09       	st.w	r8[0x0],r9

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
#endif

	return SPI_OK;
80003342:	30 08       	mov	r8,0
}
80003344:	10 9c       	mov	r12,r8
80003346:	2f dd       	sub	sp,-12
80003348:	e3 cd 80 80 	ldm	sp++,r7,pc

8000334c <spi_setupChipReg>:

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
8000334c:	eb cd 40 80 	pushm	r7,lr
80003350:	1a 97       	mov	r7,sp
80003352:	20 5d       	sub	sp,20
80003354:	ef 4c ff f4 	st.w	r7[-12],r12
80003358:	ef 4b ff f0 	st.w	r7[-16],r11
8000335c:	ef 4a ff ec 	st.w	r7[-20],r10
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80003360:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003364:	f1 39 00 0c 	ld.ub	r9,r8[12]
80003368:	30 38       	mov	r8,3
8000336a:	f0 09 18 00 	cp.b	r9,r8
8000336e:	e0 8b 00 1d 	brhi	800033a8 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
80003372:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003376:	f1 39 00 0b 	ld.ub	r9,r8[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000337a:	30 18       	mov	r8,1
8000337c:	f0 09 18 00 	cp.b	r9,r8
80003380:	e0 8b 00 14 	brhi	800033a8 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80003384:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003388:	f1 39 00 08 	ld.ub	r9,r8[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000338c:	30 78       	mov	r8,7
8000338e:	f0 09 18 00 	cp.b	r9,r8
80003392:	e0 88 00 0b 	brls	800033a8 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80003396:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000339a:	f1 39 00 08 	ld.ub	r9,r8[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000339e:	31 08       	mov	r8,16
800033a0:	f0 09 18 00 	cp.b	r9,r8
800033a4:	e0 88 00 04 	brls	800033ac <spi_setupChipReg+0x60>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
800033a8:	30 28       	mov	r8,2
800033aa:	c8 d8       	rjmp	800034c4 <spi_setupChipReg+0x178>
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800033ac:	ee f8 ff f0 	ld.w	r8,r7[-16]
800033b0:	70 18       	ld.w	r8,r8[0x4]
800033b2:	ee fb ff ec 	ld.w	r11,r7[-20]
800033b6:	10 9c       	mov	r12,r8
800033b8:	f0 1f 00 45 	mcall	800034cc <spi_setupChipReg+0x180>
800033bc:	18 98       	mov	r8,r12
800033be:	ef 48 ff fc 	st.w	r7[-4],r8

	if (baudDiv < 0) {
800033c2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033c6:	58 08       	cp.w	r8,0
800033c8:	c0 34       	brge	800033ce <spi_setupChipReg+0x82>
		return SPI_ERROR_ARGUMENT;
800033ca:	30 28       	mov	r8,2
800033cc:	c7 c8       	rjmp	800034c4 <spi_setupChipReg+0x178>
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800033ce:	30 08       	mov	r8,0
800033d0:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800033d4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800033d8:	f1 38 00 0c 	ld.ub	r8,r8[12]
800033dc:	a1 98       	lsr	r8,0x1
800033de:	5c 58       	castu.b	r8
800033e0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800033e4:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800033e8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800033ec:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
800033f0:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800033f4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800033f8:	f1 38 00 0c 	ld.ub	r8,r8[12]
800033fc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003400:	5f 08       	sreq	r8
80003402:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003406:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000340a:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
8000340e:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80003412:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003416:	f1 38 00 0b 	ld.ub	r8,r8[11]
8000341a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000341e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003422:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003426:	f1 d9 d0 61 	bfins	r8,r9,0x3,0x1
8000342a:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
8000342e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003432:	f1 38 00 08 	ld.ub	r8,r8[8]
80003436:	20 88       	sub	r8,8
80003438:	5c 58       	castu.b	r8
8000343a:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000343e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003442:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003446:	f1 d9 d0 84 	bfins	r8,r9,0x4,0x4
8000344a:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
8000344e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003452:	5c 58       	castu.b	r8
80003454:	ef 68 ff fa 	st.b	r7[-6],r8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80003458:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000345c:	f1 38 00 09 	ld.ub	r8,r8[9]
80003460:	ef 68 ff f9 	st.b	r7[-7],r8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80003464:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003468:	f1 38 00 0a 	ld.ub	r8,r8[10]
8000346c:	ef 68 ff f8 	st.b	r7[-8],r8

	switch (options->reg) {
80003470:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003474:	11 88       	ld.ub	r8,r8[0x0]
80003476:	58 18       	cp.w	r8,1
80003478:	c1 10       	breq	8000349a <spi_setupChipReg+0x14e>
8000347a:	e0 89 00 05 	brgt	80003484 <spi_setupChipReg+0x138>
8000347e:	58 08       	cp.w	r8,0
80003480:	c0 70       	breq	8000348e <spi_setupChipReg+0x142>
80003482:	c1 e8       	rjmp	800034be <spi_setupChipReg+0x172>
80003484:	58 28       	cp.w	r8,2
80003486:	c1 00       	breq	800034a6 <spi_setupChipReg+0x15a>
80003488:	58 38       	cp.w	r8,3
8000348a:	c1 40       	breq	800034b2 <spi_setupChipReg+0x166>
8000348c:	c1 98       	rjmp	800034be <spi_setupChipReg+0x172>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
8000348e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003492:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003496:	91 c9       	st.w	r8[0x30],r9
		break;
80003498:	c1 58       	rjmp	800034c2 <spi_setupChipReg+0x176>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
8000349a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000349e:	ee f8 ff f4 	ld.w	r8,r7[-12]
800034a2:	91 d9       	st.w	r8[0x34],r9
		break;
800034a4:	c0 f8       	rjmp	800034c2 <spi_setupChipReg+0x176>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800034a6:	ee f9 ff f8 	ld.w	r9,r7[-8]
800034aa:	ee f8 ff f4 	ld.w	r8,r7[-12]
800034ae:	91 e9       	st.w	r8[0x38],r9
		break;
800034b0:	c0 98       	rjmp	800034c2 <spi_setupChipReg+0x176>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800034b2:	ee f9 ff f8 	ld.w	r9,r7[-8]
800034b6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800034ba:	91 f9       	st.w	r8[0x3c],r9
		break;
800034bc:	c0 38       	rjmp	800034c2 <spi_setupChipReg+0x176>

	default:
		return SPI_ERROR_ARGUMENT;
800034be:	30 28       	mov	r8,2
800034c0:	c0 28       	rjmp	800034c4 <spi_setupChipReg+0x178>
			}
		}
	}
#endif

	return SPI_OK;
800034c2:	30 08       	mov	r8,0
}
800034c4:	10 9c       	mov	r12,r8
800034c6:	2f bd       	sub	sp,-20
800034c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800034cc:	80 00       	ld.sh	r0,r0[0x0]
800034ce:	30 d2       	mov	r2,13

800034d0 <spi_enable>:

void spi_enable(volatile avr32_spi_t *spi)
{
800034d0:	eb cd 40 80 	pushm	r7,lr
800034d4:	1a 97       	mov	r7,sp
800034d6:	20 1d       	sub	sp,4
800034d8:	ef 4c ff fc 	st.w	r7[-4],r12
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
800034dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034e0:	30 19       	mov	r9,1
800034e2:	91 09       	st.w	r8[0x0],r9
}
800034e4:	2f fd       	sub	sp,-4
800034e6:	e3 cd 80 80 	ldm	sp++,r7,pc

800034ea <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
800034ea:	eb cd 40 80 	pushm	r7,lr
800034ee:	1a 97       	mov	r7,sp
800034f0:	20 3d       	sub	sp,12
800034f2:	ef 4c ff f8 	st.w	r7[-8],r12
800034f6:	16 98       	mov	r8,r11
800034f8:	ef 58 ff f4 	st.h	r7[-12],r8
	uint32_t timeout = SPI_TIMEOUT;
800034fc:	e0 68 3a 98 	mov	r8,15000
80003500:	ef 48 ff fc 	st.w	r7[-4],r8

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80003504:	c0 f8       	rjmp	80003522 <spi_write+0x38>
		if (!timeout--) {
80003506:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000350a:	58 08       	cp.w	r8,0
8000350c:	5f 08       	sreq	r8
8000350e:	5c 58       	castu.b	r8
80003510:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003514:	20 19       	sub	r9,1
80003516:	ef 49 ff fc 	st.w	r7[-4],r9
8000351a:	58 08       	cp.w	r8,0
8000351c:	c0 30       	breq	80003522 <spi_write+0x38>
			return SPI_ERROR_TIMEOUT;
8000351e:	30 18       	mov	r8,1
80003520:	c0 d8       	rjmp	8000353a <spi_write+0x50>

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80003522:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003526:	70 48       	ld.w	r8,r8[0x10]
80003528:	e2 18 00 02 	andl	r8,0x2,COH
8000352c:	ce d0       	breq	80003506 <spi_write+0x1c>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000352e:	ef 19 ff f4 	ld.uh	r9,r7[-12]
80003532:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003536:	91 39       	st.w	r8[0xc],r9

	return SPI_OK;
80003538:	30 08       	mov	r8,0
}
8000353a:	10 9c       	mov	r12,r8
8000353c:	2f dd       	sub	sp,-12
8000353e:	e3 cd 80 80 	ldm	sp++,r7,pc

80003542 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80003542:	eb cd 40 80 	pushm	r7,lr
80003546:	1a 97       	mov	r7,sp
80003548:	20 3d       	sub	sp,12
8000354a:	ef 4c ff f8 	st.w	r7[-8],r12
8000354e:	ef 4b ff f4 	st.w	r7[-12],r11
	unsigned int timeout = SPI_TIMEOUT;
80003552:	e0 68 3a 98 	mov	r8,15000
80003556:	ef 48 ff fc 	st.w	r7[-4],r8

	while ((spi->sr &
8000355a:	c0 f8       	rjmp	80003578 <spi_read+0x36>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
8000355c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003560:	58 08       	cp.w	r8,0
80003562:	5f 08       	sreq	r8
80003564:	5c 58       	castu.b	r8
80003566:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000356a:	20 19       	sub	r9,1
8000356c:	ef 49 ff fc 	st.w	r7[-4],r9
80003570:	58 08       	cp.w	r8,0
80003572:	c0 30       	breq	80003578 <spi_read+0x36>
			return SPI_ERROR_TIMEOUT;
80003574:	30 18       	mov	r8,1
80003576:	c1 18       	rjmp	80003598 <spi_read+0x56>

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80003578:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000357c:	70 48       	ld.w	r8,r8[0x10]
8000357e:	e2 18 02 01 	andl	r8,0x201,COH
80003582:	e0 48 02 01 	cp.w	r8,513
80003586:	ce b1       	brne	8000355c <spi_read+0x1a>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80003588:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000358c:	70 28       	ld.w	r8,r8[0x8]
8000358e:	5c 88       	casts.h	r8
80003590:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003594:	b2 08       	st.h	r9[0x0],r8

	return SPI_OK;
80003596:	30 08       	mov	r8,0
}
80003598:	10 9c       	mov	r12,r8
8000359a:	2f dd       	sub	sp,-12
8000359c:	e3 cd 80 80 	ldm	sp++,r7,pc

800035a0 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern bool sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
800035a0:	eb cd 40 80 	pushm	r7,lr
800035a4:	1a 97       	mov	r7,sp
	}
#endif

	switch (CONFIG_SYSCLK_SOURCE) {
	case SYSCLK_SRC_RCSYS:
		return OSC_SLOW_NOMINAL_HZ;
800035a6:	e0 78 c2 00 	mov	r8,115200

	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
800035aa:	10 9c       	mov	r12,r8
800035ac:	e3 cd 80 80 	ldm	sp++,r7,pc

800035b0 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
800035b0:	eb cd 40 80 	pushm	r7,lr
800035b4:	1a 97       	mov	r7,sp
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_CPU_DIV;
800035b6:	f0 1f 00 04 	mcall	800035c4 <sysclk_get_cpu_hz+0x14>
800035ba:	18 98       	mov	r8,r12
}
800035bc:	10 9c       	mov	r12,r8
800035be:	e3 cd 80 80 	ldm	sp++,r7,pc
800035c2:	00 00       	add	r0,r0
800035c4:	80 00       	ld.sh	r0,r0[0x0]
800035c6:	35 a0       	mov	r0,90

800035c8 <display_init>:

// Include Files
#include "display_init.h"

void display_init(void)
{
800035c8:	eb cd 40 8f 	pushm	r0-r3,r7,lr
800035cc:	1a 97       	mov	r7,sp
800035ce:	21 0d       	sub	sp,64
	volatile avr32_pm_t* pm = &AVR32_PM;
800035d0:	fe 78 0c 00 	mov	r8,-62464
800035d4:	ef 48 ff dc 	st.w	r7[-36],r8
	   .spck_delay           = 0,
	   .trans_delay  		 = 8,
	   .stay_act             = 1,
	   .spi_mode             = 0,
	   .modfdis              = 1
	};
800035d8:	4f 68       	lddpc	r8,800037b0 <display_init+0x1e8>
800035da:	ee ca 00 34 	sub	r10,r7,52
800035de:	10 9b       	mov	r11,r8
800035e0:	f6 e8 00 00 	ld.d	r8,r11[0]
800035e4:	f4 e9 00 00 	st.d	r10[0],r8
800035e8:	f6 e8 00 08 	ld.d	r8,r11[8]
800035ec:	f4 e9 00 08 	st.d	r10[8],r8

	// Switch clock to external 12 MHz crystal
	// 1) Configure OSC0 in crystal mode, external crystal with a FOSC0 Hz frequency.
	pm_enable_osc0_crystal(pm, FOSC0);
800035f0:	e0 6b 1b 00 	mov	r11,6912
800035f4:	ea 1b 00 b7 	orh	r11,0xb7
800035f8:	ee fc ff dc 	ld.w	r12,r7[-36]
800035fc:	f0 1f 00 6e 	mcall	800037b4 <display_init+0x1ec>

	// 2) Enable the OSC0
	pm_enable_clk0(pm, OSC0_STARTUP);
80003600:	30 3b       	mov	r11,3
80003602:	ee fc ff dc 	ld.w	r12,r7[-36]
80003606:	f0 1f 00 6d 	mcall	800037b8 <display_init+0x1f0>

	// 3) Set the main clock source as being OSC0.
	pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
8000360a:	30 1b       	mov	r11,1
8000360c:	ee fc ff dc 	ld.w	r12,r7[-36]
80003610:	f0 1f 00 6b 	mcall	800037bc <display_init+0x1f4>

	// Initialize the delay function
	delay_init(12000000);
	// Delay for a ms, to allow the display to power up properly
	delay_ms(1);
80003614:	f0 1f 00 6b 	mcall	800037c0 <display_init+0x1f8>
80003618:	18 98       	mov	r8,r12
8000361a:	30 19       	mov	r9,1
8000361c:	ef 49 ff e4 	st.w	r7[-28],r9
80003620:	ef 48 ff e0 	st.w	r7[-32],r8
80003624:	ee f8 ff e4 	ld.w	r8,r7[-28]
80003628:	ef 48 ff ec 	st.w	r7[-20],r8
8000362c:	ee f8 ff e0 	ld.w	r8,r7[-32]
80003630:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003634:	ee f0 ff ec 	ld.w	r0,r7[-20]
80003638:	30 01       	mov	r1,0
8000363a:	ee f2 ff e8 	ld.w	r2,r7[-24]
8000363e:	30 03       	mov	r3,0
80003640:	e2 02 02 4a 	mul	r10,r1,r2
80003644:	e6 00 02 48 	mul	r8,r3,r0
80003648:	10 0a       	add	r10,r8
8000364a:	e0 02 06 48 	mulu.d	r8,r0,r2
8000364e:	12 0a       	add	r10,r9
80003650:	14 99       	mov	r9,r10
80003652:	e0 6a 03 e7 	mov	r10,999
80003656:	30 0b       	mov	r11,0
80003658:	f0 0a 00 0a 	add	r10,r8,r10
8000365c:	f2 0b 00 4b 	adc	r11,r9,r11
80003660:	e0 68 03 e8 	mov	r8,1000
80003664:	30 09       	mov	r9,0
80003666:	f0 1f 00 58 	mcall	800037c4 <display_init+0x1fc>
8000366a:	14 98       	mov	r8,r10
8000366c:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000366e:	ef 48 ff f4 	st.w	r7[-12],r8
80003672:	ee c8 00 40 	sub	r8,r7,64
80003676:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000367a:	e1 b8 00 42 	mfsr	r8,0x108
8000367e:	10 99       	mov	r9,r8
80003680:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003684:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003686:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000368a:	70 09       	ld.w	r9,r8[0x0]
8000368c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003690:	10 09       	add	r9,r8
80003692:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003696:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80003698:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000369c:	30 08       	mov	r8,0
8000369e:	f3 68 00 08 	st.b	r9[8],r8
800036a2:	ee c8 00 40 	sub	r8,r7,64
800036a6:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800036aa:	e1 b8 00 42 	mfsr	r8,0x108
800036ae:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800036b2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800036b6:	f1 39 00 08 	ld.ub	r9,r8[8]
800036ba:	30 28       	mov	r8,2
800036bc:	f0 09 18 00 	cp.b	r9,r8
800036c0:	c0 31       	brne	800036c6 <display_init+0xfe>
    return false;
800036c2:	30 08       	mov	r8,0
800036c4:	c4 38       	rjmp	8000374a <display_init+0x182>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800036c6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800036ca:	f1 39 00 08 	ld.ub	r9,r8[8]
800036ce:	30 18       	mov	r8,1
800036d0:	f0 09 18 00 	cp.b	r9,r8
800036d4:	c0 31       	brne	800036da <display_init+0x112>
    return true;
800036d6:	30 18       	mov	r8,1
800036d8:	c3 98       	rjmp	8000374a <display_init+0x182>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800036da:	ee f8 ff f8 	ld.w	r8,r7[-8]
800036de:	70 09       	ld.w	r9,r8[0x0]
800036e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800036e4:	70 18       	ld.w	r8,r8[0x4]
800036e6:	10 39       	cp.w	r9,r8
800036e8:	e0 88 00 1a 	brls	8000371c <display_init+0x154>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800036ec:	ee f8 ff f8 	ld.w	r8,r7[-8]
800036f0:	70 08       	ld.w	r8,r8[0x0]
800036f2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800036f6:	10 39       	cp.w	r9,r8
800036f8:	c1 02       	brcc	80003718 <display_init+0x150>
800036fa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800036fe:	70 18       	ld.w	r8,r8[0x4]
80003700:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003704:	10 39       	cp.w	r9,r8
80003706:	e0 88 00 09 	brls	80003718 <display_init+0x150>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000370a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000370e:	30 18       	mov	r8,1
80003710:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80003714:	30 18       	mov	r8,1
80003716:	c1 a8       	rjmp	8000374a <display_init+0x182>
    }
    return false;
80003718:	30 08       	mov	r8,0
8000371a:	c1 88       	rjmp	8000374a <display_init+0x182>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000371c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003720:	70 08       	ld.w	r8,r8[0x0]
80003722:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003726:	10 39       	cp.w	r9,r8
80003728:	c0 93       	brcs	8000373a <display_init+0x172>
8000372a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000372e:	70 18       	ld.w	r8,r8[0x4]
80003730:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003734:	10 39       	cp.w	r9,r8
80003736:	e0 88 00 09 	brls	80003748 <display_init+0x180>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000373a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000373e:	30 18       	mov	r8,1
80003740:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80003744:	30 18       	mov	r8,1
80003746:	c0 28       	rjmp	8000374a <display_init+0x182>
    }
    return false;
80003748:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
8000374a:	58 08       	cp.w	r8,0
8000374c:	ca b0       	breq	800036a2 <display_init+0xda>

	// Enable the SPI peripheral on GPIO pins
	gpio_enable_module(DIP204_SPI_GPIO_MAP,
8000374e:	30 4b       	mov	r11,4
80003750:	49 ec       	lddpc	r12,800037c8 <display_init+0x200>
80003752:	f0 1f 00 1f 	mcall	800037cc <display_init+0x204>
						sizeof(DIP204_SPI_GPIO_MAP) / 	sizeof(DIP204_SPI_GPIO_MAP[0]));

	// Initialize as SPI master
	spi_initMaster(DIP204_SPI, &spiOptions);
80003756:	ee c8 00 34 	sub	r8,r7,52
8000375a:	10 9b       	mov	r11,r8
8000375c:	fe 7c 28 00 	mov	r12,-55296
80003760:	f0 1f 00 1c 	mcall	800037d0 <display_init+0x208>
	spi_selectionMode(DIP204_SPI, 0, 0, 0);
80003764:	30 09       	mov	r9,0
80003766:	30 0a       	mov	r10,0
80003768:	30 0b       	mov	r11,0
8000376a:	fe 7c 28 00 	mov	r12,-55296
8000376e:	f0 1f 00 1a 	mcall	800037d4 <display_init+0x20c>
	spi_enable(DIP204_SPI);
80003772:	fe 7c 28 00 	mov	r12,-55296
80003776:	f0 1f 00 19 	mcall	800037d8 <display_init+0x210>
	spi_setupChipReg(DIP204_SPI, &spiOptions, FOSC0);
8000377a:	ee c8 00 34 	sub	r8,r7,52
8000377e:	e0 6a 1b 00 	mov	r10,6912
80003782:	ea 1a 00 b7 	orh	r10,0xb7
80003786:	10 9b       	mov	r11,r8
80003788:	fe 7c 28 00 	mov	r12,-55296
8000378c:	f0 1f 00 14 	mcall	800037dc <display_init+0x214>

	dip204_init(backlight_IO, ON);
80003790:	30 1b       	mov	r11,1
80003792:	30 0c       	mov	r12,0
80003794:	f0 1f 00 13 	mcall	800037e0 <display_init+0x218>
	dip204_clear_display();
80003798:	f0 1f 00 13 	mcall	800037e4 <display_init+0x21c>
	dip204_hide_cursor();
8000379c:	f0 1f 00 13 	mcall	800037e8 <display_init+0x220>
	dip204_set_cursor_position(1,1);
800037a0:	30 1b       	mov	r11,1
800037a2:	30 1c       	mov	r12,1
800037a4:	f0 1f 00 12 	mcall	800037ec <display_init+0x224>
}
800037a8:	2f 0d       	sub	sp,-64
800037aa:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
800037ae:	00 00       	add	r0,r0
800037b0:	80 00       	ld.sh	r0,r0[0x0]
800037b2:	72 18       	ld.w	r8,r9[0x4]
800037b4:	80 00       	ld.sh	r0,r0[0x0]
800037b6:	40 f8       	lddsp	r8,sp[0x3c]
800037b8:	80 00       	ld.sh	r0,r0[0x0]
800037ba:	41 5c       	lddsp	r12,sp[0x54]
800037bc:	80 00       	ld.sh	r0,r0[0x0]
800037be:	42 08       	lddsp	r8,sp[0x80]
800037c0:	80 00       	ld.sh	r0,r0[0x0]
800037c2:	35 b0       	mov	r0,91
800037c4:	80 00       	ld.sh	r0,r0[0x0]
800037c6:	61 f4       	ld.w	r4,r0[0x7c]
800037c8:	80 00       	ld.sh	r0,r0[0x0]
800037ca:	72 28       	ld.w	r8,r9[0x8]
800037cc:	80 00       	ld.sh	r0,r0[0x0]
800037ce:	3c 64       	mov	r4,-58
800037d0:	80 00       	ld.sh	r0,r0[0x0]
800037d2:	31 22       	mov	r2,18
800037d4:	80 00       	ld.sh	r0,r0[0x0]
800037d6:	31 b6       	mov	r6,27
800037d8:	80 00       	ld.sh	r0,r0[0x0]
800037da:	34 d0       	mov	r0,77
800037dc:	80 00       	ld.sh	r0,r0[0x0]
800037de:	33 4c       	mov	r12,52
800037e0:	80 00       	ld.sh	r0,r0[0x0]
800037e2:	21 04       	sub	r4,16
800037e4:	80 00       	ld.sh	r0,r0[0x0]
800037e6:	2c 9c       	sub	r12,-55
800037e8:	80 00       	ld.sh	r0,r0[0x0]
800037ea:	2b e0       	sub	r0,-66
800037ec:	80 00       	ld.sh	r0,r0[0x0]
800037ee:	2c 14       	sub	r4,-63

800037f0 <initLED>:
#include "LED.h"

void initLED (void)
{
800037f0:	eb cd 40 80 	pushm	r7,lr
800037f4:	1a 97       	mov	r7,sp
800037f6:	20 1d       	sub	sp,4
	/*
	* First make access to the GPIO port registers
	* shorter to type , just for our convenience
	*/
	volatile avr32_gpio_port_t * led0_port;
	led0_port = &AVR32_GPIO.port[LED0_PORT];
800037f8:	fe 78 11 00 	mov	r8,-61184
800037fc:	ef 48 ff fc 	st.w	r7[-4],r8
	/*
	* Choose GPIO peripheral function ,
	* by writing a 1 to gpers , GPIO Enable Register Set
	*/
	led0_port->gpers = LED0_BIT_VALUE;
80003800:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003804:	fc 19 08 00 	movh	r9,0x800
80003808:	91 19       	st.w	r8[0x4],r9
	led0_port->gpers = LED1_BIT_VALUE;
8000380a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000380e:	fc 19 10 00 	movh	r9,0x1000
80003812:	91 19       	st.w	r8[0x4],r9
	led0_port->gpers = LED2_BIT_VALUE;
80003814:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003818:	fc 19 20 00 	movh	r9,0x2000
8000381c:	91 19       	st.w	r8[0x4],r9
	/*
	* Set the output value register to 1 in order to
	* turn the LED off (1= off , 0= on in this case ) ,
	* by writing a 1 to ovrs , Output Value Register Set
	*/
	led0_port->ovrs = LED0_BIT_VALUE;
8000381e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003822:	fc 19 08 00 	movh	r9,0x800
80003826:	f1 49 00 54 	st.w	r8[84],r9
	led0_port->ovrs = LED1_BIT_VALUE;
8000382a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000382e:	fc 19 10 00 	movh	r9,0x1000
80003832:	f1 49 00 54 	st.w	r8[84],r9
	led0_port->ovrs = LED2_BIT_VALUE;
80003836:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000383a:	fc 19 20 00 	movh	r9,0x2000
8000383e:	f1 49 00 54 	st.w	r8[84],r9
	/*
	* Set the output enable register ,
	* by writing a 1 to oders , Output Drive Enable
	* Register Set
	*/
	led0_port->oders = LED0_BIT_VALUE;
80003842:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003846:	fc 19 08 00 	movh	r9,0x800
8000384a:	f1 49 00 44 	st.w	r8[68],r9
	led0_port->oders = LED1_BIT_VALUE;
8000384e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003852:	fc 19 10 00 	movh	r9,0x1000
80003856:	f1 49 00 44 	st.w	r8[68],r9
	led0_port->oders = LED2_BIT_VALUE;
8000385a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000385e:	fc 19 20 00 	movh	r9,0x2000
80003862:	f1 49 00 44 	st.w	r8[68],r9
}
80003866:	2f fd       	sub	sp,-4
80003868:	e3 cd 80 80 	ldm	sp++,r7,pc

8000386c <onLED>:
{
	AVR32_GPIO.port[LED0_PORT].ovrt = ledNr;
}

void onLED(int ledNr)
{
8000386c:	eb cd 40 80 	pushm	r7,lr
80003870:	1a 97       	mov	r7,sp
80003872:	20 1d       	sub	sp,4
80003874:	ef 4c ff fc 	st.w	r7[-4],r12
	AVR32_GPIO.port[LED0_PORT].ovrc = ledNr;
80003878:	fe 78 10 00 	mov	r8,-61440
8000387c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003880:	f1 49 01 58 	st.w	r8[344],r9
}
80003884:	2f fd       	sub	sp,-4
80003886:	e3 cd 80 80 	ldm	sp++,r7,pc

8000388a <offLED>:

void offLED(int ledNr)
{
8000388a:	eb cd 40 80 	pushm	r7,lr
8000388e:	1a 97       	mov	r7,sp
80003890:	20 1d       	sub	sp,4
80003892:	ef 4c ff fc 	st.w	r7[-4],r12
	AVR32_GPIO.port[LED0_PORT].ovrs = ledNr;
80003896:	fe 78 10 00 	mov	r8,-61440
8000389a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000389e:	f1 49 01 54 	st.w	r8[340],r9
800038a2:	2f fd       	sub	sp,-4
800038a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800038a8:	76 50       	ld.w	r0,r11[0x14]
800038aa:	72 6f       	ld.w	pc,r9[0x18]
800038ac:	64 75       	ld.w	r5,r2[0x1c]
800038ae:	63 65       	ld.w	r5,r1[0x58]
800038b0:	72 00       	ld.w	r0,r9[0x0]
800038b2:	00 00       	add	r0,r0
800038b4:	76 43       	ld.w	r3,r11[0x10]
800038b6:	6f 6e       	ld.w	lr,r7[0x58]
800038b8:	73 75       	ld.w	r5,r9[0x5c]
800038ba:	6d 65       	ld.w	r5,r6[0x58]
800038bc:	72 00       	ld.w	r0,r9[0x0]
	...

800038c0 <init_usart>:
		cycles--;
	}
}

void init_usart ( void )
{
800038c0:	eb cd 40 80 	pushm	r7,lr
800038c4:	1a 97       	mov	r7,sp
		. charlength = 8,
		. paritytype = USART_NO_PARITY ,
		. stopbits = USART_1_STOPBIT ,
		. channelmode = USART_NORMAL_CHMODE
	};
	pm_switch_to_osc0 (& AVR32_PM , FOSC0 , OSC0_STARTUP );
800038c6:	30 3a       	mov	r10,3
800038c8:	e0 6b 1b 00 	mov	r11,6912
800038cc:	ea 1b 00 b7 	orh	r11,0xb7
800038d0:	fe 7c 0c 00 	mov	r12,-62464
800038d4:	f0 1f 00 0f 	mcall	80003910 <init_usart+0x50>
	gpio_enable_module ( USART_SERIAL_GPIO_MAP , 2);
800038d8:	30 2b       	mov	r11,2
800038da:	48 fc       	lddpc	r12,80003914 <init_usart+0x54>
800038dc:	f0 1f 00 0f 	mcall	80003918 <init_usart+0x58>
	gpio_enable_module ( USART_DEBUG_GPIO_MAP , 2);
800038e0:	30 2b       	mov	r11,2
800038e2:	48 fc       	lddpc	r12,8000391c <init_usart+0x5c>
800038e4:	f0 1f 00 0d 	mcall	80003918 <init_usart+0x58>
	usart_init_rs232 ( serialPORT_USART , & USART_OPTIONS , FOSC0 );
800038e8:	e0 6a 1b 00 	mov	r10,6912
800038ec:	ea 1a 00 b7 	orh	r10,0xb7
800038f0:	48 cb       	lddpc	r11,80003920 <init_usart+0x60>
800038f2:	fe 7c 18 00 	mov	r12,-59392
800038f6:	f0 1f 00 0c 	mcall	80003924 <init_usart+0x64>
	usart_init_rs232 ( configDBG_USART , & USART_OPTIONS , FOSC0 );
800038fa:	e0 6a 1b 00 	mov	r10,6912
800038fe:	ea 1a 00 b7 	orh	r10,0xb7
80003902:	48 8b       	lddpc	r11,80003920 <init_usart+0x60>
80003904:	fe 7c 18 00 	mov	r12,-59392
80003908:	f0 1f 00 07 	mcall	80003924 <init_usart+0x64>
}
8000390c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003910:	80 00       	ld.sh	r0,r0[0x0]
80003912:	42 54       	lddsp	r4,sp[0x94]
80003914:	80 00       	ld.sh	r0,r0[0x0]
80003916:	72 48       	ld.w	r8,r9[0x10]
80003918:	80 00       	ld.sh	r0,r0[0x0]
8000391a:	3c 64       	mov	r4,-58
8000391c:	80 00       	ld.sh	r0,r0[0x0]
8000391e:	72 58       	ld.w	r8,r9[0x14]
80003920:	80 00       	ld.sh	r0,r0[0x0]
80003922:	72 68       	ld.w	r8,r9[0x18]
80003924:	80 00       	ld.sh	r0,r0[0x0]
80003926:	44 04       	lddsp	r4,sp[0x100]

80003928 <vProducer>:

void vProducer(void *pvParameters)
{	
80003928:	eb cd 40 80 	pushm	r7,lr
8000392c:	1a 97       	mov	r7,sp
8000392e:	20 dd       	sub	sp,52
80003930:	ef 4c ff cc 	st.w	r7[-52],r12
	portTickType xLastWakeTime;
	const portTickType xFreq = TASK_DELAY_MS(1000);
80003934:	e0 68 03 e8 	mov	r8,1000
80003938:	ef 48 ff f8 	st.w	r7[-8],r8
	
	xLastWakeTime = xTaskGetTickCount();
8000393c:	f0 1f 00 45 	mcall	80003a50 <vProducer+0x128>
80003940:	18 98       	mov	r8,r12
80003942:	ef 48 ff f4 	st.w	r7[-12],r8
	
	struct msg message;
	message.id = 0;
80003946:	30 08       	mov	r8,0
80003948:	ef 48 ff e0 	st.w	r7[-32],r8
	//message.data = 0;
	message.timestamp = 0;
8000394c:	30 08       	mov	r8,0
8000394e:	ef 48 ff f0 	st.w	r7[-16],r8
	
	struct msg *pMesg = &message;
80003952:	ee c8 00 20 	sub	r8,r7,32
80003956:	ef 48 ff dc 	st.w	r7[-36],r8
	
	char data[DATALEN] = "hej\n";
8000395a:	30 08       	mov	r8,0
8000395c:	e0 69 6a 0a 	mov	r9,27146
80003960:	ea 19 68 65 	orh	r9,0x6865
80003964:	ee e9 ff d0 	st.d	r7[-48],r8
80003968:	30 08       	mov	r8,0
8000396a:	ef 58 ff d8 	st.h	r7[-40],r8
	int i = byteCount;
8000396e:	4b a8       	lddpc	r8,80003a54 <vProducer+0x12c>
80003970:	70 08       	ld.w	r8,r8[0x0]
80003972:	ef 48 ff fc 	st.w	r7[-4],r8
	
	onLED(LED0_BIT_VALUE);
80003976:	fc 1c 08 00 	movh	r12,0x800
8000397a:	f0 1f 00 38 	mcall	80003a58 <vProducer+0x130>
8000397e:	c0 28       	rjmp	80003982 <vProducer+0x5a>
				//Successfully given back
				//usart_write_line(serialPORT_USART,"PRODUCER2 Semaphore GIVEN\n");
			}
		}
		
	}
80003980:	d7 03       	nop
	
	onLED(LED0_BIT_VALUE);
	
	while(1)
	{
		if(xSemaphoreTake(xSemaphore, (portTickType)portMAX_DELAY) == pdTRUE)
80003982:	4b 78       	lddpc	r8,80003a5c <vProducer+0x134>
80003984:	70 08       	ld.w	r8,r8[0x0]
80003986:	30 09       	mov	r9,0
80003988:	3f fa       	mov	r10,-1
8000398a:	30 0b       	mov	r11,0
8000398c:	10 9c       	mov	r12,r8
8000398e:	f0 1f 00 35 	mcall	80003a60 <vProducer+0x138>
80003992:	18 98       	mov	r8,r12
80003994:	58 18       	cp.w	r8,1
80003996:	c2 41       	brne	800039de <vProducer+0xb6>
		{
			//usart_write_line(serialPORT_USART,"PRODUCER1 Semaphore TAKEN\n");
			if(byteCount == BUFFER_SIZE)
80003998:	4a f8       	lddpc	r8,80003a54 <vProducer+0x12c>
8000399a:	70 08       	ld.w	r8,r8[0x0]
8000399c:	58 a8       	cp.w	r8,10
8000399e:	c1 81       	brne	800039ce <vProducer+0xa6>
			{
				vTaskPrioritySet(NULL, 2);
800039a0:	30 2b       	mov	r11,2
800039a2:	30 0c       	mov	r12,0
800039a4:	f0 1f 00 30 	mcall	80003a64 <vProducer+0x13c>
				
				offLED(LED0_BIT_VALUE);
800039a8:	fc 1c 08 00 	movh	r12,0x800
800039ac:	f0 1f 00 2f 	mcall	80003a68 <vProducer+0x140>
				if(xSemaphoreGive(xSemaphore) == pdTRUE)
800039b0:	4a b8       	lddpc	r8,80003a5c <vProducer+0x134>
800039b2:	70 08       	ld.w	r8,r8[0x0]
800039b4:	30 09       	mov	r9,0
800039b6:	30 0a       	mov	r10,0
800039b8:	30 0b       	mov	r11,0
800039ba:	10 9c       	mov	r12,r8
800039bc:	f0 1f 00 2c 	mcall	80003a6c <vProducer+0x144>
				{
					//Successfully given back
					//usart_write_line(serialPORT_USART,"PRODUCER1 Semaphore GIVEN\n");
				}
				vTaskSuspend(NULL);
800039c0:	30 0c       	mov	r12,0
800039c2:	f0 1f 00 2c 	mcall	80003a70 <vProducer+0x148>
				vTaskPrioritySet(NULL, 1);
800039c6:	30 1b       	mov	r11,1
800039c8:	30 0c       	mov	r12,0
800039ca:	f0 1f 00 27 	mcall	80003a64 <vProducer+0x13c>
			}
			if(xSemaphoreGive(xSemaphore) == pdTRUE)
800039ce:	4a 48       	lddpc	r8,80003a5c <vProducer+0x134>
800039d0:	70 08       	ld.w	r8,r8[0x0]
800039d2:	30 09       	mov	r9,0
800039d4:	30 0a       	mov	r10,0
800039d6:	30 0b       	mov	r11,0
800039d8:	10 9c       	mov	r12,r8
800039da:	f0 1f 00 25 	mcall	80003a6c <vProducer+0x144>
				//usart_write_line(serialPORT_USART,"PRODUCER1 Semaphore GIVEN\n");
			}
		}
		
		
		strcpy(pMesg->data, data);
800039de:	ee f8 ff dc 	ld.w	r8,r7[-36]
800039e2:	2f c8       	sub	r8,-4
800039e4:	ee c9 00 30 	sub	r9,r7,48
800039e8:	12 9b       	mov	r11,r9
800039ea:	10 9c       	mov	r12,r8
800039ec:	f0 1f 00 22 	mcall	80003a74 <vProducer+0x14c>
		
		xQueueSendToBack(xQHandle, &pMesg, (portTickType)10);
800039f0:	4a 28       	lddpc	r8,80003a78 <vProducer+0x150>
800039f2:	70 08       	ld.w	r8,r8[0x0]
800039f4:	ee cb 00 24 	sub	r11,r7,36
800039f8:	30 09       	mov	r9,0
800039fa:	30 aa       	mov	r10,10
800039fc:	10 9c       	mov	r12,r8
800039fe:	f0 1f 00 1c 	mcall	80003a6c <vProducer+0x144>
		
		if(xSemaphoreTake(xSemaphore, (portTickType)portMAX_DELAY) == pdTRUE)
80003a02:	49 78       	lddpc	r8,80003a5c <vProducer+0x134>
80003a04:	70 08       	ld.w	r8,r8[0x0]
80003a06:	30 09       	mov	r9,0
80003a08:	3f fa       	mov	r10,-1
80003a0a:	30 0b       	mov	r11,0
80003a0c:	10 9c       	mov	r12,r8
80003a0e:	f0 1f 00 15 	mcall	80003a60 <vProducer+0x138>
80003a12:	18 98       	mov	r8,r12
80003a14:	58 18       	cp.w	r8,1
80003a16:	cb 51       	brne	80003980 <vProducer+0x58>
		{
			//usart_write_line(serialPORT_USART,"PRODUCER2 Semaphore TAKEN\n");
			byteCount++;
80003a18:	48 f8       	lddpc	r8,80003a54 <vProducer+0x12c>
80003a1a:	70 08       	ld.w	r8,r8[0x0]
80003a1c:	f0 c9 ff ff 	sub	r9,r8,-1
80003a20:	48 d8       	lddpc	r8,80003a54 <vProducer+0x12c>
80003a22:	91 09       	st.w	r8[0x0],r9
			
			if(byteCount == 1)
80003a24:	48 c8       	lddpc	r8,80003a54 <vProducer+0x12c>
80003a26:	70 08       	ld.w	r8,r8[0x0]
80003a28:	58 18       	cp.w	r8,1
80003a2a:	c0 a1       	brne	80003a3e <vProducer+0x116>
			{
				vTaskResume(xHandleConsumer);
80003a2c:	49 48       	lddpc	r8,80003a7c <vProducer+0x154>
80003a2e:	70 08       	ld.w	r8,r8[0x0]
80003a30:	10 9c       	mov	r12,r8
80003a32:	f0 1f 00 14 	mcall	80003a80 <vProducer+0x158>
				onLED(LED1_BIT_VALUE);
80003a36:	fc 1c 10 00 	movh	r12,0x1000
80003a3a:	f0 1f 00 08 	mcall	80003a58 <vProducer+0x130>
			}
			if(xSemaphoreGive(xSemaphore) == pdTRUE)
80003a3e:	48 88       	lddpc	r8,80003a5c <vProducer+0x134>
80003a40:	70 08       	ld.w	r8,r8[0x0]
80003a42:	30 09       	mov	r9,0
80003a44:	30 0a       	mov	r10,0
80003a46:	30 0b       	mov	r11,0
80003a48:	10 9c       	mov	r12,r8
80003a4a:	f0 1f 00 09 	mcall	80003a6c <vProducer+0x144>
				//Successfully given back
				//usart_write_line(serialPORT_USART,"PRODUCER2 Semaphore GIVEN\n");
			}
		}
		
	}
80003a4e:	c9 ab       	rjmp	80003982 <vProducer+0x5a>
80003a50:	80 00       	ld.sh	r0,r0[0x0]
80003a52:	5a 34       	cp.w	r4,-29
80003a54:	00 00       	add	r0,r0
80003a56:	05 70       	ld.ub	r0,--r2
80003a58:	80 00       	ld.sh	r0,r0[0x0]
80003a5a:	38 6c       	mov	r12,-122
80003a5c:	00 00       	add	r0,r0
80003a5e:	07 e0       	ld.ub	r0,r3[0x6]
80003a60:	80 00       	ld.sh	r0,r0[0x0]
80003a62:	4f 5c       	lddpc	r12,80003c34 <main+0x94>
80003a64:	80 00       	ld.sh	r0,r0[0x0]
80003a66:	55 68       	stdsp	sp[0x158],r8
80003a68:	80 00       	ld.sh	r0,r0[0x0]
80003a6a:	38 8a       	mov	r10,-120
80003a6c:	80 00       	ld.sh	r0,r0[0x0]
80003a6e:	4d f4       	lddpc	r4,80003be8 <main+0x48>
80003a70:	80 00       	ld.sh	r0,r0[0x0]
80003a72:	56 b0       	stdsp	sp[0x1ac],r0
80003a74:	80 00       	ld.sh	r0,r0[0x0]
80003a76:	6a 54       	ld.w	r4,r5[0x14]
80003a78:	00 00       	add	r0,r0
80003a7a:	07 d4       	ld.ub	r4,r3[0x5]
80003a7c:	00 00       	add	r0,r0
80003a7e:	07 d8       	ld.ub	r8,r3[0x5]
80003a80:	80 00       	ld.sh	r0,r0[0x0]
80003a82:	57 c8       	stdsp	sp[0x1f0],r8

80003a84 <vConsumer>:
}

void vConsumer( void *pvParameters )
{
80003a84:	eb cd 40 80 	pushm	r7,lr
80003a88:	1a 97       	mov	r7,sp
80003a8a:	20 5d       	sub	sp,20
80003a8c:	ef 4c ff ec 	st.w	r7[-20],r12
	portTickType xLastWakeTime;
	const portTickType xFreq = TASK_DELAY_MS(10000);
80003a90:	e0 68 27 10 	mov	r8,10000
80003a94:	ef 48 ff fc 	st.w	r7[-4],r8
	volatile portTickType elapsed;
	
	struct msg *pMesg;
	
	onLED(LED1_BIT_VALUE);
80003a98:	fc 1c 10 00 	movh	r12,0x1000
80003a9c:	f0 1f 00 35 	mcall	80003b70 <vConsumer+0xec>
80003aa0:	c0 28       	rjmp	80003aa4 <vConsumer+0x20>
			{
				//Successfully given back
				//usart_write_line(serialPORT_USART,"CONSUMER2 Semaphore TAKEN\n");
			}
		}
	}
80003aa2:	d7 03       	nop
	
	onLED(LED1_BIT_VALUE);
	
	while(1)
	{
		if(xSemaphoreTake(xSemaphore, (portTickType)portMAX_DELAY) == pdTRUE)
80003aa4:	4b 48       	lddpc	r8,80003b74 <vConsumer+0xf0>
80003aa6:	70 08       	ld.w	r8,r8[0x0]
80003aa8:	30 09       	mov	r9,0
80003aaa:	3f fa       	mov	r10,-1
80003aac:	30 0b       	mov	r11,0
80003aae:	10 9c       	mov	r12,r8
80003ab0:	f0 1f 00 32 	mcall	80003b78 <vConsumer+0xf4>
80003ab4:	18 98       	mov	r8,r12
80003ab6:	58 18       	cp.w	r8,1
80003ab8:	c2 41       	brne	80003b00 <vConsumer+0x7c>
		{
			//usart_write_line(serialPORT_USART,"CONSUMER1 Semaphore TAKEN\n");
			if(byteCount == 0)
80003aba:	4b 18       	lddpc	r8,80003b7c <vConsumer+0xf8>
80003abc:	70 08       	ld.w	r8,r8[0x0]
80003abe:	58 08       	cp.w	r8,0
80003ac0:	c1 81       	brne	80003af0 <vConsumer+0x6c>
			{
				vTaskPrioritySet(NULL, 2);
80003ac2:	30 2b       	mov	r11,2
80003ac4:	30 0c       	mov	r12,0
80003ac6:	f0 1f 00 2f 	mcall	80003b80 <vConsumer+0xfc>
				
				offLED(LED1_BIT_VALUE);
80003aca:	fc 1c 10 00 	movh	r12,0x1000
80003ace:	f0 1f 00 2e 	mcall	80003b84 <vConsumer+0x100>
				if(xSemaphoreGive(xSemaphore) == pdTRUE)
80003ad2:	4a 98       	lddpc	r8,80003b74 <vConsumer+0xf0>
80003ad4:	70 08       	ld.w	r8,r8[0x0]
80003ad6:	30 09       	mov	r9,0
80003ad8:	30 0a       	mov	r10,0
80003ada:	30 0b       	mov	r11,0
80003adc:	10 9c       	mov	r12,r8
80003ade:	f0 1f 00 2b 	mcall	80003b88 <vConsumer+0x104>
				{
					//Successfully given back
					//usart_write_line(serialPORT_USART,"CONSUMER1 Semaphore GIVEN\n");
				}
				vTaskSuspend(NULL);
80003ae2:	30 0c       	mov	r12,0
80003ae4:	f0 1f 00 2a 	mcall	80003b8c <vConsumer+0x108>
							
				vTaskPrioritySet(NULL, 1);
80003ae8:	30 1b       	mov	r11,1
80003aea:	30 0c       	mov	r12,0
80003aec:	f0 1f 00 25 	mcall	80003b80 <vConsumer+0xfc>
			}
			if(xSemaphoreGive(xSemaphore) == pdTRUE)
80003af0:	4a 18       	lddpc	r8,80003b74 <vConsumer+0xf0>
80003af2:	70 08       	ld.w	r8,r8[0x0]
80003af4:	30 09       	mov	r9,0
80003af6:	30 0a       	mov	r10,0
80003af8:	30 0b       	mov	r11,0
80003afa:	10 9c       	mov	r12,r8
80003afc:	f0 1f 00 23 	mcall	80003b88 <vConsumer+0x104>
					//Successfully given back
					//usart_write_line(serialPORT_USART,"CONSUMER1 Semaphore GIVEN\n");
			}
		}
			
		xQueueReceive(xQHandle, &pMesg, (portTickType)10);
80003b00:	4a 48       	lddpc	r8,80003b90 <vConsumer+0x10c>
80003b02:	70 08       	ld.w	r8,r8[0x0]
80003b04:	ee cb 00 10 	sub	r11,r7,16
80003b08:	30 09       	mov	r9,0
80003b0a:	30 aa       	mov	r10,10
80003b0c:	10 9c       	mov	r12,r8
80003b0e:	f0 1f 00 1b 	mcall	80003b78 <vConsumer+0xf4>
		usart_write_line(serialPORT_USART, pMesg->data);
80003b12:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003b16:	2f c8       	sub	r8,-4
80003b18:	10 9b       	mov	r11,r8
80003b1a:	fe 7c 18 00 	mov	r12,-59392
80003b1e:	f0 1f 00 1e 	mcall	80003b94 <vConsumer+0x110>
		
		
		
		if(xSemaphoreTake(xSemaphore, (portTickType)portMAX_DELAY) == pdTRUE)
80003b22:	49 58       	lddpc	r8,80003b74 <vConsumer+0xf0>
80003b24:	70 08       	ld.w	r8,r8[0x0]
80003b26:	30 09       	mov	r9,0
80003b28:	3f fa       	mov	r10,-1
80003b2a:	30 0b       	mov	r11,0
80003b2c:	10 9c       	mov	r12,r8
80003b2e:	f0 1f 00 13 	mcall	80003b78 <vConsumer+0xf4>
80003b32:	18 98       	mov	r8,r12
80003b34:	58 18       	cp.w	r8,1
80003b36:	cb 61       	brne	80003aa2 <vConsumer+0x1e>
		{
			//usart_write_line(serialPORT_USART,"CONSUMER2 Semaphore TAKEN\n");
			byteCount--;
80003b38:	49 18       	lddpc	r8,80003b7c <vConsumer+0xf8>
80003b3a:	70 08       	ld.w	r8,r8[0x0]
80003b3c:	f0 c9 00 01 	sub	r9,r8,1
80003b40:	48 f8       	lddpc	r8,80003b7c <vConsumer+0xf8>
80003b42:	91 09       	st.w	r8[0x0],r9
			
			if(byteCount == BUFFER_SIZE - 1)
80003b44:	48 e8       	lddpc	r8,80003b7c <vConsumer+0xf8>
80003b46:	70 08       	ld.w	r8,r8[0x0]
80003b48:	58 98       	cp.w	r8,9
80003b4a:	c0 a1       	brne	80003b5e <vConsumer+0xda>
			{
				vTaskResume(xHandleProducer);
80003b4c:	49 38       	lddpc	r8,80003b98 <vConsumer+0x114>
80003b4e:	70 08       	ld.w	r8,r8[0x0]
80003b50:	10 9c       	mov	r12,r8
80003b52:	f0 1f 00 13 	mcall	80003b9c <vConsumer+0x118>
				onLED(LED0_BIT_VALUE);
80003b56:	fc 1c 08 00 	movh	r12,0x800
80003b5a:	f0 1f 00 06 	mcall	80003b70 <vConsumer+0xec>
			}
			if(xSemaphoreGive(xSemaphore) == pdTRUE)
80003b5e:	48 68       	lddpc	r8,80003b74 <vConsumer+0xf0>
80003b60:	70 08       	ld.w	r8,r8[0x0]
80003b62:	30 09       	mov	r9,0
80003b64:	30 0a       	mov	r10,0
80003b66:	30 0b       	mov	r11,0
80003b68:	10 9c       	mov	r12,r8
80003b6a:	f0 1f 00 08 	mcall	80003b88 <vConsumer+0x104>
			{
				//Successfully given back
				//usart_write_line(serialPORT_USART,"CONSUMER2 Semaphore TAKEN\n");
			}
		}
	}
80003b6e:	c9 bb       	rjmp	80003aa4 <vConsumer+0x20>
80003b70:	80 00       	ld.sh	r0,r0[0x0]
80003b72:	38 6c       	mov	r12,-122
80003b74:	00 00       	add	r0,r0
80003b76:	07 e0       	ld.ub	r0,r3[0x6]
80003b78:	80 00       	ld.sh	r0,r0[0x0]
80003b7a:	4f 5c       	lddpc	r12,80003d4c <gpio_enable_module_pin+0x78>
80003b7c:	00 00       	add	r0,r0
80003b7e:	05 70       	ld.ub	r0,--r2
80003b80:	80 00       	ld.sh	r0,r0[0x0]
80003b82:	55 68       	stdsp	sp[0x158],r8
80003b84:	80 00       	ld.sh	r0,r0[0x0]
80003b86:	38 8a       	mov	r10,-120
80003b88:	80 00       	ld.sh	r0,r0[0x0]
80003b8a:	4d f4       	lddpc	r4,80003d04 <gpio_enable_module_pin+0x30>
80003b8c:	80 00       	ld.sh	r0,r0[0x0]
80003b8e:	56 b0       	stdsp	sp[0x1ac],r0
80003b90:	00 00       	add	r0,r0
80003b92:	07 d4       	ld.ub	r4,r3[0x5]
80003b94:	80 00       	ld.sh	r0,r0[0x0]
80003b96:	46 0c       	lddsp	r12,sp[0x180]
80003b98:	00 00       	add	r0,r0
80003b9a:	07 dc       	ld.ub	r12,r3[0x5]
80003b9c:	80 00       	ld.sh	r0,r0[0x0]
80003b9e:	57 c8       	stdsp	sp[0x1f0],r8

80003ba0 <main>:
}

int main(void)
{
80003ba0:	eb cd 40 80 	pushm	r7,lr
80003ba4:	1a 97       	mov	r7,sp
	initLED();
80003ba6:	f0 1f 00 21 	mcall	80003c28 <main+0x88>
	init_usart();
80003baa:	f0 1f 00 21 	mcall	80003c2c <main+0x8c>
	display_init();
80003bae:	f0 1f 00 21 	mcall	80003c30 <main+0x90>

	static unsigned char ucParameterToPass ;
	
	vSemaphoreCreateBinary(xSemaphore);
80003bb2:	30 0b       	mov	r11,0
80003bb4:	30 1c       	mov	r12,1
80003bb6:	f0 1f 00 20 	mcall	80003c34 <main+0x94>
80003bba:	18 99       	mov	r9,r12
80003bbc:	49 f8       	lddpc	r8,80003c38 <main+0x98>
80003bbe:	91 09       	st.w	r8[0x0],r9
80003bc0:	49 e8       	lddpc	r8,80003c38 <main+0x98>
80003bc2:	70 08       	ld.w	r8,r8[0x0]
80003bc4:	58 08       	cp.w	r8,0
80003bc6:	c0 90       	breq	80003bd8 <main+0x38>
80003bc8:	49 c8       	lddpc	r8,80003c38 <main+0x98>
80003bca:	70 08       	ld.w	r8,r8[0x0]
80003bcc:	30 09       	mov	r9,0
80003bce:	30 0a       	mov	r10,0
80003bd0:	30 0b       	mov	r11,0
80003bd2:	10 9c       	mov	r12,r8
80003bd4:	f0 1f 00 1a 	mcall	80003c3c <main+0x9c>
	
	xQHandle = xQueueCreate(10, sizeof(struct msg*));
80003bd8:	30 4b       	mov	r11,4
80003bda:	30 ac       	mov	r12,10
80003bdc:	f0 1f 00 16 	mcall	80003c34 <main+0x94>
80003be0:	18 99       	mov	r9,r12
80003be2:	49 88       	lddpc	r8,80003c40 <main+0xa0>
80003be4:	91 09       	st.w	r8[0x0],r9
		//ERROR!
	}
	
	
	// Create the task , store the handle .
	xTaskCreate(	vProducer,
80003be6:	49 8b       	lddpc	r11,80003c44 <main+0xa4>
80003be8:	30 08       	mov	r8,0
80003bea:	1a d8       	st.w	--sp,r8
80003bec:	30 08       	mov	r8,0
80003bee:	1a d8       	st.w	--sp,r8
80003bf0:	49 68       	lddpc	r8,80003c48 <main+0xa8>
80003bf2:	1a d8       	st.w	--sp,r8
80003bf4:	30 18       	mov	r8,1
80003bf6:	30 09       	mov	r9,0
80003bf8:	e0 6a 01 00 	mov	r10,256
80003bfc:	49 4c       	lddpc	r12,80003c4c <main+0xac>
80003bfe:	f0 1f 00 15 	mcall	80003c50 <main+0xb0>
80003c02:	2f dd       	sub	sp,-12
					"vProducer",
					configMINIMAL_STACK_SIZE,
					NULL,
					1,
					&xHandleProducer);
	xTaskCreate(	vConsumer, "vConsumer", configMINIMAL_STACK_SIZE, NULL, 1, &xHandleConsumer);
80003c04:	49 4b       	lddpc	r11,80003c54 <main+0xb4>
80003c06:	30 08       	mov	r8,0
80003c08:	1a d8       	st.w	--sp,r8
80003c0a:	30 08       	mov	r8,0
80003c0c:	1a d8       	st.w	--sp,r8
80003c0e:	49 38       	lddpc	r8,80003c58 <main+0xb8>
80003c10:	1a d8       	st.w	--sp,r8
80003c12:	30 18       	mov	r8,1
80003c14:	30 09       	mov	r9,0
80003c16:	e0 6a 01 00 	mov	r10,256
80003c1a:	49 1c       	lddpc	r12,80003c5c <main+0xbc>
80003c1c:	f0 1f 00 0d 	mcall	80003c50 <main+0xb0>
80003c20:	2f dd       	sub	sp,-12
	
	
	
	vTaskStartScheduler();
80003c22:	f0 1f 00 10 	mcall	80003c60 <main+0xc0>

	
	for( ;; )
	{
		
	}
80003c26:	c0 08       	rjmp	80003c26 <main+0x86>
80003c28:	80 00       	ld.sh	r0,r0[0x0]
80003c2a:	37 f0       	mov	r0,127
80003c2c:	80 00       	ld.sh	r0,r0[0x0]
80003c2e:	38 c0       	mov	r0,-116
80003c30:	80 00       	ld.sh	r0,r0[0x0]
80003c32:	35 c8       	mov	r8,92
80003c34:	80 00       	ld.sh	r0,r0[0x0]
80003c36:	4c dc       	lddpc	r12,80003d68 <gpio_enable_module_pin+0x94>
80003c38:	00 00       	add	r0,r0
80003c3a:	07 e0       	ld.ub	r0,r3[0x6]
80003c3c:	80 00       	ld.sh	r0,r0[0x0]
80003c3e:	4d f4       	lddpc	r4,80003db8 <gpio_enable_module_pin+0xe4>
80003c40:	00 00       	add	r0,r0
80003c42:	07 d4       	ld.ub	r4,r3[0x5]
80003c44:	80 00       	ld.sh	r0,r0[0x0]
80003c46:	38 a8       	mov	r8,-118
80003c48:	00 00       	add	r0,r0
80003c4a:	07 dc       	ld.ub	r12,r3[0x5]
80003c4c:	80 00       	ld.sh	r0,r0[0x0]
80003c4e:	39 28       	mov	r8,-110
80003c50:	80 00       	ld.sh	r0,r0[0x0]
80003c52:	53 a0       	stdsp	sp[0xe8],r0
80003c54:	80 00       	ld.sh	r0,r0[0x0]
80003c56:	38 b4       	mov	r4,-117
80003c58:	00 00       	add	r0,r0
80003c5a:	07 d8       	ld.ub	r8,r3[0x5]
80003c5c:	80 00       	ld.sh	r0,r0[0x0]
80003c5e:	3a 84       	mov	r4,-88
80003c60:	80 00       	ld.sh	r0,r0[0x0]
80003c62:	58 8c       	cp.w	r12,8

80003c64 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80003c64:	eb cd 40 80 	pushm	r7,lr
80003c68:	1a 97       	mov	r7,sp
80003c6a:	20 4d       	sub	sp,16
80003c6c:	ef 4c ff f4 	st.w	r7[-12],r12
80003c70:	ef 4b ff f0 	st.w	r7[-16],r11
	uint32_t status = GPIO_SUCCESS;
80003c74:	30 08       	mov	r8,0
80003c76:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t i;

	for (i = 0; i < size; i++) {
80003c7a:	30 08       	mov	r8,0
80003c7c:	ef 48 ff fc 	st.w	r7[-4],r8
80003c80:	c1 c8       	rjmp	80003cb8 <gpio_enable_module+0x54>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80003c82:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003c86:	70 19       	ld.w	r9,r8[0x4]
80003c88:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003c8c:	70 08       	ld.w	r8,r8[0x0]
80003c8e:	12 9b       	mov	r11,r9
80003c90:	10 9c       	mov	r12,r8
80003c92:	f0 1f 00 10 	mcall	80003cd0 <gpio_enable_module+0x6c>
80003c96:	18 98       	mov	r8,r12
80003c98:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003c9c:	f3 e8 10 08 	or	r8,r9,r8
80003ca0:	ef 48 ff f8 	st.w	r7[-8],r8
		gpiomap++;
80003ca4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003ca8:	2f 88       	sub	r8,-8
80003caa:	ef 48 ff f4 	st.w	r7[-12],r8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80003cae:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003cb2:	2f f8       	sub	r8,-1
80003cb4:	ef 48 ff fc 	st.w	r7[-4],r8
80003cb8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003cbc:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003cc0:	10 39       	cp.w	r9,r8
80003cc2:	ce 03       	brcs	80003c82 <gpio_enable_module+0x1e>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
80003cc4:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80003cc8:	10 9c       	mov	r12,r8
80003cca:	2f cd       	sub	sp,-16
80003ccc:	e3 cd 80 80 	ldm	sp++,r7,pc
80003cd0:	80 00       	ld.sh	r0,r0[0x0]
80003cd2:	3c d4       	mov	r4,-51

80003cd4 <gpio_enable_module_pin>:
 * \param function The pin function.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
80003cd4:	eb cd 40 80 	pushm	r7,lr
80003cd8:	1a 97       	mov	r7,sp
80003cda:	20 3d       	sub	sp,12
80003cdc:	ef 4c ff f8 	st.w	r7[-8],r12
80003ce0:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80003ce4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003ce8:	a5 98       	lsr	r8,0x5
80003cea:	a9 68       	lsl	r8,0x8
80003cec:	e0 28 f0 00 	sub	r8,61440
80003cf0:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Enable the correct function. */
	switch (function) {
80003cf4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003cf8:	58 18       	cp.w	r8,1
80003cfa:	c1 e0       	breq	80003d36 <gpio_enable_module_pin+0x62>
80003cfc:	c0 63       	brcs	80003d08 <gpio_enable_module_pin+0x34>
80003cfe:	58 28       	cp.w	r8,2
80003d00:	c3 20       	breq	80003d64 <gpio_enable_module_pin+0x90>
80003d02:	58 38       	cp.w	r8,3
80003d04:	c4 70       	breq	80003d92 <gpio_enable_module_pin+0xbe>
80003d06:	c5 d8       	rjmp	80003dc0 <gpio_enable_module_pin+0xec>
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80003d08:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d0c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003d10:	30 19       	mov	r9,1
80003d12:	f2 08 09 48 	lsl	r8,r9,r8
80003d16:	10 99       	mov	r9,r8
80003d18:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d1c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80003d1e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d22:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003d26:	30 19       	mov	r9,1
80003d28:	f2 08 09 48 	lsl	r8,r9,r8
80003d2c:	10 99       	mov	r9,r8
80003d2e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d32:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80003d34:	c4 88       	rjmp	80003dc4 <gpio_enable_module_pin+0xf0>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80003d36:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d3a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003d3e:	30 19       	mov	r9,1
80003d40:	f2 08 09 48 	lsl	r8,r9,r8
80003d44:	10 99       	mov	r9,r8
80003d46:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d4a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80003d4c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d50:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003d54:	30 19       	mov	r9,1
80003d56:	f2 08 09 48 	lsl	r8,r9,r8
80003d5a:	10 99       	mov	r9,r8
80003d5c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d60:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80003d62:	c3 18       	rjmp	80003dc4 <gpio_enable_module_pin+0xf0>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80003d64:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d68:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003d6c:	30 19       	mov	r9,1
80003d6e:	f2 08 09 48 	lsl	r8,r9,r8
80003d72:	10 99       	mov	r9,r8
80003d74:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d78:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80003d7a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d7e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003d82:	30 19       	mov	r9,1
80003d84:	f2 08 09 48 	lsl	r8,r9,r8
80003d88:	10 99       	mov	r9,r8
80003d8a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d8e:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80003d90:	c1 a8       	rjmp	80003dc4 <gpio_enable_module_pin+0xf0>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80003d92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d96:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003d9a:	30 19       	mov	r9,1
80003d9c:	f2 08 09 48 	lsl	r8,r9,r8
80003da0:	10 99       	mov	r9,r8
80003da2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003da6:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80003da8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003dac:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003db0:	30 19       	mov	r9,1
80003db2:	f2 08 09 48 	lsl	r8,r9,r8
80003db6:	10 99       	mov	r9,r8
80003db8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003dbc:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80003dbe:	c0 38       	rjmp	80003dc4 <gpio_enable_module_pin+0xf0>
		gpio_port->pmr2s = 1 << (pin & 0x1F);
		break;
#endif

	default:
		return GPIO_INVALID_ARGUMENT;
80003dc0:	30 18       	mov	r8,1
80003dc2:	c0 d8       	rjmp	80003ddc <gpio_enable_module_pin+0x108>
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80003dc4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003dc8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003dcc:	30 19       	mov	r9,1
80003dce:	f2 08 09 48 	lsl	r8,r9,r8
80003dd2:	10 99       	mov	r9,r8
80003dd4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003dd8:	91 29       	st.w	r8[0x8],r9

	return GPIO_SUCCESS;
80003dda:	30 08       	mov	r8,0
}
80003ddc:	10 9c       	mov	r12,r8
80003dde:	2f dd       	sub	sp,-12
80003de0:	e3 cd 80 80 	ldm	sp++,r7,pc

80003de4 <gpio_set_gpio_pin>:
/** \brief Drives a GPIO pin to 1.
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
80003de4:	eb cd 40 80 	pushm	r7,lr
80003de8:	1a 97       	mov	r7,sp
80003dea:	20 2d       	sub	sp,8
80003dec:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80003df0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003df4:	a5 98       	lsr	r8,0x5
80003df6:	a9 68       	lsl	r8,0x8
80003df8:	e0 28 f0 00 	sub	r8,61440
80003dfc:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80003e00:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e04:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003e08:	30 19       	mov	r9,1
80003e0a:	f2 08 09 48 	lsl	r8,r9,r8
80003e0e:	10 99       	mov	r9,r8
80003e10:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e14:	f1 49 00 54 	st.w	r8[84],r9
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80003e18:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e1c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003e20:	30 19       	mov	r9,1
80003e22:	f2 08 09 48 	lsl	r8,r9,r8
80003e26:	10 99       	mov	r9,r8
80003e28:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e2c:	f1 49 00 44 	st.w	r8[68],r9
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80003e30:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e34:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003e38:	30 19       	mov	r9,1
80003e3a:	f2 08 09 48 	lsl	r8,r9,r8
80003e3e:	10 99       	mov	r9,r8
80003e40:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e44:	91 19       	st.w	r8[0x4],r9
}
80003e46:	2f ed       	sub	sp,-8
80003e48:	e3 cd 80 80 	ldm	sp++,r7,pc

80003e4c <gpio_clr_gpio_pin>:
/** \brief Drives a GPIO pin to 0.
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
80003e4c:	eb cd 40 80 	pushm	r7,lr
80003e50:	1a 97       	mov	r7,sp
80003e52:	20 2d       	sub	sp,8
80003e54:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80003e58:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e5c:	a5 98       	lsr	r8,0x5
80003e5e:	a9 68       	lsl	r8,0x8
80003e60:	e0 28 f0 00 	sub	r8,61440
80003e64:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80003e68:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e6c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003e70:	30 19       	mov	r9,1
80003e72:	f2 08 09 48 	lsl	r8,r9,r8
80003e76:	10 99       	mov	r9,r8
80003e78:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e7c:	f1 49 00 58 	st.w	r8[88],r9
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80003e80:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e84:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003e88:	30 19       	mov	r9,1
80003e8a:	f2 08 09 48 	lsl	r8,r9,r8
80003e8e:	10 99       	mov	r9,r8
80003e90:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e94:	f1 49 00 44 	st.w	r8[68],r9
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80003e98:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e9c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003ea0:	30 19       	mov	r9,1
80003ea2:	f2 08 09 48 	lsl	r8,r9,r8
80003ea6:	10 99       	mov	r9,r8
80003ea8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003eac:	91 19       	st.w	r8[0x4],r9
}
80003eae:	2f ed       	sub	sp,-8
80003eb0:	e3 cd 80 80 	ldm	sp++,r7,pc

80003eb4 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80003eb4:	eb cd 40 80 	pushm	r7,lr
80003eb8:	1a 97       	mov	r7,sp
	// Catch unregistered interrupts.
	while (true);
80003eba:	c0 08       	rjmp	80003eba <_unhandled_interrupt+0x6>

80003ebc <_get_interrupt_handler>:
 *
 * \return Interrupt handler to execute.
 */
__int_handler _get_interrupt_handler(uint32_t int_level);
__int_handler _get_interrupt_handler(uint32_t int_level)
{
80003ebc:	eb cd 40 80 	pushm	r7,lr
80003ec0:	1a 97       	mov	r7,sp
80003ec2:	20 3d       	sub	sp,12
80003ec4:	ef 4c ff f4 	st.w	r7[-12],r12
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80003ec8:	fe 78 08 00 	mov	r8,-63488
80003ecc:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003ed0:	f2 09 11 03 	rsub	r9,r9,3
80003ed4:	28 09       	sub	r9,-128
80003ed6:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80003eda:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80003ede:	fe 78 08 00 	mov	r8,-63488
80003ee2:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003ee6:	2c 09       	sub	r9,-64
80003ee8:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80003eec:	ef 48 ff fc 	st.w	r7[-4],r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80003ef0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ef4:	58 08       	cp.w	r8,0
80003ef6:	c1 30       	breq	80003f1c <_get_interrupt_handler+0x60>
		? _int_handler_table[int_grp]._int_line_handler_table[32
80003ef8:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003efc:	48 b8       	lddpc	r8,80003f28 <_get_interrupt_handler+0x6c>
80003efe:	a1 79       	lsl	r9,0x1
80003f00:	2f f9       	sub	r9,-1
80003f02:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80003f06:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f0a:	f0 08 12 00 	clz	r8,r8
80003f0e:	f0 08 11 1f 	rsub	r8,r8,31
			- clz(int_req) - 1]
80003f12:	a3 68       	lsl	r8,0x2
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
80003f14:	f2 08 00 08 	add	r8,r9,r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80003f18:	70 08       	ld.w	r8,r8[0x0]
80003f1a:	c0 28       	rjmp	80003f1e <_get_interrupt_handler+0x62>
80003f1c:	30 08       	mov	r8,0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80003f1e:	10 9c       	mov	r12,r8
80003f20:	2f dd       	sub	sp,-12
80003f22:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f26:	00 00       	add	r0,r0
80003f28:	80 00       	ld.sh	r0,r0[0x0]
80003f2a:	72 74       	ld.w	r4,r9[0x1c]

80003f2c <INTC_init_evba>:
 * \internal
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
80003f2c:	eb cd 40 80 	pushm	r7,lr
80003f30:	1a 97       	mov	r7,sp
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80003f32:	48 38       	lddpc	r8,80003f3c <INTC_init_evba+0x10>
80003f34:	e3 b8 00 01 	mtsr	0x4,r8
}
80003f38:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f3c:	80 00       	ld.sh	r0,r0[0x0]
80003f3e:	70 00       	ld.w	r0,r8[0x0]

80003f40 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80003f40:	eb cd 40 80 	pushm	r7,lr
80003f44:	1a 97       	mov	r7,sp
80003f46:	20 2d       	sub	sp,8
	uint32_t int_grp, int_req;

	INTC_init_evba();
80003f48:	f0 1f 00 1f 	mcall	80003fc4 <INTC_init_interrupts+0x84>

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80003f4c:	30 08       	mov	r8,0
80003f4e:	ef 48 ff f8 	st.w	r7[-8],r8
80003f52:	c3 18       	rjmp	80003fb4 <INTC_init_interrupts+0x74>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80003f54:	30 08       	mov	r8,0
80003f56:	ef 48 ff fc 	st.w	r7[-4],r8
80003f5a:	c1 48       	rjmp	80003f82 <INTC_init_interrupts+0x42>
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80003f5c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003f60:	49 a8       	lddpc	r8,80003fc8 <INTC_init_interrupts+0x88>
80003f62:	a1 79       	lsl	r9,0x1
80003f64:	2f f9       	sub	r9,-1
80003f66:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80003f6a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f6e:	a3 68       	lsl	r8,0x2
80003f70:	f2 08 00 08 	add	r8,r9,r8
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80003f74:	49 69       	lddpc	r9,80003fcc <INTC_init_interrupts+0x8c>
80003f76:	91 09       	st.w	r8[0x0],r9
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80003f78:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f7c:	2f f8       	sub	r8,-1
80003f7e:	ef 48 ff fc 	st.w	r7[-4],r8
	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
80003f82:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003f86:	49 18       	lddpc	r8,80003fc8 <INTC_init_interrupts+0x88>
80003f88:	f0 09 03 39 	ld.w	r9,r8[r9<<0x3]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80003f8c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f90:	10 39       	cp.w	r9,r8
80003f92:	fe 9b ff e5 	brhi	80003f5c <INTC_init_interrupts+0x1c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80003f96:	fe 78 08 00 	mov	r8,-63488
80003f9a:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003f9e:	48 db       	lddpc	r11,80003fd0 <INTC_init_interrupts+0x90>
80003fa0:	48 da       	lddpc	r10,80003fd4 <INTC_init_interrupts+0x94>
80003fa2:	f6 0a 01 0a 	sub	r10,r11,r10
80003fa6:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80003faa:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003fae:	2f f8       	sub	r8,-1
80003fb0:	ef 48 ff f8 	st.w	r7[-8],r8
80003fb4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003fb8:	59 38       	cp.w	r8,19
80003fba:	fe 98 ff cd 	brls	80003f54 <INTC_init_interrupts+0x14>
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	}
}
80003fbe:	2f ed       	sub	sp,-8
80003fc0:	e3 cd 80 80 	ldm	sp++,r7,pc
80003fc4:	80 00       	ld.sh	r0,r0[0x0]
80003fc6:	3f 2c       	mov	r12,-14
80003fc8:	80 00       	ld.sh	r0,r0[0x0]
80003fca:	72 74       	ld.w	r4,r9[0x1c]
80003fcc:	80 00       	ld.sh	r0,r0[0x0]
80003fce:	3e b4       	mov	r4,-21
80003fd0:	80 00       	ld.sh	r0,r0[0x0]
80003fd2:	71 04       	ld.w	r4,r8[0x40]
80003fd4:	80 00       	ld.sh	r0,r0[0x0]
80003fd6:	70 00       	ld.w	r0,r8[0x0]

80003fd8 <INTC_register_interrupt>:
 *          be effective.
 *
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
80003fd8:	eb cd 40 80 	pushm	r7,lr
80003fdc:	1a 97       	mov	r7,sp
80003fde:	20 4d       	sub	sp,16
80003fe0:	ef 4c ff f8 	st.w	r7[-8],r12
80003fe4:	ef 4b ff f4 	st.w	r7[-12],r11
80003fe8:	ef 4a ff f0 	st.w	r7[-16],r10
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80003fec:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003ff0:	a5 98       	lsr	r8,0x5
80003ff2:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80003ff6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003ffa:	4a 78       	lddpc	r8,80004094 <INTC_register_interrupt+0xbc>
80003ffc:	a1 79       	lsl	r9,0x1
80003ffe:	2f f9       	sub	r9,-1
80004000:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80004004:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004008:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000400c:	a3 68       	lsl	r8,0x2
8000400e:	f2 08 00 08 	add	r8,r9,r8
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004012:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004016:	91 09       	st.w	r8[0x0],r9
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004018:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000401c:	58 08       	cp.w	r8,0
8000401e:	c0 c1       	brne	80004036 <INTC_register_interrupt+0x5e>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004020:	fe 78 08 00 	mov	r8,-63488
80004024:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004028:	49 cb       	lddpc	r11,80004098 <INTC_register_interrupt+0xc0>
8000402a:	49 da       	lddpc	r10,8000409c <INTC_register_interrupt+0xc4>
8000402c:	f6 0a 01 0a 	sub	r10,r11,r10
80004030:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004034:	c2 d8       	rjmp	8000408e <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT1) {
80004036:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000403a:	58 18       	cp.w	r8,1
8000403c:	c0 d1       	brne	80004056 <INTC_register_interrupt+0x7e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000403e:	fe 78 08 00 	mov	r8,-63488
80004042:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004046:	49 7b       	lddpc	r11,800040a0 <INTC_register_interrupt+0xc8>
80004048:	49 5a       	lddpc	r10,8000409c <INTC_register_interrupt+0xc4>
8000404a:	f6 0a 01 0a 	sub	r10,r11,r10
8000404e:	bf aa       	sbr	r10,0x1e
80004050:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004054:	c1 d8       	rjmp	8000408e <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT2) {
80004056:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000405a:	58 28       	cp.w	r8,2
8000405c:	c0 d1       	brne	80004076 <INTC_register_interrupt+0x9e>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000405e:	fe 78 08 00 	mov	r8,-63488
80004062:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004066:	49 0b       	lddpc	r11,800040a4 <INTC_register_interrupt+0xcc>
80004068:	48 da       	lddpc	r10,8000409c <INTC_register_interrupt+0xc4>
8000406a:	f6 0a 01 0a 	sub	r10,r11,r10
8000406e:	bf ba       	sbr	r10,0x1f
80004070:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004074:	c0 d8       	rjmp	8000408e <INTC_register_interrupt+0xb6>
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004076:	fe 78 08 00 	mov	r8,-63488
8000407a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000407e:	48 bb       	lddpc	r11,800040a8 <INTC_register_interrupt+0xd0>
80004080:	48 7a       	lddpc	r10,8000409c <INTC_register_interrupt+0xc4>
80004082:	f6 0a 01 0a 	sub	r10,r11,r10
80004086:	ea 1a c0 00 	orh	r10,0xc000
8000408a:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	}
}
8000408e:	2f cd       	sub	sp,-16
80004090:	e3 cd 80 80 	ldm	sp++,r7,pc
80004094:	80 00       	ld.sh	r0,r0[0x0]
80004096:	72 74       	ld.w	r4,r9[0x1c]
80004098:	80 00       	ld.sh	r0,r0[0x0]
8000409a:	71 04       	ld.w	r4,r8[0x40]
8000409c:	80 00       	ld.sh	r0,r0[0x0]
8000409e:	70 00       	ld.w	r0,r8[0x0]
800040a0:	80 00       	ld.sh	r0,r0[0x0]
800040a2:	71 12       	ld.w	r2,r8[0x44]
800040a4:	80 00       	ld.sh	r0,r0[0x0]
800040a6:	71 20       	ld.w	r0,r8[0x48]
800040a8:	80 00       	ld.sh	r0,r0[0x0]
800040aa:	71 2e       	ld.w	lr,r8[0x48]

800040ac <pm_set_osc0_mode>:
 *
 * \param pm Base address of the Power Manager (i.e. &AVR32_PM).
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
800040ac:	eb cd 40 80 	pushm	r7,lr
800040b0:	1a 97       	mov	r7,sp
800040b2:	20 3d       	sub	sp,12
800040b4:	ef 4c ff f8 	st.w	r7[-8],r12
800040b8:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800040bc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800040c0:	70 a8       	ld.w	r8,r8[0x28]
800040c2:	30 09       	mov	r9,0
800040c4:	ef 49 ff fc 	st.w	r7[-4],r9
800040c8:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800040cc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800040d0:	5c 58       	castu.b	r8
800040d2:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800040d6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800040da:	ee f8 ff fc 	ld.w	r8,r7[-4]
800040de:	f1 d9 d0 03 	bfins	r8,r9,0x0,0x3
800040e2:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800040e6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800040ea:	ee f8 ff f8 	ld.w	r8,r7[-8]
800040ee:	91 a9       	st.w	r8[0x28],r9
}
800040f0:	2f dd       	sub	sp,-12
800040f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800040f6:	d7 03       	nop

800040f8 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
800040f8:	eb cd 40 80 	pushm	r7,lr
800040fc:	1a 97       	mov	r7,sp
800040fe:	20 2d       	sub	sp,8
80004100:	ef 4c ff fc 	st.w	r7[-4],r12
80004104:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80004108:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000410c:	ec 58 bb 9f 	cp.w	r8,899999
80004110:	e0 88 00 1a 	brls	80004144 <pm_enable_osc0_crystal+0x4c>
80004114:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004118:	e0 69 c6 bf 	mov	r9,50879
8000411c:	ea 19 00 2d 	orh	r9,0x2d
80004120:	12 38       	cp.w	r8,r9
80004122:	e0 88 00 0f 	brls	80004140 <pm_enable_osc0_crystal+0x48>
80004126:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000412a:	e0 69 11 ff 	mov	r9,4607
8000412e:	ea 19 00 7a 	orh	r9,0x7a
80004132:	12 38       	cp.w	r8,r9
80004134:	e0 8b 00 04 	brhi	8000413c <pm_enable_osc0_crystal+0x44>
80004138:	30 68       	mov	r8,6
8000413a:	c0 28       	rjmp	8000413e <pm_enable_osc0_crystal+0x46>
8000413c:	30 78       	mov	r8,7
8000413e:	c0 28       	rjmp	80004142 <pm_enable_osc0_crystal+0x4a>
80004140:	30 58       	mov	r8,5
80004142:	c0 28       	rjmp	80004146 <pm_enable_osc0_crystal+0x4e>
80004144:	30 48       	mov	r8,4
80004146:	10 9b       	mov	r11,r8
80004148:	ee fc ff fc 	ld.w	r12,r7[-4]
8000414c:	f0 1f 00 03 	mcall	80004158 <pm_enable_osc0_crystal+0x60>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80004150:	2f ed       	sub	sp,-8
80004152:	e3 cd 80 80 	ldm	sp++,r7,pc
80004156:	00 00       	add	r0,r0
80004158:	80 00       	ld.sh	r0,r0[0x0]
8000415a:	40 ac       	lddsp	r12,sp[0x28]

8000415c <pm_enable_clk0>:


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
8000415c:	eb cd 40 80 	pushm	r7,lr
80004160:	1a 97       	mov	r7,sp
80004162:	20 2d       	sub	sp,8
80004164:	ef 4c ff fc 	st.w	r7[-4],r12
80004168:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_enable_clk0_no_wait(pm, startup);
8000416c:	ee fb ff f8 	ld.w	r11,r7[-8]
80004170:	ee fc ff fc 	ld.w	r12,r7[-4]
80004174:	f0 1f 00 05 	mcall	80004188 <pm_enable_clk0+0x2c>
  pm_wait_for_clk0_ready(pm);
80004178:	ee fc ff fc 	ld.w	r12,r7[-4]
8000417c:	f0 1f 00 04 	mcall	8000418c <pm_enable_clk0+0x30>
}
80004180:	2f ed       	sub	sp,-8
80004182:	e3 cd 80 80 	ldm	sp++,r7,pc
80004186:	00 00       	add	r0,r0
80004188:	80 00       	ld.sh	r0,r0[0x0]
8000418a:	41 90       	lddsp	r0,sp[0x64]
8000418c:	80 00       	ld.sh	r0,r0[0x0]
8000418e:	41 ea       	lddsp	r10,sp[0x78]

80004190 <pm_enable_clk0_no_wait>:
  pm->mcctrl &= ~AVR32_PM_MCCTRL_OSC0EN_MASK;
}


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
80004190:	eb cd 40 80 	pushm	r7,lr
80004194:	1a 97       	mov	r7,sp
80004196:	20 3d       	sub	sp,12
80004198:	ef 4c ff f8 	st.w	r7[-8],r12
8000419c:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800041a0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041a4:	70 a8       	ld.w	r8,r8[0x28]
800041a6:	30 09       	mov	r9,0
800041a8:	ef 49 ff fc 	st.w	r7[-4],r9
800041ac:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800041b0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800041b4:	5c 58       	castu.b	r8
800041b6:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800041ba:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800041be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800041c2:	f1 d9 d1 03 	bfins	r8,r9,0x8,0x3
800041c6:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800041ca:	ee f9 ff fc 	ld.w	r9,r7[-4]
800041ce:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041d2:	91 a9       	st.w	r8[0x28],r9

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800041d4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041d8:	70 08       	ld.w	r8,r8[0x0]
800041da:	10 99       	mov	r9,r8
800041dc:	a3 a9       	sbr	r9,0x2
800041de:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041e2:	91 09       	st.w	r8[0x0],r9
}
800041e4:	2f dd       	sub	sp,-12
800041e6:	e3 cd 80 80 	ldm	sp++,r7,pc

800041ea <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
800041ea:	eb cd 40 80 	pushm	r7,lr
800041ee:	1a 97       	mov	r7,sp
800041f0:	20 1d       	sub	sp,4
800041f2:	ef 4c ff fc 	st.w	r7[-4],r12
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800041f6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800041fa:	71 58       	ld.w	r8,r8[0x54]
800041fc:	e2 18 00 80 	andl	r8,0x80,COH
80004200:	cf b0       	breq	800041f6 <pm_wait_for_clk0_ready+0xc>
}
80004202:	2f fd       	sub	sp,-4
80004204:	e3 cd 80 80 	ldm	sp++,r7,pc

80004208 <pm_switch_to_clock>:
  return u_avr32_pm_mcctrl.MCCTRL.mcsel;
}


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
80004208:	eb cd 40 80 	pushm	r7,lr
8000420c:	1a 97       	mov	r7,sp
8000420e:	20 3d       	sub	sp,12
80004210:	ef 4c ff f8 	st.w	r7[-8],r12
80004214:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80004218:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000421c:	70 08       	ld.w	r8,r8[0x0]
8000421e:	30 09       	mov	r9,0
80004220:	ef 49 ff fc 	st.w	r7[-4],r9
80004224:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80004228:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000422c:	5c 58       	castu.b	r8
8000422e:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80004232:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80004236:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000423a:	f1 d9 d0 02 	bfins	r8,r9,0x0,0x2
8000423e:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80004242:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004246:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000424a:	91 09       	st.w	r8[0x0],r9
}
8000424c:	2f dd       	sub	sp,-12
8000424e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004252:	d7 03       	nop

80004254 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80004254:	eb cd 40 80 	pushm	r7,lr
80004258:	1a 97       	mov	r7,sp
8000425a:	20 3d       	sub	sp,12
8000425c:	ef 4c ff fc 	st.w	r7[-4],r12
80004260:	ef 4b ff f8 	st.w	r7[-8],r11
80004264:	ef 4a ff f4 	st.w	r7[-12],r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80004268:	ee fb ff f8 	ld.w	r11,r7[-8]
8000426c:	ee fc ff fc 	ld.w	r12,r7[-4]
80004270:	f0 1f 00 08 	mcall	80004290 <pm_switch_to_osc0+0x3c>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80004274:	ee fb ff f4 	ld.w	r11,r7[-12]
80004278:	ee fc ff fc 	ld.w	r12,r7[-4]
8000427c:	f0 1f 00 06 	mcall	80004294 <pm_switch_to_osc0+0x40>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80004280:	30 1b       	mov	r11,1
80004282:	ee fc ff fc 	ld.w	r12,r7[-4]
80004286:	f0 1f 00 05 	mcall	80004298 <pm_switch_to_osc0+0x44>
}
8000428a:	2f dd       	sub	sp,-12
8000428c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004290:	80 00       	ld.sh	r0,r0[0x0]
80004292:	40 f8       	lddsp	r8,sp[0x3c]
80004294:	80 00       	ld.sh	r0,r0[0x0]
80004296:	41 5c       	lddsp	r12,sp[0x54]
80004298:	80 00       	ld.sh	r0,r0[0x0]
8000429a:	42 08       	lddsp	r8,sp[0x80]

8000429c <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
8000429c:	eb cd 40 80 	pushm	r7,lr
800042a0:	1a 97       	mov	r7,sp
800042a2:	20 1d       	sub	sp,4
800042a4:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
800042a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042ac:	e6 18 00 01 	andh	r8,0x1,COH
800042b0:	5f 08       	sreq	r8
800042b2:	5c 58       	castu.b	r8
}
800042b4:	10 9c       	mov	r12,r8
800042b6:	2f fd       	sub	sp,-4
800042b8:	e3 cd 80 80 	ldm	sp++,r7,pc

800042bc <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800042bc:	eb cd 40 80 	pushm	r7,lr
800042c0:	1a 97       	mov	r7,sp
800042c2:	20 7d       	sub	sp,28
800042c4:	ef 4c ff ec 	st.w	r7[-20],r12
800042c8:	ef 4b ff e8 	st.w	r7[-24],r11
800042cc:	ef 4a ff e4 	st.w	r7[-28],r10
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800042d0:	ee f8 ff e8 	ld.w	r8,r7[-24]
800042d4:	f0 09 15 04 	lsl	r9,r8,0x4
800042d8:	ee f8 ff e4 	ld.w	r8,r7[-28]
800042dc:	10 39       	cp.w	r9,r8
800042de:	e0 8b 00 04 	brhi	800042e6 <usart_set_async_baudrate+0x2a>
800042e2:	31 08       	mov	r8,16
800042e4:	c0 28       	rjmp	800042e8 <usart_set_async_baudrate+0x2c>
800042e6:	30 88       	mov	r8,8
800042e8:	ef 48 ff f0 	st.w	r7[-16],r8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800042ec:	ee f8 ff e4 	ld.w	r8,r7[-28]
800042f0:	f0 09 15 03 	lsl	r9,r8,0x3
800042f4:	ee fa ff f0 	ld.w	r10,r7[-16]
800042f8:	ee f8 ff e8 	ld.w	r8,r7[-24]
800042fc:	f4 08 02 48 	mul	r8,r10,r8
80004300:	a1 98       	lsr	r8,0x1
80004302:	f2 08 00 08 	add	r8,r9,r8
80004306:	ee fa ff f0 	ld.w	r10,r7[-16]
8000430a:	ee f9 ff e8 	ld.w	r9,r7[-24]
8000430e:	f4 09 02 49 	mul	r9,r10,r9
80004312:	f0 09 0d 08 	divu	r8,r8,r9
80004316:	ef 48 ff f4 	st.w	r7[-12],r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
8000431a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000431e:	a3 98       	lsr	r8,0x3
80004320:	ef 48 ff f8 	st.w	r7[-8],r8
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);
80004324:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004328:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000432c:	ef 48 ff fc 	st.w	r7[-4],r8

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004330:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004334:	58 08       	cp.w	r8,0
80004336:	c0 70       	breq	80004344 <usart_set_async_baudrate+0x88>
80004338:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000433c:	e0 48 ff ff 	cp.w	r8,65535
80004340:	e0 88 00 04 	brls	80004348 <usart_set_async_baudrate+0x8c>
    return USART_INVALID_INPUT;
80004344:	30 18       	mov	r8,1
80004346:	c2 08       	rjmp	80004386 <usart_set_async_baudrate+0xca>

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004348:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000434c:	70 18       	ld.w	r8,r8[0x4]
8000434e:	10 99       	mov	r9,r8
80004350:	e4 19 ff f7 	andh	r9,0xfff7
80004354:	e0 19 fe cf 	andl	r9,0xfecf
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004358:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000435c:	59 08       	cp.w	r8,16
8000435e:	c0 40       	breq	80004366 <usart_set_async_baudrate+0xaa>
80004360:	e8 68 00 00 	mov	r8,524288
80004364:	c0 28       	rjmp	80004368 <usart_set_async_baudrate+0xac>
80004366:	30 08       	mov	r8,0
80004368:	10 49       	or	r9,r8
8000436a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000436e:	91 19       	st.w	r8[0x4],r9
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
                fp << AVR32_USART_BRGR_FP_OFFSET;
80004370:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004374:	f0 09 15 10 	lsl	r9,r8,0x10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004378:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000437c:	10 49       	or	r9,r8
8000437e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004382:	91 89       	st.w	r8[0x20],r9
                fp << AVR32_USART_BRGR_FP_OFFSET;

  return USART_SUCCESS;
80004384:	30 08       	mov	r8,0
}
80004386:	10 9c       	mov	r12,r8
80004388:	2f 9d       	sub	sp,-28
8000438a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000438e:	d7 03       	nop

80004390 <usart_reset>:
 */
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
80004390:	eb cd 40 80 	pushm	r7,lr
80004394:	1a 97       	mov	r7,sp
80004396:	20 2d       	sub	sp,8
80004398:	ef 4c ff f8 	st.w	r7[-8],r12
  bool global_interrupt_enabled = cpu_irq_is_enabled();
8000439c:	e1 b8 00 00 	mfsr	r8,0x0
800043a0:	10 9c       	mov	r12,r8
800043a2:	f0 1f 00 18 	mcall	80004400 <usart_reset+0x70>
800043a6:	18 98       	mov	r8,r12
800043a8:	ef 68 ff ff 	st.b	r7[-1],r8

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800043ac:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800043b0:	30 08       	mov	r8,0
800043b2:	f0 09 18 00 	cp.b	r9,r8
800043b6:	c0 20       	breq	800043ba <usart_reset+0x2a>
800043b8:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800043ba:	ee f8 ff f8 	ld.w	r8,r7[-8]
800043be:	3f f9       	mov	r9,-1
800043c0:	91 39       	st.w	r8[0xc],r9
  usart->csr;
800043c2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800043c6:	70 58       	ld.w	r8,r8[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800043c8:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800043cc:	30 08       	mov	r8,0
800043ce:	f0 09 18 00 	cp.b	r9,r8
800043d2:	c0 20       	breq	800043d6 <usart_reset+0x46>
800043d4:	d5 03       	csrf	0x10

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800043d6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800043da:	30 09       	mov	r9,0
800043dc:	91 19       	st.w	r8[0x4],r9
  usart->rtor = 0;
800043de:	ee f8 ff f8 	ld.w	r8,r7[-8]
800043e2:	30 09       	mov	r9,0
800043e4:	91 99       	st.w	r8[0x24],r9
  usart->ttgr = 0;
800043e6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800043ea:	30 09       	mov	r9,0
800043ec:	91 a9       	st.w	r8[0x28],r9

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800043ee:	ee f8 ff f8 	ld.w	r8,r7[-8]
800043f2:	ea 69 61 0c 	mov	r9,680204
800043f6:	91 09       	st.w	r8[0x0],r9
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800043f8:	2f ed       	sub	sp,-8
800043fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800043fe:	00 00       	add	r0,r0
80004400:	80 00       	ld.sh	r0,r0[0x0]
80004402:	42 9c       	lddsp	r12,sp[0xa4]

80004404 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004404:	eb cd 40 80 	pushm	r7,lr
80004408:	1a 97       	mov	r7,sp
8000440a:	20 3d       	sub	sp,12
8000440c:	ef 4c ff fc 	st.w	r7[-4],r12
80004410:	ef 4b ff f8 	st.w	r7[-8],r11
80004414:	ef 4a ff f4 	st.w	r7[-12],r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004418:	ee fc ff fc 	ld.w	r12,r7[-4]
8000441c:	f0 1f 00 54 	mcall	8000456c <usart_init_rs232+0x168>

  // Check input values.
  if (!opt || // Null pointer.
80004420:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004424:	58 08       	cp.w	r8,0
80004426:	c3 90       	breq	80004498 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80004428:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000442c:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000442e:	30 48       	mov	r8,4
80004430:	f0 09 18 00 	cp.b	r9,r8
80004434:	e0 88 00 32 	brls	80004498 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80004438:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000443c:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000443e:	30 98       	mov	r8,9
80004440:	f0 09 18 00 	cp.b	r9,r8
80004444:	e0 8b 00 2a 	brhi	80004498 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004448:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000444c:	11 d9       	ld.ub	r9,r8[0x5]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000444e:	30 78       	mov	r8,7
80004450:	f0 09 18 00 	cp.b	r9,r8
80004454:	e0 8b 00 22 	brhi	80004498 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
80004458:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000445c:	90 39       	ld.sh	r9,r8[0x6]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000445e:	e0 68 01 01 	mov	r8,257
80004462:	f0 09 19 00 	cp.h	r9,r8
80004466:	e0 8b 00 19 	brhi	80004498 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
8000446a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000446e:	f1 39 00 08 	ld.ub	r9,r8[8]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004472:	30 38       	mov	r8,3
80004474:	f0 09 18 00 	cp.b	r9,r8
80004478:	e0 8b 00 10 	brhi	80004498 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
8000447c:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004480:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004484:	70 08       	ld.w	r8,r8[0x0]
80004486:	12 9a       	mov	r10,r9
80004488:	10 9b       	mov	r11,r8
8000448a:	ee fc ff fc 	ld.w	r12,r7[-4]
8000448e:	f0 1f 00 39 	mcall	80004570 <usart_init_rs232+0x16c>
80004492:	18 98       	mov	r8,r12
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004494:	58 18       	cp.w	r8,1
80004496:	c0 31       	brne	8000449c <usart_init_rs232+0x98>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;
80004498:	30 18       	mov	r8,1
8000449a:	c6 48       	rjmp	80004562 <usart_init_rs232+0x15e>

  if (opt->charlength == 9)
8000449c:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044a0:	11 c9       	ld.ub	r9,r8[0x4]
800044a2:	30 98       	mov	r8,9
800044a4:	f0 09 18 00 	cp.b	r9,r8
800044a8:	c0 a1       	brne	800044bc <usart_init_rs232+0xb8>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800044aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800044ae:	70 18       	ld.w	r8,r8[0x4]
800044b0:	10 99       	mov	r9,r8
800044b2:	b1 b9       	sbr	r9,0x11
800044b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800044b8:	91 19       	st.w	r8[0x4],r9
800044ba:	c0 d8       	rjmp	800044d4 <usart_init_rs232+0xd0>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800044bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800044c0:	70 19       	ld.w	r9,r8[0x4]
800044c2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044c6:	11 c8       	ld.ub	r8,r8[0x4]
800044c8:	20 58       	sub	r8,5
800044ca:	a7 68       	lsl	r8,0x6
800044cc:	10 49       	or	r9,r8
800044ce:	ee f8 ff fc 	ld.w	r8,r7[-4]
800044d2:	91 19       	st.w	r8[0x4],r9
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800044d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800044d8:	70 19       	ld.w	r9,r8[0x4]
800044da:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044de:	11 d8       	ld.ub	r8,r8[0x5]
800044e0:	f0 0a 15 09 	lsl	r10,r8,0x9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;
800044e4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044e8:	f1 38 00 08 	ld.ub	r8,r8[8]
800044ec:	af 68       	lsl	r8,0xe
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800044ee:	f5 e8 10 08 	or	r8,r10,r8
800044f2:	10 49       	or	r9,r8
800044f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800044f8:	91 19       	st.w	r8[0x4],r9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800044fa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044fe:	90 39       	ld.sh	r9,r8[0x6]
80004500:	30 28       	mov	r8,2
80004502:	f0 09 19 00 	cp.h	r9,r8
80004506:	e0 88 00 14 	brls	8000452e <usart_init_rs232+0x12a>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
8000450a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000450e:	70 18       	ld.w	r8,r8[0x4]
80004510:	10 99       	mov	r9,r8
80004512:	ad b9       	sbr	r9,0xd
80004514:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004518:	91 19       	st.w	r8[0x4],r9
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
8000451a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000451e:	90 38       	ld.sh	r8,r8[0x6]
80004520:	5c 78       	castu.h	r8
80004522:	20 28       	sub	r8,2
80004524:	10 99       	mov	r9,r8
80004526:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000452a:	91 a9       	st.w	r8[0x28],r9
8000452c:	c0 d8       	rjmp	80004546 <usart_init_rs232+0x142>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
8000452e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004532:	70 19       	ld.w	r9,r8[0x4]
80004534:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004538:	90 38       	ld.sh	r8,r8[0x6]
8000453a:	5c 78       	castu.h	r8
8000453c:	ad 68       	lsl	r8,0xc
8000453e:	10 49       	or	r9,r8
80004540:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004544:	91 19       	st.w	r8[0x4],r9

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004546:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000454a:	70 18       	ld.w	r8,r8[0x4]
8000454c:	10 99       	mov	r9,r8
8000454e:	e0 19 ff f0 	andl	r9,0xfff0
80004552:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004556:	91 19       	st.w	r8[0x4],r9
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004558:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000455c:	35 09       	mov	r9,80
8000455e:	91 09       	st.w	r8[0x0],r9
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004560:	30 08       	mov	r8,0
}
80004562:	10 9c       	mov	r12,r8
80004564:	2f dd       	sub	sp,-12
80004566:	e3 cd 80 80 	ldm	sp++,r7,pc
8000456a:	00 00       	add	r0,r0
8000456c:	80 00       	ld.sh	r0,r0[0x0]
8000456e:	43 90       	lddsp	r0,sp[0xe4]
80004570:	80 00       	ld.sh	r0,r0[0x0]
80004572:	42 bc       	lddsp	r12,sp[0xac]

80004574 <usart_write_char>:
  return USART_SUCCESS;
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
80004574:	eb cd 40 80 	pushm	r7,lr
80004578:	1a 97       	mov	r7,sp
8000457a:	20 3d       	sub	sp,12
8000457c:	ef 4c ff f8 	st.w	r7[-8],r12
80004580:	ef 4b ff f4 	st.w	r7[-12],r11
80004584:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004588:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000458c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004590:	70 58       	ld.w	r8,r8[0x14]
80004592:	e2 18 00 02 	andl	r8,0x2,COH
80004596:	5f 18       	srne	r8
  if (usart_tx_ready(usart))
80004598:	58 08       	cp.w	r8,0
8000459a:	c0 a0       	breq	800045ae <usart_write_char+0x3a>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000459c:	ee f8 ff f4 	ld.w	r8,r7[-12]
800045a0:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
800045a4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045a8:	91 79       	st.w	r8[0x1c],r9
    return USART_SUCCESS;
800045aa:	30 08       	mov	r8,0
800045ac:	c0 28       	rjmp	800045b0 <usart_write_char+0x3c>
  }
  else
    return USART_TX_BUSY;
800045ae:	30 28       	mov	r8,2
}
800045b0:	10 9c       	mov	r12,r8
800045b2:	2f dd       	sub	sp,-12
800045b4:	e3 cd 80 80 	ldm	sp++,r7,pc

800045b8 <usart_putchar>:


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
800045b8:	eb cd 40 80 	pushm	r7,lr
800045bc:	1a 97       	mov	r7,sp
800045be:	20 3d       	sub	sp,12
800045c0:	ef 4c ff f8 	st.w	r7[-8],r12
800045c4:	ef 4b ff f4 	st.w	r7[-12],r11
  int timeout = USART_DEFAULT_TIMEOUT;
800045c8:	e0 68 27 10 	mov	r8,10000
800045cc:	ef 48 ff fc 	st.w	r7[-4],r8

  do
  {
    if (!timeout--) return USART_FAILURE;
800045d0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800045d4:	58 08       	cp.w	r8,0
800045d6:	5f 08       	sreq	r8
800045d8:	5c 58       	castu.b	r8
800045da:	ee f9 ff fc 	ld.w	r9,r7[-4]
800045de:	20 19       	sub	r9,1
800045e0:	ef 49 ff fc 	st.w	r7[-4],r9
800045e4:	58 08       	cp.w	r8,0
800045e6:	c0 30       	breq	800045ec <usart_putchar+0x34>
800045e8:	3f f8       	mov	r8,-1
800045ea:	c0 b8       	rjmp	80004600 <usart_putchar+0x48>
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800045ec:	ee fb ff f4 	ld.w	r11,r7[-12]
800045f0:	ee fc ff f8 	ld.w	r12,r7[-8]
800045f4:	f0 1f 00 05 	mcall	80004608 <usart_putchar+0x50>
800045f8:	18 98       	mov	r8,r12
800045fa:	58 08       	cp.w	r8,0
800045fc:	ce a1       	brne	800045d0 <usart_putchar+0x18>

  return USART_SUCCESS;
800045fe:	30 08       	mov	r8,0
}
80004600:	10 9c       	mov	r12,r8
80004602:	2f dd       	sub	sp,-12
80004604:	e3 cd 80 80 	ldm	sp++,r7,pc
80004608:	80 00       	ld.sh	r0,r0[0x0]
8000460a:	45 74       	lddsp	r4,sp[0x15c]

8000460c <usart_write_line>:
  return c;
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
8000460c:	eb cd 40 80 	pushm	r7,lr
80004610:	1a 97       	mov	r7,sp
80004612:	20 2d       	sub	sp,8
80004614:	ef 4c ff fc 	st.w	r7[-4],r12
80004618:	ef 4b ff f8 	st.w	r7[-8],r11
  while (*string != '\0')
8000461c:	c0 e8       	rjmp	80004638 <usart_write_line+0x2c>
    usart_putchar(usart, *string++);
8000461e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004622:	11 88       	ld.ub	r8,r8[0x0]
80004624:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004628:	2f f9       	sub	r9,-1
8000462a:	ef 49 ff f8 	st.w	r7[-8],r9
8000462e:	10 9b       	mov	r11,r8
80004630:	ee fc ff fc 	ld.w	r12,r7[-4]
80004634:	f0 1f 00 05 	mcall	80004648 <usart_write_line+0x3c>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80004638:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000463c:	11 88       	ld.ub	r8,r8[0x0]
8000463e:	58 08       	cp.w	r8,0
80004640:	ce f1       	brne	8000461e <usart_write_line+0x12>
    usart_putchar(usart, *string++);
}
80004642:	2f ed       	sub	sp,-8
80004644:	e3 cd 80 80 	ldm	sp++,r7,pc
80004648:	80 00       	ld.sh	r0,r0[0x0]
8000464a:	45 b8       	lddsp	r8,sp[0x16c]

8000464c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
8000464c:	eb cd 40 80 	pushm	r7,lr
80004650:	1a 97       	mov	r7,sp
80004652:	20 1d       	sub	sp,4
80004654:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004658:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000465c:	2f 88       	sub	r8,-8
8000465e:	10 99       	mov	r9,r8
80004660:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004664:	91 19       	st.w	r8[0x4],r9

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004666:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000466a:	3f f9       	mov	r9,-1
8000466c:	91 29       	st.w	r8[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
8000466e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004672:	2f 88       	sub	r8,-8
80004674:	10 99       	mov	r9,r8
80004676:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000467a:	91 39       	st.w	r8[0xc],r9
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
8000467c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004680:	2f 88       	sub	r8,-8
80004682:	10 99       	mov	r9,r8
80004684:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004688:	91 49       	st.w	r8[0x10],r9

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
8000468a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000468e:	30 09       	mov	r9,0
80004690:	91 09       	st.w	r8[0x0],r9
}
80004692:	2f fd       	sub	sp,-4
80004694:	e3 cd 80 80 	ldm	sp++,r7,pc

80004698 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
80004698:	eb cd 40 80 	pushm	r7,lr
8000469c:	1a 97       	mov	r7,sp
8000469e:	20 1d       	sub	sp,4
800046a0:	ef 4c ff fc 	st.w	r7[-4],r12
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
800046a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046a8:	30 09       	mov	r9,0
800046aa:	91 49       	st.w	r8[0x10],r9
}
800046ac:	2f fd       	sub	sp,-4
800046ae:	e3 cd 80 80 	ldm	sp++,r7,pc

800046b2 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
800046b2:	eb cd 40 80 	pushm	r7,lr
800046b6:	1a 97       	mov	r7,sp
800046b8:	20 3d       	sub	sp,12
800046ba:	ef 4c ff f8 	st.w	r7[-8],r12
800046be:	ef 4b ff f4 	st.w	r7[-12],r11

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
800046c2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046c6:	70 18       	ld.w	r8,r8[0x4]
800046c8:	ef 48 ff fc 	st.w	r7[-4],r8

	pxNewListItem->pxNext = pxIndex->pxNext;
800046cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046d0:	70 19       	ld.w	r9,r8[0x4]
800046d2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800046d6:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
800046d8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046dc:	70 19       	ld.w	r9,r8[0x4]
800046de:	ee f8 ff f4 	ld.w	r8,r7[-12]
800046e2:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800046e4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046e8:	70 18       	ld.w	r8,r8[0x4]
800046ea:	ee f9 ff f4 	ld.w	r9,r7[-12]
800046ee:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
800046f0:	ee f9 ff f4 	ld.w	r9,r7[-12]
800046f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046f8:	91 19       	st.w	r8[0x4],r9
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
800046fa:	ee f9 ff f4 	ld.w	r9,r7[-12]
800046fe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004702:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004704:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004708:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000470c:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
8000470e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004712:	70 08       	ld.w	r8,r8[0x0]
80004714:	f0 c9 ff ff 	sub	r9,r8,-1
80004718:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000471c:	91 09       	st.w	r8[0x0],r9
}
8000471e:	2f dd       	sub	sp,-12
80004720:	e3 cd 80 80 	ldm	sp++,r7,pc

80004724 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
80004724:	eb cd 40 80 	pushm	r7,lr
80004728:	1a 97       	mov	r7,sp
8000472a:	20 4d       	sub	sp,16
8000472c:	ef 4c ff f4 	st.w	r7[-12],r12
80004730:	ef 4b ff f0 	st.w	r7[-16],r11
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004734:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004738:	70 08       	ld.w	r8,r8[0x0]
8000473a:	ef 48 ff fc 	st.w	r7[-4],r8
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
8000473e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004742:	5b f8       	cp.w	r8,-1
80004744:	c0 71       	brne	80004752 <vListInsert+0x2e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004746:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000474a:	70 48       	ld.w	r8,r8[0x10]
8000474c:	ef 48 ff f8 	st.w	r7[-8],r8
80004750:	c1 58       	rjmp	8000477a <vListInsert+0x56>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004752:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004756:	2f 88       	sub	r8,-8
80004758:	ef 48 ff f8 	st.w	r7[-8],r8
8000475c:	c0 68       	rjmp	80004768 <vListInsert+0x44>
8000475e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004762:	70 18       	ld.w	r8,r8[0x4]
80004764:	ef 48 ff f8 	st.w	r7[-8],r8
80004768:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000476c:	70 18       	ld.w	r8,r8[0x4]
8000476e:	70 09       	ld.w	r9,r8[0x0]
80004770:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004774:	10 39       	cp.w	r9,r8
80004776:	fe 98 ff f4 	brls	8000475e <vListInsert+0x3a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
8000477a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000477e:	70 19       	ld.w	r9,r8[0x4]
80004780:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004784:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004786:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000478a:	70 18       	ld.w	r8,r8[0x4]
8000478c:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004790:	91 29       	st.w	r8[0x8],r9
	pxNewListItem->pxPrevious = pxIterator;
80004792:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004796:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000479a:	91 29       	st.w	r8[0x8],r9
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
8000479c:	ee f9 ff f0 	ld.w	r9,r7[-16]
800047a0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047a4:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800047a6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800047aa:	ee f9 ff f4 	ld.w	r9,r7[-12]
800047ae:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
800047b0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800047b4:	70 08       	ld.w	r8,r8[0x0]
800047b6:	f0 c9 ff ff 	sub	r9,r8,-1
800047ba:	ee f8 ff f4 	ld.w	r8,r7[-12]
800047be:	91 09       	st.w	r8[0x0],r9
}
800047c0:	2f cd       	sub	sp,-16
800047c2:	e3 cd 80 80 	ldm	sp++,r7,pc

800047c6 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
800047c6:	eb cd 40 80 	pushm	r7,lr
800047ca:	1a 97       	mov	r7,sp
800047cc:	20 2d       	sub	sp,8
800047ce:	ef 4c ff f8 	st.w	r7[-8],r12
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800047d2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047d6:	70 18       	ld.w	r8,r8[0x4]
800047d8:	ee f9 ff f8 	ld.w	r9,r7[-8]
800047dc:	72 29       	ld.w	r9,r9[0x8]
800047de:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
800047e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047e4:	70 28       	ld.w	r8,r8[0x8]
800047e6:	ee f9 ff f8 	ld.w	r9,r7[-8]
800047ea:	72 19       	ld.w	r9,r9[0x4]
800047ec:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
800047ee:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047f2:	70 48       	ld.w	r8,r8[0x10]
800047f4:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800047f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800047fc:	70 19       	ld.w	r9,r8[0x4]
800047fe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004802:	10 39       	cp.w	r9,r8
80004804:	c0 71       	brne	80004812 <vListRemove+0x4c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004806:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000480a:	70 29       	ld.w	r9,r8[0x8]
8000480c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004810:	91 19       	st.w	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004812:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004816:	30 09       	mov	r9,0
80004818:	91 49       	st.w	r8[0x10],r9
	( pxList->uxNumberOfItems )--;
8000481a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000481e:	70 08       	ld.w	r8,r8[0x0]
80004820:	f0 c9 00 01 	sub	r9,r8,1
80004824:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004828:	91 09       	st.w	r8[0x0],r9
}
8000482a:	2f ed       	sub	sp,-8
8000482c:	e3 cd 80 80 	ldm	sp++,r7,pc

80004830 <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80004830:	eb cd 40 80 	pushm	r7,lr
80004834:	1a 97       	mov	r7,sp
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
80004836:	48 e8       	lddpc	r8,8000486c <_init_startup+0x3c>
80004838:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
8000483c:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
8000483e:	f0 1f 00 0d 	mcall	80004870 <_init_startup+0x40>
			.channelmode = USART_NORMAL_CHMODE
		};

		/* Initialize the USART used for the debug trace with the configured parameters. */
		extern volatile avr32_usart_t *volatile stdio_usart_base;
		stdio_usart_base = configDBG_USART;
80004842:	48 d8       	lddpc	r8,80004874 <_init_startup+0x44>
80004844:	fe 79 18 00 	mov	r9,-59392
80004848:	91 09       	st.w	r8[0x0],r9
		gpio_enable_module( DBG_USART_GPIO_MAP,
8000484a:	30 2b       	mov	r11,2
8000484c:	48 bc       	lddpc	r12,80004878 <_init_startup+0x48>
8000484e:	f0 1f 00 0c 	mcall	8000487c <_init_startup+0x4c>
		                    sizeof( DBG_USART_GPIO_MAP ) / sizeof( DBG_USART_GPIO_MAP[0] ) );
		usart_init_rs232(configDBG_USART, &DBG_USART_OPTIONS, configPBA_CLOCK_HZ);
80004852:	e0 6a 1b 00 	mov	r10,6912
80004856:	ea 1a 00 b7 	orh	r10,0xb7
8000485a:	48 ab       	lddpc	r11,80004880 <_init_startup+0x50>
8000485c:	fe 7c 18 00 	mov	r12,-59392
80004860:	f0 1f 00 09 	mcall	80004884 <_init_startup+0x54>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
80004864:	30 18       	mov	r8,1
}
80004866:	10 9c       	mov	r12,r8
80004868:	e3 cd 80 80 	ldm	sp++,r7,pc
8000486c:	80 00       	ld.sh	r0,r0[0x0]
8000486e:	70 00       	ld.w	r0,r8[0x0]
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	3f 40       	mov	r0,-12
80004874:	00 00       	add	r0,r0
80004876:	07 e4       	ld.ub	r4,r3[0x6]
80004878:	80 00       	ld.sh	r0,r0[0x0]
8000487a:	73 14       	ld.w	r4,r9[0x44]
8000487c:	80 00       	ld.sh	r0,r0[0x0]
8000487e:	3c 64       	mov	r4,-58
80004880:	80 00       	ld.sh	r0,r0[0x0]
80004882:	73 24       	ld.w	r4,r9[0x48]
80004884:	80 00       	ld.sh	r0,r0[0x0]
80004886:	44 04       	lddsp	r4,sp[0x100]

80004888 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80004888:	eb cd 40 80 	pushm	r7,lr
8000488c:	1a 97       	mov	r7,sp
8000488e:	20 1d       	sub	sp,4
80004890:	ef 4c ff fc 	st.w	r7[-4],r12
	vTaskSuspendAll();
80004894:	f0 1f 00 03 	mcall	800048a0 <__malloc_lock+0x18>
}
80004898:	2f fd       	sub	sp,-4
8000489a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000489e:	00 00       	add	r0,r0
800048a0:	80 00       	ld.sh	r0,r0[0x0]
800048a2:	58 f0       	cp.w	r0,15

800048a4 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800048a4:	eb cd 40 80 	pushm	r7,lr
800048a8:	1a 97       	mov	r7,sp
800048aa:	20 1d       	sub	sp,4
800048ac:	ef 4c ff fc 	st.w	r7[-4],r12
	xTaskResumeAll();
800048b0:	f0 1f 00 03 	mcall	800048bc <__malloc_unlock+0x18>
}
800048b4:	2f fd       	sub	sp,-4
800048b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800048ba:	00 00       	add	r0,r0
800048bc:	80 00       	ld.sh	r0,r0[0x0]
800048be:	59 0c       	cp.w	r12,16

800048c0 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800048c0:	eb cd 00 ff 	pushm	r0-r7
800048c4:	e0 68 00 20 	mov	r8,32
800048c8:	ea 18 00 00 	orh	r8,0x0
800048cc:	70 00       	ld.w	r0,r8[0x0]
800048ce:	1a d0       	st.w	--sp,r0
800048d0:	7a 90       	ld.w	r0,sp[0x24]
800048d2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800048d6:	58 10       	cp.w	r0,1
800048d8:	e0 8b 00 08 	brhi	800048e8 <LABEL_INT_SKIP_SAVE_CONTEXT_234>
800048dc:	e0 68 06 60 	mov	r8,1632
800048e0:	ea 18 00 00 	orh	r8,0x0
800048e4:	70 00       	ld.w	r0,r8[0x0]
800048e6:	81 0d       	st.w	r0[0x0],sp

800048e8 <LABEL_INT_SKIP_SAVE_CONTEXT_234>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800048e8:	f0 1f 00 12 	mcall	80004930 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800048ec:	f0 1f 00 12 	mcall	80004934 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
		vTaskIncrementTick();
800048f0:	f0 1f 00 12 	mcall	80004938 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x1c>
	portEXIT_CRITICAL();
800048f4:	f0 1f 00 12 	mcall	8000493c <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800048f8:	7a 90       	ld.w	r0,sp[0x24]
800048fa:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800048fe:	58 10       	cp.w	r0,1
80004900:	e0 8b 00 0e 	brhi	8000491c <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
80004904:	f0 1f 00 0c 	mcall	80004934 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
80004908:	f0 1f 00 0e 	mcall	80004940 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x24>
8000490c:	f0 1f 00 0c 	mcall	8000493c <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>
80004910:	e0 68 06 60 	mov	r8,1632
80004914:	ea 18 00 00 	orh	r8,0x0
80004918:	70 00       	ld.w	r0,r8[0x0]
8000491a:	60 0d       	ld.w	sp,r0[0x0]

8000491c <LABEL_INT_SKIP_RESTORE_CONTEXT_251>:
8000491c:	1b 00       	ld.w	r0,sp++
8000491e:	e0 68 00 20 	mov	r8,32
80004922:	ea 18 00 00 	orh	r8,0x0
80004926:	91 00       	st.w	r8[0x0],r0
80004928:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000492c:	d6 03       	rete
8000492e:	00 00       	add	r0,r0
80004930:	80 00       	ld.sh	r0,r0[0x0]
80004932:	4c 2c       	lddpc	r12,80004a38 <pxPortInitialiseStack+0x14>
80004934:	80 00       	ld.sh	r0,r0[0x0]
80004936:	49 dc       	lddpc	r12,800049a8 <SCALLYield+0x64>
80004938:	80 00       	ld.sh	r0,r0[0x0]
8000493a:	5a 64       	cp.w	r4,-26
8000493c:	80 00       	ld.sh	r0,r0[0x0]
8000493e:	49 f8       	lddpc	r8,800049b8 <SCALLYield+0x74>
80004940:	80 00       	ld.sh	r0,r0[0x0]
80004942:	5b c4       	cp.w	r4,-4

80004944 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004944:	20 6d       	sub	sp,24
80004946:	eb cd 00 ff 	pushm	r0-r7
8000494a:	fa c7 ff c0 	sub	r7,sp,-64
8000494e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80004952:	ef 40 ff e0 	st.w	r7[-32],r0
80004956:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000495a:	ef 40 ff e4 	st.w	r7[-28],r0
8000495e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80004962:	e0 68 00 20 	mov	r8,32
80004966:	ea 18 00 00 	orh	r8,0x0
8000496a:	70 00       	ld.w	r0,r8[0x0]
8000496c:	1a d0       	st.w	--sp,r0
8000496e:	f0 1f 00 1a 	mcall	800049d4 <LABEL_RET_SCALL_260+0x14>
80004972:	e0 68 06 60 	mov	r8,1632
80004976:	ea 18 00 00 	orh	r8,0x0
8000497a:	70 00       	ld.w	r0,r8[0x0]
8000497c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
8000497e:	f0 1f 00 17 	mcall	800049d8 <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
80004982:	e0 68 06 60 	mov	r8,1632
80004986:	ea 18 00 00 	orh	r8,0x0
8000498a:	70 00       	ld.w	r0,r8[0x0]
8000498c:	60 0d       	ld.w	sp,r0[0x0]
8000498e:	1b 00       	ld.w	r0,sp++
80004990:	e0 68 00 20 	mov	r8,32
80004994:	ea 18 00 00 	orh	r8,0x0
80004998:	91 00       	st.w	r8[0x0],r0
8000499a:	fa c7 ff d8 	sub	r7,sp,-40
8000499e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800049a2:	ee f0 ff e0 	ld.w	r0,r7[-32]
800049a6:	e0 61 00 20 	mov	r1,32
800049aa:	ea 11 00 00 	orh	r1,0x0
800049ae:	62 02       	ld.w	r2,r1[0x0]
800049b0:	58 02       	cp.w	r2,0
800049b2:	c0 70       	breq	800049c0 <LABEL_RET_SCALL_260>
800049b4:	e4 c2 00 01 	sub	r2,r2,1
800049b8:	83 02       	st.w	r1[0x0],r2
800049ba:	58 02       	cp.w	r2,0
800049bc:	c0 21       	brne	800049c0 <LABEL_RET_SCALL_260>
800049be:	b1 c0       	cbr	r0,0x10

800049c0 <LABEL_RET_SCALL_260>:
800049c0:	ef 40 ff f8 	st.w	r7[-8],r0
800049c4:	ee f0 ff e4 	ld.w	r0,r7[-28]
800049c8:	ef 40 ff fc 	st.w	r7[-4],r0
800049cc:	e3 cd 00 ff 	ldm	sp++,r0-r7
800049d0:	2f ad       	sub	sp,-24
800049d2:	d6 13       	rets
800049d4:	80 00       	ld.sh	r0,r0[0x0]
800049d6:	49 dc       	lddpc	r12,80004a48 <pxPortInitialiseStack+0x24>
800049d8:	80 00       	ld.sh	r0,r0[0x0]
800049da:	5b c4       	cp.w	r4,-4

800049dc <vPortEnterCritical>:
/* The code generated by the GCC compiler uses the stack in different ways at
different optimisation levels.  The interrupt flags can therefore not always
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
800049dc:	eb cd 40 80 	pushm	r7,lr
800049e0:	1a 97       	mov	r7,sp
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
800049e2:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
800049e4:	48 48       	lddpc	r8,800049f4 <vPortEnterCritical+0x18>
800049e6:	70 08       	ld.w	r8,r8[0x0]
800049e8:	f0 c9 ff ff 	sub	r9,r8,-1
800049ec:	48 28       	lddpc	r8,800049f4 <vPortEnterCritical+0x18>
800049ee:	91 09       	st.w	r8[0x0],r9
}
800049f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800049f4:	00 00       	add	r0,r0
800049f6:	00 20       	rsub	r0,r0

800049f8 <vPortExitCritical>:
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
800049f8:	eb cd 40 80 	pushm	r7,lr
800049fc:	1a 97       	mov	r7,sp
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
800049fe:	48 98       	lddpc	r8,80004a20 <vPortExitCritical+0x28>
80004a00:	70 08       	ld.w	r8,r8[0x0]
80004a02:	58 08       	cp.w	r8,0
80004a04:	c0 c0       	breq	80004a1c <vPortExitCritical+0x24>
	{
		ulCriticalNesting--;
80004a06:	48 78       	lddpc	r8,80004a20 <vPortExitCritical+0x28>
80004a08:	70 08       	ld.w	r8,r8[0x0]
80004a0a:	f0 c9 00 01 	sub	r9,r8,1
80004a0e:	48 58       	lddpc	r8,80004a20 <vPortExitCritical+0x28>
80004a10:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004a12:	48 48       	lddpc	r8,80004a20 <vPortExitCritical+0x28>
80004a14:	70 08       	ld.w	r8,r8[0x0]
80004a16:	58 08       	cp.w	r8,0
80004a18:	c0 21       	brne	80004a1c <vPortExitCritical+0x24>
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80004a1a:	d5 03       	csrf	0x10
		}
	}
}
80004a1c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a20:	00 00       	add	r0,r0
80004a22:	00 20       	rsub	r0,r0

80004a24 <pxPortInitialiseStack>:
 * portSAVE_CONTEXT had been called.
 *
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
80004a24:	eb cd 40 80 	pushm	r7,lr
80004a28:	1a 97       	mov	r7,sp
80004a2a:	20 3d       	sub	sp,12
80004a2c:	ef 4c ff fc 	st.w	r7[-4],r12
80004a30:	ef 4b ff f8 	st.w	r7[-8],r11
80004a34:	ef 4a ff f4 	st.w	r7[-12],r10
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
80004a38:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a3c:	20 48       	sub	r8,4
80004a3e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004a42:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a46:	e0 69 08 08 	mov	r9,2056
80004a4a:	ea 19 08 08 	orh	r9,0x808
80004a4e:	91 09       	st.w	r8[0x0],r9
80004a50:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a54:	20 48       	sub	r8,4
80004a56:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80004a5a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a5e:	e0 69 09 09 	mov	r9,2313
80004a62:	ea 19 09 09 	orh	r9,0x909
80004a66:	91 09       	st.w	r8[0x0],r9
80004a68:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a6c:	20 48       	sub	r8,4
80004a6e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004a72:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a76:	e0 69 0a 0a 	mov	r9,2570
80004a7a:	ea 19 0a 0a 	orh	r9,0xa0a
80004a7e:	91 09       	st.w	r8[0x0],r9
80004a80:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a84:	20 48       	sub	r8,4
80004a86:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80004a8a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a8e:	e0 69 0b 0b 	mov	r9,2827
80004a92:	ea 19 0b 0b 	orh	r9,0xb0b
80004a96:	91 09       	st.w	r8[0x0],r9
80004a98:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a9c:	20 48       	sub	r8,4
80004a9e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80004aa2:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004aa6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004aaa:	91 09       	st.w	r8[0x0],r9
80004aac:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ab0:	20 48       	sub	r8,4
80004ab2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80004ab6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004aba:	e0 69 be ef 	mov	r9,48879
80004abe:	ea 19 de ad 	orh	r9,0xdead
80004ac2:	91 09       	st.w	r8[0x0],r9
80004ac4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ac8:	20 48       	sub	r8,4
80004aca:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80004ace:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004ad2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ad6:	91 09       	st.w	r8[0x0],r9
80004ad8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004adc:	20 48       	sub	r8,4
80004ade:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80004ae2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ae6:	fc 19 00 40 	movh	r9,0x40
80004aea:	91 09       	st.w	r8[0x0],r9
80004aec:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004af0:	20 48       	sub	r8,4
80004af2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80004af6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004afa:	e0 69 00 ff 	mov	r9,255
80004afe:	ea 19 ff 00 	orh	r9,0xff00
80004b02:	91 09       	st.w	r8[0x0],r9
80004b04:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b08:	20 48       	sub	r8,4
80004b0a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80004b0e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b12:	e0 69 01 01 	mov	r9,257
80004b16:	ea 19 01 01 	orh	r9,0x101
80004b1a:	91 09       	st.w	r8[0x0],r9
80004b1c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b20:	20 48       	sub	r8,4
80004b22:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004b26:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b2a:	e0 69 02 02 	mov	r9,514
80004b2e:	ea 19 02 02 	orh	r9,0x202
80004b32:	91 09       	st.w	r8[0x0],r9
80004b34:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b38:	20 48       	sub	r8,4
80004b3a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80004b3e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b42:	e0 69 03 03 	mov	r9,771
80004b46:	ea 19 03 03 	orh	r9,0x303
80004b4a:	91 09       	st.w	r8[0x0],r9
80004b4c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b50:	20 48       	sub	r8,4
80004b52:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80004b56:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b5a:	e0 69 04 04 	mov	r9,1028
80004b5e:	ea 19 04 04 	orh	r9,0x404
80004b62:	91 09       	st.w	r8[0x0],r9
80004b64:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b68:	20 48       	sub	r8,4
80004b6a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004b6e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b72:	e0 69 05 05 	mov	r9,1285
80004b76:	ea 19 05 05 	orh	r9,0x505
80004b7a:	91 09       	st.w	r8[0x0],r9
80004b7c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b80:	20 48       	sub	r8,4
80004b82:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80004b86:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b8a:	e0 69 06 06 	mov	r9,1542
80004b8e:	ea 19 06 06 	orh	r9,0x606
80004b92:	91 09       	st.w	r8[0x0],r9
80004b94:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b98:	20 48       	sub	r8,4
80004b9a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80004b9e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ba2:	e0 69 07 07 	mov	r9,1799
80004ba6:	ea 19 07 07 	orh	r9,0x707
80004baa:	91 09       	st.w	r8[0x0],r9
80004bac:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bb0:	20 48       	sub	r8,4
80004bb2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004bb6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bba:	30 09       	mov	r9,0
80004bbc:	91 09       	st.w	r8[0x0],r9

	return pxTopOfStack;
80004bbe:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80004bc2:	10 9c       	mov	r12,r8
80004bc4:	2f dd       	sub	sp,-12
80004bc6:	e3 cd 80 80 	ldm	sp++,r7,pc
80004bca:	d7 03       	nop

80004bcc <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80004bcc:	eb cd 40 80 	pushm	r7,lr
80004bd0:	1a 97       	mov	r7,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
80004bd2:	f0 1f 00 10 	mcall	80004c10 <xPortStartScheduler+0x44>

	/* Start the first task. */
	portRESTORE_CONTEXT();
80004bd6:	e0 68 06 60 	mov	r8,1632
80004bda:	ea 18 00 00 	orh	r8,0x0
80004bde:	70 00       	ld.w	r0,r8[0x0]
80004be0:	60 0d       	ld.w	sp,r0[0x0]
80004be2:	1b 00       	ld.w	r0,sp++
80004be4:	e0 68 00 20 	mov	r8,32
80004be8:	ea 18 00 00 	orh	r8,0x0
80004bec:	91 00       	st.w	r8[0x0],r0
80004bee:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004bf2:	2f ed       	sub	sp,-8
80004bf4:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80004bf8:	fa f0 ff e0 	ld.w	r0,sp[-32]
80004bfc:	e3 b0 00 00 	mtsr	0x0,r0
80004c00:	fa f0 ff dc 	ld.w	r0,sp[-36]
80004c04:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
80004c08:	30 08       	mov	r8,0
}
80004c0a:	10 9c       	mov	r12,r8
80004c0c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c10:	80 00       	ld.sh	r0,r0[0x0]
80004c12:	4c 40       	lddpc	r0,80004d20 <xQueueCreate+0x44>

80004c14 <prvScheduleFirstTick>:

/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
80004c14:	eb cd 40 80 	pushm	r7,lr
80004c18:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
80004c1a:	e0 68 2e e0 	mov	r8,12000
80004c1e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80004c22:	30 08       	mov	r8,0
80004c24:	e3 b8 00 42 	mtsr	0x108,r8
	}
80004c28:	e3 cd 80 80 	ldm	sp++,r7,pc

80004c2c <prvClearCcInt>:

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
80004c2c:	eb cd 40 80 	pushm	r7,lr
80004c30:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80004c32:	e1 b8 00 43 	mfsr	r8,0x10c
80004c36:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80004c3a:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c3e:	d7 03       	nop

80004c40 <prvSetupTimerInterrupt>:
#endif
/*-----------------------------------------------------------*/

/* Setup the timer to generate the tick interrupts. */
static void prvSetupTimerInterrupt(void)
{
80004c40:	eb cd 40 80 	pushm	r7,lr
80004c44:	1a 97       	mov	r7,sp
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80004c46:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80004c48:	30 0a       	mov	r10,0
80004c4a:	30 0b       	mov	r11,0
80004c4c:	48 4c       	lddpc	r12,80004c5c <prvSetupTimerInterrupt+0x1c>
80004c4e:	f0 1f 00 05 	mcall	80004c60 <prvSetupTimerInterrupt+0x20>
		prvScheduleFirstTick();
80004c52:	f0 1f 00 05 	mcall	80004c64 <prvSetupTimerInterrupt+0x24>
	}
	#endif
}
80004c56:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c5a:	00 00       	add	r0,r0
80004c5c:	80 00       	ld.sh	r0,r0[0x0]
80004c5e:	48 c0       	lddpc	r0,80004c8c <pvPortMalloc+0x24>
80004c60:	80 00       	ld.sh	r0,r0[0x0]
80004c62:	3f d8       	mov	r8,-3
80004c64:	80 00       	ld.sh	r0,r0[0x0]
80004c66:	4c 14       	lddpc	r4,80004d68 <xQueueCreate+0x8c>

80004c68 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80004c68:	eb cd 40 80 	pushm	r7,lr
80004c6c:	1a 97       	mov	r7,sp
80004c6e:	20 2d       	sub	sp,8
80004c70:	ef 4c ff f8 	st.w	r7[-8],r12
void *pvReturn;

	vTaskSuspendAll();
80004c74:	f0 1f 00 09 	mcall	80004c98 <pvPortMalloc+0x30>
	{
		pvReturn = malloc( xWantedSize );
80004c78:	ee fc ff f8 	ld.w	r12,r7[-8]
80004c7c:	f0 1f 00 08 	mcall	80004c9c <pvPortMalloc+0x34>
80004c80:	18 98       	mov	r8,r12
80004c82:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	xTaskResumeAll();
80004c86:	f0 1f 00 07 	mcall	80004ca0 <pvPortMalloc+0x38>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
80004c8a:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80004c8e:	10 9c       	mov	r12,r8
80004c90:	2f ed       	sub	sp,-8
80004c92:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c96:	00 00       	add	r0,r0
80004c98:	80 00       	ld.sh	r0,r0[0x0]
80004c9a:	58 f0       	cp.w	r0,15
80004c9c:	80 00       	ld.sh	r0,r0[0x0]
80004c9e:	64 98       	ld.w	r8,r2[0x24]
80004ca0:	80 00       	ld.sh	r0,r0[0x0]
80004ca2:	59 0c       	cp.w	r12,16

80004ca4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80004ca4:	eb cd 40 80 	pushm	r7,lr
80004ca8:	1a 97       	mov	r7,sp
80004caa:	20 1d       	sub	sp,4
80004cac:	ef 4c ff fc 	st.w	r7[-4],r12
	if( pv )
80004cb0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004cb4:	58 08       	cp.w	r8,0
80004cb6:	c0 90       	breq	80004cc8 <vPortFree+0x24>
	{
		vTaskSuspendAll();
80004cb8:	f0 1f 00 06 	mcall	80004cd0 <vPortFree+0x2c>
		{
			free( pv );
80004cbc:	ee fc ff fc 	ld.w	r12,r7[-4]
80004cc0:	f0 1f 00 05 	mcall	80004cd4 <vPortFree+0x30>
		}
		xTaskResumeAll();
80004cc4:	f0 1f 00 05 	mcall	80004cd8 <vPortFree+0x34>
	}
}
80004cc8:	2f fd       	sub	sp,-4
80004cca:	e3 cd 80 80 	ldm	sp++,r7,pc
80004cce:	00 00       	add	r0,r0
80004cd0:	80 00       	ld.sh	r0,r0[0x0]
80004cd2:	58 f0       	cp.w	r0,15
80004cd4:	80 00       	ld.sh	r0,r0[0x0]
80004cd6:	64 88       	ld.w	r8,r2[0x20]
80004cd8:	80 00       	ld.sh	r0,r0[0x0]
80004cda:	59 0c       	cp.w	r12,16

80004cdc <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80004cdc:	eb cd 40 80 	pushm	r7,lr
80004ce0:	1a 97       	mov	r7,sp
80004ce2:	20 5d       	sub	sp,20
80004ce4:	ef 4c ff f0 	st.w	r7[-16],r12
80004ce8:	ef 4b ff ec 	st.w	r7[-20],r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
80004cec:	30 08       	mov	r8,0
80004cee:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80004cf2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004cf6:	58 08       	cp.w	r8,0
80004cf8:	c7 20       	breq	80004ddc <xQueueCreate+0x100>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80004cfa:	34 cc       	mov	r12,76
80004cfc:	f0 1f 00 3b 	mcall	80004de8 <xQueueCreate+0x10c>
80004d00:	18 98       	mov	r8,r12
80004d02:	ef 48 ff f4 	st.w	r7[-12],r8
		if( pxNewQueue != NULL )
80004d06:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d0a:	58 08       	cp.w	r8,0
80004d0c:	c6 80       	breq	80004ddc <xQueueCreate+0x100>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80004d0e:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004d12:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004d16:	f2 08 02 48 	mul	r8,r9,r8
80004d1a:	2f f8       	sub	r8,-1
80004d1c:	ef 48 ff f8 	st.w	r7[-8],r8

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80004d20:	ee fc ff f8 	ld.w	r12,r7[-8]
80004d24:	f0 1f 00 31 	mcall	80004de8 <xQueueCreate+0x10c>
80004d28:	18 98       	mov	r8,r12
80004d2a:	10 99       	mov	r9,r8
80004d2c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d30:	91 09       	st.w	r8[0x0],r9
			if( pxNewQueue->pcHead != NULL )
80004d32:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d36:	70 08       	ld.w	r8,r8[0x0]
80004d38:	58 08       	cp.w	r8,0
80004d3a:	c4 d0       	breq	80004dd4 <xQueueCreate+0xf8>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80004d3c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d40:	70 09       	ld.w	r9,r8[0x0]
80004d42:	ee fa ff f0 	ld.w	r10,r7[-16]
80004d46:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004d4a:	f4 08 02 48 	mul	r8,r10,r8
80004d4e:	10 09       	add	r9,r8
80004d50:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d54:	91 19       	st.w	r8[0x4],r9
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80004d56:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d5a:	30 09       	mov	r9,0
80004d5c:	91 e9       	st.w	r8[0x38],r9
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80004d5e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d62:	70 09       	ld.w	r9,r8[0x0]
80004d64:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d68:	91 29       	st.w	r8[0x8],r9
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80004d6a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d6e:	70 09       	ld.w	r9,r8[0x0]
80004d70:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004d74:	f0 ca 00 01 	sub	r10,r8,1
80004d78:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004d7c:	f4 08 02 48 	mul	r8,r10,r8
80004d80:	10 09       	add	r9,r8
80004d82:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d86:	91 39       	st.w	r8[0xc],r9
				pxNewQueue->uxLength = uxQueueLength;
80004d88:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d8c:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004d90:	91 f9       	st.w	r8[0x3c],r9
				pxNewQueue->uxItemSize = uxItemSize;
80004d92:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d96:	ee f9 ff ec 	ld.w	r9,r7[-20]
80004d9a:	f1 49 00 40 	st.w	r8[64],r9
				pxNewQueue->xRxLock = queueUNLOCKED;
80004d9e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004da2:	3f f9       	mov	r9,-1
80004da4:	f1 49 00 44 	st.w	r8[68],r9
				pxNewQueue->xTxLock = queueUNLOCKED;
80004da8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004dac:	3f f9       	mov	r9,-1
80004dae:	f1 49 00 48 	st.w	r8[72],r9

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80004db2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004db6:	2f 08       	sub	r8,-16
80004db8:	10 9c       	mov	r12,r8
80004dba:	f0 1f 00 0d 	mcall	80004dec <xQueueCreate+0x110>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80004dbe:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004dc2:	2d c8       	sub	r8,-36
80004dc4:	10 9c       	mov	r12,r8
80004dc6:	f0 1f 00 0a 	mcall	80004dec <xQueueCreate+0x110>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
80004dca:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004dce:	ef 48 ff fc 	st.w	r7[-4],r8
80004dd2:	c0 58       	rjmp	80004ddc <xQueueCreate+0x100>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80004dd4:	ee fc ff f4 	ld.w	r12,r7[-12]
80004dd8:	f0 1f 00 06 	mcall	80004df0 <xQueueCreate+0x114>
		}
	}

	configASSERT( xReturn );

	return xReturn;
80004ddc:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80004de0:	10 9c       	mov	r12,r8
80004de2:	2f bd       	sub	sp,-20
80004de4:	e3 cd 80 80 	ldm	sp++,r7,pc
80004de8:	80 00       	ld.sh	r0,r0[0x0]
80004dea:	4c 68       	lddpc	r8,80004f00 <xQueueGenericSend+0x10c>
80004dec:	80 00       	ld.sh	r0,r0[0x0]
80004dee:	46 4c       	lddsp	r12,sp[0x190]
80004df0:	80 00       	ld.sh	r0,r0[0x0]
80004df2:	4c a4       	lddpc	r4,80004f18 <xQueueGenericSend+0x124>

80004df4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80004df4:	eb cd 40 80 	pushm	r7,lr
80004df8:	1a 97       	mov	r7,sp
80004dfa:	20 7d       	sub	sp,28
80004dfc:	ef 4c ff f0 	st.w	r7[-16],r12
80004e00:	ef 4b ff ec 	st.w	r7[-20],r11
80004e04:	ef 4a ff e8 	st.w	r7[-24],r10
80004e08:	ef 49 ff e4 	st.w	r7[-28],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
80004e0c:	30 08       	mov	r8,0
80004e0e:	ef 48 ff fc 	st.w	r7[-4],r8
80004e12:	c0 28       	rjmp	80004e16 <xQueueGenericSend+0x22>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80004e14:	d7 03       	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80004e16:	f0 1f 00 47 	mcall	80004f30 <xQueueGenericSend+0x13c>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80004e1a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004e1e:	70 e9       	ld.w	r9,r8[0x38]
80004e20:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004e24:	70 f8       	ld.w	r8,r8[0x3c]
80004e26:	10 39       	cp.w	r9,r8
80004e28:	c1 c2       	brcc	80004e60 <xQueueGenericSend+0x6c>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80004e2a:	ee fa ff e4 	ld.w	r10,r7[-28]
80004e2e:	ee fb ff ec 	ld.w	r11,r7[-20]
80004e32:	ee fc ff f0 	ld.w	r12,r7[-16]
80004e36:	f0 1f 00 40 	mcall	80004f34 <xQueueGenericSend+0x140>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004e3a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004e3e:	70 98       	ld.w	r8,r8[0x24]
80004e40:	58 08       	cp.w	r8,0
80004e42:	c0 b0       	breq	80004e58 <xQueueGenericSend+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80004e44:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004e48:	2d c8       	sub	r8,-36
80004e4a:	10 9c       	mov	r12,r8
80004e4c:	f0 1f 00 3b 	mcall	80004f38 <xQueueGenericSend+0x144>
80004e50:	18 98       	mov	r8,r12
80004e52:	58 18       	cp.w	r8,1
80004e54:	c0 21       	brne	80004e58 <xQueueGenericSend+0x64>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80004e56:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80004e58:	f0 1f 00 39 	mcall	80004f3c <xQueueGenericSend+0x148>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80004e5c:	30 18       	mov	r8,1
80004e5e:	c6 58       	rjmp	80004f28 <xQueueGenericSend+0x134>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80004e60:	ee f8 ff e8 	ld.w	r8,r7[-24]
80004e64:	58 08       	cp.w	r8,0
80004e66:	c0 51       	brne	80004e70 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80004e68:	f0 1f 00 35 	mcall	80004f3c <xQueueGenericSend+0x148>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80004e6c:	30 08       	mov	r8,0
80004e6e:	c5 d8       	rjmp	80004f28 <xQueueGenericSend+0x134>
				}
				else if( xEntryTimeSet == pdFALSE )
80004e70:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e74:	58 08       	cp.w	r8,0
80004e76:	c0 91       	brne	80004e88 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004e78:	ee c8 00 0c 	sub	r8,r7,12
80004e7c:	10 9c       	mov	r12,r8
80004e7e:	f0 1f 00 31 	mcall	80004f40 <xQueueGenericSend+0x14c>
					xEntryTimeSet = pdTRUE;
80004e82:	30 18       	mov	r8,1
80004e84:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}
		}
		taskEXIT_CRITICAL();
80004e88:	f0 1f 00 2d 	mcall	80004f3c <xQueueGenericSend+0x148>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80004e8c:	f0 1f 00 2e 	mcall	80004f44 <xQueueGenericSend+0x150>
		prvLockQueue( pxQueue );
80004e90:	f0 1f 00 28 	mcall	80004f30 <xQueueGenericSend+0x13c>
80004e94:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004e98:	71 18       	ld.w	r8,r8[0x44]
80004e9a:	5b f8       	cp.w	r8,-1
80004e9c:	c0 61       	brne	80004ea8 <xQueueGenericSend+0xb4>
80004e9e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004ea2:	30 09       	mov	r9,0
80004ea4:	f1 49 00 44 	st.w	r8[68],r9
80004ea8:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004eac:	71 28       	ld.w	r8,r8[0x48]
80004eae:	5b f8       	cp.w	r8,-1
80004eb0:	c0 61       	brne	80004ebc <xQueueGenericSend+0xc8>
80004eb2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004eb6:	30 09       	mov	r9,0
80004eb8:	f1 49 00 48 	st.w	r8[72],r9
80004ebc:	f0 1f 00 20 	mcall	80004f3c <xQueueGenericSend+0x148>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004ec0:	ee c9 00 18 	sub	r9,r7,24
80004ec4:	ee c8 00 0c 	sub	r8,r7,12
80004ec8:	12 9b       	mov	r11,r9
80004eca:	10 9c       	mov	r12,r8
80004ecc:	f0 1f 00 1f 	mcall	80004f48 <xQueueGenericSend+0x154>
80004ed0:	18 98       	mov	r8,r12
80004ed2:	58 08       	cp.w	r8,0
80004ed4:	c2 31       	brne	80004f1a <xQueueGenericSend+0x126>
		{
			if( prvIsQueueFull( pxQueue ) )
80004ed6:	ee fc ff f0 	ld.w	r12,r7[-16]
80004eda:	f0 1f 00 1d 	mcall	80004f4c <xQueueGenericSend+0x158>
80004ede:	18 98       	mov	r8,r12
80004ee0:	58 08       	cp.w	r8,0
80004ee2:	c1 50       	breq	80004f0c <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80004ee4:	ee f9 ff e8 	ld.w	r9,r7[-24]
80004ee8:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004eec:	2f 08       	sub	r8,-16
80004eee:	12 9b       	mov	r11,r9
80004ef0:	10 9c       	mov	r12,r8
80004ef2:	f0 1f 00 18 	mcall	80004f50 <xQueueGenericSend+0x15c>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80004ef6:	ee fc ff f0 	ld.w	r12,r7[-16]
80004efa:	f0 1f 00 17 	mcall	80004f54 <xQueueGenericSend+0x160>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80004efe:	f0 1f 00 17 	mcall	80004f58 <xQueueGenericSend+0x164>
80004f02:	18 98       	mov	r8,r12
80004f04:	58 08       	cp.w	r8,0
80004f06:	c8 71       	brne	80004e14 <xQueueGenericSend+0x20>
				{
					portYIELD_WITHIN_API();
80004f08:	d7 33       	scall
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80004f0a:	c8 6b       	rjmp	80004e16 <xQueueGenericSend+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80004f0c:	ee fc ff f0 	ld.w	r12,r7[-16]
80004f10:	f0 1f 00 11 	mcall	80004f54 <xQueueGenericSend+0x160>
				( void ) xTaskResumeAll();
80004f14:	f0 1f 00 11 	mcall	80004f58 <xQueueGenericSend+0x164>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80004f18:	c7 fb       	rjmp	80004e16 <xQueueGenericSend+0x22>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80004f1a:	ee fc ff f0 	ld.w	r12,r7[-16]
80004f1e:	f0 1f 00 0e 	mcall	80004f54 <xQueueGenericSend+0x160>
			( void ) xTaskResumeAll();
80004f22:	f0 1f 00 0e 	mcall	80004f58 <xQueueGenericSend+0x164>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
80004f26:	30 08       	mov	r8,0
		}
	}
}
80004f28:	10 9c       	mov	r12,r8
80004f2a:	2f 9d       	sub	sp,-28
80004f2c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f30:	80 00       	ld.sh	r0,r0[0x0]
80004f32:	49 dc       	lddpc	r12,80004fa4 <xQueueGenericReceive+0x48>
80004f34:	80 00       	ld.sh	r0,r0[0x0]
80004f36:	51 08       	stdsp	sp[0x40],r8
80004f38:	80 00       	ld.sh	r0,r0[0x0]
80004f3a:	5c f4       	rol	r4
80004f3c:	80 00       	ld.sh	r0,r0[0x0]
80004f3e:	49 f8       	lddpc	r8,80004fb8 <xQueueGenericReceive+0x5c>
80004f40:	80 00       	ld.sh	r0,r0[0x0]
80004f42:	5d c4       	*unknown*
80004f44:	80 00       	ld.sh	r0,r0[0x0]
80004f46:	58 f0       	cp.w	r0,15
80004f48:	80 00       	ld.sh	r0,r0[0x0]
80004f4a:	5d f4       	*unknown*
80004f4c:	80 00       	ld.sh	r0,r0[0x0]
80004f4e:	53 5c       	stdsp	sp[0xd4],r12
80004f50:	80 00       	ld.sh	r0,r0[0x0]
80004f52:	5c 74       	castu.h	r4
80004f54:	80 00       	ld.sh	r0,r0[0x0]
80004f56:	52 54       	stdsp	sp[0x94],r4
80004f58:	80 00       	ld.sh	r0,r0[0x0]
80004f5a:	59 0c       	cp.w	r12,16

80004f5c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80004f5c:	eb cd 40 80 	pushm	r7,lr
80004f60:	1a 97       	mov	r7,sp
80004f62:	20 8d       	sub	sp,32
80004f64:	ef 4c ff ec 	st.w	r7[-20],r12
80004f68:	ef 4b ff e8 	st.w	r7[-24],r11
80004f6c:	ef 4a ff e4 	st.w	r7[-28],r10
80004f70:	ef 49 ff e0 	st.w	r7[-32],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
80004f74:	30 08       	mov	r8,0
80004f76:	ef 48 ff f8 	st.w	r7[-8],r8
80004f7a:	c0 28       	rjmp	80004f7e <xQueueGenericReceive+0x22>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
80004f7c:	d7 03       	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80004f7e:	f0 1f 00 58 	mcall	800050dc <xQueueGenericReceive+0x180>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80004f82:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004f86:	70 e8       	ld.w	r8,r8[0x38]
80004f88:	58 08       	cp.w	r8,0
80004f8a:	c4 00       	breq	8000500a <xQueueGenericReceive+0xae>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80004f8c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004f90:	70 38       	ld.w	r8,r8[0xc]
80004f92:	ef 48 ff fc 	st.w	r7[-4],r8

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80004f96:	ee fb ff e8 	ld.w	r11,r7[-24]
80004f9a:	ee fc ff ec 	ld.w	r12,r7[-20]
80004f9e:	f0 1f 00 51 	mcall	800050e0 <xQueueGenericReceive+0x184>

				if( xJustPeeking == pdFALSE )
80004fa2:	ee f8 ff e0 	ld.w	r8,r7[-32]
80004fa6:	58 08       	cp.w	r8,0
80004fa8:	c1 91       	brne	80004fda <xQueueGenericReceive+0x7e>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80004faa:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004fae:	70 e8       	ld.w	r8,r8[0x38]
80004fb0:	f0 c9 00 01 	sub	r9,r8,1
80004fb4:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004fb8:	91 e9       	st.w	r8[0x38],r9
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004fba:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004fbe:	70 48       	ld.w	r8,r8[0x10]
80004fc0:	58 08       	cp.w	r8,0
80004fc2:	c2 00       	breq	80005002 <xQueueGenericReceive+0xa6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80004fc4:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004fc8:	2f 08       	sub	r8,-16
80004fca:	10 9c       	mov	r12,r8
80004fcc:	f0 1f 00 46 	mcall	800050e4 <xQueueGenericReceive+0x188>
80004fd0:	18 98       	mov	r8,r12
80004fd2:	58 18       	cp.w	r8,1
80004fd4:	c1 71       	brne	80005002 <xQueueGenericReceive+0xa6>
						{
							portYIELD_WITHIN_API();
80004fd6:	d7 33       	scall
80004fd8:	c1 58       	rjmp	80005002 <xQueueGenericReceive+0xa6>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80004fda:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004fde:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004fe2:	91 39       	st.w	r8[0xc],r9

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004fe4:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004fe8:	70 98       	ld.w	r8,r8[0x24]
80004fea:	58 08       	cp.w	r8,0
80004fec:	c0 b0       	breq	80005002 <xQueueGenericReceive+0xa6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004fee:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004ff2:	2d c8       	sub	r8,-36
80004ff4:	10 9c       	mov	r12,r8
80004ff6:	f0 1f 00 3c 	mcall	800050e4 <xQueueGenericReceive+0x188>
80004ffa:	18 98       	mov	r8,r12
80004ffc:	58 08       	cp.w	r8,0
80004ffe:	c0 20       	breq	80005002 <xQueueGenericReceive+0xa6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005000:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005002:	f0 1f 00 3a 	mcall	800050e8 <xQueueGenericReceive+0x18c>
				return pdPASS;
80005006:	30 18       	mov	r8,1
80005008:	c6 68       	rjmp	800050d4 <xQueueGenericReceive+0x178>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000500a:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000500e:	58 08       	cp.w	r8,0
80005010:	c0 51       	brne	8000501a <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005012:	f0 1f 00 36 	mcall	800050e8 <xQueueGenericReceive+0x18c>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005016:	30 08       	mov	r8,0
80005018:	c5 e8       	rjmp	800050d4 <xQueueGenericReceive+0x178>
				}
				else if( xEntryTimeSet == pdFALSE )
8000501a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000501e:	58 08       	cp.w	r8,0
80005020:	c0 91       	brne	80005032 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005022:	ee c8 00 10 	sub	r8,r7,16
80005026:	10 9c       	mov	r12,r8
80005028:	f0 1f 00 31 	mcall	800050ec <xQueueGenericReceive+0x190>
					xEntryTimeSet = pdTRUE;
8000502c:	30 18       	mov	r8,1
8000502e:	ef 48 ff f8 	st.w	r7[-8],r8
				}
			}
		}
		taskEXIT_CRITICAL();
80005032:	f0 1f 00 2e 	mcall	800050e8 <xQueueGenericReceive+0x18c>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005036:	f0 1f 00 2f 	mcall	800050f0 <xQueueGenericReceive+0x194>
		prvLockQueue( pxQueue );
8000503a:	f0 1f 00 29 	mcall	800050dc <xQueueGenericReceive+0x180>
8000503e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005042:	71 18       	ld.w	r8,r8[0x44]
80005044:	5b f8       	cp.w	r8,-1
80005046:	c0 61       	brne	80005052 <xQueueGenericReceive+0xf6>
80005048:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000504c:	30 09       	mov	r9,0
8000504e:	f1 49 00 44 	st.w	r8[68],r9
80005052:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005056:	71 28       	ld.w	r8,r8[0x48]
80005058:	5b f8       	cp.w	r8,-1
8000505a:	c0 61       	brne	80005066 <xQueueGenericReceive+0x10a>
8000505c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005060:	30 09       	mov	r9,0
80005062:	f1 49 00 48 	st.w	r8[72],r9
80005066:	f0 1f 00 21 	mcall	800050e8 <xQueueGenericReceive+0x18c>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000506a:	ee c9 00 1c 	sub	r9,r7,28
8000506e:	ee c8 00 10 	sub	r8,r7,16
80005072:	12 9b       	mov	r11,r9
80005074:	10 9c       	mov	r12,r8
80005076:	f0 1f 00 20 	mcall	800050f4 <xQueueGenericReceive+0x198>
8000507a:	18 98       	mov	r8,r12
8000507c:	58 08       	cp.w	r8,0
8000507e:	c2 41       	brne	800050c6 <xQueueGenericReceive+0x16a>
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005080:	ee fc ff ec 	ld.w	r12,r7[-20]
80005084:	f0 1f 00 1d 	mcall	800050f8 <xQueueGenericReceive+0x19c>
80005088:	18 98       	mov	r8,r12
8000508a:	58 08       	cp.w	r8,0
8000508c:	c1 60       	breq	800050b8 <xQueueGenericReceive+0x15c>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000508e:	ee f9 ff e4 	ld.w	r9,r7[-28]
80005092:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005096:	2d c8       	sub	r8,-36
80005098:	12 9b       	mov	r11,r9
8000509a:	10 9c       	mov	r12,r8
8000509c:	f0 1f 00 18 	mcall	800050fc <xQueueGenericReceive+0x1a0>
				prvUnlockQueue( pxQueue );
800050a0:	ee fc ff ec 	ld.w	r12,r7[-20]
800050a4:	f0 1f 00 17 	mcall	80005100 <xQueueGenericReceive+0x1a4>
				if( !xTaskResumeAll() )
800050a8:	f0 1f 00 17 	mcall	80005104 <xQueueGenericReceive+0x1a8>
800050ac:	18 98       	mov	r8,r12
800050ae:	58 08       	cp.w	r8,0
800050b0:	fe 91 ff 66 	brne	80004f7c <xQueueGenericReceive+0x20>
				{
					portYIELD_WITHIN_API();
800050b4:	d7 33       	scall
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800050b6:	c6 4b       	rjmp	80004f7e <xQueueGenericReceive+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800050b8:	ee fc ff ec 	ld.w	r12,r7[-20]
800050bc:	f0 1f 00 11 	mcall	80005100 <xQueueGenericReceive+0x1a4>
				( void ) xTaskResumeAll();
800050c0:	f0 1f 00 11 	mcall	80005104 <xQueueGenericReceive+0x1a8>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800050c4:	c5 db       	rjmp	80004f7e <xQueueGenericReceive+0x22>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800050c6:	ee fc ff ec 	ld.w	r12,r7[-20]
800050ca:	f0 1f 00 0e 	mcall	80005100 <xQueueGenericReceive+0x1a4>
			( void ) xTaskResumeAll();
800050ce:	f0 1f 00 0e 	mcall	80005104 <xQueueGenericReceive+0x1a8>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
800050d2:	30 08       	mov	r8,0
		}
	}
}
800050d4:	10 9c       	mov	r12,r8
800050d6:	2f 8d       	sub	sp,-32
800050d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800050dc:	80 00       	ld.sh	r0,r0[0x0]
800050de:	49 dc       	lddpc	r12,80005150 <prvCopyDataToQueue+0x48>
800050e0:	80 00       	ld.sh	r0,r0[0x0]
800050e2:	51 e8       	stdsp	sp[0x78],r8
800050e4:	80 00       	ld.sh	r0,r0[0x0]
800050e6:	5c f4       	rol	r4
800050e8:	80 00       	ld.sh	r0,r0[0x0]
800050ea:	49 f8       	lddpc	r8,80005164 <prvCopyDataToQueue+0x5c>
800050ec:	80 00       	ld.sh	r0,r0[0x0]
800050ee:	5d c4       	*unknown*
800050f0:	80 00       	ld.sh	r0,r0[0x0]
800050f2:	58 f0       	cp.w	r0,15
800050f4:	80 00       	ld.sh	r0,r0[0x0]
800050f6:	5d f4       	*unknown*
800050f8:	80 00       	ld.sh	r0,r0[0x0]
800050fa:	53 24       	stdsp	sp[0xc8],r4
800050fc:	80 00       	ld.sh	r0,r0[0x0]
800050fe:	5c 74       	castu.h	r4
80005100:	80 00       	ld.sh	r0,r0[0x0]
80005102:	52 54       	stdsp	sp[0x94],r4
80005104:	80 00       	ld.sh	r0,r0[0x0]
80005106:	59 0c       	cp.w	r12,16

80005108 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005108:	eb cd 40 80 	pushm	r7,lr
8000510c:	1a 97       	mov	r7,sp
8000510e:	20 3d       	sub	sp,12
80005110:	ef 4c ff fc 	st.w	r7[-4],r12
80005114:	ef 4b ff f8 	st.w	r7[-8],r11
80005118:	ef 4a ff f4 	st.w	r7[-12],r10
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000511c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005120:	71 08       	ld.w	r8,r8[0x40]
80005122:	58 08       	cp.w	r8,0
80005124:	c5 40       	breq	800051cc <prvCopyDataToQueue+0xc4>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005126:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000512a:	58 08       	cp.w	r8,0
8000512c:	c2 61       	brne	80005178 <prvCopyDataToQueue+0x70>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000512e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005132:	71 09       	ld.w	r9,r8[0x40]
80005134:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005138:	70 28       	ld.w	r8,r8[0x8]
8000513a:	12 9a       	mov	r10,r9
8000513c:	ee fb ff f8 	ld.w	r11,r7[-8]
80005140:	10 9c       	mov	r12,r8
80005142:	f0 1f 00 29 	mcall	800051e4 <prvCopyDataToQueue+0xdc>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005146:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000514a:	70 29       	ld.w	r9,r8[0x8]
8000514c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005150:	71 08       	ld.w	r8,r8[0x40]
80005152:	10 09       	add	r9,r8
80005154:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005158:	91 29       	st.w	r8[0x8],r9
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000515a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000515e:	70 29       	ld.w	r9,r8[0x8]
80005160:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005164:	70 18       	ld.w	r8,r8[0x4]
80005166:	10 39       	cp.w	r9,r8
80005168:	c3 23       	brcs	800051cc <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000516a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000516e:	70 09       	ld.w	r9,r8[0x0]
80005170:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005174:	91 29       	st.w	r8[0x8],r9
80005176:	c2 b8       	rjmp	800051cc <prvCopyDataToQueue+0xc4>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005178:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000517c:	71 09       	ld.w	r9,r8[0x40]
8000517e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005182:	70 38       	ld.w	r8,r8[0xc]
80005184:	12 9a       	mov	r10,r9
80005186:	ee fb ff f8 	ld.w	r11,r7[-8]
8000518a:	10 9c       	mov	r12,r8
8000518c:	f0 1f 00 16 	mcall	800051e4 <prvCopyDataToQueue+0xdc>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005190:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005194:	70 39       	ld.w	r9,r8[0xc]
80005196:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000519a:	71 08       	ld.w	r8,r8[0x40]
8000519c:	5c 38       	neg	r8
8000519e:	10 09       	add	r9,r8
800051a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051a4:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800051a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051aa:	70 39       	ld.w	r9,r8[0xc]
800051ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051b0:	70 08       	ld.w	r8,r8[0x0]
800051b2:	10 39       	cp.w	r9,r8
800051b4:	c0 c2       	brcc	800051cc <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800051b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051ba:	70 19       	ld.w	r9,r8[0x4]
800051bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051c0:	71 08       	ld.w	r8,r8[0x40]
800051c2:	5c 38       	neg	r8
800051c4:	10 09       	add	r9,r8
800051c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051ca:	91 39       	st.w	r8[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800051cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051d0:	70 e8       	ld.w	r8,r8[0x38]
800051d2:	f0 c9 ff ff 	sub	r9,r8,-1
800051d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051da:	91 e9       	st.w	r8[0x38],r9
}
800051dc:	2f dd       	sub	sp,-12
800051de:	e3 cd 80 80 	ldm	sp++,r7,pc
800051e2:	00 00       	add	r0,r0
800051e4:	80 00       	ld.sh	r0,r0[0x0]
800051e6:	68 dc       	ld.w	r12,r4[0x34]

800051e8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800051e8:	eb cd 40 80 	pushm	r7,lr
800051ec:	1a 97       	mov	r7,sp
800051ee:	20 2d       	sub	sp,8
800051f0:	ef 4c ff fc 	st.w	r7[-4],r12
800051f4:	ef 4b ff f8 	st.w	r7[-8],r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800051f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051fc:	70 08       	ld.w	r8,r8[0x0]
800051fe:	58 08       	cp.w	r8,0
80005200:	c2 50       	breq	8000524a <prvCopyDataFromQueue+0x62>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005202:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005206:	70 39       	ld.w	r9,r8[0xc]
80005208:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000520c:	71 08       	ld.w	r8,r8[0x40]
8000520e:	10 09       	add	r9,r8
80005210:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005214:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005216:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000521a:	70 39       	ld.w	r9,r8[0xc]
8000521c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005220:	70 18       	ld.w	r8,r8[0x4]
80005222:	10 39       	cp.w	r9,r8
80005224:	c0 73       	brcs	80005232 <prvCopyDataFromQueue+0x4a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005226:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000522a:	70 09       	ld.w	r9,r8[0x0]
8000522c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005230:	91 39       	st.w	r8[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005232:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005236:	71 09       	ld.w	r9,r8[0x40]
80005238:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000523c:	70 38       	ld.w	r8,r8[0xc]
8000523e:	12 9a       	mov	r10,r9
80005240:	10 9b       	mov	r11,r8
80005242:	ee fc ff f8 	ld.w	r12,r7[-8]
80005246:	f0 1f 00 03 	mcall	80005250 <prvCopyDataFromQueue+0x68>
	}
}
8000524a:	2f ed       	sub	sp,-8
8000524c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005250:	80 00       	ld.sh	r0,r0[0x0]
80005252:	68 dc       	ld.w	r12,r4[0x34]

80005254 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005254:	eb cd 40 80 	pushm	r7,lr
80005258:	1a 97       	mov	r7,sp
8000525a:	20 1d       	sub	sp,4
8000525c:	ef 4c ff fc 	st.w	r7[-4],r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005260:	f0 1f 00 2d 	mcall	80005314 <prvUnlockQueue+0xc0>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005264:	c1 a8       	rjmp	80005298 <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005266:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000526a:	70 98       	ld.w	r8,r8[0x24]
8000526c:	58 08       	cp.w	r8,0
8000526e:	c1 c0       	breq	800052a6 <prvUnlockQueue+0x52>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005270:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005274:	2d c8       	sub	r8,-36
80005276:	10 9c       	mov	r12,r8
80005278:	f0 1f 00 28 	mcall	80005318 <prvUnlockQueue+0xc4>
8000527c:	18 98       	mov	r8,r12
8000527e:	58 08       	cp.w	r8,0
80005280:	c0 30       	breq	80005286 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005282:	f0 1f 00 27 	mcall	8000531c <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xTxLock );
80005286:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000528a:	71 28       	ld.w	r8,r8[0x48]
8000528c:	f0 c9 00 01 	sub	r9,r8,1
80005290:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005294:	f1 49 00 48 	st.w	r8[72],r9
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005298:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000529c:	71 28       	ld.w	r8,r8[0x48]
8000529e:	58 08       	cp.w	r8,0
800052a0:	fe 99 ff e3 	brgt	80005266 <prvUnlockQueue+0x12>
800052a4:	c0 28       	rjmp	800052a8 <prvUnlockQueue+0x54>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
800052a6:	d7 03       	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800052a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052ac:	3f f9       	mov	r9,-1
800052ae:	f1 49 00 48 	st.w	r8[72],r9
	}
	taskEXIT_CRITICAL();
800052b2:	f0 1f 00 1c 	mcall	80005320 <prvUnlockQueue+0xcc>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800052b6:	f0 1f 00 18 	mcall	80005314 <prvUnlockQueue+0xc0>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800052ba:	c1 a8       	rjmp	800052ee <prvUnlockQueue+0x9a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800052bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052c0:	70 48       	ld.w	r8,r8[0x10]
800052c2:	58 08       	cp.w	r8,0
800052c4:	c1 c0       	breq	800052fc <prvUnlockQueue+0xa8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800052c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052ca:	2f 08       	sub	r8,-16
800052cc:	10 9c       	mov	r12,r8
800052ce:	f0 1f 00 13 	mcall	80005318 <prvUnlockQueue+0xc4>
800052d2:	18 98       	mov	r8,r12
800052d4:	58 08       	cp.w	r8,0
800052d6:	c0 30       	breq	800052dc <prvUnlockQueue+0x88>
				{
					vTaskMissedYield();
800052d8:	f0 1f 00 11 	mcall	8000531c <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xRxLock );
800052dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052e0:	71 18       	ld.w	r8,r8[0x44]
800052e2:	f0 c9 00 01 	sub	r9,r8,1
800052e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052ea:	f1 49 00 44 	st.w	r8[68],r9
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800052ee:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052f2:	71 18       	ld.w	r8,r8[0x44]
800052f4:	58 08       	cp.w	r8,0
800052f6:	fe 99 ff e3 	brgt	800052bc <prvUnlockQueue+0x68>
800052fa:	c0 28       	rjmp	800052fe <prvUnlockQueue+0xaa>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
800052fc:	d7 03       	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800052fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005302:	3f f9       	mov	r9,-1
80005304:	f1 49 00 44 	st.w	r8[68],r9
	}
	taskEXIT_CRITICAL();
80005308:	f0 1f 00 06 	mcall	80005320 <prvUnlockQueue+0xcc>
}
8000530c:	2f fd       	sub	sp,-4
8000530e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005312:	00 00       	add	r0,r0
80005314:	80 00       	ld.sh	r0,r0[0x0]
80005316:	49 dc       	lddpc	r12,80005388 <prvIsQueueFull+0x2c>
80005318:	80 00       	ld.sh	r0,r0[0x0]
8000531a:	5c f4       	rol	r4
8000531c:	80 00       	ld.sh	r0,r0[0x0]
8000531e:	5e ac       	retle	r12
80005320:	80 00       	ld.sh	r0,r0[0x0]
80005322:	49 f8       	lddpc	r8,8000539c <prvIsQueueFull+0x40>

80005324 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
80005324:	eb cd 40 80 	pushm	r7,lr
80005328:	1a 97       	mov	r7,sp
8000532a:	20 2d       	sub	sp,8
8000532c:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005330:	f0 1f 00 09 	mcall	80005354 <prvIsQueueEmpty+0x30>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005334:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005338:	70 e8       	ld.w	r8,r8[0x38]
8000533a:	58 08       	cp.w	r8,0
8000533c:	5f 08       	sreq	r8
8000533e:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80005342:	f0 1f 00 06 	mcall	80005358 <prvIsQueueEmpty+0x34>

	return xReturn;
80005346:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000534a:	10 9c       	mov	r12,r8
8000534c:	2f ed       	sub	sp,-8
8000534e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005352:	00 00       	add	r0,r0
80005354:	80 00       	ld.sh	r0,r0[0x0]
80005356:	49 dc       	lddpc	r12,800053c8 <xTaskGenericCreate+0x28>
80005358:	80 00       	ld.sh	r0,r0[0x0]
8000535a:	49 f8       	lddpc	r8,800053d4 <xTaskGenericCreate+0x34>

8000535c <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
8000535c:	eb cd 40 80 	pushm	r7,lr
80005360:	1a 97       	mov	r7,sp
80005362:	20 2d       	sub	sp,8
80005364:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005368:	f0 1f 00 0a 	mcall	80005390 <prvIsQueueFull+0x34>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
8000536c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005370:	70 e9       	ld.w	r9,r8[0x38]
80005372:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005376:	70 f8       	ld.w	r8,r8[0x3c]
80005378:	10 39       	cp.w	r9,r8
8000537a:	5f 08       	sreq	r8
8000537c:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80005380:	f0 1f 00 05 	mcall	80005394 <prvIsQueueFull+0x38>

	return xReturn;
80005384:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005388:	10 9c       	mov	r12,r8
8000538a:	2f ed       	sub	sp,-8
8000538c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005390:	80 00       	ld.sh	r0,r0[0x0]
80005392:	49 dc       	lddpc	r12,80005404 <xTaskGenericCreate+0x64>
80005394:	80 00       	ld.sh	r0,r0[0x0]
80005396:	49 f8       	lddpc	r8,80005410 <xTaskGenericCreate+0x70>
80005398:	49 44       	lddpc	r4,800053e8 <xTaskGenericCreate+0x48>
8000539a:	4c 45       	lddpc	r5,800054a8 <xTaskGenericCreate+0x108>
8000539c:	00 00       	add	r0,r0
	...

800053a0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800053a0:	eb cd 40 c0 	pushm	r6-r7,lr
800053a4:	1a 97       	mov	r7,sp
800053a6:	20 8d       	sub	sp,32
800053a8:	ee c6 ff f4 	sub	r6,r7,-12
800053ac:	ef 4c ff f0 	st.w	r7[-16],r12
800053b0:	ef 4b ff ec 	st.w	r7[-20],r11
800053b4:	ef 49 ff e4 	st.w	r7[-28],r9
800053b8:	ef 48 ff e0 	st.w	r7[-32],r8
800053bc:	14 98       	mov	r8,r10
800053be:	ef 58 ff e8 	st.h	r7[-24],r8
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
800053c2:	ef 18 ff e8 	ld.uh	r8,r7[-24]
800053c6:	6c 1b       	ld.w	r11,r6[0x4]
800053c8:	10 9c       	mov	r12,r8
800053ca:	f0 1f 00 5a 	mcall	80005530 <xTaskGenericCreate+0x190>
800053ce:	18 98       	mov	r8,r12
800053d0:	ef 48 ff f8 	st.w	r7[-8],r8

	if( pxNewTCB != NULL )
800053d4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800053d8:	58 08       	cp.w	r8,0
800053da:	e0 80 00 92 	breq	800054fe <xTaskGenericCreate+0x15e>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
800053de:	ee f8 ff f8 	ld.w	r8,r7[-8]
800053e2:	70 c9       	ld.w	r9,r8[0x30]
800053e4:	ef 18 ff e8 	ld.uh	r8,r7[-24]
800053e8:	20 18       	sub	r8,1
800053ea:	a3 68       	lsl	r8,0x2
800053ec:	f2 08 00 08 	add	r8,r9,r8
800053f0:	ef 48 ff fc 	st.w	r7[-4],r8
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800053f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800053f8:	e0 18 ff fc 	andl	r8,0xfffc
800053fc:	ef 48 ff fc 	st.w	r7[-4],r8
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
80005400:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80005404:	6c 29       	ld.w	r9,r6[0x8]
80005406:	ee fa ff e0 	ld.w	r10,r7[-32]
8000540a:	ee fb ff ec 	ld.w	r11,r7[-20]
8000540e:	ee fc ff f8 	ld.w	r12,r7[-8]
80005412:	f0 1f 00 49 	mcall	80005534 <xTaskGenericCreate+0x194>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005416:	ee fa ff e4 	ld.w	r10,r7[-28]
8000541a:	ee fb ff f0 	ld.w	r11,r7[-16]
8000541e:	ee fc ff fc 	ld.w	r12,r7[-4]
80005422:	f0 1f 00 46 	mcall	80005538 <xTaskGenericCreate+0x198>
80005426:	18 98       	mov	r8,r12
80005428:	10 99       	mov	r9,r8
8000542a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000542e:	91 09       	st.w	r8[0x0],r9
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
80005430:	6c 08       	ld.w	r8,r6[0x0]
80005432:	58 08       	cp.w	r8,0
80005434:	c0 50       	breq	8000543e <xTaskGenericCreate+0x9e>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005436:	6c 08       	ld.w	r8,r6[0x0]
80005438:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000543c:	91 09       	st.w	r8[0x0],r9
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
8000543e:	f0 1f 00 40 	mcall	8000553c <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
80005442:	4c 08       	lddpc	r8,80005540 <xTaskGenericCreate+0x1a0>
80005444:	70 08       	ld.w	r8,r8[0x0]
80005446:	f0 c9 ff ff 	sub	r9,r8,-1
8000544a:	4b e8       	lddpc	r8,80005540 <xTaskGenericCreate+0x1a0>
8000544c:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
8000544e:	4b e8       	lddpc	r8,80005544 <xTaskGenericCreate+0x1a4>
80005450:	70 08       	ld.w	r8,r8[0x0]
80005452:	58 08       	cp.w	r8,0
80005454:	c0 c1       	brne	8000546c <xTaskGenericCreate+0xcc>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005456:	4b c8       	lddpc	r8,80005544 <xTaskGenericCreate+0x1a4>
80005458:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000545c:	91 09       	st.w	r8[0x0],r9

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
8000545e:	4b 98       	lddpc	r8,80005540 <xTaskGenericCreate+0x1a0>
80005460:	70 08       	ld.w	r8,r8[0x0]
80005462:	58 18       	cp.w	r8,1
80005464:	c1 41       	brne	8000548c <xTaskGenericCreate+0xec>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
80005466:	f0 1f 00 39 	mcall	80005548 <xTaskGenericCreate+0x1a8>
8000546a:	c1 18       	rjmp	8000548c <xTaskGenericCreate+0xec>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
8000546c:	4b 88       	lddpc	r8,8000554c <xTaskGenericCreate+0x1ac>
8000546e:	70 08       	ld.w	r8,r8[0x0]
80005470:	58 08       	cp.w	r8,0
80005472:	c0 d1       	brne	8000548c <xTaskGenericCreate+0xec>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005474:	4b 48       	lddpc	r8,80005544 <xTaskGenericCreate+0x1a4>
80005476:	70 08       	ld.w	r8,r8[0x0]
80005478:	70 b9       	ld.w	r9,r8[0x2c]
8000547a:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000547e:	10 39       	cp.w	r9,r8
80005480:	e0 8b 00 06 	brhi	8000548c <xTaskGenericCreate+0xec>
					{
						pxCurrentTCB = pxNewTCB;
80005484:	4b 08       	lddpc	r8,80005544 <xTaskGenericCreate+0x1a4>
80005486:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000548a:	91 09       	st.w	r8[0x0],r9
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
8000548c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005490:	70 b9       	ld.w	r9,r8[0x2c]
80005492:	4b 08       	lddpc	r8,80005550 <xTaskGenericCreate+0x1b0>
80005494:	70 08       	ld.w	r8,r8[0x0]
80005496:	10 39       	cp.w	r9,r8
80005498:	e0 88 00 07 	brls	800054a6 <xTaskGenericCreate+0x106>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
8000549c:	ee f8 ff f8 	ld.w	r8,r7[-8]
800054a0:	70 b9       	ld.w	r9,r8[0x2c]
800054a2:	4a c8       	lddpc	r8,80005550 <xTaskGenericCreate+0x1b0>
800054a4:	91 09       	st.w	r8[0x0],r9
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
800054a6:	4a c8       	lddpc	r8,80005554 <xTaskGenericCreate+0x1b4>
800054a8:	70 08       	ld.w	r8,r8[0x0]
800054aa:	f0 c9 ff ff 	sub	r9,r8,-1
800054ae:	4a a8       	lddpc	r8,80005554 <xTaskGenericCreate+0x1b4>
800054b0:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
800054b2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800054b6:	70 b9       	ld.w	r9,r8[0x2c]
800054b8:	4a 88       	lddpc	r8,80005558 <xTaskGenericCreate+0x1b8>
800054ba:	70 08       	ld.w	r8,r8[0x0]
800054bc:	10 39       	cp.w	r9,r8
800054be:	e0 88 00 07 	brls	800054cc <xTaskGenericCreate+0x12c>
800054c2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800054c6:	70 b9       	ld.w	r9,r8[0x2c]
800054c8:	4a 48       	lddpc	r8,80005558 <xTaskGenericCreate+0x1b8>
800054ca:	91 09       	st.w	r8[0x0],r9
800054cc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800054d0:	f0 ca ff fc 	sub	r10,r8,-4
800054d4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800054d8:	70 b9       	ld.w	r9,r8[0x2c]
800054da:	12 98       	mov	r8,r9
800054dc:	a3 68       	lsl	r8,0x2
800054de:	12 08       	add	r8,r9
800054e0:	a3 68       	lsl	r8,0x2
800054e2:	10 99       	mov	r9,r8
800054e4:	49 e8       	lddpc	r8,8000555c <xTaskGenericCreate+0x1bc>
800054e6:	f2 08 00 08 	add	r8,r9,r8
800054ea:	14 9b       	mov	r11,r10
800054ec:	10 9c       	mov	r12,r8
800054ee:	f0 1f 00 1d 	mcall	80005560 <xTaskGenericCreate+0x1c0>

			xReturn = pdPASS;
800054f2:	30 18       	mov	r8,1
800054f4:	ef 48 ff f4 	st.w	r7[-12],r8
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800054f8:	f0 1f 00 1b 	mcall	80005564 <xTaskGenericCreate+0x1c4>
800054fc:	c0 48       	rjmp	80005504 <xTaskGenericCreate+0x164>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
800054fe:	3f f8       	mov	r8,-1
80005500:	ef 48 ff f4 	st.w	r7[-12],r8
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
80005504:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005508:	58 18       	cp.w	r8,1
8000550a:	c0 d1       	brne	80005524 <xTaskGenericCreate+0x184>
	{
		if( xSchedulerRunning != pdFALSE )
8000550c:	49 08       	lddpc	r8,8000554c <xTaskGenericCreate+0x1ac>
8000550e:	70 08       	ld.w	r8,r8[0x0]
80005510:	58 08       	cp.w	r8,0
80005512:	c0 90       	breq	80005524 <xTaskGenericCreate+0x184>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005514:	48 c8       	lddpc	r8,80005544 <xTaskGenericCreate+0x1a4>
80005516:	70 08       	ld.w	r8,r8[0x0]
80005518:	70 b9       	ld.w	r9,r8[0x2c]
8000551a:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000551e:	10 39       	cp.w	r9,r8
80005520:	c0 22       	brcc	80005524 <xTaskGenericCreate+0x184>
			{
				portYIELD_WITHIN_API();
80005522:	d7 33       	scall
			}
		}
	}

	return xReturn;
80005524:	ee f8 ff f4 	ld.w	r8,r7[-12]
}
80005528:	10 9c       	mov	r12,r8
8000552a:	2f 8d       	sub	sp,-32
8000552c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005530:	80 00       	ld.sh	r0,r0[0x0]
80005532:	61 34       	ld.w	r4,r0[0x4c]
80005534:	80 00       	ld.sh	r0,r0[0x0]
80005536:	5e ec       	retqs	r12
80005538:	80 00       	ld.sh	r0,r0[0x0]
8000553a:	4a 24       	lddpc	r4,800055c0 <vTaskPrioritySet+0x58>
8000553c:	80 00       	ld.sh	r0,r0[0x0]
8000553e:	49 dc       	lddpc	r12,800055b0 <vTaskPrioritySet+0x48>
80005540:	00 00       	add	r0,r0
80005542:	07 74       	ld.ub	r4,--r3
80005544:	00 00       	add	r0,r0
80005546:	06 60       	and	r0,r3
80005548:	80 00       	ld.sh	r0,r0[0x0]
8000554a:	5f 88       	srls	r8
8000554c:	00 00       	add	r0,r0
8000554e:	07 84       	ld.ub	r4,r3[0x0]
80005550:	00 00       	add	r0,r0
80005552:	07 7c       	ld.ub	r12,--r3
80005554:	00 00       	add	r0,r0
80005556:	07 98       	ld.ub	r8,r3[0x1]
80005558:	00 00       	add	r0,r0
8000555a:	07 80       	ld.ub	r0,r3[0x0]
8000555c:	00 00       	add	r0,r0
8000555e:	06 64       	and	r4,r3
80005560:	80 00       	ld.sh	r0,r0[0x0]
80005562:	46 b2       	lddsp	r2,sp[0x1ac]
80005564:	80 00       	ld.sh	r0,r0[0x0]
80005566:	49 f8       	lddpc	r8,800055e0 <vTaskPrioritySet+0x78>

80005568 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
80005568:	eb cd 40 80 	pushm	r7,lr
8000556c:	1a 97       	mov	r7,sp
8000556e:	20 5d       	sub	sp,20
80005570:	ef 4c ff f0 	st.w	r7[-16],r12
80005574:	ef 4b ff ec 	st.w	r7[-20],r11
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentPriority;
	portBASE_TYPE xYieldRequired = pdFALSE;
80005578:	30 08       	mov	r8,0
8000557a:	ef 48 ff fc 	st.w	r7[-4],r8

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= configMAX_PRIORITIES )
8000557e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005582:	58 78       	cp.w	r8,7
80005584:	e0 88 00 05 	brls	8000558e <vTaskPrioritySet+0x26>
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
80005588:	30 78       	mov	r8,7
8000558a:	ef 48 ff ec 	st.w	r7[-20],r8
		}

		taskENTER_CRITICAL();
8000558e:	f0 1f 00 42 	mcall	80005694 <vTaskPrioritySet+0x12c>
		{
			if( pxTask == pxCurrentTCB )
80005592:	4c 28       	lddpc	r8,80005698 <vTaskPrioritySet+0x130>
80005594:	70 08       	ld.w	r8,r8[0x0]
80005596:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000559a:	10 39       	cp.w	r9,r8
8000559c:	c0 41       	brne	800055a4 <vTaskPrioritySet+0x3c>
			{
				pxTask = NULL;
8000559e:	30 08       	mov	r8,0
800055a0:	ef 48 ff f0 	st.w	r7[-16],r8
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
800055a4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800055a8:	58 08       	cp.w	r8,0
800055aa:	c0 41       	brne	800055b2 <vTaskPrioritySet+0x4a>
800055ac:	4b b8       	lddpc	r8,80005698 <vTaskPrioritySet+0x130>
800055ae:	70 08       	ld.w	r8,r8[0x0]
800055b0:	c0 38       	rjmp	800055b6 <vTaskPrioritySet+0x4e>
800055b2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800055b6:	ef 48 ff f4 	st.w	r7[-12],r8
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentPriority = pxTCB->uxPriority;
800055ba:	ee f8 ff f4 	ld.w	r8,r7[-12]
800055be:	70 b8       	ld.w	r8,r8[0x2c]
800055c0:	ef 48 ff f8 	st.w	r7[-8],r8
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
800055c4:	ee f9 ff f8 	ld.w	r9,r7[-8]
800055c8:	ee f8 ff ec 	ld.w	r8,r7[-20]
800055cc:	10 39       	cp.w	r9,r8
800055ce:	c5 d0       	breq	80005688 <vTaskPrioritySet+0x120>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
800055d0:	ee f9 ff ec 	ld.w	r9,r7[-20]
800055d4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800055d8:	10 39       	cp.w	r9,r8
800055da:	e0 88 00 0a 	brls	800055ee <vTaskPrioritySet+0x86>
				{
					if( pxTask != NULL )
800055de:	ee f8 ff f0 	ld.w	r8,r7[-16]
800055e2:	58 08       	cp.w	r8,0
800055e4:	c0 c0       	breq	800055fc <vTaskPrioritySet+0x94>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
800055e6:	30 18       	mov	r8,1
800055e8:	ef 48 ff fc 	st.w	r7[-4],r8
800055ec:	c0 88       	rjmp	800055fc <vTaskPrioritySet+0x94>
					}
				}
				else if( pxTask == NULL )
800055ee:	ee f8 ff f0 	ld.w	r8,r7[-16]
800055f2:	58 08       	cp.w	r8,0
800055f4:	c0 41       	brne	800055fc <vTaskPrioritySet+0x94>
				{
					/* Setting our own priority down means there may now be another
					task of higher priority that is ready to execute. */
					xYieldRequired = pdTRUE;
800055f6:	30 18       	mov	r8,1
800055f8:	ef 48 ff fc 	st.w	r7[-4],r8
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
800055fc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005600:	ee f9 ff ec 	ld.w	r9,r7[-20]
80005604:	91 b9       	st.w	r8[0x2c],r9
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
80005606:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000560a:	f0 09 11 08 	rsub	r9,r8,8
8000560e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005612:	91 69       	st.w	r8[0x18],r9

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
80005614:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005618:	70 5a       	ld.w	r10,r8[0x14]
8000561a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000561e:	12 98       	mov	r8,r9
80005620:	a3 68       	lsl	r8,0x2
80005622:	12 08       	add	r8,r9
80005624:	a3 68       	lsl	r8,0x2
80005626:	10 99       	mov	r9,r8
80005628:	49 d8       	lddpc	r8,8000569c <vTaskPrioritySet+0x134>
8000562a:	f2 08 00 08 	add	r8,r9,r8
8000562e:	10 3a       	cp.w	r10,r8
80005630:	c2 71       	brne	8000567e <vTaskPrioritySet+0x116>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
80005632:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005636:	2f c8       	sub	r8,-4
80005638:	10 9c       	mov	r12,r8
8000563a:	f0 1f 00 1a 	mcall	800056a0 <vTaskPrioritySet+0x138>
					prvAddTaskToReadyQueue( pxTCB );
8000563e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005642:	70 b9       	ld.w	r9,r8[0x2c]
80005644:	49 88       	lddpc	r8,800056a4 <vTaskPrioritySet+0x13c>
80005646:	70 08       	ld.w	r8,r8[0x0]
80005648:	10 39       	cp.w	r9,r8
8000564a:	e0 88 00 07 	brls	80005658 <vTaskPrioritySet+0xf0>
8000564e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005652:	70 b9       	ld.w	r9,r8[0x2c]
80005654:	49 48       	lddpc	r8,800056a4 <vTaskPrioritySet+0x13c>
80005656:	91 09       	st.w	r8[0x0],r9
80005658:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000565c:	f0 ca ff fc 	sub	r10,r8,-4
80005660:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005664:	70 b9       	ld.w	r9,r8[0x2c]
80005666:	12 98       	mov	r8,r9
80005668:	a3 68       	lsl	r8,0x2
8000566a:	12 08       	add	r8,r9
8000566c:	a3 68       	lsl	r8,0x2
8000566e:	10 99       	mov	r9,r8
80005670:	48 b8       	lddpc	r8,8000569c <vTaskPrioritySet+0x134>
80005672:	f2 08 00 08 	add	r8,r9,r8
80005676:	14 9b       	mov	r11,r10
80005678:	10 9c       	mov	r12,r8
8000567a:	f0 1f 00 0c 	mcall	800056a8 <vTaskPrioritySet+0x140>
				}

				if( xYieldRequired == pdTRUE )
8000567e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005682:	58 18       	cp.w	r8,1
80005684:	c0 21       	brne	80005688 <vTaskPrioritySet+0x120>
				{
					portYIELD_WITHIN_API();
80005686:	d7 33       	scall
				}
			}
		}
		taskEXIT_CRITICAL();
80005688:	f0 1f 00 09 	mcall	800056ac <vTaskPrioritySet+0x144>
	}
8000568c:	2f bd       	sub	sp,-20
8000568e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005692:	00 00       	add	r0,r0
80005694:	80 00       	ld.sh	r0,r0[0x0]
80005696:	49 dc       	lddpc	r12,80005708 <vTaskSuspend+0x58>
80005698:	00 00       	add	r0,r0
8000569a:	06 60       	and	r0,r3
8000569c:	00 00       	add	r0,r0
8000569e:	06 64       	and	r4,r3
800056a0:	80 00       	ld.sh	r0,r0[0x0]
800056a2:	47 c6       	lddsp	r6,sp[0x1f0]
800056a4:	00 00       	add	r0,r0
800056a6:	07 80       	ld.ub	r0,r3[0x0]
800056a8:	80 00       	ld.sh	r0,r0[0x0]
800056aa:	46 b2       	lddsp	r2,sp[0x1ac]
800056ac:	80 00       	ld.sh	r0,r0[0x0]
800056ae:	49 f8       	lddpc	r8,80005728 <vTaskSuspend+0x78>

800056b0 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
800056b0:	eb cd 40 80 	pushm	r7,lr
800056b4:	1a 97       	mov	r7,sp
800056b6:	20 2d       	sub	sp,8
800056b8:	ef 4c ff f8 	st.w	r7[-8],r12
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
800056bc:	f0 1f 00 24 	mcall	8000574c <vTaskSuspend+0x9c>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
800056c0:	4a 48       	lddpc	r8,80005750 <vTaskSuspend+0xa0>
800056c2:	70 08       	ld.w	r8,r8[0x0]
800056c4:	ee f9 ff f8 	ld.w	r9,r7[-8]
800056c8:	10 39       	cp.w	r9,r8
800056ca:	c0 41       	brne	800056d2 <vTaskSuspend+0x22>
			{
				pxTaskToSuspend = NULL;
800056cc:	30 08       	mov	r8,0
800056ce:	ef 48 ff f8 	st.w	r7[-8],r8
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
800056d2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800056d6:	58 08       	cp.w	r8,0
800056d8:	c0 41       	brne	800056e0 <vTaskSuspend+0x30>
800056da:	49 e8       	lddpc	r8,80005750 <vTaskSuspend+0xa0>
800056dc:	70 08       	ld.w	r8,r8[0x0]
800056de:	c0 38       	rjmp	800056e4 <vTaskSuspend+0x34>
800056e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800056e4:	ef 48 ff fc 	st.w	r7[-4],r8

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
800056e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056ec:	2f c8       	sub	r8,-4
800056ee:	10 9c       	mov	r12,r8
800056f0:	f0 1f 00 19 	mcall	80005754 <vTaskSuspend+0xa4>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
800056f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056f8:	70 a8       	ld.w	r8,r8[0x28]
800056fa:	58 08       	cp.w	r8,0
800056fc:	c0 70       	breq	8000570a <vTaskSuspend+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
800056fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005702:	2e 88       	sub	r8,-24
80005704:	10 9c       	mov	r12,r8
80005706:	f0 1f 00 14 	mcall	80005754 <vTaskSuspend+0xa4>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
8000570a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000570e:	2f c8       	sub	r8,-4
80005710:	10 9b       	mov	r11,r8
80005712:	49 2c       	lddpc	r12,80005758 <vTaskSuspend+0xa8>
80005714:	f0 1f 00 12 	mcall	8000575c <vTaskSuspend+0xac>
		}
		taskEXIT_CRITICAL();
80005718:	f0 1f 00 12 	mcall	80005760 <vTaskSuspend+0xb0>

		if( ( void * ) pxTaskToSuspend == NULL )
8000571c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005720:	58 08       	cp.w	r8,0
80005722:	c1 11       	brne	80005744 <vTaskSuspend+0x94>
		{
			if( xSchedulerRunning != pdFALSE )
80005724:	49 08       	lddpc	r8,80005764 <vTaskSuspend+0xb4>
80005726:	70 08       	ld.w	r8,r8[0x0]
80005728:	58 08       	cp.w	r8,0
8000572a:	c0 30       	breq	80005730 <vTaskSuspend+0x80>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
8000572c:	d7 33       	scall
8000572e:	c0 b8       	rjmp	80005744 <vTaskSuspend+0x94>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1U )
80005730:	48 e8       	lddpc	r8,80005768 <vTaskSuspend+0xb8>
80005732:	70 08       	ld.w	r8,r8[0x0]
80005734:	58 18       	cp.w	r8,1
80005736:	c0 51       	brne	80005740 <vTaskSuspend+0x90>
				{
					/* No other tasks are defined, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
80005738:	48 68       	lddpc	r8,80005750 <vTaskSuspend+0xa0>
8000573a:	30 09       	mov	r9,0
8000573c:	91 09       	st.w	r8[0x0],r9
8000573e:	c0 38       	rjmp	80005744 <vTaskSuspend+0x94>
				}
				else
				{
					vTaskSwitchContext();
80005740:	f0 1f 00 0b 	mcall	8000576c <vTaskSuspend+0xbc>
				}
			}
		}
	}
80005744:	2f ed       	sub	sp,-8
80005746:	e3 cd 80 80 	ldm	sp++,r7,pc
8000574a:	00 00       	add	r0,r0
8000574c:	80 00       	ld.sh	r0,r0[0x0]
8000574e:	49 dc       	lddpc	r12,800057c0 <xTaskIsTaskSuspended+0x50>
80005750:	00 00       	add	r0,r0
80005752:	06 60       	and	r0,r3
80005754:	80 00       	ld.sh	r0,r0[0x0]
80005756:	47 c6       	lddsp	r6,sp[0x1f0]
80005758:	00 00       	add	r0,r0
8000575a:	07 60       	ld.uh	r0,--r3
8000575c:	80 00       	ld.sh	r0,r0[0x0]
8000575e:	46 b2       	lddsp	r2,sp[0x1ac]
80005760:	80 00       	ld.sh	r0,r0[0x0]
80005762:	49 f8       	lddpc	r8,800057dc <vTaskResume+0x14>
80005764:	00 00       	add	r0,r0
80005766:	07 84       	ld.ub	r4,r3[0x0]
80005768:	00 00       	add	r0,r0
8000576a:	07 74       	ld.ub	r4,--r3
8000576c:	80 00       	ld.sh	r0,r0[0x0]
8000576e:	5b c4       	cp.w	r4,-4

80005770 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
80005770:	eb cd 40 80 	pushm	r7,lr
80005774:	1a 97       	mov	r7,sp
80005776:	20 3d       	sub	sp,12
80005778:	ef 4c ff f4 	st.w	r7[-12],r12
	portBASE_TYPE xReturn = pdFALSE;
8000577c:	30 08       	mov	r8,0
8000577e:	ef 48 ff f8 	st.w	r7[-8],r8
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
80005782:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005786:	ef 48 ff fc 	st.w	r7[-4],r8
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
8000578a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000578e:	70 59       	ld.w	r9,r8[0x14]
80005790:	48 c8       	lddpc	r8,800057c0 <xTaskIsTaskSuspended+0x50>
80005792:	10 39       	cp.w	r9,r8
80005794:	c0 f1       	brne	800057b2 <xTaskIsTaskSuspended+0x42>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
80005796:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000579a:	70 a9       	ld.w	r9,r8[0x28]
8000579c:	48 a8       	lddpc	r8,800057c4 <xTaskIsTaskSuspended+0x54>
8000579e:	10 39       	cp.w	r9,r8
800057a0:	c0 90       	breq	800057b2 <xTaskIsTaskSuspended+0x42>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
800057a2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800057a6:	70 a8       	ld.w	r8,r8[0x28]
800057a8:	58 08       	cp.w	r8,0
800057aa:	c0 41       	brne	800057b2 <xTaskIsTaskSuspended+0x42>
				{
					xReturn = pdTRUE;
800057ac:	30 18       	mov	r8,1
800057ae:	ef 48 ff f8 	st.w	r7[-8],r8
				}
			}
		}

		return xReturn;
800057b2:	ee f8 ff f8 	ld.w	r8,r7[-8]
	}
800057b6:	10 9c       	mov	r12,r8
800057b8:	2f dd       	sub	sp,-12
800057ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800057be:	00 00       	add	r0,r0
800057c0:	00 00       	add	r0,r0
800057c2:	07 60       	ld.uh	r0,--r3
800057c4:	00 00       	add	r0,r0
800057c6:	07 34       	ld.ub	r4,r3++

800057c8 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
800057c8:	eb cd 40 80 	pushm	r7,lr
800057cc:	1a 97       	mov	r7,sp
800057ce:	20 2d       	sub	sp,8
800057d0:	ef 4c ff f8 	st.w	r7[-8],r12
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
800057d4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800057d8:	ef 48 ff fc 	st.w	r7[-4],r8

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
800057dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800057e0:	58 08       	cp.w	r8,0
800057e2:	c4 10       	breq	80005864 <vTaskResume+0x9c>
800057e4:	4a 28       	lddpc	r8,8000586c <vTaskResume+0xa4>
800057e6:	70 08       	ld.w	r8,r8[0x0]
800057e8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800057ec:	10 39       	cp.w	r9,r8
800057ee:	c3 b0       	breq	80005864 <vTaskResume+0x9c>
		{
			taskENTER_CRITICAL();
800057f0:	f0 1f 00 20 	mcall	80005870 <vTaskResume+0xa8>
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
800057f4:	ee fc ff fc 	ld.w	r12,r7[-4]
800057f8:	f0 1f 00 1f 	mcall	80005874 <vTaskResume+0xac>
800057fc:	18 98       	mov	r8,r12
800057fe:	58 18       	cp.w	r8,1
80005800:	c3 01       	brne	80005860 <vTaskResume+0x98>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
80005802:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005806:	2f c8       	sub	r8,-4
80005808:	10 9c       	mov	r12,r8
8000580a:	f0 1f 00 1c 	mcall	80005878 <vTaskResume+0xb0>
					prvAddTaskToReadyQueue( pxTCB );
8000580e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005812:	70 b9       	ld.w	r9,r8[0x2c]
80005814:	49 a8       	lddpc	r8,8000587c <vTaskResume+0xb4>
80005816:	70 08       	ld.w	r8,r8[0x0]
80005818:	10 39       	cp.w	r9,r8
8000581a:	e0 88 00 07 	brls	80005828 <vTaskResume+0x60>
8000581e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005822:	70 b9       	ld.w	r9,r8[0x2c]
80005824:	49 68       	lddpc	r8,8000587c <vTaskResume+0xb4>
80005826:	91 09       	st.w	r8[0x0],r9
80005828:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000582c:	f0 ca ff fc 	sub	r10,r8,-4
80005830:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005834:	70 b9       	ld.w	r9,r8[0x2c]
80005836:	12 98       	mov	r8,r9
80005838:	a3 68       	lsl	r8,0x2
8000583a:	12 08       	add	r8,r9
8000583c:	a3 68       	lsl	r8,0x2
8000583e:	10 99       	mov	r9,r8
80005840:	49 08       	lddpc	r8,80005880 <vTaskResume+0xb8>
80005842:	f2 08 00 08 	add	r8,r9,r8
80005846:	14 9b       	mov	r11,r10
80005848:	10 9c       	mov	r12,r8
8000584a:	f0 1f 00 0f 	mcall	80005884 <vTaskResume+0xbc>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000584e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005852:	70 b9       	ld.w	r9,r8[0x2c]
80005854:	48 68       	lddpc	r8,8000586c <vTaskResume+0xa4>
80005856:	70 08       	ld.w	r8,r8[0x0]
80005858:	70 b8       	ld.w	r8,r8[0x2c]
8000585a:	10 39       	cp.w	r9,r8
8000585c:	c0 23       	brcs	80005860 <vTaskResume+0x98>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
8000585e:	d7 33       	scall
					}
				}
			}
			taskEXIT_CRITICAL();
80005860:	f0 1f 00 0a 	mcall	80005888 <vTaskResume+0xc0>
		}
	}
80005864:	2f ed       	sub	sp,-8
80005866:	e3 cd 80 80 	ldm	sp++,r7,pc
8000586a:	00 00       	add	r0,r0
8000586c:	00 00       	add	r0,r0
8000586e:	06 60       	and	r0,r3
80005870:	80 00       	ld.sh	r0,r0[0x0]
80005872:	49 dc       	lddpc	r12,800058e4 <vTaskStartScheduler+0x58>
80005874:	80 00       	ld.sh	r0,r0[0x0]
80005876:	57 70       	stdsp	sp[0x1dc],r0
80005878:	80 00       	ld.sh	r0,r0[0x0]
8000587a:	47 c6       	lddsp	r6,sp[0x1f0]
8000587c:	00 00       	add	r0,r0
8000587e:	07 80       	ld.ub	r0,r3[0x0]
80005880:	00 00       	add	r0,r0
80005882:	06 64       	and	r4,r3
80005884:	80 00       	ld.sh	r0,r0[0x0]
80005886:	46 b2       	lddsp	r2,sp[0x1ac]
80005888:	80 00       	ld.sh	r0,r0[0x0]
8000588a:	49 f8       	lddpc	r8,80005904 <vTaskSuspendAll+0x14>

8000588c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
8000588c:	eb cd 40 80 	pushm	r7,lr
80005890:	1a 97       	mov	r7,sp
80005892:	20 1d       	sub	sp,4
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005894:	49 1b       	lddpc	r11,800058d8 <vTaskStartScheduler+0x4c>
80005896:	30 08       	mov	r8,0
80005898:	1a d8       	st.w	--sp,r8
8000589a:	30 08       	mov	r8,0
8000589c:	1a d8       	st.w	--sp,r8
8000589e:	30 08       	mov	r8,0
800058a0:	1a d8       	st.w	--sp,r8
800058a2:	30 08       	mov	r8,0
800058a4:	30 09       	mov	r9,0
800058a6:	e0 6a 01 00 	mov	r10,256
800058aa:	48 dc       	lddpc	r12,800058dc <vTaskStartScheduler+0x50>
800058ac:	f0 1f 00 0d 	mcall	800058e0 <vTaskStartScheduler+0x54>
800058b0:	2f dd       	sub	sp,-12
800058b2:	18 98       	mov	r8,r12
800058b4:	ef 48 ff fc 	st.w	r7[-4],r8
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800058b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058bc:	58 18       	cp.w	r8,1
800058be:	c0 a1       	brne	800058d2 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800058c0:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800058c2:	48 98       	lddpc	r8,800058e4 <vTaskStartScheduler+0x58>
800058c4:	30 19       	mov	r9,1
800058c6:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800058c8:	48 88       	lddpc	r8,800058e8 <vTaskStartScheduler+0x5c>
800058ca:	30 09       	mov	r9,0
800058cc:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800058ce:	f0 1f 00 08 	mcall	800058ec <vTaskStartScheduler+0x60>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
800058d2:	2f fd       	sub	sp,-4
800058d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800058d8:	80 00       	ld.sh	r0,r0[0x0]
800058da:	53 98       	stdsp	sp[0xe4],r8
800058dc:	80 00       	ld.sh	r0,r0[0x0]
800058de:	5e c0       	retvs	r0
800058e0:	80 00       	ld.sh	r0,r0[0x0]
800058e2:	53 a0       	stdsp	sp[0xe8],r0
800058e4:	00 00       	add	r0,r0
800058e6:	07 84       	ld.ub	r4,r3[0x0]
800058e8:	00 00       	add	r0,r0
800058ea:	07 78       	ld.ub	r8,--r3
800058ec:	80 00       	ld.sh	r0,r0[0x0]
800058ee:	4b cc       	lddpc	r12,800059dc <xTaskResumeAll+0xd0>

800058f0 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
800058f0:	eb cd 40 80 	pushm	r7,lr
800058f4:	1a 97       	mov	r7,sp
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800058f6:	48 58       	lddpc	r8,80005908 <vTaskSuspendAll+0x18>
800058f8:	70 08       	ld.w	r8,r8[0x0]
800058fa:	f0 c9 ff ff 	sub	r9,r8,-1
800058fe:	48 38       	lddpc	r8,80005908 <vTaskSuspendAll+0x18>
80005900:	91 09       	st.w	r8[0x0],r9
}
80005902:	e3 cd 80 80 	ldm	sp++,r7,pc
80005906:	00 00       	add	r0,r0
80005908:	00 00       	add	r0,r0
8000590a:	07 88       	ld.ub	r8,r3[0x0]

8000590c <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000590c:	eb cd 40 c0 	pushm	r6-r7,lr
80005910:	1a 97       	mov	r7,sp
80005912:	20 2d       	sub	sp,8
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
80005914:	30 08       	mov	r8,0
80005916:	ef 48 ff f8 	st.w	r7[-8],r8
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
8000591a:	f0 1f 00 3a 	mcall	80005a00 <xTaskResumeAll+0xf4>
	{
		--uxSchedulerSuspended;
8000591e:	4b a8       	lddpc	r8,80005a04 <xTaskResumeAll+0xf8>
80005920:	70 08       	ld.w	r8,r8[0x0]
80005922:	f0 c9 00 01 	sub	r9,r8,1
80005926:	4b 88       	lddpc	r8,80005a04 <xTaskResumeAll+0xf8>
80005928:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000592a:	4b 78       	lddpc	r8,80005a04 <xTaskResumeAll+0xf8>
8000592c:	70 08       	ld.w	r8,r8[0x0]
8000592e:	58 08       	cp.w	r8,0
80005930:	c5 f1       	brne	800059ee <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005932:	4b 68       	lddpc	r8,80005a08 <xTaskResumeAll+0xfc>
80005934:	70 08       	ld.w	r8,r8[0x0]
80005936:	58 08       	cp.w	r8,0
80005938:	c5 b0       	breq	800059ee <xTaskResumeAll+0xe2>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
8000593a:	30 08       	mov	r8,0
8000593c:	ef 48 ff fc 	st.w	r7[-4],r8

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005940:	c3 08       	rjmp	800059a0 <xTaskResumeAll+0x94>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005942:	4b 38       	lddpc	r8,80005a0c <xTaskResumeAll+0x100>
80005944:	70 38       	ld.w	r8,r8[0xc]
80005946:	70 38       	ld.w	r8,r8[0xc]
80005948:	10 96       	mov	r6,r8
					vListRemove( &( pxTCB->xEventListItem ) );
8000594a:	ec c8 ff e8 	sub	r8,r6,-24
8000594e:	10 9c       	mov	r12,r8
80005950:	f0 1f 00 30 	mcall	80005a10 <xTaskResumeAll+0x104>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005954:	ec c8 ff fc 	sub	r8,r6,-4
80005958:	10 9c       	mov	r12,r8
8000595a:	f0 1f 00 2e 	mcall	80005a10 <xTaskResumeAll+0x104>
					prvAddTaskToReadyQueue( pxTCB );
8000595e:	6c b9       	ld.w	r9,r6[0x2c]
80005960:	4a d8       	lddpc	r8,80005a14 <xTaskResumeAll+0x108>
80005962:	70 08       	ld.w	r8,r8[0x0]
80005964:	10 39       	cp.w	r9,r8
80005966:	e0 88 00 05 	brls	80005970 <xTaskResumeAll+0x64>
8000596a:	6c b9       	ld.w	r9,r6[0x2c]
8000596c:	4a a8       	lddpc	r8,80005a14 <xTaskResumeAll+0x108>
8000596e:	91 09       	st.w	r8[0x0],r9
80005970:	ec ca ff fc 	sub	r10,r6,-4
80005974:	6c b9       	ld.w	r9,r6[0x2c]
80005976:	12 98       	mov	r8,r9
80005978:	a3 68       	lsl	r8,0x2
8000597a:	12 08       	add	r8,r9
8000597c:	a3 68       	lsl	r8,0x2
8000597e:	10 99       	mov	r9,r8
80005980:	4a 68       	lddpc	r8,80005a18 <xTaskResumeAll+0x10c>
80005982:	f2 08 00 08 	add	r8,r9,r8
80005986:	14 9b       	mov	r11,r10
80005988:	10 9c       	mov	r12,r8
8000598a:	f0 1f 00 25 	mcall	80005a1c <xTaskResumeAll+0x110>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000598e:	6c b9       	ld.w	r9,r6[0x2c]
80005990:	4a 48       	lddpc	r8,80005a20 <xTaskResumeAll+0x114>
80005992:	70 08       	ld.w	r8,r8[0x0]
80005994:	70 b8       	ld.w	r8,r8[0x2c]
80005996:	10 39       	cp.w	r9,r8
80005998:	c0 43       	brcs	800059a0 <xTaskResumeAll+0x94>
					{
						xYieldRequired = pdTRUE;
8000599a:	30 18       	mov	r8,1
8000599c:	ef 48 ff fc 	st.w	r7[-4],r8
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800059a0:	49 b8       	lddpc	r8,80005a0c <xTaskResumeAll+0x100>
800059a2:	70 08       	ld.w	r8,r8[0x0]
800059a4:	58 08       	cp.w	r8,0
800059a6:	cc e1       	brne	80005942 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800059a8:	49 f8       	lddpc	r8,80005a24 <xTaskResumeAll+0x118>
800059aa:	70 08       	ld.w	r8,r8[0x0]
800059ac:	58 08       	cp.w	r8,0
800059ae:	c1 10       	breq	800059d0 <xTaskResumeAll+0xc4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800059b0:	c0 98       	rjmp	800059c2 <xTaskResumeAll+0xb6>
					{
						vTaskIncrementTick();
800059b2:	f0 1f 00 1e 	mcall	80005a28 <xTaskResumeAll+0x11c>
						--uxMissedTicks;
800059b6:	49 c8       	lddpc	r8,80005a24 <xTaskResumeAll+0x118>
800059b8:	70 08       	ld.w	r8,r8[0x0]
800059ba:	f0 c9 00 01 	sub	r9,r8,1
800059be:	49 a8       	lddpc	r8,80005a24 <xTaskResumeAll+0x118>
800059c0:	91 09       	st.w	r8[0x0],r9
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800059c2:	49 98       	lddpc	r8,80005a24 <xTaskResumeAll+0x118>
800059c4:	70 08       	ld.w	r8,r8[0x0]
800059c6:	58 08       	cp.w	r8,0
800059c8:	cf 51       	brne	800059b2 <xTaskResumeAll+0xa6>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
800059ca:	30 18       	mov	r8,1
800059cc:	ef 48 ff fc 	st.w	r7[-4],r8
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800059d0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059d4:	58 18       	cp.w	r8,1
800059d6:	c0 50       	breq	800059e0 <xTaskResumeAll+0xd4>
800059d8:	49 58       	lddpc	r8,80005a2c <xTaskResumeAll+0x120>
800059da:	70 08       	ld.w	r8,r8[0x0]
800059dc:	58 18       	cp.w	r8,1
800059de:	c0 81       	brne	800059ee <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
800059e0:	30 18       	mov	r8,1
800059e2:	ef 48 ff f8 	st.w	r7[-8],r8
					xMissedYield = pdFALSE;
800059e6:	49 28       	lddpc	r8,80005a2c <xTaskResumeAll+0x120>
800059e8:	30 09       	mov	r9,0
800059ea:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800059ec:	d7 33       	scall
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800059ee:	f0 1f 00 11 	mcall	80005a30 <xTaskResumeAll+0x124>

	return xAlreadyYielded;
800059f2:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800059f6:	10 9c       	mov	r12,r8
800059f8:	2f ed       	sub	sp,-8
800059fa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059fe:	00 00       	add	r0,r0
80005a00:	80 00       	ld.sh	r0,r0[0x0]
80005a02:	49 dc       	lddpc	r12,80005a74 <vTaskIncrementTick+0x10>
80005a04:	00 00       	add	r0,r0
80005a06:	07 88       	ld.ub	r8,r3[0x0]
80005a08:	00 00       	add	r0,r0
80005a0a:	07 74       	ld.ub	r4,--r3
80005a0c:	00 00       	add	r0,r0
80005a0e:	07 34       	ld.ub	r4,r3++
80005a10:	80 00       	ld.sh	r0,r0[0x0]
80005a12:	47 c6       	lddsp	r6,sp[0x1f0]
80005a14:	00 00       	add	r0,r0
80005a16:	07 80       	ld.ub	r0,r3[0x0]
80005a18:	00 00       	add	r0,r0
80005a1a:	06 64       	and	r4,r3
80005a1c:	80 00       	ld.sh	r0,r0[0x0]
80005a1e:	46 b2       	lddsp	r2,sp[0x1ac]
80005a20:	00 00       	add	r0,r0
80005a22:	06 60       	and	r0,r3
80005a24:	00 00       	add	r0,r0
80005a26:	07 8c       	ld.ub	r12,r3[0x0]
80005a28:	80 00       	ld.sh	r0,r0[0x0]
80005a2a:	5a 64       	cp.w	r4,-26
80005a2c:	00 00       	add	r0,r0
80005a2e:	07 90       	ld.ub	r0,r3[0x1]
80005a30:	80 00       	ld.sh	r0,r0[0x0]
80005a32:	49 f8       	lddpc	r8,80005aac <vTaskIncrementTick+0x48>

80005a34 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005a34:	eb cd 40 80 	pushm	r7,lr
80005a38:	1a 97       	mov	r7,sp
80005a3a:	20 1d       	sub	sp,4
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005a3c:	f0 1f 00 07 	mcall	80005a58 <xTaskGetTickCount+0x24>
	{
		xTicks = xTickCount;
80005a40:	48 78       	lddpc	r8,80005a5c <xTaskGetTickCount+0x28>
80005a42:	70 08       	ld.w	r8,r8[0x0]
80005a44:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	taskEXIT_CRITICAL();
80005a48:	f0 1f 00 06 	mcall	80005a60 <xTaskGetTickCount+0x2c>

	return xTicks;
80005a4c:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005a50:	10 9c       	mov	r12,r8
80005a52:	2f fd       	sub	sp,-4
80005a54:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a58:	80 00       	ld.sh	r0,r0[0x0]
80005a5a:	49 dc       	lddpc	r12,80005acc <vTaskIncrementTick+0x68>
80005a5c:	00 00       	add	r0,r0
80005a5e:	07 78       	ld.ub	r8,--r3
80005a60:	80 00       	ld.sh	r0,r0[0x0]
80005a62:	49 f8       	lddpc	r8,80005adc <vTaskIncrementTick+0x78>

80005a64 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005a64:	eb cd 40 80 	pushm	r7,lr
80005a68:	1a 97       	mov	r7,sp
80005a6a:	20 3d       	sub	sp,12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005a6c:	4c b8       	lddpc	r8,80005b98 <vTaskIncrementTick+0x134>
80005a6e:	70 08       	ld.w	r8,r8[0x0]
80005a70:	58 08       	cp.w	r8,0
80005a72:	e0 81 00 89 	brne	80005b84 <vTaskIncrementTick+0x120>
	{
		++xTickCount;
80005a76:	4c a8       	lddpc	r8,80005b9c <vTaskIncrementTick+0x138>
80005a78:	70 08       	ld.w	r8,r8[0x0]
80005a7a:	f0 c9 ff ff 	sub	r9,r8,-1
80005a7e:	4c 88       	lddpc	r8,80005b9c <vTaskIncrementTick+0x138>
80005a80:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005a82:	4c 78       	lddpc	r8,80005b9c <vTaskIncrementTick+0x138>
80005a84:	70 08       	ld.w	r8,r8[0x0]
80005a86:	58 08       	cp.w	r8,0
80005a88:	c2 71       	brne	80005ad6 <vTaskIncrementTick+0x72>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005a8a:	4c 68       	lddpc	r8,80005ba0 <vTaskIncrementTick+0x13c>
80005a8c:	70 08       	ld.w	r8,r8[0x0]
80005a8e:	ef 48 ff f8 	st.w	r7[-8],r8
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005a92:	4c 58       	lddpc	r8,80005ba4 <vTaskIncrementTick+0x140>
80005a94:	70 09       	ld.w	r9,r8[0x0]
80005a96:	4c 38       	lddpc	r8,80005ba0 <vTaskIncrementTick+0x13c>
80005a98:	91 09       	st.w	r8[0x0],r9
			pxOverflowDelayedTaskList = pxTemp;
80005a9a:	4c 38       	lddpc	r8,80005ba4 <vTaskIncrementTick+0x140>
80005a9c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005aa0:	91 09       	st.w	r8[0x0],r9
			xNumOfOverflows++;
80005aa2:	4c 28       	lddpc	r8,80005ba8 <vTaskIncrementTick+0x144>
80005aa4:	70 08       	ld.w	r8,r8[0x0]
80005aa6:	f0 c9 ff ff 	sub	r9,r8,-1
80005aaa:	4c 08       	lddpc	r8,80005ba8 <vTaskIncrementTick+0x144>
80005aac:	91 09       	st.w	r8[0x0],r9

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005aae:	4b d8       	lddpc	r8,80005ba0 <vTaskIncrementTick+0x13c>
80005ab0:	70 08       	ld.w	r8,r8[0x0]
80005ab2:	70 08       	ld.w	r8,r8[0x0]
80005ab4:	58 08       	cp.w	r8,0
80005ab6:	c0 51       	brne	80005ac0 <vTaskIncrementTick+0x5c>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005ab8:	4b d8       	lddpc	r8,80005bac <vTaskIncrementTick+0x148>
80005aba:	3f f9       	mov	r9,-1
80005abc:	91 09       	st.w	r8[0x0],r9
80005abe:	c0 c8       	rjmp	80005ad6 <vTaskIncrementTick+0x72>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005ac0:	4b 88       	lddpc	r8,80005ba0 <vTaskIncrementTick+0x13c>
80005ac2:	70 08       	ld.w	r8,r8[0x0]
80005ac4:	70 38       	ld.w	r8,r8[0xc]
80005ac6:	70 38       	ld.w	r8,r8[0xc]
80005ac8:	ef 48 ff f4 	st.w	r7[-12],r8
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005acc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005ad0:	70 19       	ld.w	r9,r8[0x4]
80005ad2:	4b 78       	lddpc	r8,80005bac <vTaskIncrementTick+0x148>
80005ad4:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005ad6:	4b 28       	lddpc	r8,80005b9c <vTaskIncrementTick+0x138>
80005ad8:	70 09       	ld.w	r9,r8[0x0]
80005ada:	4b 58       	lddpc	r8,80005bac <vTaskIncrementTick+0x148>
80005adc:	70 08       	ld.w	r8,r8[0x0]
80005ade:	10 39       	cp.w	r9,r8
80005ae0:	c5 83       	brcs	80005b90 <vTaskIncrementTick+0x12c>
80005ae2:	4b 08       	lddpc	r8,80005ba0 <vTaskIncrementTick+0x13c>
80005ae4:	70 08       	ld.w	r8,r8[0x0]
80005ae6:	70 08       	ld.w	r8,r8[0x0]
80005ae8:	58 08       	cp.w	r8,0
80005aea:	c0 51       	brne	80005af4 <vTaskIncrementTick+0x90>
80005aec:	4b 08       	lddpc	r8,80005bac <vTaskIncrementTick+0x148>
80005aee:	3f f9       	mov	r9,-1
80005af0:	91 09       	st.w	r8[0x0],r9
80005af2:	c4 f8       	rjmp	80005b90 <vTaskIncrementTick+0x12c>
80005af4:	4a b8       	lddpc	r8,80005ba0 <vTaskIncrementTick+0x13c>
80005af6:	70 08       	ld.w	r8,r8[0x0]
80005af8:	70 38       	ld.w	r8,r8[0xc]
80005afa:	70 38       	ld.w	r8,r8[0xc]
80005afc:	ef 48 ff f4 	st.w	r7[-12],r8
80005b00:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005b04:	70 18       	ld.w	r8,r8[0x4]
80005b06:	ef 48 ff fc 	st.w	r7[-4],r8
80005b0a:	4a 58       	lddpc	r8,80005b9c <vTaskIncrementTick+0x138>
80005b0c:	70 09       	ld.w	r9,r8[0x0]
80005b0e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b12:	10 39       	cp.w	r9,r8
80005b14:	c0 62       	brcc	80005b20 <vTaskIncrementTick+0xbc>
80005b16:	4a 68       	lddpc	r8,80005bac <vTaskIncrementTick+0x148>
80005b18:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005b1c:	91 09       	st.w	r8[0x0],r9
80005b1e:	c3 98       	rjmp	80005b90 <vTaskIncrementTick+0x12c>
80005b20:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005b24:	2f c8       	sub	r8,-4
80005b26:	10 9c       	mov	r12,r8
80005b28:	f0 1f 00 22 	mcall	80005bb0 <vTaskIncrementTick+0x14c>
80005b2c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005b30:	70 a8       	ld.w	r8,r8[0x28]
80005b32:	58 08       	cp.w	r8,0
80005b34:	c0 70       	breq	80005b42 <vTaskIncrementTick+0xde>
80005b36:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005b3a:	2e 88       	sub	r8,-24
80005b3c:	10 9c       	mov	r12,r8
80005b3e:	f0 1f 00 1d 	mcall	80005bb0 <vTaskIncrementTick+0x14c>
80005b42:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005b46:	70 b9       	ld.w	r9,r8[0x2c]
80005b48:	49 b8       	lddpc	r8,80005bb4 <vTaskIncrementTick+0x150>
80005b4a:	70 08       	ld.w	r8,r8[0x0]
80005b4c:	10 39       	cp.w	r9,r8
80005b4e:	e0 88 00 07 	brls	80005b5c <vTaskIncrementTick+0xf8>
80005b52:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005b56:	70 b9       	ld.w	r9,r8[0x2c]
80005b58:	49 78       	lddpc	r8,80005bb4 <vTaskIncrementTick+0x150>
80005b5a:	91 09       	st.w	r8[0x0],r9
80005b5c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005b60:	f0 ca ff fc 	sub	r10,r8,-4
80005b64:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005b68:	70 b9       	ld.w	r9,r8[0x2c]
80005b6a:	12 98       	mov	r8,r9
80005b6c:	a3 68       	lsl	r8,0x2
80005b6e:	12 08       	add	r8,r9
80005b70:	a3 68       	lsl	r8,0x2
80005b72:	10 99       	mov	r9,r8
80005b74:	49 18       	lddpc	r8,80005bb8 <vTaskIncrementTick+0x154>
80005b76:	f2 08 00 08 	add	r8,r9,r8
80005b7a:	14 9b       	mov	r11,r10
80005b7c:	10 9c       	mov	r12,r8
80005b7e:	f0 1f 00 10 	mcall	80005bbc <vTaskIncrementTick+0x158>
80005b82:	cb 0b       	rjmp	80005ae2 <vTaskIncrementTick+0x7e>
	}
	else
	{
		++uxMissedTicks;
80005b84:	48 f8       	lddpc	r8,80005bc0 <vTaskIncrementTick+0x15c>
80005b86:	70 08       	ld.w	r8,r8[0x0]
80005b88:	f0 c9 ff ff 	sub	r9,r8,-1
80005b8c:	48 d8       	lddpc	r8,80005bc0 <vTaskIncrementTick+0x15c>
80005b8e:	91 09       	st.w	r8[0x0],r9
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
80005b90:	2f dd       	sub	sp,-12
80005b92:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b96:	00 00       	add	r0,r0
80005b98:	00 00       	add	r0,r0
80005b9a:	07 88       	ld.ub	r8,r3[0x0]
80005b9c:	00 00       	add	r0,r0
80005b9e:	07 78       	ld.ub	r8,--r3
80005ba0:	00 00       	add	r0,r0
80005ba2:	07 2c       	ld.uh	r12,r3++
80005ba4:	00 00       	add	r0,r0
80005ba6:	07 30       	ld.ub	r0,r3++
80005ba8:	00 00       	add	r0,r0
80005baa:	07 94       	ld.ub	r4,r3[0x1]
80005bac:	00 00       	add	r0,r0
80005bae:	00 24       	rsub	r4,r0
80005bb0:	80 00       	ld.sh	r0,r0[0x0]
80005bb2:	47 c6       	lddsp	r6,sp[0x1f0]
80005bb4:	00 00       	add	r0,r0
80005bb6:	07 80       	ld.ub	r0,r3[0x0]
80005bb8:	00 00       	add	r0,r0
80005bba:	06 64       	and	r4,r3
80005bbc:	80 00       	ld.sh	r0,r0[0x0]
80005bbe:	46 b2       	lddsp	r2,sp[0x1ac]
80005bc0:	00 00       	add	r0,r0
80005bc2:	07 8c       	ld.ub	r12,r3[0x0]

80005bc4 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
80005bc4:	eb cd 40 80 	pushm	r7,lr
80005bc8:	1a 97       	mov	r7,sp
80005bca:	20 1d       	sub	sp,4
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005bcc:	4a 58       	lddpc	r8,80005c60 <vTaskSwitchContext+0x9c>
80005bce:	70 08       	ld.w	r8,r8[0x0]
80005bd0:	58 08       	cp.w	r8,0
80005bd2:	c0 c0       	breq	80005bea <vTaskSwitchContext+0x26>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005bd4:	4a 48       	lddpc	r8,80005c64 <vTaskSwitchContext+0xa0>
80005bd6:	30 19       	mov	r9,1
80005bd8:	91 09       	st.w	r8[0x0],r9
80005bda:	c3 f8       	rjmp	80005c58 <vTaskSwitchContext+0x94>

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005bdc:	4a 38       	lddpc	r8,80005c68 <vTaskSwitchContext+0xa4>
80005bde:	70 08       	ld.w	r8,r8[0x0]
80005be0:	f0 c9 00 01 	sub	r9,r8,1
80005be4:	4a 18       	lddpc	r8,80005c68 <vTaskSwitchContext+0xa4>
80005be6:	91 09       	st.w	r8[0x0],r9
80005be8:	c0 28       	rjmp	80005bec <vTaskSwitchContext+0x28>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005bea:	d7 03       	nop
80005bec:	49 f8       	lddpc	r8,80005c68 <vTaskSwitchContext+0xa4>
80005bee:	70 09       	ld.w	r9,r8[0x0]
80005bf0:	12 98       	mov	r8,r9
80005bf2:	a3 68       	lsl	r8,0x2
80005bf4:	12 08       	add	r8,r9
80005bf6:	a3 68       	lsl	r8,0x2
80005bf8:	10 99       	mov	r9,r8
80005bfa:	49 d8       	lddpc	r8,80005c6c <vTaskSwitchContext+0xa8>
80005bfc:	f2 08 00 08 	add	r8,r9,r8
80005c00:	70 08       	ld.w	r8,r8[0x0]
80005c02:	58 08       	cp.w	r8,0
80005c04:	ce c0       	breq	80005bdc <vTaskSwitchContext+0x18>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005c06:	49 98       	lddpc	r8,80005c68 <vTaskSwitchContext+0xa4>
80005c08:	70 09       	ld.w	r9,r8[0x0]
80005c0a:	12 98       	mov	r8,r9
80005c0c:	a3 68       	lsl	r8,0x2
80005c0e:	12 08       	add	r8,r9
80005c10:	a3 68       	lsl	r8,0x2
80005c12:	10 99       	mov	r9,r8
80005c14:	49 68       	lddpc	r8,80005c6c <vTaskSwitchContext+0xa8>
80005c16:	f2 08 00 08 	add	r8,r9,r8
80005c1a:	ef 48 ff fc 	st.w	r7[-4],r8
80005c1e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c22:	70 18       	ld.w	r8,r8[0x4]
80005c24:	70 19       	ld.w	r9,r8[0x4]
80005c26:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c2a:	91 19       	st.w	r8[0x4],r9
80005c2c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c30:	70 19       	ld.w	r9,r8[0x4]
80005c32:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c36:	2f 88       	sub	r8,-8
80005c38:	10 39       	cp.w	r9,r8
80005c3a:	c0 81       	brne	80005c4a <vTaskSwitchContext+0x86>
80005c3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c40:	70 18       	ld.w	r8,r8[0x4]
80005c42:	70 19       	ld.w	r9,r8[0x4]
80005c44:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c48:	91 19       	st.w	r8[0x4],r9
80005c4a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c4e:	70 18       	ld.w	r8,r8[0x4]
80005c50:	70 38       	ld.w	r8,r8[0xc]
80005c52:	10 99       	mov	r9,r8
80005c54:	48 78       	lddpc	r8,80005c70 <vTaskSwitchContext+0xac>
80005c56:	91 09       	st.w	r8[0x0],r9

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
80005c58:	2f fd       	sub	sp,-4
80005c5a:	e3 cd 80 80 	ldm	sp++,r7,pc
80005c5e:	00 00       	add	r0,r0
80005c60:	00 00       	add	r0,r0
80005c62:	07 88       	ld.ub	r8,r3[0x0]
80005c64:	00 00       	add	r0,r0
80005c66:	07 90       	ld.ub	r0,r3[0x1]
80005c68:	00 00       	add	r0,r0
80005c6a:	07 80       	ld.ub	r0,r3[0x0]
80005c6c:	00 00       	add	r0,r0
80005c6e:	06 64       	and	r4,r3
80005c70:	00 00       	add	r0,r0
80005c72:	06 60       	and	r0,r3

80005c74 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005c74:	eb cd 40 80 	pushm	r7,lr
80005c78:	1a 97       	mov	r7,sp
80005c7a:	20 3d       	sub	sp,12
80005c7c:	ef 4c ff f8 	st.w	r7[-8],r12
80005c80:	ef 4b ff f4 	st.w	r7[-12],r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005c84:	49 58       	lddpc	r8,80005cd8 <vTaskPlaceOnEventList+0x64>
80005c86:	70 08       	ld.w	r8,r8[0x0]
80005c88:	2e 88       	sub	r8,-24
80005c8a:	10 9b       	mov	r11,r8
80005c8c:	ee fc ff f8 	ld.w	r12,r7[-8]
80005c90:	f0 1f 00 13 	mcall	80005cdc <vTaskPlaceOnEventList+0x68>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005c94:	49 18       	lddpc	r8,80005cd8 <vTaskPlaceOnEventList+0x64>
80005c96:	70 08       	ld.w	r8,r8[0x0]
80005c98:	2f c8       	sub	r8,-4
80005c9a:	10 9c       	mov	r12,r8
80005c9c:	f0 1f 00 11 	mcall	80005ce0 <vTaskPlaceOnEventList+0x6c>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005ca0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005ca4:	5b f8       	cp.w	r8,-1
80005ca6:	c0 91       	brne	80005cb8 <vTaskPlaceOnEventList+0x44>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005ca8:	48 c8       	lddpc	r8,80005cd8 <vTaskPlaceOnEventList+0x64>
80005caa:	70 08       	ld.w	r8,r8[0x0]
80005cac:	2f c8       	sub	r8,-4
80005cae:	10 9b       	mov	r11,r8
80005cb0:	48 dc       	lddpc	r12,80005ce4 <vTaskPlaceOnEventList+0x70>
80005cb2:	f0 1f 00 0e 	mcall	80005ce8 <vTaskPlaceOnEventList+0x74>
80005cb6:	c0 d8       	rjmp	80005cd0 <vTaskPlaceOnEventList+0x5c>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005cb8:	48 d8       	lddpc	r8,80005cec <vTaskPlaceOnEventList+0x78>
80005cba:	70 09       	ld.w	r9,r8[0x0]
80005cbc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005cc0:	f2 08 00 08 	add	r8,r9,r8
80005cc4:	ef 48 ff fc 	st.w	r7[-4],r8
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005cc8:	ee fc ff fc 	ld.w	r12,r7[-4]
80005ccc:	f0 1f 00 09 	mcall	80005cf0 <vTaskPlaceOnEventList+0x7c>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
80005cd0:	2f dd       	sub	sp,-12
80005cd2:	e3 cd 80 80 	ldm	sp++,r7,pc
80005cd6:	00 00       	add	r0,r0
80005cd8:	00 00       	add	r0,r0
80005cda:	06 60       	and	r0,r3
80005cdc:	80 00       	ld.sh	r0,r0[0x0]
80005cde:	47 24       	lddsp	r4,sp[0x1c8]
80005ce0:	80 00       	ld.sh	r0,r0[0x0]
80005ce2:	47 c6       	lddsp	r6,sp[0x1f0]
80005ce4:	00 00       	add	r0,r0
80005ce6:	07 60       	ld.uh	r0,--r3
80005ce8:	80 00       	ld.sh	r0,r0[0x0]
80005cea:	46 b2       	lddsp	r2,sp[0x1ac]
80005cec:	00 00       	add	r0,r0
80005cee:	07 78       	ld.ub	r8,--r3
80005cf0:	80 00       	ld.sh	r0,r0[0x0]
80005cf2:	60 b4       	ld.w	r4,r0[0x2c]

80005cf4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005cf4:	eb cd 40 80 	pushm	r7,lr
80005cf8:	1a 97       	mov	r7,sp
80005cfa:	20 3d       	sub	sp,12
80005cfc:	ef 4c ff f4 	st.w	r7[-12],r12
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005d00:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005d04:	70 38       	ld.w	r8,r8[0xc]
80005d06:	70 38       	ld.w	r8,r8[0xc]
80005d08:	ef 48 ff f8 	st.w	r7[-8],r8
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005d0c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d10:	2e 88       	sub	r8,-24
80005d12:	10 9c       	mov	r12,r8
80005d14:	f0 1f 00 25 	mcall	80005da8 <xTaskRemoveFromEventList+0xb4>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005d18:	4a 58       	lddpc	r8,80005dac <xTaskRemoveFromEventList+0xb8>
80005d1a:	70 08       	ld.w	r8,r8[0x0]
80005d1c:	58 08       	cp.w	r8,0
80005d1e:	c2 81       	brne	80005d6e <xTaskRemoveFromEventList+0x7a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005d20:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d24:	2f c8       	sub	r8,-4
80005d26:	10 9c       	mov	r12,r8
80005d28:	f0 1f 00 20 	mcall	80005da8 <xTaskRemoveFromEventList+0xb4>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005d2c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d30:	70 b9       	ld.w	r9,r8[0x2c]
80005d32:	4a 08       	lddpc	r8,80005db0 <xTaskRemoveFromEventList+0xbc>
80005d34:	70 08       	ld.w	r8,r8[0x0]
80005d36:	10 39       	cp.w	r9,r8
80005d38:	e0 88 00 07 	brls	80005d46 <xTaskRemoveFromEventList+0x52>
80005d3c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d40:	70 b9       	ld.w	r9,r8[0x2c]
80005d42:	49 c8       	lddpc	r8,80005db0 <xTaskRemoveFromEventList+0xbc>
80005d44:	91 09       	st.w	r8[0x0],r9
80005d46:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d4a:	f0 ca ff fc 	sub	r10,r8,-4
80005d4e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d52:	70 b9       	ld.w	r9,r8[0x2c]
80005d54:	12 98       	mov	r8,r9
80005d56:	a3 68       	lsl	r8,0x2
80005d58:	12 08       	add	r8,r9
80005d5a:	a3 68       	lsl	r8,0x2
80005d5c:	10 99       	mov	r9,r8
80005d5e:	49 68       	lddpc	r8,80005db4 <xTaskRemoveFromEventList+0xc0>
80005d60:	f2 08 00 08 	add	r8,r9,r8
80005d64:	14 9b       	mov	r11,r10
80005d66:	10 9c       	mov	r12,r8
80005d68:	f0 1f 00 14 	mcall	80005db8 <xTaskRemoveFromEventList+0xc4>
80005d6c:	c0 88       	rjmp	80005d7c <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005d6e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d72:	2e 88       	sub	r8,-24
80005d74:	10 9b       	mov	r11,r8
80005d76:	49 2c       	lddpc	r12,80005dbc <xTaskRemoveFromEventList+0xc8>
80005d78:	f0 1f 00 10 	mcall	80005db8 <xTaskRemoveFromEventList+0xc4>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005d7c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d80:	70 b9       	ld.w	r9,r8[0x2c]
80005d82:	49 08       	lddpc	r8,80005dc0 <xTaskRemoveFromEventList+0xcc>
80005d84:	70 08       	ld.w	r8,r8[0x0]
80005d86:	70 b8       	ld.w	r8,r8[0x2c]
80005d88:	10 39       	cp.w	r9,r8
80005d8a:	c0 53       	brcs	80005d94 <xTaskRemoveFromEventList+0xa0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
80005d8c:	30 18       	mov	r8,1
80005d8e:	ef 48 ff fc 	st.w	r7[-4],r8
80005d92:	c0 48       	rjmp	80005d9a <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		xReturn = pdFALSE;
80005d94:	30 08       	mov	r8,0
80005d96:	ef 48 ff fc 	st.w	r7[-4],r8
	}

	return xReturn;
80005d9a:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005d9e:	10 9c       	mov	r12,r8
80005da0:	2f dd       	sub	sp,-12
80005da2:	e3 cd 80 80 	ldm	sp++,r7,pc
80005da6:	00 00       	add	r0,r0
80005da8:	80 00       	ld.sh	r0,r0[0x0]
80005daa:	47 c6       	lddsp	r6,sp[0x1f0]
80005dac:	00 00       	add	r0,r0
80005dae:	07 88       	ld.ub	r8,r3[0x0]
80005db0:	00 00       	add	r0,r0
80005db2:	07 80       	ld.ub	r0,r3[0x0]
80005db4:	00 00       	add	r0,r0
80005db6:	06 64       	and	r4,r3
80005db8:	80 00       	ld.sh	r0,r0[0x0]
80005dba:	46 b2       	lddsp	r2,sp[0x1ac]
80005dbc:	00 00       	add	r0,r0
80005dbe:	07 34       	ld.ub	r4,r3++
80005dc0:	00 00       	add	r0,r0
80005dc2:	06 60       	and	r0,r3

80005dc4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
80005dc4:	eb cd 40 80 	pushm	r7,lr
80005dc8:	1a 97       	mov	r7,sp
80005dca:	20 1d       	sub	sp,4
80005dcc:	ef 4c ff fc 	st.w	r7[-4],r12
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80005dd0:	48 78       	lddpc	r8,80005dec <vTaskSetTimeOutState+0x28>
80005dd2:	70 09       	ld.w	r9,r8[0x0]
80005dd4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005dd8:	91 09       	st.w	r8[0x0],r9
	pxTimeOut->xTimeOnEntering = xTickCount;
80005dda:	48 68       	lddpc	r8,80005df0 <vTaskSetTimeOutState+0x2c>
80005ddc:	70 09       	ld.w	r9,r8[0x0]
80005dde:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005de2:	91 19       	st.w	r8[0x4],r9
}
80005de4:	2f fd       	sub	sp,-4
80005de6:	e3 cd 80 80 	ldm	sp++,r7,pc
80005dea:	00 00       	add	r0,r0
80005dec:	00 00       	add	r0,r0
80005dee:	07 94       	ld.ub	r4,r3[0x1]
80005df0:	00 00       	add	r0,r0
80005df2:	07 78       	ld.ub	r8,--r3

80005df4 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005df4:	eb cd 40 80 	pushm	r7,lr
80005df8:	1a 97       	mov	r7,sp
80005dfa:	20 3d       	sub	sp,12
80005dfc:	ef 4c ff f8 	st.w	r7[-8],r12
80005e00:	ef 4b ff f4 	st.w	r7[-12],r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005e04:	f0 1f 00 25 	mcall	80005e98 <xTaskCheckForTimeOut+0xa4>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005e08:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005e0c:	70 08       	ld.w	r8,r8[0x0]
80005e0e:	5b f8       	cp.w	r8,-1
80005e10:	c0 51       	brne	80005e1a <xTaskCheckForTimeOut+0x26>
			{
				xReturn = pdFALSE;
80005e12:	30 08       	mov	r8,0
80005e14:	ef 48 ff fc 	st.w	r7[-4],r8
80005e18:	c3 88       	rjmp	80005e88 <xTaskCheckForTimeOut+0x94>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80005e1a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e1e:	70 09       	ld.w	r9,r8[0x0]
80005e20:	49 f8       	lddpc	r8,80005e9c <xTaskCheckForTimeOut+0xa8>
80005e22:	70 08       	ld.w	r8,r8[0x0]
80005e24:	10 39       	cp.w	r9,r8
80005e26:	c0 d0       	breq	80005e40 <xTaskCheckForTimeOut+0x4c>
80005e28:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e2c:	70 19       	ld.w	r9,r8[0x4]
80005e2e:	49 d8       	lddpc	r8,80005ea0 <xTaskCheckForTimeOut+0xac>
80005e30:	70 08       	ld.w	r8,r8[0x0]
80005e32:	10 39       	cp.w	r9,r8
80005e34:	e0 8b 00 06 	brhi	80005e40 <xTaskCheckForTimeOut+0x4c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
80005e38:	30 18       	mov	r8,1
80005e3a:	ef 48 ff fc 	st.w	r7[-4],r8
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80005e3e:	c2 58       	rjmp	80005e88 <xTaskCheckForTimeOut+0x94>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005e40:	49 88       	lddpc	r8,80005ea0 <xTaskCheckForTimeOut+0xac>
80005e42:	70 09       	ld.w	r9,r8[0x0]
80005e44:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e48:	70 18       	ld.w	r8,r8[0x4]
80005e4a:	10 19       	sub	r9,r8
80005e4c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005e50:	70 08       	ld.w	r8,r8[0x0]
80005e52:	10 39       	cp.w	r9,r8
80005e54:	c1 72       	brcc	80005e82 <xTaskCheckForTimeOut+0x8e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005e56:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005e5a:	70 09       	ld.w	r9,r8[0x0]
80005e5c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e60:	70 1a       	ld.w	r10,r8[0x4]
80005e62:	49 08       	lddpc	r8,80005ea0 <xTaskCheckForTimeOut+0xac>
80005e64:	70 08       	ld.w	r8,r8[0x0]
80005e66:	f4 08 01 08 	sub	r8,r10,r8
80005e6a:	10 09       	add	r9,r8
80005e6c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005e70:	91 09       	st.w	r8[0x0],r9
			vTaskSetTimeOutState( pxTimeOut );
80005e72:	ee fc ff f8 	ld.w	r12,r7[-8]
80005e76:	f0 1f 00 0c 	mcall	80005ea4 <xTaskCheckForTimeOut+0xb0>
			xReturn = pdFALSE;
80005e7a:	30 08       	mov	r8,0
80005e7c:	ef 48 ff fc 	st.w	r7[-4],r8
80005e80:	c0 48       	rjmp	80005e88 <xTaskCheckForTimeOut+0x94>
		}
		else
		{
			xReturn = pdTRUE;
80005e82:	30 18       	mov	r8,1
80005e84:	ef 48 ff fc 	st.w	r7[-4],r8
		}
	}
	taskEXIT_CRITICAL();
80005e88:	f0 1f 00 08 	mcall	80005ea8 <xTaskCheckForTimeOut+0xb4>

	return xReturn;
80005e8c:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005e90:	10 9c       	mov	r12,r8
80005e92:	2f dd       	sub	sp,-12
80005e94:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e98:	80 00       	ld.sh	r0,r0[0x0]
80005e9a:	49 dc       	lddpc	r12,80005f0c <prvInitialiseTCBVariables+0x20>
80005e9c:	00 00       	add	r0,r0
80005e9e:	07 94       	ld.ub	r4,r3[0x1]
80005ea0:	00 00       	add	r0,r0
80005ea2:	07 78       	ld.ub	r8,--r3
80005ea4:	80 00       	ld.sh	r0,r0[0x0]
80005ea6:	5d c4       	*unknown*
80005ea8:	80 00       	ld.sh	r0,r0[0x0]
80005eaa:	49 f8       	lddpc	r8,80005f24 <prvInitialiseTCBVariables+0x38>

80005eac <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
80005eac:	eb cd 40 80 	pushm	r7,lr
80005eb0:	1a 97       	mov	r7,sp
	xMissedYield = pdTRUE;
80005eb2:	48 38       	lddpc	r8,80005ebc <vTaskMissedYield+0x10>
80005eb4:	30 19       	mov	r9,1
80005eb6:	91 09       	st.w	r8[0x0],r9
}
80005eb8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ebc:	00 00       	add	r0,r0
80005ebe:	07 90       	ld.ub	r0,r3[0x1]

80005ec0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005ec0:	eb cd 40 80 	pushm	r7,lr
80005ec4:	1a 97       	mov	r7,sp
80005ec6:	20 1d       	sub	sp,4
80005ec8:	ef 4c ff fc 	st.w	r7[-4],r12
80005ecc:	c0 28       	rjmp	80005ed0 <prvIdleTask+0x10>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
80005ece:	d7 03       	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
80005ed0:	f0 1f 00 05 	mcall	80005ee4 <prvIdleTask+0x24>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005ed4:	48 58       	lddpc	r8,80005ee8 <prvIdleTask+0x28>
80005ed6:	70 08       	ld.w	r8,r8[0x0]
80005ed8:	58 18       	cp.w	r8,1
80005eda:	fe 98 ff fa 	brls	80005ece <prvIdleTask+0xe>
			{
				taskYIELD();
80005ede:	d7 33       	scall
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
80005ee0:	cf 8b       	rjmp	80005ed0 <prvIdleTask+0x10>
80005ee2:	00 00       	add	r0,r0
80005ee4:	80 00       	ld.sh	r0,r0[0x0]
80005ee6:	60 1c       	ld.w	r12,r0[0x4]
80005ee8:	00 00       	add	r0,r0
80005eea:	06 64       	and	r4,r3

80005eec <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
80005eec:	eb cd 40 80 	pushm	r7,lr
80005ef0:	1a 97       	mov	r7,sp
80005ef2:	20 5d       	sub	sp,20
80005ef4:	ef 4c ff fc 	st.w	r7[-4],r12
80005ef8:	ef 4b ff f8 	st.w	r7[-8],r11
80005efc:	ef 4a ff f4 	st.w	r7[-12],r10
80005f00:	ef 49 ff f0 	st.w	r7[-16],r9
80005f04:	ef 58 ff ec 	st.h	r7[-20],r8
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005f08:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005f0c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005f10:	2c c8       	sub	r8,-52
80005f12:	31 0a       	mov	r10,16
80005f14:	12 9b       	mov	r11,r9
80005f16:	10 9c       	mov	r12,r8
80005f18:	f0 1f 00 1a 	mcall	80005f80 <prvInitialiseTCBVariables+0x94>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005f1c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005f20:	30 08       	mov	r8,0
80005f22:	f3 68 00 43 	st.b	r9[67],r8

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
80005f26:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005f2a:	58 78       	cp.w	r8,7
80005f2c:	e0 88 00 05 	brls	80005f36 <prvInitialiseTCBVariables+0x4a>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
80005f30:	30 78       	mov	r8,7
80005f32:	ef 48 ff f4 	st.w	r7[-12],r8
	}

	pxTCB->uxPriority = uxPriority;
80005f36:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005f3a:	ee f9 ff f4 	ld.w	r9,r7[-12]
80005f3e:	91 b9       	st.w	r8[0x2c],r9
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005f40:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005f44:	2f c8       	sub	r8,-4
80005f46:	10 9c       	mov	r12,r8
80005f48:	f0 1f 00 0f 	mcall	80005f84 <prvInitialiseTCBVariables+0x98>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005f4c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005f50:	2e 88       	sub	r8,-24
80005f52:	10 9c       	mov	r12,r8
80005f54:	f0 1f 00 0c 	mcall	80005f84 <prvInitialiseTCBVariables+0x98>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005f58:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005f5c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005f60:	91 49       	st.w	r8[0x10],r9

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005f62:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005f66:	f0 09 11 08 	rsub	r9,r8,8
80005f6a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005f6e:	91 69       	st.w	r8[0x18],r9
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005f70:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005f74:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005f78:	91 99       	st.w	r8[0x24],r9
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
80005f7a:	2f bd       	sub	sp,-20
80005f7c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005f80:	80 00       	ld.sh	r0,r0[0x0]
80005f82:	6a 68       	ld.w	r8,r5[0x18]
80005f84:	80 00       	ld.sh	r0,r0[0x0]
80005f86:	46 98       	lddsp	r8,sp[0x1a4]

80005f88 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
80005f88:	eb cd 40 80 	pushm	r7,lr
80005f8c:	1a 97       	mov	r7,sp
80005f8e:	20 1d       	sub	sp,4
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005f90:	30 08       	mov	r8,0
80005f92:	ef 48 ff fc 	st.w	r7[-4],r8
80005f96:	c1 38       	rjmp	80005fbc <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005f98:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005f9c:	12 98       	mov	r8,r9
80005f9e:	a3 68       	lsl	r8,0x2
80005fa0:	12 08       	add	r8,r9
80005fa2:	a3 68       	lsl	r8,0x2
80005fa4:	10 99       	mov	r9,r8
80005fa6:	49 58       	lddpc	r8,80005ff8 <prvInitialiseTaskLists+0x70>
80005fa8:	f2 08 00 08 	add	r8,r9,r8
80005fac:	10 9c       	mov	r12,r8
80005fae:	f0 1f 00 14 	mcall	80005ffc <prvInitialiseTaskLists+0x74>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005fb2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005fb6:	2f f8       	sub	r8,-1
80005fb8:	ef 48 ff fc 	st.w	r7[-4],r8
80005fbc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005fc0:	58 78       	cp.w	r8,7
80005fc2:	fe 98 ff eb 	brls	80005f98 <prvInitialiseTaskLists+0x10>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80005fc6:	48 fc       	lddpc	r12,80006000 <prvInitialiseTaskLists+0x78>
80005fc8:	f0 1f 00 0d 	mcall	80005ffc <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005fcc:	48 ec       	lddpc	r12,80006004 <prvInitialiseTaskLists+0x7c>
80005fce:	f0 1f 00 0c 	mcall	80005ffc <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xPendingReadyList );
80005fd2:	48 ec       	lddpc	r12,80006008 <prvInitialiseTaskLists+0x80>
80005fd4:	f0 1f 00 0a 	mcall	80005ffc <prvInitialiseTaskLists+0x74>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80005fd8:	48 dc       	lddpc	r12,8000600c <prvInitialiseTaskLists+0x84>
80005fda:	f0 1f 00 09 	mcall	80005ffc <prvInitialiseTaskLists+0x74>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005fde:	48 dc       	lddpc	r12,80006010 <prvInitialiseTaskLists+0x88>
80005fe0:	f0 1f 00 07 	mcall	80005ffc <prvInitialiseTaskLists+0x74>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80005fe4:	48 c8       	lddpc	r8,80006014 <prvInitialiseTaskLists+0x8c>
80005fe6:	48 79       	lddpc	r9,80006000 <prvInitialiseTaskLists+0x78>
80005fe8:	91 09       	st.w	r8[0x0],r9
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80005fea:	48 c8       	lddpc	r8,80006018 <prvInitialiseTaskLists+0x90>
80005fec:	48 69       	lddpc	r9,80006004 <prvInitialiseTaskLists+0x7c>
80005fee:	91 09       	st.w	r8[0x0],r9
}
80005ff0:	2f fd       	sub	sp,-4
80005ff2:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ff6:	00 00       	add	r0,r0
80005ff8:	00 00       	add	r0,r0
80005ffa:	06 64       	and	r4,r3
80005ffc:	80 00       	ld.sh	r0,r0[0x0]
80005ffe:	46 4c       	lddsp	r12,sp[0x190]
80006000:	00 00       	add	r0,r0
80006002:	07 04       	ld.w	r4,r3++
80006004:	00 00       	add	r0,r0
80006006:	07 18       	ld.sh	r8,r3++
80006008:	00 00       	add	r0,r0
8000600a:	07 34       	ld.ub	r4,r3++
8000600c:	00 00       	add	r0,r0
8000600e:	07 48       	ld.w	r8,--r3
80006010:	00 00       	add	r0,r0
80006012:	07 60       	ld.uh	r0,--r3
80006014:	00 00       	add	r0,r0
80006016:	07 2c       	ld.uh	r12,r3++
80006018:	00 00       	add	r0,r0
8000601a:	07 30       	ld.ub	r0,r3++

8000601c <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
8000601c:	eb cd 40 80 	pushm	r7,lr
80006020:	1a 97       	mov	r7,sp
80006022:	20 2d       	sub	sp,8
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006024:	49 b8       	lddpc	r8,80006090 <prvCheckTasksWaitingTermination+0x74>
80006026:	70 08       	ld.w	r8,r8[0x0]
80006028:	58 08       	cp.w	r8,0
8000602a:	c2 f0       	breq	80006088 <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
8000602c:	f0 1f 00 1a 	mcall	80006094 <prvCheckTasksWaitingTermination+0x78>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006030:	49 a8       	lddpc	r8,80006098 <prvCheckTasksWaitingTermination+0x7c>
80006032:	70 08       	ld.w	r8,r8[0x0]
80006034:	58 08       	cp.w	r8,0
80006036:	5f 08       	sreq	r8
80006038:	ef 48 ff f8 	st.w	r7[-8],r8
			xTaskResumeAll();
8000603c:	f0 1f 00 18 	mcall	8000609c <prvCheckTasksWaitingTermination+0x80>

			if( xListIsEmpty == pdFALSE )
80006040:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006044:	58 08       	cp.w	r8,0
80006046:	c2 11       	brne	80006088 <prvCheckTasksWaitingTermination+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006048:	f0 1f 00 16 	mcall	800060a0 <prvCheckTasksWaitingTermination+0x84>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
8000604c:	49 38       	lddpc	r8,80006098 <prvCheckTasksWaitingTermination+0x7c>
8000604e:	2f 88       	sub	r8,-8
80006050:	70 18       	ld.w	r8,r8[0x4]
80006052:	70 38       	ld.w	r8,r8[0xc]
80006054:	ef 48 ff fc 	st.w	r7[-4],r8
					vListRemove( &( pxTCB->xGenericListItem ) );
80006058:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000605c:	2f c8       	sub	r8,-4
8000605e:	10 9c       	mov	r12,r8
80006060:	f0 1f 00 11 	mcall	800060a4 <prvCheckTasksWaitingTermination+0x88>
					--uxCurrentNumberOfTasks;
80006064:	49 18       	lddpc	r8,800060a8 <prvCheckTasksWaitingTermination+0x8c>
80006066:	70 08       	ld.w	r8,r8[0x0]
80006068:	f0 c9 00 01 	sub	r9,r8,1
8000606c:	48 f8       	lddpc	r8,800060a8 <prvCheckTasksWaitingTermination+0x8c>
8000606e:	91 09       	st.w	r8[0x0],r9
					--uxTasksDeleted;
80006070:	48 88       	lddpc	r8,80006090 <prvCheckTasksWaitingTermination+0x74>
80006072:	70 08       	ld.w	r8,r8[0x0]
80006074:	f0 c9 00 01 	sub	r9,r8,1
80006078:	48 68       	lddpc	r8,80006090 <prvCheckTasksWaitingTermination+0x74>
8000607a:	91 09       	st.w	r8[0x0],r9
				}
				taskEXIT_CRITICAL();
8000607c:	f0 1f 00 0c 	mcall	800060ac <prvCheckTasksWaitingTermination+0x90>

				prvDeleteTCB( pxTCB );
80006080:	ee fc ff fc 	ld.w	r12,r7[-4]
80006084:	f0 1f 00 0b 	mcall	800060b0 <prvCheckTasksWaitingTermination+0x94>
			}
		}
	}
	#endif
}
80006088:	2f ed       	sub	sp,-8
8000608a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000608e:	00 00       	add	r0,r0
80006090:	00 00       	add	r0,r0
80006092:	07 5c       	ld.sh	r12,--r3
80006094:	80 00       	ld.sh	r0,r0[0x0]
80006096:	58 f0       	cp.w	r0,15
80006098:	00 00       	add	r0,r0
8000609a:	07 48       	ld.w	r8,--r3
8000609c:	80 00       	ld.sh	r0,r0[0x0]
8000609e:	59 0c       	cp.w	r12,16
800060a0:	80 00       	ld.sh	r0,r0[0x0]
800060a2:	49 dc       	lddpc	r12,80006114 <prvAddCurrentTaskToDelayedList+0x60>
800060a4:	80 00       	ld.sh	r0,r0[0x0]
800060a6:	47 c6       	lddsp	r6,sp[0x1f0]
800060a8:	00 00       	add	r0,r0
800060aa:	07 74       	ld.ub	r4,--r3
800060ac:	80 00       	ld.sh	r0,r0[0x0]
800060ae:	49 f8       	lddpc	r8,80006128 <prvAddCurrentTaskToDelayedList+0x74>
800060b0:	80 00       	ld.sh	r0,r0[0x0]
800060b2:	61 c8       	ld.w	r8,r0[0x70]

800060b4 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800060b4:	eb cd 40 80 	pushm	r7,lr
800060b8:	1a 97       	mov	r7,sp
800060ba:	20 1d       	sub	sp,4
800060bc:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800060c0:	49 78       	lddpc	r8,8000611c <prvAddCurrentTaskToDelayedList+0x68>
800060c2:	70 08       	ld.w	r8,r8[0x0]
800060c4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800060c8:	91 19       	st.w	r8[0x4],r9

	if( xTimeToWake < xTickCount )
800060ca:	49 68       	lddpc	r8,80006120 <prvAddCurrentTaskToDelayedList+0x6c>
800060cc:	70 08       	ld.w	r8,r8[0x0]
800060ce:	ee f9 ff fc 	ld.w	r9,r7[-4]
800060d2:	10 39       	cp.w	r9,r8
800060d4:	c0 c2       	brcc	800060ec <prvAddCurrentTaskToDelayedList+0x38>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800060d6:	49 28       	lddpc	r8,8000611c <prvAddCurrentTaskToDelayedList+0x68>
800060d8:	70 08       	ld.w	r8,r8[0x0]
800060da:	f0 c9 ff fc 	sub	r9,r8,-4
800060de:	49 28       	lddpc	r8,80006124 <prvAddCurrentTaskToDelayedList+0x70>
800060e0:	70 08       	ld.w	r8,r8[0x0]
800060e2:	12 9b       	mov	r11,r9
800060e4:	10 9c       	mov	r12,r8
800060e6:	f0 1f 00 11 	mcall	80006128 <prvAddCurrentTaskToDelayedList+0x74>
800060ea:	c1 58       	rjmp	80006114 <prvAddCurrentTaskToDelayedList+0x60>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800060ec:	48 c8       	lddpc	r8,8000611c <prvAddCurrentTaskToDelayedList+0x68>
800060ee:	70 08       	ld.w	r8,r8[0x0]
800060f0:	f0 c9 ff fc 	sub	r9,r8,-4
800060f4:	48 e8       	lddpc	r8,8000612c <prvAddCurrentTaskToDelayedList+0x78>
800060f6:	70 08       	ld.w	r8,r8[0x0]
800060f8:	12 9b       	mov	r11,r9
800060fa:	10 9c       	mov	r12,r8
800060fc:	f0 1f 00 0b 	mcall	80006128 <prvAddCurrentTaskToDelayedList+0x74>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006100:	48 c8       	lddpc	r8,80006130 <prvAddCurrentTaskToDelayedList+0x7c>
80006102:	70 08       	ld.w	r8,r8[0x0]
80006104:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006108:	10 39       	cp.w	r9,r8
8000610a:	c0 52       	brcc	80006114 <prvAddCurrentTaskToDelayedList+0x60>
		{
			xNextTaskUnblockTime = xTimeToWake;
8000610c:	48 98       	lddpc	r8,80006130 <prvAddCurrentTaskToDelayedList+0x7c>
8000610e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006112:	91 09       	st.w	r8[0x0],r9
		}
	}
}
80006114:	2f fd       	sub	sp,-4
80006116:	e3 cd 80 80 	ldm	sp++,r7,pc
8000611a:	00 00       	add	r0,r0
8000611c:	00 00       	add	r0,r0
8000611e:	06 60       	and	r0,r3
80006120:	00 00       	add	r0,r0
80006122:	07 78       	ld.ub	r8,--r3
80006124:	00 00       	add	r0,r0
80006126:	07 30       	ld.ub	r0,r3++
80006128:	80 00       	ld.sh	r0,r0[0x0]
8000612a:	47 24       	lddsp	r4,sp[0x1c8]
8000612c:	00 00       	add	r0,r0
8000612e:	07 2c       	ld.uh	r12,r3++
80006130:	00 00       	add	r0,r0
80006132:	00 24       	rsub	r4,r0

80006134 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
80006134:	eb cd 40 80 	pushm	r7,lr
80006138:	1a 97       	mov	r7,sp
8000613a:	20 3d       	sub	sp,12
8000613c:	18 98       	mov	r8,r12
8000613e:	ef 4b ff f4 	st.w	r7[-12],r11
80006142:	ef 58 ff f8 	st.h	r7[-8],r8
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006146:	34 4c       	mov	r12,68
80006148:	f0 1f 00 1d 	mcall	800061bc <prvAllocateTCBAndStack+0x88>
8000614c:	18 98       	mov	r8,r12
8000614e:	ef 48 ff fc 	st.w	r7[-4],r8

	if( pxNewTCB != NULL )
80006152:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006156:	58 08       	cp.w	r8,0
80006158:	c2 c0       	breq	800061b0 <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
8000615a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000615e:	58 08       	cp.w	r8,0
80006160:	c0 91       	brne	80006172 <prvAllocateTCBAndStack+0x3e>
80006162:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80006166:	a3 68       	lsl	r8,0x2
80006168:	10 9c       	mov	r12,r8
8000616a:	f0 1f 00 15 	mcall	800061bc <prvAllocateTCBAndStack+0x88>
8000616e:	18 98       	mov	r8,r12
80006170:	c0 38       	rjmp	80006176 <prvAllocateTCBAndStack+0x42>
80006172:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006176:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000617a:	93 c8       	st.w	r9[0x30],r8

		if( pxNewTCB->pxStack == NULL )
8000617c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006180:	70 c8       	ld.w	r8,r8[0x30]
80006182:	58 08       	cp.w	r8,0
80006184:	c0 91       	brne	80006196 <prvAllocateTCBAndStack+0x62>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006186:	ee fc ff fc 	ld.w	r12,r7[-4]
8000618a:	f0 1f 00 0e 	mcall	800061c0 <prvAllocateTCBAndStack+0x8c>
			pxNewTCB = NULL;
8000618e:	30 08       	mov	r8,0
80006190:	ef 48 ff fc 	st.w	r7[-4],r8
80006194:	c0 e8       	rjmp	800061b0 <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006196:	ef 18 ff f8 	ld.uh	r8,r7[-8]
8000619a:	f0 09 15 02 	lsl	r9,r8,0x2
8000619e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800061a2:	70 c8       	ld.w	r8,r8[0x30]
800061a4:	12 9a       	mov	r10,r9
800061a6:	e0 6b 00 a5 	mov	r11,165
800061aa:	10 9c       	mov	r12,r8
800061ac:	f0 1f 00 06 	mcall	800061c4 <prvAllocateTCBAndStack+0x90>
		}
	}

	return pxNewTCB;
800061b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800061b4:	10 9c       	mov	r12,r8
800061b6:	2f dd       	sub	sp,-12
800061b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800061bc:	80 00       	ld.sh	r0,r0[0x0]
800061be:	4c 68       	lddpc	r8,800062d4 <__avr32_udiv64+0xe0>
800061c0:	80 00       	ld.sh	r0,r0[0x0]
800061c2:	4c a4       	lddpc	r4,800062e8 <__avr32_udiv64+0xf4>
800061c4:	80 00       	ld.sh	r0,r0[0x0]
800061c6:	6a 24       	ld.w	r4,r5[0x8]

800061c8 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
800061c8:	eb cd 40 80 	pushm	r7,lr
800061cc:	1a 97       	mov	r7,sp
800061ce:	20 1d       	sub	sp,4
800061d0:	ef 4c ff fc 	st.w	r7[-4],r12
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800061d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800061d8:	70 c8       	ld.w	r8,r8[0x30]
800061da:	10 9c       	mov	r12,r8
800061dc:	f0 1f 00 05 	mcall	800061f0 <prvDeleteTCB+0x28>
		vPortFree( pxTCB );
800061e0:	ee fc ff fc 	ld.w	r12,r7[-4]
800061e4:	f0 1f 00 03 	mcall	800061f0 <prvDeleteTCB+0x28>
	}
800061e8:	2f fd       	sub	sp,-4
800061ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800061ee:	00 00       	add	r0,r0
800061f0:	80 00       	ld.sh	r0,r0[0x0]
800061f2:	4c a4       	lddpc	r4,80006318 <__avr32_udiv64+0x124>

800061f4 <__avr32_udiv64>:
800061f4:	d4 31       	pushm	r0-r7,lr
800061f6:	1a 97       	mov	r7,sp
800061f8:	20 3d       	sub	sp,12
800061fa:	10 9c       	mov	r12,r8
800061fc:	12 9e       	mov	lr,r9
800061fe:	14 93       	mov	r3,r10
80006200:	58 09       	cp.w	r9,0
80006202:	e0 81 00 bd 	brne	8000637c <__avr32_udiv64+0x188>
80006206:	16 38       	cp.w	r8,r11
80006208:	e0 88 00 40 	brls	80006288 <__avr32_udiv64+0x94>
8000620c:	f0 08 12 00 	clz	r8,r8
80006210:	c0 d0       	breq	8000622a <__avr32_udiv64+0x36>
80006212:	f6 08 09 4b 	lsl	r11,r11,r8
80006216:	f0 09 11 20 	rsub	r9,r8,32
8000621a:	f8 08 09 4c 	lsl	r12,r12,r8
8000621e:	f4 09 0a 49 	lsr	r9,r10,r9
80006222:	f4 08 09 43 	lsl	r3,r10,r8
80006226:	f3 eb 10 0b 	or	r11,r9,r11
8000622a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000622e:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80006232:	f6 0e 0d 00 	divu	r0,r11,lr
80006236:	e6 0b 16 10 	lsr	r11,r3,0x10
8000623a:	00 99       	mov	r9,r0
8000623c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80006240:	e0 0a 02 48 	mul	r8,r0,r10
80006244:	10 3b       	cp.w	r11,r8
80006246:	c0 a2       	brcc	8000625a <__avr32_udiv64+0x66>
80006248:	20 19       	sub	r9,1
8000624a:	18 0b       	add	r11,r12
8000624c:	18 3b       	cp.w	r11,r12
8000624e:	c0 63       	brcs	8000625a <__avr32_udiv64+0x66>
80006250:	10 3b       	cp.w	r11,r8
80006252:	f7 b9 03 01 	sublo	r9,1
80006256:	f7 dc e3 0b 	addcs	r11,r11,r12
8000625a:	f6 08 01 01 	sub	r1,r11,r8
8000625e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80006262:	e2 0e 0d 00 	divu	r0,r1,lr
80006266:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000626a:	00 98       	mov	r8,r0
8000626c:	e0 0a 02 4a 	mul	r10,r0,r10
80006270:	14 33       	cp.w	r3,r10
80006272:	c0 82       	brcc	80006282 <__avr32_udiv64+0x8e>
80006274:	20 18       	sub	r8,1
80006276:	18 03       	add	r3,r12
80006278:	18 33       	cp.w	r3,r12
8000627a:	c0 43       	brcs	80006282 <__avr32_udiv64+0x8e>
8000627c:	14 33       	cp.w	r3,r10
8000627e:	f7 b8 03 01 	sublo	r8,1
80006282:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80006286:	cd f8       	rjmp	80006444 <__avr32_udiv64+0x250>
80006288:	58 08       	cp.w	r8,0
8000628a:	c0 51       	brne	80006294 <__avr32_udiv64+0xa0>
8000628c:	30 19       	mov	r9,1
8000628e:	f2 08 0d 08 	divu	r8,r9,r8
80006292:	10 9c       	mov	r12,r8
80006294:	f8 06 12 00 	clz	r6,r12
80006298:	c0 41       	brne	800062a0 <__avr32_udiv64+0xac>
8000629a:	18 1b       	sub	r11,r12
8000629c:	30 19       	mov	r9,1
8000629e:	c4 08       	rjmp	8000631e <__avr32_udiv64+0x12a>
800062a0:	ec 01 11 20 	rsub	r1,r6,32
800062a4:	f4 01 0a 49 	lsr	r9,r10,r1
800062a8:	f8 06 09 4c 	lsl	r12,r12,r6
800062ac:	f6 06 09 48 	lsl	r8,r11,r6
800062b0:	f6 01 0a 41 	lsr	r1,r11,r1
800062b4:	f3 e8 10 08 	or	r8,r9,r8
800062b8:	f8 03 16 10 	lsr	r3,r12,0x10
800062bc:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
800062c0:	e2 03 0d 00 	divu	r0,r1,r3
800062c4:	f0 0b 16 10 	lsr	r11,r8,0x10
800062c8:	00 9e       	mov	lr,r0
800062ca:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800062ce:	e0 05 02 49 	mul	r9,r0,r5
800062d2:	12 3b       	cp.w	r11,r9
800062d4:	c0 a2       	brcc	800062e8 <__avr32_udiv64+0xf4>
800062d6:	20 1e       	sub	lr,1
800062d8:	18 0b       	add	r11,r12
800062da:	18 3b       	cp.w	r11,r12
800062dc:	c0 63       	brcs	800062e8 <__avr32_udiv64+0xf4>
800062de:	12 3b       	cp.w	r11,r9
800062e0:	f7 be 03 01 	sublo	lr,1
800062e4:	f7 dc e3 0b 	addcs	r11,r11,r12
800062e8:	12 1b       	sub	r11,r9
800062ea:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
800062ee:	f6 03 0d 02 	divu	r2,r11,r3
800062f2:	f1 e3 11 08 	or	r8,r8,r3<<0x10
800062f6:	04 99       	mov	r9,r2
800062f8:	e4 05 02 4b 	mul	r11,r2,r5
800062fc:	16 38       	cp.w	r8,r11
800062fe:	c0 a2       	brcc	80006312 <__avr32_udiv64+0x11e>
80006300:	20 19       	sub	r9,1
80006302:	18 08       	add	r8,r12
80006304:	18 38       	cp.w	r8,r12
80006306:	c0 63       	brcs	80006312 <__avr32_udiv64+0x11e>
80006308:	16 38       	cp.w	r8,r11
8000630a:	f7 b9 03 01 	sublo	r9,1
8000630e:	f1 dc e3 08 	addcs	r8,r8,r12
80006312:	f4 06 09 43 	lsl	r3,r10,r6
80006316:	f0 0b 01 0b 	sub	r11,r8,r11
8000631a:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000631e:	f8 06 16 10 	lsr	r6,r12,0x10
80006322:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
80006326:	f6 06 0d 00 	divu	r0,r11,r6
8000632a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000632e:	00 9a       	mov	r10,r0
80006330:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80006334:	e0 0e 02 48 	mul	r8,r0,lr
80006338:	10 3b       	cp.w	r11,r8
8000633a:	c0 a2       	brcc	8000634e <__avr32_udiv64+0x15a>
8000633c:	20 1a       	sub	r10,1
8000633e:	18 0b       	add	r11,r12
80006340:	18 3b       	cp.w	r11,r12
80006342:	c0 63       	brcs	8000634e <__avr32_udiv64+0x15a>
80006344:	10 3b       	cp.w	r11,r8
80006346:	f7 ba 03 01 	sublo	r10,1
8000634a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000634e:	f6 08 01 01 	sub	r1,r11,r8
80006352:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80006356:	e2 06 0d 00 	divu	r0,r1,r6
8000635a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000635e:	00 98       	mov	r8,r0
80006360:	e0 0e 02 4b 	mul	r11,r0,lr
80006364:	16 33       	cp.w	r3,r11
80006366:	c0 82       	brcc	80006376 <__avr32_udiv64+0x182>
80006368:	20 18       	sub	r8,1
8000636a:	18 03       	add	r3,r12
8000636c:	18 33       	cp.w	r3,r12
8000636e:	c0 43       	brcs	80006376 <__avr32_udiv64+0x182>
80006370:	16 33       	cp.w	r3,r11
80006372:	f7 b8 03 01 	sublo	r8,1
80006376:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000637a:	c6 98       	rjmp	8000644c <__avr32_udiv64+0x258>
8000637c:	16 39       	cp.w	r9,r11
8000637e:	e0 8b 00 65 	brhi	80006448 <__avr32_udiv64+0x254>
80006382:	f2 09 12 00 	clz	r9,r9
80006386:	c0 b1       	brne	8000639c <__avr32_udiv64+0x1a8>
80006388:	10 3a       	cp.w	r10,r8
8000638a:	5f 2a       	srhs	r10
8000638c:	1c 3b       	cp.w	r11,lr
8000638e:	5f b8       	srhi	r8
80006390:	10 4a       	or	r10,r8
80006392:	f2 0a 18 00 	cp.b	r10,r9
80006396:	c5 90       	breq	80006448 <__avr32_udiv64+0x254>
80006398:	30 18       	mov	r8,1
8000639a:	c5 98       	rjmp	8000644c <__avr32_udiv64+0x258>
8000639c:	f0 09 09 46 	lsl	r6,r8,r9
800063a0:	f2 03 11 20 	rsub	r3,r9,32
800063a4:	fc 09 09 4e 	lsl	lr,lr,r9
800063a8:	f0 03 0a 48 	lsr	r8,r8,r3
800063ac:	f6 09 09 4c 	lsl	r12,r11,r9
800063b0:	f4 03 0a 42 	lsr	r2,r10,r3
800063b4:	ef 46 ff f4 	st.w	r7[-12],r6
800063b8:	f6 03 0a 43 	lsr	r3,r11,r3
800063bc:	18 42       	or	r2,r12
800063be:	f1 ee 10 0c 	or	r12,r8,lr
800063c2:	f8 01 16 10 	lsr	r1,r12,0x10
800063c6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
800063ca:	e6 01 0d 04 	divu	r4,r3,r1
800063ce:	e4 03 16 10 	lsr	r3,r2,0x10
800063d2:	08 9e       	mov	lr,r4
800063d4:	e7 e5 11 03 	or	r3,r3,r5<<0x10
800063d8:	e8 06 02 48 	mul	r8,r4,r6
800063dc:	10 33       	cp.w	r3,r8
800063de:	c0 a2       	brcc	800063f2 <__avr32_udiv64+0x1fe>
800063e0:	20 1e       	sub	lr,1
800063e2:	18 03       	add	r3,r12
800063e4:	18 33       	cp.w	r3,r12
800063e6:	c0 63       	brcs	800063f2 <__avr32_udiv64+0x1fe>
800063e8:	10 33       	cp.w	r3,r8
800063ea:	f7 be 03 01 	sublo	lr,1
800063ee:	e7 dc e3 03 	addcs	r3,r3,r12
800063f2:	10 13       	sub	r3,r8
800063f4:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
800063f8:	e6 01 0d 00 	divu	r0,r3,r1
800063fc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80006400:	00 98       	mov	r8,r0
80006402:	e0 06 02 46 	mul	r6,r0,r6
80006406:	0c 3b       	cp.w	r11,r6
80006408:	c0 a2       	brcc	8000641c <__avr32_udiv64+0x228>
8000640a:	20 18       	sub	r8,1
8000640c:	18 0b       	add	r11,r12
8000640e:	18 3b       	cp.w	r11,r12
80006410:	c0 63       	brcs	8000641c <__avr32_udiv64+0x228>
80006412:	0c 3b       	cp.w	r11,r6
80006414:	f7 dc e3 0b 	addcs	r11,r11,r12
80006418:	f7 b8 03 01 	sublo	r8,1
8000641c:	f1 ee 11 08 	or	r8,r8,lr<<0x10
80006420:	ee f4 ff f4 	ld.w	r4,r7[-12]
80006424:	0c 1b       	sub	r11,r6
80006426:	f0 04 06 42 	mulu.d	r2,r8,r4
8000642a:	06 95       	mov	r5,r3
8000642c:	16 35       	cp.w	r5,r11
8000642e:	e0 8b 00 0a 	brhi	80006442 <__avr32_udiv64+0x24e>
80006432:	5f 0b       	sreq	r11
80006434:	f4 09 09 49 	lsl	r9,r10,r9
80006438:	12 32       	cp.w	r2,r9
8000643a:	5f b9       	srhi	r9
8000643c:	f7 e9 00 09 	and	r9,r11,r9
80006440:	c0 60       	breq	8000644c <__avr32_udiv64+0x258>
80006442:	20 18       	sub	r8,1
80006444:	30 09       	mov	r9,0
80006446:	c0 38       	rjmp	8000644c <__avr32_udiv64+0x258>
80006448:	30 09       	mov	r9,0
8000644a:	12 98       	mov	r8,r9
8000644c:	10 9a       	mov	r10,r8
8000644e:	12 93       	mov	r3,r9
80006450:	10 92       	mov	r2,r8
80006452:	12 9b       	mov	r11,r9
80006454:	2f dd       	sub	sp,-12
80006456:	d8 32       	popm	r0-r7,pc

80006458 <atexit>:
80006458:	d4 01       	pushm	lr
8000645a:	30 09       	mov	r9,0
8000645c:	18 9b       	mov	r11,r12
8000645e:	12 9a       	mov	r10,r9
80006460:	12 9c       	mov	r12,r9
80006462:	e0 a0 03 39 	rcall	80006ad4 <__register_exitproc>
80006466:	d8 02       	popm	pc

80006468 <exit>:
80006468:	d4 21       	pushm	r4-r7,lr
8000646a:	30 0b       	mov	r11,0
8000646c:	18 97       	mov	r7,r12
8000646e:	e0 a0 03 85 	rcall	80006b78 <__call_exitprocs>
80006472:	fe c8 f1 3e 	sub	r8,pc,-3778
80006476:	70 0c       	ld.w	r12,r8[0x0]
80006478:	78 a8       	ld.w	r8,r12[0x28]
8000647a:	58 08       	cp.w	r8,0
8000647c:	c0 20       	breq	80006480 <exit+0x18>
8000647e:	5d 18       	icall	r8
80006480:	0e 9c       	mov	r12,r7
80006482:	e0 a0 03 08 	rcall	80006a92 <_exit>
80006486:	d7 03       	nop

80006488 <free>:
80006488:	d4 01       	pushm	lr
8000648a:	e0 68 01 18 	mov	r8,280
8000648e:	18 9b       	mov	r11,r12
80006490:	70 0c       	ld.w	r12,r8[0x0]
80006492:	e0 a0 04 27 	rcall	80006ce0 <_free_r>
80006496:	d8 02       	popm	pc

80006498 <malloc>:
80006498:	d4 01       	pushm	lr
8000649a:	e0 68 01 18 	mov	r8,280
8000649e:	18 9b       	mov	r11,r12
800064a0:	70 0c       	ld.w	r12,r8[0x0]
800064a2:	c0 3c       	rcall	800064a8 <_malloc_r>
800064a4:	d8 02       	popm	pc
800064a6:	d7 03       	nop

800064a8 <_malloc_r>:
800064a8:	d4 31       	pushm	r0-r7,lr
800064aa:	f6 c8 ff f5 	sub	r8,r11,-11
800064ae:	18 95       	mov	r5,r12
800064b0:	10 97       	mov	r7,r8
800064b2:	e0 17 ff f8 	andl	r7,0xfff8
800064b6:	59 68       	cp.w	r8,22
800064b8:	f9 b7 08 10 	movls	r7,16
800064bc:	16 37       	cp.w	r7,r11
800064be:	5f 38       	srlo	r8
800064c0:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800064c4:	c0 50       	breq	800064ce <_malloc_r+0x26>
800064c6:	30 c8       	mov	r8,12
800064c8:	99 38       	st.w	r12[0xc],r8
800064ca:	e0 8f 01 f8 	bral	800068ba <_malloc_r+0x412>
800064ce:	fe b0 f1 dd 	rcall	80004888 <__malloc_lock>
800064d2:	e0 47 01 f7 	cp.w	r7,503
800064d6:	e0 8b 00 1d 	brhi	80006510 <_malloc_r+0x68>
800064da:	ee 03 16 03 	lsr	r3,r7,0x3
800064de:	e0 68 01 1c 	mov	r8,284
800064e2:	f0 03 00 38 	add	r8,r8,r3<<0x3
800064e6:	70 36       	ld.w	r6,r8[0xc]
800064e8:	10 36       	cp.w	r6,r8
800064ea:	c0 61       	brne	800064f6 <_malloc_r+0x4e>
800064ec:	ec c8 ff f8 	sub	r8,r6,-8
800064f0:	70 36       	ld.w	r6,r8[0xc]
800064f2:	10 36       	cp.w	r6,r8
800064f4:	c0 c0       	breq	8000650c <_malloc_r+0x64>
800064f6:	6c 18       	ld.w	r8,r6[0x4]
800064f8:	e0 18 ff fc 	andl	r8,0xfffc
800064fc:	6c 3a       	ld.w	r10,r6[0xc]
800064fe:	ec 08 00 09 	add	r9,r6,r8
80006502:	0a 9c       	mov	r12,r5
80006504:	6c 28       	ld.w	r8,r6[0x8]
80006506:	95 28       	st.w	r10[0x8],r8
80006508:	91 3a       	st.w	r8[0xc],r10
8000650a:	c4 78       	rjmp	80006598 <_malloc_r+0xf0>
8000650c:	2f e3       	sub	r3,-2
8000650e:	c4 d8       	rjmp	800065a8 <_malloc_r+0x100>
80006510:	ee 03 16 09 	lsr	r3,r7,0x9
80006514:	c0 41       	brne	8000651c <_malloc_r+0x74>
80006516:	ee 03 16 03 	lsr	r3,r7,0x3
8000651a:	c2 68       	rjmp	80006566 <_malloc_r+0xbe>
8000651c:	58 43       	cp.w	r3,4
8000651e:	e0 8b 00 06 	brhi	8000652a <_malloc_r+0x82>
80006522:	ee 03 16 06 	lsr	r3,r7,0x6
80006526:	2c 83       	sub	r3,-56
80006528:	c1 f8       	rjmp	80006566 <_malloc_r+0xbe>
8000652a:	59 43       	cp.w	r3,20
8000652c:	e0 8b 00 04 	brhi	80006534 <_malloc_r+0x8c>
80006530:	2a 53       	sub	r3,-91
80006532:	c1 a8       	rjmp	80006566 <_malloc_r+0xbe>
80006534:	e0 43 00 54 	cp.w	r3,84
80006538:	e0 8b 00 06 	brhi	80006544 <_malloc_r+0x9c>
8000653c:	ee 03 16 0c 	lsr	r3,r7,0xc
80006540:	29 23       	sub	r3,-110
80006542:	c1 28       	rjmp	80006566 <_malloc_r+0xbe>
80006544:	e0 43 01 54 	cp.w	r3,340
80006548:	e0 8b 00 06 	brhi	80006554 <_malloc_r+0xac>
8000654c:	ee 03 16 0f 	lsr	r3,r7,0xf
80006550:	28 93       	sub	r3,-119
80006552:	c0 a8       	rjmp	80006566 <_malloc_r+0xbe>
80006554:	e0 43 05 54 	cp.w	r3,1364
80006558:	e0 88 00 04 	brls	80006560 <_malloc_r+0xb8>
8000655c:	37 e3       	mov	r3,126
8000655e:	c0 48       	rjmp	80006566 <_malloc_r+0xbe>
80006560:	ee 03 16 12 	lsr	r3,r7,0x12
80006564:	28 43       	sub	r3,-124
80006566:	e0 6a 01 1c 	mov	r10,284
8000656a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000656e:	74 36       	ld.w	r6,r10[0xc]
80006570:	c1 98       	rjmp	800065a2 <_malloc_r+0xfa>
80006572:	6c 19       	ld.w	r9,r6[0x4]
80006574:	e0 19 ff fc 	andl	r9,0xfffc
80006578:	f2 07 01 0b 	sub	r11,r9,r7
8000657c:	58 fb       	cp.w	r11,15
8000657e:	e0 8a 00 04 	brle	80006586 <_malloc_r+0xde>
80006582:	20 13       	sub	r3,1
80006584:	c1 18       	rjmp	800065a6 <_malloc_r+0xfe>
80006586:	6c 38       	ld.w	r8,r6[0xc]
80006588:	58 0b       	cp.w	r11,0
8000658a:	c0 b5       	brlt	800065a0 <_malloc_r+0xf8>
8000658c:	6c 2a       	ld.w	r10,r6[0x8]
8000658e:	ec 09 00 09 	add	r9,r6,r9
80006592:	0a 9c       	mov	r12,r5
80006594:	91 2a       	st.w	r8[0x8],r10
80006596:	95 38       	st.w	r10[0xc],r8
80006598:	72 18       	ld.w	r8,r9[0x4]
8000659a:	a1 a8       	sbr	r8,0x0
8000659c:	93 18       	st.w	r9[0x4],r8
8000659e:	cb c8       	rjmp	80006716 <_malloc_r+0x26e>
800065a0:	10 96       	mov	r6,r8
800065a2:	14 36       	cp.w	r6,r10
800065a4:	ce 71       	brne	80006572 <_malloc_r+0xca>
800065a6:	2f f3       	sub	r3,-1
800065a8:	e0 6a 01 1c 	mov	r10,284
800065ac:	f4 cc ff f8 	sub	r12,r10,-8
800065b0:	78 26       	ld.w	r6,r12[0x8]
800065b2:	18 36       	cp.w	r6,r12
800065b4:	c6 c0       	breq	8000668c <_malloc_r+0x1e4>
800065b6:	6c 19       	ld.w	r9,r6[0x4]
800065b8:	e0 19 ff fc 	andl	r9,0xfffc
800065bc:	f2 07 01 08 	sub	r8,r9,r7
800065c0:	58 f8       	cp.w	r8,15
800065c2:	e0 89 00 8f 	brgt	800066e0 <_malloc_r+0x238>
800065c6:	99 3c       	st.w	r12[0xc],r12
800065c8:	99 2c       	st.w	r12[0x8],r12
800065ca:	58 08       	cp.w	r8,0
800065cc:	c0 55       	brlt	800065d6 <_malloc_r+0x12e>
800065ce:	ec 09 00 09 	add	r9,r6,r9
800065d2:	0a 9c       	mov	r12,r5
800065d4:	ce 2b       	rjmp	80006598 <_malloc_r+0xf0>
800065d6:	e0 49 01 ff 	cp.w	r9,511
800065da:	e0 8b 00 13 	brhi	80006600 <_malloc_r+0x158>
800065de:	a3 99       	lsr	r9,0x3
800065e0:	f4 09 00 38 	add	r8,r10,r9<<0x3
800065e4:	70 2b       	ld.w	r11,r8[0x8]
800065e6:	8d 38       	st.w	r6[0xc],r8
800065e8:	8d 2b       	st.w	r6[0x8],r11
800065ea:	97 36       	st.w	r11[0xc],r6
800065ec:	91 26       	st.w	r8[0x8],r6
800065ee:	a3 49       	asr	r9,0x2
800065f0:	74 18       	ld.w	r8,r10[0x4]
800065f2:	30 1b       	mov	r11,1
800065f4:	f6 09 09 49 	lsl	r9,r11,r9
800065f8:	f1 e9 10 09 	or	r9,r8,r9
800065fc:	95 19       	st.w	r10[0x4],r9
800065fe:	c4 78       	rjmp	8000668c <_malloc_r+0x1e4>
80006600:	f2 0a 16 09 	lsr	r10,r9,0x9
80006604:	58 4a       	cp.w	r10,4
80006606:	e0 8b 00 07 	brhi	80006614 <_malloc_r+0x16c>
8000660a:	f2 0a 16 06 	lsr	r10,r9,0x6
8000660e:	2c 8a       	sub	r10,-56
80006610:	c2 08       	rjmp	80006650 <_malloc_r+0x1a8>
80006612:	d7 03       	nop
80006614:	59 4a       	cp.w	r10,20
80006616:	e0 8b 00 04 	brhi	8000661e <_malloc_r+0x176>
8000661a:	2a 5a       	sub	r10,-91
8000661c:	c1 a8       	rjmp	80006650 <_malloc_r+0x1a8>
8000661e:	e0 4a 00 54 	cp.w	r10,84
80006622:	e0 8b 00 06 	brhi	8000662e <_malloc_r+0x186>
80006626:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000662a:	29 2a       	sub	r10,-110
8000662c:	c1 28       	rjmp	80006650 <_malloc_r+0x1a8>
8000662e:	e0 4a 01 54 	cp.w	r10,340
80006632:	e0 8b 00 06 	brhi	8000663e <_malloc_r+0x196>
80006636:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000663a:	28 9a       	sub	r10,-119
8000663c:	c0 a8       	rjmp	80006650 <_malloc_r+0x1a8>
8000663e:	e0 4a 05 54 	cp.w	r10,1364
80006642:	e0 88 00 04 	brls	8000664a <_malloc_r+0x1a2>
80006646:	37 ea       	mov	r10,126
80006648:	c0 48       	rjmp	80006650 <_malloc_r+0x1a8>
8000664a:	f2 0a 16 12 	lsr	r10,r9,0x12
8000664e:	28 4a       	sub	r10,-124
80006650:	e0 6b 01 1c 	mov	r11,284
80006654:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006658:	68 28       	ld.w	r8,r4[0x8]
8000665a:	08 38       	cp.w	r8,r4
8000665c:	c0 e1       	brne	80006678 <_malloc_r+0x1d0>
8000665e:	76 19       	ld.w	r9,r11[0x4]
80006660:	a3 4a       	asr	r10,0x2
80006662:	30 1e       	mov	lr,1
80006664:	fc 0a 09 4a 	lsl	r10,lr,r10
80006668:	f3 ea 10 0a 	or	r10,r9,r10
8000666c:	10 99       	mov	r9,r8
8000666e:	97 1a       	st.w	r11[0x4],r10
80006670:	c0 a8       	rjmp	80006684 <_malloc_r+0x1dc>
80006672:	70 28       	ld.w	r8,r8[0x8]
80006674:	08 38       	cp.w	r8,r4
80006676:	c0 60       	breq	80006682 <_malloc_r+0x1da>
80006678:	70 1a       	ld.w	r10,r8[0x4]
8000667a:	e0 1a ff fc 	andl	r10,0xfffc
8000667e:	14 39       	cp.w	r9,r10
80006680:	cf 93       	brcs	80006672 <_malloc_r+0x1ca>
80006682:	70 39       	ld.w	r9,r8[0xc]
80006684:	8d 39       	st.w	r6[0xc],r9
80006686:	8d 28       	st.w	r6[0x8],r8
80006688:	91 36       	st.w	r8[0xc],r6
8000668a:	93 26       	st.w	r9[0x8],r6
8000668c:	e6 08 14 02 	asr	r8,r3,0x2
80006690:	30 1b       	mov	r11,1
80006692:	e0 64 01 1c 	mov	r4,284
80006696:	f6 08 09 4b 	lsl	r11,r11,r8
8000669a:	68 18       	ld.w	r8,r4[0x4]
8000669c:	10 3b       	cp.w	r11,r8
8000669e:	e0 8b 00 6b 	brhi	80006774 <_malloc_r+0x2cc>
800066a2:	f7 e8 00 09 	and	r9,r11,r8
800066a6:	c0 b1       	brne	800066bc <_malloc_r+0x214>
800066a8:	e0 13 ff fc 	andl	r3,0xfffc
800066ac:	a1 7b       	lsl	r11,0x1
800066ae:	2f c3       	sub	r3,-4
800066b0:	c0 38       	rjmp	800066b6 <_malloc_r+0x20e>
800066b2:	2f c3       	sub	r3,-4
800066b4:	a1 7b       	lsl	r11,0x1
800066b6:	f7 e8 00 09 	and	r9,r11,r8
800066ba:	cf c0       	breq	800066b2 <_malloc_r+0x20a>
800066bc:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800066c0:	06 92       	mov	r2,r3
800066c2:	1c 91       	mov	r1,lr
800066c4:	62 36       	ld.w	r6,r1[0xc]
800066c6:	c2 e8       	rjmp	80006722 <_malloc_r+0x27a>
800066c8:	6c 1a       	ld.w	r10,r6[0x4]
800066ca:	e0 1a ff fc 	andl	r10,0xfffc
800066ce:	f4 07 01 08 	sub	r8,r10,r7
800066d2:	58 f8       	cp.w	r8,15
800066d4:	e0 8a 00 15 	brle	800066fe <_malloc_r+0x256>
800066d8:	6c 3a       	ld.w	r10,r6[0xc]
800066da:	6c 29       	ld.w	r9,r6[0x8]
800066dc:	95 29       	st.w	r10[0x8],r9
800066de:	93 3a       	st.w	r9[0xc],r10
800066e0:	0e 99       	mov	r9,r7
800066e2:	ec 07 00 07 	add	r7,r6,r7
800066e6:	a1 a9       	sbr	r9,0x0
800066e8:	99 37       	st.w	r12[0xc],r7
800066ea:	99 27       	st.w	r12[0x8],r7
800066ec:	8d 19       	st.w	r6[0x4],r9
800066ee:	ee 08 09 08 	st.w	r7[r8],r8
800066f2:	8f 2c       	st.w	r7[0x8],r12
800066f4:	8f 3c       	st.w	r7[0xc],r12
800066f6:	a1 a8       	sbr	r8,0x0
800066f8:	0a 9c       	mov	r12,r5
800066fa:	8f 18       	st.w	r7[0x4],r8
800066fc:	c0 d8       	rjmp	80006716 <_malloc_r+0x26e>
800066fe:	6c 39       	ld.w	r9,r6[0xc]
80006700:	58 08       	cp.w	r8,0
80006702:	c0 f5       	brlt	80006720 <_malloc_r+0x278>
80006704:	ec 0a 00 0a 	add	r10,r6,r10
80006708:	74 18       	ld.w	r8,r10[0x4]
8000670a:	a1 a8       	sbr	r8,0x0
8000670c:	0a 9c       	mov	r12,r5
8000670e:	95 18       	st.w	r10[0x4],r8
80006710:	6c 28       	ld.w	r8,r6[0x8]
80006712:	93 28       	st.w	r9[0x8],r8
80006714:	91 39       	st.w	r8[0xc],r9
80006716:	fe b0 f0 c7 	rcall	800048a4 <__malloc_unlock>
8000671a:	ec cc ff f8 	sub	r12,r6,-8
8000671e:	d8 32       	popm	r0-r7,pc
80006720:	12 96       	mov	r6,r9
80006722:	02 36       	cp.w	r6,r1
80006724:	cd 21       	brne	800066c8 <_malloc_r+0x220>
80006726:	2f f2       	sub	r2,-1
80006728:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000672c:	c0 30       	breq	80006732 <_malloc_r+0x28a>
8000672e:	2f 81       	sub	r1,-8
80006730:	cc ab       	rjmp	800066c4 <_malloc_r+0x21c>
80006732:	1c 98       	mov	r8,lr
80006734:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006738:	c0 81       	brne	80006748 <_malloc_r+0x2a0>
8000673a:	68 19       	ld.w	r9,r4[0x4]
8000673c:	f6 08 11 ff 	rsub	r8,r11,-1
80006740:	f3 e8 00 08 	and	r8,r9,r8
80006744:	89 18       	st.w	r4[0x4],r8
80006746:	c0 78       	rjmp	80006754 <_malloc_r+0x2ac>
80006748:	f0 c9 00 08 	sub	r9,r8,8
8000674c:	20 13       	sub	r3,1
8000674e:	70 08       	ld.w	r8,r8[0x0]
80006750:	12 38       	cp.w	r8,r9
80006752:	cf 10       	breq	80006734 <_malloc_r+0x28c>
80006754:	a1 7b       	lsl	r11,0x1
80006756:	68 18       	ld.w	r8,r4[0x4]
80006758:	10 3b       	cp.w	r11,r8
8000675a:	e0 8b 00 0d 	brhi	80006774 <_malloc_r+0x2cc>
8000675e:	58 0b       	cp.w	r11,0
80006760:	c0 a0       	breq	80006774 <_malloc_r+0x2cc>
80006762:	04 93       	mov	r3,r2
80006764:	c0 38       	rjmp	8000676a <_malloc_r+0x2c2>
80006766:	2f c3       	sub	r3,-4
80006768:	a1 7b       	lsl	r11,0x1
8000676a:	f7 e8 00 09 	and	r9,r11,r8
8000676e:	ca 71       	brne	800066bc <_malloc_r+0x214>
80006770:	cf bb       	rjmp	80006766 <_malloc_r+0x2be>
80006772:	d7 03       	nop
80006774:	68 23       	ld.w	r3,r4[0x8]
80006776:	66 12       	ld.w	r2,r3[0x4]
80006778:	e0 12 ff fc 	andl	r2,0xfffc
8000677c:	0e 32       	cp.w	r2,r7
8000677e:	5f 39       	srlo	r9
80006780:	e4 07 01 08 	sub	r8,r2,r7
80006784:	58 f8       	cp.w	r8,15
80006786:	5f aa       	srle	r10
80006788:	f5 e9 10 09 	or	r9,r10,r9
8000678c:	e0 80 00 98 	breq	800068bc <_malloc_r+0x414>
80006790:	e0 68 07 a4 	mov	r8,1956
80006794:	70 01       	ld.w	r1,r8[0x0]
80006796:	e0 68 05 28 	mov	r8,1320
8000679a:	2f 01       	sub	r1,-16
8000679c:	70 08       	ld.w	r8,r8[0x0]
8000679e:	0e 01       	add	r1,r7
800067a0:	5b f8       	cp.w	r8,-1
800067a2:	c0 40       	breq	800067aa <_malloc_r+0x302>
800067a4:	28 11       	sub	r1,-127
800067a6:	e0 11 ff 80 	andl	r1,0xff80
800067aa:	02 9b       	mov	r11,r1
800067ac:	0a 9c       	mov	r12,r5
800067ae:	c4 3d       	rcall	80006a34 <_sbrk_r>
800067b0:	18 96       	mov	r6,r12
800067b2:	5b fc       	cp.w	r12,-1
800067b4:	c7 40       	breq	8000689c <_malloc_r+0x3f4>
800067b6:	e6 02 00 08 	add	r8,r3,r2
800067ba:	10 3c       	cp.w	r12,r8
800067bc:	c0 32       	brcc	800067c2 <_malloc_r+0x31a>
800067be:	08 33       	cp.w	r3,r4
800067c0:	c6 e1       	brne	8000689c <_malloc_r+0x3f4>
800067c2:	e0 6a 07 a8 	mov	r10,1960
800067c6:	74 09       	ld.w	r9,r10[0x0]
800067c8:	e2 09 00 09 	add	r9,r1,r9
800067cc:	95 09       	st.w	r10[0x0],r9
800067ce:	10 36       	cp.w	r6,r8
800067d0:	c0 a1       	brne	800067e4 <_malloc_r+0x33c>
800067d2:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800067d6:	c0 71       	brne	800067e4 <_malloc_r+0x33c>
800067d8:	e2 02 00 02 	add	r2,r1,r2
800067dc:	68 28       	ld.w	r8,r4[0x8]
800067de:	a1 a2       	sbr	r2,0x0
800067e0:	91 12       	st.w	r8[0x4],r2
800067e2:	c4 e8       	rjmp	8000687e <_malloc_r+0x3d6>
800067e4:	e0 6a 05 28 	mov	r10,1320
800067e8:	74 0b       	ld.w	r11,r10[0x0]
800067ea:	5b fb       	cp.w	r11,-1
800067ec:	c0 31       	brne	800067f2 <_malloc_r+0x34a>
800067ee:	95 06       	st.w	r10[0x0],r6
800067f0:	c0 78       	rjmp	800067fe <_malloc_r+0x356>
800067f2:	ec 09 00 09 	add	r9,r6,r9
800067f6:	e0 6a 07 a8 	mov	r10,1960
800067fa:	10 19       	sub	r9,r8
800067fc:	95 09       	st.w	r10[0x0],r9
800067fe:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006802:	f0 09 11 08 	rsub	r9,r8,8
80006806:	58 08       	cp.w	r8,0
80006808:	f2 08 17 10 	movne	r8,r9
8000680c:	ed d8 e1 06 	addne	r6,r6,r8
80006810:	28 08       	sub	r8,-128
80006812:	ec 01 00 01 	add	r1,r6,r1
80006816:	0a 9c       	mov	r12,r5
80006818:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000681c:	f0 01 01 01 	sub	r1,r8,r1
80006820:	02 9b       	mov	r11,r1
80006822:	c0 9d       	rcall	80006a34 <_sbrk_r>
80006824:	e0 68 07 a8 	mov	r8,1960
80006828:	5b fc       	cp.w	r12,-1
8000682a:	ec 0c 17 00 	moveq	r12,r6
8000682e:	f9 b1 00 00 	moveq	r1,0
80006832:	70 09       	ld.w	r9,r8[0x0]
80006834:	0c 1c       	sub	r12,r6
80006836:	89 26       	st.w	r4[0x8],r6
80006838:	02 0c       	add	r12,r1
8000683a:	12 01       	add	r1,r9
8000683c:	a1 ac       	sbr	r12,0x0
8000683e:	91 01       	st.w	r8[0x0],r1
80006840:	8d 1c       	st.w	r6[0x4],r12
80006842:	08 33       	cp.w	r3,r4
80006844:	c1 d0       	breq	8000687e <_malloc_r+0x3d6>
80006846:	58 f2       	cp.w	r2,15
80006848:	e0 8b 00 05 	brhi	80006852 <_malloc_r+0x3aa>
8000684c:	30 18       	mov	r8,1
8000684e:	8d 18       	st.w	r6[0x4],r8
80006850:	c2 68       	rjmp	8000689c <_malloc_r+0x3f4>
80006852:	30 59       	mov	r9,5
80006854:	20 c2       	sub	r2,12
80006856:	e0 12 ff f8 	andl	r2,0xfff8
8000685a:	e6 02 00 08 	add	r8,r3,r2
8000685e:	91 29       	st.w	r8[0x8],r9
80006860:	91 19       	st.w	r8[0x4],r9
80006862:	66 18       	ld.w	r8,r3[0x4]
80006864:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006868:	e5 e8 10 08 	or	r8,r2,r8
8000686c:	87 18       	st.w	r3[0x4],r8
8000686e:	58 f2       	cp.w	r2,15
80006870:	e0 88 00 07 	brls	8000687e <_malloc_r+0x3d6>
80006874:	e6 cb ff f8 	sub	r11,r3,-8
80006878:	0a 9c       	mov	r12,r5
8000687a:	e0 a0 02 33 	rcall	80006ce0 <_free_r>
8000687e:	e0 69 07 a0 	mov	r9,1952
80006882:	72 0a       	ld.w	r10,r9[0x0]
80006884:	e0 68 07 a8 	mov	r8,1960
80006888:	70 08       	ld.w	r8,r8[0x0]
8000688a:	14 38       	cp.w	r8,r10
8000688c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006890:	e0 69 07 9c 	mov	r9,1948
80006894:	72 0a       	ld.w	r10,r9[0x0]
80006896:	14 38       	cp.w	r8,r10
80006898:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000689c:	68 28       	ld.w	r8,r4[0x8]
8000689e:	70 18       	ld.w	r8,r8[0x4]
800068a0:	e0 18 ff fc 	andl	r8,0xfffc
800068a4:	0e 38       	cp.w	r8,r7
800068a6:	5f 39       	srlo	r9
800068a8:	0e 18       	sub	r8,r7
800068aa:	58 f8       	cp.w	r8,15
800068ac:	5f aa       	srle	r10
800068ae:	f5 e9 10 09 	or	r9,r10,r9
800068b2:	c0 50       	breq	800068bc <_malloc_r+0x414>
800068b4:	0a 9c       	mov	r12,r5
800068b6:	fe b0 ef f7 	rcall	800048a4 <__malloc_unlock>
800068ba:	d8 3a       	popm	r0-r7,pc,r12=0
800068bc:	68 26       	ld.w	r6,r4[0x8]
800068be:	a1 a8       	sbr	r8,0x0
800068c0:	0e 99       	mov	r9,r7
800068c2:	a1 a9       	sbr	r9,0x0
800068c4:	8d 19       	st.w	r6[0x4],r9
800068c6:	ec 07 00 07 	add	r7,r6,r7
800068ca:	0a 9c       	mov	r12,r5
800068cc:	89 27       	st.w	r4[0x8],r7
800068ce:	8f 18       	st.w	r7[0x4],r8
800068d0:	fe b0 ef ea 	rcall	800048a4 <__malloc_unlock>
800068d4:	ec cc ff f8 	sub	r12,r6,-8
800068d8:	d8 32       	popm	r0-r7,pc
800068da:	d7 03       	nop

800068dc <memcpy>:
800068dc:	58 8a       	cp.w	r10,8
800068de:	c2 f5       	brlt	8000693c <memcpy+0x60>
800068e0:	f9 eb 10 09 	or	r9,r12,r11
800068e4:	e2 19 00 03 	andl	r9,0x3,COH
800068e8:	e0 81 00 97 	brne	80006a16 <memcpy+0x13a>
800068ec:	e0 4a 00 20 	cp.w	r10,32
800068f0:	c3 b4       	brge	80006966 <memcpy+0x8a>
800068f2:	f4 08 14 02 	asr	r8,r10,0x2
800068f6:	f0 09 11 08 	rsub	r9,r8,8
800068fa:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800068fe:	76 69       	ld.w	r9,r11[0x18]
80006900:	99 69       	st.w	r12[0x18],r9
80006902:	76 59       	ld.w	r9,r11[0x14]
80006904:	99 59       	st.w	r12[0x14],r9
80006906:	76 49       	ld.w	r9,r11[0x10]
80006908:	99 49       	st.w	r12[0x10],r9
8000690a:	76 39       	ld.w	r9,r11[0xc]
8000690c:	99 39       	st.w	r12[0xc],r9
8000690e:	76 29       	ld.w	r9,r11[0x8]
80006910:	99 29       	st.w	r12[0x8],r9
80006912:	76 19       	ld.w	r9,r11[0x4]
80006914:	99 19       	st.w	r12[0x4],r9
80006916:	76 09       	ld.w	r9,r11[0x0]
80006918:	99 09       	st.w	r12[0x0],r9
8000691a:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000691e:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006922:	e0 1a 00 03 	andl	r10,0x3
80006926:	f4 0a 11 04 	rsub	r10,r10,4
8000692a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000692e:	17 a9       	ld.ub	r9,r11[0x2]
80006930:	b0 a9       	st.b	r8[0x2],r9
80006932:	17 99       	ld.ub	r9,r11[0x1]
80006934:	b0 99       	st.b	r8[0x1],r9
80006936:	17 89       	ld.ub	r9,r11[0x0]
80006938:	b0 89       	st.b	r8[0x0],r9
8000693a:	5e fc       	retal	r12
8000693c:	f4 0a 11 09 	rsub	r10,r10,9
80006940:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006944:	17 f9       	ld.ub	r9,r11[0x7]
80006946:	b8 f9       	st.b	r12[0x7],r9
80006948:	17 e9       	ld.ub	r9,r11[0x6]
8000694a:	b8 e9       	st.b	r12[0x6],r9
8000694c:	17 d9       	ld.ub	r9,r11[0x5]
8000694e:	b8 d9       	st.b	r12[0x5],r9
80006950:	17 c9       	ld.ub	r9,r11[0x4]
80006952:	b8 c9       	st.b	r12[0x4],r9
80006954:	17 b9       	ld.ub	r9,r11[0x3]
80006956:	b8 b9       	st.b	r12[0x3],r9
80006958:	17 a9       	ld.ub	r9,r11[0x2]
8000695a:	b8 a9       	st.b	r12[0x2],r9
8000695c:	17 99       	ld.ub	r9,r11[0x1]
8000695e:	b8 99       	st.b	r12[0x1],r9
80006960:	17 89       	ld.ub	r9,r11[0x0]
80006962:	b8 89       	st.b	r12[0x0],r9
80006964:	5e fc       	retal	r12
80006966:	eb cd 40 c0 	pushm	r6-r7,lr
8000696a:	18 99       	mov	r9,r12
8000696c:	22 0a       	sub	r10,32
8000696e:	b7 07       	ld.d	r6,r11++
80006970:	b3 26       	st.d	r9++,r6
80006972:	b7 07       	ld.d	r6,r11++
80006974:	b3 26       	st.d	r9++,r6
80006976:	b7 07       	ld.d	r6,r11++
80006978:	b3 26       	st.d	r9++,r6
8000697a:	b7 07       	ld.d	r6,r11++
8000697c:	b3 26       	st.d	r9++,r6
8000697e:	22 0a       	sub	r10,32
80006980:	cf 74       	brge	8000696e <memcpy+0x92>
80006982:	2f 0a       	sub	r10,-16
80006984:	c0 65       	brlt	80006990 <memcpy+0xb4>
80006986:	b7 07       	ld.d	r6,r11++
80006988:	b3 26       	st.d	r9++,r6
8000698a:	b7 07       	ld.d	r6,r11++
8000698c:	b3 26       	st.d	r9++,r6
8000698e:	21 0a       	sub	r10,16
80006990:	5c 3a       	neg	r10
80006992:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006996:	d7 03       	nop
80006998:	d7 03       	nop
8000699a:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000699e:	f3 66 00 0e 	st.b	r9[14],r6
800069a2:	f7 36 00 0d 	ld.ub	r6,r11[13]
800069a6:	f3 66 00 0d 	st.b	r9[13],r6
800069aa:	f7 36 00 0c 	ld.ub	r6,r11[12]
800069ae:	f3 66 00 0c 	st.b	r9[12],r6
800069b2:	f7 36 00 0b 	ld.ub	r6,r11[11]
800069b6:	f3 66 00 0b 	st.b	r9[11],r6
800069ba:	f7 36 00 0a 	ld.ub	r6,r11[10]
800069be:	f3 66 00 0a 	st.b	r9[10],r6
800069c2:	f7 36 00 09 	ld.ub	r6,r11[9]
800069c6:	f3 66 00 09 	st.b	r9[9],r6
800069ca:	f7 36 00 08 	ld.ub	r6,r11[8]
800069ce:	f3 66 00 08 	st.b	r9[8],r6
800069d2:	f7 36 00 07 	ld.ub	r6,r11[7]
800069d6:	f3 66 00 07 	st.b	r9[7],r6
800069da:	f7 36 00 06 	ld.ub	r6,r11[6]
800069de:	f3 66 00 06 	st.b	r9[6],r6
800069e2:	f7 36 00 05 	ld.ub	r6,r11[5]
800069e6:	f3 66 00 05 	st.b	r9[5],r6
800069ea:	f7 36 00 04 	ld.ub	r6,r11[4]
800069ee:	f3 66 00 04 	st.b	r9[4],r6
800069f2:	f7 36 00 03 	ld.ub	r6,r11[3]
800069f6:	f3 66 00 03 	st.b	r9[3],r6
800069fa:	f7 36 00 02 	ld.ub	r6,r11[2]
800069fe:	f3 66 00 02 	st.b	r9[2],r6
80006a02:	f7 36 00 01 	ld.ub	r6,r11[1]
80006a06:	f3 66 00 01 	st.b	r9[1],r6
80006a0a:	f7 36 00 00 	ld.ub	r6,r11[0]
80006a0e:	f3 66 00 00 	st.b	r9[0],r6
80006a12:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a16:	20 1a       	sub	r10,1
80006a18:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006a1c:	f8 0a 0b 09 	st.b	r12[r10],r9
80006a20:	cf b1       	brne	80006a16 <memcpy+0x13a>
80006a22:	5e fc       	retal	r12

80006a24 <memset>:
80006a24:	18 98       	mov	r8,r12
80006a26:	c0 38       	rjmp	80006a2c <memset+0x8>
80006a28:	10 cb       	st.b	r8++,r11
80006a2a:	20 1a       	sub	r10,1
80006a2c:	58 0a       	cp.w	r10,0
80006a2e:	cf d1       	brne	80006a28 <memset+0x4>
80006a30:	5e fc       	retal	r12
80006a32:	d7 03       	nop

80006a34 <_sbrk_r>:
80006a34:	d4 21       	pushm	r4-r7,lr
80006a36:	30 08       	mov	r8,0
80006a38:	18 97       	mov	r7,r12
80006a3a:	e0 66 07 e8 	mov	r6,2024
80006a3e:	16 9c       	mov	r12,r11
80006a40:	8d 08       	st.w	r6[0x0],r8
80006a42:	c2 dc       	rcall	80006a9c <_sbrk>
80006a44:	5b fc       	cp.w	r12,-1
80006a46:	c0 51       	brne	80006a50 <_sbrk_r+0x1c>
80006a48:	6c 08       	ld.w	r8,r6[0x0]
80006a4a:	58 08       	cp.w	r8,0
80006a4c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006a50:	d8 22       	popm	r4-r7,pc
80006a52:	d7 03       	nop

80006a54 <strcpy>:
80006a54:	30 08       	mov	r8,0
80006a56:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006a5a:	f8 08 0b 09 	st.b	r12[r8],r9
80006a5e:	2f f8       	sub	r8,-1
80006a60:	58 09       	cp.w	r9,0
80006a62:	cf a1       	brne	80006a56 <strcpy+0x2>
80006a64:	5e fc       	retal	r12
80006a66:	d7 03       	nop

80006a68 <strncpy>:
80006a68:	30 08       	mov	r8,0
80006a6a:	10 3a       	cp.w	r10,r8
80006a6c:	5e 0c       	reteq	r12
80006a6e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006a72:	f8 08 0b 09 	st.b	r12[r8],r9
80006a76:	2f f8       	sub	r8,-1
80006a78:	58 09       	cp.w	r9,0
80006a7a:	cf 81       	brne	80006a6a <strncpy+0x2>
80006a7c:	10 3a       	cp.w	r10,r8
80006a7e:	5e 0c       	reteq	r12
80006a80:	f8 08 0b 09 	st.b	r12[r8],r9
80006a84:	2f f8       	sub	r8,-1
80006a86:	cf bb       	rjmp	80006a7c <strncpy+0x14>

80006a88 <_init_argv>:
80006a88:	30 e8       	mov	r8,14
80006a8a:	d6 73       	breakpoint
80006a8c:	3f fc       	mov	r12,-1
80006a8e:	35 8b       	mov	r11,88
80006a90:	5e fc       	retal	r12

80006a92 <_exit>:
80006a92:	30 d8       	mov	r8,13
80006a94:	d6 73       	breakpoint
80006a96:	3f fc       	mov	r12,-1
80006a98:	35 8b       	mov	r11,88
80006a9a:	c0 08       	rjmp	80006a9a <_exit+0x8>

80006a9c <_sbrk>:
80006a9c:	d4 01       	pushm	lr
80006a9e:	e0 68 07 d0 	mov	r8,2000
80006aa2:	70 09       	ld.w	r9,r8[0x0]
80006aa4:	58 09       	cp.w	r9,0
80006aa6:	c0 41       	brne	80006aae <_sbrk+0x12>
80006aa8:	e0 69 07 f0 	mov	r9,2032
80006aac:	91 09       	st.w	r8[0x0],r9
80006aae:	e0 69 07 d0 	mov	r9,2000
80006ab2:	e0 6a f0 00 	mov	r10,61440
80006ab6:	72 08       	ld.w	r8,r9[0x0]
80006ab8:	f0 0c 00 0c 	add	r12,r8,r12
80006abc:	14 3c       	cp.w	r12,r10
80006abe:	e0 8b 00 04 	brhi	80006ac6 <_sbrk+0x2a>
80006ac2:	93 0c       	st.w	r9[0x0],r12
80006ac4:	c0 58       	rjmp	80006ace <_sbrk+0x32>
80006ac6:	cb fc       	rcall	80006c44 <__errno>
80006ac8:	30 c8       	mov	r8,12
80006aca:	99 08       	st.w	r12[0x0],r8
80006acc:	3f f8       	mov	r8,-1
80006ace:	10 9c       	mov	r12,r8
80006ad0:	d8 02       	popm	pc
80006ad2:	d7 03       	nop

80006ad4 <__register_exitproc>:
80006ad4:	d4 31       	pushm	r0-r7,lr
80006ad6:	fe c8 f7 a2 	sub	r8,pc,-2142
80006ada:	70 03       	ld.w	r3,r8[0x0]
80006adc:	67 24       	ld.w	r4,r3[0x48]
80006ade:	e6 c8 ff b4 	sub	r8,r3,-76
80006ae2:	58 04       	cp.w	r4,0
80006ae4:	f0 04 17 00 	moveq	r4,r8
80006ae8:	e7 f4 0a 12 	st.weq	r3[0x48],r4
80006aec:	18 97       	mov	r7,r12
80006aee:	16 96       	mov	r6,r11
80006af0:	14 95       	mov	r5,r10
80006af2:	12 92       	mov	r2,r9
80006af4:	68 18       	ld.w	r8,r4[0x4]
80006af6:	59 f8       	cp.w	r8,31
80006af8:	e0 8a 00 0e 	brle	80006b14 <__register_exitproc+0x40>
80006afc:	e0 6c 00 8c 	mov	r12,140
80006b00:	fe b0 fc cc 	rcall	80006498 <malloc>
80006b04:	18 94       	mov	r4,r12
80006b06:	c3 80       	breq	80006b76 <__register_exitproc+0xa2>
80006b08:	67 28       	ld.w	r8,r3[0x48]
80006b0a:	99 08       	st.w	r12[0x0],r8
80006b0c:	e7 4c 00 48 	st.w	r3[72],r12
80006b10:	30 08       	mov	r8,0
80006b12:	99 18       	st.w	r12[0x4],r8
80006b14:	58 07       	cp.w	r7,0
80006b16:	c2 70       	breq	80006b64 <__register_exitproc+0x90>
80006b18:	e8 fc 00 88 	ld.w	r12,r4[136]
80006b1c:	58 0c       	cp.w	r12,0
80006b1e:	c0 d1       	brne	80006b38 <__register_exitproc+0x64>
80006b20:	e0 6c 01 08 	mov	r12,264
80006b24:	fe b0 fc ba 	rcall	80006498 <malloc>
80006b28:	c2 70       	breq	80006b76 <__register_exitproc+0xa2>
80006b2a:	30 08       	mov	r8,0
80006b2c:	e9 4c 00 88 	st.w	r4[136],r12
80006b30:	f9 48 01 04 	st.w	r12[260],r8
80006b34:	f9 48 01 00 	st.w	r12[256],r8
80006b38:	68 18       	ld.w	r8,r4[0x4]
80006b3a:	f0 c9 ff e0 	sub	r9,r8,-32
80006b3e:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
80006b42:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
80006b46:	30 1a       	mov	r10,1
80006b48:	f8 f9 01 00 	ld.w	r9,r12[256]
80006b4c:	f4 08 09 48 	lsl	r8,r10,r8
80006b50:	10 49       	or	r9,r8
80006b52:	f9 49 01 00 	st.w	r12[256],r9
80006b56:	58 27       	cp.w	r7,2
80006b58:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
80006b5c:	f3 d8 e0 38 	oreq	r8,r9,r8
80006b60:	f9 f8 0a 41 	st.weq	r12[0x104],r8
80006b64:	68 18       	ld.w	r8,r4[0x4]
80006b66:	30 0c       	mov	r12,0
80006b68:	f0 c9 ff ff 	sub	r9,r8,-1
80006b6c:	2f e8       	sub	r8,-2
80006b6e:	89 19       	st.w	r4[0x4],r9
80006b70:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
80006b74:	d8 32       	popm	r0-r7,pc
80006b76:	dc 3a       	popm	r0-r7,pc,r12=-1

80006b78 <__call_exitprocs>:
80006b78:	d4 31       	pushm	r0-r7,lr
80006b7a:	20 3d       	sub	sp,12
80006b7c:	fe c8 f8 48 	sub	r8,pc,-1976
80006b80:	50 2c       	stdsp	sp[0x8],r12
80006b82:	70 08       	ld.w	r8,r8[0x0]
80006b84:	16 91       	mov	r1,r11
80006b86:	50 08       	stdsp	sp[0x0],r8
80006b88:	2b 88       	sub	r8,-72
80006b8a:	50 18       	stdsp	sp[0x4],r8
80006b8c:	40 0a       	lddsp	r10,sp[0x0]
80006b8e:	40 14       	lddsp	r4,sp[0x4]
80006b90:	75 27       	ld.w	r7,r10[0x48]
80006b92:	c5 58       	rjmp	80006c3c <__call_exitprocs+0xc4>
80006b94:	6e 15       	ld.w	r5,r7[0x4]
80006b96:	ee f6 00 88 	ld.w	r6,r7[136]
80006b9a:	ea c2 ff ff 	sub	r2,r5,-1
80006b9e:	20 15       	sub	r5,1
80006ba0:	ee 02 00 22 	add	r2,r7,r2<<0x2
80006ba4:	ec 05 00 23 	add	r3,r6,r5<<0x2
80006ba8:	c3 58       	rjmp	80006c12 <__call_exitprocs+0x9a>
80006baa:	58 01       	cp.w	r1,0
80006bac:	c0 70       	breq	80006bba <__call_exitprocs+0x42>
80006bae:	58 06       	cp.w	r6,0
80006bb0:	c2 e0       	breq	80006c0c <__call_exitprocs+0x94>
80006bb2:	e6 f8 00 80 	ld.w	r8,r3[128]
80006bb6:	02 38       	cp.w	r8,r1
80006bb8:	c2 a1       	brne	80006c0c <__call_exitprocs+0x94>
80006bba:	6e 19       	ld.w	r9,r7[0x4]
80006bbc:	64 08       	ld.w	r8,r2[0x0]
80006bbe:	20 19       	sub	r9,1
80006bc0:	12 35       	cp.w	r5,r9
80006bc2:	ef f5 0a 01 	st.weq	r7[0x4],r5
80006bc6:	f9 b9 01 00 	movne	r9,0
80006bca:	e5 f9 1a 00 	st.wne	r2[0x0],r9
80006bce:	58 08       	cp.w	r8,0
80006bd0:	c1 e0       	breq	80006c0c <__call_exitprocs+0x94>
80006bd2:	6e 10       	ld.w	r0,r7[0x4]
80006bd4:	58 06       	cp.w	r6,0
80006bd6:	c0 90       	breq	80006be8 <__call_exitprocs+0x70>
80006bd8:	30 1a       	mov	r10,1
80006bda:	f4 05 09 49 	lsl	r9,r10,r5
80006bde:	ec fa 01 00 	ld.w	r10,r6[256]
80006be2:	f3 ea 00 0a 	and	r10,r9,r10
80006be6:	c0 31       	brne	80006bec <__call_exitprocs+0x74>
80006be8:	5d 18       	icall	r8
80006bea:	c0 b8       	rjmp	80006c00 <__call_exitprocs+0x88>
80006bec:	ec fa 01 04 	ld.w	r10,r6[260]
80006bf0:	66 0b       	ld.w	r11,r3[0x0]
80006bf2:	14 69       	and	r9,r10
80006bf4:	c0 41       	brne	80006bfc <__call_exitprocs+0x84>
80006bf6:	40 2c       	lddsp	r12,sp[0x8]
80006bf8:	5d 18       	icall	r8
80006bfa:	c0 38       	rjmp	80006c00 <__call_exitprocs+0x88>
80006bfc:	16 9c       	mov	r12,r11
80006bfe:	5d 18       	icall	r8
80006c00:	6e 18       	ld.w	r8,r7[0x4]
80006c02:	10 30       	cp.w	r0,r8
80006c04:	cc 41       	brne	80006b8c <__call_exitprocs+0x14>
80006c06:	68 08       	ld.w	r8,r4[0x0]
80006c08:	0e 38       	cp.w	r8,r7
80006c0a:	cc 11       	brne	80006b8c <__call_exitprocs+0x14>
80006c0c:	20 15       	sub	r5,1
80006c0e:	20 43       	sub	r3,4
80006c10:	20 42       	sub	r2,4
80006c12:	58 05       	cp.w	r5,0
80006c14:	cc b4       	brge	80006baa <__call_exitprocs+0x32>
80006c16:	6e 18       	ld.w	r8,r7[0x4]
80006c18:	58 08       	cp.w	r8,0
80006c1a:	c0 f1       	brne	80006c38 <__call_exitprocs+0xc0>
80006c1c:	6e 08       	ld.w	r8,r7[0x0]
80006c1e:	58 08       	cp.w	r8,0
80006c20:	c0 c0       	breq	80006c38 <__call_exitprocs+0xc0>
80006c22:	89 08       	st.w	r4[0x0],r8
80006c24:	58 06       	cp.w	r6,0
80006c26:	c0 40       	breq	80006c2e <__call_exitprocs+0xb6>
80006c28:	0c 9c       	mov	r12,r6
80006c2a:	fe b0 fc 2f 	rcall	80006488 <free>
80006c2e:	0e 9c       	mov	r12,r7
80006c30:	fe b0 fc 2c 	rcall	80006488 <free>
80006c34:	68 07       	ld.w	r7,r4[0x0]
80006c36:	c0 38       	rjmp	80006c3c <__call_exitprocs+0xc4>
80006c38:	0e 94       	mov	r4,r7
80006c3a:	6e 07       	ld.w	r7,r7[0x0]
80006c3c:	58 07       	cp.w	r7,0
80006c3e:	ca b1       	brne	80006b94 <__call_exitprocs+0x1c>
80006c40:	2f dd       	sub	sp,-12
80006c42:	d8 32       	popm	r0-r7,pc

80006c44 <__errno>:
80006c44:	e0 68 01 18 	mov	r8,280
80006c48:	70 0c       	ld.w	r12,r8[0x0]
80006c4a:	2f 4c       	sub	r12,-12
80006c4c:	5e fc       	retal	r12
80006c4e:	d7 03       	nop

80006c50 <_malloc_trim_r>:
80006c50:	d4 21       	pushm	r4-r7,lr
80006c52:	16 95       	mov	r5,r11
80006c54:	18 97       	mov	r7,r12
80006c56:	fe b0 ee 19 	rcall	80004888 <__malloc_lock>
80006c5a:	e0 64 01 1c 	mov	r4,284
80006c5e:	68 28       	ld.w	r8,r4[0x8]
80006c60:	70 16       	ld.w	r6,r8[0x4]
80006c62:	e0 16 ff fc 	andl	r6,0xfffc
80006c66:	ec c8 ff 91 	sub	r8,r6,-111
80006c6a:	f0 05 01 05 	sub	r5,r8,r5
80006c6e:	e0 15 ff 80 	andl	r5,0xff80
80006c72:	ea c5 00 80 	sub	r5,r5,128
80006c76:	e0 45 00 7f 	cp.w	r5,127
80006c7a:	e0 8a 00 22 	brle	80006cbe <_malloc_trim_r+0x6e>
80006c7e:	30 0b       	mov	r11,0
80006c80:	0e 9c       	mov	r12,r7
80006c82:	cd 9e       	rcall	80006a34 <_sbrk_r>
80006c84:	68 28       	ld.w	r8,r4[0x8]
80006c86:	0c 08       	add	r8,r6
80006c88:	10 3c       	cp.w	r12,r8
80006c8a:	c1 a1       	brne	80006cbe <_malloc_trim_r+0x6e>
80006c8c:	ea 0b 11 00 	rsub	r11,r5,0
80006c90:	0e 9c       	mov	r12,r7
80006c92:	cd 1e       	rcall	80006a34 <_sbrk_r>
80006c94:	5b fc       	cp.w	r12,-1
80006c96:	c1 81       	brne	80006cc6 <_malloc_trim_r+0x76>
80006c98:	30 0b       	mov	r11,0
80006c9a:	0e 9c       	mov	r12,r7
80006c9c:	cc ce       	rcall	80006a34 <_sbrk_r>
80006c9e:	68 28       	ld.w	r8,r4[0x8]
80006ca0:	f8 08 01 09 	sub	r9,r12,r8
80006ca4:	58 f9       	cp.w	r9,15
80006ca6:	e0 8a 00 0c 	brle	80006cbe <_malloc_trim_r+0x6e>
80006caa:	a1 a9       	sbr	r9,0x0
80006cac:	91 19       	st.w	r8[0x4],r9
80006cae:	e0 68 05 28 	mov	r8,1320
80006cb2:	70 09       	ld.w	r9,r8[0x0]
80006cb4:	e0 68 07 a8 	mov	r8,1960
80006cb8:	f8 09 01 09 	sub	r9,r12,r9
80006cbc:	91 09       	st.w	r8[0x0],r9
80006cbe:	0e 9c       	mov	r12,r7
80006cc0:	fe b0 ed f2 	rcall	800048a4 <__malloc_unlock>
80006cc4:	d8 2a       	popm	r4-r7,pc,r12=0
80006cc6:	68 28       	ld.w	r8,r4[0x8]
80006cc8:	0a 16       	sub	r6,r5
80006cca:	a1 a6       	sbr	r6,0x0
80006ccc:	91 16       	st.w	r8[0x4],r6
80006cce:	e0 68 07 a8 	mov	r8,1960
80006cd2:	70 09       	ld.w	r9,r8[0x0]
80006cd4:	0a 19       	sub	r9,r5
80006cd6:	0e 9c       	mov	r12,r7
80006cd8:	91 09       	st.w	r8[0x0],r9
80006cda:	fe b0 ed e5 	rcall	800048a4 <__malloc_unlock>
80006cde:	da 2a       	popm	r4-r7,pc,r12=1

80006ce0 <_free_r>:
80006ce0:	d4 21       	pushm	r4-r7,lr
80006ce2:	16 96       	mov	r6,r11
80006ce4:	18 97       	mov	r7,r12
80006ce6:	58 0b       	cp.w	r11,0
80006ce8:	e0 80 00 c0 	breq	80006e68 <_free_r+0x188>
80006cec:	fe b0 ed ce 	rcall	80004888 <__malloc_lock>
80006cf0:	20 86       	sub	r6,8
80006cf2:	e0 6a 01 1c 	mov	r10,284
80006cf6:	6c 18       	ld.w	r8,r6[0x4]
80006cf8:	74 2e       	ld.w	lr,r10[0x8]
80006cfa:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80006cfe:	a1 c8       	cbr	r8,0x0
80006d00:	ec 08 00 09 	add	r9,r6,r8
80006d04:	72 1b       	ld.w	r11,r9[0x4]
80006d06:	e0 1b ff fc 	andl	r11,0xfffc
80006d0a:	1c 39       	cp.w	r9,lr
80006d0c:	c1 e1       	brne	80006d48 <_free_r+0x68>
80006d0e:	f6 08 00 08 	add	r8,r11,r8
80006d12:	58 0c       	cp.w	r12,0
80006d14:	c0 81       	brne	80006d24 <_free_r+0x44>
80006d16:	6c 09       	ld.w	r9,r6[0x0]
80006d18:	12 16       	sub	r6,r9
80006d1a:	12 08       	add	r8,r9
80006d1c:	6c 3b       	ld.w	r11,r6[0xc]
80006d1e:	6c 29       	ld.w	r9,r6[0x8]
80006d20:	97 29       	st.w	r11[0x8],r9
80006d22:	93 3b       	st.w	r9[0xc],r11
80006d24:	10 99       	mov	r9,r8
80006d26:	95 26       	st.w	r10[0x8],r6
80006d28:	a1 a9       	sbr	r9,0x0
80006d2a:	8d 19       	st.w	r6[0x4],r9
80006d2c:	e0 69 05 24 	mov	r9,1316
80006d30:	72 09       	ld.w	r9,r9[0x0]
80006d32:	12 38       	cp.w	r8,r9
80006d34:	c0 63       	brcs	80006d40 <_free_r+0x60>
80006d36:	e0 68 07 a4 	mov	r8,1956
80006d3a:	0e 9c       	mov	r12,r7
80006d3c:	70 0b       	ld.w	r11,r8[0x0]
80006d3e:	c8 9f       	rcall	80006c50 <_malloc_trim_r>
80006d40:	0e 9c       	mov	r12,r7
80006d42:	fe b0 ed b1 	rcall	800048a4 <__malloc_unlock>
80006d46:	d8 22       	popm	r4-r7,pc
80006d48:	93 1b       	st.w	r9[0x4],r11
80006d4a:	58 0c       	cp.w	r12,0
80006d4c:	c0 30       	breq	80006d52 <_free_r+0x72>
80006d4e:	30 0c       	mov	r12,0
80006d50:	c1 08       	rjmp	80006d70 <_free_r+0x90>
80006d52:	6c 0e       	ld.w	lr,r6[0x0]
80006d54:	f4 c5 ff f8 	sub	r5,r10,-8
80006d58:	1c 16       	sub	r6,lr
80006d5a:	1c 08       	add	r8,lr
80006d5c:	6c 2e       	ld.w	lr,r6[0x8]
80006d5e:	0a 3e       	cp.w	lr,r5
80006d60:	f9 bc 00 01 	moveq	r12,1
80006d64:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80006d68:	eb fe 1a 02 	st.wne	r5[0x8],lr
80006d6c:	fd f5 1a 03 	st.wne	lr[0xc],r5
80006d70:	f2 0b 00 0e 	add	lr,r9,r11
80006d74:	7c 1e       	ld.w	lr,lr[0x4]
80006d76:	ed be 00 00 	bld	lr,0x0
80006d7a:	c1 40       	breq	80006da2 <_free_r+0xc2>
80006d7c:	16 08       	add	r8,r11
80006d7e:	58 0c       	cp.w	r12,0
80006d80:	c0 d1       	brne	80006d9a <_free_r+0xba>
80006d82:	e0 6e 01 1c 	mov	lr,284
80006d86:	72 2b       	ld.w	r11,r9[0x8]
80006d88:	2f 8e       	sub	lr,-8
80006d8a:	1c 3b       	cp.w	r11,lr
80006d8c:	c0 71       	brne	80006d9a <_free_r+0xba>
80006d8e:	97 36       	st.w	r11[0xc],r6
80006d90:	97 26       	st.w	r11[0x8],r6
80006d92:	8d 2b       	st.w	r6[0x8],r11
80006d94:	8d 3b       	st.w	r6[0xc],r11
80006d96:	30 1c       	mov	r12,1
80006d98:	c0 58       	rjmp	80006da2 <_free_r+0xc2>
80006d9a:	72 2b       	ld.w	r11,r9[0x8]
80006d9c:	72 39       	ld.w	r9,r9[0xc]
80006d9e:	93 2b       	st.w	r9[0x8],r11
80006da0:	97 39       	st.w	r11[0xc],r9
80006da2:	10 99       	mov	r9,r8
80006da4:	ec 08 09 08 	st.w	r6[r8],r8
80006da8:	a1 a9       	sbr	r9,0x0
80006daa:	8d 19       	st.w	r6[0x4],r9
80006dac:	58 0c       	cp.w	r12,0
80006dae:	c5 a1       	brne	80006e62 <_free_r+0x182>
80006db0:	e0 48 01 ff 	cp.w	r8,511
80006db4:	e0 8b 00 13 	brhi	80006dda <_free_r+0xfa>
80006db8:	a3 98       	lsr	r8,0x3
80006dba:	f4 08 00 39 	add	r9,r10,r8<<0x3
80006dbe:	72 2b       	ld.w	r11,r9[0x8]
80006dc0:	8d 39       	st.w	r6[0xc],r9
80006dc2:	8d 2b       	st.w	r6[0x8],r11
80006dc4:	97 36       	st.w	r11[0xc],r6
80006dc6:	93 26       	st.w	r9[0x8],r6
80006dc8:	a3 48       	asr	r8,0x2
80006dca:	74 19       	ld.w	r9,r10[0x4]
80006dcc:	30 1b       	mov	r11,1
80006dce:	f6 08 09 48 	lsl	r8,r11,r8
80006dd2:	f3 e8 10 08 	or	r8,r9,r8
80006dd6:	95 18       	st.w	r10[0x4],r8
80006dd8:	c4 58       	rjmp	80006e62 <_free_r+0x182>
80006dda:	f0 0b 16 09 	lsr	r11,r8,0x9
80006dde:	58 4b       	cp.w	r11,4
80006de0:	e0 8b 00 06 	brhi	80006dec <_free_r+0x10c>
80006de4:	f0 0b 16 06 	lsr	r11,r8,0x6
80006de8:	2c 8b       	sub	r11,-56
80006dea:	c2 08       	rjmp	80006e2a <_free_r+0x14a>
80006dec:	59 4b       	cp.w	r11,20
80006dee:	e0 8b 00 04 	brhi	80006df6 <_free_r+0x116>
80006df2:	2a 5b       	sub	r11,-91
80006df4:	c1 b8       	rjmp	80006e2a <_free_r+0x14a>
80006df6:	e0 4b 00 54 	cp.w	r11,84
80006dfa:	e0 8b 00 06 	brhi	80006e06 <_free_r+0x126>
80006dfe:	f0 0b 16 0c 	lsr	r11,r8,0xc
80006e02:	29 2b       	sub	r11,-110
80006e04:	c1 38       	rjmp	80006e2a <_free_r+0x14a>
80006e06:	e0 4b 01 54 	cp.w	r11,340
80006e0a:	e0 8b 00 06 	brhi	80006e16 <_free_r+0x136>
80006e0e:	f0 0b 16 0f 	lsr	r11,r8,0xf
80006e12:	28 9b       	sub	r11,-119
80006e14:	c0 b8       	rjmp	80006e2a <_free_r+0x14a>
80006e16:	e0 4b 05 54 	cp.w	r11,1364
80006e1a:	e0 88 00 05 	brls	80006e24 <_free_r+0x144>
80006e1e:	37 eb       	mov	r11,126
80006e20:	c0 58       	rjmp	80006e2a <_free_r+0x14a>
80006e22:	d7 03       	nop
80006e24:	f0 0b 16 12 	lsr	r11,r8,0x12
80006e28:	28 4b       	sub	r11,-124
80006e2a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80006e2e:	78 29       	ld.w	r9,r12[0x8]
80006e30:	18 39       	cp.w	r9,r12
80006e32:	c0 e1       	brne	80006e4e <_free_r+0x16e>
80006e34:	74 18       	ld.w	r8,r10[0x4]
80006e36:	a3 4b       	asr	r11,0x2
80006e38:	30 1c       	mov	r12,1
80006e3a:	f8 0b 09 4b 	lsl	r11,r12,r11
80006e3e:	f1 eb 10 0b 	or	r11,r8,r11
80006e42:	12 98       	mov	r8,r9
80006e44:	95 1b       	st.w	r10[0x4],r11
80006e46:	c0 a8       	rjmp	80006e5a <_free_r+0x17a>
80006e48:	72 29       	ld.w	r9,r9[0x8]
80006e4a:	18 39       	cp.w	r9,r12
80006e4c:	c0 60       	breq	80006e58 <_free_r+0x178>
80006e4e:	72 1a       	ld.w	r10,r9[0x4]
80006e50:	e0 1a ff fc 	andl	r10,0xfffc
80006e54:	14 38       	cp.w	r8,r10
80006e56:	cf 93       	brcs	80006e48 <_free_r+0x168>
80006e58:	72 38       	ld.w	r8,r9[0xc]
80006e5a:	8d 38       	st.w	r6[0xc],r8
80006e5c:	8d 29       	st.w	r6[0x8],r9
80006e5e:	93 36       	st.w	r9[0xc],r6
80006e60:	91 26       	st.w	r8[0x8],r6
80006e62:	0e 9c       	mov	r12,r7
80006e64:	fe b0 ed 20 	rcall	800048a4 <__malloc_unlock>
80006e68:	d8 22       	popm	r4-r7,pc
80006e6a:	d7 03       	nop

80006e6c <__do_global_ctors_aux>:
80006e6c:	d4 21       	pushm	r4-r7,lr
80006e6e:	30 c7       	mov	r7,12
80006e70:	c0 28       	rjmp	80006e74 <__do_global_ctors_aux+0x8>
80006e72:	5d 18       	icall	r8
80006e74:	20 47       	sub	r7,4
80006e76:	6e 08       	ld.w	r8,r7[0x0]
80006e78:	5b f8       	cp.w	r8,-1
80006e7a:	cf c1       	brne	80006e72 <__do_global_ctors_aux+0x6>
80006e7c:	d8 22       	popm	r4-r7,pc
80006e7e:	d7 03       	nop

Disassembly of section .exception:

80007000 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80007000:	c0 08       	rjmp	80007000 <_evba>
	...

80007004 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80007004:	c0 08       	rjmp	80007004 <_handle_TLB_Multiple_Hit>
	...

80007008 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80007008:	c0 08       	rjmp	80007008 <_handle_Bus_Error_Data_Fetch>
	...

8000700c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000700c:	c0 08       	rjmp	8000700c <_handle_Bus_Error_Instruction_Fetch>
	...

80007010 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80007010:	c0 08       	rjmp	80007010 <_handle_NMI>
	...

80007014 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80007014:	c0 08       	rjmp	80007014 <_handle_Instruction_Address>
	...

80007018 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80007018:	c0 08       	rjmp	80007018 <_handle_ITLB_Protection>
	...

8000701c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000701c:	c0 08       	rjmp	8000701c <_handle_Breakpoint>
	...

80007020 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80007020:	c0 08       	rjmp	80007020 <_handle_Illegal_Opcode>
	...

80007024 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80007024:	c0 08       	rjmp	80007024 <_handle_Unimplemented_Instruction>
	...

80007028 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80007028:	c0 08       	rjmp	80007028 <_handle_Privilege_Violation>
	...

8000702c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000702c:	c0 08       	rjmp	8000702c <_handle_Floating_Point>
	...

80007030 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
80007030:	c0 08       	rjmp	80007030 <_handle_Coprocessor_Absent>
	...

80007034 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80007034:	c0 08       	rjmp	80007034 <_handle_Data_Address_Read>
	...

80007038 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80007038:	c0 08       	rjmp	80007038 <_handle_Data_Address_Write>
	...

8000703c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000703c:	c0 08       	rjmp	8000703c <_handle_DTLB_Protection_Read>
	...

80007040 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80007040:	c0 08       	rjmp	80007040 <_handle_DTLB_Protection_Write>
	...

80007044 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80007044:	c0 08       	rjmp	80007044 <_handle_DTLB_Modified>
	...

80007050 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80007050:	c0 08       	rjmp	80007050 <_handle_ITLB_Miss>
	...

80007060 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80007060:	c0 08       	rjmp	80007060 <_handle_DTLB_Miss_Read>
	...

80007070 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80007070:	c0 08       	rjmp	80007070 <_handle_DTLB_Miss_Write>
	...

80007100 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80007100:	fe cf 27 bc 	sub	pc,pc,10172

80007104 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80007104:	30 0c       	mov	r12,0
80007106:	fe b0 e6 db 	rcall	80003ebc <_get_interrupt_handler>
8000710a:	58 0c       	cp.w	r12,0
8000710c:	f8 0f 17 10 	movne	pc,r12
80007110:	d6 03       	rete

80007112 <_int1>:
80007112:	30 1c       	mov	r12,1
80007114:	fe b0 e6 d4 	rcall	80003ebc <_get_interrupt_handler>
80007118:	58 0c       	cp.w	r12,0
8000711a:	f8 0f 17 10 	movne	pc,r12
8000711e:	d6 03       	rete

80007120 <_int2>:
80007120:	30 2c       	mov	r12,2
80007122:	fe b0 e6 cd 	rcall	80003ebc <_get_interrupt_handler>
80007126:	58 0c       	cp.w	r12,0
80007128:	f8 0f 17 10 	movne	pc,r12
8000712c:	d6 03       	rete

8000712e <_int3>:
8000712e:	30 3c       	mov	r12,3
80007130:	fe b0 e6 c6 	rcall	80003ebc <_get_interrupt_handler>
80007134:	58 0c       	cp.w	r12,0
80007136:	f8 0f 17 10 	movne	pc,r12
8000713a:	d6 03       	rete
8000713c:	d7 03       	nop
8000713e:	d7 03       	nop
80007140:	d7 03       	nop
80007142:	d7 03       	nop
80007144:	d7 03       	nop
80007146:	d7 03       	nop
80007148:	d7 03       	nop
8000714a:	d7 03       	nop
8000714c:	d7 03       	nop
8000714e:	d7 03       	nop
80007150:	d7 03       	nop
80007152:	d7 03       	nop
80007154:	d7 03       	nop
80007156:	d7 03       	nop
80007158:	d7 03       	nop
8000715a:	d7 03       	nop
8000715c:	d7 03       	nop
8000715e:	d7 03       	nop
80007160:	d7 03       	nop
80007162:	d7 03       	nop
80007164:	d7 03       	nop
80007166:	d7 03       	nop
80007168:	d7 03       	nop
8000716a:	d7 03       	nop
8000716c:	d7 03       	nop
8000716e:	d7 03       	nop
80007170:	d7 03       	nop
80007172:	d7 03       	nop
80007174:	d7 03       	nop
80007176:	d7 03       	nop
80007178:	d7 03       	nop
8000717a:	d7 03       	nop
8000717c:	d7 03       	nop
8000717e:	d7 03       	nop
80007180:	d7 03       	nop
80007182:	d7 03       	nop
80007184:	d7 03       	nop
80007186:	d7 03       	nop
80007188:	d7 03       	nop
8000718a:	d7 03       	nop
8000718c:	d7 03       	nop
8000718e:	d7 03       	nop
80007190:	d7 03       	nop
80007192:	d7 03       	nop
80007194:	d7 03       	nop
80007196:	d7 03       	nop
80007198:	d7 03       	nop
8000719a:	d7 03       	nop
8000719c:	d7 03       	nop
8000719e:	d7 03       	nop
800071a0:	d7 03       	nop
800071a2:	d7 03       	nop
800071a4:	d7 03       	nop
800071a6:	d7 03       	nop
800071a8:	d7 03       	nop
800071aa:	d7 03       	nop
800071ac:	d7 03       	nop
800071ae:	d7 03       	nop
800071b0:	d7 03       	nop
800071b2:	d7 03       	nop
800071b4:	d7 03       	nop
800071b6:	d7 03       	nop
800071b8:	d7 03       	nop
800071ba:	d7 03       	nop
800071bc:	d7 03       	nop
800071be:	d7 03       	nop
800071c0:	d7 03       	nop
800071c2:	d7 03       	nop
800071c4:	d7 03       	nop
800071c6:	d7 03       	nop
800071c8:	d7 03       	nop
800071ca:	d7 03       	nop
800071cc:	d7 03       	nop
800071ce:	d7 03       	nop
800071d0:	d7 03       	nop
800071d2:	d7 03       	nop
800071d4:	d7 03       	nop
800071d6:	d7 03       	nop
800071d8:	d7 03       	nop
800071da:	d7 03       	nop
800071dc:	d7 03       	nop
800071de:	d7 03       	nop
800071e0:	d7 03       	nop
800071e2:	d7 03       	nop
800071e4:	d7 03       	nop
800071e6:	d7 03       	nop
800071e8:	d7 03       	nop
800071ea:	d7 03       	nop
800071ec:	d7 03       	nop
800071ee:	d7 03       	nop
800071f0:	d7 03       	nop
800071f2:	d7 03       	nop
800071f4:	d7 03       	nop
800071f6:	d7 03       	nop
800071f8:	d7 03       	nop
800071fa:	d7 03       	nop
800071fc:	d7 03       	nop
800071fe:	d7 03       	nop

Disassembly of section .fini:

80007200 <_fini>:
80007200:	eb cd 40 40 	pushm	r6,lr
80007204:	48 26       	lddpc	r6,8000720c <_fini+0xc>
80007206:	1e 26       	rsub	r6,pc
80007208:	c0 48       	rjmp	80007210 <_fini+0x10>
8000720a:	d7 03       	nop
8000720c:	80 00       	ld.sh	r0,r0[0x0]
8000720e:	71 ea       	ld.w	r10,r8[0x78]
80007210:	fe b0 d7 3c 	rcall	80002088 <__do_global_dtors_aux>
80007214:	e3 cd 80 40 	ldm	sp++,r6,pc
