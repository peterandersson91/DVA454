
Lab63_peter.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         0000a0cc  80002028  80002028  00002428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  8000c200  8000c200  0000c600  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  8000c400  8000c400  0000c800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       000006a0  8000c418  8000c418  0000c818  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  8 .ctors        00000008  00000008  8000cab8  0000d008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .dtors        00000008  00000010  8000cac0  0000d010  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .jcr          00000004  00000018  8000cac8  0000d018  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got          00000000  0000001c  8000cacc  0000d01c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         00000510  0000001c  8000cacc  0000d01c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .bss          000002d0  00000548  00000548  00000000  2**2
                  ALLOC
 14 .heap         0000e7e8  00000818  00000818  00000000  2**0
                  ALLOC
 15 .comment      00000030  00000000  00000000  0000d52c  2**0
                  CONTENTS, READONLY
 16 .debug_aranges 000010f8  00000000  00000000  0000d560  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_pubnames 00001f6f  00000000  00000000  0000e658  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_info   0002952c  00000000  00000000  000105c7  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_abbrev 00005cfb  00000000  00000000  00039af3  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_line   00012871  00000000  00000000  0003f7ee  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_frame  00002e58  00000000  00000000  00052060  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_str    00005699  00000000  00000000  00054eb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_loc    0000a860  00000000  00000000  0005a551  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_macinfo 010d0c0a  00000000  00000000  00064db1  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 26 .debug_ranges 00001158  00000000  00000000  011359bb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	20 28       	sub	r8,2

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

8000200c <_init>:
8000200c:	eb cd 40 40 	pushm	r6,lr
80002010:	48 26       	lddpc	r6,80002018 <_init+0xc>
80002012:	1e 26       	rsub	r6,pc
80002014:	c0 48       	rjmp	8000201c <_init+0x10>
80002016:	d7 03       	nop
80002018:	80 00       	ld.sh	r0,r0[0x0]
8000201a:	1f f6       	ld.ub	r6,pc[0x7]
8000201c:	c5 6c       	rcall	800020c8 <frame_dummy>
8000201e:	e0 a0 50 61 	rcall	8000c0e0 <__do_global_ctors_aux>
80002022:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002028 <_stext>:
80002028:	30 07       	mov	r7,0
8000202a:	e0 7a 00 00 	mov	r10,65536
8000202e:	5b fa       	cp.w	r10,-1
80002030:	f4 0d 17 10 	movne	sp,r10
80002034:	49 4b       	lddpc	r11,80002084 <_stext+0x5c>
80002036:	30 8c       	mov	r12,8
80002038:	18 3b       	cp.w	r11,r12
8000203a:	c0 70       	breq	80002048 <_stext+0x20>
8000203c:	e0 6a 05 30 	mov	r10,1328
80002040:	b7 09       	ld.d	r8,r11++
80002042:	b9 28       	st.d	r12++,r8
80002044:	14 3c       	cp.w	r12,r10
80002046:	cf d5       	brlt	80002040 <_stext+0x18>
80002048:	e0 6a 08 18 	mov	r10,2072
8000204c:	e0 6c 05 30 	mov	r12,1328
80002050:	30 08       	mov	r8,0
80002052:	30 09       	mov	r9,0
80002054:	b9 28       	st.d	r12++,r8
80002056:	14 3c       	cp.w	r12,r10
80002058:	cf e5       	brlt	80002054 <_stext+0x2c>
8000205a:	e0 a0 16 af 	rcall	80004db8 <_init_startup>
8000205e:	48 bc       	lddpc	r12,80002088 <_stext+0x60>
80002060:	e0 a0 24 18 	rcall	80006890 <atexit>
80002064:	cd 4f       	rcall	8000200c <_init>
80002066:	1a 9c       	mov	r12,sp
80002068:	30 0b       	mov	r11,0
8000206a:	e0 a0 28 83 	rcall	80007170 <_init_argv>
8000206e:	5b fc       	cp.w	r12,-1
80002070:	f9 bc 00 00 	moveq	r12,0
80002074:	f9 ba 00 00 	moveq	r10,0
80002078:	14 1d       	sub	sp,r10
8000207a:	e0 a0 0f a3 	rcall	80003fc0 <main>
8000207e:	e0 a0 24 11 	rcall	800068a0 <exit>
80002082:	d7 03       	nop
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	ca b8       	rjmp	800021dc <dip204_init+0xd4>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	c4 00       	breq	8000210a <dip204_init+0x2>

8000208c <__do_global_dtors_aux>:
8000208c:	d4 21       	pushm	r4-r7,lr
8000208e:	e0 68 05 48 	mov	r8,1352
80002092:	11 89       	ld.ub	r9,r8[0x0]
80002094:	30 08       	mov	r8,0
80002096:	f0 09 18 00 	cp.b	r9,r8
8000209a:	c1 61       	brne	800020c6 <__do_global_dtors_aux+0x3a>
8000209c:	31 08       	mov	r8,16
8000209e:	31 46       	mov	r6,20
800020a0:	10 95       	mov	r5,r8
800020a2:	10 16       	sub	r6,r8
800020a4:	e0 67 05 4c 	mov	r7,1356
800020a8:	a3 46       	asr	r6,0x2
800020aa:	20 16       	sub	r6,1
800020ac:	c0 68       	rjmp	800020b8 <__do_global_dtors_aux+0x2c>
800020ae:	2f f8       	sub	r8,-1
800020b0:	8f 08       	st.w	r7[0x0],r8
800020b2:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020b6:	5d 18       	icall	r8
800020b8:	6e 08       	ld.w	r8,r7[0x0]
800020ba:	0c 38       	cp.w	r8,r6
800020bc:	cf 93       	brcs	800020ae <__do_global_dtors_aux+0x22>
800020be:	30 19       	mov	r9,1
800020c0:	e0 68 05 48 	mov	r8,1352
800020c4:	b0 89       	st.b	r8[0x0],r9
800020c6:	d8 22       	popm	r4-r7,pc

800020c8 <frame_dummy>:
800020c8:	d4 01       	pushm	lr
800020ca:	31 8c       	mov	r12,24
800020cc:	78 08       	ld.w	r8,r12[0x0]
800020ce:	58 08       	cp.w	r8,0
800020d0:	c0 50       	breq	800020da <frame_dummy+0x12>
800020d2:	48 38       	lddpc	r8,800020dc <frame_dummy+0x14>
800020d4:	58 08       	cp.w	r8,0
800020d6:	c0 20       	breq	800020da <frame_dummy+0x12>
800020d8:	5d 18       	icall	r8
800020da:	d8 02       	popm	pc
800020dc:	00 00       	add	r0,r0
	...

800020e0 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern bool sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
800020e0:	eb cd 40 80 	pushm	r7,lr
800020e4:	1a 97       	mov	r7,sp
	}
#endif

	switch (CONFIG_SYSCLK_SOURCE) {
	case SYSCLK_SRC_RCSYS:
		return OSC_SLOW_NOMINAL_HZ;
800020e6:	e0 78 c2 00 	mov	r8,115200

	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
800020ea:	10 9c       	mov	r12,r8
800020ec:	e3 cd 80 80 	ldm	sp++,r7,pc

800020f0 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
800020f0:	eb cd 40 80 	pushm	r7,lr
800020f4:	1a 97       	mov	r7,sp
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_CPU_DIV;
800020f6:	f0 1f 00 04 	mcall	80002104 <sysclk_get_cpu_hz+0x14>
800020fa:	18 98       	mov	r8,r12
}
800020fc:	10 9c       	mov	r12,r8
800020fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002102:	00 00       	add	r0,r0
80002104:	80 00       	ld.sh	r0,r0[0x0]
80002106:	20 e0       	sub	r0,14

80002108 <dip204_init>:


/****************************** global functions *****************************/

void dip204_init(backlight_options option, bool backlight_on)
{
80002108:	eb cd 40 8f 	pushm	r0-r3,r7,lr
8000210c:	1a 97       	mov	r7,sp
8000210e:	fa cd 01 ac 	sub	sp,sp,428
80002112:	ef 4c fe b8 	st.w	r7[-328],r12
80002116:	16 98       	mov	r8,r11
80002118:	ef 68 fe b4 	st.b	r7[-332],r8
  pwm_opt_t pwm_opt;  // pwm option config

  if (option == backlight_PWM)
8000211c:	ee f8 fe b8 	ld.w	r8,r7[-328]
80002120:	58 18       	cp.w	r8,1
80002122:	c6 41       	brne	800021ea <dip204_init+0xe2>
  {
    channel_id = DIP204_PWM_CHANNEL;
80002124:	fe f9 0a 84 	ld.w	r9,pc[2692]
80002128:	30 68       	mov	r8,6
8000212a:	93 08       	st.w	r9[0x0],r8
    gpio_enable_module_pin(DIP204_PWM_PIN, DIP204_PWM_FUNCTION);
8000212c:	30 2b       	mov	r11,2
8000212e:	33 2c       	mov	r12,50
80002130:	f0 1f 02 9f 	mcall	80002bac <dip204_init+0xaa4>

    // PWM controller configuration
    pwm_opt.diva=0;
80002134:	30 08       	mov	r8,0
80002136:	ef 48 ff 14 	st.w	r7[-236],r8
    pwm_opt.divb=0;
8000213a:	30 08       	mov	r8,0
8000213c:	ef 48 ff 10 	st.w	r7[-240],r8
    pwm_opt.prea=0;
80002140:	30 08       	mov	r8,0
80002142:	ef 48 ff 1c 	st.w	r7[-228],r8
    pwm_opt.preb=0;
80002146:	30 08       	mov	r8,0
80002148:	ef 48 ff 18 	st.w	r7[-232],r8

    pwm_init(&pwm_opt);
8000214c:	ee c8 00 f0 	sub	r8,r7,240
80002150:	10 9c       	mov	r12,r8
80002152:	f0 1f 02 98 	mcall	80002bb0 <dip204_init+0xaa8>
    pwm_duty = (backlight_on) ? DIP204_PERIOD_MAX - 1 : 1;
80002156:	ef 39 fe b4 	ld.ub	r9,r7[-332]
8000215a:	30 08       	mov	r8,0
8000215c:	f0 09 18 00 	cp.b	r9,r8
80002160:	c0 30       	breq	80002166 <dip204_init+0x5e>
80002162:	33 18       	mov	r8,49
80002164:	c0 28       	rjmp	80002168 <dip204_init+0x60>
80002166:	30 18       	mov	r8,1
80002168:	fe f9 0a 4c 	ld.w	r9,pc[2636]
8000216c:	b2 08       	st.h	r9[0x0],r8
    pwm_channel.CMR.calg = PWM_MODE_LEFT_ALIGNED;   // channel mode
8000216e:	fe fa 0a 4a 	ld.w	r10,pc[2634]
80002172:	74 08       	ld.w	r8,r10[0x0]
80002174:	30 09       	mov	r9,0
80002176:	f1 d9 d1 01 	bfins	r8,r9,0x8,0x1
8000217a:	95 08       	st.w	r10[0x0],r8
    pwm_channel.CMR.cpol = PWM_POLARITY_LOW;   // channel polarity
8000217c:	fe fa 0a 3c 	ld.w	r10,pc[2620]
80002180:	74 08       	ld.w	r8,r10[0x0]
80002182:	30 09       	mov	r9,0
80002184:	f1 d9 d1 21 	bfins	r8,r9,0x9,0x1
80002188:	95 08       	st.w	r10[0x0],r8
    pwm_channel.CMR.cpd = PWM_UPDATE_PERIOD;   // not used the first time
8000218a:	fe fa 0a 2e 	ld.w	r10,pc[2606]
8000218e:	74 08       	ld.w	r8,r10[0x0]
80002190:	30 19       	mov	r9,1
80002192:	f1 d9 d1 41 	bfins	r8,r9,0xa,0x1
80002196:	95 08       	st.w	r10[0x0],r8
    pwm_channel.CMR.cpre = AVR32_PWM_CPRE_MCK_DIV_256;   // channel prescaler
80002198:	fe fa 0a 20 	ld.w	r10,pc[2592]
8000219c:	74 08       	ld.w	r8,r10[0x0]
8000219e:	30 89       	mov	r9,8
800021a0:	f1 d9 d0 04 	bfins	r8,r9,0x0,0x4
800021a4:	95 08       	st.w	r10[0x0],r8
    pwm_channel.cdty = pwm_duty;  // channel duty cycle, should be < CPRD
800021a6:	fe f8 0a 0e 	ld.w	r8,pc[2574]
800021aa:	90 08       	ld.sh	r8,r8[0x0]
800021ac:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800021b0:	fe f8 0a 08 	ld.w	r8,pc[2568]
800021b4:	91 19       	st.w	r8[0x4],r9
    pwm_channel.cprd = DIP204_PERIOD_MAX;  // channel period
800021b6:	fe f9 0a 02 	ld.w	r9,pc[2562]
800021ba:	33 28       	mov	r8,50
800021bc:	93 28       	st.w	r9[0x8],r8
    pwm_channel.cupd = 0;  // channel update is not used here.
800021be:	fe f9 09 fa 	ld.w	r9,pc[2554]
800021c2:	30 08       	mov	r8,0
800021c4:	93 48       	st.w	r9[0x10],r8

    pwm_channel_init(channel_id, &pwm_channel);
800021c6:	fe f8 09 e2 	ld.w	r8,pc[2530]
800021ca:	70 08       	ld.w	r8,r8[0x0]
800021cc:	fe fb 09 ec 	ld.w	r11,pc[2540]
800021d0:	10 9c       	mov	r12,r8
800021d2:	f0 1f 02 7b 	mcall	80002bbc <dip204_init+0xab4>
    // start PWM
    pwm_start_channels(1 << channel_id);
800021d6:	fe f8 09 d2 	ld.w	r8,pc[2514]
800021da:	70 09       	ld.w	r9,r8[0x0]
800021dc:	30 18       	mov	r8,1
800021de:	f0 09 09 48 	lsl	r8,r8,r9
800021e2:	10 9c       	mov	r12,r8
800021e4:	f0 1f 02 77 	mcall	80002bc0 <dip204_init+0xab8>
800021e8:	c0 e8       	rjmp	80002204 <dip204_init+0xfc>
  }
  else
  {
    if (backlight_on)
800021ea:	ef 39 fe b4 	ld.ub	r9,r7[-332]
800021ee:	30 08       	mov	r8,0
800021f0:	f0 09 18 00 	cp.b	r9,r8
800021f4:	c0 50       	breq	800021fe <dip204_init+0xf6>
    {
      gpio_clr_gpio_pin(DIP204_BACKLIGHT_PIN);
800021f6:	33 2c       	mov	r12,50
800021f8:	f0 1f 02 73 	mcall	80002bc4 <dip204_init+0xabc>
800021fc:	c0 48       	rjmp	80002204 <dip204_init+0xfc>
    }
    else
    {
      gpio_set_gpio_pin(DIP204_BACKLIGHT_PIN);
800021fe:	33 2c       	mov	r12,50
80002200:	f0 1f 02 72 	mcall	80002bc8 <dip204_init+0xac0>
    }
  }
  // delay for power on
  delay_ms(20);
80002204:	f0 1f 02 72 	mcall	80002bcc <dip204_init+0xac4>
80002208:	18 99       	mov	r9,r12
8000220a:	31 48       	mov	r8,20
8000220c:	ef 48 ff 24 	st.w	r7[-220],r8
80002210:	ef 49 ff 20 	st.w	r7[-224],r9
80002214:	ee f8 ff 24 	ld.w	r8,r7[-220]
80002218:	ef 48 ff 2c 	st.w	r7[-212],r8
8000221c:	ee f8 ff 20 	ld.w	r8,r7[-224]
80002220:	ef 48 ff 28 	st.w	r7[-216],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002224:	ee f0 ff 2c 	ld.w	r0,r7[-212]
80002228:	30 01       	mov	r1,0
8000222a:	ee f2 ff 28 	ld.w	r2,r7[-216]
8000222e:	30 03       	mov	r3,0
80002230:	e2 02 02 49 	mul	r9,r1,r2
80002234:	e6 00 02 48 	mul	r8,r3,r0
80002238:	10 09       	add	r9,r8
8000223a:	e0 02 06 4a 	mulu.d	r10,r0,r2
8000223e:	16 09       	add	r9,r11
80002240:	12 9b       	mov	r11,r9
80002242:	e0 68 03 e7 	mov	r8,999
80002246:	30 09       	mov	r9,0
80002248:	10 0a       	add	r10,r8
8000224a:	f6 09 00 4b 	adc	r11,r11,r9
8000224e:	e0 68 03 e8 	mov	r8,1000
80002252:	30 09       	mov	r9,0
80002254:	f0 1f 02 5f 	mcall	80002bd0 <dip204_init+0xac8>
80002258:	14 98       	mov	r8,r10
8000225a:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000225c:	ef 48 ff 34 	st.w	r7[-204],r8
80002260:	ee c8 01 44 	sub	r8,r7,324
80002264:	ef 48 ff 30 	st.w	r7[-208],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002268:	e1 b8 00 42 	mfsr	r8,0x108
8000226c:	10 99       	mov	r9,r8
8000226e:	ee f8 ff 30 	ld.w	r8,r7[-208]
80002272:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002274:	ee f8 ff 30 	ld.w	r8,r7[-208]
80002278:	70 09       	ld.w	r9,r8[0x0]
8000227a:	ee f8 ff 34 	ld.w	r8,r7[-204]
8000227e:	10 09       	add	r9,r8
80002280:	ee f8 ff 30 	ld.w	r8,r7[-208]
80002284:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002286:	ee f9 ff 30 	ld.w	r9,r7[-208]
8000228a:	30 08       	mov	r8,0
8000228c:	f3 68 00 08 	st.b	r9[8],r8
80002290:	ee c8 01 44 	sub	r8,r7,324
80002294:	ef 48 ff 38 	st.w	r7[-200],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002298:	e1 b8 00 42 	mfsr	r8,0x108
8000229c:	ef 48 ff 3c 	st.w	r7[-196],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800022a0:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022a4:	f1 39 00 08 	ld.ub	r9,r8[8]
800022a8:	30 28       	mov	r8,2
800022aa:	f0 09 18 00 	cp.b	r9,r8
800022ae:	c0 31       	brne	800022b4 <dip204_init+0x1ac>
    return false;
800022b0:	30 08       	mov	r8,0
800022b2:	c4 38       	rjmp	80002338 <dip204_init+0x230>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800022b4:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022b8:	f1 39 00 08 	ld.ub	r9,r8[8]
800022bc:	30 18       	mov	r8,1
800022be:	f0 09 18 00 	cp.b	r9,r8
800022c2:	c0 31       	brne	800022c8 <dip204_init+0x1c0>
    return true;
800022c4:	30 18       	mov	r8,1
800022c6:	c3 98       	rjmp	80002338 <dip204_init+0x230>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800022c8:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022cc:	70 09       	ld.w	r9,r8[0x0]
800022ce:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022d2:	70 18       	ld.w	r8,r8[0x4]
800022d4:	10 39       	cp.w	r9,r8
800022d6:	e0 88 00 1a 	brls	8000230a <dip204_init+0x202>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800022da:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022de:	70 09       	ld.w	r9,r8[0x0]
800022e0:	ee f8 ff 3c 	ld.w	r8,r7[-196]
800022e4:	12 38       	cp.w	r8,r9
800022e6:	c1 02       	brcc	80002306 <dip204_init+0x1fe>
800022e8:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022ec:	70 19       	ld.w	r9,r8[0x4]
800022ee:	ee f8 ff 3c 	ld.w	r8,r7[-196]
800022f2:	12 38       	cp.w	r8,r9
800022f4:	e0 88 00 09 	brls	80002306 <dip204_init+0x1fe>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800022f8:	ee f9 ff 38 	ld.w	r9,r7[-200]
800022fc:	30 18       	mov	r8,1
800022fe:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002302:	30 18       	mov	r8,1
80002304:	c1 a8       	rjmp	80002338 <dip204_init+0x230>
    }
    return false;
80002306:	30 08       	mov	r8,0
80002308:	c1 88       	rjmp	80002338 <dip204_init+0x230>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000230a:	ee f8 ff 38 	ld.w	r8,r7[-200]
8000230e:	70 09       	ld.w	r9,r8[0x0]
80002310:	ee f8 ff 3c 	ld.w	r8,r7[-196]
80002314:	12 38       	cp.w	r8,r9
80002316:	c0 93       	brcs	80002328 <dip204_init+0x220>
80002318:	ee f8 ff 38 	ld.w	r8,r7[-200]
8000231c:	70 19       	ld.w	r9,r8[0x4]
8000231e:	ee f8 ff 3c 	ld.w	r8,r7[-196]
80002322:	12 38       	cp.w	r8,r9
80002324:	e0 88 00 09 	brls	80002336 <dip204_init+0x22e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002328:	ee f9 ff 38 	ld.w	r9,r7[-200]
8000232c:	30 18       	mov	r8,1
8000232e:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002332:	30 18       	mov	r8,1
80002334:	c0 28       	rjmp	80002338 <dip204_init+0x230>
    }
    return false;
80002336:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002338:	58 08       	cp.w	r8,0
8000233a:	ca b0       	breq	80002290 <dip204_init+0x188>
  // select the LCD chip
  dip204_select();
8000233c:	f0 1f 02 26 	mcall	80002bd4 <dip204_init+0xacc>
  // Send Command Start Byte
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002340:	e0 6c 00 f8 	mov	r12,248
80002344:	f0 1f 02 25 	mcall	80002bd8 <dip204_init+0xad0>
  // Send "extended Function Set" Command  (RE=1)
  dip204_write_byte(0x34);
80002348:	33 4c       	mov	r12,52
8000234a:	f0 1f 02 24 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
8000234e:	f0 1f 02 20 	mcall	80002bcc <dip204_init+0xac4>
80002352:	18 99       	mov	r9,r12
80002354:	30 18       	mov	r8,1
80002356:	ef 48 ff 44 	st.w	r7[-188],r8
8000235a:	ef 49 ff 40 	st.w	r7[-192],r9
8000235e:	ee f8 ff 44 	ld.w	r8,r7[-188]
80002362:	ef 48 ff 4c 	st.w	r7[-180],r8
80002366:	ee f8 ff 40 	ld.w	r8,r7[-192]
8000236a:	ef 48 ff 48 	st.w	r7[-184],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000236e:	ee fc ff 4c 	ld.w	r12,r7[-180]
80002372:	ef 4c fe 60 	st.w	r7[-416],r12
80002376:	30 0b       	mov	r11,0
80002378:	ef 4b fe 5c 	st.w	r7[-420],r11
8000237c:	ee fa ff 48 	ld.w	r10,r7[-184]
80002380:	ef 4a fe 58 	st.w	r7[-424],r10
80002384:	30 09       	mov	r9,0
80002386:	ef 49 fe 54 	st.w	r7[-428],r9
8000238a:	ee f9 fe 5c 	ld.w	r9,r7[-420]
8000238e:	ee f8 fe 58 	ld.w	r8,r7[-424]
80002392:	b1 39       	mul	r9,r8
80002394:	ee f8 fe 54 	ld.w	r8,r7[-428]
80002398:	ee fc fe 60 	ld.w	r12,r7[-416]
8000239c:	b9 38       	mul	r8,r12
8000239e:	10 09       	add	r9,r8
800023a0:	ee f8 fe 60 	ld.w	r8,r7[-416]
800023a4:	ee fc fe 58 	ld.w	r12,r7[-424]
800023a8:	f0 0c 06 4a 	mulu.d	r10,r8,r12
800023ac:	16 09       	add	r9,r11
800023ae:	12 9b       	mov	r11,r9
800023b0:	e0 68 03 e7 	mov	r8,999
800023b4:	30 09       	mov	r9,0
800023b6:	10 0a       	add	r10,r8
800023b8:	f6 09 00 4b 	adc	r11,r11,r9
800023bc:	e0 68 03 e8 	mov	r8,1000
800023c0:	30 09       	mov	r9,0
800023c2:	f0 1f 02 04 	mcall	80002bd0 <dip204_init+0xac8>
800023c6:	14 98       	mov	r8,r10
800023c8:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
800023ca:	ef 48 ff 54 	st.w	r7[-172],r8
800023ce:	ee c8 01 38 	sub	r8,r7,312
800023d2:	ef 48 ff 50 	st.w	r7[-176],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800023d6:	e1 b8 00 42 	mfsr	r8,0x108
800023da:	10 99       	mov	r9,r8
800023dc:	ee f8 ff 50 	ld.w	r8,r7[-176]
800023e0:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800023e2:	ee f8 ff 50 	ld.w	r8,r7[-176]
800023e6:	70 09       	ld.w	r9,r8[0x0]
800023e8:	ee f8 ff 54 	ld.w	r8,r7[-172]
800023ec:	10 09       	add	r9,r8
800023ee:	ee f8 ff 50 	ld.w	r8,r7[-176]
800023f2:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800023f4:	ee f9 ff 50 	ld.w	r9,r7[-176]
800023f8:	30 08       	mov	r8,0
800023fa:	f3 68 00 08 	st.b	r9[8],r8
800023fe:	ee c8 01 38 	sub	r8,r7,312
80002402:	ef 48 ff 58 	st.w	r7[-168],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002406:	e1 b8 00 42 	mfsr	r8,0x108
8000240a:	ef 48 ff 5c 	st.w	r7[-164],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000240e:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002412:	f1 39 00 08 	ld.ub	r9,r8[8]
80002416:	30 28       	mov	r8,2
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c0 31       	brne	80002422 <dip204_init+0x31a>
    return false;
8000241e:	30 08       	mov	r8,0
80002420:	c4 38       	rjmp	800024a6 <dip204_init+0x39e>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002422:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002426:	f1 39 00 08 	ld.ub	r9,r8[8]
8000242a:	30 18       	mov	r8,1
8000242c:	f0 09 18 00 	cp.b	r9,r8
80002430:	c0 31       	brne	80002436 <dip204_init+0x32e>
    return true;
80002432:	30 18       	mov	r8,1
80002434:	c3 98       	rjmp	800024a6 <dip204_init+0x39e>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002436:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000243a:	70 09       	ld.w	r9,r8[0x0]
8000243c:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002440:	70 18       	ld.w	r8,r8[0x4]
80002442:	10 39       	cp.w	r9,r8
80002444:	e0 88 00 1a 	brls	80002478 <dip204_init+0x370>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002448:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000244c:	70 09       	ld.w	r9,r8[0x0]
8000244e:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002452:	12 38       	cp.w	r8,r9
80002454:	c1 02       	brcc	80002474 <dip204_init+0x36c>
80002456:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000245a:	70 19       	ld.w	r9,r8[0x4]
8000245c:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002460:	12 38       	cp.w	r8,r9
80002462:	e0 88 00 09 	brls	80002474 <dip204_init+0x36c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002466:	ee f9 ff 58 	ld.w	r9,r7[-168]
8000246a:	30 18       	mov	r8,1
8000246c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002470:	30 18       	mov	r8,1
80002472:	c1 a8       	rjmp	800024a6 <dip204_init+0x39e>
    }
    return false;
80002474:	30 08       	mov	r8,0
80002476:	c1 88       	rjmp	800024a6 <dip204_init+0x39e>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002478:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000247c:	70 09       	ld.w	r9,r8[0x0]
8000247e:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002482:	12 38       	cp.w	r8,r9
80002484:	c0 93       	brcs	80002496 <dip204_init+0x38e>
80002486:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000248a:	70 19       	ld.w	r9,r8[0x4]
8000248c:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002490:	12 38       	cp.w	r8,r9
80002492:	e0 88 00 09 	brls	800024a4 <dip204_init+0x39c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002496:	ee f9 ff 58 	ld.w	r9,r7[-168]
8000249a:	30 18       	mov	r8,1
8000249c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800024a0:	30 18       	mov	r8,1
800024a2:	c0 28       	rjmp	800024a6 <dip204_init+0x39e>
    }
    return false;
800024a4:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800024a6:	58 08       	cp.w	r8,0
800024a8:	ca b0       	breq	800023fe <dip204_init+0x2f6>
  // Send "Enter 4-Line Mode" Command
  dip204_write_byte(0x09);
800024aa:	30 9c       	mov	r12,9
800024ac:	f0 1f 01 cb 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
800024b0:	f0 1f 01 c7 	mcall	80002bcc <dip204_init+0xac4>
800024b4:	18 99       	mov	r9,r12
800024b6:	30 18       	mov	r8,1
800024b8:	ef 48 ff 64 	st.w	r7[-156],r8
800024bc:	ef 49 ff 60 	st.w	r7[-160],r9
800024c0:	ee f8 ff 64 	ld.w	r8,r7[-156]
800024c4:	ef 48 ff 6c 	st.w	r7[-148],r8
800024c8:	ee f8 ff 60 	ld.w	r8,r7[-160]
800024cc:	ef 48 ff 68 	st.w	r7[-152],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800024d0:	ee fb ff 6c 	ld.w	r11,r7[-148]
800024d4:	ef 4b fe 70 	st.w	r7[-400],r11
800024d8:	30 0a       	mov	r10,0
800024da:	ef 4a fe 6c 	st.w	r7[-404],r10
800024de:	ee f9 ff 68 	ld.w	r9,r7[-152]
800024e2:	ef 49 fe 68 	st.w	r7[-408],r9
800024e6:	30 08       	mov	r8,0
800024e8:	ef 48 fe 64 	st.w	r7[-412],r8
800024ec:	ee f9 fe 6c 	ld.w	r9,r7[-404]
800024f0:	ee fc fe 68 	ld.w	r12,r7[-408]
800024f4:	b9 39       	mul	r9,r12
800024f6:	ee f8 fe 64 	ld.w	r8,r7[-412]
800024fa:	ee fb fe 70 	ld.w	r11,r7[-400]
800024fe:	b7 38       	mul	r8,r11
80002500:	10 09       	add	r9,r8
80002502:	ee f8 fe 70 	ld.w	r8,r7[-400]
80002506:	ee fc fe 68 	ld.w	r12,r7[-408]
8000250a:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000250e:	16 09       	add	r9,r11
80002510:	12 9b       	mov	r11,r9
80002512:	e0 68 03 e7 	mov	r8,999
80002516:	30 09       	mov	r9,0
80002518:	10 0a       	add	r10,r8
8000251a:	f6 09 00 4b 	adc	r11,r11,r9
8000251e:	e0 68 03 e8 	mov	r8,1000
80002522:	30 09       	mov	r9,0
80002524:	f0 1f 01 ab 	mcall	80002bd0 <dip204_init+0xac8>
80002528:	14 98       	mov	r8,r10
8000252a:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000252c:	ef 48 ff 74 	st.w	r7[-140],r8
80002530:	ee c8 01 2c 	sub	r8,r7,300
80002534:	ef 48 ff 70 	st.w	r7[-144],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002538:	e1 b8 00 42 	mfsr	r8,0x108
8000253c:	10 99       	mov	r9,r8
8000253e:	ee f8 ff 70 	ld.w	r8,r7[-144]
80002542:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002544:	ee f8 ff 70 	ld.w	r8,r7[-144]
80002548:	70 09       	ld.w	r9,r8[0x0]
8000254a:	ee f8 ff 74 	ld.w	r8,r7[-140]
8000254e:	10 09       	add	r9,r8
80002550:	ee f8 ff 70 	ld.w	r8,r7[-144]
80002554:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002556:	ee f9 ff 70 	ld.w	r9,r7[-144]
8000255a:	30 08       	mov	r8,0
8000255c:	f3 68 00 08 	st.b	r9[8],r8
80002560:	ee c8 01 2c 	sub	r8,r7,300
80002564:	ef 48 ff 78 	st.w	r7[-136],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002568:	e1 b8 00 42 	mfsr	r8,0x108
8000256c:	ef 48 ff 7c 	st.w	r7[-132],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002570:	ee f8 ff 78 	ld.w	r8,r7[-136]
80002574:	f1 39 00 08 	ld.ub	r9,r8[8]
80002578:	30 28       	mov	r8,2
8000257a:	f0 09 18 00 	cp.b	r9,r8
8000257e:	c0 31       	brne	80002584 <dip204_init+0x47c>
    return false;
80002580:	30 08       	mov	r8,0
80002582:	c4 38       	rjmp	80002608 <dip204_init+0x500>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002584:	ee f8 ff 78 	ld.w	r8,r7[-136]
80002588:	f1 39 00 08 	ld.ub	r9,r8[8]
8000258c:	30 18       	mov	r8,1
8000258e:	f0 09 18 00 	cp.b	r9,r8
80002592:	c0 31       	brne	80002598 <dip204_init+0x490>
    return true;
80002594:	30 18       	mov	r8,1
80002596:	c3 98       	rjmp	80002608 <dip204_init+0x500>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002598:	ee f8 ff 78 	ld.w	r8,r7[-136]
8000259c:	70 09       	ld.w	r9,r8[0x0]
8000259e:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025a2:	70 18       	ld.w	r8,r8[0x4]
800025a4:	10 39       	cp.w	r9,r8
800025a6:	e0 88 00 1a 	brls	800025da <dip204_init+0x4d2>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800025aa:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025ae:	70 09       	ld.w	r9,r8[0x0]
800025b0:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025b4:	12 38       	cp.w	r8,r9
800025b6:	c1 02       	brcc	800025d6 <dip204_init+0x4ce>
800025b8:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025bc:	70 19       	ld.w	r9,r8[0x4]
800025be:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025c2:	12 38       	cp.w	r8,r9
800025c4:	e0 88 00 09 	brls	800025d6 <dip204_init+0x4ce>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800025c8:	ee f9 ff 78 	ld.w	r9,r7[-136]
800025cc:	30 18       	mov	r8,1
800025ce:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800025d2:	30 18       	mov	r8,1
800025d4:	c1 a8       	rjmp	80002608 <dip204_init+0x500>
    }
    return false;
800025d6:	30 08       	mov	r8,0
800025d8:	c1 88       	rjmp	80002608 <dip204_init+0x500>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800025da:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025de:	70 09       	ld.w	r9,r8[0x0]
800025e0:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025e4:	12 38       	cp.w	r8,r9
800025e6:	c0 93       	brcs	800025f8 <dip204_init+0x4f0>
800025e8:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025ec:	70 19       	ld.w	r9,r8[0x4]
800025ee:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025f2:	12 38       	cp.w	r8,r9
800025f4:	e0 88 00 09 	brls	80002606 <dip204_init+0x4fe>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800025f8:	ee f9 ff 78 	ld.w	r9,r7[-136]
800025fc:	30 18       	mov	r8,1
800025fe:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002602:	30 18       	mov	r8,1
80002604:	c0 28       	rjmp	80002608 <dip204_init+0x500>
    }
    return false;
80002606:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002608:	58 08       	cp.w	r8,0
8000260a:	ca b0       	breq	80002560 <dip204_init+0x458>
  // Send "Function Set" Command (RE=0)
  dip204_write_byte(0x30);
8000260c:	33 0c       	mov	r12,48
8000260e:	f0 1f 01 73 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
80002612:	f0 1f 01 6f 	mcall	80002bcc <dip204_init+0xac4>
80002616:	18 99       	mov	r9,r12
80002618:	30 18       	mov	r8,1
8000261a:	ef 48 ff 84 	st.w	r7[-124],r8
8000261e:	ef 49 ff 80 	st.w	r7[-128],r9
80002622:	ee f8 ff 84 	ld.w	r8,r7[-124]
80002626:	ef 48 ff 8c 	st.w	r7[-116],r8
8000262a:	ee f8 ff 80 	ld.w	r8,r7[-128]
8000262e:	ef 48 ff 88 	st.w	r7[-120],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002632:	ee fb ff 8c 	ld.w	r11,r7[-116]
80002636:	ef 4b fe 80 	st.w	r7[-384],r11
8000263a:	30 0a       	mov	r10,0
8000263c:	ef 4a fe 7c 	st.w	r7[-388],r10
80002640:	ee f9 ff 88 	ld.w	r9,r7[-120]
80002644:	ef 49 fe 78 	st.w	r7[-392],r9
80002648:	30 08       	mov	r8,0
8000264a:	ef 48 fe 74 	st.w	r7[-396],r8
8000264e:	ee f9 fe 7c 	ld.w	r9,r7[-388]
80002652:	ee fc fe 78 	ld.w	r12,r7[-392]
80002656:	b9 39       	mul	r9,r12
80002658:	ee f8 fe 74 	ld.w	r8,r7[-396]
8000265c:	ee fb fe 80 	ld.w	r11,r7[-384]
80002660:	b7 38       	mul	r8,r11
80002662:	10 09       	add	r9,r8
80002664:	ee f8 fe 80 	ld.w	r8,r7[-384]
80002668:	ee fc fe 78 	ld.w	r12,r7[-392]
8000266c:	f0 0c 06 4a 	mulu.d	r10,r8,r12
80002670:	16 09       	add	r9,r11
80002672:	12 9b       	mov	r11,r9
80002674:	e0 68 03 e7 	mov	r8,999
80002678:	30 09       	mov	r9,0
8000267a:	10 0a       	add	r10,r8
8000267c:	f6 09 00 4b 	adc	r11,r11,r9
80002680:	e0 68 03 e8 	mov	r8,1000
80002684:	30 09       	mov	r9,0
80002686:	f0 1f 01 53 	mcall	80002bd0 <dip204_init+0xac8>
8000268a:	14 98       	mov	r8,r10
8000268c:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000268e:	ef 48 ff 94 	st.w	r7[-108],r8
80002692:	ee c8 01 20 	sub	r8,r7,288
80002696:	ef 48 ff 90 	st.w	r7[-112],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000269a:	e1 b8 00 42 	mfsr	r8,0x108
8000269e:	10 99       	mov	r9,r8
800026a0:	ee f8 ff 90 	ld.w	r8,r7[-112]
800026a4:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800026a6:	ee f8 ff 90 	ld.w	r8,r7[-112]
800026aa:	70 09       	ld.w	r9,r8[0x0]
800026ac:	ee f8 ff 94 	ld.w	r8,r7[-108]
800026b0:	10 09       	add	r9,r8
800026b2:	ee f8 ff 90 	ld.w	r8,r7[-112]
800026b6:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800026b8:	ee f9 ff 90 	ld.w	r9,r7[-112]
800026bc:	30 08       	mov	r8,0
800026be:	f3 68 00 08 	st.b	r9[8],r8
800026c2:	ee c8 01 20 	sub	r8,r7,288
800026c6:	ef 48 ff 98 	st.w	r7[-104],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800026ca:	e1 b8 00 42 	mfsr	r8,0x108
800026ce:	ef 48 ff 9c 	st.w	r7[-100],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800026d2:	ee f8 ff 98 	ld.w	r8,r7[-104]
800026d6:	f1 39 00 08 	ld.ub	r9,r8[8]
800026da:	30 28       	mov	r8,2
800026dc:	f0 09 18 00 	cp.b	r9,r8
800026e0:	c0 31       	brne	800026e6 <dip204_init+0x5de>
    return false;
800026e2:	30 08       	mov	r8,0
800026e4:	c4 38       	rjmp	8000276a <dip204_init+0x662>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800026e6:	ee f8 ff 98 	ld.w	r8,r7[-104]
800026ea:	f1 39 00 08 	ld.ub	r9,r8[8]
800026ee:	30 18       	mov	r8,1
800026f0:	f0 09 18 00 	cp.b	r9,r8
800026f4:	c0 31       	brne	800026fa <dip204_init+0x5f2>
    return true;
800026f6:	30 18       	mov	r8,1
800026f8:	c3 98       	rjmp	8000276a <dip204_init+0x662>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800026fa:	ee f8 ff 98 	ld.w	r8,r7[-104]
800026fe:	70 09       	ld.w	r9,r8[0x0]
80002700:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002704:	70 18       	ld.w	r8,r8[0x4]
80002706:	10 39       	cp.w	r9,r8
80002708:	e0 88 00 1a 	brls	8000273c <dip204_init+0x634>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000270c:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002710:	70 08       	ld.w	r8,r8[0x0]
80002712:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002716:	10 39       	cp.w	r9,r8
80002718:	c1 02       	brcc	80002738 <dip204_init+0x630>
8000271a:	ee f8 ff 98 	ld.w	r8,r7[-104]
8000271e:	70 18       	ld.w	r8,r8[0x4]
80002720:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002724:	10 39       	cp.w	r9,r8
80002726:	e0 88 00 09 	brls	80002738 <dip204_init+0x630>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000272a:	ee f9 ff 98 	ld.w	r9,r7[-104]
8000272e:	30 18       	mov	r8,1
80002730:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002734:	30 18       	mov	r8,1
80002736:	c1 a8       	rjmp	8000276a <dip204_init+0x662>
    }
    return false;
80002738:	30 08       	mov	r8,0
8000273a:	c1 88       	rjmp	8000276a <dip204_init+0x662>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000273c:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002740:	70 08       	ld.w	r8,r8[0x0]
80002742:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002746:	10 39       	cp.w	r9,r8
80002748:	c0 93       	brcs	8000275a <dip204_init+0x652>
8000274a:	ee f8 ff 98 	ld.w	r8,r7[-104]
8000274e:	70 18       	ld.w	r8,r8[0x4]
80002750:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002754:	10 39       	cp.w	r9,r8
80002756:	e0 88 00 09 	brls	80002768 <dip204_init+0x660>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000275a:	ee f9 ff 98 	ld.w	r9,r7[-104]
8000275e:	30 18       	mov	r8,1
80002760:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002764:	30 18       	mov	r8,1
80002766:	c0 28       	rjmp	8000276a <dip204_init+0x662>
    }
    return false;
80002768:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
8000276a:	58 08       	cp.w	r8,0
8000276c:	ca b0       	breq	800026c2 <dip204_init+0x5ba>
  // Send "Display On Command: Display On, Cursor On, Blink On"
  dip204_write_byte(0x0F);
8000276e:	30 fc       	mov	r12,15
80002770:	f0 1f 01 1a 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
80002774:	f0 1f 01 16 	mcall	80002bcc <dip204_init+0xac4>
80002778:	18 98       	mov	r8,r12
8000277a:	30 19       	mov	r9,1
8000277c:	ef 49 ff a4 	st.w	r7[-92],r9
80002780:	ef 48 ff a0 	st.w	r7[-96],r8
80002784:	ee f8 ff a4 	ld.w	r8,r7[-92]
80002788:	ef 48 ff ac 	st.w	r7[-84],r8
8000278c:	ee f8 ff a0 	ld.w	r8,r7[-96]
80002790:	ef 48 ff a8 	st.w	r7[-88],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002794:	ee fb ff ac 	ld.w	r11,r7[-84]
80002798:	ef 4b fe 90 	st.w	r7[-368],r11
8000279c:	30 0a       	mov	r10,0
8000279e:	ef 4a fe 8c 	st.w	r7[-372],r10
800027a2:	ee f9 ff a8 	ld.w	r9,r7[-88]
800027a6:	ef 49 fe 88 	st.w	r7[-376],r9
800027aa:	30 08       	mov	r8,0
800027ac:	ef 48 fe 84 	st.w	r7[-380],r8
800027b0:	ee fa fe 8c 	ld.w	r10,r7[-372]
800027b4:	ee fc fe 88 	ld.w	r12,r7[-376]
800027b8:	b9 3a       	mul	r10,r12
800027ba:	ee f8 fe 84 	ld.w	r8,r7[-380]
800027be:	ee fb fe 90 	ld.w	r11,r7[-368]
800027c2:	b7 38       	mul	r8,r11
800027c4:	10 0a       	add	r10,r8
800027c6:	ee fc fe 90 	ld.w	r12,r7[-368]
800027ca:	ee fb fe 88 	ld.w	r11,r7[-376]
800027ce:	f8 0b 06 48 	mulu.d	r8,r12,r11
800027d2:	12 0a       	add	r10,r9
800027d4:	14 99       	mov	r9,r10
800027d6:	e0 6a 03 e7 	mov	r10,999
800027da:	30 0b       	mov	r11,0
800027dc:	f0 0a 00 0a 	add	r10,r8,r10
800027e0:	f2 0b 00 4b 	adc	r11,r9,r11
800027e4:	e0 68 03 e8 	mov	r8,1000
800027e8:	30 09       	mov	r9,0
800027ea:	f0 1f 00 fa 	mcall	80002bd0 <dip204_init+0xac8>
800027ee:	14 98       	mov	r8,r10
800027f0:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
800027f2:	ef 48 ff b4 	st.w	r7[-76],r8
800027f6:	ee c8 01 14 	sub	r8,r7,276
800027fa:	ef 48 ff b0 	st.w	r7[-80],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800027fe:	e1 b8 00 42 	mfsr	r8,0x108
80002802:	10 99       	mov	r9,r8
80002804:	ee f8 ff b0 	ld.w	r8,r7[-80]
80002808:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000280a:	ee f8 ff b0 	ld.w	r8,r7[-80]
8000280e:	70 09       	ld.w	r9,r8[0x0]
80002810:	ee f8 ff b4 	ld.w	r8,r7[-76]
80002814:	10 09       	add	r9,r8
80002816:	ee f8 ff b0 	ld.w	r8,r7[-80]
8000281a:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000281c:	ee f9 ff b0 	ld.w	r9,r7[-80]
80002820:	30 08       	mov	r8,0
80002822:	f3 68 00 08 	st.b	r9[8],r8
80002826:	ee c8 01 14 	sub	r8,r7,276
8000282a:	ef 48 ff b8 	st.w	r7[-72],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000282e:	e1 b8 00 42 	mfsr	r8,0x108
80002832:	ef 48 ff bc 	st.w	r7[-68],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002836:	ee f8 ff b8 	ld.w	r8,r7[-72]
8000283a:	f1 39 00 08 	ld.ub	r9,r8[8]
8000283e:	30 28       	mov	r8,2
80002840:	f0 09 18 00 	cp.b	r9,r8
80002844:	c0 31       	brne	8000284a <dip204_init+0x742>
    return false;
80002846:	30 08       	mov	r8,0
80002848:	c4 38       	rjmp	800028ce <dip204_init+0x7c6>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
8000284a:	ee f8 ff b8 	ld.w	r8,r7[-72]
8000284e:	f1 39 00 08 	ld.ub	r9,r8[8]
80002852:	30 18       	mov	r8,1
80002854:	f0 09 18 00 	cp.b	r9,r8
80002858:	c0 31       	brne	8000285e <dip204_init+0x756>
    return true;
8000285a:	30 18       	mov	r8,1
8000285c:	c3 98       	rjmp	800028ce <dip204_init+0x7c6>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000285e:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002862:	70 09       	ld.w	r9,r8[0x0]
80002864:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002868:	70 18       	ld.w	r8,r8[0x4]
8000286a:	10 39       	cp.w	r9,r8
8000286c:	e0 88 00 1a 	brls	800028a0 <dip204_init+0x798>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002870:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002874:	70 08       	ld.w	r8,r8[0x0]
80002876:	ee f9 ff bc 	ld.w	r9,r7[-68]
8000287a:	10 39       	cp.w	r9,r8
8000287c:	c1 02       	brcc	8000289c <dip204_init+0x794>
8000287e:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002882:	70 18       	ld.w	r8,r8[0x4]
80002884:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002888:	10 39       	cp.w	r9,r8
8000288a:	e0 88 00 09 	brls	8000289c <dip204_init+0x794>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000288e:	ee f9 ff b8 	ld.w	r9,r7[-72]
80002892:	30 18       	mov	r8,1
80002894:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002898:	30 18       	mov	r8,1
8000289a:	c1 a8       	rjmp	800028ce <dip204_init+0x7c6>
    }
    return false;
8000289c:	30 08       	mov	r8,0
8000289e:	c1 88       	rjmp	800028ce <dip204_init+0x7c6>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800028a0:	ee f8 ff b8 	ld.w	r8,r7[-72]
800028a4:	70 08       	ld.w	r8,r8[0x0]
800028a6:	ee f9 ff bc 	ld.w	r9,r7[-68]
800028aa:	10 39       	cp.w	r9,r8
800028ac:	c0 93       	brcs	800028be <dip204_init+0x7b6>
800028ae:	ee f8 ff b8 	ld.w	r8,r7[-72]
800028b2:	70 18       	ld.w	r8,r8[0x4]
800028b4:	ee f9 ff bc 	ld.w	r9,r7[-68]
800028b8:	10 39       	cp.w	r9,r8
800028ba:	e0 88 00 09 	brls	800028cc <dip204_init+0x7c4>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800028be:	ee f9 ff b8 	ld.w	r9,r7[-72]
800028c2:	30 18       	mov	r8,1
800028c4:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800028c8:	30 18       	mov	r8,1
800028ca:	c0 28       	rjmp	800028ce <dip204_init+0x7c6>
    }
    return false;
800028cc:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800028ce:	58 08       	cp.w	r8,0
800028d0:	ca b0       	breq	80002826 <dip204_init+0x71e>
  // Send "Display Clear" Command
  dip204_write_byte(0x01);
800028d2:	30 1c       	mov	r12,1
800028d4:	f0 1f 00 c1 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(5);
800028d8:	f0 1f 00 bd 	mcall	80002bcc <dip204_init+0xac4>
800028dc:	18 98       	mov	r8,r12
800028de:	30 59       	mov	r9,5
800028e0:	ef 49 ff c4 	st.w	r7[-60],r9
800028e4:	ef 48 ff c0 	st.w	r7[-64],r8
800028e8:	ee f8 ff c4 	ld.w	r8,r7[-60]
800028ec:	ef 48 ff cc 	st.w	r7[-52],r8
800028f0:	ee f8 ff c0 	ld.w	r8,r7[-64]
800028f4:	ef 48 ff c8 	st.w	r7[-56],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800028f8:	ee fa ff cc 	ld.w	r10,r7[-52]
800028fc:	ef 4a fe a0 	st.w	r7[-352],r10
80002900:	30 09       	mov	r9,0
80002902:	ef 49 fe 9c 	st.w	r7[-356],r9
80002906:	ee f8 ff c8 	ld.w	r8,r7[-56]
8000290a:	ef 48 fe 98 	st.w	r7[-360],r8
8000290e:	30 0c       	mov	r12,0
80002910:	ef 4c fe 94 	st.w	r7[-364],r12
80002914:	ee fa fe 9c 	ld.w	r10,r7[-356]
80002918:	ee fb fe 98 	ld.w	r11,r7[-360]
8000291c:	b7 3a       	mul	r10,r11
8000291e:	ee f8 fe 94 	ld.w	r8,r7[-364]
80002922:	ee f9 fe a0 	ld.w	r9,r7[-352]
80002926:	b3 38       	mul	r8,r9
80002928:	10 0a       	add	r10,r8
8000292a:	ee fc fe a0 	ld.w	r12,r7[-352]
8000292e:	ee fb fe 98 	ld.w	r11,r7[-360]
80002932:	f8 0b 06 48 	mulu.d	r8,r12,r11
80002936:	12 0a       	add	r10,r9
80002938:	14 99       	mov	r9,r10
8000293a:	e0 6a 03 e7 	mov	r10,999
8000293e:	30 0b       	mov	r11,0
80002940:	f0 0a 00 0a 	add	r10,r8,r10
80002944:	f2 0b 00 4b 	adc	r11,r9,r11
80002948:	e0 68 03 e8 	mov	r8,1000
8000294c:	30 09       	mov	r9,0
8000294e:	f0 1f 00 a1 	mcall	80002bd0 <dip204_init+0xac8>
80002952:	14 98       	mov	r8,r10
80002954:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002956:	ef 48 ff d4 	st.w	r7[-44],r8
8000295a:	ee c8 01 08 	sub	r8,r7,264
8000295e:	ef 48 ff d0 	st.w	r7[-48],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002962:	e1 b8 00 42 	mfsr	r8,0x108
80002966:	10 99       	mov	r9,r8
80002968:	ee f8 ff d0 	ld.w	r8,r7[-48]
8000296c:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000296e:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002972:	70 09       	ld.w	r9,r8[0x0]
80002974:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002978:	10 09       	add	r9,r8
8000297a:	ee f8 ff d0 	ld.w	r8,r7[-48]
8000297e:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002980:	ee f9 ff d0 	ld.w	r9,r7[-48]
80002984:	30 08       	mov	r8,0
80002986:	f3 68 00 08 	st.b	r9[8],r8
8000298a:	ee c8 01 08 	sub	r8,r7,264
8000298e:	ef 48 ff d8 	st.w	r7[-40],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002992:	e1 b8 00 42 	mfsr	r8,0x108
80002996:	ef 48 ff dc 	st.w	r7[-36],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000299a:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000299e:	f1 39 00 08 	ld.ub	r9,r8[8]
800029a2:	30 28       	mov	r8,2
800029a4:	f0 09 18 00 	cp.b	r9,r8
800029a8:	c0 31       	brne	800029ae <dip204_init+0x8a6>
    return false;
800029aa:	30 08       	mov	r8,0
800029ac:	c4 38       	rjmp	80002a32 <dip204_init+0x92a>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800029ae:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029b2:	f1 39 00 08 	ld.ub	r9,r8[8]
800029b6:	30 18       	mov	r8,1
800029b8:	f0 09 18 00 	cp.b	r9,r8
800029bc:	c0 31       	brne	800029c2 <dip204_init+0x8ba>
    return true;
800029be:	30 18       	mov	r8,1
800029c0:	c3 98       	rjmp	80002a32 <dip204_init+0x92a>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800029c2:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029c6:	70 09       	ld.w	r9,r8[0x0]
800029c8:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029cc:	70 18       	ld.w	r8,r8[0x4]
800029ce:	10 39       	cp.w	r9,r8
800029d0:	e0 88 00 1a 	brls	80002a04 <dip204_init+0x8fc>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800029d4:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029d8:	70 08       	ld.w	r8,r8[0x0]
800029da:	ee f9 ff dc 	ld.w	r9,r7[-36]
800029de:	10 39       	cp.w	r9,r8
800029e0:	c1 02       	brcc	80002a00 <dip204_init+0x8f8>
800029e2:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029e6:	70 18       	ld.w	r8,r8[0x4]
800029e8:	ee f9 ff dc 	ld.w	r9,r7[-36]
800029ec:	10 39       	cp.w	r9,r8
800029ee:	e0 88 00 09 	brls	80002a00 <dip204_init+0x8f8>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800029f2:	ee f9 ff d8 	ld.w	r9,r7[-40]
800029f6:	30 18       	mov	r8,1
800029f8:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800029fc:	30 18       	mov	r8,1
800029fe:	c1 a8       	rjmp	80002a32 <dip204_init+0x92a>
    }
    return false;
80002a00:	30 08       	mov	r8,0
80002a02:	c1 88       	rjmp	80002a32 <dip204_init+0x92a>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002a04:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002a08:	70 08       	ld.w	r8,r8[0x0]
80002a0a:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002a0e:	10 39       	cp.w	r9,r8
80002a10:	c0 93       	brcs	80002a22 <dip204_init+0x91a>
80002a12:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002a16:	70 18       	ld.w	r8,r8[0x4]
80002a18:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002a1c:	10 39       	cp.w	r9,r8
80002a1e:	e0 88 00 09 	brls	80002a30 <dip204_init+0x928>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002a22:	ee f9 ff d8 	ld.w	r9,r7[-40]
80002a26:	30 18       	mov	r8,1
80002a28:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002a2c:	30 18       	mov	r8,1
80002a2e:	c0 28       	rjmp	80002a32 <dip204_init+0x92a>
    }
    return false;
80002a30:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002a32:	58 08       	cp.w	r8,0
80002a34:	ca b0       	breq	8000298a <dip204_init+0x882>
  // Send "Entry Mode Set Command: Increment Mode, Entire Shift off"
  dip204_write_byte(0x06);
80002a36:	30 6c       	mov	r12,6
80002a38:	f0 1f 00 68 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
80002a3c:	f0 1f 00 64 	mcall	80002bcc <dip204_init+0xac4>
80002a40:	18 98       	mov	r8,r12
80002a42:	30 19       	mov	r9,1
80002a44:	ef 49 ff e4 	st.w	r7[-28],r9
80002a48:	ef 48 ff e0 	st.w	r7[-32],r8
80002a4c:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002a50:	ef 48 ff ec 	st.w	r7[-20],r8
80002a54:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002a58:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002a5c:	ee fa ff ec 	ld.w	r10,r7[-20]
80002a60:	ef 4a fe b0 	st.w	r7[-336],r10
80002a64:	30 09       	mov	r9,0
80002a66:	ef 49 fe ac 	st.w	r7[-340],r9
80002a6a:	ee f8 ff e8 	ld.w	r8,r7[-24]
80002a6e:	ef 48 fe a8 	st.w	r7[-344],r8
80002a72:	30 0c       	mov	r12,0
80002a74:	ef 4c fe a4 	st.w	r7[-348],r12
80002a78:	ee fa fe ac 	ld.w	r10,r7[-340]
80002a7c:	ee fb fe a8 	ld.w	r11,r7[-344]
80002a80:	b7 3a       	mul	r10,r11
80002a82:	ee f8 fe a4 	ld.w	r8,r7[-348]
80002a86:	ee f9 fe b0 	ld.w	r9,r7[-336]
80002a8a:	b3 38       	mul	r8,r9
80002a8c:	10 0a       	add	r10,r8
80002a8e:	ee fc fe b0 	ld.w	r12,r7[-336]
80002a92:	ee fb fe a8 	ld.w	r11,r7[-344]
80002a96:	f8 0b 06 48 	mulu.d	r8,r12,r11
80002a9a:	12 0a       	add	r10,r9
80002a9c:	14 99       	mov	r9,r10
80002a9e:	e0 6a 03 e7 	mov	r10,999
80002aa2:	30 0b       	mov	r11,0
80002aa4:	f0 0a 00 0a 	add	r10,r8,r10
80002aa8:	f2 0b 00 4b 	adc	r11,r9,r11
80002aac:	e0 68 03 e8 	mov	r8,1000
80002ab0:	30 09       	mov	r9,0
80002ab2:	f0 1f 00 48 	mcall	80002bd0 <dip204_init+0xac8>
80002ab6:	14 98       	mov	r8,r10
80002ab8:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002aba:	ef 48 ff f4 	st.w	r7[-12],r8
80002abe:	ee c8 00 fc 	sub	r8,r7,252
80002ac2:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002ac6:	e1 b8 00 42 	mfsr	r8,0x108
80002aca:	10 99       	mov	r9,r8
80002acc:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ad0:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002ad2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ad6:	70 09       	ld.w	r9,r8[0x0]
80002ad8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002adc:	10 09       	add	r9,r8
80002ade:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ae2:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002ae4:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002ae8:	30 08       	mov	r8,0
80002aea:	f3 68 00 08 	st.b	r9[8],r8
80002aee:	ee c8 00 fc 	sub	r8,r7,252
80002af2:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002af6:	e1 b8 00 42 	mfsr	r8,0x108
80002afa:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002afe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b02:	f1 39 00 08 	ld.ub	r9,r8[8]
80002b06:	30 28       	mov	r8,2
80002b08:	f0 09 18 00 	cp.b	r9,r8
80002b0c:	c0 31       	brne	80002b12 <dip204_init+0xa0a>
    return false;
80002b0e:	30 08       	mov	r8,0
80002b10:	c4 38       	rjmp	80002b96 <dip204_init+0xa8e>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002b12:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b16:	f1 39 00 08 	ld.ub	r9,r8[8]
80002b1a:	30 18       	mov	r8,1
80002b1c:	f0 09 18 00 	cp.b	r9,r8
80002b20:	c0 31       	brne	80002b26 <dip204_init+0xa1e>
    return true;
80002b22:	30 18       	mov	r8,1
80002b24:	c3 98       	rjmp	80002b96 <dip204_init+0xa8e>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002b26:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b2a:	70 09       	ld.w	r9,r8[0x0]
80002b2c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b30:	70 18       	ld.w	r8,r8[0x4]
80002b32:	10 39       	cp.w	r9,r8
80002b34:	e0 88 00 1a 	brls	80002b68 <dip204_init+0xa60>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002b38:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b3c:	70 08       	ld.w	r8,r8[0x0]
80002b3e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b42:	10 39       	cp.w	r9,r8
80002b44:	c1 02       	brcc	80002b64 <dip204_init+0xa5c>
80002b46:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b4a:	70 18       	ld.w	r8,r8[0x4]
80002b4c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b50:	10 39       	cp.w	r9,r8
80002b52:	e0 88 00 09 	brls	80002b64 <dip204_init+0xa5c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002b56:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002b5a:	30 18       	mov	r8,1
80002b5c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002b60:	30 18       	mov	r8,1
80002b62:	c1 a8       	rjmp	80002b96 <dip204_init+0xa8e>
    }
    return false;
80002b64:	30 08       	mov	r8,0
80002b66:	c1 88       	rjmp	80002b96 <dip204_init+0xa8e>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002b68:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b6c:	70 08       	ld.w	r8,r8[0x0]
80002b6e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b72:	10 39       	cp.w	r9,r8
80002b74:	c0 93       	brcs	80002b86 <dip204_init+0xa7e>
80002b76:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b7a:	70 18       	ld.w	r8,r8[0x4]
80002b7c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b80:	10 39       	cp.w	r9,r8
80002b82:	e0 88 00 09 	brls	80002b94 <dip204_init+0xa8c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002b86:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002b8a:	30 18       	mov	r8,1
80002b8c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002b90:	30 18       	mov	r8,1
80002b92:	c0 28       	rjmp	80002b96 <dip204_init+0xa8e>
    }
    return false;
80002b94:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002b96:	58 08       	cp.w	r8,0
80002b98:	ca b0       	breq	80002aee <dip204_init+0x9e6>
  dip204_wait_busy();
80002b9a:	f0 1f 00 11 	mcall	80002bdc <dip204_init+0xad4>
  // unselect chip
  dip204_unselect();
80002b9e:	f0 1f 00 11 	mcall	80002be0 <dip204_init+0xad8>
}
80002ba2:	29 5d       	sub	sp,-428
80002ba4:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
80002ba8:	00 00       	add	r0,r0
80002baa:	00 1c       	sub	r12,r0
80002bac:	80 00       	ld.sh	r0,r0[0x0]
80002bae:	42 04       	lddsp	r4,sp[0x80]
80002bb0:	80 00       	ld.sh	r0,r0[0x0]
80002bb2:	31 b8       	mov	r8,27
80002bb4:	00 00       	add	r0,r0
80002bb6:	05 50       	ld.sh	r0,--r2
80002bb8:	00 00       	add	r0,r0
80002bba:	05 54       	ld.sh	r4,--r2
80002bbc:	80 00       	ld.sh	r0,r0[0x0]
80002bbe:	32 4c       	mov	r12,36
80002bc0:	80 00       	ld.sh	r0,r0[0x0]
80002bc2:	32 d4       	mov	r4,45
80002bc4:	80 00       	ld.sh	r0,r0[0x0]
80002bc6:	43 7c       	lddsp	r12,sp[0xdc]
80002bc8:	80 00       	ld.sh	r0,r0[0x0]
80002bca:	43 14       	lddsp	r4,sp[0xc4]
80002bcc:	80 00       	ld.sh	r0,r0[0x0]
80002bce:	20 f0       	sub	r0,15
80002bd0:	80 00       	ld.sh	r0,r0[0x0]
80002bd2:	66 2c       	ld.w	r12,r3[0x8]
80002bd4:	80 00       	ld.sh	r0,r0[0x0]
80002bd6:	2f 50       	sub	r0,-11
80002bd8:	80 00       	ld.sh	r0,r0[0x0]
80002bda:	2f 80       	sub	r0,-8
80002bdc:	80 00       	ld.sh	r0,r0[0x0]
80002bde:	30 64       	mov	r4,6
80002be0:	80 00       	ld.sh	r0,r0[0x0]
80002be2:	2f 68       	sub	r8,-10

80002be4 <dip204_hide_cursor>:
  dip204_unselect();
}


void dip204_hide_cursor(void)
{
80002be4:	eb cd 40 80 	pushm	r7,lr
80002be8:	1a 97       	mov	r7,sp
  /* select the LCD chip */
  dip204_select();
80002bea:	f0 1f 00 08 	mcall	80002c08 <dip204_hide_cursor+0x24>
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002bee:	e0 6c 00 f8 	mov	r12,248
80002bf2:	f0 1f 00 07 	mcall	80002c0c <dip204_hide_cursor+0x28>
  /* Send "Display On Command: Display On, Cursor On, Blink On" */
  dip204_write_byte(0x0C);
80002bf6:	30 cc       	mov	r12,12
80002bf8:	f0 1f 00 05 	mcall	80002c0c <dip204_hide_cursor+0x28>
  dip204_wait_busy();
80002bfc:	f0 1f 00 05 	mcall	80002c10 <dip204_hide_cursor+0x2c>
  /* unselect chip */
  dip204_unselect();
80002c00:	f0 1f 00 05 	mcall	80002c14 <dip204_hide_cursor+0x30>
}
80002c04:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c08:	80 00       	ld.sh	r0,r0[0x0]
80002c0a:	2f 50       	sub	r0,-11
80002c0c:	80 00       	ld.sh	r0,r0[0x0]
80002c0e:	2f 80       	sub	r0,-8
80002c10:	80 00       	ld.sh	r0,r0[0x0]
80002c12:	30 64       	mov	r4,6
80002c14:	80 00       	ld.sh	r0,r0[0x0]
80002c16:	2f 68       	sub	r8,-10

80002c18 <dip204_set_cursor_position>:
  dip204_set_cursor_position(column, line);
}


void dip204_set_cursor_position(unsigned char column, unsigned char line)
{
80002c18:	eb cd 40 80 	pushm	r7,lr
80002c1c:	1a 97       	mov	r7,sp
80002c1e:	20 3d       	sub	sp,12
80002c20:	18 99       	mov	r9,r12
80002c22:	16 98       	mov	r8,r11
80002c24:	ef 69 ff f8 	st.b	r7[-8],r9
80002c28:	ef 68 ff f4 	st.b	r7[-12],r8
  unsigned char address = 0;
80002c2c:	30 08       	mov	r8,0
80002c2e:	ef 68 ff ff 	st.b	r7[-1],r8

  dip204_select();
80002c32:	f0 1f 00 18 	mcall	80002c90 <dip204_set_cursor_position+0x78>
  if ((column <= 20) && (line <= 4))
80002c36:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80002c3a:	31 48       	mov	r8,20
80002c3c:	f0 09 18 00 	cp.b	r9,r8
80002c40:	e0 8b 00 17 	brhi	80002c6e <dip204_set_cursor_position+0x56>
80002c44:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80002c48:	30 48       	mov	r8,4
80002c4a:	f0 09 18 00 	cp.b	r9,r8
80002c4e:	e0 8b 00 10 	brhi	80002c6e <dip204_set_cursor_position+0x56>
  {
    /* Calculate DDRAM address from line and row values */
    address = ( (line-1) * 32 ) + ( column-1 ) + 128;
80002c52:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002c56:	20 18       	sub	r8,1
80002c58:	5c 58       	castu.b	r8
80002c5a:	a5 78       	lsl	r8,0x5
80002c5c:	5c 58       	castu.b	r8
80002c5e:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80002c62:	f2 08 00 08 	add	r8,r9,r8
80002c66:	5c 58       	castu.b	r8
80002c68:	28 18       	sub	r8,-127
80002c6a:	ef 68 ff ff 	st.b	r7[-1],r8
  }
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002c6e:	e0 6c 00 f8 	mov	r12,248
80002c72:	f0 1f 00 09 	mcall	80002c94 <dip204_set_cursor_position+0x7c>
  /* Send Address lower Nibble */
  dip204_write_byte(address);
80002c76:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002c7a:	10 9c       	mov	r12,r8
80002c7c:	f0 1f 00 06 	mcall	80002c94 <dip204_set_cursor_position+0x7c>
  dip204_wait_busy();
80002c80:	f0 1f 00 06 	mcall	80002c98 <dip204_set_cursor_position+0x80>
  dip204_unselect();
80002c84:	f0 1f 00 06 	mcall	80002c9c <dip204_set_cursor_position+0x84>
}
80002c88:	2f dd       	sub	sp,-12
80002c8a:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c8e:	00 00       	add	r0,r0
80002c90:	80 00       	ld.sh	r0,r0[0x0]
80002c92:	2f 50       	sub	r0,-11
80002c94:	80 00       	ld.sh	r0,r0[0x0]
80002c96:	2f 80       	sub	r0,-8
80002c98:	80 00       	ld.sh	r0,r0[0x0]
80002c9a:	30 64       	mov	r4,6
80002c9c:	80 00       	ld.sh	r0,r0[0x0]
80002c9e:	2f 68       	sub	r8,-10

80002ca0 <dip204_clear_display>:


void dip204_clear_display(void)
{
80002ca0:	eb cd 40 8f 	pushm	r0-r3,r7,lr
80002ca4:	1a 97       	mov	r7,sp
80002ca6:	20 bd       	sub	sp,44
  dip204_select();
80002ca8:	f0 1f 00 57 	mcall	80002e04 <dip204_clear_display+0x164>
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002cac:	e0 6c 00 f8 	mov	r12,248
80002cb0:	f0 1f 00 56 	mcall	80002e08 <dip204_clear_display+0x168>
  /* Send Display Clear Command */
  dip204_write_byte(0x01);
80002cb4:	30 1c       	mov	r12,1
80002cb6:	f0 1f 00 55 	mcall	80002e08 <dip204_clear_display+0x168>
  /* Wait for command execution */
  delay_ms(4);
80002cba:	f0 1f 00 55 	mcall	80002e0c <dip204_clear_display+0x16c>
80002cbe:	18 98       	mov	r8,r12
80002cc0:	30 49       	mov	r9,4
80002cc2:	ef 49 ff e4 	st.w	r7[-28],r9
80002cc6:	ef 48 ff e0 	st.w	r7[-32],r8
80002cca:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002cce:	ef 48 ff ec 	st.w	r7[-20],r8
80002cd2:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002cd6:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002cda:	ee f0 ff ec 	ld.w	r0,r7[-20]
80002cde:	30 01       	mov	r1,0
80002ce0:	ee f2 ff e8 	ld.w	r2,r7[-24]
80002ce4:	30 03       	mov	r3,0
80002ce6:	e2 02 02 4a 	mul	r10,r1,r2
80002cea:	e6 00 02 48 	mul	r8,r3,r0
80002cee:	10 0a       	add	r10,r8
80002cf0:	e0 02 06 48 	mulu.d	r8,r0,r2
80002cf4:	12 0a       	add	r10,r9
80002cf6:	14 99       	mov	r9,r10
80002cf8:	e0 6a 03 e7 	mov	r10,999
80002cfc:	30 0b       	mov	r11,0
80002cfe:	f0 0a 00 0a 	add	r10,r8,r10
80002d02:	f2 0b 00 4b 	adc	r11,r9,r11
80002d06:	e0 68 03 e8 	mov	r8,1000
80002d0a:	30 09       	mov	r9,0
80002d0c:	f0 1f 00 41 	mcall	80002e10 <dip204_clear_display+0x170>
80002d10:	14 98       	mov	r8,r10
80002d12:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002d14:	ef 48 ff f4 	st.w	r7[-12],r8
80002d18:	ee c8 00 2c 	sub	r8,r7,44
80002d1c:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002d20:	e1 b8 00 42 	mfsr	r8,0x108
80002d24:	10 99       	mov	r9,r8
80002d26:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d2a:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002d2c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d30:	70 09       	ld.w	r9,r8[0x0]
80002d32:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002d36:	10 09       	add	r9,r8
80002d38:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d3c:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002d3e:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002d42:	30 08       	mov	r8,0
80002d44:	f3 68 00 08 	st.b	r9[8],r8
80002d48:	ee c8 00 2c 	sub	r8,r7,44
80002d4c:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002d50:	e1 b8 00 42 	mfsr	r8,0x108
80002d54:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002d58:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d5c:	f1 39 00 08 	ld.ub	r9,r8[8]
80002d60:	30 28       	mov	r8,2
80002d62:	f0 09 18 00 	cp.b	r9,r8
80002d66:	c0 31       	brne	80002d6c <dip204_clear_display+0xcc>
    return false;
80002d68:	30 08       	mov	r8,0
80002d6a:	c4 38       	rjmp	80002df0 <dip204_clear_display+0x150>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002d6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d70:	f1 39 00 08 	ld.ub	r9,r8[8]
80002d74:	30 18       	mov	r8,1
80002d76:	f0 09 18 00 	cp.b	r9,r8
80002d7a:	c0 31       	brne	80002d80 <dip204_clear_display+0xe0>
    return true;
80002d7c:	30 18       	mov	r8,1
80002d7e:	c3 98       	rjmp	80002df0 <dip204_clear_display+0x150>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002d80:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d84:	70 09       	ld.w	r9,r8[0x0]
80002d86:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d8a:	70 18       	ld.w	r8,r8[0x4]
80002d8c:	10 39       	cp.w	r9,r8
80002d8e:	e0 88 00 1a 	brls	80002dc2 <dip204_clear_display+0x122>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002d92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d96:	70 08       	ld.w	r8,r8[0x0]
80002d98:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002d9c:	10 39       	cp.w	r9,r8
80002d9e:	c1 02       	brcc	80002dbe <dip204_clear_display+0x11e>
80002da0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002da4:	70 18       	ld.w	r8,r8[0x4]
80002da6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002daa:	10 39       	cp.w	r9,r8
80002dac:	e0 88 00 09 	brls	80002dbe <dip204_clear_display+0x11e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002db0:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002db4:	30 18       	mov	r8,1
80002db6:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002dba:	30 18       	mov	r8,1
80002dbc:	c1 a8       	rjmp	80002df0 <dip204_clear_display+0x150>
    }
    return false;
80002dbe:	30 08       	mov	r8,0
80002dc0:	c1 88       	rjmp	80002df0 <dip204_clear_display+0x150>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002dc2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dc6:	70 08       	ld.w	r8,r8[0x0]
80002dc8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002dcc:	10 39       	cp.w	r9,r8
80002dce:	c0 93       	brcs	80002de0 <dip204_clear_display+0x140>
80002dd0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dd4:	70 18       	ld.w	r8,r8[0x4]
80002dd6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002dda:	10 39       	cp.w	r9,r8
80002ddc:	e0 88 00 09 	brls	80002dee <dip204_clear_display+0x14e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002de0:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002de4:	30 18       	mov	r8,1
80002de6:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002dea:	30 18       	mov	r8,1
80002dec:	c0 28       	rjmp	80002df0 <dip204_clear_display+0x150>
    }
    return false;
80002dee:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002df0:	58 08       	cp.w	r8,0
80002df2:	ca b0       	breq	80002d48 <dip204_clear_display+0xa8>
  dip204_wait_busy();
80002df4:	f0 1f 00 08 	mcall	80002e14 <dip204_clear_display+0x174>
  dip204_unselect();
80002df8:	f0 1f 00 08 	mcall	80002e18 <dip204_clear_display+0x178>
}
80002dfc:	2f 5d       	sub	sp,-44
80002dfe:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
80002e02:	00 00       	add	r0,r0
80002e04:	80 00       	ld.sh	r0,r0[0x0]
80002e06:	2f 50       	sub	r0,-11
80002e08:	80 00       	ld.sh	r0,r0[0x0]
80002e0a:	2f 80       	sub	r0,-8
80002e0c:	80 00       	ld.sh	r0,r0[0x0]
80002e0e:	20 f0       	sub	r0,15
80002e10:	80 00       	ld.sh	r0,r0[0x0]
80002e12:	66 2c       	ld.w	r12,r3[0x8]
80002e14:	80 00       	ld.sh	r0,r0[0x0]
80002e16:	30 64       	mov	r4,6
80002e18:	80 00       	ld.sh	r0,r0[0x0]
80002e1a:	2f 68       	sub	r8,-10

80002e1c <dip204_write_string>:


void dip204_write_string(const char *string)
{
80002e1c:	eb cd 40 80 	pushm	r7,lr
80002e20:	1a 97       	mov	r7,sp
80002e22:	20 2d       	sub	sp,8
80002e24:	ef 4c ff f8 	st.w	r7[-8],r12
  unsigned char i=0;
80002e28:	30 08       	mov	r8,0
80002e2a:	ef 68 ff ff 	st.b	r7[-1],r8

  dip204_select();
80002e2e:	f0 1f 00 14 	mcall	80002e7c <dip204_write_string+0x60>
  /* for all chars in string */
  while(string[i]!=0)
80002e32:	c1 68       	rjmp	80002e5e <dip204_write_string+0x42>
  {
    /* Send Write Data Start Byte */
    dip204_write_byte(DIP204_WRITE_DATA);
80002e34:	e0 6c 00 fa 	mov	r12,250
80002e38:	f0 1f 00 12 	mcall	80002e80 <dip204_write_string+0x64>
    /* Send byte */
    dip204_write_byte(string[i]);
80002e3c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002e40:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002e44:	f2 08 00 08 	add	r8,r9,r8
80002e48:	11 88       	ld.ub	r8,r8[0x0]
80002e4a:	10 9c       	mov	r12,r8
80002e4c:	f0 1f 00 0d 	mcall	80002e80 <dip204_write_string+0x64>
    /* go to next char */
    i++;
80002e50:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002e54:	2f f8       	sub	r8,-1
80002e56:	ef 68 ff ff 	st.b	r7[-1],r8
    dip204_wait_busy();
80002e5a:	f0 1f 00 0b 	mcall	80002e84 <dip204_write_string+0x68>
{
  unsigned char i=0;

  dip204_select();
  /* for all chars in string */
  while(string[i]!=0)
80002e5e:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002e62:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002e66:	f2 08 00 08 	add	r8,r9,r8
80002e6a:	11 88       	ld.ub	r8,r8[0x0]
80002e6c:	58 08       	cp.w	r8,0
80002e6e:	ce 31       	brne	80002e34 <dip204_write_string+0x18>
    dip204_write_byte(string[i]);
    /* go to next char */
    i++;
    dip204_wait_busy();
  }
  dip204_unselect();
80002e70:	f0 1f 00 06 	mcall	80002e88 <dip204_write_string+0x6c>
}
80002e74:	2f ed       	sub	sp,-8
80002e76:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e7a:	00 00       	add	r0,r0
80002e7c:	80 00       	ld.sh	r0,r0[0x0]
80002e7e:	2f 50       	sub	r0,-11
80002e80:	80 00       	ld.sh	r0,r0[0x0]
80002e82:	2f 80       	sub	r0,-8
80002e84:	80 00       	ld.sh	r0,r0[0x0]
80002e86:	30 64       	mov	r4,6
80002e88:	80 00       	ld.sh	r0,r0[0x0]
80002e8a:	2f 68       	sub	r8,-10

80002e8c <dip204_printf_string>:


void dip204_printf_string(const char *format, ...)
{
80002e8c:	eb cd 40 80 	pushm	r7,lr
80002e90:	1a 97       	mov	r7,sp
80002e92:	20 9d       	sub	sp,36
80002e94:	ee c9 ff f8 	sub	r9,r7,-8
80002e98:	ef 4c ff dc 	st.w	r7[-36],r12
  va_list arg;
  char string[21];
  unsigned char i=0;
80002e9c:	30 08       	mov	r8,0
80002e9e:	ef 68 ff ff 	st.b	r7[-1],r8

  va_start(arg, format);
80002ea2:	f2 c8 00 00 	sub	r8,r9,0
80002ea6:	ef 48 ff f8 	st.w	r7[-8],r8
  i = vsprintf(string, format, arg);
80002eaa:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002eae:	ee c8 00 20 	sub	r8,r7,32
80002eb2:	12 9a       	mov	r10,r9
80002eb4:	ee fb ff dc 	ld.w	r11,r7[-36]
80002eb8:	10 9c       	mov	r12,r8
80002eba:	f0 1f 00 21 	mcall	80002f3c <dip204_printf_string+0xb0>
80002ebe:	18 98       	mov	r8,r12
80002ec0:	ef 68 ff ff 	st.b	r7[-1],r8
  while (i < sizeof(string) - 1) string[i++] = '\0';
80002ec4:	c0 d8       	rjmp	80002ede <dip204_printf_string+0x52>
80002ec6:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002eca:	ee 08 00 09 	add	r9,r7,r8
80002ece:	30 08       	mov	r8,0
80002ed0:	f3 68 ff e0 	st.b	r9[-32],r8
80002ed4:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002ed8:	2f f8       	sub	r8,-1
80002eda:	ef 68 ff ff 	st.b	r7[-1],r8
80002ede:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80002ee2:	31 38       	mov	r8,19
80002ee4:	f0 09 18 00 	cp.b	r9,r8
80002ee8:	fe 98 ff ef 	brls	80002ec6 <dip204_printf_string+0x3a>
  va_end(arg);
  dip204_select();
80002eec:	f0 1f 00 15 	mcall	80002f40 <dip204_printf_string+0xb4>
  /* for all chars in string */
  i = 0;
80002ef0:	30 08       	mov	r8,0
80002ef2:	ef 68 ff ff 	st.b	r7[-1],r8
  while(string[i]!='\0')
80002ef6:	c1 58       	rjmp	80002f20 <dip204_printf_string+0x94>
  {
    /* Send Write Data Start Byte */
    dip204_write_byte(DIP204_WRITE_DATA);
80002ef8:	e0 6c 00 fa 	mov	r12,250
80002efc:	f0 1f 00 12 	mcall	80002f44 <dip204_printf_string+0xb8>
    /* Send byte */
    dip204_write_byte(string[i]);
80002f00:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002f04:	ee 08 00 08 	add	r8,r7,r8
80002f08:	f1 38 ff e0 	ld.ub	r8,r8[-32]
80002f0c:	10 9c       	mov	r12,r8
80002f0e:	f0 1f 00 0e 	mcall	80002f44 <dip204_printf_string+0xb8>
    /* go to next char */
    i++;
80002f12:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002f16:	2f f8       	sub	r8,-1
80002f18:	ef 68 ff ff 	st.b	r7[-1],r8
    dip204_wait_busy();
80002f1c:	f0 1f 00 0b 	mcall	80002f48 <dip204_printf_string+0xbc>
  while (i < sizeof(string) - 1) string[i++] = '\0';
  va_end(arg);
  dip204_select();
  /* for all chars in string */
  i = 0;
  while(string[i]!='\0')
80002f20:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002f24:	ee 08 00 08 	add	r8,r7,r8
80002f28:	f1 38 ff e0 	ld.ub	r8,r8[-32]
80002f2c:	58 08       	cp.w	r8,0
80002f2e:	ce 51       	brne	80002ef8 <dip204_printf_string+0x6c>
    dip204_write_byte(string[i]);
    /* go to next char */
    i++;
    dip204_wait_busy();
  }
  dip204_unselect();
80002f30:	f0 1f 00 07 	mcall	80002f4c <dip204_printf_string+0xc0>
}
80002f34:	2f 7d       	sub	sp,-36
80002f36:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f3a:	00 00       	add	r0,r0
80002f3c:	80 00       	ld.sh	r0,r0[0x0]
80002f3e:	72 88       	ld.w	r8,r9[0x20]
80002f40:	80 00       	ld.sh	r0,r0[0x0]
80002f42:	2f 50       	sub	r0,-11
80002f44:	80 00       	ld.sh	r0,r0[0x0]
80002f46:	2f 80       	sub	r0,-8
80002f48:	80 00       	ld.sh	r0,r0[0x0]
80002f4a:	30 64       	mov	r4,6
80002f4c:	80 00       	ld.sh	r0,r0[0x0]
80002f4e:	2f 68       	sub	r8,-10

80002f50 <dip204_select>:

/*! \brief function to select the LCD
 *
 */
static void dip204_select(void)
{
80002f50:	eb cd 40 80 	pushm	r7,lr
80002f54:	1a 97       	mov	r7,sp
  spi_selectChip(DIP204_SPI, DIP204_SPI_NPCS);
80002f56:	30 2b       	mov	r11,2
80002f58:	fe 7c 28 00 	mov	r12,-55296
80002f5c:	f0 1f 00 02 	mcall	80002f64 <dip204_select+0x14>
}
80002f60:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f64:	80 00       	ld.sh	r0,r0[0x0]
80002f66:	34 7a       	mov	r10,71

80002f68 <dip204_unselect>:

/*! \brief function to unselect the LCD
 *
 */
static void dip204_unselect(void)
{
80002f68:	eb cd 40 80 	pushm	r7,lr
80002f6c:	1a 97       	mov	r7,sp
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_unselectChip(DIP204_SPI, DIP204_SPI_NPCS);
80002f6e:	30 2b       	mov	r11,2
80002f70:	fe 7c 28 00 	mov	r12,-55296
80002f74:	f0 1f 00 02 	mcall	80002f7c <dip204_unselect+0x14>
  Assert( SPI_OK==spi_status );
}
80002f78:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f7c:	80 00       	ld.sh	r0,r0[0x0]
80002f7e:	35 12       	mov	r2,81

80002f80 <dip204_write_byte>:
 *
 *  \param  byte  Input. byte to write to the LCD (D7 .. D0)
 *
 */
static void dip204_write_byte(unsigned char byte)
{
80002f80:	eb cd 40 80 	pushm	r7,lr
80002f84:	1a 97       	mov	r7,sp
80002f86:	20 3d       	sub	sp,12
80002f88:	18 98       	mov	r8,r12
80002f8a:	ef 68 ff f4 	st.b	r7[-12],r8
  unsigned char reverse;

  switch (byte)
80002f8e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002f92:	f0 c8 00 f8 	sub	r8,r8,248
80002f96:	58 68       	cp.w	r8,6
80002f98:	e0 8b 00 10 	brhi	80002fb8 <dip204_write_byte+0x38>
80002f9c:	30 19       	mov	r9,1
80002f9e:	f2 08 09 48 	lsl	r8,r9,r8
80002fa2:	e2 18 00 55 	andl	r8,0x55,COH
80002fa6:	c0 90       	breq	80002fb8 <dip204_write_byte+0x38>
    {
      /* send D7 to D0 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, byte);
80002fa8:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002fac:	10 9b       	mov	r11,r8
80002fae:	fe 7c 28 00 	mov	r12,-55296
80002fb2:	f0 1f 00 15 	mcall	80003004 <dip204_write_byte+0x84>
      Assert( SPI_OK==spi_status );
      break;
80002fb6:	c2 48       	rjmp	80002ffe <dip204_write_byte+0x7e>
    }
    /* LSB first for all other data */
    default:
    {
      /* reverse byte */
      reverse = bit_reverse8(byte);
80002fb8:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002fbc:	ef 48 ff fc 	st.w	r7[-4],r8
80002fc0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fc4:	5c 98       	brev	r8
80002fc6:	ef 48 ff fc 	st.w	r7[-4],r8
80002fca:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fce:	b9 88       	lsr	r8,0x18
80002fd0:	ef 68 ff fb 	st.b	r7[-5],r8
      /* send D0 to D3 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, (reverse & 0xF0));
80002fd4:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002fd8:	e2 18 00 f0 	andl	r8,0xf0,COH
80002fdc:	10 9b       	mov	r11,r8
80002fde:	fe 7c 28 00 	mov	r12,-55296
80002fe2:	f0 1f 00 09 	mcall	80003004 <dip204_write_byte+0x84>
      Assert( SPI_OK==spi_status );
      /* send D4 to D7 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, ((reverse << 4) & 0xF0));
80002fe6:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002fea:	a5 68       	lsl	r8,0x4
80002fec:	5c 88       	casts.h	r8
80002fee:	5c 78       	castu.h	r8
80002ff0:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002ff4:	10 9b       	mov	r11,r8
80002ff6:	fe 7c 28 00 	mov	r12,-55296
80002ffa:	f0 1f 00 03 	mcall	80003004 <dip204_write_byte+0x84>
      Assert( SPI_OK==spi_status );
      break;
    }
  }
}
80002ffe:	2f dd       	sub	sp,-12
80003000:	e3 cd 80 80 	ldm	sp++,r7,pc
80003004:	80 00       	ld.sh	r0,r0[0x0]
80003006:	37 1a       	mov	r10,113

80003008 <dip204_read_byte>:
 *
 *  \param  byte  Input. byte read from the LCD (D7 .. D0)
 *
 */
static void dip204_read_byte(unsigned char *byte)
{
80003008:	eb cd 40 80 	pushm	r7,lr
8000300c:	1a 97       	mov	r7,sp
8000300e:	20 3d       	sub	sp,12
80003010:	ef 4c ff f4 	st.w	r7[-12],r12
  unsigned short reverse = 0x00;
80003014:	30 08       	mov	r8,0
80003016:	ef 58 ff fa 	st.h	r7[-6],r8

  /* dummy write */
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_write(DIP204_SPI, 0x00);
8000301a:	30 0b       	mov	r11,0
8000301c:	fe 7c 28 00 	mov	r12,-55296
80003020:	f0 1f 00 0f 	mcall	8000305c <dip204_read_byte+0x54>
  Assert( SPI_OK==spi_status );
  /* read RSR register */
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_read(DIP204_SPI, &reverse);
80003024:	ee c8 00 06 	sub	r8,r7,6
80003028:	10 9b       	mov	r11,r8
8000302a:	fe 7c 28 00 	mov	r12,-55296
8000302e:	f0 1f 00 0d 	mcall	80003060 <dip204_read_byte+0x58>
  Assert( SPI_OK==spi_status );
  /* Revert received byte (issued LSB first by the LCD) */
  *byte = bit_reverse8(reverse);
80003032:	ef 08 ff fa 	ld.sh	r8,r7[-6]
80003036:	5c 58       	castu.b	r8
80003038:	ef 48 ff fc 	st.w	r7[-4],r8
8000303c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003040:	5c 98       	brev	r8
80003042:	ef 48 ff fc 	st.w	r7[-4],r8
80003046:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000304a:	b9 88       	lsr	r8,0x18
8000304c:	5c 58       	castu.b	r8
8000304e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003052:	b2 88       	st.b	r9[0x0],r8
}
80003054:	2f dd       	sub	sp,-12
80003056:	e3 cd 80 80 	ldm	sp++,r7,pc
8000305a:	00 00       	add	r0,r0
8000305c:	80 00       	ld.sh	r0,r0[0x0]
8000305e:	37 1a       	mov	r10,113
80003060:	80 00       	ld.sh	r0,r0[0x0]
80003062:	37 72       	mov	r2,119

80003064 <dip204_wait_busy>:

/*! \brief function to wait for LCD becomes not busy
 *
 */
static void dip204_wait_busy(void)
{
80003064:	eb cd 40 80 	pushm	r7,lr
80003068:	1a 97       	mov	r7,sp
8000306a:	20 1d       	sub	sp,4
  unsigned char status = 0x00;
8000306c:	30 08       	mov	r8,0
8000306e:	ef 68 ff ff 	st.b	r7[-1],r8

  /* send read command to LCD */
  dip204_write_byte(DIP204_READ_COMMAND);
80003072:	e0 6c 00 fc 	mov	r12,252
80003076:	f0 1f 00 09 	mcall	80003098 <dip204_wait_busy+0x34>
  /* read next byte */
  do {
  dip204_read_byte(&status);
8000307a:	ee c8 00 01 	sub	r8,r7,1
8000307e:	10 9c       	mov	r12,r8
80003080:	f0 1f 00 07 	mcall	8000309c <dip204_wait_busy+0x38>
  /* keep D7 to know status */
  }while (status & 0x80);
80003084:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003088:	10 99       	mov	r9,r8
8000308a:	30 08       	mov	r8,0
8000308c:	f0 09 18 00 	cp.b	r9,r8
80003090:	cf 55       	brlt	8000307a <dip204_wait_busy+0x16>
}
80003092:	2f fd       	sub	sp,-4
80003094:	e3 cd 80 80 	ldm	sp++,r7,pc
80003098:	80 00       	ld.sh	r0,r0[0x0]
8000309a:	2f 80       	sub	r0,-8
8000309c:	80 00       	ld.sh	r0,r0[0x0]
8000309e:	30 08       	mov	r8,0

800030a0 <adc_configure>:
 * If not called, ADC channels will have side effects
 *
 * \param *adc Base address of the ADC
 */
void adc_configure(volatile avr32_adc_t *adc)
{
800030a0:	eb cd 40 80 	pushm	r7,lr
800030a4:	1a 97       	mov	r7,sp
800030a6:	20 1d       	sub	sp,4
800030a8:	ef 4c ff fc 	st.w	r7[-4],r12
	adc->mr |= 1 << AVR32_ADC_LOWRES_OFFSET;
#endif

	/* Set Sample/Hold time to max so that the ADC capacitor should be
	 * loaded entirely */
	adc->mr |= 0xF << AVR32_ADC_SHTIM_OFFSET;
800030ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030b0:	70 18       	ld.w	r8,r8[0x4]
800030b2:	10 99       	mov	r9,r8
800030b4:	ea 19 0f 00 	orh	r9,0xf00
800030b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030bc:	91 19       	st.w	r8[0x4],r9

	/* Set Startup to max so that the ADC capacitor should be loaded
	 * entirely */
	adc->mr |= 0x1F << AVR32_ADC_STARTUP_OFFSET;
800030be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030c2:	70 18       	ld.w	r8,r8[0x4]
800030c4:	10 99       	mov	r9,r8
800030c6:	ea 19 00 1f 	orh	r9,0x1f
800030ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030ce:	91 19       	st.w	r8[0x4],r9
}
800030d0:	2f fd       	sub	sp,-4
800030d2:	e3 cd 80 80 	ldm	sp++,r7,pc

800030d6 <adc_start>:

/** \brief Start analog to digital conversion
 * \param *adc Base address of the ADC
 */
void adc_start(volatile avr32_adc_t *adc)
{
800030d6:	eb cd 40 80 	pushm	r7,lr
800030da:	1a 97       	mov	r7,sp
800030dc:	20 1d       	sub	sp,4
800030de:	ef 4c ff fc 	st.w	r7[-4],r12
	Assert( adc != NULL );

	/* start conversion */
	adc->cr = AVR32_ADC_START_MASK;
800030e2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030e6:	30 29       	mov	r9,2
800030e8:	91 09       	st.w	r8[0x0],r9
}
800030ea:	2f fd       	sub	sp,-4
800030ec:	e3 cd 80 80 	ldm	sp++,r7,pc

800030f0 <adc_enable>:
 *
 * \param *adc Base address of the ADC
 * \param  channel   channel to enable (0 to 7)
 */
void adc_enable(volatile avr32_adc_t *adc, uint16_t channel)
{
800030f0:	eb cd 40 80 	pushm	r7,lr
800030f4:	1a 97       	mov	r7,sp
800030f6:	20 2d       	sub	sp,8
800030f8:	ef 4c ff fc 	st.w	r7[-4],r12
800030fc:	16 98       	mov	r8,r11
800030fe:	ef 58 ff f8 	st.h	r7[-8],r8
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB ); /* check if channel exist
	                                              **/

	/* enable channel */
	adc->cher = (1 << channel);
80003102:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003106:	30 19       	mov	r9,1
80003108:	f2 08 09 48 	lsl	r8,r9,r8
8000310c:	10 99       	mov	r9,r8
8000310e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003112:	91 49       	st.w	r8[0x10],r9
}
80003114:	2f ed       	sub	sp,-8
80003116:	e3 cd 80 80 	ldm	sp++,r7,pc

8000311a <adc_check_eoc>:
 * \param  channel   channel to check (0 to 7)
 * \return bool      true if conversion not running
 *                   false if conversion running
 */
bool adc_check_eoc(volatile avr32_adc_t *adc, uint16_t channel)
{
8000311a:	eb cd 40 80 	pushm	r7,lr
8000311e:	1a 97       	mov	r7,sp
80003120:	20 2d       	sub	sp,8
80003122:	ef 4c ff fc 	st.w	r7[-4],r12
80003126:	16 98       	mov	r8,r11
80003128:	ef 58 ff f8 	st.h	r7[-8],r8
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB ); /* check if channel exist
	                                              **/

	/* get SR register : EOC bit for channel */
	return ((adc->sr & (1 << channel)) ? true : false);
8000312c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003130:	70 79       	ld.w	r9,r8[0x1c]
80003132:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003136:	30 1a       	mov	r10,1
80003138:	f4 08 09 48 	lsl	r8,r10,r8
8000313c:	f3 e8 00 08 	and	r8,r9,r8
80003140:	5f 18       	srne	r8
80003142:	5c 58       	castu.b	r8
}
80003144:	10 9c       	mov	r12,r8
80003146:	2f ed       	sub	sp,-8
80003148:	e3 cd 80 80 	ldm	sp++,r7,pc

8000314c <adc_get_value>:
 * \param *adc Base address of the ADC
 * \param  channel   channel to handle (0 to 7)
 * \return The value acquired (unsigned long)
 */
uint32_t adc_get_value(volatile avr32_adc_t *adc, uint16_t channel)
{
8000314c:	eb cd 40 80 	pushm	r7,lr
80003150:	1a 97       	mov	r7,sp
80003152:	20 2d       	sub	sp,8
80003154:	ef 4c ff fc 	st.w	r7[-4],r12
80003158:	16 98       	mov	r8,r11
8000315a:	ef 58 ff f8 	st.h	r7[-8],r8
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB );

	/* wait for end of conversion */
	while (adc_check_eoc(adc, channel) != true) {
8000315e:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003162:	10 9b       	mov	r11,r8
80003164:	ee fc ff fc 	ld.w	r12,r7[-4]
80003168:	f0 1f 00 0b 	mcall	80003194 <adc_get_value+0x48>
8000316c:	18 98       	mov	r8,r12
8000316e:	ec 18 00 01 	eorl	r8,0x1
80003172:	5c 58       	castu.b	r8
80003174:	cf 51       	brne	8000315e <adc_get_value+0x12>
	}

	return *((uint32_t *)((&(adc->cdr0)) + channel));
80003176:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000317a:	f0 c9 ff d0 	sub	r9,r8,-48
8000317e:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003182:	a3 68       	lsl	r8,0x2
80003184:	f2 08 00 08 	add	r8,r9,r8
80003188:	70 08       	ld.w	r8,r8[0x0]
}
8000318a:	10 9c       	mov	r12,r8
8000318c:	2f ed       	sub	sp,-8
8000318e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003192:	00 00       	add	r0,r0
80003194:	80 00       	ld.sh	r0,r0[0x0]
80003196:	31 1a       	mov	r10,17

80003198 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80003198:	eb cd 40 80 	pushm	r7,lr
8000319c:	1a 97       	mov	r7,sp
8000319e:	20 1d       	sub	sp,4
800031a0:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
800031a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031a8:	e6 18 00 01 	andh	r8,0x1,COH
800031ac:	5f 08       	sreq	r8
800031ae:	5c 58       	castu.b	r8
}
800031b0:	10 9c       	mov	r12,r8
800031b2:	2f fd       	sub	sp,-4
800031b4:	e3 cd 80 80 	ldm	sp++,r7,pc

800031b8 <pwm_init>:
#include "compiler.h"
#include "pwm.h"


int pwm_init(const pwm_opt_t *opt)
{
800031b8:	eb cd 40 80 	pushm	r7,lr
800031bc:	1a 97       	mov	r7,sp
800031be:	20 3d       	sub	sp,12
800031c0:	ef 4c ff f4 	st.w	r7[-12],r12
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
800031c4:	fe 78 30 00 	mov	r8,-53248
800031c8:	ef 48 ff f8 	st.w	r7[-8],r8
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
800031cc:	e1 b8 00 00 	mfsr	r8,0x0
800031d0:	10 9c       	mov	r12,r8
800031d2:	f0 1f 00 1e 	mcall	80003248 <pwm_init+0x90>
800031d6:	18 98       	mov	r8,r12
800031d8:	ef 68 ff ff 	st.b	r7[-1],r8

  if (opt == 0 ) // Null pointer.
800031dc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800031e0:	58 08       	cp.w	r8,0
800031e2:	c0 31       	brne	800031e8 <pwm_init+0x30>
    return PWM_INVALID_INPUT;
800031e4:	30 18       	mov	r8,1
800031e6:	c2 c8       	rjmp	8000323e <pwm_init+0x86>

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
800031e8:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800031ec:	30 08       	mov	r8,0
800031ee:	f0 09 18 00 	cp.b	r9,r8
800031f2:	c0 20       	breq	800031f6 <pwm_init+0x3e>
800031f4:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
800031f6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800031fa:	37 f9       	mov	r9,127
800031fc:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
800031fe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003202:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
80003204:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003208:	30 08       	mov	r8,0
8000320a:	f0 09 18 00 	cp.b	r9,r8
8000320e:	c0 20       	breq	80003212 <pwm_init+0x5a>
80003210:	d5 03       	csrf	0x10

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
80003212:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003216:	70 19       	ld.w	r9,r8[0x4]
    ((opt->divb)<<AVR32_PWM_DIVB_OFFSET) |
80003218:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000321c:	70 08       	ld.w	r8,r8[0x0]
8000321e:	b1 68       	lsl	r8,0x10
80003220:	10 49       	or	r9,r8
    ((opt->prea)<<AVR32_PWM_PREA_OFFSET) |
80003222:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003226:	70 38       	ld.w	r8,r8[0xc]
80003228:	a9 68       	lsl	r8,0x8
8000322a:	10 49       	or	r9,r8
    ((opt->preb)<<AVR32_PWM_PREB_OFFSET)
8000322c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003230:	70 28       	ld.w	r8,r8[0x8]
80003232:	b9 68       	lsl	r8,0x18
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
80003234:	10 49       	or	r9,r8
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
80003236:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000323a:	91 09       	st.w	r8[0x0],r9
    ((opt->divb)<<AVR32_PWM_DIVB_OFFSET) |
    ((opt->prea)<<AVR32_PWM_PREA_OFFSET) |
    ((opt->preb)<<AVR32_PWM_PREB_OFFSET)
    ;

  return PWM_SUCCESS;
8000323c:	30 08       	mov	r8,0
}
8000323e:	10 9c       	mov	r12,r8
80003240:	2f dd       	sub	sp,-12
80003242:	e3 cd 80 80 	ldm	sp++,r7,pc
80003246:	00 00       	add	r0,r0
80003248:	80 00       	ld.sh	r0,r0[0x0]
8000324a:	31 98       	mov	r8,25

8000324c <pwm_channel_init>:


int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
8000324c:	eb cd 40 80 	pushm	r7,lr
80003250:	1a 97       	mov	r7,sp
80003252:	20 3d       	sub	sp,12
80003254:	ef 4c ff f8 	st.w	r7[-8],r12
80003258:	ef 4b ff f4 	st.w	r7[-12],r11
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
8000325c:	fe 78 30 00 	mov	r8,-53248
80003260:	ef 48 ff fc 	st.w	r7[-4],r8

  if (pwm_channel == 0) // Null pointer.
80003264:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003268:	58 08       	cp.w	r8,0
8000326a:	c0 31       	brne	80003270 <pwm_channel_init+0x24>
    return PWM_INVALID_ARGUMENT;
8000326c:	30 18       	mov	r8,1
8000326e:	c2 f8       	rjmp	800032cc <pwm_channel_init+0x80>
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
80003270:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003274:	58 68       	cp.w	r8,6
80003276:	e0 88 00 04 	brls	8000327e <pwm_channel_init+0x32>
    return PWM_INVALID_INPUT;
8000327a:	30 18       	mov	r8,1
8000327c:	c2 88       	rjmp	800032cc <pwm_channel_init+0x80>

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
8000327e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003282:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003286:	72 09       	ld.w	r9,r9[0x0]
80003288:	ee fa ff fc 	ld.w	r10,r7[-4]
8000328c:	2f 08       	sub	r8,-16
8000328e:	a5 78       	lsl	r8,0x5
80003290:	f4 08 00 08 	add	r8,r10,r8
80003294:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
80003296:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000329a:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000329e:	72 19       	ld.w	r9,r9[0x4]
800032a0:	ee fa ff fc 	ld.w	r10,r7[-4]
800032a4:	a5 78       	lsl	r8,0x5
800032a6:	f4 08 00 08 	add	r8,r10,r8
800032aa:	f0 c8 fd fc 	sub	r8,r8,-516
800032ae:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
800032b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800032b4:	ee f9 ff f4 	ld.w	r9,r7[-12]
800032b8:	72 29       	ld.w	r9,r9[0x8]
800032ba:	ee fa ff fc 	ld.w	r10,r7[-4]
800032be:	a5 78       	lsl	r8,0x5
800032c0:	f4 08 00 08 	add	r8,r10,r8
800032c4:	f0 c8 fd f8 	sub	r8,r8,-520
800032c8:	91 09       	st.w	r8[0x0],r9

  return PWM_SUCCESS;
800032ca:	30 08       	mov	r8,0
}
800032cc:	10 9c       	mov	r12,r8
800032ce:	2f dd       	sub	sp,-12
800032d0:	e3 cd 80 80 	ldm	sp++,r7,pc

800032d4 <pwm_start_channels>:


int pwm_start_channels(unsigned long channels_bitmask)
{
800032d4:	eb cd 40 80 	pushm	r7,lr
800032d8:	1a 97       	mov	r7,sp
800032da:	20 1d       	sub	sp,4
800032dc:	ef 4c ff fc 	st.w	r7[-4],r12
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
800032e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032e4:	e0 18 ff 80 	andl	r8,0xff80
800032e8:	c0 30       	breq	800032ee <pwm_start_channels+0x1a>
    return PWM_INVALID_INPUT;
800032ea:	30 18       	mov	r8,1
800032ec:	c0 78       	rjmp	800032fa <pwm_start_channels+0x26>

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
800032ee:	fe 78 30 00 	mov	r8,-53248
800032f2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800032f6:	91 19       	st.w	r8[0x4],r9

  return PWM_SUCCESS;
800032f8:	30 08       	mov	r8,0
}
800032fa:	10 9c       	mov	r12,r8
800032fc:	2f fd       	sub	sp,-4
800032fe:	e3 cd 80 80 	ldm	sp++,r7,pc

80003302 <getBaudDiv>:
/** The SPI mutex. */
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
80003302:	eb cd 40 80 	pushm	r7,lr
80003306:	1a 97       	mov	r7,sp
80003308:	20 3d       	sub	sp,12
8000330a:	ef 4c ff f8 	st.w	r7[-8],r12
8000330e:	ef 4b ff f4 	st.w	r7[-12],r11
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80003312:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003316:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000331a:	f2 08 00 08 	add	r8,r9,r8
8000331e:	20 18       	sub	r8,1
80003320:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003324:	f0 09 0d 08 	divu	r8,r8,r9
80003328:	ef 48 ff fc 	st.w	r7[-4],r8

	if (baudDiv <= 0 || baudDiv > 255) {
8000332c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003330:	58 08       	cp.w	r8,0
80003332:	c0 70       	breq	80003340 <getBaudDiv+0x3e>
80003334:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003338:	e0 48 00 ff 	cp.w	r8,255
8000333c:	e0 88 00 04 	brls	80003344 <getBaudDiv+0x42>
		return -1;
80003340:	3f f8       	mov	r8,-1
80003342:	c0 48       	rjmp	8000334a <getBaudDiv+0x48>
	}

	return baudDiv;
80003344:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003348:	5c 88       	casts.h	r8
}
8000334a:	10 9c       	mov	r12,r8
8000334c:	2f dd       	sub	sp,-12
8000334e:	e3 cd 80 80 	ldm	sp++,r7,pc

80003352 <spi_initMaster>:
	return SPI_OK;
}

spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
80003352:	eb cd 40 80 	pushm	r7,lr
80003356:	1a 97       	mov	r7,sp
80003358:	20 3d       	sub	sp,12
8000335a:	ef 4c ff f8 	st.w	r7[-8],r12
8000335e:	ef 4b ff f4 	st.w	r7[-12],r11
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80003362:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003366:	f1 39 00 0d 	ld.ub	r9,r8[13]
8000336a:	30 18       	mov	r8,1
8000336c:	f0 09 18 00 	cp.b	r9,r8
80003370:	e0 88 00 04 	brls	80003378 <spi_initMaster+0x26>
		return SPI_ERROR_ARGUMENT;
80003374:	30 28       	mov	r8,2
80003376:	c3 48       	rjmp	800033de <spi_initMaster+0x8c>
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80003378:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000337c:	e0 69 00 80 	mov	r9,128
80003380:	91 09       	st.w	r8[0x0],r9

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80003382:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003386:	70 18       	ld.w	r8,r8[0x4]
80003388:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.mstr = 1;
8000338c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003390:	30 19       	mov	r9,1
80003392:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
80003396:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
8000339a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000339e:	f1 38 00 0d 	ld.ub	r8,r8[13]
800033a2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800033a6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800033aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033ae:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
800033b2:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.llb = 0;
800033b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033ba:	30 09       	mov	r9,0
800033bc:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
800033c0:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800033c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033c8:	30 f9       	mov	r9,15
800033ca:	f1 d9 d2 04 	bfins	r8,r9,0x10,0x4
800033ce:	ef 48 ff fc 	st.w	r7[-4],r8
	spi->mr = u_avr32_spi_mr.mr;
800033d2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800033d6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800033da:	91 19       	st.w	r8[0x4],r9

	return SPI_OK;
800033dc:	30 08       	mov	r8,0
}
800033de:	10 9c       	mov	r12,r8
800033e0:	2f dd       	sub	sp,-12
800033e2:	e3 cd 80 80 	ldm	sp++,r7,pc

800033e6 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800033e6:	eb cd 40 80 	pushm	r7,lr
800033ea:	1a 97       	mov	r7,sp
800033ec:	20 5d       	sub	sp,20
800033ee:	ef 4c ff f8 	st.w	r7[-8],r12
800033f2:	12 98       	mov	r8,r9
800033f4:	16 99       	mov	r9,r11
800033f6:	ef 69 ff f4 	st.b	r7[-12],r9
800033fa:	14 99       	mov	r9,r10
800033fc:	ef 69 ff f0 	st.b	r7[-16],r9
80003400:	ef 68 ff ec 	st.b	r7[-20],r8
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80003404:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80003408:	30 18       	mov	r8,1
8000340a:	f0 09 18 00 	cp.b	r9,r8
8000340e:	e0 8b 00 09 	brhi	80003420 <spi_selectionMode+0x3a>
80003412:	ef 39 ff f0 	ld.ub	r9,r7[-16]
80003416:	30 18       	mov	r8,1
80003418:	f0 09 18 00 	cp.b	r9,r8
8000341c:	e0 88 00 04 	brls	80003424 <spi_selectionMode+0x3e>
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
80003420:	30 28       	mov	r8,2
80003422:	c2 88       	rjmp	80003472 <spi_selectionMode+0x8c>
	}

	u_avr32_spi_mr.mr = spi->mr;
80003424:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003428:	70 18       	ld.w	r8,r8[0x4]
8000342a:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.ps = variable_ps;
8000342e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003432:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003436:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000343a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000343e:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
80003442:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80003446:	ef 38 ff f0 	ld.ub	r8,r7[-16]
8000344a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000344e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003452:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003456:	f1 d9 d0 41 	bfins	r8,r9,0x2,0x1
8000345a:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.dlybcs = delay;
8000345e:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80003462:	ef 68 ff fc 	st.b	r7[-4],r8
	spi->mr = u_avr32_spi_mr.mr;
80003466:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000346a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000346e:	91 19       	st.w	r8[0x4],r9

	return SPI_OK;
80003470:	30 08       	mov	r8,0
}
80003472:	10 9c       	mov	r12,r8
80003474:	2f bd       	sub	sp,-20
80003476:	e3 cd 80 80 	ldm	sp++,r7,pc

8000347a <spi_selectChip>:

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000347a:	eb cd 40 80 	pushm	r7,lr
8000347e:	1a 97       	mov	r7,sp
80003480:	20 2d       	sub	sp,8
80003482:	ef 4c ff fc 	st.w	r7[-4],r12
80003486:	16 98       	mov	r8,r11
80003488:	ef 68 ff f8 	st.b	r7[-8],r8
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000348c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003490:	70 18       	ld.w	r8,r8[0x4]
80003492:	10 99       	mov	r9,r8
80003494:	ea 19 00 0f 	orh	r9,0xf
80003498:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000349c:	91 19       	st.w	r8[0x4],r9

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
8000349e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034a2:	70 18       	ld.w	r8,r8[0x4]
800034a4:	e2 18 00 04 	andl	r8,0x4,COH
800034a8:	c1 90       	breq	800034da <spi_selectChip+0x60>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800034aa:	ef 39 ff f8 	ld.ub	r9,r7[-8]
800034ae:	30 e8       	mov	r8,14
800034b0:	f0 09 18 00 	cp.b	r9,r8
800034b4:	e0 88 00 04 	brls	800034bc <spi_selectChip+0x42>
			return SPI_ERROR_ARGUMENT;
800034b8:	30 28       	mov	r8,2
800034ba:	c2 88       	rjmp	8000350a <spi_selectChip+0x90>
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800034bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034c0:	70 19       	ld.w	r9,r8[0x4]
				(chip << AVR32_SPI_MR_PCS_OFFSET);
800034c2:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800034c6:	b1 68       	lsl	r8,0x10
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800034c8:	ea 18 ff f0 	orh	r8,0xfff0
800034cc:	e8 18 ff ff 	orl	r8,0xffff
800034d0:	10 69       	and	r9,r8
800034d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034d6:	91 19       	st.w	r8[0x4],r9
800034d8:	c1 88       	rjmp	80003508 <spi_selectChip+0x8e>
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800034da:	ef 39 ff f8 	ld.ub	r9,r7[-8]
800034de:	30 38       	mov	r8,3
800034e0:	f0 09 18 00 	cp.b	r9,r8
800034e4:	e0 88 00 04 	brls	800034ec <spi_selectChip+0x72>
			return SPI_ERROR_ARGUMENT;
800034e8:	30 28       	mov	r8,2
800034ea:	c1 08       	rjmp	8000350a <spi_selectChip+0x90>
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800034ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034f0:	70 19       	ld.w	r9,r8[0x4]
800034f2:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800034f6:	2f 08       	sub	r8,-16
800034f8:	30 1a       	mov	r10,1
800034fa:	f4 08 09 48 	lsl	r8,r10,r8
800034fe:	5c d8       	com	r8
80003500:	10 69       	and	r9,r8
80003502:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003506:	91 19       	st.w	r8[0x4],r9
	}

	return SPI_OK;
80003508:	30 08       	mov	r8,0
}
8000350a:	10 9c       	mov	r12,r8
8000350c:	2f ed       	sub	sp,-8
8000350e:	e3 cd 80 80 	ldm	sp++,r7,pc

80003512 <spi_unselectChip>:

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80003512:	eb cd 40 80 	pushm	r7,lr
80003516:	1a 97       	mov	r7,sp
80003518:	20 3d       	sub	sp,12
8000351a:	ef 4c ff f8 	st.w	r7[-8],r12
8000351e:	16 98       	mov	r8,r11
80003520:	ef 68 ff f4 	st.b	r7[-12],r8
	uint32_t timeout = SPI_TIMEOUT;
80003524:	e0 68 3a 98 	mov	r8,15000
80003528:	ef 48 ff fc 	st.w	r7[-4],r8

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000352c:	c0 f8       	rjmp	8000354a <spi_unselectChip+0x38>
		if (!timeout--) {
8000352e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003532:	58 08       	cp.w	r8,0
80003534:	5f 08       	sreq	r8
80003536:	5c 58       	castu.b	r8
80003538:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000353c:	20 19       	sub	r9,1
8000353e:	ef 49 ff fc 	st.w	r7[-4],r9
80003542:	58 08       	cp.w	r8,0
80003544:	c0 30       	breq	8000354a <spi_unselectChip+0x38>
			return SPI_ERROR_TIMEOUT;
80003546:	30 18       	mov	r8,1
80003548:	c1 68       	rjmp	80003574 <spi_unselectChip+0x62>

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000354a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000354e:	70 48       	ld.w	r8,r8[0x10]
80003550:	e2 18 02 00 	andl	r8,0x200,COH
80003554:	ce d0       	breq	8000352e <spi_unselectChip+0x1c>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80003556:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000355a:	70 18       	ld.w	r8,r8[0x4]
8000355c:	10 99       	mov	r9,r8
8000355e:	ea 19 00 0f 	orh	r9,0xf
80003562:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003566:	91 19       	st.w	r8[0x4],r9

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80003568:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000356c:	fc 19 01 00 	movh	r9,0x100
80003570:	91 09       	st.w	r8[0x0],r9

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
#endif

	return SPI_OK;
80003572:	30 08       	mov	r8,0
}
80003574:	10 9c       	mov	r12,r8
80003576:	2f dd       	sub	sp,-12
80003578:	e3 cd 80 80 	ldm	sp++,r7,pc

8000357c <spi_setupChipReg>:

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
8000357c:	eb cd 40 80 	pushm	r7,lr
80003580:	1a 97       	mov	r7,sp
80003582:	20 5d       	sub	sp,20
80003584:	ef 4c ff f4 	st.w	r7[-12],r12
80003588:	ef 4b ff f0 	st.w	r7[-16],r11
8000358c:	ef 4a ff ec 	st.w	r7[-20],r10
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80003590:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003594:	f1 39 00 0c 	ld.ub	r9,r8[12]
80003598:	30 38       	mov	r8,3
8000359a:	f0 09 18 00 	cp.b	r9,r8
8000359e:	e0 8b 00 1d 	brhi	800035d8 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
800035a2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035a6:	f1 39 00 0b 	ld.ub	r9,r8[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800035aa:	30 18       	mov	r8,1
800035ac:	f0 09 18 00 	cp.b	r9,r8
800035b0:	e0 8b 00 14 	brhi	800035d8 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800035b4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035b8:	f1 39 00 08 	ld.ub	r9,r8[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800035bc:	30 78       	mov	r8,7
800035be:	f0 09 18 00 	cp.b	r9,r8
800035c2:	e0 88 00 0b 	brls	800035d8 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800035c6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035ca:	f1 39 00 08 	ld.ub	r9,r8[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800035ce:	31 08       	mov	r8,16
800035d0:	f0 09 18 00 	cp.b	r9,r8
800035d4:	e0 88 00 04 	brls	800035dc <spi_setupChipReg+0x60>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
800035d8:	30 28       	mov	r8,2
800035da:	c8 d8       	rjmp	800036f4 <spi_setupChipReg+0x178>
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800035dc:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035e0:	70 18       	ld.w	r8,r8[0x4]
800035e2:	ee fb ff ec 	ld.w	r11,r7[-20]
800035e6:	10 9c       	mov	r12,r8
800035e8:	f0 1f 00 45 	mcall	800036fc <spi_setupChipReg+0x180>
800035ec:	18 98       	mov	r8,r12
800035ee:	ef 48 ff fc 	st.w	r7[-4],r8

	if (baudDiv < 0) {
800035f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800035f6:	58 08       	cp.w	r8,0
800035f8:	c0 34       	brge	800035fe <spi_setupChipReg+0x82>
		return SPI_ERROR_ARGUMENT;
800035fa:	30 28       	mov	r8,2
800035fc:	c7 c8       	rjmp	800036f4 <spi_setupChipReg+0x178>
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800035fe:	30 08       	mov	r8,0
80003600:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80003604:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003608:	f1 38 00 0c 	ld.ub	r8,r8[12]
8000360c:	a1 98       	lsr	r8,0x1
8000360e:	5c 58       	castu.b	r8
80003610:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003614:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003618:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000361c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
80003620:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80003624:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003628:	f1 38 00 0c 	ld.ub	r8,r8[12]
8000362c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003630:	5f 08       	sreq	r8
80003632:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003636:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000363a:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
8000363e:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80003642:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003646:	f1 38 00 0b 	ld.ub	r8,r8[11]
8000364a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000364e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003652:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003656:	f1 d9 d0 61 	bfins	r8,r9,0x3,0x1
8000365a:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
8000365e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003662:	f1 38 00 08 	ld.ub	r8,r8[8]
80003666:	20 88       	sub	r8,8
80003668:	5c 58       	castu.b	r8
8000366a:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000366e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003672:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003676:	f1 d9 d0 84 	bfins	r8,r9,0x4,0x4
8000367a:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
8000367e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003682:	5c 58       	castu.b	r8
80003684:	ef 68 ff fa 	st.b	r7[-6],r8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80003688:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000368c:	f1 38 00 09 	ld.ub	r8,r8[9]
80003690:	ef 68 ff f9 	st.b	r7[-7],r8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80003694:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003698:	f1 38 00 0a 	ld.ub	r8,r8[10]
8000369c:	ef 68 ff f8 	st.b	r7[-8],r8

	switch (options->reg) {
800036a0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800036a4:	11 88       	ld.ub	r8,r8[0x0]
800036a6:	58 18       	cp.w	r8,1
800036a8:	c1 10       	breq	800036ca <spi_setupChipReg+0x14e>
800036aa:	e0 89 00 05 	brgt	800036b4 <spi_setupChipReg+0x138>
800036ae:	58 08       	cp.w	r8,0
800036b0:	c0 70       	breq	800036be <spi_setupChipReg+0x142>
800036b2:	c1 e8       	rjmp	800036ee <spi_setupChipReg+0x172>
800036b4:	58 28       	cp.w	r8,2
800036b6:	c1 00       	breq	800036d6 <spi_setupChipReg+0x15a>
800036b8:	58 38       	cp.w	r8,3
800036ba:	c1 40       	breq	800036e2 <spi_setupChipReg+0x166>
800036bc:	c1 98       	rjmp	800036ee <spi_setupChipReg+0x172>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800036be:	ee f9 ff f8 	ld.w	r9,r7[-8]
800036c2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036c6:	91 c9       	st.w	r8[0x30],r9
		break;
800036c8:	c1 58       	rjmp	800036f2 <spi_setupChipReg+0x176>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800036ca:	ee f9 ff f8 	ld.w	r9,r7[-8]
800036ce:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036d2:	91 d9       	st.w	r8[0x34],r9
		break;
800036d4:	c0 f8       	rjmp	800036f2 <spi_setupChipReg+0x176>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800036d6:	ee f9 ff f8 	ld.w	r9,r7[-8]
800036da:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036de:	91 e9       	st.w	r8[0x38],r9
		break;
800036e0:	c0 98       	rjmp	800036f2 <spi_setupChipReg+0x176>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800036e2:	ee f9 ff f8 	ld.w	r9,r7[-8]
800036e6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036ea:	91 f9       	st.w	r8[0x3c],r9
		break;
800036ec:	c0 38       	rjmp	800036f2 <spi_setupChipReg+0x176>

	default:
		return SPI_ERROR_ARGUMENT;
800036ee:	30 28       	mov	r8,2
800036f0:	c0 28       	rjmp	800036f4 <spi_setupChipReg+0x178>
			}
		}
	}
#endif

	return SPI_OK;
800036f2:	30 08       	mov	r8,0
}
800036f4:	10 9c       	mov	r12,r8
800036f6:	2f bd       	sub	sp,-20
800036f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800036fc:	80 00       	ld.sh	r0,r0[0x0]
800036fe:	33 02       	mov	r2,48

80003700 <spi_enable>:

void spi_enable(volatile avr32_spi_t *spi)
{
80003700:	eb cd 40 80 	pushm	r7,lr
80003704:	1a 97       	mov	r7,sp
80003706:	20 1d       	sub	sp,4
80003708:	ef 4c ff fc 	st.w	r7[-4],r12
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000370c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003710:	30 19       	mov	r9,1
80003712:	91 09       	st.w	r8[0x0],r9
}
80003714:	2f fd       	sub	sp,-4
80003716:	e3 cd 80 80 	ldm	sp++,r7,pc

8000371a <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000371a:	eb cd 40 80 	pushm	r7,lr
8000371e:	1a 97       	mov	r7,sp
80003720:	20 3d       	sub	sp,12
80003722:	ef 4c ff f8 	st.w	r7[-8],r12
80003726:	16 98       	mov	r8,r11
80003728:	ef 58 ff f4 	st.h	r7[-12],r8
	uint32_t timeout = SPI_TIMEOUT;
8000372c:	e0 68 3a 98 	mov	r8,15000
80003730:	ef 48 ff fc 	st.w	r7[-4],r8

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80003734:	c0 f8       	rjmp	80003752 <spi_write+0x38>
		if (!timeout--) {
80003736:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000373a:	58 08       	cp.w	r8,0
8000373c:	5f 08       	sreq	r8
8000373e:	5c 58       	castu.b	r8
80003740:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003744:	20 19       	sub	r9,1
80003746:	ef 49 ff fc 	st.w	r7[-4],r9
8000374a:	58 08       	cp.w	r8,0
8000374c:	c0 30       	breq	80003752 <spi_write+0x38>
			return SPI_ERROR_TIMEOUT;
8000374e:	30 18       	mov	r8,1
80003750:	c0 d8       	rjmp	8000376a <spi_write+0x50>

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80003752:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003756:	70 48       	ld.w	r8,r8[0x10]
80003758:	e2 18 00 02 	andl	r8,0x2,COH
8000375c:	ce d0       	breq	80003736 <spi_write+0x1c>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000375e:	ef 19 ff f4 	ld.uh	r9,r7[-12]
80003762:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003766:	91 39       	st.w	r8[0xc],r9

	return SPI_OK;
80003768:	30 08       	mov	r8,0
}
8000376a:	10 9c       	mov	r12,r8
8000376c:	2f dd       	sub	sp,-12
8000376e:	e3 cd 80 80 	ldm	sp++,r7,pc

80003772 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80003772:	eb cd 40 80 	pushm	r7,lr
80003776:	1a 97       	mov	r7,sp
80003778:	20 3d       	sub	sp,12
8000377a:	ef 4c ff f8 	st.w	r7[-8],r12
8000377e:	ef 4b ff f4 	st.w	r7[-12],r11
	unsigned int timeout = SPI_TIMEOUT;
80003782:	e0 68 3a 98 	mov	r8,15000
80003786:	ef 48 ff fc 	st.w	r7[-4],r8

	while ((spi->sr &
8000378a:	c0 f8       	rjmp	800037a8 <spi_read+0x36>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
8000378c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003790:	58 08       	cp.w	r8,0
80003792:	5f 08       	sreq	r8
80003794:	5c 58       	castu.b	r8
80003796:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000379a:	20 19       	sub	r9,1
8000379c:	ef 49 ff fc 	st.w	r7[-4],r9
800037a0:	58 08       	cp.w	r8,0
800037a2:	c0 30       	breq	800037a8 <spi_read+0x36>
			return SPI_ERROR_TIMEOUT;
800037a4:	30 18       	mov	r8,1
800037a6:	c1 18       	rjmp	800037c8 <spi_read+0x56>

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800037a8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800037ac:	70 48       	ld.w	r8,r8[0x10]
800037ae:	e2 18 02 01 	andl	r8,0x201,COH
800037b2:	e0 48 02 01 	cp.w	r8,513
800037b6:	ce b1       	brne	8000378c <spi_read+0x1a>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800037b8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800037bc:	70 28       	ld.w	r8,r8[0x8]
800037be:	5c 88       	casts.h	r8
800037c0:	ee f9 ff f4 	ld.w	r9,r7[-12]
800037c4:	b2 08       	st.h	r9[0x0],r8

	return SPI_OK;
800037c6:	30 08       	mov	r8,0
}
800037c8:	10 9c       	mov	r12,r8
800037ca:	2f dd       	sub	sp,-12
800037cc:	e3 cd 80 80 	ldm	sp++,r7,pc

800037d0 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern bool sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
800037d0:	eb cd 40 80 	pushm	r7,lr
800037d4:	1a 97       	mov	r7,sp
	}
#endif

	switch (CONFIG_SYSCLK_SOURCE) {
	case SYSCLK_SRC_RCSYS:
		return OSC_SLOW_NOMINAL_HZ;
800037d6:	e0 78 c2 00 	mov	r8,115200

	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
800037da:	10 9c       	mov	r12,r8
800037dc:	e3 cd 80 80 	ldm	sp++,r7,pc

800037e0 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
800037e0:	eb cd 40 80 	pushm	r7,lr
800037e4:	1a 97       	mov	r7,sp
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_CPU_DIV;
800037e6:	f0 1f 00 04 	mcall	800037f4 <sysclk_get_cpu_hz+0x14>
800037ea:	18 98       	mov	r8,r12
}
800037ec:	10 9c       	mov	r12,r8
800037ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800037f2:	00 00       	add	r0,r0
800037f4:	80 00       	ld.sh	r0,r0[0x0]
800037f6:	37 d0       	mov	r0,125

800037f8 <display_init>:

// Include Files
#include "display_init.h"

void display_init(void)
{
800037f8:	eb cd 40 8f 	pushm	r0-r3,r7,lr
800037fc:	1a 97       	mov	r7,sp
800037fe:	21 0d       	sub	sp,64
	volatile avr32_pm_t* pm = &AVR32_PM;
80003800:	fe 78 0c 00 	mov	r8,-62464
80003804:	ef 48 ff dc 	st.w	r7[-36],r8
	   .spck_delay           = 0,
	   .trans_delay  		 = 8,
	   .stay_act             = 1,
	   .spi_mode             = 0,
	   .modfdis              = 1
	};
80003808:	4f 68       	lddpc	r8,800039e0 <display_init+0x1e8>
8000380a:	ee ca 00 34 	sub	r10,r7,52
8000380e:	10 9b       	mov	r11,r8
80003810:	f6 e8 00 00 	ld.d	r8,r11[0]
80003814:	f4 e9 00 00 	st.d	r10[0],r8
80003818:	f6 e8 00 08 	ld.d	r8,r11[8]
8000381c:	f4 e9 00 08 	st.d	r10[8],r8

	// Switch clock to external 12 MHz crystal
	// 1) Configure OSC0 in crystal mode, external crystal with a FOSC0 Hz frequency.
	pm_enable_osc0_crystal(pm, FOSC0);
80003820:	e0 6b 1b 00 	mov	r11,6912
80003824:	ea 1b 00 b7 	orh	r11,0xb7
80003828:	ee fc ff dc 	ld.w	r12,r7[-36]
8000382c:	f0 1f 00 6e 	mcall	800039e4 <display_init+0x1ec>

	// 2) Enable the OSC0
	pm_enable_clk0(pm, OSC0_STARTUP);
80003830:	30 3b       	mov	r11,3
80003832:	ee fc ff dc 	ld.w	r12,r7[-36]
80003836:	f0 1f 00 6d 	mcall	800039e8 <display_init+0x1f0>

	// 3) Set the main clock source as being OSC0.
	pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
8000383a:	30 1b       	mov	r11,1
8000383c:	ee fc ff dc 	ld.w	r12,r7[-36]
80003840:	f0 1f 00 6b 	mcall	800039ec <display_init+0x1f4>

	// Initialize the delay function
	delay_init(12000000);
	// Delay for a ms, to allow the display to power up properly
	delay_ms(1);
80003844:	f0 1f 00 6b 	mcall	800039f0 <display_init+0x1f8>
80003848:	18 98       	mov	r8,r12
8000384a:	30 19       	mov	r9,1
8000384c:	ef 49 ff e4 	st.w	r7[-28],r9
80003850:	ef 48 ff e0 	st.w	r7[-32],r8
80003854:	ee f8 ff e4 	ld.w	r8,r7[-28]
80003858:	ef 48 ff ec 	st.w	r7[-20],r8
8000385c:	ee f8 ff e0 	ld.w	r8,r7[-32]
80003860:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003864:	ee f0 ff ec 	ld.w	r0,r7[-20]
80003868:	30 01       	mov	r1,0
8000386a:	ee f2 ff e8 	ld.w	r2,r7[-24]
8000386e:	30 03       	mov	r3,0
80003870:	e2 02 02 4a 	mul	r10,r1,r2
80003874:	e6 00 02 48 	mul	r8,r3,r0
80003878:	10 0a       	add	r10,r8
8000387a:	e0 02 06 48 	mulu.d	r8,r0,r2
8000387e:	12 0a       	add	r10,r9
80003880:	14 99       	mov	r9,r10
80003882:	e0 6a 03 e7 	mov	r10,999
80003886:	30 0b       	mov	r11,0
80003888:	f0 0a 00 0a 	add	r10,r8,r10
8000388c:	f2 0b 00 4b 	adc	r11,r9,r11
80003890:	e0 68 03 e8 	mov	r8,1000
80003894:	30 09       	mov	r9,0
80003896:	f0 1f 00 58 	mcall	800039f4 <display_init+0x1fc>
8000389a:	14 98       	mov	r8,r10
8000389c:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000389e:	ef 48 ff f4 	st.w	r7[-12],r8
800038a2:	ee c8 00 40 	sub	r8,r7,64
800038a6:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800038aa:	e1 b8 00 42 	mfsr	r8,0x108
800038ae:	10 99       	mov	r9,r8
800038b0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800038b4:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800038b6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800038ba:	70 09       	ld.w	r9,r8[0x0]
800038bc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800038c0:	10 09       	add	r9,r8
800038c2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800038c6:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800038c8:	ee f9 ff f0 	ld.w	r9,r7[-16]
800038cc:	30 08       	mov	r8,0
800038ce:	f3 68 00 08 	st.b	r9[8],r8
800038d2:	ee c8 00 40 	sub	r8,r7,64
800038d6:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800038da:	e1 b8 00 42 	mfsr	r8,0x108
800038de:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800038e2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800038e6:	f1 39 00 08 	ld.ub	r9,r8[8]
800038ea:	30 28       	mov	r8,2
800038ec:	f0 09 18 00 	cp.b	r9,r8
800038f0:	c0 31       	brne	800038f6 <display_init+0xfe>
    return false;
800038f2:	30 08       	mov	r8,0
800038f4:	c4 38       	rjmp	8000397a <display_init+0x182>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800038f6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800038fa:	f1 39 00 08 	ld.ub	r9,r8[8]
800038fe:	30 18       	mov	r8,1
80003900:	f0 09 18 00 	cp.b	r9,r8
80003904:	c0 31       	brne	8000390a <display_init+0x112>
    return true;
80003906:	30 18       	mov	r8,1
80003908:	c3 98       	rjmp	8000397a <display_init+0x182>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000390a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000390e:	70 09       	ld.w	r9,r8[0x0]
80003910:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003914:	70 18       	ld.w	r8,r8[0x4]
80003916:	10 39       	cp.w	r9,r8
80003918:	e0 88 00 1a 	brls	8000394c <display_init+0x154>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000391c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003920:	70 08       	ld.w	r8,r8[0x0]
80003922:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003926:	10 39       	cp.w	r9,r8
80003928:	c1 02       	brcc	80003948 <display_init+0x150>
8000392a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000392e:	70 18       	ld.w	r8,r8[0x4]
80003930:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003934:	10 39       	cp.w	r9,r8
80003936:	e0 88 00 09 	brls	80003948 <display_init+0x150>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000393a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000393e:	30 18       	mov	r8,1
80003940:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80003944:	30 18       	mov	r8,1
80003946:	c1 a8       	rjmp	8000397a <display_init+0x182>
    }
    return false;
80003948:	30 08       	mov	r8,0
8000394a:	c1 88       	rjmp	8000397a <display_init+0x182>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000394c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003950:	70 08       	ld.w	r8,r8[0x0]
80003952:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003956:	10 39       	cp.w	r9,r8
80003958:	c0 93       	brcs	8000396a <display_init+0x172>
8000395a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000395e:	70 18       	ld.w	r8,r8[0x4]
80003960:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003964:	10 39       	cp.w	r9,r8
80003966:	e0 88 00 09 	brls	80003978 <display_init+0x180>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000396a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000396e:	30 18       	mov	r8,1
80003970:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80003974:	30 18       	mov	r8,1
80003976:	c0 28       	rjmp	8000397a <display_init+0x182>
    }
    return false;
80003978:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
8000397a:	58 08       	cp.w	r8,0
8000397c:	ca b0       	breq	800038d2 <display_init+0xda>

	// Enable the SPI peripheral on GPIO pins
	gpio_enable_module(DIP204_SPI_GPIO_MAP,
8000397e:	30 4b       	mov	r11,4
80003980:	49 ec       	lddpc	r12,800039f8 <display_init+0x200>
80003982:	f0 1f 00 1f 	mcall	800039fc <display_init+0x204>
						sizeof(DIP204_SPI_GPIO_MAP) / 	sizeof(DIP204_SPI_GPIO_MAP[0]));

	// Initialize as SPI master
	spi_initMaster(DIP204_SPI, &spiOptions);
80003986:	ee c8 00 34 	sub	r8,r7,52
8000398a:	10 9b       	mov	r11,r8
8000398c:	fe 7c 28 00 	mov	r12,-55296
80003990:	f0 1f 00 1c 	mcall	80003a00 <display_init+0x208>
	spi_selectionMode(DIP204_SPI, 0, 0, 0);
80003994:	30 09       	mov	r9,0
80003996:	30 0a       	mov	r10,0
80003998:	30 0b       	mov	r11,0
8000399a:	fe 7c 28 00 	mov	r12,-55296
8000399e:	f0 1f 00 1a 	mcall	80003a04 <display_init+0x20c>
	spi_enable(DIP204_SPI);
800039a2:	fe 7c 28 00 	mov	r12,-55296
800039a6:	f0 1f 00 19 	mcall	80003a08 <display_init+0x210>
	spi_setupChipReg(DIP204_SPI, &spiOptions, FOSC0);
800039aa:	ee c8 00 34 	sub	r8,r7,52
800039ae:	e0 6a 1b 00 	mov	r10,6912
800039b2:	ea 1a 00 b7 	orh	r10,0xb7
800039b6:	10 9b       	mov	r11,r8
800039b8:	fe 7c 28 00 	mov	r12,-55296
800039bc:	f0 1f 00 14 	mcall	80003a0c <display_init+0x214>

	dip204_init(backlight_IO, ON);
800039c0:	30 1b       	mov	r11,1
800039c2:	30 0c       	mov	r12,0
800039c4:	f0 1f 00 13 	mcall	80003a10 <display_init+0x218>
	dip204_clear_display();
800039c8:	f0 1f 00 13 	mcall	80003a14 <display_init+0x21c>
	dip204_hide_cursor();
800039cc:	f0 1f 00 13 	mcall	80003a18 <display_init+0x220>
	dip204_set_cursor_position(1,1);
800039d0:	30 1b       	mov	r11,1
800039d2:	30 1c       	mov	r12,1
800039d4:	f0 1f 00 12 	mcall	80003a1c <display_init+0x224>
}
800039d8:	2f 0d       	sub	sp,-64
800039da:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
800039de:	00 00       	add	r0,r0
800039e0:	80 00       	ld.sh	r0,r0[0x0]
800039e2:	c4 18       	rjmp	80003a64 <initLED+0x44>
800039e4:	80 00       	ld.sh	r0,r0[0x0]
800039e6:	46 28       	lddsp	r8,sp[0x188]
800039e8:	80 00       	ld.sh	r0,r0[0x0]
800039ea:	46 8c       	lddsp	r12,sp[0x1a0]
800039ec:	80 00       	ld.sh	r0,r0[0x0]
800039ee:	47 38       	lddsp	r8,sp[0x1cc]
800039f0:	80 00       	ld.sh	r0,r0[0x0]
800039f2:	37 e0       	mov	r0,126
800039f4:	80 00       	ld.sh	r0,r0[0x0]
800039f6:	66 2c       	ld.w	r12,r3[0x8]
800039f8:	80 00       	ld.sh	r0,r0[0x0]
800039fa:	c4 28       	rjmp	80003a7e <initLED+0x5e>
800039fc:	80 00       	ld.sh	r0,r0[0x0]
800039fe:	41 94       	lddsp	r4,sp[0x64]
80003a00:	80 00       	ld.sh	r0,r0[0x0]
80003a02:	33 52       	mov	r2,53
80003a04:	80 00       	ld.sh	r0,r0[0x0]
80003a06:	33 e6       	mov	r6,62
80003a08:	80 00       	ld.sh	r0,r0[0x0]
80003a0a:	37 00       	mov	r0,112
80003a0c:	80 00       	ld.sh	r0,r0[0x0]
80003a0e:	35 7c       	mov	r12,87
80003a10:	80 00       	ld.sh	r0,r0[0x0]
80003a12:	21 08       	sub	r8,16
80003a14:	80 00       	ld.sh	r0,r0[0x0]
80003a16:	2c a0       	sub	r0,-54
80003a18:	80 00       	ld.sh	r0,r0[0x0]
80003a1a:	2b e4       	sub	r4,-66
80003a1c:	80 00       	ld.sh	r0,r0[0x0]
80003a1e:	2c 18       	sub	r8,-63

80003a20 <initLED>:
#include "LED.h"

void initLED (void)
{
80003a20:	eb cd 40 80 	pushm	r7,lr
80003a24:	1a 97       	mov	r7,sp
80003a26:	20 1d       	sub	sp,4
	/*
	* First make access to the GPIO port registers
	* shorter to type , just for our convenience
	*/
	volatile avr32_gpio_port_t * led0_port;
	led0_port = &AVR32_GPIO.port[LED0_PORT];
80003a28:	fe 78 11 00 	mov	r8,-61184
80003a2c:	ef 48 ff fc 	st.w	r7[-4],r8
	/*
	* Choose GPIO peripheral function ,
	* by writing a 1 to gpers , GPIO Enable Register Set
	*/
	led0_port->gpers = LED0_BIT_VALUE;
80003a30:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a34:	fc 19 08 00 	movh	r9,0x800
80003a38:	91 19       	st.w	r8[0x4],r9
	led0_port->gpers = LED1_BIT_VALUE;
80003a3a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a3e:	fc 19 10 00 	movh	r9,0x1000
80003a42:	91 19       	st.w	r8[0x4],r9
	led0_port->gpers = LED2_BIT_VALUE;
80003a44:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a48:	fc 19 20 00 	movh	r9,0x2000
80003a4c:	91 19       	st.w	r8[0x4],r9
	/*
	* Set the output value register to 1 in order to
	* turn the LED off (1= off , 0= on in this case ) ,
	* by writing a 1 to ovrs , Output Value Register Set
	*/
	led0_port->ovrs = LED0_BIT_VALUE;
80003a4e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a52:	fc 19 08 00 	movh	r9,0x800
80003a56:	f1 49 00 54 	st.w	r8[84],r9
	led0_port->ovrs = LED1_BIT_VALUE;
80003a5a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a5e:	fc 19 10 00 	movh	r9,0x1000
80003a62:	f1 49 00 54 	st.w	r8[84],r9
	led0_port->ovrs = LED2_BIT_VALUE;
80003a66:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a6a:	fc 19 20 00 	movh	r9,0x2000
80003a6e:	f1 49 00 54 	st.w	r8[84],r9
	/*
	* Set the output enable register ,
	* by writing a 1 to oders , Output Drive Enable
	* Register Set
	*/
	led0_port->oders = LED0_BIT_VALUE;
80003a72:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a76:	fc 19 08 00 	movh	r9,0x800
80003a7a:	f1 49 00 44 	st.w	r8[68],r9
	led0_port->oders = LED1_BIT_VALUE;
80003a7e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a82:	fc 19 10 00 	movh	r9,0x1000
80003a86:	f1 49 00 44 	st.w	r8[68],r9
	led0_port->oders = LED2_BIT_VALUE;
80003a8a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a8e:	fc 19 20 00 	movh	r9,0x2000
80003a92:	f1 49 00 44 	st.w	r8[68],r9
}
80003a96:	2f fd       	sub	sp,-4
80003a98:	e3 cd 80 80 	ldm	sp++,r7,pc

80003a9c <onLED>:
{
	AVR32_GPIO.port[LED0_PORT].ovrt = ledNr;
}

void onLED(int ledNr)
{
80003a9c:	eb cd 40 80 	pushm	r7,lr
80003aa0:	1a 97       	mov	r7,sp
80003aa2:	20 1d       	sub	sp,4
80003aa4:	ef 4c ff fc 	st.w	r7[-4],r12
	AVR32_GPIO.port[LED0_PORT].ovrc = ledNr;
80003aa8:	fe 78 10 00 	mov	r8,-61440
80003aac:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003ab0:	f1 49 01 58 	st.w	r8[344],r9
}
80003ab4:	2f fd       	sub	sp,-4
80003ab6:	e3 cd 80 80 	ldm	sp++,r7,pc

80003aba <offLED>:

void offLED(int ledNr)
{
80003aba:	eb cd 40 80 	pushm	r7,lr
80003abe:	1a 97       	mov	r7,sp
80003ac0:	20 1d       	sub	sp,4
80003ac2:	ef 4c ff fc 	st.w	r7[-4],r12
	AVR32_GPIO.port[LED0_PORT].ovrs = ledNr;
80003ac6:	fe 78 10 00 	mov	r8,-61440
80003aca:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003ace:	f1 49 01 54 	st.w	r8[340],r9
80003ad2:	2f fd       	sub	sp,-4
80003ad4:	e3 cd 80 80 	ldm	sp++,r7,pc
80003ad8:	54 65       	stdsp	sp[0x118],r5
80003ada:	6d 70       	ld.w	r0,r6[0x5c]
80003adc:	65 72       	ld.w	r2,r2[0x5c]
80003ade:	61 74       	ld.w	r4,r0[0x5c]
80003ae0:	75 72       	ld.w	r2,r10[0x5c]
80003ae2:	65 3a       	ld.w	r10,r2[0x4c]
80003ae4:	00 00       	add	r0,r0
80003ae6:	00 00       	add	r0,r0
80003ae8:	50 6f       	stdsp	sp[0x18],pc
80003aea:	74 65       	ld.w	r5,r10[0x18]
80003aec:	6e 74       	ld.w	r4,r7[0x1c]
80003aee:	69 6f       	ld.w	pc,r4[0x58]
80003af0:	6d 65       	ld.w	r5,r6[0x58]
80003af2:	74 65       	ld.w	r5,r10[0x18]
80003af4:	72 3a       	ld.w	r10,r9[0xc]
80003af6:	00 00       	add	r0,r0
80003af8:	4c 69       	lddpc	r9,80003c10 <vTemperature+0x6c>
80003afa:	67 68       	ld.w	r8,r3[0x58]
80003afc:	74 3a       	ld.w	r10,r10[0xc]
80003afe:	00 00       	add	r0,r0
80003b00:	25 30       	sub	r0,83
80003b02:	34 64       	mov	r4,70
80003b04:	00 00       	add	r0,r0
80003b06:	00 00       	add	r0,r0
80003b08:	76 43       	ld.w	r3,r11[0x10]
80003b0a:	6f 6e       	ld.w	lr,r7[0x58]
80003b0c:	73 75       	ld.w	r5,r9[0x5c]
80003b0e:	6d 65       	ld.w	r5,r6[0x58]
80003b10:	72 00       	ld.w	r0,r9[0x0]
80003b12:	00 00       	add	r0,r0
80003b14:	76 54       	ld.w	r4,r11[0x14]
80003b16:	65 6d       	ld.w	sp,r2[0x58]
80003b18:	70 65       	ld.w	r5,r8[0x18]
80003b1a:	72 61       	ld.w	r1,r9[0x18]
80003b1c:	74 75       	ld.w	r5,r10[0x1c]
80003b1e:	72 65       	ld.w	r5,r9[0x18]
80003b20:	00 00       	add	r0,r0
80003b22:	00 00       	add	r0,r0
80003b24:	76 50       	ld.w	r0,r11[0x14]
80003b26:	6f 74       	ld.w	r4,r7[0x5c]
80003b28:	65 6e       	ld.w	lr,r2[0x58]
80003b2a:	74 69       	ld.w	r9,r10[0x18]
80003b2c:	6f 6d       	ld.w	sp,r7[0x58]
80003b2e:	65 74       	ld.w	r4,r2[0x5c]
80003b30:	65 72       	ld.w	r2,r2[0x5c]
80003b32:	00 00       	add	r0,r0
80003b34:	76 4c       	ld.w	r12,r11[0x10]
80003b36:	69 67       	ld.w	r7,r4[0x58]
80003b38:	68 74       	ld.w	r4,r4[0x1c]
	...

80003b3c <init_usart>:
xTaskHandle xHandleTemperature;		// Task handle - Temperature
xTaskHandle xHandlePotentiometer;	// Task handle - Potentiometer
xTaskHandle xHandleLight;			// Task handle - Light

void init_usart ( void )
{
80003b3c:	eb cd 40 80 	pushm	r7,lr
80003b40:	1a 97       	mov	r7,sp
		. charlength = 8,
		. paritytype = USART_NO_PARITY ,
		. stopbits = USART_1_STOPBIT ,
		. channelmode = USART_NORMAL_CHMODE
	};
	pm_switch_to_osc0 (& AVR32_PM , FOSC0 , OSC0_STARTUP );				// Switch to 12 MHz clock
80003b42:	30 3a       	mov	r10,3
80003b44:	e0 6b 1b 00 	mov	r11,6912
80003b48:	ea 1b 00 b7 	orh	r11,0xb7
80003b4c:	fe 7c 0c 00 	mov	r12,-62464
80003b50:	f0 1f 00 0f 	mcall	80003b8c <init_usart+0x50>
	gpio_enable_module ( USART_SERIAL_GPIO_MAP , 2);					// Enable usart
80003b54:	30 2b       	mov	r11,2
80003b56:	48 fc       	lddpc	r12,80003b90 <init_usart+0x54>
80003b58:	f0 1f 00 0f 	mcall	80003b94 <init_usart+0x58>
	gpio_enable_module ( USART_DEBUG_GPIO_MAP , 2);
80003b5c:	30 2b       	mov	r11,2
80003b5e:	48 fc       	lddpc	r12,80003b98 <init_usart+0x5c>
80003b60:	f0 1f 00 0d 	mcall	80003b94 <init_usart+0x58>
	usart_init_rs232 ( serialPORT_USART , & USART_OPTIONS , FOSC0 );	// Usart options
80003b64:	e0 6a 1b 00 	mov	r10,6912
80003b68:	ea 1a 00 b7 	orh	r10,0xb7
80003b6c:	48 cb       	lddpc	r11,80003b9c <init_usart+0x60>
80003b6e:	fe 7c 18 00 	mov	r12,-59392
80003b72:	f0 1f 00 0c 	mcall	80003ba0 <init_usart+0x64>
	usart_init_rs232 ( configDBG_USART , & USART_OPTIONS , FOSC0 );
80003b76:	e0 6a 1b 00 	mov	r10,6912
80003b7a:	ea 1a 00 b7 	orh	r10,0xb7
80003b7e:	48 8b       	lddpc	r11,80003b9c <init_usart+0x60>
80003b80:	fe 7c 18 00 	mov	r12,-59392
80003b84:	f0 1f 00 07 	mcall	80003ba0 <init_usart+0x64>
}
80003b88:	e3 cd 80 80 	ldm	sp++,r7,pc
80003b8c:	80 00       	ld.sh	r0,r0[0x0]
80003b8e:	47 84       	lddsp	r4,sp[0x1e0]
80003b90:	80 00       	ld.sh	r0,r0[0x0]
80003b92:	c4 48       	rjmp	80003c1a <vTemperature+0x76>
80003b94:	80 00       	ld.sh	r0,r0[0x0]
80003b96:	41 94       	lddsp	r4,sp[0x64]
80003b98:	80 00       	ld.sh	r0,r0[0x0]
80003b9a:	c4 58       	rjmp	80003c24 <vTemperature+0x80>
80003b9c:	80 00       	ld.sh	r0,r0[0x0]
80003b9e:	c4 68       	rjmp	80003c2a <vTemperature+0x86>
80003ba0:	80 00       	ld.sh	r0,r0[0x0]
80003ba2:	49 34       	lddpc	r4,80003bec <vTemperature+0x48>

80003ba4 <vTemperature>:

void vTemperature(void *pvParameters)
{
80003ba4:	eb cd 40 80 	pushm	r7,lr
80003ba8:	1a 97       	mov	r7,sp
80003baa:	20 2d       	sub	sp,8
80003bac:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile uint32_t value_to_send;		// Character to send to Consumer
	
	onLED(LED0_BIT_VALUE);	// On when the temp-producer is active
80003bb0:	fc 1c 08 00 	movh	r12,0x800
80003bb4:	f0 1f 00 1a 	mcall	80003c1c <vTemperature+0x78>
	
	while(1)
	{
		offLED(LED0_BIT_VALUE);
80003bb8:	fc 1c 08 00 	movh	r12,0x800
80003bbc:	f0 1f 00 19 	mcall	80003c20 <vTemperature+0x7c>
		if(xSemaphoreTake(xEmptyCountTemperature, (portTickType)portMAX_DELAY) == pdTRUE)
80003bc0:	49 98       	lddpc	r8,80003c24 <vTemperature+0x80>
80003bc2:	70 08       	ld.w	r8,r8[0x0]
80003bc4:	30 09       	mov	r9,0
80003bc6:	3f fa       	mov	r10,-1
80003bc8:	30 0b       	mov	r11,0
80003bca:	10 9c       	mov	r12,r8
80003bcc:	f0 1f 00 17 	mcall	80003c28 <vTemperature+0x84>
		{
			// Semaphore taken
		}
		onLED(LED0_BIT_VALUE);
80003bd0:	fc 1c 08 00 	movh	r12,0x800
80003bd4:	f0 1f 00 12 	mcall	80003c1c <vTemperature+0x78>
		adc_start(&AVR32_ADC);
80003bd8:	fe 7c 3c 00 	mov	r12,-50176
80003bdc:	f0 1f 00 14 	mcall	80003c2c <vTemperature+0x88>
		value_to_send = adc_get_value(&AVR32_ADC, ADC_TEMPERATURE_CHANNEL);
80003be0:	30 0b       	mov	r11,0
80003be2:	fe 7c 3c 00 	mov	r12,-50176
80003be6:	f0 1f 00 13 	mcall	80003c30 <vTemperature+0x8c>
80003bea:	18 98       	mov	r8,r12
80003bec:	ef 48 ff fc 	st.w	r7[-4],r8
		xQueueSendToBack(xQHandleTemperature, &value_to_send, (portTickType)portMAX_DELAY);
80003bf0:	49 18       	lddpc	r8,80003c34 <vTemperature+0x90>
80003bf2:	70 08       	ld.w	r8,r8[0x0]
80003bf4:	ee cb 00 04 	sub	r11,r7,4
80003bf8:	30 09       	mov	r9,0
80003bfa:	3f fa       	mov	r10,-1
80003bfc:	10 9c       	mov	r12,r8
80003bfe:	f0 1f 00 0f 	mcall	80003c38 <vTemperature+0x94>
		
		if(xSemaphoreGive(xFillCountTemperature) == pdTRUE)
80003c02:	48 f8       	lddpc	r8,80003c3c <vTemperature+0x98>
80003c04:	70 08       	ld.w	r8,r8[0x0]
80003c06:	30 09       	mov	r9,0
80003c08:	30 0a       	mov	r10,0
80003c0a:	30 0b       	mov	r11,0
80003c0c:	10 9c       	mov	r12,r8
80003c0e:	f0 1f 00 0b 	mcall	80003c38 <vTemperature+0x94>
		// ADCClock = CLK_ADC / ( (PRESCAL+1) * 2 ) where PRESCAL = 0 => ADCClock = CLK_ADC / 2
		// IF CLK_ADC = 12 MHz => ADDClock = 6 MHz => Sample hold time = 16/6MHz = 0.00000267, Startup time = 32 * 8 / 6MHz = 0,00004267
		// Sample hold time + Startup time = 0,00004534
		// (Sample hold time + Startup time) * 12MHz = 544
		// IF CLK_ADC = 115200Hz => (Sample hold time + Startup time) * 115200 = (0,0002778 + 0,00444) * 115200 = 543.49
		vTaskDelay(1000);
80003c12:	e0 6c 03 e8 	mov	r12,1000
80003c16:	f0 1f 00 0b 	mcall	80003c40 <vTemperature+0x9c>
	}
80003c1a:	cc fb       	rjmp	80003bb8 <vTemperature+0x14>
80003c1c:	80 00       	ld.sh	r0,r0[0x0]
80003c1e:	3a 9c       	mov	r12,-87
80003c20:	80 00       	ld.sh	r0,r0[0x0]
80003c22:	3a ba       	mov	r10,-85
80003c24:	00 00       	add	r0,r0
80003c26:	07 e0       	ld.ub	r0,r3[0x6]
80003c28:	80 00       	ld.sh	r0,r0[0x0]
80003c2a:	56 44       	stdsp	sp[0x190],r4
80003c2c:	80 00       	ld.sh	r0,r0[0x0]
80003c2e:	30 d6       	mov	r6,13
80003c30:	80 00       	ld.sh	r0,r0[0x0]
80003c32:	31 4c       	mov	r12,20
80003c34:	00 00       	add	r0,r0
80003c36:	08 00       	add	r0,r4
80003c38:	80 00       	ld.sh	r0,r0[0x0]
80003c3a:	54 dc       	stdsp	sp[0x134],r12
80003c3c:	00 00       	add	r0,r0
80003c3e:	07 d8       	ld.ub	r8,r3[0x5]
80003c40:	80 00       	ld.sh	r0,r0[0x0]
80003c42:	5c 50       	castu.b	r0

80003c44 <vPotentiometer>:
}

void vPotentiometer(void *pvParameters)
{
80003c44:	eb cd 40 80 	pushm	r7,lr
80003c48:	1a 97       	mov	r7,sp
80003c4a:	20 4d       	sub	sp,16
80003c4c:	ef 4c ff f0 	st.w	r7[-16],r12
	volatile portTickType xLastWakeTime; // Holds tick count
	volatile const portTickType xFreq = TASK_DELAY_MS(1000); // Holds the period		
80003c50:	e0 68 03 e8 	mov	r8,1000
80003c54:	ef 48 ff f8 	st.w	r7[-8],r8
	//volatile const portTickType xFreq = 544; // Holds the period	
	volatile uint32_t value_to_send;		// Character to send to Consumer
	
	onLED(LED1_BIT_VALUE);	// On when the temp-producer is active
80003c58:	fc 1c 10 00 	movh	r12,0x1000
80003c5c:	f0 1f 00 1d 	mcall	80003cd0 <vPotentiometer+0x8c>
	
	while(1)
	{		
		offLED(LED1_BIT_VALUE);
80003c60:	fc 1c 10 00 	movh	r12,0x1000
80003c64:	f0 1f 00 1c 	mcall	80003cd4 <vPotentiometer+0x90>
		if(xSemaphoreTake(xEmptyCountPotentiometer, (portTickType)portMAX_DELAY) == pdTRUE)
80003c68:	49 c8       	lddpc	r8,80003cd8 <vPotentiometer+0x94>
80003c6a:	70 08       	ld.w	r8,r8[0x0]
80003c6c:	30 09       	mov	r9,0
80003c6e:	3f fa       	mov	r10,-1
80003c70:	30 0b       	mov	r11,0
80003c72:	10 9c       	mov	r12,r8
80003c74:	f0 1f 00 1a 	mcall	80003cdc <vPotentiometer+0x98>
		}
		/*if (xTaskGetTickCount() > (xLastWakeTime + xFreq))
		{
			usart_write_line(serialPORT_USART, "Deadline miss - Potentiometer");
		}*/
		xLastWakeTime = xTaskGetTickCount(); // Sets current tick count
80003c78:	f0 1f 00 1a 	mcall	80003ce0 <vPotentiometer+0x9c>
80003c7c:	18 98       	mov	r8,r12
80003c7e:	ef 48 ff fc 	st.w	r7[-4],r8
		onLED(LED1_BIT_VALUE);
80003c82:	fc 1c 10 00 	movh	r12,0x1000
80003c86:	f0 1f 00 13 	mcall	80003cd0 <vPotentiometer+0x8c>
		adc_start(&AVR32_ADC);
80003c8a:	fe 7c 3c 00 	mov	r12,-50176
80003c8e:	f0 1f 00 16 	mcall	80003ce4 <vPotentiometer+0xa0>
		value_to_send = adc_get_value(&AVR32_ADC, ADC_POTENTIOMETER_CHANNEL);
80003c92:	30 1b       	mov	r11,1
80003c94:	fe 7c 3c 00 	mov	r12,-50176
80003c98:	f0 1f 00 14 	mcall	80003ce8 <vPotentiometer+0xa4>
80003c9c:	18 98       	mov	r8,r12
80003c9e:	ef 48 ff f4 	st.w	r7[-12],r8
		xQueueSendToBack(xQHandlePotentiometer, &value_to_send, (portTickType)portMAX_DELAY);
80003ca2:	49 38       	lddpc	r8,80003cec <vPotentiometer+0xa8>
80003ca4:	70 08       	ld.w	r8,r8[0x0]
80003ca6:	ee cb 00 0c 	sub	r11,r7,12
80003caa:	30 09       	mov	r9,0
80003cac:	3f fa       	mov	r10,-1
80003cae:	10 9c       	mov	r12,r8
80003cb0:	f0 1f 00 10 	mcall	80003cf0 <vPotentiometer+0xac>
		
		if(xSemaphoreGive(xFillCountPotentiometer) == pdTRUE)
80003cb4:	49 08       	lddpc	r8,80003cf4 <vPotentiometer+0xb0>
80003cb6:	70 08       	ld.w	r8,r8[0x0]
80003cb8:	30 09       	mov	r9,0
80003cba:	30 0a       	mov	r10,0
80003cbc:	30 0b       	mov	r11,0
80003cbe:	10 9c       	mov	r12,r8
80003cc0:	f0 1f 00 0c 	mcall	80003cf0 <vPotentiometer+0xac>
		{
			// Semaphore given
		}
		//vTaskDelayUntil(xLastWakeTime,xFreq);
		vTaskDelay(1000);
80003cc4:	e0 6c 03 e8 	mov	r12,1000
80003cc8:	f0 1f 00 0c 	mcall	80003cf8 <vPotentiometer+0xb4>
	}
80003ccc:	cc ab       	rjmp	80003c60 <vPotentiometer+0x1c>
80003cce:	00 00       	add	r0,r0
80003cd0:	80 00       	ld.sh	r0,r0[0x0]
80003cd2:	3a 9c       	mov	r12,-87
80003cd4:	80 00       	ld.sh	r0,r0[0x0]
80003cd6:	3a ba       	mov	r10,-85
80003cd8:	00 00       	add	r0,r0
80003cda:	08 04       	add	r4,r4
80003cdc:	80 00       	ld.sh	r0,r0[0x0]
80003cde:	56 44       	stdsp	sp[0x190],r4
80003ce0:	80 00       	ld.sh	r0,r0[0x0]
80003ce2:	5e 6c       	retmi	r12
80003ce4:	80 00       	ld.sh	r0,r0[0x0]
80003ce6:	30 d6       	mov	r6,13
80003ce8:	80 00       	ld.sh	r0,r0[0x0]
80003cea:	31 4c       	mov	r12,20
80003cec:	00 00       	add	r0,r0
80003cee:	07 f8       	ld.ub	r8,r3[0x7]
80003cf0:	80 00       	ld.sh	r0,r0[0x0]
80003cf2:	54 dc       	stdsp	sp[0x134],r12
80003cf4:	00 00       	add	r0,r0
80003cf6:	07 e8       	ld.ub	r8,r3[0x6]
80003cf8:	80 00       	ld.sh	r0,r0[0x0]
80003cfa:	5c 50       	castu.b	r0

80003cfc <vLight>:
}

void vLight(void *pvParameters)
{
80003cfc:	eb cd 40 80 	pushm	r7,lr
80003d00:	1a 97       	mov	r7,sp
80003d02:	20 2d       	sub	sp,8
80003d04:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile uint32_t value_to_send;		// Character to send to Consumer
	
	onLED(LED2_BIT_VALUE);	// On when the temp-producer is active
80003d08:	fc 1c 20 00 	movh	r12,0x2000
80003d0c:	f0 1f 00 1a 	mcall	80003d74 <vLight+0x78>
	
	while(1)
	{		
		offLED(LED2_BIT_VALUE);
80003d10:	fc 1c 20 00 	movh	r12,0x2000
80003d14:	f0 1f 00 19 	mcall	80003d78 <vLight+0x7c>
		if(xSemaphoreTake(xEmptyCountLight, (portTickType)portMAX_DELAY) == pdTRUE)
80003d18:	49 98       	lddpc	r8,80003d7c <vLight+0x80>
80003d1a:	70 08       	ld.w	r8,r8[0x0]
80003d1c:	30 09       	mov	r9,0
80003d1e:	3f fa       	mov	r10,-1
80003d20:	30 0b       	mov	r11,0
80003d22:	10 9c       	mov	r12,r8
80003d24:	f0 1f 00 17 	mcall	80003d80 <vLight+0x84>
		{
			// Semaphore taken
		}
		onLED(LED2_BIT_VALUE);
80003d28:	fc 1c 20 00 	movh	r12,0x2000
80003d2c:	f0 1f 00 12 	mcall	80003d74 <vLight+0x78>
		adc_start(&AVR32_ADC);
80003d30:	fe 7c 3c 00 	mov	r12,-50176
80003d34:	f0 1f 00 14 	mcall	80003d84 <vLight+0x88>
		value_to_send = adc_get_value(&AVR32_ADC, ADC_LIGHT_CHANNEL);
80003d38:	30 2b       	mov	r11,2
80003d3a:	fe 7c 3c 00 	mov	r12,-50176
80003d3e:	f0 1f 00 13 	mcall	80003d88 <vLight+0x8c>
80003d42:	18 98       	mov	r8,r12
80003d44:	ef 48 ff fc 	st.w	r7[-4],r8
		xQueueSendToBack(xQHandleLight, &value_to_send, (portTickType)portMAX_DELAY);
80003d48:	49 18       	lddpc	r8,80003d8c <vLight+0x90>
80003d4a:	70 08       	ld.w	r8,r8[0x0]
80003d4c:	ee cb 00 04 	sub	r11,r7,4
80003d50:	30 09       	mov	r9,0
80003d52:	3f fa       	mov	r10,-1
80003d54:	10 9c       	mov	r12,r8
80003d56:	f0 1f 00 0f 	mcall	80003d90 <vLight+0x94>
		
		if(xSemaphoreGive(xFillCountLight) == pdTRUE)
80003d5a:	48 f8       	lddpc	r8,80003d94 <vLight+0x98>
80003d5c:	70 08       	ld.w	r8,r8[0x0]
80003d5e:	30 09       	mov	r9,0
80003d60:	30 0a       	mov	r10,0
80003d62:	30 0b       	mov	r11,0
80003d64:	10 9c       	mov	r12,r8
80003d66:	f0 1f 00 0b 	mcall	80003d90 <vLight+0x94>
		{
			// Semaphore given
		}
		//vTaskDelay(TASK_DELAY_MS(100));
		vTaskDelay(1000);
80003d6a:	e0 6c 03 e8 	mov	r12,1000
80003d6e:	f0 1f 00 0b 	mcall	80003d98 <vLight+0x9c>
	}
80003d72:	cc fb       	rjmp	80003d10 <vLight+0x14>
80003d74:	80 00       	ld.sh	r0,r0[0x0]
80003d76:	3a 9c       	mov	r12,-87
80003d78:	80 00       	ld.sh	r0,r0[0x0]
80003d7a:	3a ba       	mov	r10,-85
80003d7c:	00 00       	add	r0,r0
80003d7e:	07 fc       	ld.ub	r12,r3[0x7]
80003d80:	80 00       	ld.sh	r0,r0[0x0]
80003d82:	56 44       	stdsp	sp[0x190],r4
80003d84:	80 00       	ld.sh	r0,r0[0x0]
80003d86:	30 d6       	mov	r6,13
80003d88:	80 00       	ld.sh	r0,r0[0x0]
80003d8a:	31 4c       	mov	r12,20
80003d8c:	00 00       	add	r0,r0
80003d8e:	07 ec       	ld.ub	r12,r3[0x6]
80003d90:	80 00       	ld.sh	r0,r0[0x0]
80003d92:	54 dc       	stdsp	sp[0x134],r12
80003d94:	00 00       	add	r0,r0
80003d96:	08 08       	add	r8,r4
80003d98:	80 00       	ld.sh	r0,r0[0x0]
80003d9a:	5c 50       	castu.b	r0

80003d9c <vConsumer>:
}

void vConsumer( void *pvParameters )
{
80003d9c:	eb cd 40 80 	pushm	r7,lr
80003da0:	1a 97       	mov	r7,sp
80003da2:	21 6d       	sub	sp,88
80003da4:	ef 4c ff a8 	st.w	r7[-88],r12
	volatile int potentiometer_received;	// Value received
	volatile int light_received;			// Value received
	volatile int temp_usart_write;		// Value received
	volatile int pot_usart_write;	// Value received
	volatile int light_usart_write;			// Value received
	volatile int row_temp = 1;			// Where on display to write
80003da8:	30 18       	mov	r8,1
80003daa:	ef 48 ff d8 	st.w	r7[-40],r8
	volatile int row_potentiometer = 2;	// Where on display to write
80003dae:	30 28       	mov	r8,2
80003db0:	ef 48 ff d4 	st.w	r7[-44],r8
	volatile int row_light = 3;			// Where on display to write
80003db4:	30 38       	mov	r8,3
80003db6:	ef 48 ff d0 	st.w	r7[-48],r8
	volatile const char * string_temp = "Temperature:";
80003dba:	4e c8       	lddpc	r8,80003f68 <vConsumer+0x1cc>
80003dbc:	ef 48 ff f4 	st.w	r7[-12],r8
	volatile const char * string_potentiometer = "Potentiometer:";
80003dc0:	4e b8       	lddpc	r8,80003f6c <vConsumer+0x1d0>
80003dc2:	ef 48 ff f8 	st.w	r7[-8],r8
	volatile const char * string_light = "Light:";
80003dc6:	4e b8       	lddpc	r8,80003f70 <vConsumer+0x1d4>
80003dc8:	ef 48 ff fc 	st.w	r7[-4],r8
	volatile char temperature_usart[10];
	volatile char potentiometer_usart[10];
	volatile char light_usart[10];
	
	dip204_clear_display();
80003dcc:	f0 1f 00 6a 	mcall	80003f74 <vConsumer+0x1d8>
	dip204_set_cursor_position(1, row_temp);
80003dd0:	ee f8 ff d8 	ld.w	r8,r7[-40]
80003dd4:	5c 58       	castu.b	r8
80003dd6:	10 9b       	mov	r11,r8
80003dd8:	30 1c       	mov	r12,1
80003dda:	f0 1f 00 68 	mcall	80003f78 <vConsumer+0x1dc>
	dip204_write_string(string_temp);
80003dde:	ee fc ff f4 	ld.w	r12,r7[-12]
80003de2:	f0 1f 00 67 	mcall	80003f7c <vConsumer+0x1e0>
	dip204_set_cursor_position(1, row_potentiometer);
80003de6:	ee f8 ff d4 	ld.w	r8,r7[-44]
80003dea:	5c 58       	castu.b	r8
80003dec:	10 9b       	mov	r11,r8
80003dee:	30 1c       	mov	r12,1
80003df0:	f0 1f 00 62 	mcall	80003f78 <vConsumer+0x1dc>
	dip204_write_string(string_potentiometer);
80003df4:	ee fc ff f8 	ld.w	r12,r7[-8]
80003df8:	f0 1f 00 61 	mcall	80003f7c <vConsumer+0x1e0>
	dip204_set_cursor_position(1, row_light);
80003dfc:	ee f8 ff d0 	ld.w	r8,r7[-48]
80003e00:	5c 58       	castu.b	r8
80003e02:	10 9b       	mov	r11,r8
80003e04:	30 1c       	mov	r12,1
80003e06:	f0 1f 00 5d 	mcall	80003f78 <vConsumer+0x1dc>
	dip204_write_string(string_light);
80003e0a:	ee fc ff fc 	ld.w	r12,r7[-4]
80003e0e:	f0 1f 00 5c 	mcall	80003f7c <vConsumer+0x1e0>
	
	onLED(LED3_BIT_VALUE);	// On when Consumer is active
80003e12:	fc 1c 40 00 	movh	r12,0x4000
80003e16:	f0 1f 00 5b 	mcall	80003f80 <vConsumer+0x1e4>
80003e1a:	c0 28       	rjmp	80003e1e <vConsumer+0x82>
			if(xSemaphoreGive(xLCDSemaphore) == pdTRUE)
			{
				//Successfully given back
			}
		}
	}
80003e1c:	d7 03       	nop
	
	onLED(LED3_BIT_VALUE);	// On when Consumer is active
	
	while(1)
	{
		offLED(LED3_BIT_VALUE);
80003e1e:	fc 1c 40 00 	movh	r12,0x4000
80003e22:	f0 1f 00 59 	mcall	80003f84 <vConsumer+0x1e8>
		if(xSemaphoreTake(xFillCountTemperature, (portTickType)portMAX_DELAY) == pdTRUE)
80003e26:	4d 98       	lddpc	r8,80003f88 <vConsumer+0x1ec>
80003e28:	70 08       	ld.w	r8,r8[0x0]
80003e2a:	30 09       	mov	r9,0
80003e2c:	3f fa       	mov	r10,-1
80003e2e:	30 0b       	mov	r11,0
80003e30:	10 9c       	mov	r12,r8
80003e32:	f0 1f 00 57 	mcall	80003f8c <vConsumer+0x1f0>
		{
			// Semaphore taken
		}
		onLED(LED3_BIT_VALUE);
80003e36:	fc 1c 40 00 	movh	r12,0x4000
80003e3a:	f0 1f 00 52 	mcall	80003f80 <vConsumer+0x1e4>
		
		xQueueReceive(xQHandleTemperature, &temperature_received, (portTickType)10);
80003e3e:	4d 58       	lddpc	r8,80003f90 <vConsumer+0x1f4>
80003e40:	70 08       	ld.w	r8,r8[0x0]
80003e42:	ee cb 00 10 	sub	r11,r7,16
80003e46:	30 09       	mov	r9,0
80003e48:	30 aa       	mov	r10,10
80003e4a:	10 9c       	mov	r12,r8
80003e4c:	f0 1f 00 50 	mcall	80003f8c <vConsumer+0x1f0>
		temp_usart_write = temperature_received;
80003e50:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003e54:	ef 48 ff e4 	st.w	r7[-28],r8
		
		if(xSemaphoreGive(xEmptyCountTemperature) == pdTRUE)
80003e58:	4c f8       	lddpc	r8,80003f94 <vConsumer+0x1f8>
80003e5a:	70 08       	ld.w	r8,r8[0x0]
80003e5c:	30 09       	mov	r9,0
80003e5e:	30 0a       	mov	r10,0
80003e60:	30 0b       	mov	r11,0
80003e62:	10 9c       	mov	r12,r8
80003e64:	f0 1f 00 4d 	mcall	80003f98 <vConsumer+0x1fc>
		{
			// Semaphore given
		}
		
		offLED(LED3_BIT_VALUE);
80003e68:	fc 1c 40 00 	movh	r12,0x4000
80003e6c:	f0 1f 00 46 	mcall	80003f84 <vConsumer+0x1e8>
		if(xSemaphoreTake(xFillCountPotentiometer, (portTickType)portMAX_DELAY) == pdTRUE)
80003e70:	4c b8       	lddpc	r8,80003f9c <vConsumer+0x200>
80003e72:	70 08       	ld.w	r8,r8[0x0]
80003e74:	30 09       	mov	r9,0
80003e76:	3f fa       	mov	r10,-1
80003e78:	30 0b       	mov	r11,0
80003e7a:	10 9c       	mov	r12,r8
80003e7c:	f0 1f 00 44 	mcall	80003f8c <vConsumer+0x1f0>
		{
			// Semaphore taken
		}
		onLED(LED3_BIT_VALUE);
80003e80:	fc 1c 40 00 	movh	r12,0x4000
80003e84:	f0 1f 00 3f 	mcall	80003f80 <vConsumer+0x1e4>
		
		xQueueReceive(xQHandlePotentiometer, &potentiometer_received, (portTickType)10);
80003e88:	4c 68       	lddpc	r8,80003fa0 <vConsumer+0x204>
80003e8a:	70 08       	ld.w	r8,r8[0x0]
80003e8c:	ee cb 00 14 	sub	r11,r7,20
80003e90:	30 09       	mov	r9,0
80003e92:	30 aa       	mov	r10,10
80003e94:	10 9c       	mov	r12,r8
80003e96:	f0 1f 00 3e 	mcall	80003f8c <vConsumer+0x1f0>
		pot_usart_write = potentiometer_received;
80003e9a:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003e9e:	ef 48 ff e0 	st.w	r7[-32],r8
		
		if(xSemaphoreGive(xEmptyCountPotentiometer) == pdTRUE)
80003ea2:	4c 18       	lddpc	r8,80003fa4 <vConsumer+0x208>
80003ea4:	70 08       	ld.w	r8,r8[0x0]
80003ea6:	30 09       	mov	r9,0
80003ea8:	30 0a       	mov	r10,0
80003eaa:	30 0b       	mov	r11,0
80003eac:	10 9c       	mov	r12,r8
80003eae:	f0 1f 00 3b 	mcall	80003f98 <vConsumer+0x1fc>
		{
			// Semaphore given
		}
		
		offLED(LED3_BIT_VALUE);
80003eb2:	fc 1c 40 00 	movh	r12,0x4000
80003eb6:	f0 1f 00 34 	mcall	80003f84 <vConsumer+0x1e8>
		if(xSemaphoreTake(xFillCountLight, (portTickType)portMAX_DELAY) == pdTRUE)
80003eba:	4b c8       	lddpc	r8,80003fa8 <vConsumer+0x20c>
80003ebc:	70 08       	ld.w	r8,r8[0x0]
80003ebe:	30 09       	mov	r9,0
80003ec0:	3f fa       	mov	r10,-1
80003ec2:	30 0b       	mov	r11,0
80003ec4:	10 9c       	mov	r12,r8
80003ec6:	f0 1f 00 32 	mcall	80003f8c <vConsumer+0x1f0>
		{
			// Semaphore taken
		}
		onLED(LED3_BIT_VALUE);
80003eca:	fc 1c 40 00 	movh	r12,0x4000
80003ece:	f0 1f 00 2d 	mcall	80003f80 <vConsumer+0x1e4>
		
		xQueueReceive(xQHandleLight, &light_received, (portTickType)10);
80003ed2:	4b 78       	lddpc	r8,80003fac <vConsumer+0x210>
80003ed4:	70 08       	ld.w	r8,r8[0x0]
80003ed6:	ee cb 00 18 	sub	r11,r7,24
80003eda:	30 09       	mov	r9,0
80003edc:	30 aa       	mov	r10,10
80003ede:	10 9c       	mov	r12,r8
80003ee0:	f0 1f 00 2b 	mcall	80003f8c <vConsumer+0x1f0>
		light_usart_write = light_received;
80003ee4:	ee f8 ff e8 	ld.w	r8,r7[-24]
80003ee8:	ef 48 ff dc 	st.w	r7[-36],r8
		
		if(xSemaphoreGive(xEmptyCountLight) == pdTRUE)
80003eec:	4b 18       	lddpc	r8,80003fb0 <vConsumer+0x214>
80003eee:	70 08       	ld.w	r8,r8[0x0]
80003ef0:	30 09       	mov	r9,0
80003ef2:	30 0a       	mov	r10,0
80003ef4:	30 0b       	mov	r11,0
80003ef6:	10 9c       	mov	r12,r8
80003ef8:	f0 1f 00 28 	mcall	80003f98 <vConsumer+0x1fc>
		{
			// Semaphore given
		}
		
		if(xSemaphoreTake(xLCDSemaphore, (portTickType)portMAX_DELAY) == pdTRUE)	// Semaphore - Display
80003efc:	4a e8       	lddpc	r8,80003fb4 <vConsumer+0x218>
80003efe:	70 08       	ld.w	r8,r8[0x0]
80003f00:	30 09       	mov	r9,0
80003f02:	3f fa       	mov	r10,-1
80003f04:	30 0b       	mov	r11,0
80003f06:	10 9c       	mov	r12,r8
80003f08:	f0 1f 00 21 	mcall	80003f8c <vConsumer+0x1f0>
80003f0c:	18 98       	mov	r8,r12
80003f0e:	58 18       	cp.w	r8,1
80003f10:	c8 61       	brne	80003e1c <vConsumer+0x80>
			usart_write_line(serialPORT_USART, temperature_usart);
			sprintf(potentiometer_usart, "Potentiometer %d\n", pot_usart_write);
			usart_write_line(serialPORT_USART, potentiometer_usart);
			sprintf(light_usart, "Light %d\n", light_usart_write);
			usart_write_line(serialPORT_USART, light_usart);*/
			dip204_set_cursor_position(15, 1);
80003f12:	30 1b       	mov	r11,1
80003f14:	30 fc       	mov	r12,15
80003f16:	f0 1f 00 19 	mcall	80003f78 <vConsumer+0x1dc>
			dip204_printf_string("%04d", temperature_received); //print value
80003f1a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003f1e:	1a d8       	st.w	--sp,r8
80003f20:	4a 6c       	lddpc	r12,80003fb8 <vConsumer+0x21c>
80003f22:	f0 1f 00 27 	mcall	80003fbc <vConsumer+0x220>
80003f26:	2f fd       	sub	sp,-4
			dip204_set_cursor_position(15, 2);
80003f28:	30 2b       	mov	r11,2
80003f2a:	30 fc       	mov	r12,15
80003f2c:	f0 1f 00 13 	mcall	80003f78 <vConsumer+0x1dc>
			dip204_printf_string("%04d", potentiometer_received); //print value
80003f30:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003f34:	1a d8       	st.w	--sp,r8
80003f36:	4a 1c       	lddpc	r12,80003fb8 <vConsumer+0x21c>
80003f38:	f0 1f 00 21 	mcall	80003fbc <vConsumer+0x220>
80003f3c:	2f fd       	sub	sp,-4
			dip204_set_cursor_position(15, 3);
80003f3e:	30 3b       	mov	r11,3
80003f40:	30 fc       	mov	r12,15
80003f42:	f0 1f 00 0e 	mcall	80003f78 <vConsumer+0x1dc>
			dip204_printf_string("%04d", light_received); //print value
80003f46:	ee f8 ff e8 	ld.w	r8,r7[-24]
80003f4a:	1a d8       	st.w	--sp,r8
80003f4c:	49 bc       	lddpc	r12,80003fb8 <vConsumer+0x21c>
80003f4e:	f0 1f 00 1c 	mcall	80003fbc <vConsumer+0x220>
80003f52:	2f fd       	sub	sp,-4
			if(xSemaphoreGive(xLCDSemaphore) == pdTRUE)
80003f54:	49 88       	lddpc	r8,80003fb4 <vConsumer+0x218>
80003f56:	70 08       	ld.w	r8,r8[0x0]
80003f58:	30 09       	mov	r9,0
80003f5a:	30 0a       	mov	r10,0
80003f5c:	30 0b       	mov	r11,0
80003f5e:	10 9c       	mov	r12,r8
80003f60:	f0 1f 00 0e 	mcall	80003f98 <vConsumer+0x1fc>
			{
				//Successfully given back
			}
		}
	}
80003f64:	c5 db       	rjmp	80003e1e <vConsumer+0x82>
80003f66:	00 00       	add	r0,r0
80003f68:	80 00       	ld.sh	r0,r0[0x0]
80003f6a:	3a d8       	mov	r8,-83
80003f6c:	80 00       	ld.sh	r0,r0[0x0]
80003f6e:	3a e8       	mov	r8,-82
80003f70:	80 00       	ld.sh	r0,r0[0x0]
80003f72:	3a f8       	mov	r8,-81
80003f74:	80 00       	ld.sh	r0,r0[0x0]
80003f76:	2c a0       	sub	r0,-54
80003f78:	80 00       	ld.sh	r0,r0[0x0]
80003f7a:	2c 18       	sub	r8,-63
80003f7c:	80 00       	ld.sh	r0,r0[0x0]
80003f7e:	2e 1c       	sub	r12,-31
80003f80:	80 00       	ld.sh	r0,r0[0x0]
80003f82:	3a 9c       	mov	r12,-87
80003f84:	80 00       	ld.sh	r0,r0[0x0]
80003f86:	3a ba       	mov	r10,-85
80003f88:	00 00       	add	r0,r0
80003f8a:	07 d8       	ld.ub	r8,r3[0x5]
80003f8c:	80 00       	ld.sh	r0,r0[0x0]
80003f8e:	56 44       	stdsp	sp[0x190],r4
80003f90:	00 00       	add	r0,r0
80003f92:	08 00       	add	r0,r4
80003f94:	00 00       	add	r0,r0
80003f96:	07 e0       	ld.ub	r0,r3[0x6]
80003f98:	80 00       	ld.sh	r0,r0[0x0]
80003f9a:	54 dc       	stdsp	sp[0x134],r12
80003f9c:	00 00       	add	r0,r0
80003f9e:	07 e8       	ld.ub	r8,r3[0x6]
80003fa0:	00 00       	add	r0,r0
80003fa2:	07 f8       	ld.ub	r8,r3[0x7]
80003fa4:	00 00       	add	r0,r0
80003fa6:	08 04       	add	r4,r4
80003fa8:	00 00       	add	r0,r0
80003faa:	08 08       	add	r8,r4
80003fac:	00 00       	add	r0,r0
80003fae:	07 ec       	ld.ub	r12,r3[0x6]
80003fb0:	00 00       	add	r0,r0
80003fb2:	07 fc       	ld.ub	r12,r3[0x7]
80003fb4:	00 00       	add	r0,r0
80003fb6:	07 dc       	ld.ub	r12,r3[0x5]
80003fb8:	80 00       	ld.sh	r0,r0[0x0]
80003fba:	3b 00       	mov	r0,-80
80003fbc:	80 00       	ld.sh	r0,r0[0x0]
80003fbe:	2e 8c       	sub	r12,-24

80003fc0 <main>:
}

int main(void)
{
80003fc0:	eb cd 40 80 	pushm	r7,lr
80003fc4:	1a 97       	mov	r7,sp
	initLED();
80003fc6:	f0 1f 00 57 	mcall	80004120 <main+0x160>
	init_usart();
80003fca:	f0 1f 00 57 	mcall	80004124 <main+0x164>
	display_init();
80003fce:	f0 1f 00 57 	mcall	80004128 <main+0x168>
	dip204_clear_display();
80003fd2:	f0 1f 00 57 	mcall	8000412c <main+0x16c>
	
	// Configure the ADC module and enable the potentiometer, temperature and light channel
	adc_configure(&AVR32_ADC);
80003fd6:	fe 7c 3c 00 	mov	r12,-50176
80003fda:	f0 1f 00 56 	mcall	80004130 <main+0x170>
	adc_enable(&AVR32_ADC, ADC_POTENTIOMETER_CHANNEL);
80003fde:	30 1b       	mov	r11,1
80003fe0:	fe 7c 3c 00 	mov	r12,-50176
80003fe4:	f0 1f 00 54 	mcall	80004134 <main+0x174>
	adc_enable(&AVR32_ADC, ADC_TEMPERATURE_CHANNEL);
80003fe8:	30 0b       	mov	r11,0
80003fea:	fe 7c 3c 00 	mov	r12,-50176
80003fee:	f0 1f 00 52 	mcall	80004134 <main+0x174>
	adc_enable(&AVR32_ADC, ADC_LIGHT_CHANNEL);
80003ff2:	30 2b       	mov	r11,2
80003ff4:	fe 7c 3c 00 	mov	r12,-50176
80003ff8:	f0 1f 00 4f 	mcall	80004134 <main+0x174>
	
	vSemaphoreCreateBinary(xLCDSemaphore);	// Semaphore - Display
80003ffc:	30 0b       	mov	r11,0
80003ffe:	30 1c       	mov	r12,1
80004000:	f0 1f 00 4e 	mcall	80004138 <main+0x178>
80004004:	18 99       	mov	r9,r12
80004006:	4c e8       	lddpc	r8,8000413c <main+0x17c>
80004008:	91 09       	st.w	r8[0x0],r9
8000400a:	4c d8       	lddpc	r8,8000413c <main+0x17c>
8000400c:	70 08       	ld.w	r8,r8[0x0]
8000400e:	58 08       	cp.w	r8,0
80004010:	c0 90       	breq	80004022 <main+0x62>
80004012:	4c b8       	lddpc	r8,8000413c <main+0x17c>
80004014:	70 08       	ld.w	r8,r8[0x0]
80004016:	30 09       	mov	r9,0
80004018:	30 0a       	mov	r10,0
8000401a:	30 0b       	mov	r11,0
8000401c:	10 9c       	mov	r12,r8
8000401e:	f0 1f 00 49 	mcall	80004140 <main+0x180>
	xFillCountTemperature = xSemaphoreCreateCounting(BUFFER_SIZE, 0);
80004022:	30 0b       	mov	r11,0
80004024:	30 1c       	mov	r12,1
80004026:	f0 1f 00 48 	mcall	80004144 <main+0x184>
8000402a:	18 99       	mov	r9,r12
8000402c:	4c 78       	lddpc	r8,80004148 <main+0x188>
8000402e:	91 09       	st.w	r8[0x0],r9
	xEmptyCountTemperature = xSemaphoreCreateCounting(BUFFER_SIZE, BUFFER_SIZE);
80004030:	30 1b       	mov	r11,1
80004032:	30 1c       	mov	r12,1
80004034:	f0 1f 00 44 	mcall	80004144 <main+0x184>
80004038:	18 99       	mov	r9,r12
8000403a:	4c 58       	lddpc	r8,8000414c <main+0x18c>
8000403c:	91 09       	st.w	r8[0x0],r9
	xFillCountPotentiometer = xSemaphoreCreateCounting(BUFFER_SIZE, 0);
8000403e:	30 0b       	mov	r11,0
80004040:	30 1c       	mov	r12,1
80004042:	f0 1f 00 41 	mcall	80004144 <main+0x184>
80004046:	18 99       	mov	r9,r12
80004048:	4c 28       	lddpc	r8,80004150 <main+0x190>
8000404a:	91 09       	st.w	r8[0x0],r9
	xEmptyCountPotentiometer = xSemaphoreCreateCounting(BUFFER_SIZE, BUFFER_SIZE);
8000404c:	30 1b       	mov	r11,1
8000404e:	30 1c       	mov	r12,1
80004050:	f0 1f 00 3d 	mcall	80004144 <main+0x184>
80004054:	18 99       	mov	r9,r12
80004056:	4c 08       	lddpc	r8,80004154 <main+0x194>
80004058:	91 09       	st.w	r8[0x0],r9
	xFillCountLight = xSemaphoreCreateCounting(BUFFER_SIZE, 0);
8000405a:	30 0b       	mov	r11,0
8000405c:	30 1c       	mov	r12,1
8000405e:	f0 1f 00 3a 	mcall	80004144 <main+0x184>
80004062:	18 99       	mov	r9,r12
80004064:	4b d8       	lddpc	r8,80004158 <main+0x198>
80004066:	91 09       	st.w	r8[0x0],r9
	xEmptyCountLight = xSemaphoreCreateCounting(BUFFER_SIZE, BUFFER_SIZE);
80004068:	30 1b       	mov	r11,1
8000406a:	30 1c       	mov	r12,1
8000406c:	f0 1f 00 36 	mcall	80004144 <main+0x184>
80004070:	18 99       	mov	r9,r12
80004072:	4b b8       	lddpc	r8,8000415c <main+0x19c>
80004074:	91 09       	st.w	r8[0x0],r9
	
	xQHandleTemperature = xQueueCreate(BUFFER_SIZE, sizeof(uint32_t*));		// Queue - 10 spots of char-pointer size
80004076:	30 4b       	mov	r11,4
80004078:	30 1c       	mov	r12,1
8000407a:	f0 1f 00 30 	mcall	80004138 <main+0x178>
8000407e:	18 99       	mov	r9,r12
80004080:	4b 88       	lddpc	r8,80004160 <main+0x1a0>
80004082:	91 09       	st.w	r8[0x0],r9
	if(xQHandleTemperature == NULL)
	{
		//ERROR!
	}
	xQHandlePotentiometer = xQueueCreate(BUFFER_SIZE, sizeof(uint32_t*));		// Queue - 10 spots of char-pointer size
80004084:	30 4b       	mov	r11,4
80004086:	30 1c       	mov	r12,1
80004088:	f0 1f 00 2c 	mcall	80004138 <main+0x178>
8000408c:	18 99       	mov	r9,r12
8000408e:	4b 68       	lddpc	r8,80004164 <main+0x1a4>
80004090:	91 09       	st.w	r8[0x0],r9
	if(xQHandlePotentiometer == NULL)
	{
		//ERROR!
	}
	xQHandleLight = xQueueCreate(BUFFER_SIZE, sizeof(uint32_t*));		// Queue - 10 spots of char-pointer size
80004092:	30 4b       	mov	r11,4
80004094:	30 1c       	mov	r12,1
80004096:	f0 1f 00 29 	mcall	80004138 <main+0x178>
8000409a:	18 99       	mov	r9,r12
8000409c:	4b 38       	lddpc	r8,80004168 <main+0x1a8>
8000409e:	91 09       	st.w	r8[0x0],r9
	xTaskCreate(	vConsumer, "vConsumer", configMINIMAL_STACK_SIZE, NULL, 1, &xHandleConsumer);	
	xTaskCreate(	vTemperature, "vTemperature", configMINIMAL_STACK_SIZE, NULL, 1, &xHandleTemperature);
	xTaskCreate(	vPotentiometer, "vPotentiometer", configMINIMAL_STACK_SIZE, NULL, 1, &xHandlePotentiometer);
	xTaskCreate(	vLight, "vLight", configMINIMAL_STACK_SIZE, NULL, 1, &xHandleLight);*/
	
	xTaskCreate(	vConsumer, "vConsumer", configMINIMAL_STACK_SIZE, NULL, 1, NULL);	
800040a0:	4b 3b       	lddpc	r11,8000416c <main+0x1ac>
800040a2:	30 08       	mov	r8,0
800040a4:	1a d8       	st.w	--sp,r8
800040a6:	30 08       	mov	r8,0
800040a8:	1a d8       	st.w	--sp,r8
800040aa:	30 08       	mov	r8,0
800040ac:	1a d8       	st.w	--sp,r8
800040ae:	30 18       	mov	r8,1
800040b0:	30 09       	mov	r9,0
800040b2:	e0 6a 01 00 	mov	r10,256
800040b6:	4a fc       	lddpc	r12,80004170 <main+0x1b0>
800040b8:	f0 1f 00 2f 	mcall	80004174 <main+0x1b4>
800040bc:	2f dd       	sub	sp,-12
	xTaskCreate(	vTemperature, "vTemperature", configMINIMAL_STACK_SIZE, NULL, 1,NULL);
800040be:	4a fb       	lddpc	r11,80004178 <main+0x1b8>
800040c0:	30 08       	mov	r8,0
800040c2:	1a d8       	st.w	--sp,r8
800040c4:	30 08       	mov	r8,0
800040c6:	1a d8       	st.w	--sp,r8
800040c8:	30 08       	mov	r8,0
800040ca:	1a d8       	st.w	--sp,r8
800040cc:	30 18       	mov	r8,1
800040ce:	30 09       	mov	r9,0
800040d0:	e0 6a 01 00 	mov	r10,256
800040d4:	4a ac       	lddpc	r12,8000417c <main+0x1bc>
800040d6:	f0 1f 00 28 	mcall	80004174 <main+0x1b4>
800040da:	2f dd       	sub	sp,-12
	xTaskCreate(	vPotentiometer, "vPotentiometer", configMINIMAL_STACK_SIZE, NULL, 1, NULL);
800040dc:	4a 9b       	lddpc	r11,80004180 <main+0x1c0>
800040de:	30 08       	mov	r8,0
800040e0:	1a d8       	st.w	--sp,r8
800040e2:	30 08       	mov	r8,0
800040e4:	1a d8       	st.w	--sp,r8
800040e6:	30 08       	mov	r8,0
800040e8:	1a d8       	st.w	--sp,r8
800040ea:	30 18       	mov	r8,1
800040ec:	30 09       	mov	r9,0
800040ee:	e0 6a 01 00 	mov	r10,256
800040f2:	4a 5c       	lddpc	r12,80004184 <main+0x1c4>
800040f4:	f0 1f 00 20 	mcall	80004174 <main+0x1b4>
800040f8:	2f dd       	sub	sp,-12
	xTaskCreate(	vLight, "vLight", configMINIMAL_STACK_SIZE, NULL, 1, NULL);
800040fa:	4a 4b       	lddpc	r11,80004188 <main+0x1c8>
800040fc:	30 08       	mov	r8,0
800040fe:	1a d8       	st.w	--sp,r8
80004100:	30 08       	mov	r8,0
80004102:	1a d8       	st.w	--sp,r8
80004104:	30 08       	mov	r8,0
80004106:	1a d8       	st.w	--sp,r8
80004108:	30 18       	mov	r8,1
8000410a:	30 09       	mov	r9,0
8000410c:	e0 6a 01 00 	mov	r10,256
80004110:	49 fc       	lddpc	r12,8000418c <main+0x1cc>
80004112:	f0 1f 00 19 	mcall	80004174 <main+0x1b4>
80004116:	2f dd       	sub	sp,-12
	
	vTaskStartScheduler();		// Starts the schedueling
80004118:	f0 1f 00 1e 	mcall	80004190 <main+0x1d0>

	
	for( ;; )
	{
		
	}
8000411c:	c0 08       	rjmp	8000411c <main+0x15c>
8000411e:	00 00       	add	r0,r0
80004120:	80 00       	ld.sh	r0,r0[0x0]
80004122:	3a 20       	mov	r0,-94
80004124:	80 00       	ld.sh	r0,r0[0x0]
80004126:	3b 3c       	mov	r12,-77
80004128:	80 00       	ld.sh	r0,r0[0x0]
8000412a:	37 f8       	mov	r8,127
8000412c:	80 00       	ld.sh	r0,r0[0x0]
8000412e:	2c a0       	sub	r0,-54
80004130:	80 00       	ld.sh	r0,r0[0x0]
80004132:	30 a0       	mov	r0,10
80004134:	80 00       	ld.sh	r0,r0[0x0]
80004136:	30 f0       	mov	r0,15
80004138:	80 00       	ld.sh	r0,r0[0x0]
8000413a:	53 80       	stdsp	sp[0xe0],r0
8000413c:	00 00       	add	r0,r0
8000413e:	07 dc       	ld.ub	r12,r3[0x5]
80004140:	80 00       	ld.sh	r0,r0[0x0]
80004142:	54 dc       	stdsp	sp[0x134],r12
80004144:	80 00       	ld.sh	r0,r0[0x0]
80004146:	54 98       	stdsp	sp[0x124],r8
80004148:	00 00       	add	r0,r0
8000414a:	07 d8       	ld.ub	r8,r3[0x5]
8000414c:	00 00       	add	r0,r0
8000414e:	07 e0       	ld.ub	r0,r3[0x6]
80004150:	00 00       	add	r0,r0
80004152:	07 e8       	ld.ub	r8,r3[0x6]
80004154:	00 00       	add	r0,r0
80004156:	08 04       	add	r4,r4
80004158:	00 00       	add	r0,r0
8000415a:	08 08       	add	r8,r4
8000415c:	00 00       	add	r0,r0
8000415e:	07 fc       	ld.ub	r12,r3[0x7]
80004160:	00 00       	add	r0,r0
80004162:	08 00       	add	r0,r4
80004164:	00 00       	add	r0,r0
80004166:	07 f8       	ld.ub	r8,r3[0x7]
80004168:	00 00       	add	r0,r0
8000416a:	07 ec       	ld.ub	r12,r3[0x6]
8000416c:	80 00       	ld.sh	r0,r0[0x0]
8000416e:	3b 08       	mov	r8,-80
80004170:	80 00       	ld.sh	r0,r0[0x0]
80004172:	3d 9c       	mov	r12,-39
80004174:	80 00       	ld.sh	r0,r0[0x0]
80004176:	5a 88       	cp.w	r8,-24
80004178:	80 00       	ld.sh	r0,r0[0x0]
8000417a:	3b 14       	mov	r4,-79
8000417c:	80 00       	ld.sh	r0,r0[0x0]
8000417e:	3b a4       	mov	r4,-70
80004180:	80 00       	ld.sh	r0,r0[0x0]
80004182:	3b 24       	mov	r4,-78
80004184:	80 00       	ld.sh	r0,r0[0x0]
80004186:	3c 44       	mov	r4,-60
80004188:	80 00       	ld.sh	r0,r0[0x0]
8000418a:	3b 34       	mov	r4,-77
8000418c:	80 00       	ld.sh	r0,r0[0x0]
8000418e:	3c fc       	mov	r12,-49
80004190:	80 00       	ld.sh	r0,r0[0x0]
80004192:	5c c4       	swap.bh	r4

80004194 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80004194:	eb cd 40 80 	pushm	r7,lr
80004198:	1a 97       	mov	r7,sp
8000419a:	20 4d       	sub	sp,16
8000419c:	ef 4c ff f4 	st.w	r7[-12],r12
800041a0:	ef 4b ff f0 	st.w	r7[-16],r11
	uint32_t status = GPIO_SUCCESS;
800041a4:	30 08       	mov	r8,0
800041a6:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t i;

	for (i = 0; i < size; i++) {
800041aa:	30 08       	mov	r8,0
800041ac:	ef 48 ff fc 	st.w	r7[-4],r8
800041b0:	c1 c8       	rjmp	800041e8 <gpio_enable_module+0x54>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800041b2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800041b6:	70 19       	ld.w	r9,r8[0x4]
800041b8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800041bc:	70 08       	ld.w	r8,r8[0x0]
800041be:	12 9b       	mov	r11,r9
800041c0:	10 9c       	mov	r12,r8
800041c2:	f0 1f 00 10 	mcall	80004200 <gpio_enable_module+0x6c>
800041c6:	18 98       	mov	r8,r12
800041c8:	ee f9 ff f8 	ld.w	r9,r7[-8]
800041cc:	f3 e8 10 08 	or	r8,r9,r8
800041d0:	ef 48 ff f8 	st.w	r7[-8],r8
		gpiomap++;
800041d4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800041d8:	2f 88       	sub	r8,-8
800041da:	ef 48 ff f4 	st.w	r7[-12],r8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800041de:	ee f8 ff fc 	ld.w	r8,r7[-4]
800041e2:	2f f8       	sub	r8,-1
800041e4:	ef 48 ff fc 	st.w	r7[-4],r8
800041e8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800041ec:	ee f8 ff f0 	ld.w	r8,r7[-16]
800041f0:	10 39       	cp.w	r9,r8
800041f2:	ce 03       	brcs	800041b2 <gpio_enable_module+0x1e>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
800041f4:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800041f8:	10 9c       	mov	r12,r8
800041fa:	2f cd       	sub	sp,-16
800041fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80004200:	80 00       	ld.sh	r0,r0[0x0]
80004202:	42 04       	lddsp	r4,sp[0x80]

80004204 <gpio_enable_module_pin>:
 * \param function The pin function.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
80004204:	eb cd 40 80 	pushm	r7,lr
80004208:	1a 97       	mov	r7,sp
8000420a:	20 3d       	sub	sp,12
8000420c:	ef 4c ff f8 	st.w	r7[-8],r12
80004210:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004214:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004218:	a5 98       	lsr	r8,0x5
8000421a:	a9 68       	lsl	r8,0x8
8000421c:	e0 28 f0 00 	sub	r8,61440
80004220:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Enable the correct function. */
	switch (function) {
80004224:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004228:	58 18       	cp.w	r8,1
8000422a:	c1 e0       	breq	80004266 <gpio_enable_module_pin+0x62>
8000422c:	c0 63       	brcs	80004238 <gpio_enable_module_pin+0x34>
8000422e:	58 28       	cp.w	r8,2
80004230:	c3 20       	breq	80004294 <gpio_enable_module_pin+0x90>
80004232:	58 38       	cp.w	r8,3
80004234:	c4 70       	breq	800042c2 <gpio_enable_module_pin+0xbe>
80004236:	c5 d8       	rjmp	800042f0 <gpio_enable_module_pin+0xec>
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004238:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000423c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004240:	30 19       	mov	r9,1
80004242:	f2 08 09 48 	lsl	r8,r9,r8
80004246:	10 99       	mov	r9,r8
80004248:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000424c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000424e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004252:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004256:	30 19       	mov	r9,1
80004258:	f2 08 09 48 	lsl	r8,r9,r8
8000425c:	10 99       	mov	r9,r8
8000425e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004262:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004264:	c4 88       	rjmp	800042f4 <gpio_enable_module_pin+0xf0>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004266:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000426a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000426e:	30 19       	mov	r9,1
80004270:	f2 08 09 48 	lsl	r8,r9,r8
80004274:	10 99       	mov	r9,r8
80004276:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000427a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000427c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004280:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004284:	30 19       	mov	r9,1
80004286:	f2 08 09 48 	lsl	r8,r9,r8
8000428a:	10 99       	mov	r9,r8
8000428c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004290:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004292:	c3 18       	rjmp	800042f4 <gpio_enable_module_pin+0xf0>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004294:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004298:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000429c:	30 19       	mov	r9,1
8000429e:	f2 08 09 48 	lsl	r8,r9,r8
800042a2:	10 99       	mov	r9,r8
800042a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042a8:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800042aa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042ae:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800042b2:	30 19       	mov	r9,1
800042b4:	f2 08 09 48 	lsl	r8,r9,r8
800042b8:	10 99       	mov	r9,r8
800042ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042be:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800042c0:	c1 a8       	rjmp	800042f4 <gpio_enable_module_pin+0xf0>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800042c2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042c6:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800042ca:	30 19       	mov	r9,1
800042cc:	f2 08 09 48 	lsl	r8,r9,r8
800042d0:	10 99       	mov	r9,r8
800042d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042d6:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800042d8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042dc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800042e0:	30 19       	mov	r9,1
800042e2:	f2 08 09 48 	lsl	r8,r9,r8
800042e6:	10 99       	mov	r9,r8
800042e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042ec:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800042ee:	c0 38       	rjmp	800042f4 <gpio_enable_module_pin+0xf0>
		gpio_port->pmr2s = 1 << (pin & 0x1F);
		break;
#endif

	default:
		return GPIO_INVALID_ARGUMENT;
800042f0:	30 18       	mov	r8,1
800042f2:	c0 d8       	rjmp	8000430c <gpio_enable_module_pin+0x108>
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800042f4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042f8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800042fc:	30 19       	mov	r9,1
800042fe:	f2 08 09 48 	lsl	r8,r9,r8
80004302:	10 99       	mov	r9,r8
80004304:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004308:	91 29       	st.w	r8[0x8],r9

	return GPIO_SUCCESS;
8000430a:	30 08       	mov	r8,0
}
8000430c:	10 9c       	mov	r12,r8
8000430e:	2f dd       	sub	sp,-12
80004310:	e3 cd 80 80 	ldm	sp++,r7,pc

80004314 <gpio_set_gpio_pin>:
/** \brief Drives a GPIO pin to 1.
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
80004314:	eb cd 40 80 	pushm	r7,lr
80004318:	1a 97       	mov	r7,sp
8000431a:	20 2d       	sub	sp,8
8000431c:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004320:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004324:	a5 98       	lsr	r8,0x5
80004326:	a9 68       	lsl	r8,0x8
80004328:	e0 28 f0 00 	sub	r8,61440
8000432c:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80004330:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004334:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004338:	30 19       	mov	r9,1
8000433a:	f2 08 09 48 	lsl	r8,r9,r8
8000433e:	10 99       	mov	r9,r8
80004340:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004344:	f1 49 00 54 	st.w	r8[84],r9
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80004348:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000434c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004350:	30 19       	mov	r9,1
80004352:	f2 08 09 48 	lsl	r8,r9,r8
80004356:	10 99       	mov	r9,r8
80004358:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000435c:	f1 49 00 44 	st.w	r8[68],r9
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80004360:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004364:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004368:	30 19       	mov	r9,1
8000436a:	f2 08 09 48 	lsl	r8,r9,r8
8000436e:	10 99       	mov	r9,r8
80004370:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004374:	91 19       	st.w	r8[0x4],r9
}
80004376:	2f ed       	sub	sp,-8
80004378:	e3 cd 80 80 	ldm	sp++,r7,pc

8000437c <gpio_clr_gpio_pin>:
/** \brief Drives a GPIO pin to 0.
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
8000437c:	eb cd 40 80 	pushm	r7,lr
80004380:	1a 97       	mov	r7,sp
80004382:	20 2d       	sub	sp,8
80004384:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004388:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000438c:	a5 98       	lsr	r8,0x5
8000438e:	a9 68       	lsl	r8,0x8
80004390:	e0 28 f0 00 	sub	r8,61440
80004394:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80004398:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000439c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800043a0:	30 19       	mov	r9,1
800043a2:	f2 08 09 48 	lsl	r8,r9,r8
800043a6:	10 99       	mov	r9,r8
800043a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043ac:	f1 49 00 58 	st.w	r8[88],r9
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800043b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800043b4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800043b8:	30 19       	mov	r9,1
800043ba:	f2 08 09 48 	lsl	r8,r9,r8
800043be:	10 99       	mov	r9,r8
800043c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043c4:	f1 49 00 44 	st.w	r8[68],r9
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800043c8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800043cc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800043d0:	30 19       	mov	r9,1
800043d2:	f2 08 09 48 	lsl	r8,r9,r8
800043d6:	10 99       	mov	r9,r8
800043d8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043dc:	91 19       	st.w	r8[0x4],r9
}
800043de:	2f ed       	sub	sp,-8
800043e0:	e3 cd 80 80 	ldm	sp++,r7,pc

800043e4 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800043e4:	eb cd 40 80 	pushm	r7,lr
800043e8:	1a 97       	mov	r7,sp
	// Catch unregistered interrupts.
	while (true);
800043ea:	c0 08       	rjmp	800043ea <_unhandled_interrupt+0x6>

800043ec <_get_interrupt_handler>:
 *
 * \return Interrupt handler to execute.
 */
__int_handler _get_interrupt_handler(uint32_t int_level);
__int_handler _get_interrupt_handler(uint32_t int_level)
{
800043ec:	eb cd 40 80 	pushm	r7,lr
800043f0:	1a 97       	mov	r7,sp
800043f2:	20 3d       	sub	sp,12
800043f4:	ef 4c ff f4 	st.w	r7[-12],r12
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800043f8:	fe 78 08 00 	mov	r8,-63488
800043fc:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004400:	f2 09 11 03 	rsub	r9,r9,3
80004404:	28 09       	sub	r9,-128
80004406:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
8000440a:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t int_req = AVR32_INTC.irr[int_grp];
8000440e:	fe 78 08 00 	mov	r8,-63488
80004412:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004416:	2c 09       	sub	r9,-64
80004418:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
8000441c:	ef 48 ff fc 	st.w	r7[-4],r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004420:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004424:	58 08       	cp.w	r8,0
80004426:	c1 30       	breq	8000444c <_get_interrupt_handler+0x60>
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004428:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000442c:	48 b8       	lddpc	r8,80004458 <_get_interrupt_handler+0x6c>
8000442e:	a1 79       	lsl	r9,0x1
80004430:	2f f9       	sub	r9,-1
80004432:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80004436:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000443a:	f0 08 12 00 	clz	r8,r8
8000443e:	f0 08 11 1f 	rsub	r8,r8,31
			- clz(int_req) - 1]
80004442:	a3 68       	lsl	r8,0x2
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004444:	f2 08 00 08 	add	r8,r9,r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004448:	70 08       	ld.w	r8,r8[0x0]
8000444a:	c0 28       	rjmp	8000444e <_get_interrupt_handler+0x62>
8000444c:	30 08       	mov	r8,0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000444e:	10 9c       	mov	r12,r8
80004450:	2f dd       	sub	sp,-12
80004452:	e3 cd 80 80 	ldm	sp++,r7,pc
80004456:	00 00       	add	r0,r0
80004458:	80 00       	ld.sh	r0,r0[0x0]
8000445a:	c4 74       	brge	800044e8 <INTC_init_interrupts+0x78>

8000445c <INTC_init_evba>:
 * \internal
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
8000445c:	eb cd 40 80 	pushm	r7,lr
80004460:	1a 97       	mov	r7,sp
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004462:	48 38       	lddpc	r8,8000446c <INTC_init_evba+0x10>
80004464:	e3 b8 00 01 	mtsr	0x4,r8
}
80004468:	e3 cd 80 80 	ldm	sp++,r7,pc
8000446c:	80 00       	ld.sh	r0,r0[0x0]
8000446e:	c2 00       	breq	800044ae <INTC_init_interrupts+0x3e>

80004470 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004470:	eb cd 40 80 	pushm	r7,lr
80004474:	1a 97       	mov	r7,sp
80004476:	20 2d       	sub	sp,8
	uint32_t int_grp, int_req;

	INTC_init_evba();
80004478:	f0 1f 00 1f 	mcall	800044f4 <INTC_init_interrupts+0x84>

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
8000447c:	30 08       	mov	r8,0
8000447e:	ef 48 ff f8 	st.w	r7[-8],r8
80004482:	c3 18       	rjmp	800044e4 <INTC_init_interrupts+0x74>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004484:	30 08       	mov	r8,0
80004486:	ef 48 ff fc 	st.w	r7[-4],r8
8000448a:	c1 48       	rjmp	800044b2 <INTC_init_interrupts+0x42>
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
8000448c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004490:	49 a8       	lddpc	r8,800044f8 <INTC_init_interrupts+0x88>
80004492:	a1 79       	lsl	r9,0x1
80004494:	2f f9       	sub	r9,-1
80004496:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
8000449a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000449e:	a3 68       	lsl	r8,0x2
800044a0:	f2 08 00 08 	add	r8,r9,r8
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800044a4:	49 69       	lddpc	r9,800044fc <INTC_init_interrupts+0x8c>
800044a6:	91 09       	st.w	r8[0x0],r9
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800044a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800044ac:	2f f8       	sub	r8,-1
800044ae:	ef 48 ff fc 	st.w	r7[-4],r8
	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
800044b2:	ee f9 ff f8 	ld.w	r9,r7[-8]
800044b6:	49 18       	lddpc	r8,800044f8 <INTC_init_interrupts+0x88>
800044b8:	f0 09 03 39 	ld.w	r9,r8[r9<<0x3]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800044bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800044c0:	10 39       	cp.w	r9,r8
800044c2:	fe 9b ff e5 	brhi	8000448c <INTC_init_interrupts+0x1c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800044c6:	fe 78 08 00 	mov	r8,-63488
800044ca:	ee f9 ff f8 	ld.w	r9,r7[-8]
800044ce:	48 db       	lddpc	r11,80004500 <INTC_init_interrupts+0x90>
800044d0:	48 da       	lddpc	r10,80004504 <INTC_init_interrupts+0x94>
800044d2:	f6 0a 01 0a 	sub	r10,r11,r10
800044d6:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800044da:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044de:	2f f8       	sub	r8,-1
800044e0:	ef 48 ff f8 	st.w	r7[-8],r8
800044e4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044e8:	59 38       	cp.w	r8,19
800044ea:	fe 98 ff cd 	brls	80004484 <INTC_init_interrupts+0x14>
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	}
}
800044ee:	2f ed       	sub	sp,-8
800044f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800044f4:	80 00       	ld.sh	r0,r0[0x0]
800044f6:	44 5c       	lddsp	r12,sp[0x114]
800044f8:	80 00       	ld.sh	r0,r0[0x0]
800044fa:	c4 74       	brge	80004588 <INTC_register_interrupt+0x80>
800044fc:	80 00       	ld.sh	r0,r0[0x0]
800044fe:	43 e4       	lddsp	r4,sp[0xf8]
80004500:	80 00       	ld.sh	r0,r0[0x0]
80004502:	c3 04       	brge	80004562 <INTC_register_interrupt+0x5a>
80004504:	80 00       	ld.sh	r0,r0[0x0]
80004506:	c2 00       	breq	80004546 <INTC_register_interrupt+0x3e>

80004508 <INTC_register_interrupt>:
 *          be effective.
 *
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
80004508:	eb cd 40 80 	pushm	r7,lr
8000450c:	1a 97       	mov	r7,sp
8000450e:	20 4d       	sub	sp,16
80004510:	ef 4c ff f8 	st.w	r7[-8],r12
80004514:	ef 4b ff f4 	st.w	r7[-12],r11
80004518:	ef 4a ff f0 	st.w	r7[-16],r10
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000451c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004520:	a5 98       	lsr	r8,0x5
80004522:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004526:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000452a:	4a 78       	lddpc	r8,800045c4 <INTC_register_interrupt+0xbc>
8000452c:	a1 79       	lsl	r9,0x1
8000452e:	2f f9       	sub	r9,-1
80004530:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80004534:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004538:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000453c:	a3 68       	lsl	r8,0x2
8000453e:	f2 08 00 08 	add	r8,r9,r8
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004542:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004546:	91 09       	st.w	r8[0x0],r9
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004548:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000454c:	58 08       	cp.w	r8,0
8000454e:	c0 c1       	brne	80004566 <INTC_register_interrupt+0x5e>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004550:	fe 78 08 00 	mov	r8,-63488
80004554:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004558:	49 cb       	lddpc	r11,800045c8 <INTC_register_interrupt+0xc0>
8000455a:	49 da       	lddpc	r10,800045cc <INTC_register_interrupt+0xc4>
8000455c:	f6 0a 01 0a 	sub	r10,r11,r10
80004560:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004564:	c2 d8       	rjmp	800045be <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT1) {
80004566:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000456a:	58 18       	cp.w	r8,1
8000456c:	c0 d1       	brne	80004586 <INTC_register_interrupt+0x7e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000456e:	fe 78 08 00 	mov	r8,-63488
80004572:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004576:	49 7b       	lddpc	r11,800045d0 <INTC_register_interrupt+0xc8>
80004578:	49 5a       	lddpc	r10,800045cc <INTC_register_interrupt+0xc4>
8000457a:	f6 0a 01 0a 	sub	r10,r11,r10
8000457e:	bf aa       	sbr	r10,0x1e
80004580:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004584:	c1 d8       	rjmp	800045be <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT2) {
80004586:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000458a:	58 28       	cp.w	r8,2
8000458c:	c0 d1       	brne	800045a6 <INTC_register_interrupt+0x9e>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000458e:	fe 78 08 00 	mov	r8,-63488
80004592:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004596:	49 0b       	lddpc	r11,800045d4 <INTC_register_interrupt+0xcc>
80004598:	48 da       	lddpc	r10,800045cc <INTC_register_interrupt+0xc4>
8000459a:	f6 0a 01 0a 	sub	r10,r11,r10
8000459e:	bf ba       	sbr	r10,0x1f
800045a0:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
800045a4:	c0 d8       	rjmp	800045be <INTC_register_interrupt+0xb6>
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800045a6:	fe 78 08 00 	mov	r8,-63488
800045aa:	ee f9 ff fc 	ld.w	r9,r7[-4]
800045ae:	48 bb       	lddpc	r11,800045d8 <INTC_register_interrupt+0xd0>
800045b0:	48 7a       	lddpc	r10,800045cc <INTC_register_interrupt+0xc4>
800045b2:	f6 0a 01 0a 	sub	r10,r11,r10
800045b6:	ea 1a c0 00 	orh	r10,0xc000
800045ba:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	}
}
800045be:	2f cd       	sub	sp,-16
800045c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800045c4:	80 00       	ld.sh	r0,r0[0x0]
800045c6:	c4 74       	brge	80004654 <pm_enable_osc0_crystal+0x2c>
800045c8:	80 00       	ld.sh	r0,r0[0x0]
800045ca:	c3 04       	brge	8000462a <pm_enable_osc0_crystal+0x2>
800045cc:	80 00       	ld.sh	r0,r0[0x0]
800045ce:	c2 00       	breq	8000460e <pm_set_osc0_mode+0x32>
800045d0:	80 00       	ld.sh	r0,r0[0x0]
800045d2:	c3 12       	brcc	80004634 <pm_enable_osc0_crystal+0xc>
800045d4:	80 00       	ld.sh	r0,r0[0x0]
800045d6:	c3 20       	breq	8000463a <pm_enable_osc0_crystal+0x12>
800045d8:	80 00       	ld.sh	r0,r0[0x0]
800045da:	c3 2e       	rcall	8000423e <gpio_enable_module_pin+0x3a>

800045dc <pm_set_osc0_mode>:
 *
 * \param pm Base address of the Power Manager (i.e. &AVR32_PM).
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
800045dc:	eb cd 40 80 	pushm	r7,lr
800045e0:	1a 97       	mov	r7,sp
800045e2:	20 3d       	sub	sp,12
800045e4:	ef 4c ff f8 	st.w	r7[-8],r12
800045e8:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800045ec:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045f0:	70 a8       	ld.w	r8,r8[0x28]
800045f2:	30 09       	mov	r9,0
800045f4:	ef 49 ff fc 	st.w	r7[-4],r9
800045f8:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800045fc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004600:	5c 58       	castu.b	r8
80004602:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004606:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000460a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000460e:	f1 d9 d0 03 	bfins	r8,r9,0x0,0x3
80004612:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80004616:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000461a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000461e:	91 a9       	st.w	r8[0x28],r9
}
80004620:	2f dd       	sub	sp,-12
80004622:	e3 cd 80 80 	ldm	sp++,r7,pc
80004626:	d7 03       	nop

80004628 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80004628:	eb cd 40 80 	pushm	r7,lr
8000462c:	1a 97       	mov	r7,sp
8000462e:	20 2d       	sub	sp,8
80004630:	ef 4c ff fc 	st.w	r7[-4],r12
80004634:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80004638:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000463c:	ec 58 bb 9f 	cp.w	r8,899999
80004640:	e0 88 00 1a 	brls	80004674 <pm_enable_osc0_crystal+0x4c>
80004644:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004648:	e0 69 c6 bf 	mov	r9,50879
8000464c:	ea 19 00 2d 	orh	r9,0x2d
80004650:	12 38       	cp.w	r8,r9
80004652:	e0 88 00 0f 	brls	80004670 <pm_enable_osc0_crystal+0x48>
80004656:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000465a:	e0 69 11 ff 	mov	r9,4607
8000465e:	ea 19 00 7a 	orh	r9,0x7a
80004662:	12 38       	cp.w	r8,r9
80004664:	e0 8b 00 04 	brhi	8000466c <pm_enable_osc0_crystal+0x44>
80004668:	30 68       	mov	r8,6
8000466a:	c0 28       	rjmp	8000466e <pm_enable_osc0_crystal+0x46>
8000466c:	30 78       	mov	r8,7
8000466e:	c0 28       	rjmp	80004672 <pm_enable_osc0_crystal+0x4a>
80004670:	30 58       	mov	r8,5
80004672:	c0 28       	rjmp	80004676 <pm_enable_osc0_crystal+0x4e>
80004674:	30 48       	mov	r8,4
80004676:	10 9b       	mov	r11,r8
80004678:	ee fc ff fc 	ld.w	r12,r7[-4]
8000467c:	f0 1f 00 03 	mcall	80004688 <pm_enable_osc0_crystal+0x60>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80004680:	2f ed       	sub	sp,-8
80004682:	e3 cd 80 80 	ldm	sp++,r7,pc
80004686:	00 00       	add	r0,r0
80004688:	80 00       	ld.sh	r0,r0[0x0]
8000468a:	45 dc       	lddsp	r12,sp[0x174]

8000468c <pm_enable_clk0>:


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
8000468c:	eb cd 40 80 	pushm	r7,lr
80004690:	1a 97       	mov	r7,sp
80004692:	20 2d       	sub	sp,8
80004694:	ef 4c ff fc 	st.w	r7[-4],r12
80004698:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_enable_clk0_no_wait(pm, startup);
8000469c:	ee fb ff f8 	ld.w	r11,r7[-8]
800046a0:	ee fc ff fc 	ld.w	r12,r7[-4]
800046a4:	f0 1f 00 05 	mcall	800046b8 <pm_enable_clk0+0x2c>
  pm_wait_for_clk0_ready(pm);
800046a8:	ee fc ff fc 	ld.w	r12,r7[-4]
800046ac:	f0 1f 00 04 	mcall	800046bc <pm_enable_clk0+0x30>
}
800046b0:	2f ed       	sub	sp,-8
800046b2:	e3 cd 80 80 	ldm	sp++,r7,pc
800046b6:	00 00       	add	r0,r0
800046b8:	80 00       	ld.sh	r0,r0[0x0]
800046ba:	46 c0       	lddsp	r0,sp[0x1b0]
800046bc:	80 00       	ld.sh	r0,r0[0x0]
800046be:	47 1a       	lddsp	r10,sp[0x1c4]

800046c0 <pm_enable_clk0_no_wait>:
  pm->mcctrl &= ~AVR32_PM_MCCTRL_OSC0EN_MASK;
}


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
800046c0:	eb cd 40 80 	pushm	r7,lr
800046c4:	1a 97       	mov	r7,sp
800046c6:	20 3d       	sub	sp,12
800046c8:	ef 4c ff f8 	st.w	r7[-8],r12
800046cc:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800046d0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046d4:	70 a8       	ld.w	r8,r8[0x28]
800046d6:	30 09       	mov	r9,0
800046d8:	ef 49 ff fc 	st.w	r7[-4],r9
800046dc:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800046e0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800046e4:	5c 58       	castu.b	r8
800046e6:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800046ea:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800046ee:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046f2:	f1 d9 d1 03 	bfins	r8,r9,0x8,0x3
800046f6:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800046fa:	ee f9 ff fc 	ld.w	r9,r7[-4]
800046fe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004702:	91 a9       	st.w	r8[0x28],r9

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80004704:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004708:	70 08       	ld.w	r8,r8[0x0]
8000470a:	10 99       	mov	r9,r8
8000470c:	a3 a9       	sbr	r9,0x2
8000470e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004712:	91 09       	st.w	r8[0x0],r9
}
80004714:	2f dd       	sub	sp,-12
80004716:	e3 cd 80 80 	ldm	sp++,r7,pc

8000471a <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
8000471a:	eb cd 40 80 	pushm	r7,lr
8000471e:	1a 97       	mov	r7,sp
80004720:	20 1d       	sub	sp,4
80004722:	ef 4c ff fc 	st.w	r7[-4],r12
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004726:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000472a:	71 58       	ld.w	r8,r8[0x54]
8000472c:	e2 18 00 80 	andl	r8,0x80,COH
80004730:	cf b0       	breq	80004726 <pm_wait_for_clk0_ready+0xc>
}
80004732:	2f fd       	sub	sp,-4
80004734:	e3 cd 80 80 	ldm	sp++,r7,pc

80004738 <pm_switch_to_clock>:
  return u_avr32_pm_mcctrl.MCCTRL.mcsel;
}


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
80004738:	eb cd 40 80 	pushm	r7,lr
8000473c:	1a 97       	mov	r7,sp
8000473e:	20 3d       	sub	sp,12
80004740:	ef 4c ff f8 	st.w	r7[-8],r12
80004744:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80004748:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000474c:	70 08       	ld.w	r8,r8[0x0]
8000474e:	30 09       	mov	r9,0
80004750:	ef 49 ff fc 	st.w	r7[-4],r9
80004754:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80004758:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000475c:	5c 58       	castu.b	r8
8000475e:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80004762:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80004766:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000476a:	f1 d9 d0 02 	bfins	r8,r9,0x0,0x2
8000476e:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80004772:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004776:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000477a:	91 09       	st.w	r8[0x0],r9
}
8000477c:	2f dd       	sub	sp,-12
8000477e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004782:	d7 03       	nop

80004784 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80004784:	eb cd 40 80 	pushm	r7,lr
80004788:	1a 97       	mov	r7,sp
8000478a:	20 3d       	sub	sp,12
8000478c:	ef 4c ff fc 	st.w	r7[-4],r12
80004790:	ef 4b ff f8 	st.w	r7[-8],r11
80004794:	ef 4a ff f4 	st.w	r7[-12],r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80004798:	ee fb ff f8 	ld.w	r11,r7[-8]
8000479c:	ee fc ff fc 	ld.w	r12,r7[-4]
800047a0:	f0 1f 00 08 	mcall	800047c0 <pm_switch_to_osc0+0x3c>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800047a4:	ee fb ff f4 	ld.w	r11,r7[-12]
800047a8:	ee fc ff fc 	ld.w	r12,r7[-4]
800047ac:	f0 1f 00 06 	mcall	800047c4 <pm_switch_to_osc0+0x40>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800047b0:	30 1b       	mov	r11,1
800047b2:	ee fc ff fc 	ld.w	r12,r7[-4]
800047b6:	f0 1f 00 05 	mcall	800047c8 <pm_switch_to_osc0+0x44>
}
800047ba:	2f dd       	sub	sp,-12
800047bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800047c0:	80 00       	ld.sh	r0,r0[0x0]
800047c2:	46 28       	lddsp	r8,sp[0x188]
800047c4:	80 00       	ld.sh	r0,r0[0x0]
800047c6:	46 8c       	lddsp	r12,sp[0x1a0]
800047c8:	80 00       	ld.sh	r0,r0[0x0]
800047ca:	47 38       	lddsp	r8,sp[0x1cc]

800047cc <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
800047cc:	eb cd 40 80 	pushm	r7,lr
800047d0:	1a 97       	mov	r7,sp
800047d2:	20 1d       	sub	sp,4
800047d4:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
800047d8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800047dc:	e6 18 00 01 	andh	r8,0x1,COH
800047e0:	5f 08       	sreq	r8
800047e2:	5c 58       	castu.b	r8
}
800047e4:	10 9c       	mov	r12,r8
800047e6:	2f fd       	sub	sp,-4
800047e8:	e3 cd 80 80 	ldm	sp++,r7,pc

800047ec <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800047ec:	eb cd 40 80 	pushm	r7,lr
800047f0:	1a 97       	mov	r7,sp
800047f2:	20 7d       	sub	sp,28
800047f4:	ef 4c ff ec 	st.w	r7[-20],r12
800047f8:	ef 4b ff e8 	st.w	r7[-24],r11
800047fc:	ef 4a ff e4 	st.w	r7[-28],r10
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004800:	ee f8 ff e8 	ld.w	r8,r7[-24]
80004804:	f0 09 15 04 	lsl	r9,r8,0x4
80004808:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000480c:	10 39       	cp.w	r9,r8
8000480e:	e0 8b 00 04 	brhi	80004816 <usart_set_async_baudrate+0x2a>
80004812:	31 08       	mov	r8,16
80004814:	c0 28       	rjmp	80004818 <usart_set_async_baudrate+0x2c>
80004816:	30 88       	mov	r8,8
80004818:	ef 48 ff f0 	st.w	r7[-16],r8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
8000481c:	ee f8 ff e4 	ld.w	r8,r7[-28]
80004820:	f0 09 15 03 	lsl	r9,r8,0x3
80004824:	ee fa ff f0 	ld.w	r10,r7[-16]
80004828:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000482c:	f4 08 02 48 	mul	r8,r10,r8
80004830:	a1 98       	lsr	r8,0x1
80004832:	f2 08 00 08 	add	r8,r9,r8
80004836:	ee fa ff f0 	ld.w	r10,r7[-16]
8000483a:	ee f9 ff e8 	ld.w	r9,r7[-24]
8000483e:	f4 09 02 49 	mul	r9,r10,r9
80004842:	f0 09 0d 08 	divu	r8,r8,r9
80004846:	ef 48 ff f4 	st.w	r7[-12],r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
8000484a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000484e:	a3 98       	lsr	r8,0x3
80004850:	ef 48 ff f8 	st.w	r7[-8],r8
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);
80004854:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004858:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000485c:	ef 48 ff fc 	st.w	r7[-4],r8

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004860:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004864:	58 08       	cp.w	r8,0
80004866:	c0 70       	breq	80004874 <usart_set_async_baudrate+0x88>
80004868:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000486c:	e0 48 ff ff 	cp.w	r8,65535
80004870:	e0 88 00 04 	brls	80004878 <usart_set_async_baudrate+0x8c>
    return USART_INVALID_INPUT;
80004874:	30 18       	mov	r8,1
80004876:	c2 08       	rjmp	800048b6 <usart_set_async_baudrate+0xca>

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004878:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000487c:	70 18       	ld.w	r8,r8[0x4]
8000487e:	10 99       	mov	r9,r8
80004880:	e4 19 ff f7 	andh	r9,0xfff7
80004884:	e0 19 fe cf 	andl	r9,0xfecf
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004888:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000488c:	59 08       	cp.w	r8,16
8000488e:	c0 40       	breq	80004896 <usart_set_async_baudrate+0xaa>
80004890:	e8 68 00 00 	mov	r8,524288
80004894:	c0 28       	rjmp	80004898 <usart_set_async_baudrate+0xac>
80004896:	30 08       	mov	r8,0
80004898:	10 49       	or	r9,r8
8000489a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000489e:	91 19       	st.w	r8[0x4],r9
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
                fp << AVR32_USART_BRGR_FP_OFFSET;
800048a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800048a4:	f0 09 15 10 	lsl	r9,r8,0x10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
800048a8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048ac:	10 49       	or	r9,r8
800048ae:	ee f8 ff ec 	ld.w	r8,r7[-20]
800048b2:	91 89       	st.w	r8[0x20],r9
                fp << AVR32_USART_BRGR_FP_OFFSET;

  return USART_SUCCESS;
800048b4:	30 08       	mov	r8,0
}
800048b6:	10 9c       	mov	r12,r8
800048b8:	2f 9d       	sub	sp,-28
800048ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800048be:	d7 03       	nop

800048c0 <usart_reset>:
 */
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
800048c0:	eb cd 40 80 	pushm	r7,lr
800048c4:	1a 97       	mov	r7,sp
800048c6:	20 2d       	sub	sp,8
800048c8:	ef 4c ff f8 	st.w	r7[-8],r12
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800048cc:	e1 b8 00 00 	mfsr	r8,0x0
800048d0:	10 9c       	mov	r12,r8
800048d2:	f0 1f 00 18 	mcall	80004930 <usart_reset+0x70>
800048d6:	18 98       	mov	r8,r12
800048d8:	ef 68 ff ff 	st.b	r7[-1],r8

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800048dc:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800048e0:	30 08       	mov	r8,0
800048e2:	f0 09 18 00 	cp.b	r9,r8
800048e6:	c0 20       	breq	800048ea <usart_reset+0x2a>
800048e8:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800048ea:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048ee:	3f f9       	mov	r9,-1
800048f0:	91 39       	st.w	r8[0xc],r9
  usart->csr;
800048f2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048f6:	70 58       	ld.w	r8,r8[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800048f8:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800048fc:	30 08       	mov	r8,0
800048fe:	f0 09 18 00 	cp.b	r9,r8
80004902:	c0 20       	breq	80004906 <usart_reset+0x46>
80004904:	d5 03       	csrf	0x10

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004906:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000490a:	30 09       	mov	r9,0
8000490c:	91 19       	st.w	r8[0x4],r9
  usart->rtor = 0;
8000490e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004912:	30 09       	mov	r9,0
80004914:	91 99       	st.w	r8[0x24],r9
  usart->ttgr = 0;
80004916:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000491a:	30 09       	mov	r9,0
8000491c:	91 a9       	st.w	r8[0x28],r9

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
8000491e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004922:	ea 69 61 0c 	mov	r9,680204
80004926:	91 09       	st.w	r8[0x0],r9
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004928:	2f ed       	sub	sp,-8
8000492a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000492e:	00 00       	add	r0,r0
80004930:	80 00       	ld.sh	r0,r0[0x0]
80004932:	47 cc       	lddsp	r12,sp[0x1f0]

80004934 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004934:	eb cd 40 80 	pushm	r7,lr
80004938:	1a 97       	mov	r7,sp
8000493a:	20 3d       	sub	sp,12
8000493c:	ef 4c ff fc 	st.w	r7[-4],r12
80004940:	ef 4b ff f8 	st.w	r7[-8],r11
80004944:	ef 4a ff f4 	st.w	r7[-12],r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004948:	ee fc ff fc 	ld.w	r12,r7[-4]
8000494c:	f0 1f 00 54 	mcall	80004a9c <usart_init_rs232+0x168>

  // Check input values.
  if (!opt || // Null pointer.
80004950:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004954:	58 08       	cp.w	r8,0
80004956:	c3 90       	breq	800049c8 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80004958:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000495c:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000495e:	30 48       	mov	r8,4
80004960:	f0 09 18 00 	cp.b	r9,r8
80004964:	e0 88 00 32 	brls	800049c8 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80004968:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000496c:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000496e:	30 98       	mov	r8,9
80004970:	f0 09 18 00 	cp.b	r9,r8
80004974:	e0 8b 00 2a 	brhi	800049c8 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004978:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000497c:	11 d9       	ld.ub	r9,r8[0x5]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000497e:	30 78       	mov	r8,7
80004980:	f0 09 18 00 	cp.b	r9,r8
80004984:	e0 8b 00 22 	brhi	800049c8 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
80004988:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000498c:	90 39       	ld.sh	r9,r8[0x6]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000498e:	e0 68 01 01 	mov	r8,257
80004992:	f0 09 19 00 	cp.h	r9,r8
80004996:	e0 8b 00 19 	brhi	800049c8 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
8000499a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000499e:	f1 39 00 08 	ld.ub	r9,r8[8]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800049a2:	30 38       	mov	r8,3
800049a4:	f0 09 18 00 	cp.b	r9,r8
800049a8:	e0 8b 00 10 	brhi	800049c8 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
800049ac:	ee f9 ff f4 	ld.w	r9,r7[-12]
800049b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049b4:	70 08       	ld.w	r8,r8[0x0]
800049b6:	12 9a       	mov	r10,r9
800049b8:	10 9b       	mov	r11,r8
800049ba:	ee fc ff fc 	ld.w	r12,r7[-4]
800049be:	f0 1f 00 39 	mcall	80004aa0 <usart_init_rs232+0x16c>
800049c2:	18 98       	mov	r8,r12
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800049c4:	58 18       	cp.w	r8,1
800049c6:	c0 31       	brne	800049cc <usart_init_rs232+0x98>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;
800049c8:	30 18       	mov	r8,1
800049ca:	c6 48       	rjmp	80004a92 <usart_init_rs232+0x15e>

  if (opt->charlength == 9)
800049cc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049d0:	11 c9       	ld.ub	r9,r8[0x4]
800049d2:	30 98       	mov	r8,9
800049d4:	f0 09 18 00 	cp.b	r9,r8
800049d8:	c0 a1       	brne	800049ec <usart_init_rs232+0xb8>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800049da:	ee f8 ff fc 	ld.w	r8,r7[-4]
800049de:	70 18       	ld.w	r8,r8[0x4]
800049e0:	10 99       	mov	r9,r8
800049e2:	b1 b9       	sbr	r9,0x11
800049e4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800049e8:	91 19       	st.w	r8[0x4],r9
800049ea:	c0 d8       	rjmp	80004a04 <usart_init_rs232+0xd0>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800049ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800049f0:	70 19       	ld.w	r9,r8[0x4]
800049f2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049f6:	11 c8       	ld.ub	r8,r8[0x4]
800049f8:	20 58       	sub	r8,5
800049fa:	a7 68       	lsl	r8,0x6
800049fc:	10 49       	or	r9,r8
800049fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a02:	91 19       	st.w	r8[0x4],r9
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004a04:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a08:	70 19       	ld.w	r9,r8[0x4]
80004a0a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a0e:	11 d8       	ld.ub	r8,r8[0x5]
80004a10:	f0 0a 15 09 	lsl	r10,r8,0x9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;
80004a14:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a18:	f1 38 00 08 	ld.ub	r8,r8[8]
80004a1c:	af 68       	lsl	r8,0xe
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004a1e:	f5 e8 10 08 	or	r8,r10,r8
80004a22:	10 49       	or	r9,r8
80004a24:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a28:	91 19       	st.w	r8[0x4],r9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004a2a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a2e:	90 39       	ld.sh	r9,r8[0x6]
80004a30:	30 28       	mov	r8,2
80004a32:	f0 09 19 00 	cp.h	r9,r8
80004a36:	e0 88 00 14 	brls	80004a5e <usart_init_rs232+0x12a>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004a3a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a3e:	70 18       	ld.w	r8,r8[0x4]
80004a40:	10 99       	mov	r9,r8
80004a42:	ad b9       	sbr	r9,0xd
80004a44:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a48:	91 19       	st.w	r8[0x4],r9
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004a4a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a4e:	90 38       	ld.sh	r8,r8[0x6]
80004a50:	5c 78       	castu.h	r8
80004a52:	20 28       	sub	r8,2
80004a54:	10 99       	mov	r9,r8
80004a56:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a5a:	91 a9       	st.w	r8[0x28],r9
80004a5c:	c0 d8       	rjmp	80004a76 <usart_init_rs232+0x142>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004a5e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a62:	70 19       	ld.w	r9,r8[0x4]
80004a64:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a68:	90 38       	ld.sh	r8,r8[0x6]
80004a6a:	5c 78       	castu.h	r8
80004a6c:	ad 68       	lsl	r8,0xc
80004a6e:	10 49       	or	r9,r8
80004a70:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a74:	91 19       	st.w	r8[0x4],r9

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004a76:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a7a:	70 18       	ld.w	r8,r8[0x4]
80004a7c:	10 99       	mov	r9,r8
80004a7e:	e0 19 ff f0 	andl	r9,0xfff0
80004a82:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a86:	91 19       	st.w	r8[0x4],r9
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004a88:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a8c:	35 09       	mov	r9,80
80004a8e:	91 09       	st.w	r8[0x0],r9
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004a90:	30 08       	mov	r8,0
}
80004a92:	10 9c       	mov	r12,r8
80004a94:	2f dd       	sub	sp,-12
80004a96:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a9a:	00 00       	add	r0,r0
80004a9c:	80 00       	ld.sh	r0,r0[0x0]
80004a9e:	48 c0       	lddpc	r0,80004acc <usart_write_char+0x28>
80004aa0:	80 00       	ld.sh	r0,r0[0x0]
80004aa2:	47 ec       	lddsp	r12,sp[0x1f8]

80004aa4 <usart_write_char>:
  return USART_SUCCESS;
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
80004aa4:	eb cd 40 80 	pushm	r7,lr
80004aa8:	1a 97       	mov	r7,sp
80004aaa:	20 3d       	sub	sp,12
80004aac:	ef 4c ff f8 	st.w	r7[-8],r12
80004ab0:	ef 4b ff f4 	st.w	r7[-12],r11
80004ab4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ab8:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004abc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ac0:	70 58       	ld.w	r8,r8[0x14]
80004ac2:	e2 18 00 02 	andl	r8,0x2,COH
80004ac6:	5f 18       	srne	r8
  if (usart_tx_ready(usart))
80004ac8:	58 08       	cp.w	r8,0
80004aca:	c0 a0       	breq	80004ade <usart_write_char+0x3a>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004acc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004ad0:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80004ad4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ad8:	91 79       	st.w	r8[0x1c],r9
    return USART_SUCCESS;
80004ada:	30 08       	mov	r8,0
80004adc:	c0 28       	rjmp	80004ae0 <usart_write_char+0x3c>
  }
  else
    return USART_TX_BUSY;
80004ade:	30 28       	mov	r8,2
}
80004ae0:	10 9c       	mov	r12,r8
80004ae2:	2f dd       	sub	sp,-12
80004ae4:	e3 cd 80 80 	ldm	sp++,r7,pc

80004ae8 <usart_putchar>:


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004ae8:	eb cd 40 80 	pushm	r7,lr
80004aec:	1a 97       	mov	r7,sp
80004aee:	20 3d       	sub	sp,12
80004af0:	ef 4c ff f8 	st.w	r7[-8],r12
80004af4:	ef 4b ff f4 	st.w	r7[-12],r11
  int timeout = USART_DEFAULT_TIMEOUT;
80004af8:	e0 68 27 10 	mov	r8,10000
80004afc:	ef 48 ff fc 	st.w	r7[-4],r8

  do
  {
    if (!timeout--) return USART_FAILURE;
80004b00:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b04:	58 08       	cp.w	r8,0
80004b06:	5f 08       	sreq	r8
80004b08:	5c 58       	castu.b	r8
80004b0a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004b0e:	20 19       	sub	r9,1
80004b10:	ef 49 ff fc 	st.w	r7[-4],r9
80004b14:	58 08       	cp.w	r8,0
80004b16:	c0 30       	breq	80004b1c <usart_putchar+0x34>
80004b18:	3f f8       	mov	r8,-1
80004b1a:	c0 b8       	rjmp	80004b30 <usart_putchar+0x48>
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004b1c:	ee fb ff f4 	ld.w	r11,r7[-12]
80004b20:	ee fc ff f8 	ld.w	r12,r7[-8]
80004b24:	f0 1f 00 05 	mcall	80004b38 <usart_putchar+0x50>
80004b28:	18 98       	mov	r8,r12
80004b2a:	58 08       	cp.w	r8,0
80004b2c:	ce a1       	brne	80004b00 <usart_putchar+0x18>

  return USART_SUCCESS;
80004b2e:	30 08       	mov	r8,0
}
80004b30:	10 9c       	mov	r12,r8
80004b32:	2f dd       	sub	sp,-12
80004b34:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b38:	80 00       	ld.sh	r0,r0[0x0]
80004b3a:	4a a4       	lddpc	r4,80004be0 <vListInitialise+0xc>

80004b3c <usart_read_char>:


int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
80004b3c:	eb cd 40 80 	pushm	r7,lr
80004b40:	1a 97       	mov	r7,sp
80004b42:	20 3d       	sub	sp,12
80004b44:	ef 4c ff f8 	st.w	r7[-8],r12
80004b48:	ef 4b ff f4 	st.w	r7[-12],r11
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004b4c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b50:	70 58       	ld.w	r8,r8[0x14]
80004b52:	e2 18 00 e0 	andl	r8,0xe0,COH
80004b56:	c0 30       	breq	80004b5c <usart_read_char+0x20>
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;
80004b58:	30 48       	mov	r8,4
80004b5a:	c1 68       	rjmp	80004b86 <usart_read_char+0x4a>
80004b5c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b60:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004b64:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b68:	70 58       	ld.w	r8,r8[0x14]
80004b6a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004b6e:	c0 b0       	breq	80004b84 <usart_read_char+0x48>
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004b70:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b74:	70 68       	ld.w	r8,r8[0x18]
80004b76:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80004b7a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004b7e:	91 09       	st.w	r8[0x0],r9
    return USART_SUCCESS;
80004b80:	30 08       	mov	r8,0
80004b82:	c0 28       	rjmp	80004b86 <usart_read_char+0x4a>
  }
  else
    return USART_RX_EMPTY;
80004b84:	30 38       	mov	r8,3
}
80004b86:	10 9c       	mov	r12,r8
80004b88:	2f dd       	sub	sp,-12
80004b8a:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b8e:	d7 03       	nop

80004b90 <usart_getchar>:


int usart_getchar(volatile avr32_usart_t *usart)
{
80004b90:	eb cd 40 80 	pushm	r7,lr
80004b94:	1a 97       	mov	r7,sp
80004b96:	20 3d       	sub	sp,12
80004b98:	ef 4c ff f4 	st.w	r7[-12],r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004b9c:	ee c8 00 08 	sub	r8,r7,8
80004ba0:	10 9b       	mov	r11,r8
80004ba2:	ee fc ff f4 	ld.w	r12,r7[-12]
80004ba6:	f0 1f 00 0b 	mcall	80004bd0 <usart_getchar+0x40>
80004baa:	18 98       	mov	r8,r12
80004bac:	ef 48 ff fc 	st.w	r7[-4],r8
80004bb0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bb4:	58 38       	cp.w	r8,3
80004bb6:	cf 30       	breq	80004b9c <usart_getchar+0xc>

  if (ret == USART_RX_ERROR)
80004bb8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bbc:	58 48       	cp.w	r8,4
80004bbe:	c0 31       	brne	80004bc4 <usart_getchar+0x34>
    return USART_FAILURE;
80004bc0:	3f f8       	mov	r8,-1
80004bc2:	c0 38       	rjmp	80004bc8 <usart_getchar+0x38>

  return c;
80004bc4:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80004bc8:	10 9c       	mov	r12,r8
80004bca:	2f dd       	sub	sp,-12
80004bcc:	e3 cd 80 80 	ldm	sp++,r7,pc
80004bd0:	80 00       	ld.sh	r0,r0[0x0]
80004bd2:	4b 3c       	lddpc	r12,80004c9c <vListInsertEnd+0x62>

80004bd4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
80004bd4:	eb cd 40 80 	pushm	r7,lr
80004bd8:	1a 97       	mov	r7,sp
80004bda:	20 1d       	sub	sp,4
80004bdc:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004be0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004be4:	2f 88       	sub	r8,-8
80004be6:	10 99       	mov	r9,r8
80004be8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bec:	91 19       	st.w	r8[0x4],r9

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004bee:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bf2:	3f f9       	mov	r9,-1
80004bf4:	91 29       	st.w	r8[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004bf6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bfa:	2f 88       	sub	r8,-8
80004bfc:	10 99       	mov	r9,r8
80004bfe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c02:	91 39       	st.w	r8[0xc],r9
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004c04:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c08:	2f 88       	sub	r8,-8
80004c0a:	10 99       	mov	r9,r8
80004c0c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c10:	91 49       	st.w	r8[0x10],r9

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004c12:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c16:	30 09       	mov	r9,0
80004c18:	91 09       	st.w	r8[0x0],r9
}
80004c1a:	2f fd       	sub	sp,-4
80004c1c:	e3 cd 80 80 	ldm	sp++,r7,pc

80004c20 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
80004c20:	eb cd 40 80 	pushm	r7,lr
80004c24:	1a 97       	mov	r7,sp
80004c26:	20 1d       	sub	sp,4
80004c28:	ef 4c ff fc 	st.w	r7[-4],r12
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004c2c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c30:	30 09       	mov	r9,0
80004c32:	91 49       	st.w	r8[0x10],r9
}
80004c34:	2f fd       	sub	sp,-4
80004c36:	e3 cd 80 80 	ldm	sp++,r7,pc

80004c3a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
80004c3a:	eb cd 40 80 	pushm	r7,lr
80004c3e:	1a 97       	mov	r7,sp
80004c40:	20 3d       	sub	sp,12
80004c42:	ef 4c ff f8 	st.w	r7[-8],r12
80004c46:	ef 4b ff f4 	st.w	r7[-12],r11

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004c4a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c4e:	70 18       	ld.w	r8,r8[0x4]
80004c50:	ef 48 ff fc 	st.w	r7[-4],r8

	pxNewListItem->pxNext = pxIndex->pxNext;
80004c54:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c58:	70 19       	ld.w	r9,r8[0x4]
80004c5a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004c5e:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004c60:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c64:	70 19       	ld.w	r9,r8[0x4]
80004c66:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004c6a:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004c6c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c70:	70 18       	ld.w	r8,r8[0x4]
80004c72:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004c76:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004c78:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004c7c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c80:	91 19       	st.w	r8[0x4],r9
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004c82:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004c86:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c8a:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004c8c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004c90:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004c94:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80004c96:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c9a:	70 08       	ld.w	r8,r8[0x0]
80004c9c:	f0 c9 ff ff 	sub	r9,r8,-1
80004ca0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ca4:	91 09       	st.w	r8[0x0],r9
}
80004ca6:	2f dd       	sub	sp,-12
80004ca8:	e3 cd 80 80 	ldm	sp++,r7,pc

80004cac <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
80004cac:	eb cd 40 80 	pushm	r7,lr
80004cb0:	1a 97       	mov	r7,sp
80004cb2:	20 4d       	sub	sp,16
80004cb4:	ef 4c ff f4 	st.w	r7[-12],r12
80004cb8:	ef 4b ff f0 	st.w	r7[-16],r11
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004cbc:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004cc0:	70 08       	ld.w	r8,r8[0x0]
80004cc2:	ef 48 ff fc 	st.w	r7[-4],r8
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004cc6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004cca:	5b f8       	cp.w	r8,-1
80004ccc:	c0 71       	brne	80004cda <vListInsert+0x2e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004cce:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004cd2:	70 48       	ld.w	r8,r8[0x10]
80004cd4:	ef 48 ff f8 	st.w	r7[-8],r8
80004cd8:	c1 58       	rjmp	80004d02 <vListInsert+0x56>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004cda:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004cde:	2f 88       	sub	r8,-8
80004ce0:	ef 48 ff f8 	st.w	r7[-8],r8
80004ce4:	c0 68       	rjmp	80004cf0 <vListInsert+0x44>
80004ce6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004cea:	70 18       	ld.w	r8,r8[0x4]
80004cec:	ef 48 ff f8 	st.w	r7[-8],r8
80004cf0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004cf4:	70 18       	ld.w	r8,r8[0x4]
80004cf6:	70 09       	ld.w	r9,r8[0x0]
80004cf8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004cfc:	10 39       	cp.w	r9,r8
80004cfe:	fe 98 ff f4 	brls	80004ce6 <vListInsert+0x3a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004d02:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d06:	70 19       	ld.w	r9,r8[0x4]
80004d08:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004d0c:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004d0e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004d12:	70 18       	ld.w	r8,r8[0x4]
80004d14:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004d18:	91 29       	st.w	r8[0x8],r9
	pxNewListItem->pxPrevious = pxIterator;
80004d1a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004d1e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004d22:	91 29       	st.w	r8[0x8],r9
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004d24:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004d28:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d2c:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004d2e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004d32:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004d36:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80004d38:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d3c:	70 08       	ld.w	r8,r8[0x0]
80004d3e:	f0 c9 ff ff 	sub	r9,r8,-1
80004d42:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d46:	91 09       	st.w	r8[0x0],r9
}
80004d48:	2f cd       	sub	sp,-16
80004d4a:	e3 cd 80 80 	ldm	sp++,r7,pc

80004d4e <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
80004d4e:	eb cd 40 80 	pushm	r7,lr
80004d52:	1a 97       	mov	r7,sp
80004d54:	20 2d       	sub	sp,8
80004d56:	ef 4c ff f8 	st.w	r7[-8],r12
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004d5a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d5e:	70 18       	ld.w	r8,r8[0x4]
80004d60:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004d64:	72 29       	ld.w	r9,r9[0x8]
80004d66:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004d68:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d6c:	70 28       	ld.w	r8,r8[0x8]
80004d6e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004d72:	72 19       	ld.w	r9,r9[0x4]
80004d74:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004d76:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d7a:	70 48       	ld.w	r8,r8[0x10]
80004d7c:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004d80:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d84:	70 19       	ld.w	r9,r8[0x4]
80004d86:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d8a:	10 39       	cp.w	r9,r8
80004d8c:	c0 71       	brne	80004d9a <vListRemove+0x4c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004d8e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d92:	70 29       	ld.w	r9,r8[0x8]
80004d94:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d98:	91 19       	st.w	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004d9a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d9e:	30 09       	mov	r9,0
80004da0:	91 49       	st.w	r8[0x10],r9
	( pxList->uxNumberOfItems )--;
80004da2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004da6:	70 08       	ld.w	r8,r8[0x0]
80004da8:	f0 c9 00 01 	sub	r9,r8,1
80004dac:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004db0:	91 09       	st.w	r8[0x0],r9
}
80004db2:	2f ed       	sub	sp,-8
80004db4:	e3 cd 80 80 	ldm	sp++,r7,pc

80004db8 <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80004db8:	eb cd 40 80 	pushm	r7,lr
80004dbc:	1a 97       	mov	r7,sp
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
80004dbe:	48 e8       	lddpc	r8,80004df4 <_init_startup+0x3c>
80004dc0:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
80004dc4:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
80004dc6:	f0 1f 00 0d 	mcall	80004df8 <_init_startup+0x40>
			.channelmode = USART_NORMAL_CHMODE
		};

		/* Initialize the USART used for the debug trace with the configured parameters. */
		extern volatile avr32_usart_t *volatile stdio_usart_base;
		stdio_usart_base = configDBG_USART;
80004dca:	48 d8       	lddpc	r8,80004dfc <_init_startup+0x44>
80004dcc:	fe 79 18 00 	mov	r9,-59392
80004dd0:	91 09       	st.w	r8[0x0],r9
		gpio_enable_module( DBG_USART_GPIO_MAP,
80004dd2:	30 2b       	mov	r11,2
80004dd4:	48 bc       	lddpc	r12,80004e00 <_init_startup+0x48>
80004dd6:	f0 1f 00 0c 	mcall	80004e04 <_init_startup+0x4c>
		                    sizeof( DBG_USART_GPIO_MAP ) / sizeof( DBG_USART_GPIO_MAP[0] ) );
		usart_init_rs232(configDBG_USART, &DBG_USART_OPTIONS, configPBA_CLOCK_HZ);
80004dda:	e0 6a 1b 00 	mov	r10,6912
80004dde:	ea 1a 00 b7 	orh	r10,0xb7
80004de2:	48 ab       	lddpc	r11,80004e08 <_init_startup+0x50>
80004de4:	fe 7c 18 00 	mov	r12,-59392
80004de8:	f0 1f 00 09 	mcall	80004e0c <_init_startup+0x54>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
80004dec:	30 18       	mov	r8,1
}
80004dee:	10 9c       	mov	r12,r8
80004df0:	e3 cd 80 80 	ldm	sp++,r7,pc
80004df4:	80 00       	ld.sh	r0,r0[0x0]
80004df6:	c2 00       	breq	80004e36 <__malloc_unlock+0xa>
80004df8:	80 00       	ld.sh	r0,r0[0x0]
80004dfa:	44 70       	lddsp	r0,sp[0x11c]
80004dfc:	00 00       	add	r0,r0
80004dfe:	08 0c       	add	r12,r4
80004e00:	80 00       	ld.sh	r0,r0[0x0]
80004e02:	c5 14       	brge	80004ea4 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
80004e04:	80 00       	ld.sh	r0,r0[0x0]
80004e06:	41 94       	lddsp	r4,sp[0x64]
80004e08:	80 00       	ld.sh	r0,r0[0x0]
80004e0a:	c5 24       	brge	80004eae <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0xa>
80004e0c:	80 00       	ld.sh	r0,r0[0x0]
80004e0e:	49 34       	lddpc	r4,80004e58 <vTick+0x10>

80004e10 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80004e10:	eb cd 40 80 	pushm	r7,lr
80004e14:	1a 97       	mov	r7,sp
80004e16:	20 1d       	sub	sp,4
80004e18:	ef 4c ff fc 	st.w	r7[-4],r12
	vTaskSuspendAll();
80004e1c:	f0 1f 00 03 	mcall	80004e28 <__malloc_lock+0x18>
}
80004e20:	2f fd       	sub	sp,-4
80004e22:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e26:	00 00       	add	r0,r0
80004e28:	80 00       	ld.sh	r0,r0[0x0]
80004e2a:	5d 28       	mustr	r8

80004e2c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80004e2c:	eb cd 40 80 	pushm	r7,lr
80004e30:	1a 97       	mov	r7,sp
80004e32:	20 1d       	sub	sp,4
80004e34:	ef 4c ff fc 	st.w	r7[-4],r12
	xTaskResumeAll();
80004e38:	f0 1f 00 03 	mcall	80004e44 <__malloc_unlock+0x18>
}
80004e3c:	2f fd       	sub	sp,-4
80004e3e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e42:	00 00       	add	r0,r0
80004e44:	80 00       	ld.sh	r0,r0[0x0]
80004e46:	5d 44       	*unknown*

80004e48 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004e48:	eb cd 00 ff 	pushm	r0-r7
80004e4c:	e0 68 00 20 	mov	r8,32
80004e50:	ea 18 00 00 	orh	r8,0x0
80004e54:	70 00       	ld.w	r0,r8[0x0]
80004e56:	1a d0       	st.w	--sp,r0
80004e58:	7a 90       	ld.w	r0,sp[0x24]
80004e5a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004e5e:	58 10       	cp.w	r0,1
80004e60:	e0 8b 00 08 	brhi	80004e70 <LABEL_INT_SKIP_SAVE_CONTEXT_234>
80004e64:	e0 68 06 60 	mov	r8,1632
80004e68:	ea 18 00 00 	orh	r8,0x0
80004e6c:	70 00       	ld.w	r0,r8[0x0]
80004e6e:	81 0d       	st.w	r0[0x0],sp

80004e70 <LABEL_INT_SKIP_SAVE_CONTEXT_234>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80004e70:	f0 1f 00 12 	mcall	80004eb8 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80004e74:	f0 1f 00 12 	mcall	80004ebc <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
		vTaskIncrementTick();
80004e78:	f0 1f 00 12 	mcall	80004ec0 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x1c>
	portEXIT_CRITICAL();
80004e7c:	f0 1f 00 12 	mcall	80004ec4 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80004e80:	7a 90       	ld.w	r0,sp[0x24]
80004e82:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004e86:	58 10       	cp.w	r0,1
80004e88:	e0 8b 00 0e 	brhi	80004ea4 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
80004e8c:	f0 1f 00 0c 	mcall	80004ebc <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
80004e90:	f0 1f 00 0e 	mcall	80004ec8 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x24>
80004e94:	f0 1f 00 0c 	mcall	80004ec4 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>
80004e98:	e0 68 06 60 	mov	r8,1632
80004e9c:	ea 18 00 00 	orh	r8,0x0
80004ea0:	70 00       	ld.w	r0,r8[0x0]
80004ea2:	60 0d       	ld.w	sp,r0[0x0]

80004ea4 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>:
80004ea4:	1b 00       	ld.w	r0,sp++
80004ea6:	e0 68 00 20 	mov	r8,32
80004eaa:	ea 18 00 00 	orh	r8,0x0
80004eae:	91 00       	st.w	r8[0x0],r0
80004eb0:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004eb4:	d6 03       	rete
80004eb6:	00 00       	add	r0,r0
80004eb8:	80 00       	ld.sh	r0,r0[0x0]
80004eba:	51 b4       	stdsp	sp[0x6c],r4
80004ebc:	80 00       	ld.sh	r0,r0[0x0]
80004ebe:	4f 64       	lddpc	r4,80005094 <pxPortInitialiseStack+0xe8>
80004ec0:	80 00       	ld.sh	r0,r0[0x0]
80004ec2:	5e 9c       	retgt	r12
80004ec4:	80 00       	ld.sh	r0,r0[0x0]
80004ec6:	4f 80       	lddpc	r0,800050a4 <pxPortInitialiseStack+0xf8>
80004ec8:	80 00       	ld.sh	r0,r0[0x0]
80004eca:	5f fc       	sral	r12

80004ecc <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004ecc:	20 6d       	sub	sp,24
80004ece:	eb cd 00 ff 	pushm	r0-r7
80004ed2:	fa c7 ff c0 	sub	r7,sp,-64
80004ed6:	ee f0 ff f8 	ld.w	r0,r7[-8]
80004eda:	ef 40 ff e0 	st.w	r7[-32],r0
80004ede:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004ee2:	ef 40 ff e4 	st.w	r7[-28],r0
80004ee6:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80004eea:	e0 68 00 20 	mov	r8,32
80004eee:	ea 18 00 00 	orh	r8,0x0
80004ef2:	70 00       	ld.w	r0,r8[0x0]
80004ef4:	1a d0       	st.w	--sp,r0
80004ef6:	f0 1f 00 1a 	mcall	80004f5c <LABEL_RET_SCALL_260+0x14>
80004efa:	e0 68 06 60 	mov	r8,1632
80004efe:	ea 18 00 00 	orh	r8,0x0
80004f02:	70 00       	ld.w	r0,r8[0x0]
80004f04:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80004f06:	f0 1f 00 17 	mcall	80004f60 <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
80004f0a:	e0 68 06 60 	mov	r8,1632
80004f0e:	ea 18 00 00 	orh	r8,0x0
80004f12:	70 00       	ld.w	r0,r8[0x0]
80004f14:	60 0d       	ld.w	sp,r0[0x0]
80004f16:	1b 00       	ld.w	r0,sp++
80004f18:	e0 68 00 20 	mov	r8,32
80004f1c:	ea 18 00 00 	orh	r8,0x0
80004f20:	91 00       	st.w	r8[0x0],r0
80004f22:	fa c7 ff d8 	sub	r7,sp,-40
80004f26:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80004f2a:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004f2e:	e0 61 00 20 	mov	r1,32
80004f32:	ea 11 00 00 	orh	r1,0x0
80004f36:	62 02       	ld.w	r2,r1[0x0]
80004f38:	58 02       	cp.w	r2,0
80004f3a:	c0 70       	breq	80004f48 <LABEL_RET_SCALL_260>
80004f3c:	e4 c2 00 01 	sub	r2,r2,1
80004f40:	83 02       	st.w	r1[0x0],r2
80004f42:	58 02       	cp.w	r2,0
80004f44:	c0 21       	brne	80004f48 <LABEL_RET_SCALL_260>
80004f46:	b1 c0       	cbr	r0,0x10

80004f48 <LABEL_RET_SCALL_260>:
80004f48:	ef 40 ff f8 	st.w	r7[-8],r0
80004f4c:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004f50:	ef 40 ff fc 	st.w	r7[-4],r0
80004f54:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004f58:	2f ad       	sub	sp,-24
80004f5a:	d6 13       	rets
80004f5c:	80 00       	ld.sh	r0,r0[0x0]
80004f5e:	4f 64       	lddpc	r4,80005134 <pxPortInitialiseStack+0x188>
80004f60:	80 00       	ld.sh	r0,r0[0x0]
80004f62:	5f fc       	sral	r12

80004f64 <vPortEnterCritical>:
/* The code generated by the GCC compiler uses the stack in different ways at
different optimisation levels.  The interrupt flags can therefore not always
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
80004f64:	eb cd 40 80 	pushm	r7,lr
80004f68:	1a 97       	mov	r7,sp
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004f6a:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80004f6c:	48 48       	lddpc	r8,80004f7c <vPortEnterCritical+0x18>
80004f6e:	70 08       	ld.w	r8,r8[0x0]
80004f70:	f0 c9 ff ff 	sub	r9,r8,-1
80004f74:	48 28       	lddpc	r8,80004f7c <vPortEnterCritical+0x18>
80004f76:	91 09       	st.w	r8[0x0],r9
}
80004f78:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f7c:	00 00       	add	r0,r0
80004f7e:	00 20       	rsub	r0,r0

80004f80 <vPortExitCritical>:
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
80004f80:	eb cd 40 80 	pushm	r7,lr
80004f84:	1a 97       	mov	r7,sp
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004f86:	48 98       	lddpc	r8,80004fa8 <vPortExitCritical+0x28>
80004f88:	70 08       	ld.w	r8,r8[0x0]
80004f8a:	58 08       	cp.w	r8,0
80004f8c:	c0 c0       	breq	80004fa4 <vPortExitCritical+0x24>
	{
		ulCriticalNesting--;
80004f8e:	48 78       	lddpc	r8,80004fa8 <vPortExitCritical+0x28>
80004f90:	70 08       	ld.w	r8,r8[0x0]
80004f92:	f0 c9 00 01 	sub	r9,r8,1
80004f96:	48 58       	lddpc	r8,80004fa8 <vPortExitCritical+0x28>
80004f98:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004f9a:	48 48       	lddpc	r8,80004fa8 <vPortExitCritical+0x28>
80004f9c:	70 08       	ld.w	r8,r8[0x0]
80004f9e:	58 08       	cp.w	r8,0
80004fa0:	c0 21       	brne	80004fa4 <vPortExitCritical+0x24>
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80004fa2:	d5 03       	csrf	0x10
		}
	}
}
80004fa4:	e3 cd 80 80 	ldm	sp++,r7,pc
80004fa8:	00 00       	add	r0,r0
80004faa:	00 20       	rsub	r0,r0

80004fac <pxPortInitialiseStack>:
 * portSAVE_CONTEXT had been called.
 *
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
80004fac:	eb cd 40 80 	pushm	r7,lr
80004fb0:	1a 97       	mov	r7,sp
80004fb2:	20 3d       	sub	sp,12
80004fb4:	ef 4c ff fc 	st.w	r7[-4],r12
80004fb8:	ef 4b ff f8 	st.w	r7[-8],r11
80004fbc:	ef 4a ff f4 	st.w	r7[-12],r10
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
80004fc0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004fc4:	20 48       	sub	r8,4
80004fc6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004fca:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004fce:	e0 69 08 08 	mov	r9,2056
80004fd2:	ea 19 08 08 	orh	r9,0x808
80004fd6:	91 09       	st.w	r8[0x0],r9
80004fd8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004fdc:	20 48       	sub	r8,4
80004fde:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80004fe2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004fe6:	e0 69 09 09 	mov	r9,2313
80004fea:	ea 19 09 09 	orh	r9,0x909
80004fee:	91 09       	st.w	r8[0x0],r9
80004ff0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ff4:	20 48       	sub	r8,4
80004ff6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004ffa:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ffe:	e0 69 0a 0a 	mov	r9,2570
80005002:	ea 19 0a 0a 	orh	r9,0xa0a
80005006:	91 09       	st.w	r8[0x0],r9
80005008:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000500c:	20 48       	sub	r8,4
8000500e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005012:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005016:	e0 69 0b 0b 	mov	r9,2827
8000501a:	ea 19 0b 0b 	orh	r9,0xb0b
8000501e:	91 09       	st.w	r8[0x0],r9
80005020:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005024:	20 48       	sub	r8,4
80005026:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
8000502a:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000502e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005032:	91 09       	st.w	r8[0x0],r9
80005034:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005038:	20 48       	sub	r8,4
8000503a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
8000503e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005042:	e0 69 be ef 	mov	r9,48879
80005046:	ea 19 de ad 	orh	r9,0xdead
8000504a:	91 09       	st.w	r8[0x0],r9
8000504c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005050:	20 48       	sub	r8,4
80005052:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005056:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000505a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000505e:	91 09       	st.w	r8[0x0],r9
80005060:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005064:	20 48       	sub	r8,4
80005066:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
8000506a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000506e:	fc 19 00 40 	movh	r9,0x40
80005072:	91 09       	st.w	r8[0x0],r9
80005074:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005078:	20 48       	sub	r8,4
8000507a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
8000507e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005082:	e0 69 00 ff 	mov	r9,255
80005086:	ea 19 ff 00 	orh	r9,0xff00
8000508a:	91 09       	st.w	r8[0x0],r9
8000508c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005090:	20 48       	sub	r8,4
80005092:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005096:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000509a:	e0 69 01 01 	mov	r9,257
8000509e:	ea 19 01 01 	orh	r9,0x101
800050a2:	91 09       	st.w	r8[0x0],r9
800050a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050a8:	20 48       	sub	r8,4
800050aa:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
800050ae:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050b2:	e0 69 02 02 	mov	r9,514
800050b6:	ea 19 02 02 	orh	r9,0x202
800050ba:	91 09       	st.w	r8[0x0],r9
800050bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050c0:	20 48       	sub	r8,4
800050c2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
800050c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050ca:	e0 69 03 03 	mov	r9,771
800050ce:	ea 19 03 03 	orh	r9,0x303
800050d2:	91 09       	st.w	r8[0x0],r9
800050d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050d8:	20 48       	sub	r8,4
800050da:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
800050de:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050e2:	e0 69 04 04 	mov	r9,1028
800050e6:	ea 19 04 04 	orh	r9,0x404
800050ea:	91 09       	st.w	r8[0x0],r9
800050ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050f0:	20 48       	sub	r8,4
800050f2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800050f6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050fa:	e0 69 05 05 	mov	r9,1285
800050fe:	ea 19 05 05 	orh	r9,0x505
80005102:	91 09       	st.w	r8[0x0],r9
80005104:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005108:	20 48       	sub	r8,4
8000510a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
8000510e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005112:	e0 69 06 06 	mov	r9,1542
80005116:	ea 19 06 06 	orh	r9,0x606
8000511a:	91 09       	st.w	r8[0x0],r9
8000511c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005120:	20 48       	sub	r8,4
80005122:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005126:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000512a:	e0 69 07 07 	mov	r9,1799
8000512e:	ea 19 07 07 	orh	r9,0x707
80005132:	91 09       	st.w	r8[0x0],r9
80005134:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005138:	20 48       	sub	r8,4
8000513a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
8000513e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005142:	30 09       	mov	r9,0
80005144:	91 09       	st.w	r8[0x0],r9

	return pxTopOfStack;
80005146:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000514a:	10 9c       	mov	r12,r8
8000514c:	2f dd       	sub	sp,-12
8000514e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005152:	d7 03       	nop

80005154 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005154:	eb cd 40 80 	pushm	r7,lr
80005158:	1a 97       	mov	r7,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
8000515a:	f0 1f 00 10 	mcall	80005198 <xPortStartScheduler+0x44>

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000515e:	e0 68 06 60 	mov	r8,1632
80005162:	ea 18 00 00 	orh	r8,0x0
80005166:	70 00       	ld.w	r0,r8[0x0]
80005168:	60 0d       	ld.w	sp,r0[0x0]
8000516a:	1b 00       	ld.w	r0,sp++
8000516c:	e0 68 00 20 	mov	r8,32
80005170:	ea 18 00 00 	orh	r8,0x0
80005174:	91 00       	st.w	r8[0x0],r0
80005176:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000517a:	2f ed       	sub	sp,-8
8000517c:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005180:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005184:	e3 b0 00 00 	mtsr	0x0,r0
80005188:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000518c:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
80005190:	30 08       	mov	r8,0
}
80005192:	10 9c       	mov	r12,r8
80005194:	e3 cd 80 80 	ldm	sp++,r7,pc
80005198:	80 00       	ld.sh	r0,r0[0x0]
8000519a:	51 c8       	stdsp	sp[0x70],r8

8000519c <prvScheduleFirstTick>:

/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
8000519c:	eb cd 40 80 	pushm	r7,lr
800051a0:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
800051a2:	e0 68 2e e0 	mov	r8,12000
800051a6:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800051aa:	30 08       	mov	r8,0
800051ac:	e3 b8 00 42 	mtsr	0x108,r8
	}
800051b0:	e3 cd 80 80 	ldm	sp++,r7,pc

800051b4 <prvClearCcInt>:

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
800051b4:	eb cd 40 80 	pushm	r7,lr
800051b8:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800051ba:	e1 b8 00 43 	mfsr	r8,0x10c
800051be:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800051c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800051c6:	d7 03       	nop

800051c8 <prvSetupTimerInterrupt>:
#endif
/*-----------------------------------------------------------*/

/* Setup the timer to generate the tick interrupts. */
static void prvSetupTimerInterrupt(void)
{
800051c8:	eb cd 40 80 	pushm	r7,lr
800051cc:	1a 97       	mov	r7,sp
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
800051ce:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
800051d0:	30 0a       	mov	r10,0
800051d2:	30 0b       	mov	r11,0
800051d4:	48 4c       	lddpc	r12,800051e4 <prvSetupTimerInterrupt+0x1c>
800051d6:	f0 1f 00 05 	mcall	800051e8 <prvSetupTimerInterrupt+0x20>
		prvScheduleFirstTick();
800051da:	f0 1f 00 05 	mcall	800051ec <prvSetupTimerInterrupt+0x24>
	}
	#endif
}
800051de:	e3 cd 80 80 	ldm	sp++,r7,pc
800051e2:	00 00       	add	r0,r0
800051e4:	80 00       	ld.sh	r0,r0[0x0]
800051e6:	4e 48       	lddpc	r8,80005374 <vPortFree+0x2c>
800051e8:	80 00       	ld.sh	r0,r0[0x0]
800051ea:	45 08       	lddsp	r8,sp[0x140]
800051ec:	80 00       	ld.sh	r0,r0[0x0]
800051ee:	51 9c       	stdsp	sp[0x64],r12

800051f0 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
800051f0:	eb cd 40 80 	pushm	r7,lr
800051f4:	1a 97       	mov	r7,sp
800051f6:	20 5d       	sub	sp,20
800051f8:	ef 4c ff f4 	st.w	r7[-12],r12
800051fc:	ef 4b ff f0 	st.w	r7[-16],r11
80005200:	ef 4a ff ec 	st.w	r7[-20],r10
  int nChars = 0;
80005204:	30 08       	mov	r8,0
80005206:	ef 48 ff f8 	st.w	r7[-8],r8

  if (file != 0)
8000520a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000520e:	58 08       	cp.w	r8,0
80005210:	c2 40       	breq	80005258 <_read+0x68>
    return -1;
80005212:	3f f8       	mov	r8,-1
80005214:	c2 b8       	rjmp	8000526a <_read+0x7a>

  for (; len > 0; --len)
  {
    int c = usart_getchar(stdio_usart_base);
80005216:	49 88       	lddpc	r8,80005274 <_read+0x84>
80005218:	70 08       	ld.w	r8,r8[0x0]
8000521a:	10 9c       	mov	r12,r8
8000521c:	f0 1f 00 17 	mcall	80005278 <_read+0x88>
80005220:	18 98       	mov	r8,r12
80005222:	ef 48 ff fc 	st.w	r7[-4],r8
    if (c < 0)
80005226:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000522a:	58 08       	cp.w	r8,0
8000522c:	c1 c5       	brlt	80005264 <_read+0x74>
      break;

    *ptr++ = c;
8000522e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005232:	5c 58       	castu.b	r8
80005234:	ee f9 ff f0 	ld.w	r9,r7[-16]
80005238:	b2 88       	st.b	r9[0x0],r8
8000523a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000523e:	2f f8       	sub	r8,-1
80005240:	ef 48 ff f0 	st.w	r7[-16],r8
    ++nChars;
80005244:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005248:	2f f8       	sub	r8,-1
8000524a:	ef 48 ff f8 	st.w	r7[-8],r8
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
8000524e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005252:	20 18       	sub	r8,1
80005254:	ef 48 ff ec 	st.w	r7[-20],r8
80005258:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000525c:	58 08       	cp.w	r8,0
8000525e:	fe 99 ff dc 	brgt	80005216 <_read+0x26>
80005262:	c0 28       	rjmp	80005266 <_read+0x76>
  {
    int c = usart_getchar(stdio_usart_base);
    if (c < 0)
      break;
80005264:	d7 03       	nop

    *ptr++ = c;
    ++nChars;
  }

  return nChars;
80005266:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
8000526a:	10 9c       	mov	r12,r8
8000526c:	2f bd       	sub	sp,-20
8000526e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005272:	00 00       	add	r0,r0
80005274:	00 00       	add	r0,r0
80005276:	08 0c       	add	r12,r4
80005278:	80 00       	ld.sh	r0,r0[0x0]
8000527a:	4b 90       	lddpc	r0,8000535c <vPortFree+0x14>

8000527c <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
8000527c:	eb cd 40 80 	pushm	r7,lr
80005280:	1a 97       	mov	r7,sp
80005282:	20 4d       	sub	sp,16
80005284:	ef 4c ff f8 	st.w	r7[-8],r12
80005288:	ef 4b ff f4 	st.w	r7[-12],r11
8000528c:	ef 4a ff f0 	st.w	r7[-16],r10
  int nChars = 0;
80005290:	30 08       	mov	r8,0
80005292:	ef 48 ff fc 	st.w	r7[-4],r8

  if ( (file != 1)
80005296:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000529a:	58 18       	cp.w	r8,1
8000529c:	c2 90       	breq	800052ee <_write+0x72>
8000529e:	ee f8 ff f8 	ld.w	r8,r7[-8]
800052a2:	58 28       	cp.w	r8,2
800052a4:	c2 50       	breq	800052ee <_write+0x72>
800052a6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800052aa:	58 38       	cp.w	r8,3
800052ac:	c2 10       	breq	800052ee <_write+0x72>
       && (file != 2) && (file!=3))
    return -1;
800052ae:	3f f8       	mov	r8,-1
800052b0:	c2 58       	rjmp	800052fa <_write+0x7e>

  for (; len != 0; --len)
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
800052b2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800052b6:	11 88       	ld.ub	r8,r8[0x0]
800052b8:	10 99       	mov	r9,r8
800052ba:	ee f8 ff f4 	ld.w	r8,r7[-12]
800052be:	2f f8       	sub	r8,-1
800052c0:	ef 48 ff f4 	st.w	r7[-12],r8
800052c4:	49 08       	lddpc	r8,80005304 <_write+0x88>
800052c6:	70 08       	ld.w	r8,r8[0x0]
800052c8:	12 9b       	mov	r11,r9
800052ca:	10 9c       	mov	r12,r8
800052cc:	f0 1f 00 0f 	mcall	80005308 <_write+0x8c>
800052d0:	18 98       	mov	r8,r12
800052d2:	58 08       	cp.w	r8,0
800052d4:	c0 34       	brge	800052da <_write+0x5e>
    {
      return -1;
800052d6:	3f f8       	mov	r8,-1
800052d8:	c1 18       	rjmp	800052fa <_write+0x7e>
    }

    ++nChars;
800052da:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052de:	2f f8       	sub	r8,-1
800052e0:	ef 48 ff fc 	st.w	r7[-4],r8

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800052e4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800052e8:	20 18       	sub	r8,1
800052ea:	ef 48 ff f0 	st.w	r7[-16],r8
800052ee:	ee f8 ff f0 	ld.w	r8,r7[-16]
800052f2:	58 08       	cp.w	r8,0
800052f4:	cd f1       	brne	800052b2 <_write+0x36>
    }

    ++nChars;
  }

  return nChars;
800052f6:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800052fa:	10 9c       	mov	r12,r8
800052fc:	2f cd       	sub	sp,-16
800052fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80005302:	00 00       	add	r0,r0
80005304:	00 00       	add	r0,r0
80005306:	08 0c       	add	r12,r4
80005308:	80 00       	ld.sh	r0,r0[0x0]
8000530a:	4a e8       	lddpc	r8,800053c0 <xQueueCreate+0x40>

8000530c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
8000530c:	eb cd 40 80 	pushm	r7,lr
80005310:	1a 97       	mov	r7,sp
80005312:	20 2d       	sub	sp,8
80005314:	ef 4c ff f8 	st.w	r7[-8],r12
void *pvReturn;

	vTaskSuspendAll();
80005318:	f0 1f 00 09 	mcall	8000533c <pvPortMalloc+0x30>
	{
		pvReturn = malloc( xWantedSize );
8000531c:	ee fc ff f8 	ld.w	r12,r7[-8]
80005320:	f0 1f 00 08 	mcall	80005340 <pvPortMalloc+0x34>
80005324:	18 98       	mov	r8,r12
80005326:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	xTaskResumeAll();
8000532a:	f0 1f 00 07 	mcall	80005344 <pvPortMalloc+0x38>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
8000532e:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005332:	10 9c       	mov	r12,r8
80005334:	2f ed       	sub	sp,-8
80005336:	e3 cd 80 80 	ldm	sp++,r7,pc
8000533a:	00 00       	add	r0,r0
8000533c:	80 00       	ld.sh	r0,r0[0x0]
8000533e:	5d 28       	mustr	r8
80005340:	80 00       	ld.sh	r0,r0[0x0]
80005342:	68 d0       	ld.w	r0,r4[0x34]
80005344:	80 00       	ld.sh	r0,r0[0x0]
80005346:	5d 44       	*unknown*

80005348 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005348:	eb cd 40 80 	pushm	r7,lr
8000534c:	1a 97       	mov	r7,sp
8000534e:	20 1d       	sub	sp,4
80005350:	ef 4c ff fc 	st.w	r7[-4],r12
	if( pv )
80005354:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005358:	58 08       	cp.w	r8,0
8000535a:	c0 90       	breq	8000536c <vPortFree+0x24>
	{
		vTaskSuspendAll();
8000535c:	f0 1f 00 06 	mcall	80005374 <vPortFree+0x2c>
		{
			free( pv );
80005360:	ee fc ff fc 	ld.w	r12,r7[-4]
80005364:	f0 1f 00 05 	mcall	80005378 <vPortFree+0x30>
		}
		xTaskResumeAll();
80005368:	f0 1f 00 05 	mcall	8000537c <vPortFree+0x34>
	}
}
8000536c:	2f fd       	sub	sp,-4
8000536e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005372:	00 00       	add	r0,r0
80005374:	80 00       	ld.sh	r0,r0[0x0]
80005376:	5d 28       	mustr	r8
80005378:	80 00       	ld.sh	r0,r0[0x0]
8000537a:	68 c0       	ld.w	r0,r4[0x30]
8000537c:	80 00       	ld.sh	r0,r0[0x0]
8000537e:	5d 44       	*unknown*

80005380 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005380:	eb cd 40 80 	pushm	r7,lr
80005384:	1a 97       	mov	r7,sp
80005386:	20 5d       	sub	sp,20
80005388:	ef 4c ff f0 	st.w	r7[-16],r12
8000538c:	ef 4b ff ec 	st.w	r7[-20],r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
80005390:	30 08       	mov	r8,0
80005392:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005396:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000539a:	58 08       	cp.w	r8,0
8000539c:	c7 20       	breq	80005480 <xQueueCreate+0x100>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000539e:	34 cc       	mov	r12,76
800053a0:	f0 1f 00 3b 	mcall	8000548c <xQueueCreate+0x10c>
800053a4:	18 98       	mov	r8,r12
800053a6:	ef 48 ff f4 	st.w	r7[-12],r8
		if( pxNewQueue != NULL )
800053aa:	ee f8 ff f4 	ld.w	r8,r7[-12]
800053ae:	58 08       	cp.w	r8,0
800053b0:	c6 80       	breq	80005480 <xQueueCreate+0x100>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800053b2:	ee f9 ff f0 	ld.w	r9,r7[-16]
800053b6:	ee f8 ff ec 	ld.w	r8,r7[-20]
800053ba:	f2 08 02 48 	mul	r8,r9,r8
800053be:	2f f8       	sub	r8,-1
800053c0:	ef 48 ff f8 	st.w	r7[-8],r8

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800053c4:	ee fc ff f8 	ld.w	r12,r7[-8]
800053c8:	f0 1f 00 31 	mcall	8000548c <xQueueCreate+0x10c>
800053cc:	18 98       	mov	r8,r12
800053ce:	10 99       	mov	r9,r8
800053d0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800053d4:	91 09       	st.w	r8[0x0],r9
			if( pxNewQueue->pcHead != NULL )
800053d6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800053da:	70 08       	ld.w	r8,r8[0x0]
800053dc:	58 08       	cp.w	r8,0
800053de:	c4 d0       	breq	80005478 <xQueueCreate+0xf8>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800053e0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800053e4:	70 09       	ld.w	r9,r8[0x0]
800053e6:	ee fa ff f0 	ld.w	r10,r7[-16]
800053ea:	ee f8 ff ec 	ld.w	r8,r7[-20]
800053ee:	f4 08 02 48 	mul	r8,r10,r8
800053f2:	10 09       	add	r9,r8
800053f4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800053f8:	91 19       	st.w	r8[0x4],r9
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800053fa:	ee f8 ff f4 	ld.w	r8,r7[-12]
800053fe:	30 09       	mov	r9,0
80005400:	91 e9       	st.w	r8[0x38],r9
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005402:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005406:	70 09       	ld.w	r9,r8[0x0]
80005408:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000540c:	91 29       	st.w	r8[0x8],r9
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000540e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005412:	70 09       	ld.w	r9,r8[0x0]
80005414:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005418:	f0 ca 00 01 	sub	r10,r8,1
8000541c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005420:	f4 08 02 48 	mul	r8,r10,r8
80005424:	10 09       	add	r9,r8
80005426:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000542a:	91 39       	st.w	r8[0xc],r9
				pxNewQueue->uxLength = uxQueueLength;
8000542c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005430:	ee f9 ff f0 	ld.w	r9,r7[-16]
80005434:	91 f9       	st.w	r8[0x3c],r9
				pxNewQueue->uxItemSize = uxItemSize;
80005436:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000543a:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000543e:	f1 49 00 40 	st.w	r8[64],r9
				pxNewQueue->xRxLock = queueUNLOCKED;
80005442:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005446:	3f f9       	mov	r9,-1
80005448:	f1 49 00 44 	st.w	r8[68],r9
				pxNewQueue->xTxLock = queueUNLOCKED;
8000544c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005450:	3f f9       	mov	r9,-1
80005452:	f1 49 00 48 	st.w	r8[72],r9

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005456:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000545a:	2f 08       	sub	r8,-16
8000545c:	10 9c       	mov	r12,r8
8000545e:	f0 1f 00 0d 	mcall	80005490 <xQueueCreate+0x110>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005462:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005466:	2d c8       	sub	r8,-36
80005468:	10 9c       	mov	r12,r8
8000546a:	f0 1f 00 0a 	mcall	80005490 <xQueueCreate+0x110>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
8000546e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005472:	ef 48 ff fc 	st.w	r7[-4],r8
80005476:	c0 58       	rjmp	80005480 <xQueueCreate+0x100>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005478:	ee fc ff f4 	ld.w	r12,r7[-12]
8000547c:	f0 1f 00 06 	mcall	80005494 <xQueueCreate+0x114>
		}
	}

	configASSERT( xReturn );

	return xReturn;
80005480:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005484:	10 9c       	mov	r12,r8
80005486:	2f bd       	sub	sp,-20
80005488:	e3 cd 80 80 	ldm	sp++,r7,pc
8000548c:	80 00       	ld.sh	r0,r0[0x0]
8000548e:	53 0c       	stdsp	sp[0xc0],r12
80005490:	80 00       	ld.sh	r0,r0[0x0]
80005492:	4b d4       	lddpc	r4,80005584 <xQueueGenericSend+0xa8>
80005494:	80 00       	ld.sh	r0,r0[0x0]
80005496:	53 48       	stdsp	sp[0xd0],r8

80005498 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
80005498:	eb cd 40 80 	pushm	r7,lr
8000549c:	1a 97       	mov	r7,sp
8000549e:	20 3d       	sub	sp,12
800054a0:	ef 4c ff f8 	st.w	r7[-8],r12
800054a4:	ef 4b ff f4 	st.w	r7[-12],r11
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
800054a8:	30 0b       	mov	r11,0
800054aa:	ee fc ff f8 	ld.w	r12,r7[-8]
800054ae:	f0 1f 00 0b 	mcall	800054d8 <xQueueCreateCountingSemaphore+0x40>
800054b2:	18 98       	mov	r8,r12
800054b4:	ef 48 ff fc 	st.w	r7[-4],r8

		if( pxHandle != NULL )
800054b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800054bc:	58 08       	cp.w	r8,0
800054be:	c0 60       	breq	800054ca <xQueueCreateCountingSemaphore+0x32>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
800054c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800054c4:	ee f9 ff f4 	ld.w	r9,r7[-12]
800054c8:	91 e9       	st.w	r8[0x38],r9
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
800054ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
	}
800054ce:	10 9c       	mov	r12,r8
800054d0:	2f dd       	sub	sp,-12
800054d2:	e3 cd 80 80 	ldm	sp++,r7,pc
800054d6:	00 00       	add	r0,r0
800054d8:	80 00       	ld.sh	r0,r0[0x0]
800054da:	53 80       	stdsp	sp[0xe0],r0

800054dc <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800054dc:	eb cd 40 80 	pushm	r7,lr
800054e0:	1a 97       	mov	r7,sp
800054e2:	20 7d       	sub	sp,28
800054e4:	ef 4c ff f0 	st.w	r7[-16],r12
800054e8:	ef 4b ff ec 	st.w	r7[-20],r11
800054ec:	ef 4a ff e8 	st.w	r7[-24],r10
800054f0:	ef 49 ff e4 	st.w	r7[-28],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
800054f4:	30 08       	mov	r8,0
800054f6:	ef 48 ff fc 	st.w	r7[-4],r8
800054fa:	c0 28       	rjmp	800054fe <xQueueGenericSend+0x22>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
800054fc:	d7 03       	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800054fe:	f0 1f 00 47 	mcall	80005618 <xQueueGenericSend+0x13c>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005502:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005506:	70 e9       	ld.w	r9,r8[0x38]
80005508:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000550c:	70 f8       	ld.w	r8,r8[0x3c]
8000550e:	10 39       	cp.w	r9,r8
80005510:	c1 c2       	brcc	80005548 <xQueueGenericSend+0x6c>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005512:	ee fa ff e4 	ld.w	r10,r7[-28]
80005516:	ee fb ff ec 	ld.w	r11,r7[-20]
8000551a:	ee fc ff f0 	ld.w	r12,r7[-16]
8000551e:	f0 1f 00 40 	mcall	8000561c <xQueueGenericSend+0x140>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005522:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005526:	70 98       	ld.w	r8,r8[0x24]
80005528:	58 08       	cp.w	r8,0
8000552a:	c0 b0       	breq	80005540 <xQueueGenericSend+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
8000552c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005530:	2d c8       	sub	r8,-36
80005532:	10 9c       	mov	r12,r8
80005534:	f0 1f 00 3b 	mcall	80005620 <xQueueGenericSend+0x144>
80005538:	18 98       	mov	r8,r12
8000553a:	58 18       	cp.w	r8,1
8000553c:	c0 21       	brne	80005540 <xQueueGenericSend+0x64>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
8000553e:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005540:	f0 1f 00 39 	mcall	80005624 <xQueueGenericSend+0x148>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005544:	30 18       	mov	r8,1
80005546:	c6 58       	rjmp	80005610 <xQueueGenericSend+0x134>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005548:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000554c:	58 08       	cp.w	r8,0
8000554e:	c0 51       	brne	80005558 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005550:	f0 1f 00 35 	mcall	80005624 <xQueueGenericSend+0x148>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005554:	30 08       	mov	r8,0
80005556:	c5 d8       	rjmp	80005610 <xQueueGenericSend+0x134>
				}
				else if( xEntryTimeSet == pdFALSE )
80005558:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000555c:	58 08       	cp.w	r8,0
8000555e:	c0 91       	brne	80005570 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005560:	ee c8 00 0c 	sub	r8,r7,12
80005564:	10 9c       	mov	r12,r8
80005566:	f0 1f 00 31 	mcall	80005628 <xQueueGenericSend+0x14c>
					xEntryTimeSet = pdTRUE;
8000556a:	30 18       	mov	r8,1
8000556c:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}
		}
		taskEXIT_CRITICAL();
80005570:	f0 1f 00 2d 	mcall	80005624 <xQueueGenericSend+0x148>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005574:	f0 1f 00 2e 	mcall	8000562c <xQueueGenericSend+0x150>
		prvLockQueue( pxQueue );
80005578:	f0 1f 00 28 	mcall	80005618 <xQueueGenericSend+0x13c>
8000557c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005580:	71 18       	ld.w	r8,r8[0x44]
80005582:	5b f8       	cp.w	r8,-1
80005584:	c0 61       	brne	80005590 <xQueueGenericSend+0xb4>
80005586:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000558a:	30 09       	mov	r9,0
8000558c:	f1 49 00 44 	st.w	r8[68],r9
80005590:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005594:	71 28       	ld.w	r8,r8[0x48]
80005596:	5b f8       	cp.w	r8,-1
80005598:	c0 61       	brne	800055a4 <xQueueGenericSend+0xc8>
8000559a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000559e:	30 09       	mov	r9,0
800055a0:	f1 49 00 48 	st.w	r8[72],r9
800055a4:	f0 1f 00 20 	mcall	80005624 <xQueueGenericSend+0x148>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800055a8:	ee c9 00 18 	sub	r9,r7,24
800055ac:	ee c8 00 0c 	sub	r8,r7,12
800055b0:	12 9b       	mov	r11,r9
800055b2:	10 9c       	mov	r12,r8
800055b4:	f0 1f 00 1f 	mcall	80005630 <xQueueGenericSend+0x154>
800055b8:	18 98       	mov	r8,r12
800055ba:	58 08       	cp.w	r8,0
800055bc:	c2 31       	brne	80005602 <xQueueGenericSend+0x126>
		{
			if( prvIsQueueFull( pxQueue ) )
800055be:	ee fc ff f0 	ld.w	r12,r7[-16]
800055c2:	f0 1f 00 1d 	mcall	80005634 <xQueueGenericSend+0x158>
800055c6:	18 98       	mov	r8,r12
800055c8:	58 08       	cp.w	r8,0
800055ca:	c1 50       	breq	800055f4 <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800055cc:	ee f9 ff e8 	ld.w	r9,r7[-24]
800055d0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800055d4:	2f 08       	sub	r8,-16
800055d6:	12 9b       	mov	r11,r9
800055d8:	10 9c       	mov	r12,r8
800055da:	f0 1f 00 18 	mcall	80005638 <xQueueGenericSend+0x15c>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800055de:	ee fc ff f0 	ld.w	r12,r7[-16]
800055e2:	f0 1f 00 17 	mcall	8000563c <xQueueGenericSend+0x160>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800055e6:	f0 1f 00 17 	mcall	80005640 <xQueueGenericSend+0x164>
800055ea:	18 98       	mov	r8,r12
800055ec:	58 08       	cp.w	r8,0
800055ee:	c8 71       	brne	800054fc <xQueueGenericSend+0x20>
				{
					portYIELD_WITHIN_API();
800055f0:	d7 33       	scall
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
800055f2:	c8 6b       	rjmp	800054fe <xQueueGenericSend+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800055f4:	ee fc ff f0 	ld.w	r12,r7[-16]
800055f8:	f0 1f 00 11 	mcall	8000563c <xQueueGenericSend+0x160>
				( void ) xTaskResumeAll();
800055fc:	f0 1f 00 11 	mcall	80005640 <xQueueGenericSend+0x164>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80005600:	c7 fb       	rjmp	800054fe <xQueueGenericSend+0x22>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005602:	ee fc ff f0 	ld.w	r12,r7[-16]
80005606:	f0 1f 00 0e 	mcall	8000563c <xQueueGenericSend+0x160>
			( void ) xTaskResumeAll();
8000560a:	f0 1f 00 0e 	mcall	80005640 <xQueueGenericSend+0x164>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
8000560e:	30 08       	mov	r8,0
		}
	}
}
80005610:	10 9c       	mov	r12,r8
80005612:	2f 9d       	sub	sp,-28
80005614:	e3 cd 80 80 	ldm	sp++,r7,pc
80005618:	80 00       	ld.sh	r0,r0[0x0]
8000561a:	4f 64       	lddpc	r4,800057f0 <prvCopyDataToQueue>
8000561c:	80 00       	ld.sh	r0,r0[0x0]
8000561e:	57 f0       	stdsp	sp[0x1fc],r0
80005620:	80 00       	ld.sh	r0,r0[0x0]
80005622:	61 2c       	ld.w	r12,r0[0x48]
80005624:	80 00       	ld.sh	r0,r0[0x0]
80005626:	4f 80       	lddpc	r0,80005804 <prvCopyDataToQueue+0x14>
80005628:	80 00       	ld.sh	r0,r0[0x0]
8000562a:	61 fc       	ld.w	r12,r0[0x7c]
8000562c:	80 00       	ld.sh	r0,r0[0x0]
8000562e:	5d 28       	mustr	r8
80005630:	80 00       	ld.sh	r0,r0[0x0]
80005632:	62 2c       	ld.w	r12,r1[0x8]
80005634:	80 00       	ld.sh	r0,r0[0x0]
80005636:	5a 44       	cp.w	r4,-28
80005638:	80 00       	ld.sh	r0,r0[0x0]
8000563a:	60 ac       	ld.w	r12,r0[0x28]
8000563c:	80 00       	ld.sh	r0,r0[0x0]
8000563e:	59 3c       	cp.w	r12,19
80005640:	80 00       	ld.sh	r0,r0[0x0]
80005642:	5d 44       	*unknown*

80005644 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005644:	eb cd 40 80 	pushm	r7,lr
80005648:	1a 97       	mov	r7,sp
8000564a:	20 8d       	sub	sp,32
8000564c:	ef 4c ff ec 	st.w	r7[-20],r12
80005650:	ef 4b ff e8 	st.w	r7[-24],r11
80005654:	ef 4a ff e4 	st.w	r7[-28],r10
80005658:	ef 49 ff e0 	st.w	r7[-32],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
8000565c:	30 08       	mov	r8,0
8000565e:	ef 48 ff f8 	st.w	r7[-8],r8
80005662:	c0 28       	rjmp	80005666 <xQueueGenericReceive+0x22>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
80005664:	d7 03       	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005666:	f0 1f 00 58 	mcall	800057c4 <xQueueGenericReceive+0x180>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000566a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000566e:	70 e8       	ld.w	r8,r8[0x38]
80005670:	58 08       	cp.w	r8,0
80005672:	c4 00       	breq	800056f2 <xQueueGenericReceive+0xae>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005674:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005678:	70 38       	ld.w	r8,r8[0xc]
8000567a:	ef 48 ff fc 	st.w	r7[-4],r8

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000567e:	ee fb ff e8 	ld.w	r11,r7[-24]
80005682:	ee fc ff ec 	ld.w	r12,r7[-20]
80005686:	f0 1f 00 51 	mcall	800057c8 <xQueueGenericReceive+0x184>

				if( xJustPeeking == pdFALSE )
8000568a:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000568e:	58 08       	cp.w	r8,0
80005690:	c1 91       	brne	800056c2 <xQueueGenericReceive+0x7e>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005692:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005696:	70 e8       	ld.w	r8,r8[0x38]
80005698:	f0 c9 00 01 	sub	r9,r8,1
8000569c:	ee f8 ff ec 	ld.w	r8,r7[-20]
800056a0:	91 e9       	st.w	r8[0x38],r9
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800056a2:	ee f8 ff ec 	ld.w	r8,r7[-20]
800056a6:	70 48       	ld.w	r8,r8[0x10]
800056a8:	58 08       	cp.w	r8,0
800056aa:	c2 00       	breq	800056ea <xQueueGenericReceive+0xa6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800056ac:	ee f8 ff ec 	ld.w	r8,r7[-20]
800056b0:	2f 08       	sub	r8,-16
800056b2:	10 9c       	mov	r12,r8
800056b4:	f0 1f 00 46 	mcall	800057cc <xQueueGenericReceive+0x188>
800056b8:	18 98       	mov	r8,r12
800056ba:	58 18       	cp.w	r8,1
800056bc:	c1 71       	brne	800056ea <xQueueGenericReceive+0xa6>
						{
							portYIELD_WITHIN_API();
800056be:	d7 33       	scall
800056c0:	c1 58       	rjmp	800056ea <xQueueGenericReceive+0xa6>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800056c2:	ee f8 ff ec 	ld.w	r8,r7[-20]
800056c6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800056ca:	91 39       	st.w	r8[0xc],r9

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800056cc:	ee f8 ff ec 	ld.w	r8,r7[-20]
800056d0:	70 98       	ld.w	r8,r8[0x24]
800056d2:	58 08       	cp.w	r8,0
800056d4:	c0 b0       	breq	800056ea <xQueueGenericReceive+0xa6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800056d6:	ee f8 ff ec 	ld.w	r8,r7[-20]
800056da:	2d c8       	sub	r8,-36
800056dc:	10 9c       	mov	r12,r8
800056de:	f0 1f 00 3c 	mcall	800057cc <xQueueGenericReceive+0x188>
800056e2:	18 98       	mov	r8,r12
800056e4:	58 08       	cp.w	r8,0
800056e6:	c0 20       	breq	800056ea <xQueueGenericReceive+0xa6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800056e8:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800056ea:	f0 1f 00 3a 	mcall	800057d0 <xQueueGenericReceive+0x18c>
				return pdPASS;
800056ee:	30 18       	mov	r8,1
800056f0:	c6 68       	rjmp	800057bc <xQueueGenericReceive+0x178>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800056f2:	ee f8 ff e4 	ld.w	r8,r7[-28]
800056f6:	58 08       	cp.w	r8,0
800056f8:	c0 51       	brne	80005702 <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800056fa:	f0 1f 00 36 	mcall	800057d0 <xQueueGenericReceive+0x18c>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800056fe:	30 08       	mov	r8,0
80005700:	c5 e8       	rjmp	800057bc <xQueueGenericReceive+0x178>
				}
				else if( xEntryTimeSet == pdFALSE )
80005702:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005706:	58 08       	cp.w	r8,0
80005708:	c0 91       	brne	8000571a <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000570a:	ee c8 00 10 	sub	r8,r7,16
8000570e:	10 9c       	mov	r12,r8
80005710:	f0 1f 00 31 	mcall	800057d4 <xQueueGenericReceive+0x190>
					xEntryTimeSet = pdTRUE;
80005714:	30 18       	mov	r8,1
80005716:	ef 48 ff f8 	st.w	r7[-8],r8
				}
			}
		}
		taskEXIT_CRITICAL();
8000571a:	f0 1f 00 2e 	mcall	800057d0 <xQueueGenericReceive+0x18c>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000571e:	f0 1f 00 2f 	mcall	800057d8 <xQueueGenericReceive+0x194>
		prvLockQueue( pxQueue );
80005722:	f0 1f 00 29 	mcall	800057c4 <xQueueGenericReceive+0x180>
80005726:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000572a:	71 18       	ld.w	r8,r8[0x44]
8000572c:	5b f8       	cp.w	r8,-1
8000572e:	c0 61       	brne	8000573a <xQueueGenericReceive+0xf6>
80005730:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005734:	30 09       	mov	r9,0
80005736:	f1 49 00 44 	st.w	r8[68],r9
8000573a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000573e:	71 28       	ld.w	r8,r8[0x48]
80005740:	5b f8       	cp.w	r8,-1
80005742:	c0 61       	brne	8000574e <xQueueGenericReceive+0x10a>
80005744:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005748:	30 09       	mov	r9,0
8000574a:	f1 49 00 48 	st.w	r8[72],r9
8000574e:	f0 1f 00 21 	mcall	800057d0 <xQueueGenericReceive+0x18c>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005752:	ee c9 00 1c 	sub	r9,r7,28
80005756:	ee c8 00 10 	sub	r8,r7,16
8000575a:	12 9b       	mov	r11,r9
8000575c:	10 9c       	mov	r12,r8
8000575e:	f0 1f 00 20 	mcall	800057dc <xQueueGenericReceive+0x198>
80005762:	18 98       	mov	r8,r12
80005764:	58 08       	cp.w	r8,0
80005766:	c2 41       	brne	800057ae <xQueueGenericReceive+0x16a>
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005768:	ee fc ff ec 	ld.w	r12,r7[-20]
8000576c:	f0 1f 00 1d 	mcall	800057e0 <xQueueGenericReceive+0x19c>
80005770:	18 98       	mov	r8,r12
80005772:	58 08       	cp.w	r8,0
80005774:	c1 60       	breq	800057a0 <xQueueGenericReceive+0x15c>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005776:	ee f9 ff e4 	ld.w	r9,r7[-28]
8000577a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000577e:	2d c8       	sub	r8,-36
80005780:	12 9b       	mov	r11,r9
80005782:	10 9c       	mov	r12,r8
80005784:	f0 1f 00 18 	mcall	800057e4 <xQueueGenericReceive+0x1a0>
				prvUnlockQueue( pxQueue );
80005788:	ee fc ff ec 	ld.w	r12,r7[-20]
8000578c:	f0 1f 00 17 	mcall	800057e8 <xQueueGenericReceive+0x1a4>
				if( !xTaskResumeAll() )
80005790:	f0 1f 00 17 	mcall	800057ec <xQueueGenericReceive+0x1a8>
80005794:	18 98       	mov	r8,r12
80005796:	58 08       	cp.w	r8,0
80005798:	fe 91 ff 66 	brne	80005664 <xQueueGenericReceive+0x20>
				{
					portYIELD_WITHIN_API();
8000579c:	d7 33       	scall
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
8000579e:	c6 4b       	rjmp	80005666 <xQueueGenericReceive+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800057a0:	ee fc ff ec 	ld.w	r12,r7[-20]
800057a4:	f0 1f 00 11 	mcall	800057e8 <xQueueGenericReceive+0x1a4>
				( void ) xTaskResumeAll();
800057a8:	f0 1f 00 11 	mcall	800057ec <xQueueGenericReceive+0x1a8>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800057ac:	c5 db       	rjmp	80005666 <xQueueGenericReceive+0x22>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800057ae:	ee fc ff ec 	ld.w	r12,r7[-20]
800057b2:	f0 1f 00 0e 	mcall	800057e8 <xQueueGenericReceive+0x1a4>
			( void ) xTaskResumeAll();
800057b6:	f0 1f 00 0e 	mcall	800057ec <xQueueGenericReceive+0x1a8>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
800057ba:	30 08       	mov	r8,0
		}
	}
}
800057bc:	10 9c       	mov	r12,r8
800057be:	2f 8d       	sub	sp,-32
800057c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800057c4:	80 00       	ld.sh	r0,r0[0x0]
800057c6:	4f 64       	lddpc	r4,8000599c <prvUnlockQueue+0x60>
800057c8:	80 00       	ld.sh	r0,r0[0x0]
800057ca:	58 d0       	cp.w	r0,13
800057cc:	80 00       	ld.sh	r0,r0[0x0]
800057ce:	61 2c       	ld.w	r12,r0[0x48]
800057d0:	80 00       	ld.sh	r0,r0[0x0]
800057d2:	4f 80       	lddpc	r0,800059b0 <prvUnlockQueue+0x74>
800057d4:	80 00       	ld.sh	r0,r0[0x0]
800057d6:	61 fc       	ld.w	r12,r0[0x7c]
800057d8:	80 00       	ld.sh	r0,r0[0x0]
800057da:	5d 28       	mustr	r8
800057dc:	80 00       	ld.sh	r0,r0[0x0]
800057de:	62 2c       	ld.w	r12,r1[0x8]
800057e0:	80 00       	ld.sh	r0,r0[0x0]
800057e2:	5a 0c       	cp.w	r12,-32
800057e4:	80 00       	ld.sh	r0,r0[0x0]
800057e6:	60 ac       	ld.w	r12,r0[0x28]
800057e8:	80 00       	ld.sh	r0,r0[0x0]
800057ea:	59 3c       	cp.w	r12,19
800057ec:	80 00       	ld.sh	r0,r0[0x0]
800057ee:	5d 44       	*unknown*

800057f0 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800057f0:	eb cd 40 80 	pushm	r7,lr
800057f4:	1a 97       	mov	r7,sp
800057f6:	20 3d       	sub	sp,12
800057f8:	ef 4c ff fc 	st.w	r7[-4],r12
800057fc:	ef 4b ff f8 	st.w	r7[-8],r11
80005800:	ef 4a ff f4 	st.w	r7[-12],r10
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005804:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005808:	71 08       	ld.w	r8,r8[0x40]
8000580a:	58 08       	cp.w	r8,0
8000580c:	c5 40       	breq	800058b4 <prvCopyDataToQueue+0xc4>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000580e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005812:	58 08       	cp.w	r8,0
80005814:	c2 61       	brne	80005860 <prvCopyDataToQueue+0x70>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005816:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000581a:	71 09       	ld.w	r9,r8[0x40]
8000581c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005820:	70 28       	ld.w	r8,r8[0x8]
80005822:	12 9a       	mov	r10,r9
80005824:	ee fb ff f8 	ld.w	r11,r7[-8]
80005828:	10 9c       	mov	r12,r8
8000582a:	f0 1f 00 29 	mcall	800058cc <prvCopyDataToQueue+0xdc>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000582e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005832:	70 29       	ld.w	r9,r8[0x8]
80005834:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005838:	71 08       	ld.w	r8,r8[0x40]
8000583a:	10 09       	add	r9,r8
8000583c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005840:	91 29       	st.w	r8[0x8],r9
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005842:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005846:	70 29       	ld.w	r9,r8[0x8]
80005848:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000584c:	70 18       	ld.w	r8,r8[0x4]
8000584e:	10 39       	cp.w	r9,r8
80005850:	c3 23       	brcs	800058b4 <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005852:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005856:	70 09       	ld.w	r9,r8[0x0]
80005858:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000585c:	91 29       	st.w	r8[0x8],r9
8000585e:	c2 b8       	rjmp	800058b4 <prvCopyDataToQueue+0xc4>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005860:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005864:	71 09       	ld.w	r9,r8[0x40]
80005866:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000586a:	70 38       	ld.w	r8,r8[0xc]
8000586c:	12 9a       	mov	r10,r9
8000586e:	ee fb ff f8 	ld.w	r11,r7[-8]
80005872:	10 9c       	mov	r12,r8
80005874:	f0 1f 00 16 	mcall	800058cc <prvCopyDataToQueue+0xdc>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005878:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000587c:	70 39       	ld.w	r9,r8[0xc]
8000587e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005882:	71 08       	ld.w	r8,r8[0x40]
80005884:	5c 38       	neg	r8
80005886:	10 09       	add	r9,r8
80005888:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000588c:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000588e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005892:	70 39       	ld.w	r9,r8[0xc]
80005894:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005898:	70 08       	ld.w	r8,r8[0x0]
8000589a:	10 39       	cp.w	r9,r8
8000589c:	c0 c2       	brcc	800058b4 <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8000589e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058a2:	70 19       	ld.w	r9,r8[0x4]
800058a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058a8:	71 08       	ld.w	r8,r8[0x40]
800058aa:	5c 38       	neg	r8
800058ac:	10 09       	add	r9,r8
800058ae:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058b2:	91 39       	st.w	r8[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800058b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058b8:	70 e8       	ld.w	r8,r8[0x38]
800058ba:	f0 c9 ff ff 	sub	r9,r8,-1
800058be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058c2:	91 e9       	st.w	r8[0x38],r9
}
800058c4:	2f dd       	sub	sp,-12
800058c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800058ca:	00 00       	add	r0,r0
800058cc:	80 00       	ld.sh	r0,r0[0x0]
800058ce:	6d 18       	ld.w	r8,r6[0x44]

800058d0 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800058d0:	eb cd 40 80 	pushm	r7,lr
800058d4:	1a 97       	mov	r7,sp
800058d6:	20 2d       	sub	sp,8
800058d8:	ef 4c ff fc 	st.w	r7[-4],r12
800058dc:	ef 4b ff f8 	st.w	r7[-8],r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800058e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058e4:	70 08       	ld.w	r8,r8[0x0]
800058e6:	58 08       	cp.w	r8,0
800058e8:	c2 50       	breq	80005932 <prvCopyDataFromQueue+0x62>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
800058ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058ee:	70 39       	ld.w	r9,r8[0xc]
800058f0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058f4:	71 08       	ld.w	r8,r8[0x40]
800058f6:	10 09       	add	r9,r8
800058f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058fc:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
800058fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005902:	70 39       	ld.w	r9,r8[0xc]
80005904:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005908:	70 18       	ld.w	r8,r8[0x4]
8000590a:	10 39       	cp.w	r9,r8
8000590c:	c0 73       	brcs	8000591a <prvCopyDataFromQueue+0x4a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000590e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005912:	70 09       	ld.w	r9,r8[0x0]
80005914:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005918:	91 39       	st.w	r8[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
8000591a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000591e:	71 09       	ld.w	r9,r8[0x40]
80005920:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005924:	70 38       	ld.w	r8,r8[0xc]
80005926:	12 9a       	mov	r10,r9
80005928:	10 9b       	mov	r11,r8
8000592a:	ee fc ff f8 	ld.w	r12,r7[-8]
8000592e:	f0 1f 00 03 	mcall	80005938 <prvCopyDataFromQueue+0x68>
	}
}
80005932:	2f ed       	sub	sp,-8
80005934:	e3 cd 80 80 	ldm	sp++,r7,pc
80005938:	80 00       	ld.sh	r0,r0[0x0]
8000593a:	6d 18       	ld.w	r8,r6[0x44]

8000593c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
8000593c:	eb cd 40 80 	pushm	r7,lr
80005940:	1a 97       	mov	r7,sp
80005942:	20 1d       	sub	sp,4
80005944:	ef 4c ff fc 	st.w	r7[-4],r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005948:	f0 1f 00 2d 	mcall	800059fc <prvUnlockQueue+0xc0>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000594c:	c1 a8       	rjmp	80005980 <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000594e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005952:	70 98       	ld.w	r8,r8[0x24]
80005954:	58 08       	cp.w	r8,0
80005956:	c1 c0       	breq	8000598e <prvUnlockQueue+0x52>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005958:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000595c:	2d c8       	sub	r8,-36
8000595e:	10 9c       	mov	r12,r8
80005960:	f0 1f 00 28 	mcall	80005a00 <prvUnlockQueue+0xc4>
80005964:	18 98       	mov	r8,r12
80005966:	58 08       	cp.w	r8,0
80005968:	c0 30       	breq	8000596e <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
8000596a:	f0 1f 00 27 	mcall	80005a04 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xTxLock );
8000596e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005972:	71 28       	ld.w	r8,r8[0x48]
80005974:	f0 c9 00 01 	sub	r9,r8,1
80005978:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000597c:	f1 49 00 48 	st.w	r8[72],r9
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005980:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005984:	71 28       	ld.w	r8,r8[0x48]
80005986:	58 08       	cp.w	r8,0
80005988:	fe 99 ff e3 	brgt	8000594e <prvUnlockQueue+0x12>
8000598c:	c0 28       	rjmp	80005990 <prvUnlockQueue+0x54>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
8000598e:	d7 03       	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005990:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005994:	3f f9       	mov	r9,-1
80005996:	f1 49 00 48 	st.w	r8[72],r9
	}
	taskEXIT_CRITICAL();
8000599a:	f0 1f 00 1c 	mcall	80005a08 <prvUnlockQueue+0xcc>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
8000599e:	f0 1f 00 18 	mcall	800059fc <prvUnlockQueue+0xc0>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800059a2:	c1 a8       	rjmp	800059d6 <prvUnlockQueue+0x9a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800059a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059a8:	70 48       	ld.w	r8,r8[0x10]
800059aa:	58 08       	cp.w	r8,0
800059ac:	c1 c0       	breq	800059e4 <prvUnlockQueue+0xa8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800059ae:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059b2:	2f 08       	sub	r8,-16
800059b4:	10 9c       	mov	r12,r8
800059b6:	f0 1f 00 13 	mcall	80005a00 <prvUnlockQueue+0xc4>
800059ba:	18 98       	mov	r8,r12
800059bc:	58 08       	cp.w	r8,0
800059be:	c0 30       	breq	800059c4 <prvUnlockQueue+0x88>
				{
					vTaskMissedYield();
800059c0:	f0 1f 00 11 	mcall	80005a04 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xRxLock );
800059c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059c8:	71 18       	ld.w	r8,r8[0x44]
800059ca:	f0 c9 00 01 	sub	r9,r8,1
800059ce:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059d2:	f1 49 00 44 	st.w	r8[68],r9
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800059d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059da:	71 18       	ld.w	r8,r8[0x44]
800059dc:	58 08       	cp.w	r8,0
800059de:	fe 99 ff e3 	brgt	800059a4 <prvUnlockQueue+0x68>
800059e2:	c0 28       	rjmp	800059e6 <prvUnlockQueue+0xaa>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
800059e4:	d7 03       	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800059e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059ea:	3f f9       	mov	r9,-1
800059ec:	f1 49 00 44 	st.w	r8[68],r9
	}
	taskEXIT_CRITICAL();
800059f0:	f0 1f 00 06 	mcall	80005a08 <prvUnlockQueue+0xcc>
}
800059f4:	2f fd       	sub	sp,-4
800059f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800059fa:	00 00       	add	r0,r0
800059fc:	80 00       	ld.sh	r0,r0[0x0]
800059fe:	4f 64       	lddpc	r4,80005bd4 <xTaskGenericCreate+0x14c>
80005a00:	80 00       	ld.sh	r0,r0[0x0]
80005a02:	61 2c       	ld.w	r12,r0[0x48]
80005a04:	80 00       	ld.sh	r0,r0[0x0]
80005a06:	62 e4       	ld.w	r4,r1[0x38]
80005a08:	80 00       	ld.sh	r0,r0[0x0]
80005a0a:	4f 80       	lddpc	r0,80005be8 <xTaskGenericCreate+0x160>

80005a0c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
80005a0c:	eb cd 40 80 	pushm	r7,lr
80005a10:	1a 97       	mov	r7,sp
80005a12:	20 2d       	sub	sp,8
80005a14:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005a18:	f0 1f 00 09 	mcall	80005a3c <prvIsQueueEmpty+0x30>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005a1c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005a20:	70 e8       	ld.w	r8,r8[0x38]
80005a22:	58 08       	cp.w	r8,0
80005a24:	5f 08       	sreq	r8
80005a26:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80005a2a:	f0 1f 00 06 	mcall	80005a40 <prvIsQueueEmpty+0x34>

	return xReturn;
80005a2e:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005a32:	10 9c       	mov	r12,r8
80005a34:	2f ed       	sub	sp,-8
80005a36:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a3a:	00 00       	add	r0,r0
80005a3c:	80 00       	ld.sh	r0,r0[0x0]
80005a3e:	4f 64       	lddpc	r4,80005c14 <xTaskGenericCreate+0x18c>
80005a40:	80 00       	ld.sh	r0,r0[0x0]
80005a42:	4f 80       	lddpc	r0,80005c20 <xTaskGenericCreate+0x198>

80005a44 <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
80005a44:	eb cd 40 80 	pushm	r7,lr
80005a48:	1a 97       	mov	r7,sp
80005a4a:	20 2d       	sub	sp,8
80005a4c:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005a50:	f0 1f 00 0a 	mcall	80005a78 <prvIsQueueFull+0x34>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005a54:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005a58:	70 e9       	ld.w	r9,r8[0x38]
80005a5a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005a5e:	70 f8       	ld.w	r8,r8[0x3c]
80005a60:	10 39       	cp.w	r9,r8
80005a62:	5f 08       	sreq	r8
80005a64:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80005a68:	f0 1f 00 05 	mcall	80005a7c <prvIsQueueFull+0x38>

	return xReturn;
80005a6c:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005a70:	10 9c       	mov	r12,r8
80005a72:	2f ed       	sub	sp,-8
80005a74:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a78:	80 00       	ld.sh	r0,r0[0x0]
80005a7a:	4f 64       	lddpc	r4,80005c50 <vTaskDelay>
80005a7c:	80 00       	ld.sh	r0,r0[0x0]
80005a7e:	4f 80       	lddpc	r0,80005c5c <vTaskDelay+0xc>
80005a80:	49 44       	lddpc	r4,80005ad0 <xTaskGenericCreate+0x48>
80005a82:	4c 45       	lddpc	r5,80005b90 <xTaskGenericCreate+0x108>
80005a84:	00 00       	add	r0,r0
	...

80005a88 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005a88:	eb cd 40 c0 	pushm	r6-r7,lr
80005a8c:	1a 97       	mov	r7,sp
80005a8e:	20 8d       	sub	sp,32
80005a90:	ee c6 ff f4 	sub	r6,r7,-12
80005a94:	ef 4c ff f0 	st.w	r7[-16],r12
80005a98:	ef 4b ff ec 	st.w	r7[-20],r11
80005a9c:	ef 49 ff e4 	st.w	r7[-28],r9
80005aa0:	ef 48 ff e0 	st.w	r7[-32],r8
80005aa4:	14 98       	mov	r8,r10
80005aa6:	ef 58 ff e8 	st.h	r7[-24],r8
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
80005aaa:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80005aae:	6c 1b       	ld.w	r11,r6[0x4]
80005ab0:	10 9c       	mov	r12,r8
80005ab2:	f0 1f 00 5a 	mcall	80005c18 <xTaskGenericCreate+0x190>
80005ab6:	18 98       	mov	r8,r12
80005ab8:	ef 48 ff f8 	st.w	r7[-8],r8

	if( pxNewTCB != NULL )
80005abc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005ac0:	58 08       	cp.w	r8,0
80005ac2:	e0 80 00 92 	breq	80005be6 <xTaskGenericCreate+0x15e>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
80005ac6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005aca:	70 c9       	ld.w	r9,r8[0x30]
80005acc:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80005ad0:	20 18       	sub	r8,1
80005ad2:	a3 68       	lsl	r8,0x2
80005ad4:	f2 08 00 08 	add	r8,r9,r8
80005ad8:	ef 48 ff fc 	st.w	r7[-4],r8
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005adc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005ae0:	e0 18 ff fc 	andl	r8,0xfffc
80005ae4:	ef 48 ff fc 	st.w	r7[-4],r8
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
80005ae8:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80005aec:	6c 29       	ld.w	r9,r6[0x8]
80005aee:	ee fa ff e0 	ld.w	r10,r7[-32]
80005af2:	ee fb ff ec 	ld.w	r11,r7[-20]
80005af6:	ee fc ff f8 	ld.w	r12,r7[-8]
80005afa:	f0 1f 00 49 	mcall	80005c1c <xTaskGenericCreate+0x194>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005afe:	ee fa ff e4 	ld.w	r10,r7[-28]
80005b02:	ee fb ff f0 	ld.w	r11,r7[-16]
80005b06:	ee fc ff fc 	ld.w	r12,r7[-4]
80005b0a:	f0 1f 00 46 	mcall	80005c20 <xTaskGenericCreate+0x198>
80005b0e:	18 98       	mov	r8,r12
80005b10:	10 99       	mov	r9,r8
80005b12:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005b16:	91 09       	st.w	r8[0x0],r9
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
80005b18:	6c 08       	ld.w	r8,r6[0x0]
80005b1a:	58 08       	cp.w	r8,0
80005b1c:	c0 50       	breq	80005b26 <xTaskGenericCreate+0x9e>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005b1e:	6c 08       	ld.w	r8,r6[0x0]
80005b20:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005b24:	91 09       	st.w	r8[0x0],r9
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005b26:	f0 1f 00 40 	mcall	80005c24 <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
80005b2a:	4c 08       	lddpc	r8,80005c28 <xTaskGenericCreate+0x1a0>
80005b2c:	70 08       	ld.w	r8,r8[0x0]
80005b2e:	f0 c9 ff ff 	sub	r9,r8,-1
80005b32:	4b e8       	lddpc	r8,80005c28 <xTaskGenericCreate+0x1a0>
80005b34:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005b36:	4b e8       	lddpc	r8,80005c2c <xTaskGenericCreate+0x1a4>
80005b38:	70 08       	ld.w	r8,r8[0x0]
80005b3a:	58 08       	cp.w	r8,0
80005b3c:	c0 c1       	brne	80005b54 <xTaskGenericCreate+0xcc>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005b3e:	4b c8       	lddpc	r8,80005c2c <xTaskGenericCreate+0x1a4>
80005b40:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005b44:	91 09       	st.w	r8[0x0],r9

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005b46:	4b 98       	lddpc	r8,80005c28 <xTaskGenericCreate+0x1a0>
80005b48:	70 08       	ld.w	r8,r8[0x0]
80005b4a:	58 18       	cp.w	r8,1
80005b4c:	c1 41       	brne	80005b74 <xTaskGenericCreate+0xec>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
80005b4e:	f0 1f 00 39 	mcall	80005c30 <xTaskGenericCreate+0x1a8>
80005b52:	c1 18       	rjmp	80005b74 <xTaskGenericCreate+0xec>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005b54:	4b 88       	lddpc	r8,80005c34 <xTaskGenericCreate+0x1ac>
80005b56:	70 08       	ld.w	r8,r8[0x0]
80005b58:	58 08       	cp.w	r8,0
80005b5a:	c0 d1       	brne	80005b74 <xTaskGenericCreate+0xec>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005b5c:	4b 48       	lddpc	r8,80005c2c <xTaskGenericCreate+0x1a4>
80005b5e:	70 08       	ld.w	r8,r8[0x0]
80005b60:	70 b9       	ld.w	r9,r8[0x2c]
80005b62:	ee f8 ff e0 	ld.w	r8,r7[-32]
80005b66:	10 39       	cp.w	r9,r8
80005b68:	e0 8b 00 06 	brhi	80005b74 <xTaskGenericCreate+0xec>
					{
						pxCurrentTCB = pxNewTCB;
80005b6c:	4b 08       	lddpc	r8,80005c2c <xTaskGenericCreate+0x1a4>
80005b6e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005b72:	91 09       	st.w	r8[0x0],r9
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005b74:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005b78:	70 b9       	ld.w	r9,r8[0x2c]
80005b7a:	4b 08       	lddpc	r8,80005c38 <xTaskGenericCreate+0x1b0>
80005b7c:	70 08       	ld.w	r8,r8[0x0]
80005b7e:	10 39       	cp.w	r9,r8
80005b80:	e0 88 00 07 	brls	80005b8e <xTaskGenericCreate+0x106>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005b84:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005b88:	70 b9       	ld.w	r9,r8[0x2c]
80005b8a:	4a c8       	lddpc	r8,80005c38 <xTaskGenericCreate+0x1b0>
80005b8c:	91 09       	st.w	r8[0x0],r9
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005b8e:	4a c8       	lddpc	r8,80005c3c <xTaskGenericCreate+0x1b4>
80005b90:	70 08       	ld.w	r8,r8[0x0]
80005b92:	f0 c9 ff ff 	sub	r9,r8,-1
80005b96:	4a a8       	lddpc	r8,80005c3c <xTaskGenericCreate+0x1b4>
80005b98:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005b9a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005b9e:	70 b9       	ld.w	r9,r8[0x2c]
80005ba0:	4a 88       	lddpc	r8,80005c40 <xTaskGenericCreate+0x1b8>
80005ba2:	70 08       	ld.w	r8,r8[0x0]
80005ba4:	10 39       	cp.w	r9,r8
80005ba6:	e0 88 00 07 	brls	80005bb4 <xTaskGenericCreate+0x12c>
80005baa:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005bae:	70 b9       	ld.w	r9,r8[0x2c]
80005bb0:	4a 48       	lddpc	r8,80005c40 <xTaskGenericCreate+0x1b8>
80005bb2:	91 09       	st.w	r8[0x0],r9
80005bb4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005bb8:	f0 ca ff fc 	sub	r10,r8,-4
80005bbc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005bc0:	70 b9       	ld.w	r9,r8[0x2c]
80005bc2:	12 98       	mov	r8,r9
80005bc4:	a3 68       	lsl	r8,0x2
80005bc6:	12 08       	add	r8,r9
80005bc8:	a3 68       	lsl	r8,0x2
80005bca:	10 99       	mov	r9,r8
80005bcc:	49 e8       	lddpc	r8,80005c44 <xTaskGenericCreate+0x1bc>
80005bce:	f2 08 00 08 	add	r8,r9,r8
80005bd2:	14 9b       	mov	r11,r10
80005bd4:	10 9c       	mov	r12,r8
80005bd6:	f0 1f 00 1d 	mcall	80005c48 <xTaskGenericCreate+0x1c0>

			xReturn = pdPASS;
80005bda:	30 18       	mov	r8,1
80005bdc:	ef 48 ff f4 	st.w	r7[-12],r8
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80005be0:	f0 1f 00 1b 	mcall	80005c4c <xTaskGenericCreate+0x1c4>
80005be4:	c0 48       	rjmp	80005bec <xTaskGenericCreate+0x164>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
80005be6:	3f f8       	mov	r8,-1
80005be8:	ef 48 ff f4 	st.w	r7[-12],r8
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
80005bec:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005bf0:	58 18       	cp.w	r8,1
80005bf2:	c0 d1       	brne	80005c0c <xTaskGenericCreate+0x184>
	{
		if( xSchedulerRunning != pdFALSE )
80005bf4:	49 08       	lddpc	r8,80005c34 <xTaskGenericCreate+0x1ac>
80005bf6:	70 08       	ld.w	r8,r8[0x0]
80005bf8:	58 08       	cp.w	r8,0
80005bfa:	c0 90       	breq	80005c0c <xTaskGenericCreate+0x184>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005bfc:	48 c8       	lddpc	r8,80005c2c <xTaskGenericCreate+0x1a4>
80005bfe:	70 08       	ld.w	r8,r8[0x0]
80005c00:	70 b9       	ld.w	r9,r8[0x2c]
80005c02:	ee f8 ff e0 	ld.w	r8,r7[-32]
80005c06:	10 39       	cp.w	r9,r8
80005c08:	c0 22       	brcc	80005c0c <xTaskGenericCreate+0x184>
			{
				portYIELD_WITHIN_API();
80005c0a:	d7 33       	scall
			}
		}
	}

	return xReturn;
80005c0c:	ee f8 ff f4 	ld.w	r8,r7[-12]
}
80005c10:	10 9c       	mov	r12,r8
80005c12:	2f 8d       	sub	sp,-32
80005c14:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005c18:	80 00       	ld.sh	r0,r0[0x0]
80005c1a:	65 6c       	ld.w	r12,r2[0x58]
80005c1c:	80 00       	ld.sh	r0,r0[0x0]
80005c1e:	63 24       	ld.w	r4,r1[0x48]
80005c20:	80 00       	ld.sh	r0,r0[0x0]
80005c22:	4f ac       	lddpc	r12,80005e08 <xTaskResumeAll+0xc4>
80005c24:	80 00       	ld.sh	r0,r0[0x0]
80005c26:	4f 64       	lddpc	r4,80005dfc <xTaskResumeAll+0xb8>
80005c28:	00 00       	add	r0,r0
80005c2a:	07 74       	ld.ub	r4,--r3
80005c2c:	00 00       	add	r0,r0
80005c2e:	06 60       	and	r0,r3
80005c30:	80 00       	ld.sh	r0,r0[0x0]
80005c32:	63 c0       	ld.w	r0,r1[0x70]
80005c34:	00 00       	add	r0,r0
80005c36:	07 84       	ld.ub	r4,r3[0x0]
80005c38:	00 00       	add	r0,r0
80005c3a:	07 7c       	ld.ub	r12,--r3
80005c3c:	00 00       	add	r0,r0
80005c3e:	07 98       	ld.ub	r8,r3[0x1]
80005c40:	00 00       	add	r0,r0
80005c42:	07 80       	ld.ub	r0,r3[0x0]
80005c44:	00 00       	add	r0,r0
80005c46:	06 64       	and	r4,r3
80005c48:	80 00       	ld.sh	r0,r0[0x0]
80005c4a:	4c 3a       	lddpc	r10,80005d54 <xTaskResumeAll+0x10>
80005c4c:	80 00       	ld.sh	r0,r0[0x0]
80005c4e:	4f 80       	lddpc	r0,80005e2c <xTaskResumeAll+0xe8>

80005c50 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80005c50:	eb cd 40 80 	pushm	r7,lr
80005c54:	1a 97       	mov	r7,sp
80005c56:	20 3d       	sub	sp,12
80005c58:	ef 4c ff f4 	st.w	r7[-12],r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
80005c5c:	30 08       	mov	r8,0
80005c5e:	ef 48 ff fc 	st.w	r7[-4],r8

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80005c62:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005c66:	58 08       	cp.w	r8,0
80005c68:	c1 a0       	breq	80005c9c <vTaskDelay+0x4c>
		{
			vTaskSuspendAll();
80005c6a:	f0 1f 00 11 	mcall	80005cac <vTaskDelay+0x5c>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80005c6e:	49 18       	lddpc	r8,80005cb0 <vTaskDelay+0x60>
80005c70:	70 09       	ld.w	r9,r8[0x0]
80005c72:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005c76:	f2 08 00 08 	add	r8,r9,r8
80005c7a:	ef 48 ff f8 	st.w	r7[-8],r8

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005c7e:	48 e8       	lddpc	r8,80005cb4 <vTaskDelay+0x64>
80005c80:	70 08       	ld.w	r8,r8[0x0]
80005c82:	2f c8       	sub	r8,-4
80005c84:	10 9c       	mov	r12,r8
80005c86:	f0 1f 00 0d 	mcall	80005cb8 <vTaskDelay+0x68>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005c8a:	ee fc ff f8 	ld.w	r12,r7[-8]
80005c8e:	f0 1f 00 0c 	mcall	80005cbc <vTaskDelay+0x6c>
			}
			xAlreadyYielded = xTaskResumeAll();
80005c92:	f0 1f 00 0c 	mcall	80005cc0 <vTaskDelay+0x70>
80005c96:	18 98       	mov	r8,r12
80005c98:	ef 48 ff fc 	st.w	r7[-4],r8
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005c9c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005ca0:	58 08       	cp.w	r8,0
80005ca2:	c0 21       	brne	80005ca6 <vTaskDelay+0x56>
		{
			portYIELD_WITHIN_API();
80005ca4:	d7 33       	scall
		}
	}
80005ca6:	2f dd       	sub	sp,-12
80005ca8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005cac:	80 00       	ld.sh	r0,r0[0x0]
80005cae:	5d 28       	mustr	r8
80005cb0:	00 00       	add	r0,r0
80005cb2:	07 78       	ld.ub	r8,--r3
80005cb4:	00 00       	add	r0,r0
80005cb6:	06 60       	and	r0,r3
80005cb8:	80 00       	ld.sh	r0,r0[0x0]
80005cba:	4d 4e       	lddpc	lr,80005e08 <xTaskResumeAll+0xc4>
80005cbc:	80 00       	ld.sh	r0,r0[0x0]
80005cbe:	64 ec       	ld.w	r12,r2[0x38]
80005cc0:	80 00       	ld.sh	r0,r0[0x0]
80005cc2:	5d 44       	*unknown*

80005cc4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005cc4:	eb cd 40 80 	pushm	r7,lr
80005cc8:	1a 97       	mov	r7,sp
80005cca:	20 1d       	sub	sp,4
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005ccc:	49 1b       	lddpc	r11,80005d10 <vTaskStartScheduler+0x4c>
80005cce:	30 08       	mov	r8,0
80005cd0:	1a d8       	st.w	--sp,r8
80005cd2:	30 08       	mov	r8,0
80005cd4:	1a d8       	st.w	--sp,r8
80005cd6:	30 08       	mov	r8,0
80005cd8:	1a d8       	st.w	--sp,r8
80005cda:	30 08       	mov	r8,0
80005cdc:	30 09       	mov	r9,0
80005cde:	e0 6a 01 00 	mov	r10,256
80005ce2:	48 dc       	lddpc	r12,80005d14 <vTaskStartScheduler+0x50>
80005ce4:	f0 1f 00 0d 	mcall	80005d18 <vTaskStartScheduler+0x54>
80005ce8:	2f dd       	sub	sp,-12
80005cea:	18 98       	mov	r8,r12
80005cec:	ef 48 ff fc 	st.w	r7[-4],r8
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005cf0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005cf4:	58 18       	cp.w	r8,1
80005cf6:	c0 a1       	brne	80005d0a <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005cf8:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005cfa:	48 98       	lddpc	r8,80005d1c <vTaskStartScheduler+0x58>
80005cfc:	30 19       	mov	r9,1
80005cfe:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005d00:	48 88       	lddpc	r8,80005d20 <vTaskStartScheduler+0x5c>
80005d02:	30 09       	mov	r9,0
80005d04:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005d06:	f0 1f 00 08 	mcall	80005d24 <vTaskStartScheduler+0x60>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
80005d0a:	2f fd       	sub	sp,-4
80005d0c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d10:	80 00       	ld.sh	r0,r0[0x0]
80005d12:	5a 80       	cp.w	r0,-24
80005d14:	80 00       	ld.sh	r0,r0[0x0]
80005d16:	62 f8       	ld.w	r8,r1[0x3c]
80005d18:	80 00       	ld.sh	r0,r0[0x0]
80005d1a:	5a 88       	cp.w	r8,-24
80005d1c:	00 00       	add	r0,r0
80005d1e:	07 84       	ld.ub	r4,r3[0x0]
80005d20:	00 00       	add	r0,r0
80005d22:	07 78       	ld.ub	r8,--r3
80005d24:	80 00       	ld.sh	r0,r0[0x0]
80005d26:	51 54       	stdsp	sp[0x54],r4

80005d28 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
80005d28:	eb cd 40 80 	pushm	r7,lr
80005d2c:	1a 97       	mov	r7,sp
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005d2e:	48 58       	lddpc	r8,80005d40 <vTaskSuspendAll+0x18>
80005d30:	70 08       	ld.w	r8,r8[0x0]
80005d32:	f0 c9 ff ff 	sub	r9,r8,-1
80005d36:	48 38       	lddpc	r8,80005d40 <vTaskSuspendAll+0x18>
80005d38:	91 09       	st.w	r8[0x0],r9
}
80005d3a:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d3e:	00 00       	add	r0,r0
80005d40:	00 00       	add	r0,r0
80005d42:	07 88       	ld.ub	r8,r3[0x0]

80005d44 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005d44:	eb cd 40 c0 	pushm	r6-r7,lr
80005d48:	1a 97       	mov	r7,sp
80005d4a:	20 2d       	sub	sp,8
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
80005d4c:	30 08       	mov	r8,0
80005d4e:	ef 48 ff f8 	st.w	r7[-8],r8
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005d52:	f0 1f 00 3a 	mcall	80005e38 <xTaskResumeAll+0xf4>
	{
		--uxSchedulerSuspended;
80005d56:	4b a8       	lddpc	r8,80005e3c <xTaskResumeAll+0xf8>
80005d58:	70 08       	ld.w	r8,r8[0x0]
80005d5a:	f0 c9 00 01 	sub	r9,r8,1
80005d5e:	4b 88       	lddpc	r8,80005e3c <xTaskResumeAll+0xf8>
80005d60:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005d62:	4b 78       	lddpc	r8,80005e3c <xTaskResumeAll+0xf8>
80005d64:	70 08       	ld.w	r8,r8[0x0]
80005d66:	58 08       	cp.w	r8,0
80005d68:	c5 f1       	brne	80005e26 <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005d6a:	4b 68       	lddpc	r8,80005e40 <xTaskResumeAll+0xfc>
80005d6c:	70 08       	ld.w	r8,r8[0x0]
80005d6e:	58 08       	cp.w	r8,0
80005d70:	c5 b0       	breq	80005e26 <xTaskResumeAll+0xe2>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
80005d72:	30 08       	mov	r8,0
80005d74:	ef 48 ff fc 	st.w	r7[-4],r8

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005d78:	c3 08       	rjmp	80005dd8 <xTaskResumeAll+0x94>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005d7a:	4b 38       	lddpc	r8,80005e44 <xTaskResumeAll+0x100>
80005d7c:	70 38       	ld.w	r8,r8[0xc]
80005d7e:	70 38       	ld.w	r8,r8[0xc]
80005d80:	10 96       	mov	r6,r8
					vListRemove( &( pxTCB->xEventListItem ) );
80005d82:	ec c8 ff e8 	sub	r8,r6,-24
80005d86:	10 9c       	mov	r12,r8
80005d88:	f0 1f 00 30 	mcall	80005e48 <xTaskResumeAll+0x104>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005d8c:	ec c8 ff fc 	sub	r8,r6,-4
80005d90:	10 9c       	mov	r12,r8
80005d92:	f0 1f 00 2e 	mcall	80005e48 <xTaskResumeAll+0x104>
					prvAddTaskToReadyQueue( pxTCB );
80005d96:	6c b9       	ld.w	r9,r6[0x2c]
80005d98:	4a d8       	lddpc	r8,80005e4c <xTaskResumeAll+0x108>
80005d9a:	70 08       	ld.w	r8,r8[0x0]
80005d9c:	10 39       	cp.w	r9,r8
80005d9e:	e0 88 00 05 	brls	80005da8 <xTaskResumeAll+0x64>
80005da2:	6c b9       	ld.w	r9,r6[0x2c]
80005da4:	4a a8       	lddpc	r8,80005e4c <xTaskResumeAll+0x108>
80005da6:	91 09       	st.w	r8[0x0],r9
80005da8:	ec ca ff fc 	sub	r10,r6,-4
80005dac:	6c b9       	ld.w	r9,r6[0x2c]
80005dae:	12 98       	mov	r8,r9
80005db0:	a3 68       	lsl	r8,0x2
80005db2:	12 08       	add	r8,r9
80005db4:	a3 68       	lsl	r8,0x2
80005db6:	10 99       	mov	r9,r8
80005db8:	4a 68       	lddpc	r8,80005e50 <xTaskResumeAll+0x10c>
80005dba:	f2 08 00 08 	add	r8,r9,r8
80005dbe:	14 9b       	mov	r11,r10
80005dc0:	10 9c       	mov	r12,r8
80005dc2:	f0 1f 00 25 	mcall	80005e54 <xTaskResumeAll+0x110>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005dc6:	6c b9       	ld.w	r9,r6[0x2c]
80005dc8:	4a 48       	lddpc	r8,80005e58 <xTaskResumeAll+0x114>
80005dca:	70 08       	ld.w	r8,r8[0x0]
80005dcc:	70 b8       	ld.w	r8,r8[0x2c]
80005dce:	10 39       	cp.w	r9,r8
80005dd0:	c0 43       	brcs	80005dd8 <xTaskResumeAll+0x94>
					{
						xYieldRequired = pdTRUE;
80005dd2:	30 18       	mov	r8,1
80005dd4:	ef 48 ff fc 	st.w	r7[-4],r8
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005dd8:	49 b8       	lddpc	r8,80005e44 <xTaskResumeAll+0x100>
80005dda:	70 08       	ld.w	r8,r8[0x0]
80005ddc:	58 08       	cp.w	r8,0
80005dde:	cc e1       	brne	80005d7a <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005de0:	49 f8       	lddpc	r8,80005e5c <xTaskResumeAll+0x118>
80005de2:	70 08       	ld.w	r8,r8[0x0]
80005de4:	58 08       	cp.w	r8,0
80005de6:	c1 10       	breq	80005e08 <xTaskResumeAll+0xc4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005de8:	c0 98       	rjmp	80005dfa <xTaskResumeAll+0xb6>
					{
						vTaskIncrementTick();
80005dea:	f0 1f 00 1e 	mcall	80005e60 <xTaskResumeAll+0x11c>
						--uxMissedTicks;
80005dee:	49 c8       	lddpc	r8,80005e5c <xTaskResumeAll+0x118>
80005df0:	70 08       	ld.w	r8,r8[0x0]
80005df2:	f0 c9 00 01 	sub	r9,r8,1
80005df6:	49 a8       	lddpc	r8,80005e5c <xTaskResumeAll+0x118>
80005df8:	91 09       	st.w	r8[0x0],r9
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005dfa:	49 98       	lddpc	r8,80005e5c <xTaskResumeAll+0x118>
80005dfc:	70 08       	ld.w	r8,r8[0x0]
80005dfe:	58 08       	cp.w	r8,0
80005e00:	cf 51       	brne	80005dea <xTaskResumeAll+0xa6>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
80005e02:	30 18       	mov	r8,1
80005e04:	ef 48 ff fc 	st.w	r7[-4],r8
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005e08:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005e0c:	58 18       	cp.w	r8,1
80005e0e:	c0 50       	breq	80005e18 <xTaskResumeAll+0xd4>
80005e10:	49 58       	lddpc	r8,80005e64 <xTaskResumeAll+0x120>
80005e12:	70 08       	ld.w	r8,r8[0x0]
80005e14:	58 18       	cp.w	r8,1
80005e16:	c0 81       	brne	80005e26 <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
80005e18:	30 18       	mov	r8,1
80005e1a:	ef 48 ff f8 	st.w	r7[-8],r8
					xMissedYield = pdFALSE;
80005e1e:	49 28       	lddpc	r8,80005e64 <xTaskResumeAll+0x120>
80005e20:	30 09       	mov	r9,0
80005e22:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005e24:	d7 33       	scall
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005e26:	f0 1f 00 11 	mcall	80005e68 <xTaskResumeAll+0x124>

	return xAlreadyYielded;
80005e2a:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80005e2e:	10 9c       	mov	r12,r8
80005e30:	2f ed       	sub	sp,-8
80005e32:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e36:	00 00       	add	r0,r0
80005e38:	80 00       	ld.sh	r0,r0[0x0]
80005e3a:	4f 64       	lddpc	r4,80006010 <vTaskSwitchContext+0x14>
80005e3c:	00 00       	add	r0,r0
80005e3e:	07 88       	ld.ub	r8,r3[0x0]
80005e40:	00 00       	add	r0,r0
80005e42:	07 74       	ld.ub	r4,--r3
80005e44:	00 00       	add	r0,r0
80005e46:	07 34       	ld.ub	r4,r3++
80005e48:	80 00       	ld.sh	r0,r0[0x0]
80005e4a:	4d 4e       	lddpc	lr,80005f98 <vTaskIncrementTick+0xfc>
80005e4c:	00 00       	add	r0,r0
80005e4e:	07 80       	ld.ub	r0,r3[0x0]
80005e50:	00 00       	add	r0,r0
80005e52:	06 64       	and	r4,r3
80005e54:	80 00       	ld.sh	r0,r0[0x0]
80005e56:	4c 3a       	lddpc	r10,80005f60 <vTaskIncrementTick+0xc4>
80005e58:	00 00       	add	r0,r0
80005e5a:	06 60       	and	r0,r3
80005e5c:	00 00       	add	r0,r0
80005e5e:	07 8c       	ld.ub	r12,r3[0x0]
80005e60:	80 00       	ld.sh	r0,r0[0x0]
80005e62:	5e 9c       	retgt	r12
80005e64:	00 00       	add	r0,r0
80005e66:	07 90       	ld.ub	r0,r3[0x1]
80005e68:	80 00       	ld.sh	r0,r0[0x0]
80005e6a:	4f 80       	lddpc	r0,80006048 <vTaskSwitchContext+0x4c>

80005e6c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005e6c:	eb cd 40 80 	pushm	r7,lr
80005e70:	1a 97       	mov	r7,sp
80005e72:	20 1d       	sub	sp,4
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005e74:	f0 1f 00 07 	mcall	80005e90 <xTaskGetTickCount+0x24>
	{
		xTicks = xTickCount;
80005e78:	48 78       	lddpc	r8,80005e94 <xTaskGetTickCount+0x28>
80005e7a:	70 08       	ld.w	r8,r8[0x0]
80005e7c:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	taskEXIT_CRITICAL();
80005e80:	f0 1f 00 06 	mcall	80005e98 <xTaskGetTickCount+0x2c>

	return xTicks;
80005e84:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005e88:	10 9c       	mov	r12,r8
80005e8a:	2f fd       	sub	sp,-4
80005e8c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e90:	80 00       	ld.sh	r0,r0[0x0]
80005e92:	4f 64       	lddpc	r4,80006068 <vTaskSwitchContext+0x6c>
80005e94:	00 00       	add	r0,r0
80005e96:	07 78       	ld.ub	r8,--r3
80005e98:	80 00       	ld.sh	r0,r0[0x0]
80005e9a:	4f 80       	lddpc	r0,80006078 <vTaskSwitchContext+0x7c>

80005e9c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005e9c:	eb cd 40 80 	pushm	r7,lr
80005ea0:	1a 97       	mov	r7,sp
80005ea2:	20 3d       	sub	sp,12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005ea4:	4c b8       	lddpc	r8,80005fd0 <vTaskIncrementTick+0x134>
80005ea6:	70 08       	ld.w	r8,r8[0x0]
80005ea8:	58 08       	cp.w	r8,0
80005eaa:	e0 81 00 89 	brne	80005fbc <vTaskIncrementTick+0x120>
	{
		++xTickCount;
80005eae:	4c a8       	lddpc	r8,80005fd4 <vTaskIncrementTick+0x138>
80005eb0:	70 08       	ld.w	r8,r8[0x0]
80005eb2:	f0 c9 ff ff 	sub	r9,r8,-1
80005eb6:	4c 88       	lddpc	r8,80005fd4 <vTaskIncrementTick+0x138>
80005eb8:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005eba:	4c 78       	lddpc	r8,80005fd4 <vTaskIncrementTick+0x138>
80005ebc:	70 08       	ld.w	r8,r8[0x0]
80005ebe:	58 08       	cp.w	r8,0
80005ec0:	c2 71       	brne	80005f0e <vTaskIncrementTick+0x72>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005ec2:	4c 68       	lddpc	r8,80005fd8 <vTaskIncrementTick+0x13c>
80005ec4:	70 08       	ld.w	r8,r8[0x0]
80005ec6:	ef 48 ff f8 	st.w	r7[-8],r8
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005eca:	4c 58       	lddpc	r8,80005fdc <vTaskIncrementTick+0x140>
80005ecc:	70 09       	ld.w	r9,r8[0x0]
80005ece:	4c 38       	lddpc	r8,80005fd8 <vTaskIncrementTick+0x13c>
80005ed0:	91 09       	st.w	r8[0x0],r9
			pxOverflowDelayedTaskList = pxTemp;
80005ed2:	4c 38       	lddpc	r8,80005fdc <vTaskIncrementTick+0x140>
80005ed4:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005ed8:	91 09       	st.w	r8[0x0],r9
			xNumOfOverflows++;
80005eda:	4c 28       	lddpc	r8,80005fe0 <vTaskIncrementTick+0x144>
80005edc:	70 08       	ld.w	r8,r8[0x0]
80005ede:	f0 c9 ff ff 	sub	r9,r8,-1
80005ee2:	4c 08       	lddpc	r8,80005fe0 <vTaskIncrementTick+0x144>
80005ee4:	91 09       	st.w	r8[0x0],r9

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005ee6:	4b d8       	lddpc	r8,80005fd8 <vTaskIncrementTick+0x13c>
80005ee8:	70 08       	ld.w	r8,r8[0x0]
80005eea:	70 08       	ld.w	r8,r8[0x0]
80005eec:	58 08       	cp.w	r8,0
80005eee:	c0 51       	brne	80005ef8 <vTaskIncrementTick+0x5c>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005ef0:	4b d8       	lddpc	r8,80005fe4 <vTaskIncrementTick+0x148>
80005ef2:	3f f9       	mov	r9,-1
80005ef4:	91 09       	st.w	r8[0x0],r9
80005ef6:	c0 c8       	rjmp	80005f0e <vTaskIncrementTick+0x72>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005ef8:	4b 88       	lddpc	r8,80005fd8 <vTaskIncrementTick+0x13c>
80005efa:	70 08       	ld.w	r8,r8[0x0]
80005efc:	70 38       	ld.w	r8,r8[0xc]
80005efe:	70 38       	ld.w	r8,r8[0xc]
80005f00:	ef 48 ff f4 	st.w	r7[-12],r8
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005f04:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005f08:	70 19       	ld.w	r9,r8[0x4]
80005f0a:	4b 78       	lddpc	r8,80005fe4 <vTaskIncrementTick+0x148>
80005f0c:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005f0e:	4b 28       	lddpc	r8,80005fd4 <vTaskIncrementTick+0x138>
80005f10:	70 09       	ld.w	r9,r8[0x0]
80005f12:	4b 58       	lddpc	r8,80005fe4 <vTaskIncrementTick+0x148>
80005f14:	70 08       	ld.w	r8,r8[0x0]
80005f16:	10 39       	cp.w	r9,r8
80005f18:	c5 83       	brcs	80005fc8 <vTaskIncrementTick+0x12c>
80005f1a:	4b 08       	lddpc	r8,80005fd8 <vTaskIncrementTick+0x13c>
80005f1c:	70 08       	ld.w	r8,r8[0x0]
80005f1e:	70 08       	ld.w	r8,r8[0x0]
80005f20:	58 08       	cp.w	r8,0
80005f22:	c0 51       	brne	80005f2c <vTaskIncrementTick+0x90>
80005f24:	4b 08       	lddpc	r8,80005fe4 <vTaskIncrementTick+0x148>
80005f26:	3f f9       	mov	r9,-1
80005f28:	91 09       	st.w	r8[0x0],r9
80005f2a:	c4 f8       	rjmp	80005fc8 <vTaskIncrementTick+0x12c>
80005f2c:	4a b8       	lddpc	r8,80005fd8 <vTaskIncrementTick+0x13c>
80005f2e:	70 08       	ld.w	r8,r8[0x0]
80005f30:	70 38       	ld.w	r8,r8[0xc]
80005f32:	70 38       	ld.w	r8,r8[0xc]
80005f34:	ef 48 ff f4 	st.w	r7[-12],r8
80005f38:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005f3c:	70 18       	ld.w	r8,r8[0x4]
80005f3e:	ef 48 ff fc 	st.w	r7[-4],r8
80005f42:	4a 58       	lddpc	r8,80005fd4 <vTaskIncrementTick+0x138>
80005f44:	70 09       	ld.w	r9,r8[0x0]
80005f46:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005f4a:	10 39       	cp.w	r9,r8
80005f4c:	c0 62       	brcc	80005f58 <vTaskIncrementTick+0xbc>
80005f4e:	4a 68       	lddpc	r8,80005fe4 <vTaskIncrementTick+0x148>
80005f50:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005f54:	91 09       	st.w	r8[0x0],r9
80005f56:	c3 98       	rjmp	80005fc8 <vTaskIncrementTick+0x12c>
80005f58:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005f5c:	2f c8       	sub	r8,-4
80005f5e:	10 9c       	mov	r12,r8
80005f60:	f0 1f 00 22 	mcall	80005fe8 <vTaskIncrementTick+0x14c>
80005f64:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005f68:	70 a8       	ld.w	r8,r8[0x28]
80005f6a:	58 08       	cp.w	r8,0
80005f6c:	c0 70       	breq	80005f7a <vTaskIncrementTick+0xde>
80005f6e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005f72:	2e 88       	sub	r8,-24
80005f74:	10 9c       	mov	r12,r8
80005f76:	f0 1f 00 1d 	mcall	80005fe8 <vTaskIncrementTick+0x14c>
80005f7a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005f7e:	70 b9       	ld.w	r9,r8[0x2c]
80005f80:	49 b8       	lddpc	r8,80005fec <vTaskIncrementTick+0x150>
80005f82:	70 08       	ld.w	r8,r8[0x0]
80005f84:	10 39       	cp.w	r9,r8
80005f86:	e0 88 00 07 	brls	80005f94 <vTaskIncrementTick+0xf8>
80005f8a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005f8e:	70 b9       	ld.w	r9,r8[0x2c]
80005f90:	49 78       	lddpc	r8,80005fec <vTaskIncrementTick+0x150>
80005f92:	91 09       	st.w	r8[0x0],r9
80005f94:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005f98:	f0 ca ff fc 	sub	r10,r8,-4
80005f9c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005fa0:	70 b9       	ld.w	r9,r8[0x2c]
80005fa2:	12 98       	mov	r8,r9
80005fa4:	a3 68       	lsl	r8,0x2
80005fa6:	12 08       	add	r8,r9
80005fa8:	a3 68       	lsl	r8,0x2
80005faa:	10 99       	mov	r9,r8
80005fac:	49 18       	lddpc	r8,80005ff0 <vTaskIncrementTick+0x154>
80005fae:	f2 08 00 08 	add	r8,r9,r8
80005fb2:	14 9b       	mov	r11,r10
80005fb4:	10 9c       	mov	r12,r8
80005fb6:	f0 1f 00 10 	mcall	80005ff4 <vTaskIncrementTick+0x158>
80005fba:	cb 0b       	rjmp	80005f1a <vTaskIncrementTick+0x7e>
	}
	else
	{
		++uxMissedTicks;
80005fbc:	48 f8       	lddpc	r8,80005ff8 <vTaskIncrementTick+0x15c>
80005fbe:	70 08       	ld.w	r8,r8[0x0]
80005fc0:	f0 c9 ff ff 	sub	r9,r8,-1
80005fc4:	48 d8       	lddpc	r8,80005ff8 <vTaskIncrementTick+0x15c>
80005fc6:	91 09       	st.w	r8[0x0],r9
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
80005fc8:	2f dd       	sub	sp,-12
80005fca:	e3 cd 80 80 	ldm	sp++,r7,pc
80005fce:	00 00       	add	r0,r0
80005fd0:	00 00       	add	r0,r0
80005fd2:	07 88       	ld.ub	r8,r3[0x0]
80005fd4:	00 00       	add	r0,r0
80005fd6:	07 78       	ld.ub	r8,--r3
80005fd8:	00 00       	add	r0,r0
80005fda:	07 2c       	ld.uh	r12,r3++
80005fdc:	00 00       	add	r0,r0
80005fde:	07 30       	ld.ub	r0,r3++
80005fe0:	00 00       	add	r0,r0
80005fe2:	07 94       	ld.ub	r4,r3[0x1]
80005fe4:	00 00       	add	r0,r0
80005fe6:	00 24       	rsub	r4,r0
80005fe8:	80 00       	ld.sh	r0,r0[0x0]
80005fea:	4d 4e       	lddpc	lr,80006138 <xTaskRemoveFromEventList+0xc>
80005fec:	00 00       	add	r0,r0
80005fee:	07 80       	ld.ub	r0,r3[0x0]
80005ff0:	00 00       	add	r0,r0
80005ff2:	06 64       	and	r4,r3
80005ff4:	80 00       	ld.sh	r0,r0[0x0]
80005ff6:	4c 3a       	lddpc	r10,80006100 <vTaskPlaceOnEventList+0x54>
80005ff8:	00 00       	add	r0,r0
80005ffa:	07 8c       	ld.ub	r12,r3[0x0]

80005ffc <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
80005ffc:	eb cd 40 80 	pushm	r7,lr
80006000:	1a 97       	mov	r7,sp
80006002:	20 1d       	sub	sp,4
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006004:	4a 58       	lddpc	r8,80006098 <vTaskSwitchContext+0x9c>
80006006:	70 08       	ld.w	r8,r8[0x0]
80006008:	58 08       	cp.w	r8,0
8000600a:	c0 c0       	breq	80006022 <vTaskSwitchContext+0x26>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
8000600c:	4a 48       	lddpc	r8,8000609c <vTaskSwitchContext+0xa0>
8000600e:	30 19       	mov	r9,1
80006010:	91 09       	st.w	r8[0x0],r9
80006012:	c3 f8       	rjmp	80006090 <vTaskSwitchContext+0x94>

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006014:	4a 38       	lddpc	r8,800060a0 <vTaskSwitchContext+0xa4>
80006016:	70 08       	ld.w	r8,r8[0x0]
80006018:	f0 c9 00 01 	sub	r9,r8,1
8000601c:	4a 18       	lddpc	r8,800060a0 <vTaskSwitchContext+0xa4>
8000601e:	91 09       	st.w	r8[0x0],r9
80006020:	c0 28       	rjmp	80006024 <vTaskSwitchContext+0x28>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006022:	d7 03       	nop
80006024:	49 f8       	lddpc	r8,800060a0 <vTaskSwitchContext+0xa4>
80006026:	70 09       	ld.w	r9,r8[0x0]
80006028:	12 98       	mov	r8,r9
8000602a:	a3 68       	lsl	r8,0x2
8000602c:	12 08       	add	r8,r9
8000602e:	a3 68       	lsl	r8,0x2
80006030:	10 99       	mov	r9,r8
80006032:	49 d8       	lddpc	r8,800060a4 <vTaskSwitchContext+0xa8>
80006034:	f2 08 00 08 	add	r8,r9,r8
80006038:	70 08       	ld.w	r8,r8[0x0]
8000603a:	58 08       	cp.w	r8,0
8000603c:	ce c0       	breq	80006014 <vTaskSwitchContext+0x18>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
8000603e:	49 98       	lddpc	r8,800060a0 <vTaskSwitchContext+0xa4>
80006040:	70 09       	ld.w	r9,r8[0x0]
80006042:	12 98       	mov	r8,r9
80006044:	a3 68       	lsl	r8,0x2
80006046:	12 08       	add	r8,r9
80006048:	a3 68       	lsl	r8,0x2
8000604a:	10 99       	mov	r9,r8
8000604c:	49 68       	lddpc	r8,800060a4 <vTaskSwitchContext+0xa8>
8000604e:	f2 08 00 08 	add	r8,r9,r8
80006052:	ef 48 ff fc 	st.w	r7[-4],r8
80006056:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000605a:	70 18       	ld.w	r8,r8[0x4]
8000605c:	70 19       	ld.w	r9,r8[0x4]
8000605e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006062:	91 19       	st.w	r8[0x4],r9
80006064:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006068:	70 19       	ld.w	r9,r8[0x4]
8000606a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000606e:	2f 88       	sub	r8,-8
80006070:	10 39       	cp.w	r9,r8
80006072:	c0 81       	brne	80006082 <vTaskSwitchContext+0x86>
80006074:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006078:	70 18       	ld.w	r8,r8[0x4]
8000607a:	70 19       	ld.w	r9,r8[0x4]
8000607c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006080:	91 19       	st.w	r8[0x4],r9
80006082:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006086:	70 18       	ld.w	r8,r8[0x4]
80006088:	70 38       	ld.w	r8,r8[0xc]
8000608a:	10 99       	mov	r9,r8
8000608c:	48 78       	lddpc	r8,800060a8 <vTaskSwitchContext+0xac>
8000608e:	91 09       	st.w	r8[0x0],r9

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
80006090:	2f fd       	sub	sp,-4
80006092:	e3 cd 80 80 	ldm	sp++,r7,pc
80006096:	00 00       	add	r0,r0
80006098:	00 00       	add	r0,r0
8000609a:	07 88       	ld.ub	r8,r3[0x0]
8000609c:	00 00       	add	r0,r0
8000609e:	07 90       	ld.ub	r0,r3[0x1]
800060a0:	00 00       	add	r0,r0
800060a2:	07 80       	ld.ub	r0,r3[0x0]
800060a4:	00 00       	add	r0,r0
800060a6:	06 64       	and	r4,r3
800060a8:	00 00       	add	r0,r0
800060aa:	06 60       	and	r0,r3

800060ac <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800060ac:	eb cd 40 80 	pushm	r7,lr
800060b0:	1a 97       	mov	r7,sp
800060b2:	20 3d       	sub	sp,12
800060b4:	ef 4c ff f8 	st.w	r7[-8],r12
800060b8:	ef 4b ff f4 	st.w	r7[-12],r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800060bc:	49 58       	lddpc	r8,80006110 <vTaskPlaceOnEventList+0x64>
800060be:	70 08       	ld.w	r8,r8[0x0]
800060c0:	2e 88       	sub	r8,-24
800060c2:	10 9b       	mov	r11,r8
800060c4:	ee fc ff f8 	ld.w	r12,r7[-8]
800060c8:	f0 1f 00 13 	mcall	80006114 <vTaskPlaceOnEventList+0x68>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800060cc:	49 18       	lddpc	r8,80006110 <vTaskPlaceOnEventList+0x64>
800060ce:	70 08       	ld.w	r8,r8[0x0]
800060d0:	2f c8       	sub	r8,-4
800060d2:	10 9c       	mov	r12,r8
800060d4:	f0 1f 00 11 	mcall	80006118 <vTaskPlaceOnEventList+0x6c>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800060d8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800060dc:	5b f8       	cp.w	r8,-1
800060de:	c0 91       	brne	800060f0 <vTaskPlaceOnEventList+0x44>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800060e0:	48 c8       	lddpc	r8,80006110 <vTaskPlaceOnEventList+0x64>
800060e2:	70 08       	ld.w	r8,r8[0x0]
800060e4:	2f c8       	sub	r8,-4
800060e6:	10 9b       	mov	r11,r8
800060e8:	48 dc       	lddpc	r12,8000611c <vTaskPlaceOnEventList+0x70>
800060ea:	f0 1f 00 0e 	mcall	80006120 <vTaskPlaceOnEventList+0x74>
800060ee:	c0 d8       	rjmp	80006108 <vTaskPlaceOnEventList+0x5c>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800060f0:	48 d8       	lddpc	r8,80006124 <vTaskPlaceOnEventList+0x78>
800060f2:	70 09       	ld.w	r9,r8[0x0]
800060f4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800060f8:	f2 08 00 08 	add	r8,r9,r8
800060fc:	ef 48 ff fc 	st.w	r7[-4],r8
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006100:	ee fc ff fc 	ld.w	r12,r7[-4]
80006104:	f0 1f 00 09 	mcall	80006128 <vTaskPlaceOnEventList+0x7c>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
80006108:	2f dd       	sub	sp,-12
8000610a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000610e:	00 00       	add	r0,r0
80006110:	00 00       	add	r0,r0
80006112:	06 60       	and	r0,r3
80006114:	80 00       	ld.sh	r0,r0[0x0]
80006116:	4c ac       	lddpc	r12,8000623c <xTaskCheckForTimeOut+0x10>
80006118:	80 00       	ld.sh	r0,r0[0x0]
8000611a:	4d 4e       	lddpc	lr,80006268 <xTaskCheckForTimeOut+0x3c>
8000611c:	00 00       	add	r0,r0
8000611e:	07 60       	ld.uh	r0,--r3
80006120:	80 00       	ld.sh	r0,r0[0x0]
80006122:	4c 3a       	lddpc	r10,8000622c <xTaskCheckForTimeOut>
80006124:	00 00       	add	r0,r0
80006126:	07 78       	ld.ub	r8,--r3
80006128:	80 00       	ld.sh	r0,r0[0x0]
8000612a:	64 ec       	ld.w	r12,r2[0x38]

8000612c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
8000612c:	eb cd 40 80 	pushm	r7,lr
80006130:	1a 97       	mov	r7,sp
80006132:	20 3d       	sub	sp,12
80006134:	ef 4c ff f4 	st.w	r7[-12],r12
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006138:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000613c:	70 38       	ld.w	r8,r8[0xc]
8000613e:	70 38       	ld.w	r8,r8[0xc]
80006140:	ef 48 ff f8 	st.w	r7[-8],r8
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006144:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006148:	2e 88       	sub	r8,-24
8000614a:	10 9c       	mov	r12,r8
8000614c:	f0 1f 00 25 	mcall	800061e0 <xTaskRemoveFromEventList+0xb4>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006150:	4a 58       	lddpc	r8,800061e4 <xTaskRemoveFromEventList+0xb8>
80006152:	70 08       	ld.w	r8,r8[0x0]
80006154:	58 08       	cp.w	r8,0
80006156:	c2 81       	brne	800061a6 <xTaskRemoveFromEventList+0x7a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006158:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000615c:	2f c8       	sub	r8,-4
8000615e:	10 9c       	mov	r12,r8
80006160:	f0 1f 00 20 	mcall	800061e0 <xTaskRemoveFromEventList+0xb4>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006164:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006168:	70 b9       	ld.w	r9,r8[0x2c]
8000616a:	4a 08       	lddpc	r8,800061e8 <xTaskRemoveFromEventList+0xbc>
8000616c:	70 08       	ld.w	r8,r8[0x0]
8000616e:	10 39       	cp.w	r9,r8
80006170:	e0 88 00 07 	brls	8000617e <xTaskRemoveFromEventList+0x52>
80006174:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006178:	70 b9       	ld.w	r9,r8[0x2c]
8000617a:	49 c8       	lddpc	r8,800061e8 <xTaskRemoveFromEventList+0xbc>
8000617c:	91 09       	st.w	r8[0x0],r9
8000617e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006182:	f0 ca ff fc 	sub	r10,r8,-4
80006186:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000618a:	70 b9       	ld.w	r9,r8[0x2c]
8000618c:	12 98       	mov	r8,r9
8000618e:	a3 68       	lsl	r8,0x2
80006190:	12 08       	add	r8,r9
80006192:	a3 68       	lsl	r8,0x2
80006194:	10 99       	mov	r9,r8
80006196:	49 68       	lddpc	r8,800061ec <xTaskRemoveFromEventList+0xc0>
80006198:	f2 08 00 08 	add	r8,r9,r8
8000619c:	14 9b       	mov	r11,r10
8000619e:	10 9c       	mov	r12,r8
800061a0:	f0 1f 00 14 	mcall	800061f0 <xTaskRemoveFromEventList+0xc4>
800061a4:	c0 88       	rjmp	800061b4 <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800061a6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800061aa:	2e 88       	sub	r8,-24
800061ac:	10 9b       	mov	r11,r8
800061ae:	49 2c       	lddpc	r12,800061f4 <xTaskRemoveFromEventList+0xc8>
800061b0:	f0 1f 00 10 	mcall	800061f0 <xTaskRemoveFromEventList+0xc4>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800061b4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800061b8:	70 b9       	ld.w	r9,r8[0x2c]
800061ba:	49 08       	lddpc	r8,800061f8 <xTaskRemoveFromEventList+0xcc>
800061bc:	70 08       	ld.w	r8,r8[0x0]
800061be:	70 b8       	ld.w	r8,r8[0x2c]
800061c0:	10 39       	cp.w	r9,r8
800061c2:	c0 53       	brcs	800061cc <xTaskRemoveFromEventList+0xa0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
800061c4:	30 18       	mov	r8,1
800061c6:	ef 48 ff fc 	st.w	r7[-4],r8
800061ca:	c0 48       	rjmp	800061d2 <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		xReturn = pdFALSE;
800061cc:	30 08       	mov	r8,0
800061ce:	ef 48 ff fc 	st.w	r7[-4],r8
	}

	return xReturn;
800061d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800061d6:	10 9c       	mov	r12,r8
800061d8:	2f dd       	sub	sp,-12
800061da:	e3 cd 80 80 	ldm	sp++,r7,pc
800061de:	00 00       	add	r0,r0
800061e0:	80 00       	ld.sh	r0,r0[0x0]
800061e2:	4d 4e       	lddpc	lr,80006330 <prvInitialiseTCBVariables+0xc>
800061e4:	00 00       	add	r0,r0
800061e6:	07 88       	ld.ub	r8,r3[0x0]
800061e8:	00 00       	add	r0,r0
800061ea:	07 80       	ld.ub	r0,r3[0x0]
800061ec:	00 00       	add	r0,r0
800061ee:	06 64       	and	r4,r3
800061f0:	80 00       	ld.sh	r0,r0[0x0]
800061f2:	4c 3a       	lddpc	r10,800062fc <prvIdleTask+0x4>
800061f4:	00 00       	add	r0,r0
800061f6:	07 34       	ld.ub	r4,r3++
800061f8:	00 00       	add	r0,r0
800061fa:	06 60       	and	r0,r3

800061fc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
800061fc:	eb cd 40 80 	pushm	r7,lr
80006200:	1a 97       	mov	r7,sp
80006202:	20 1d       	sub	sp,4
80006204:	ef 4c ff fc 	st.w	r7[-4],r12
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006208:	48 78       	lddpc	r8,80006224 <vTaskSetTimeOutState+0x28>
8000620a:	70 09       	ld.w	r9,r8[0x0]
8000620c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006210:	91 09       	st.w	r8[0x0],r9
	pxTimeOut->xTimeOnEntering = xTickCount;
80006212:	48 68       	lddpc	r8,80006228 <vTaskSetTimeOutState+0x2c>
80006214:	70 09       	ld.w	r9,r8[0x0]
80006216:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000621a:	91 19       	st.w	r8[0x4],r9
}
8000621c:	2f fd       	sub	sp,-4
8000621e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006222:	00 00       	add	r0,r0
80006224:	00 00       	add	r0,r0
80006226:	07 94       	ld.ub	r4,r3[0x1]
80006228:	00 00       	add	r0,r0
8000622a:	07 78       	ld.ub	r8,--r3

8000622c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
8000622c:	eb cd 40 80 	pushm	r7,lr
80006230:	1a 97       	mov	r7,sp
80006232:	20 3d       	sub	sp,12
80006234:	ef 4c ff f8 	st.w	r7[-8],r12
80006238:	ef 4b ff f4 	st.w	r7[-12],r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
8000623c:	f0 1f 00 25 	mcall	800062d0 <xTaskCheckForTimeOut+0xa4>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006240:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006244:	70 08       	ld.w	r8,r8[0x0]
80006246:	5b f8       	cp.w	r8,-1
80006248:	c0 51       	brne	80006252 <xTaskCheckForTimeOut+0x26>
			{
				xReturn = pdFALSE;
8000624a:	30 08       	mov	r8,0
8000624c:	ef 48 ff fc 	st.w	r7[-4],r8
80006250:	c3 88       	rjmp	800062c0 <xTaskCheckForTimeOut+0x94>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80006252:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006256:	70 09       	ld.w	r9,r8[0x0]
80006258:	49 f8       	lddpc	r8,800062d4 <xTaskCheckForTimeOut+0xa8>
8000625a:	70 08       	ld.w	r8,r8[0x0]
8000625c:	10 39       	cp.w	r9,r8
8000625e:	c0 d0       	breq	80006278 <xTaskCheckForTimeOut+0x4c>
80006260:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006264:	70 19       	ld.w	r9,r8[0x4]
80006266:	49 d8       	lddpc	r8,800062d8 <xTaskCheckForTimeOut+0xac>
80006268:	70 08       	ld.w	r8,r8[0x0]
8000626a:	10 39       	cp.w	r9,r8
8000626c:	e0 8b 00 06 	brhi	80006278 <xTaskCheckForTimeOut+0x4c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
80006270:	30 18       	mov	r8,1
80006272:	ef 48 ff fc 	st.w	r7[-4],r8
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80006276:	c2 58       	rjmp	800062c0 <xTaskCheckForTimeOut+0x94>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006278:	49 88       	lddpc	r8,800062d8 <xTaskCheckForTimeOut+0xac>
8000627a:	70 09       	ld.w	r9,r8[0x0]
8000627c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006280:	70 18       	ld.w	r8,r8[0x4]
80006282:	10 19       	sub	r9,r8
80006284:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006288:	70 08       	ld.w	r8,r8[0x0]
8000628a:	10 39       	cp.w	r9,r8
8000628c:	c1 72       	brcc	800062ba <xTaskCheckForTimeOut+0x8e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000628e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006292:	70 09       	ld.w	r9,r8[0x0]
80006294:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006298:	70 1a       	ld.w	r10,r8[0x4]
8000629a:	49 08       	lddpc	r8,800062d8 <xTaskCheckForTimeOut+0xac>
8000629c:	70 08       	ld.w	r8,r8[0x0]
8000629e:	f4 08 01 08 	sub	r8,r10,r8
800062a2:	10 09       	add	r9,r8
800062a4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800062a8:	91 09       	st.w	r8[0x0],r9
			vTaskSetTimeOutState( pxTimeOut );
800062aa:	ee fc ff f8 	ld.w	r12,r7[-8]
800062ae:	f0 1f 00 0c 	mcall	800062dc <xTaskCheckForTimeOut+0xb0>
			xReturn = pdFALSE;
800062b2:	30 08       	mov	r8,0
800062b4:	ef 48 ff fc 	st.w	r7[-4],r8
800062b8:	c0 48       	rjmp	800062c0 <xTaskCheckForTimeOut+0x94>
		}
		else
		{
			xReturn = pdTRUE;
800062ba:	30 18       	mov	r8,1
800062bc:	ef 48 ff fc 	st.w	r7[-4],r8
		}
	}
	taskEXIT_CRITICAL();
800062c0:	f0 1f 00 08 	mcall	800062e0 <xTaskCheckForTimeOut+0xb4>

	return xReturn;
800062c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800062c8:	10 9c       	mov	r12,r8
800062ca:	2f dd       	sub	sp,-12
800062cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800062d0:	80 00       	ld.sh	r0,r0[0x0]
800062d2:	4f 64       	lddpc	r4,800064a8 <prvCheckTasksWaitingTermination+0x54>
800062d4:	00 00       	add	r0,r0
800062d6:	07 94       	ld.ub	r4,r3[0x1]
800062d8:	00 00       	add	r0,r0
800062da:	07 78       	ld.ub	r8,--r3
800062dc:	80 00       	ld.sh	r0,r0[0x0]
800062de:	61 fc       	ld.w	r12,r0[0x7c]
800062e0:	80 00       	ld.sh	r0,r0[0x0]
800062e2:	4f 80       	lddpc	r0,800064c0 <prvCheckTasksWaitingTermination+0x6c>

800062e4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
800062e4:	eb cd 40 80 	pushm	r7,lr
800062e8:	1a 97       	mov	r7,sp
	xMissedYield = pdTRUE;
800062ea:	48 38       	lddpc	r8,800062f4 <vTaskMissedYield+0x10>
800062ec:	30 19       	mov	r9,1
800062ee:	91 09       	st.w	r8[0x0],r9
}
800062f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800062f4:	00 00       	add	r0,r0
800062f6:	07 90       	ld.ub	r0,r3[0x1]

800062f8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800062f8:	eb cd 40 80 	pushm	r7,lr
800062fc:	1a 97       	mov	r7,sp
800062fe:	20 1d       	sub	sp,4
80006300:	ef 4c ff fc 	st.w	r7[-4],r12
80006304:	c0 28       	rjmp	80006308 <prvIdleTask+0x10>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
80006306:	d7 03       	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
80006308:	f0 1f 00 05 	mcall	8000631c <prvIdleTask+0x24>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000630c:	48 58       	lddpc	r8,80006320 <prvIdleTask+0x28>
8000630e:	70 08       	ld.w	r8,r8[0x0]
80006310:	58 18       	cp.w	r8,1
80006312:	fe 98 ff fa 	brls	80006306 <prvIdleTask+0xe>
			{
				taskYIELD();
80006316:	d7 33       	scall
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
80006318:	cf 8b       	rjmp	80006308 <prvIdleTask+0x10>
8000631a:	00 00       	add	r0,r0
8000631c:	80 00       	ld.sh	r0,r0[0x0]
8000631e:	64 54       	ld.w	r4,r2[0x14]
80006320:	00 00       	add	r0,r0
80006322:	06 64       	and	r4,r3

80006324 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
80006324:	eb cd 40 80 	pushm	r7,lr
80006328:	1a 97       	mov	r7,sp
8000632a:	20 5d       	sub	sp,20
8000632c:	ef 4c ff fc 	st.w	r7[-4],r12
80006330:	ef 4b ff f8 	st.w	r7[-8],r11
80006334:	ef 4a ff f4 	st.w	r7[-12],r10
80006338:	ef 49 ff f0 	st.w	r7[-16],r9
8000633c:	ef 58 ff ec 	st.h	r7[-20],r8
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006340:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006344:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006348:	2c c8       	sub	r8,-52
8000634a:	31 0a       	mov	r10,16
8000634c:	12 9b       	mov	r11,r9
8000634e:	10 9c       	mov	r12,r8
80006350:	f0 1f 00 1a 	mcall	800063b8 <prvInitialiseTCBVariables+0x94>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006354:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006358:	30 08       	mov	r8,0
8000635a:	f3 68 00 43 	st.b	r9[67],r8

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
8000635e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006362:	58 78       	cp.w	r8,7
80006364:	e0 88 00 05 	brls	8000636e <prvInitialiseTCBVariables+0x4a>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
80006368:	30 78       	mov	r8,7
8000636a:	ef 48 ff f4 	st.w	r7[-12],r8
	}

	pxTCB->uxPriority = uxPriority;
8000636e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006372:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006376:	91 b9       	st.w	r8[0x2c],r9
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006378:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000637c:	2f c8       	sub	r8,-4
8000637e:	10 9c       	mov	r12,r8
80006380:	f0 1f 00 0f 	mcall	800063bc <prvInitialiseTCBVariables+0x98>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006384:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006388:	2e 88       	sub	r8,-24
8000638a:	10 9c       	mov	r12,r8
8000638c:	f0 1f 00 0c 	mcall	800063bc <prvInitialiseTCBVariables+0x98>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006390:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006394:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006398:	91 49       	st.w	r8[0x10],r9

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
8000639a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000639e:	f0 09 11 08 	rsub	r9,r8,8
800063a2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800063a6:	91 69       	st.w	r8[0x18],r9
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800063a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800063ac:	ee f9 ff fc 	ld.w	r9,r7[-4]
800063b0:	91 99       	st.w	r8[0x24],r9
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
800063b2:	2f bd       	sub	sp,-20
800063b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800063b8:	80 00       	ld.sh	r0,r0[0x0]
800063ba:	71 50       	ld.w	r0,r8[0x54]
800063bc:	80 00       	ld.sh	r0,r0[0x0]
800063be:	4c 20       	lddpc	r0,800064c4 <prvCheckTasksWaitingTermination+0x70>

800063c0 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
800063c0:	eb cd 40 80 	pushm	r7,lr
800063c4:	1a 97       	mov	r7,sp
800063c6:	20 1d       	sub	sp,4
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800063c8:	30 08       	mov	r8,0
800063ca:	ef 48 ff fc 	st.w	r7[-4],r8
800063ce:	c1 38       	rjmp	800063f4 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800063d0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800063d4:	12 98       	mov	r8,r9
800063d6:	a3 68       	lsl	r8,0x2
800063d8:	12 08       	add	r8,r9
800063da:	a3 68       	lsl	r8,0x2
800063dc:	10 99       	mov	r9,r8
800063de:	49 58       	lddpc	r8,80006430 <prvInitialiseTaskLists+0x70>
800063e0:	f2 08 00 08 	add	r8,r9,r8
800063e4:	10 9c       	mov	r12,r8
800063e6:	f0 1f 00 14 	mcall	80006434 <prvInitialiseTaskLists+0x74>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800063ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800063ee:	2f f8       	sub	r8,-1
800063f0:	ef 48 ff fc 	st.w	r7[-4],r8
800063f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800063f8:	58 78       	cp.w	r8,7
800063fa:	fe 98 ff eb 	brls	800063d0 <prvInitialiseTaskLists+0x10>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
800063fe:	48 fc       	lddpc	r12,80006438 <prvInitialiseTaskLists+0x78>
80006400:	f0 1f 00 0d 	mcall	80006434 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006404:	48 ec       	lddpc	r12,8000643c <prvInitialiseTaskLists+0x7c>
80006406:	f0 1f 00 0c 	mcall	80006434 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xPendingReadyList );
8000640a:	48 ec       	lddpc	r12,80006440 <prvInitialiseTaskLists+0x80>
8000640c:	f0 1f 00 0a 	mcall	80006434 <prvInitialiseTaskLists+0x74>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006410:	48 dc       	lddpc	r12,80006444 <prvInitialiseTaskLists+0x84>
80006412:	f0 1f 00 09 	mcall	80006434 <prvInitialiseTaskLists+0x74>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006416:	48 dc       	lddpc	r12,80006448 <prvInitialiseTaskLists+0x88>
80006418:	f0 1f 00 07 	mcall	80006434 <prvInitialiseTaskLists+0x74>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
8000641c:	48 c8       	lddpc	r8,8000644c <prvInitialiseTaskLists+0x8c>
8000641e:	48 79       	lddpc	r9,80006438 <prvInitialiseTaskLists+0x78>
80006420:	91 09       	st.w	r8[0x0],r9
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006422:	48 c8       	lddpc	r8,80006450 <prvInitialiseTaskLists+0x90>
80006424:	48 69       	lddpc	r9,8000643c <prvInitialiseTaskLists+0x7c>
80006426:	91 09       	st.w	r8[0x0],r9
}
80006428:	2f fd       	sub	sp,-4
8000642a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000642e:	00 00       	add	r0,r0
80006430:	00 00       	add	r0,r0
80006432:	06 64       	and	r4,r3
80006434:	80 00       	ld.sh	r0,r0[0x0]
80006436:	4b d4       	lddpc	r4,80006528 <prvAddCurrentTaskToDelayedList+0x3c>
80006438:	00 00       	add	r0,r0
8000643a:	07 04       	ld.w	r4,r3++
8000643c:	00 00       	add	r0,r0
8000643e:	07 18       	ld.sh	r8,r3++
80006440:	00 00       	add	r0,r0
80006442:	07 34       	ld.ub	r4,r3++
80006444:	00 00       	add	r0,r0
80006446:	07 48       	ld.w	r8,--r3
80006448:	00 00       	add	r0,r0
8000644a:	07 60       	ld.uh	r0,--r3
8000644c:	00 00       	add	r0,r0
8000644e:	07 2c       	ld.uh	r12,r3++
80006450:	00 00       	add	r0,r0
80006452:	07 30       	ld.ub	r0,r3++

80006454 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
80006454:	eb cd 40 80 	pushm	r7,lr
80006458:	1a 97       	mov	r7,sp
8000645a:	20 2d       	sub	sp,8
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
8000645c:	49 b8       	lddpc	r8,800064c8 <prvCheckTasksWaitingTermination+0x74>
8000645e:	70 08       	ld.w	r8,r8[0x0]
80006460:	58 08       	cp.w	r8,0
80006462:	c2 f0       	breq	800064c0 <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
80006464:	f0 1f 00 1a 	mcall	800064cc <prvCheckTasksWaitingTermination+0x78>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006468:	49 a8       	lddpc	r8,800064d0 <prvCheckTasksWaitingTermination+0x7c>
8000646a:	70 08       	ld.w	r8,r8[0x0]
8000646c:	58 08       	cp.w	r8,0
8000646e:	5f 08       	sreq	r8
80006470:	ef 48 ff f8 	st.w	r7[-8],r8
			xTaskResumeAll();
80006474:	f0 1f 00 18 	mcall	800064d4 <prvCheckTasksWaitingTermination+0x80>

			if( xListIsEmpty == pdFALSE )
80006478:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000647c:	58 08       	cp.w	r8,0
8000647e:	c2 11       	brne	800064c0 <prvCheckTasksWaitingTermination+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006480:	f0 1f 00 16 	mcall	800064d8 <prvCheckTasksWaitingTermination+0x84>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006484:	49 38       	lddpc	r8,800064d0 <prvCheckTasksWaitingTermination+0x7c>
80006486:	2f 88       	sub	r8,-8
80006488:	70 18       	ld.w	r8,r8[0x4]
8000648a:	70 38       	ld.w	r8,r8[0xc]
8000648c:	ef 48 ff fc 	st.w	r7[-4],r8
					vListRemove( &( pxTCB->xGenericListItem ) );
80006490:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006494:	2f c8       	sub	r8,-4
80006496:	10 9c       	mov	r12,r8
80006498:	f0 1f 00 11 	mcall	800064dc <prvCheckTasksWaitingTermination+0x88>
					--uxCurrentNumberOfTasks;
8000649c:	49 18       	lddpc	r8,800064e0 <prvCheckTasksWaitingTermination+0x8c>
8000649e:	70 08       	ld.w	r8,r8[0x0]
800064a0:	f0 c9 00 01 	sub	r9,r8,1
800064a4:	48 f8       	lddpc	r8,800064e0 <prvCheckTasksWaitingTermination+0x8c>
800064a6:	91 09       	st.w	r8[0x0],r9
					--uxTasksDeleted;
800064a8:	48 88       	lddpc	r8,800064c8 <prvCheckTasksWaitingTermination+0x74>
800064aa:	70 08       	ld.w	r8,r8[0x0]
800064ac:	f0 c9 00 01 	sub	r9,r8,1
800064b0:	48 68       	lddpc	r8,800064c8 <prvCheckTasksWaitingTermination+0x74>
800064b2:	91 09       	st.w	r8[0x0],r9
				}
				taskEXIT_CRITICAL();
800064b4:	f0 1f 00 0c 	mcall	800064e4 <prvCheckTasksWaitingTermination+0x90>

				prvDeleteTCB( pxTCB );
800064b8:	ee fc ff fc 	ld.w	r12,r7[-4]
800064bc:	f0 1f 00 0b 	mcall	800064e8 <prvCheckTasksWaitingTermination+0x94>
			}
		}
	}
	#endif
}
800064c0:	2f ed       	sub	sp,-8
800064c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800064c6:	00 00       	add	r0,r0
800064c8:	00 00       	add	r0,r0
800064ca:	07 5c       	ld.sh	r12,--r3
800064cc:	80 00       	ld.sh	r0,r0[0x0]
800064ce:	5d 28       	mustr	r8
800064d0:	00 00       	add	r0,r0
800064d2:	07 48       	ld.w	r8,--r3
800064d4:	80 00       	ld.sh	r0,r0[0x0]
800064d6:	5d 44       	*unknown*
800064d8:	80 00       	ld.sh	r0,r0[0x0]
800064da:	4f 64       	lddpc	r4,800066b0 <__avr32_udiv64+0x84>
800064dc:	80 00       	ld.sh	r0,r0[0x0]
800064de:	4d 4e       	lddpc	lr,8000662c <__avr32_udiv64>
800064e0:	00 00       	add	r0,r0
800064e2:	07 74       	ld.ub	r4,--r3
800064e4:	80 00       	ld.sh	r0,r0[0x0]
800064e6:	4f 80       	lddpc	r0,800066c4 <__avr32_udiv64+0x98>
800064e8:	80 00       	ld.sh	r0,r0[0x0]
800064ea:	66 00       	ld.w	r0,r3[0x0]

800064ec <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800064ec:	eb cd 40 80 	pushm	r7,lr
800064f0:	1a 97       	mov	r7,sp
800064f2:	20 1d       	sub	sp,4
800064f4:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800064f8:	49 78       	lddpc	r8,80006554 <prvAddCurrentTaskToDelayedList+0x68>
800064fa:	70 08       	ld.w	r8,r8[0x0]
800064fc:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006500:	91 19       	st.w	r8[0x4],r9

	if( xTimeToWake < xTickCount )
80006502:	49 68       	lddpc	r8,80006558 <prvAddCurrentTaskToDelayedList+0x6c>
80006504:	70 08       	ld.w	r8,r8[0x0]
80006506:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000650a:	10 39       	cp.w	r9,r8
8000650c:	c0 c2       	brcc	80006524 <prvAddCurrentTaskToDelayedList+0x38>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000650e:	49 28       	lddpc	r8,80006554 <prvAddCurrentTaskToDelayedList+0x68>
80006510:	70 08       	ld.w	r8,r8[0x0]
80006512:	f0 c9 ff fc 	sub	r9,r8,-4
80006516:	49 28       	lddpc	r8,8000655c <prvAddCurrentTaskToDelayedList+0x70>
80006518:	70 08       	ld.w	r8,r8[0x0]
8000651a:	12 9b       	mov	r11,r9
8000651c:	10 9c       	mov	r12,r8
8000651e:	f0 1f 00 11 	mcall	80006560 <prvAddCurrentTaskToDelayedList+0x74>
80006522:	c1 58       	rjmp	8000654c <prvAddCurrentTaskToDelayedList+0x60>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006524:	48 c8       	lddpc	r8,80006554 <prvAddCurrentTaskToDelayedList+0x68>
80006526:	70 08       	ld.w	r8,r8[0x0]
80006528:	f0 c9 ff fc 	sub	r9,r8,-4
8000652c:	48 e8       	lddpc	r8,80006564 <prvAddCurrentTaskToDelayedList+0x78>
8000652e:	70 08       	ld.w	r8,r8[0x0]
80006530:	12 9b       	mov	r11,r9
80006532:	10 9c       	mov	r12,r8
80006534:	f0 1f 00 0b 	mcall	80006560 <prvAddCurrentTaskToDelayedList+0x74>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006538:	48 c8       	lddpc	r8,80006568 <prvAddCurrentTaskToDelayedList+0x7c>
8000653a:	70 08       	ld.w	r8,r8[0x0]
8000653c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006540:	10 39       	cp.w	r9,r8
80006542:	c0 52       	brcc	8000654c <prvAddCurrentTaskToDelayedList+0x60>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006544:	48 98       	lddpc	r8,80006568 <prvAddCurrentTaskToDelayedList+0x7c>
80006546:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000654a:	91 09       	st.w	r8[0x0],r9
		}
	}
}
8000654c:	2f fd       	sub	sp,-4
8000654e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006552:	00 00       	add	r0,r0
80006554:	00 00       	add	r0,r0
80006556:	06 60       	and	r0,r3
80006558:	00 00       	add	r0,r0
8000655a:	07 78       	ld.ub	r8,--r3
8000655c:	00 00       	add	r0,r0
8000655e:	07 30       	ld.ub	r0,r3++
80006560:	80 00       	ld.sh	r0,r0[0x0]
80006562:	4c ac       	lddpc	r12,80006688 <__avr32_udiv64+0x5c>
80006564:	00 00       	add	r0,r0
80006566:	07 2c       	ld.uh	r12,r3++
80006568:	00 00       	add	r0,r0
8000656a:	00 24       	rsub	r4,r0

8000656c <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
8000656c:	eb cd 40 80 	pushm	r7,lr
80006570:	1a 97       	mov	r7,sp
80006572:	20 3d       	sub	sp,12
80006574:	18 98       	mov	r8,r12
80006576:	ef 4b ff f4 	st.w	r7[-12],r11
8000657a:	ef 58 ff f8 	st.h	r7[-8],r8
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
8000657e:	34 4c       	mov	r12,68
80006580:	f0 1f 00 1d 	mcall	800065f4 <prvAllocateTCBAndStack+0x88>
80006584:	18 98       	mov	r8,r12
80006586:	ef 48 ff fc 	st.w	r7[-4],r8

	if( pxNewTCB != NULL )
8000658a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000658e:	58 08       	cp.w	r8,0
80006590:	c2 c0       	breq	800065e8 <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006592:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006596:	58 08       	cp.w	r8,0
80006598:	c0 91       	brne	800065aa <prvAllocateTCBAndStack+0x3e>
8000659a:	ef 18 ff f8 	ld.uh	r8,r7[-8]
8000659e:	a3 68       	lsl	r8,0x2
800065a0:	10 9c       	mov	r12,r8
800065a2:	f0 1f 00 15 	mcall	800065f4 <prvAllocateTCBAndStack+0x88>
800065a6:	18 98       	mov	r8,r12
800065a8:	c0 38       	rjmp	800065ae <prvAllocateTCBAndStack+0x42>
800065aa:	ee f8 ff f4 	ld.w	r8,r7[-12]
800065ae:	ee f9 ff fc 	ld.w	r9,r7[-4]
800065b2:	93 c8       	st.w	r9[0x30],r8

		if( pxNewTCB->pxStack == NULL )
800065b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800065b8:	70 c8       	ld.w	r8,r8[0x30]
800065ba:	58 08       	cp.w	r8,0
800065bc:	c0 91       	brne	800065ce <prvAllocateTCBAndStack+0x62>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800065be:	ee fc ff fc 	ld.w	r12,r7[-4]
800065c2:	f0 1f 00 0e 	mcall	800065f8 <prvAllocateTCBAndStack+0x8c>
			pxNewTCB = NULL;
800065c6:	30 08       	mov	r8,0
800065c8:	ef 48 ff fc 	st.w	r7[-4],r8
800065cc:	c0 e8       	rjmp	800065e8 <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800065ce:	ef 18 ff f8 	ld.uh	r8,r7[-8]
800065d2:	f0 09 15 02 	lsl	r9,r8,0x2
800065d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800065da:	70 c8       	ld.w	r8,r8[0x30]
800065dc:	12 9a       	mov	r10,r9
800065de:	e0 6b 00 a5 	mov	r11,165
800065e2:	10 9c       	mov	r12,r8
800065e4:	f0 1f 00 06 	mcall	800065fc <prvAllocateTCBAndStack+0x90>
		}
	}

	return pxNewTCB;
800065e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800065ec:	10 9c       	mov	r12,r8
800065ee:	2f dd       	sub	sp,-12
800065f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800065f4:	80 00       	ld.sh	r0,r0[0x0]
800065f6:	53 0c       	stdsp	sp[0xc0],r12
800065f8:	80 00       	ld.sh	r0,r0[0x0]
800065fa:	53 48       	stdsp	sp[0xd0],r8
800065fc:	80 00       	ld.sh	r0,r0[0x0]
800065fe:	6e 60       	ld.w	r0,r7[0x18]

80006600 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
80006600:	eb cd 40 80 	pushm	r7,lr
80006604:	1a 97       	mov	r7,sp
80006606:	20 1d       	sub	sp,4
80006608:	ef 4c ff fc 	st.w	r7[-4],r12
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
8000660c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006610:	70 c8       	ld.w	r8,r8[0x30]
80006612:	10 9c       	mov	r12,r8
80006614:	f0 1f 00 05 	mcall	80006628 <prvDeleteTCB+0x28>
		vPortFree( pxTCB );
80006618:	ee fc ff fc 	ld.w	r12,r7[-4]
8000661c:	f0 1f 00 03 	mcall	80006628 <prvDeleteTCB+0x28>
	}
80006620:	2f fd       	sub	sp,-4
80006622:	e3 cd 80 80 	ldm	sp++,r7,pc
80006626:	00 00       	add	r0,r0
80006628:	80 00       	ld.sh	r0,r0[0x0]
8000662a:	53 48       	stdsp	sp[0xd0],r8

8000662c <__avr32_udiv64>:
8000662c:	d4 31       	pushm	r0-r7,lr
8000662e:	1a 97       	mov	r7,sp
80006630:	20 3d       	sub	sp,12
80006632:	10 9c       	mov	r12,r8
80006634:	12 9e       	mov	lr,r9
80006636:	14 93       	mov	r3,r10
80006638:	58 09       	cp.w	r9,0
8000663a:	e0 81 00 bd 	brne	800067b4 <__avr32_udiv64+0x188>
8000663e:	16 38       	cp.w	r8,r11
80006640:	e0 88 00 40 	brls	800066c0 <__avr32_udiv64+0x94>
80006644:	f0 08 12 00 	clz	r8,r8
80006648:	c0 d0       	breq	80006662 <__avr32_udiv64+0x36>
8000664a:	f6 08 09 4b 	lsl	r11,r11,r8
8000664e:	f0 09 11 20 	rsub	r9,r8,32
80006652:	f8 08 09 4c 	lsl	r12,r12,r8
80006656:	f4 09 0a 49 	lsr	r9,r10,r9
8000665a:	f4 08 09 43 	lsl	r3,r10,r8
8000665e:	f3 eb 10 0b 	or	r11,r9,r11
80006662:	f8 0e 16 10 	lsr	lr,r12,0x10
80006666:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000666a:	f6 0e 0d 00 	divu	r0,r11,lr
8000666e:	e6 0b 16 10 	lsr	r11,r3,0x10
80006672:	00 99       	mov	r9,r0
80006674:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80006678:	e0 0a 02 48 	mul	r8,r0,r10
8000667c:	10 3b       	cp.w	r11,r8
8000667e:	c0 a2       	brcc	80006692 <__avr32_udiv64+0x66>
80006680:	20 19       	sub	r9,1
80006682:	18 0b       	add	r11,r12
80006684:	18 3b       	cp.w	r11,r12
80006686:	c0 63       	brcs	80006692 <__avr32_udiv64+0x66>
80006688:	10 3b       	cp.w	r11,r8
8000668a:	f7 b9 03 01 	sublo	r9,1
8000668e:	f7 dc e3 0b 	addcs	r11,r11,r12
80006692:	f6 08 01 01 	sub	r1,r11,r8
80006696:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000669a:	e2 0e 0d 00 	divu	r0,r1,lr
8000669e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
800066a2:	00 98       	mov	r8,r0
800066a4:	e0 0a 02 4a 	mul	r10,r0,r10
800066a8:	14 33       	cp.w	r3,r10
800066aa:	c0 82       	brcc	800066ba <__avr32_udiv64+0x8e>
800066ac:	20 18       	sub	r8,1
800066ae:	18 03       	add	r3,r12
800066b0:	18 33       	cp.w	r3,r12
800066b2:	c0 43       	brcs	800066ba <__avr32_udiv64+0x8e>
800066b4:	14 33       	cp.w	r3,r10
800066b6:	f7 b8 03 01 	sublo	r8,1
800066ba:	f1 e9 11 08 	or	r8,r8,r9<<0x10
800066be:	cd f8       	rjmp	8000687c <__avr32_udiv64+0x250>
800066c0:	58 08       	cp.w	r8,0
800066c2:	c0 51       	brne	800066cc <__avr32_udiv64+0xa0>
800066c4:	30 19       	mov	r9,1
800066c6:	f2 08 0d 08 	divu	r8,r9,r8
800066ca:	10 9c       	mov	r12,r8
800066cc:	f8 06 12 00 	clz	r6,r12
800066d0:	c0 41       	brne	800066d8 <__avr32_udiv64+0xac>
800066d2:	18 1b       	sub	r11,r12
800066d4:	30 19       	mov	r9,1
800066d6:	c4 08       	rjmp	80006756 <__avr32_udiv64+0x12a>
800066d8:	ec 01 11 20 	rsub	r1,r6,32
800066dc:	f4 01 0a 49 	lsr	r9,r10,r1
800066e0:	f8 06 09 4c 	lsl	r12,r12,r6
800066e4:	f6 06 09 48 	lsl	r8,r11,r6
800066e8:	f6 01 0a 41 	lsr	r1,r11,r1
800066ec:	f3 e8 10 08 	or	r8,r9,r8
800066f0:	f8 03 16 10 	lsr	r3,r12,0x10
800066f4:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
800066f8:	e2 03 0d 00 	divu	r0,r1,r3
800066fc:	f0 0b 16 10 	lsr	r11,r8,0x10
80006700:	00 9e       	mov	lr,r0
80006702:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80006706:	e0 05 02 49 	mul	r9,r0,r5
8000670a:	12 3b       	cp.w	r11,r9
8000670c:	c0 a2       	brcc	80006720 <__avr32_udiv64+0xf4>
8000670e:	20 1e       	sub	lr,1
80006710:	18 0b       	add	r11,r12
80006712:	18 3b       	cp.w	r11,r12
80006714:	c0 63       	brcs	80006720 <__avr32_udiv64+0xf4>
80006716:	12 3b       	cp.w	r11,r9
80006718:	f7 be 03 01 	sublo	lr,1
8000671c:	f7 dc e3 0b 	addcs	r11,r11,r12
80006720:	12 1b       	sub	r11,r9
80006722:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80006726:	f6 03 0d 02 	divu	r2,r11,r3
8000672a:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000672e:	04 99       	mov	r9,r2
80006730:	e4 05 02 4b 	mul	r11,r2,r5
80006734:	16 38       	cp.w	r8,r11
80006736:	c0 a2       	brcc	8000674a <__avr32_udiv64+0x11e>
80006738:	20 19       	sub	r9,1
8000673a:	18 08       	add	r8,r12
8000673c:	18 38       	cp.w	r8,r12
8000673e:	c0 63       	brcs	8000674a <__avr32_udiv64+0x11e>
80006740:	16 38       	cp.w	r8,r11
80006742:	f7 b9 03 01 	sublo	r9,1
80006746:	f1 dc e3 08 	addcs	r8,r8,r12
8000674a:	f4 06 09 43 	lsl	r3,r10,r6
8000674e:	f0 0b 01 0b 	sub	r11,r8,r11
80006752:	f3 ee 11 09 	or	r9,r9,lr<<0x10
80006756:	f8 06 16 10 	lsr	r6,r12,0x10
8000675a:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000675e:	f6 06 0d 00 	divu	r0,r11,r6
80006762:	e6 0b 16 10 	lsr	r11,r3,0x10
80006766:	00 9a       	mov	r10,r0
80006768:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000676c:	e0 0e 02 48 	mul	r8,r0,lr
80006770:	10 3b       	cp.w	r11,r8
80006772:	c0 a2       	brcc	80006786 <__avr32_udiv64+0x15a>
80006774:	20 1a       	sub	r10,1
80006776:	18 0b       	add	r11,r12
80006778:	18 3b       	cp.w	r11,r12
8000677a:	c0 63       	brcs	80006786 <__avr32_udiv64+0x15a>
8000677c:	10 3b       	cp.w	r11,r8
8000677e:	f7 ba 03 01 	sublo	r10,1
80006782:	f7 dc e3 0b 	addcs	r11,r11,r12
80006786:	f6 08 01 01 	sub	r1,r11,r8
8000678a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000678e:	e2 06 0d 00 	divu	r0,r1,r6
80006792:	e7 e1 11 03 	or	r3,r3,r1<<0x10
80006796:	00 98       	mov	r8,r0
80006798:	e0 0e 02 4b 	mul	r11,r0,lr
8000679c:	16 33       	cp.w	r3,r11
8000679e:	c0 82       	brcc	800067ae <__avr32_udiv64+0x182>
800067a0:	20 18       	sub	r8,1
800067a2:	18 03       	add	r3,r12
800067a4:	18 33       	cp.w	r3,r12
800067a6:	c0 43       	brcs	800067ae <__avr32_udiv64+0x182>
800067a8:	16 33       	cp.w	r3,r11
800067aa:	f7 b8 03 01 	sublo	r8,1
800067ae:	f1 ea 11 08 	or	r8,r8,r10<<0x10
800067b2:	c6 98       	rjmp	80006884 <__avr32_udiv64+0x258>
800067b4:	16 39       	cp.w	r9,r11
800067b6:	e0 8b 00 65 	brhi	80006880 <__avr32_udiv64+0x254>
800067ba:	f2 09 12 00 	clz	r9,r9
800067be:	c0 b1       	brne	800067d4 <__avr32_udiv64+0x1a8>
800067c0:	10 3a       	cp.w	r10,r8
800067c2:	5f 2a       	srhs	r10
800067c4:	1c 3b       	cp.w	r11,lr
800067c6:	5f b8       	srhi	r8
800067c8:	10 4a       	or	r10,r8
800067ca:	f2 0a 18 00 	cp.b	r10,r9
800067ce:	c5 90       	breq	80006880 <__avr32_udiv64+0x254>
800067d0:	30 18       	mov	r8,1
800067d2:	c5 98       	rjmp	80006884 <__avr32_udiv64+0x258>
800067d4:	f0 09 09 46 	lsl	r6,r8,r9
800067d8:	f2 03 11 20 	rsub	r3,r9,32
800067dc:	fc 09 09 4e 	lsl	lr,lr,r9
800067e0:	f0 03 0a 48 	lsr	r8,r8,r3
800067e4:	f6 09 09 4c 	lsl	r12,r11,r9
800067e8:	f4 03 0a 42 	lsr	r2,r10,r3
800067ec:	ef 46 ff f4 	st.w	r7[-12],r6
800067f0:	f6 03 0a 43 	lsr	r3,r11,r3
800067f4:	18 42       	or	r2,r12
800067f6:	f1 ee 10 0c 	or	r12,r8,lr
800067fa:	f8 01 16 10 	lsr	r1,r12,0x10
800067fe:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80006802:	e6 01 0d 04 	divu	r4,r3,r1
80006806:	e4 03 16 10 	lsr	r3,r2,0x10
8000680a:	08 9e       	mov	lr,r4
8000680c:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80006810:	e8 06 02 48 	mul	r8,r4,r6
80006814:	10 33       	cp.w	r3,r8
80006816:	c0 a2       	brcc	8000682a <__avr32_udiv64+0x1fe>
80006818:	20 1e       	sub	lr,1
8000681a:	18 03       	add	r3,r12
8000681c:	18 33       	cp.w	r3,r12
8000681e:	c0 63       	brcs	8000682a <__avr32_udiv64+0x1fe>
80006820:	10 33       	cp.w	r3,r8
80006822:	f7 be 03 01 	sublo	lr,1
80006826:	e7 dc e3 03 	addcs	r3,r3,r12
8000682a:	10 13       	sub	r3,r8
8000682c:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
80006830:	e6 01 0d 00 	divu	r0,r3,r1
80006834:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80006838:	00 98       	mov	r8,r0
8000683a:	e0 06 02 46 	mul	r6,r0,r6
8000683e:	0c 3b       	cp.w	r11,r6
80006840:	c0 a2       	brcc	80006854 <__avr32_udiv64+0x228>
80006842:	20 18       	sub	r8,1
80006844:	18 0b       	add	r11,r12
80006846:	18 3b       	cp.w	r11,r12
80006848:	c0 63       	brcs	80006854 <__avr32_udiv64+0x228>
8000684a:	0c 3b       	cp.w	r11,r6
8000684c:	f7 dc e3 0b 	addcs	r11,r11,r12
80006850:	f7 b8 03 01 	sublo	r8,1
80006854:	f1 ee 11 08 	or	r8,r8,lr<<0x10
80006858:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000685c:	0c 1b       	sub	r11,r6
8000685e:	f0 04 06 42 	mulu.d	r2,r8,r4
80006862:	06 95       	mov	r5,r3
80006864:	16 35       	cp.w	r5,r11
80006866:	e0 8b 00 0a 	brhi	8000687a <__avr32_udiv64+0x24e>
8000686a:	5f 0b       	sreq	r11
8000686c:	f4 09 09 49 	lsl	r9,r10,r9
80006870:	12 32       	cp.w	r2,r9
80006872:	5f b9       	srhi	r9
80006874:	f7 e9 00 09 	and	r9,r11,r9
80006878:	c0 60       	breq	80006884 <__avr32_udiv64+0x258>
8000687a:	20 18       	sub	r8,1
8000687c:	30 09       	mov	r9,0
8000687e:	c0 38       	rjmp	80006884 <__avr32_udiv64+0x258>
80006880:	30 09       	mov	r9,0
80006882:	12 98       	mov	r8,r9
80006884:	10 9a       	mov	r10,r8
80006886:	12 93       	mov	r3,r9
80006888:	10 92       	mov	r2,r8
8000688a:	12 9b       	mov	r11,r9
8000688c:	2f dd       	sub	sp,-12
8000688e:	d8 32       	popm	r0-r7,pc

80006890 <atexit>:
80006890:	d4 01       	pushm	lr
80006892:	30 09       	mov	r9,0
80006894:	18 9b       	mov	r11,r12
80006896:	12 9a       	mov	r10,r9
80006898:	12 9c       	mov	r12,r9
8000689a:	e0 a0 05 01 	rcall	8000729c <__register_exitproc>
8000689e:	d8 02       	popm	pc

800068a0 <exit>:
800068a0:	d4 21       	pushm	r4-r7,lr
800068a2:	30 0b       	mov	r11,0
800068a4:	18 97       	mov	r7,r12
800068a6:	e0 a0 05 4d 	rcall	80007340 <__call_exitprocs>
800068aa:	fe c8 a3 76 	sub	r8,pc,-23690
800068ae:	70 0c       	ld.w	r12,r8[0x0]
800068b0:	78 a8       	ld.w	r8,r12[0x28]
800068b2:	58 08       	cp.w	r8,0
800068b4:	c0 20       	breq	800068b8 <exit+0x18>
800068b6:	5d 18       	icall	r8
800068b8:	0e 9c       	mov	r12,r7
800068ba:	e0 a0 04 60 	rcall	8000717a <_exit>
800068be:	d7 03       	nop

800068c0 <free>:
800068c0:	d4 01       	pushm	lr
800068c2:	e0 68 01 18 	mov	r8,280
800068c6:	18 9b       	mov	r11,r12
800068c8:	70 0c       	ld.w	r12,r8[0x0]
800068ca:	e0 a0 06 93 	rcall	800075f0 <_free_r>
800068ce:	d8 02       	popm	pc

800068d0 <malloc>:
800068d0:	d4 01       	pushm	lr
800068d2:	e0 68 01 18 	mov	r8,280
800068d6:	18 9b       	mov	r11,r12
800068d8:	70 0c       	ld.w	r12,r8[0x0]
800068da:	c0 3c       	rcall	800068e0 <_malloc_r>
800068dc:	d8 02       	popm	pc
800068de:	d7 03       	nop

800068e0 <_malloc_r>:
800068e0:	d4 31       	pushm	r0-r7,lr
800068e2:	f6 c8 ff f5 	sub	r8,r11,-11
800068e6:	18 95       	mov	r5,r12
800068e8:	10 97       	mov	r7,r8
800068ea:	e0 17 ff f8 	andl	r7,0xfff8
800068ee:	59 68       	cp.w	r8,22
800068f0:	f9 b7 08 10 	movls	r7,16
800068f4:	16 37       	cp.w	r7,r11
800068f6:	5f 38       	srlo	r8
800068f8:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800068fc:	c0 50       	breq	80006906 <_malloc_r+0x26>
800068fe:	30 c8       	mov	r8,12
80006900:	99 38       	st.w	r12[0xc],r8
80006902:	e0 8f 01 fa 	bral	80006cf6 <_malloc_r+0x416>
80006906:	fe b0 f2 85 	rcall	80004e10 <__malloc_lock>
8000690a:	e0 47 01 f7 	cp.w	r7,503
8000690e:	e0 8b 00 1d 	brhi	80006948 <_malloc_r+0x68>
80006912:	ee 03 16 03 	lsr	r3,r7,0x3
80006916:	e0 68 01 1c 	mov	r8,284
8000691a:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000691e:	70 36       	ld.w	r6,r8[0xc]
80006920:	10 36       	cp.w	r6,r8
80006922:	c0 61       	brne	8000692e <_malloc_r+0x4e>
80006924:	ec c8 ff f8 	sub	r8,r6,-8
80006928:	70 36       	ld.w	r6,r8[0xc]
8000692a:	10 36       	cp.w	r6,r8
8000692c:	c0 c0       	breq	80006944 <_malloc_r+0x64>
8000692e:	6c 18       	ld.w	r8,r6[0x4]
80006930:	e0 18 ff fc 	andl	r8,0xfffc
80006934:	6c 3a       	ld.w	r10,r6[0xc]
80006936:	ec 08 00 09 	add	r9,r6,r8
8000693a:	0a 9c       	mov	r12,r5
8000693c:	6c 28       	ld.w	r8,r6[0x8]
8000693e:	95 28       	st.w	r10[0x8],r8
80006940:	91 3a       	st.w	r8[0xc],r10
80006942:	c4 78       	rjmp	800069d0 <_malloc_r+0xf0>
80006944:	2f e3       	sub	r3,-2
80006946:	c4 d8       	rjmp	800069e0 <_malloc_r+0x100>
80006948:	ee 03 16 09 	lsr	r3,r7,0x9
8000694c:	c0 41       	brne	80006954 <_malloc_r+0x74>
8000694e:	ee 03 16 03 	lsr	r3,r7,0x3
80006952:	c2 68       	rjmp	8000699e <_malloc_r+0xbe>
80006954:	58 43       	cp.w	r3,4
80006956:	e0 8b 00 06 	brhi	80006962 <_malloc_r+0x82>
8000695a:	ee 03 16 06 	lsr	r3,r7,0x6
8000695e:	2c 83       	sub	r3,-56
80006960:	c1 f8       	rjmp	8000699e <_malloc_r+0xbe>
80006962:	59 43       	cp.w	r3,20
80006964:	e0 8b 00 04 	brhi	8000696c <_malloc_r+0x8c>
80006968:	2a 53       	sub	r3,-91
8000696a:	c1 a8       	rjmp	8000699e <_malloc_r+0xbe>
8000696c:	e0 43 00 54 	cp.w	r3,84
80006970:	e0 8b 00 06 	brhi	8000697c <_malloc_r+0x9c>
80006974:	ee 03 16 0c 	lsr	r3,r7,0xc
80006978:	29 23       	sub	r3,-110
8000697a:	c1 28       	rjmp	8000699e <_malloc_r+0xbe>
8000697c:	e0 43 01 54 	cp.w	r3,340
80006980:	e0 8b 00 06 	brhi	8000698c <_malloc_r+0xac>
80006984:	ee 03 16 0f 	lsr	r3,r7,0xf
80006988:	28 93       	sub	r3,-119
8000698a:	c0 a8       	rjmp	8000699e <_malloc_r+0xbe>
8000698c:	e0 43 05 54 	cp.w	r3,1364
80006990:	e0 88 00 04 	brls	80006998 <_malloc_r+0xb8>
80006994:	37 e3       	mov	r3,126
80006996:	c0 48       	rjmp	8000699e <_malloc_r+0xbe>
80006998:	ee 03 16 12 	lsr	r3,r7,0x12
8000699c:	28 43       	sub	r3,-124
8000699e:	e0 6a 01 1c 	mov	r10,284
800069a2:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800069a6:	74 36       	ld.w	r6,r10[0xc]
800069a8:	c1 98       	rjmp	800069da <_malloc_r+0xfa>
800069aa:	6c 19       	ld.w	r9,r6[0x4]
800069ac:	e0 19 ff fc 	andl	r9,0xfffc
800069b0:	f2 07 01 0b 	sub	r11,r9,r7
800069b4:	58 fb       	cp.w	r11,15
800069b6:	e0 8a 00 04 	brle	800069be <_malloc_r+0xde>
800069ba:	20 13       	sub	r3,1
800069bc:	c1 18       	rjmp	800069de <_malloc_r+0xfe>
800069be:	6c 38       	ld.w	r8,r6[0xc]
800069c0:	58 0b       	cp.w	r11,0
800069c2:	c0 b5       	brlt	800069d8 <_malloc_r+0xf8>
800069c4:	6c 2a       	ld.w	r10,r6[0x8]
800069c6:	ec 09 00 09 	add	r9,r6,r9
800069ca:	0a 9c       	mov	r12,r5
800069cc:	91 2a       	st.w	r8[0x8],r10
800069ce:	95 38       	st.w	r10[0xc],r8
800069d0:	72 18       	ld.w	r8,r9[0x4]
800069d2:	a1 a8       	sbr	r8,0x0
800069d4:	93 18       	st.w	r9[0x4],r8
800069d6:	cb c8       	rjmp	80006b4e <_malloc_r+0x26e>
800069d8:	10 96       	mov	r6,r8
800069da:	14 36       	cp.w	r6,r10
800069dc:	ce 71       	brne	800069aa <_malloc_r+0xca>
800069de:	2f f3       	sub	r3,-1
800069e0:	e0 6a 01 1c 	mov	r10,284
800069e4:	f4 cc ff f8 	sub	r12,r10,-8
800069e8:	78 26       	ld.w	r6,r12[0x8]
800069ea:	18 36       	cp.w	r6,r12
800069ec:	c6 c0       	breq	80006ac4 <_malloc_r+0x1e4>
800069ee:	6c 19       	ld.w	r9,r6[0x4]
800069f0:	e0 19 ff fc 	andl	r9,0xfffc
800069f4:	f2 07 01 08 	sub	r8,r9,r7
800069f8:	58 f8       	cp.w	r8,15
800069fa:	e0 89 00 8f 	brgt	80006b18 <_malloc_r+0x238>
800069fe:	99 3c       	st.w	r12[0xc],r12
80006a00:	99 2c       	st.w	r12[0x8],r12
80006a02:	58 08       	cp.w	r8,0
80006a04:	c0 55       	brlt	80006a0e <_malloc_r+0x12e>
80006a06:	ec 09 00 09 	add	r9,r6,r9
80006a0a:	0a 9c       	mov	r12,r5
80006a0c:	ce 2b       	rjmp	800069d0 <_malloc_r+0xf0>
80006a0e:	e0 49 01 ff 	cp.w	r9,511
80006a12:	e0 8b 00 13 	brhi	80006a38 <_malloc_r+0x158>
80006a16:	a3 99       	lsr	r9,0x3
80006a18:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006a1c:	70 2b       	ld.w	r11,r8[0x8]
80006a1e:	8d 38       	st.w	r6[0xc],r8
80006a20:	8d 2b       	st.w	r6[0x8],r11
80006a22:	97 36       	st.w	r11[0xc],r6
80006a24:	91 26       	st.w	r8[0x8],r6
80006a26:	a3 49       	asr	r9,0x2
80006a28:	74 18       	ld.w	r8,r10[0x4]
80006a2a:	30 1b       	mov	r11,1
80006a2c:	f6 09 09 49 	lsl	r9,r11,r9
80006a30:	f1 e9 10 09 	or	r9,r8,r9
80006a34:	95 19       	st.w	r10[0x4],r9
80006a36:	c4 78       	rjmp	80006ac4 <_malloc_r+0x1e4>
80006a38:	f2 0a 16 09 	lsr	r10,r9,0x9
80006a3c:	58 4a       	cp.w	r10,4
80006a3e:	e0 8b 00 07 	brhi	80006a4c <_malloc_r+0x16c>
80006a42:	f2 0a 16 06 	lsr	r10,r9,0x6
80006a46:	2c 8a       	sub	r10,-56
80006a48:	c2 08       	rjmp	80006a88 <_malloc_r+0x1a8>
80006a4a:	d7 03       	nop
80006a4c:	59 4a       	cp.w	r10,20
80006a4e:	e0 8b 00 04 	brhi	80006a56 <_malloc_r+0x176>
80006a52:	2a 5a       	sub	r10,-91
80006a54:	c1 a8       	rjmp	80006a88 <_malloc_r+0x1a8>
80006a56:	e0 4a 00 54 	cp.w	r10,84
80006a5a:	e0 8b 00 06 	brhi	80006a66 <_malloc_r+0x186>
80006a5e:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006a62:	29 2a       	sub	r10,-110
80006a64:	c1 28       	rjmp	80006a88 <_malloc_r+0x1a8>
80006a66:	e0 4a 01 54 	cp.w	r10,340
80006a6a:	e0 8b 00 06 	brhi	80006a76 <_malloc_r+0x196>
80006a6e:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006a72:	28 9a       	sub	r10,-119
80006a74:	c0 a8       	rjmp	80006a88 <_malloc_r+0x1a8>
80006a76:	e0 4a 05 54 	cp.w	r10,1364
80006a7a:	e0 88 00 04 	brls	80006a82 <_malloc_r+0x1a2>
80006a7e:	37 ea       	mov	r10,126
80006a80:	c0 48       	rjmp	80006a88 <_malloc_r+0x1a8>
80006a82:	f2 0a 16 12 	lsr	r10,r9,0x12
80006a86:	28 4a       	sub	r10,-124
80006a88:	e0 6b 01 1c 	mov	r11,284
80006a8c:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006a90:	68 28       	ld.w	r8,r4[0x8]
80006a92:	08 38       	cp.w	r8,r4
80006a94:	c0 e1       	brne	80006ab0 <_malloc_r+0x1d0>
80006a96:	76 19       	ld.w	r9,r11[0x4]
80006a98:	a3 4a       	asr	r10,0x2
80006a9a:	30 1e       	mov	lr,1
80006a9c:	fc 0a 09 4a 	lsl	r10,lr,r10
80006aa0:	f3 ea 10 0a 	or	r10,r9,r10
80006aa4:	10 99       	mov	r9,r8
80006aa6:	97 1a       	st.w	r11[0x4],r10
80006aa8:	c0 a8       	rjmp	80006abc <_malloc_r+0x1dc>
80006aaa:	70 28       	ld.w	r8,r8[0x8]
80006aac:	08 38       	cp.w	r8,r4
80006aae:	c0 60       	breq	80006aba <_malloc_r+0x1da>
80006ab0:	70 1a       	ld.w	r10,r8[0x4]
80006ab2:	e0 1a ff fc 	andl	r10,0xfffc
80006ab6:	14 39       	cp.w	r9,r10
80006ab8:	cf 93       	brcs	80006aaa <_malloc_r+0x1ca>
80006aba:	70 39       	ld.w	r9,r8[0xc]
80006abc:	8d 39       	st.w	r6[0xc],r9
80006abe:	8d 28       	st.w	r6[0x8],r8
80006ac0:	91 36       	st.w	r8[0xc],r6
80006ac2:	93 26       	st.w	r9[0x8],r6
80006ac4:	e6 08 14 02 	asr	r8,r3,0x2
80006ac8:	30 1b       	mov	r11,1
80006aca:	e0 64 01 1c 	mov	r4,284
80006ace:	f6 08 09 4b 	lsl	r11,r11,r8
80006ad2:	68 18       	ld.w	r8,r4[0x4]
80006ad4:	10 3b       	cp.w	r11,r8
80006ad6:	e0 8b 00 6b 	brhi	80006bac <_malloc_r+0x2cc>
80006ada:	f7 e8 00 09 	and	r9,r11,r8
80006ade:	c0 b1       	brne	80006af4 <_malloc_r+0x214>
80006ae0:	e0 13 ff fc 	andl	r3,0xfffc
80006ae4:	a1 7b       	lsl	r11,0x1
80006ae6:	2f c3       	sub	r3,-4
80006ae8:	c0 38       	rjmp	80006aee <_malloc_r+0x20e>
80006aea:	2f c3       	sub	r3,-4
80006aec:	a1 7b       	lsl	r11,0x1
80006aee:	f7 e8 00 09 	and	r9,r11,r8
80006af2:	cf c0       	breq	80006aea <_malloc_r+0x20a>
80006af4:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006af8:	06 92       	mov	r2,r3
80006afa:	1c 91       	mov	r1,lr
80006afc:	62 36       	ld.w	r6,r1[0xc]
80006afe:	c2 e8       	rjmp	80006b5a <_malloc_r+0x27a>
80006b00:	6c 1a       	ld.w	r10,r6[0x4]
80006b02:	e0 1a ff fc 	andl	r10,0xfffc
80006b06:	f4 07 01 08 	sub	r8,r10,r7
80006b0a:	58 f8       	cp.w	r8,15
80006b0c:	e0 8a 00 15 	brle	80006b36 <_malloc_r+0x256>
80006b10:	6c 3a       	ld.w	r10,r6[0xc]
80006b12:	6c 29       	ld.w	r9,r6[0x8]
80006b14:	95 29       	st.w	r10[0x8],r9
80006b16:	93 3a       	st.w	r9[0xc],r10
80006b18:	0e 99       	mov	r9,r7
80006b1a:	ec 07 00 07 	add	r7,r6,r7
80006b1e:	a1 a9       	sbr	r9,0x0
80006b20:	99 37       	st.w	r12[0xc],r7
80006b22:	99 27       	st.w	r12[0x8],r7
80006b24:	8d 19       	st.w	r6[0x4],r9
80006b26:	ee 08 09 08 	st.w	r7[r8],r8
80006b2a:	8f 2c       	st.w	r7[0x8],r12
80006b2c:	8f 3c       	st.w	r7[0xc],r12
80006b2e:	a1 a8       	sbr	r8,0x0
80006b30:	0a 9c       	mov	r12,r5
80006b32:	8f 18       	st.w	r7[0x4],r8
80006b34:	c0 d8       	rjmp	80006b4e <_malloc_r+0x26e>
80006b36:	6c 39       	ld.w	r9,r6[0xc]
80006b38:	58 08       	cp.w	r8,0
80006b3a:	c0 f5       	brlt	80006b58 <_malloc_r+0x278>
80006b3c:	ec 0a 00 0a 	add	r10,r6,r10
80006b40:	74 18       	ld.w	r8,r10[0x4]
80006b42:	a1 a8       	sbr	r8,0x0
80006b44:	0a 9c       	mov	r12,r5
80006b46:	95 18       	st.w	r10[0x4],r8
80006b48:	6c 28       	ld.w	r8,r6[0x8]
80006b4a:	93 28       	st.w	r9[0x8],r8
80006b4c:	91 39       	st.w	r8[0xc],r9
80006b4e:	fe b0 f1 6f 	rcall	80004e2c <__malloc_unlock>
80006b52:	ec cc ff f8 	sub	r12,r6,-8
80006b56:	d8 32       	popm	r0-r7,pc
80006b58:	12 96       	mov	r6,r9
80006b5a:	02 36       	cp.w	r6,r1
80006b5c:	cd 21       	brne	80006b00 <_malloc_r+0x220>
80006b5e:	2f f2       	sub	r2,-1
80006b60:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006b64:	c0 30       	breq	80006b6a <_malloc_r+0x28a>
80006b66:	2f 81       	sub	r1,-8
80006b68:	cc ab       	rjmp	80006afc <_malloc_r+0x21c>
80006b6a:	1c 98       	mov	r8,lr
80006b6c:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006b70:	c0 81       	brne	80006b80 <_malloc_r+0x2a0>
80006b72:	68 19       	ld.w	r9,r4[0x4]
80006b74:	f6 08 11 ff 	rsub	r8,r11,-1
80006b78:	f3 e8 00 08 	and	r8,r9,r8
80006b7c:	89 18       	st.w	r4[0x4],r8
80006b7e:	c0 78       	rjmp	80006b8c <_malloc_r+0x2ac>
80006b80:	f0 c9 00 08 	sub	r9,r8,8
80006b84:	20 13       	sub	r3,1
80006b86:	70 08       	ld.w	r8,r8[0x0]
80006b88:	12 38       	cp.w	r8,r9
80006b8a:	cf 10       	breq	80006b6c <_malloc_r+0x28c>
80006b8c:	a1 7b       	lsl	r11,0x1
80006b8e:	68 18       	ld.w	r8,r4[0x4]
80006b90:	10 3b       	cp.w	r11,r8
80006b92:	e0 8b 00 0d 	brhi	80006bac <_malloc_r+0x2cc>
80006b96:	58 0b       	cp.w	r11,0
80006b98:	c0 a0       	breq	80006bac <_malloc_r+0x2cc>
80006b9a:	04 93       	mov	r3,r2
80006b9c:	c0 38       	rjmp	80006ba2 <_malloc_r+0x2c2>
80006b9e:	2f c3       	sub	r3,-4
80006ba0:	a1 7b       	lsl	r11,0x1
80006ba2:	f7 e8 00 09 	and	r9,r11,r8
80006ba6:	ca 71       	brne	80006af4 <_malloc_r+0x214>
80006ba8:	cf bb       	rjmp	80006b9e <_malloc_r+0x2be>
80006baa:	d7 03       	nop
80006bac:	68 23       	ld.w	r3,r4[0x8]
80006bae:	66 12       	ld.w	r2,r3[0x4]
80006bb0:	e0 12 ff fc 	andl	r2,0xfffc
80006bb4:	0e 32       	cp.w	r2,r7
80006bb6:	5f 39       	srlo	r9
80006bb8:	e4 07 01 08 	sub	r8,r2,r7
80006bbc:	58 f8       	cp.w	r8,15
80006bbe:	5f aa       	srle	r10
80006bc0:	f5 e9 10 09 	or	r9,r10,r9
80006bc4:	e0 80 00 9a 	breq	80006cf8 <_malloc_r+0x418>
80006bc8:	e0 68 07 a4 	mov	r8,1956
80006bcc:	70 01       	ld.w	r1,r8[0x0]
80006bce:	e0 68 05 28 	mov	r8,1320
80006bd2:	2f 01       	sub	r1,-16
80006bd4:	70 08       	ld.w	r8,r8[0x0]
80006bd6:	0e 01       	add	r1,r7
80006bd8:	5b f8       	cp.w	r8,-1
80006bda:	c0 40       	breq	80006be2 <_malloc_r+0x302>
80006bdc:	28 11       	sub	r1,-127
80006bde:	e0 11 ff 80 	andl	r1,0xff80
80006be2:	02 9b       	mov	r11,r1
80006be4:	0a 9c       	mov	r12,r5
80006be6:	e0 a0 02 a5 	rcall	80007130 <_sbrk_r>
80006bea:	18 96       	mov	r6,r12
80006bec:	5b fc       	cp.w	r12,-1
80006bee:	c7 50       	breq	80006cd8 <_malloc_r+0x3f8>
80006bf0:	e6 02 00 08 	add	r8,r3,r2
80006bf4:	10 3c       	cp.w	r12,r8
80006bf6:	c0 32       	brcc	80006bfc <_malloc_r+0x31c>
80006bf8:	08 33       	cp.w	r3,r4
80006bfa:	c6 f1       	brne	80006cd8 <_malloc_r+0x3f8>
80006bfc:	e0 6a 07 a8 	mov	r10,1960
80006c00:	74 09       	ld.w	r9,r10[0x0]
80006c02:	e2 09 00 09 	add	r9,r1,r9
80006c06:	95 09       	st.w	r10[0x0],r9
80006c08:	10 36       	cp.w	r6,r8
80006c0a:	c0 a1       	brne	80006c1e <_malloc_r+0x33e>
80006c0c:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006c10:	c0 71       	brne	80006c1e <_malloc_r+0x33e>
80006c12:	e2 02 00 02 	add	r2,r1,r2
80006c16:	68 28       	ld.w	r8,r4[0x8]
80006c18:	a1 a2       	sbr	r2,0x0
80006c1a:	91 12       	st.w	r8[0x4],r2
80006c1c:	c4 f8       	rjmp	80006cba <_malloc_r+0x3da>
80006c1e:	e0 6a 05 28 	mov	r10,1320
80006c22:	74 0b       	ld.w	r11,r10[0x0]
80006c24:	5b fb       	cp.w	r11,-1
80006c26:	c0 31       	brne	80006c2c <_malloc_r+0x34c>
80006c28:	95 06       	st.w	r10[0x0],r6
80006c2a:	c0 78       	rjmp	80006c38 <_malloc_r+0x358>
80006c2c:	ec 09 00 09 	add	r9,r6,r9
80006c30:	e0 6a 07 a8 	mov	r10,1960
80006c34:	10 19       	sub	r9,r8
80006c36:	95 09       	st.w	r10[0x0],r9
80006c38:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006c3c:	f0 09 11 08 	rsub	r9,r8,8
80006c40:	58 08       	cp.w	r8,0
80006c42:	f2 08 17 10 	movne	r8,r9
80006c46:	ed d8 e1 06 	addne	r6,r6,r8
80006c4a:	28 08       	sub	r8,-128
80006c4c:	ec 01 00 01 	add	r1,r6,r1
80006c50:	0a 9c       	mov	r12,r5
80006c52:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006c56:	f0 01 01 01 	sub	r1,r8,r1
80006c5a:	02 9b       	mov	r11,r1
80006c5c:	e0 a0 02 6a 	rcall	80007130 <_sbrk_r>
80006c60:	e0 68 07 a8 	mov	r8,1960
80006c64:	5b fc       	cp.w	r12,-1
80006c66:	ec 0c 17 00 	moveq	r12,r6
80006c6a:	f9 b1 00 00 	moveq	r1,0
80006c6e:	70 09       	ld.w	r9,r8[0x0]
80006c70:	0c 1c       	sub	r12,r6
80006c72:	89 26       	st.w	r4[0x8],r6
80006c74:	02 0c       	add	r12,r1
80006c76:	12 01       	add	r1,r9
80006c78:	a1 ac       	sbr	r12,0x0
80006c7a:	91 01       	st.w	r8[0x0],r1
80006c7c:	8d 1c       	st.w	r6[0x4],r12
80006c7e:	08 33       	cp.w	r3,r4
80006c80:	c1 d0       	breq	80006cba <_malloc_r+0x3da>
80006c82:	58 f2       	cp.w	r2,15
80006c84:	e0 8b 00 05 	brhi	80006c8e <_malloc_r+0x3ae>
80006c88:	30 18       	mov	r8,1
80006c8a:	8d 18       	st.w	r6[0x4],r8
80006c8c:	c2 68       	rjmp	80006cd8 <_malloc_r+0x3f8>
80006c8e:	30 59       	mov	r9,5
80006c90:	20 c2       	sub	r2,12
80006c92:	e0 12 ff f8 	andl	r2,0xfff8
80006c96:	e6 02 00 08 	add	r8,r3,r2
80006c9a:	91 29       	st.w	r8[0x8],r9
80006c9c:	91 19       	st.w	r8[0x4],r9
80006c9e:	66 18       	ld.w	r8,r3[0x4]
80006ca0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006ca4:	e5 e8 10 08 	or	r8,r2,r8
80006ca8:	87 18       	st.w	r3[0x4],r8
80006caa:	58 f2       	cp.w	r2,15
80006cac:	e0 88 00 07 	brls	80006cba <_malloc_r+0x3da>
80006cb0:	e6 cb ff f8 	sub	r11,r3,-8
80006cb4:	0a 9c       	mov	r12,r5
80006cb6:	e0 a0 04 9d 	rcall	800075f0 <_free_r>
80006cba:	e0 69 07 a0 	mov	r9,1952
80006cbe:	72 0a       	ld.w	r10,r9[0x0]
80006cc0:	e0 68 07 a8 	mov	r8,1960
80006cc4:	70 08       	ld.w	r8,r8[0x0]
80006cc6:	14 38       	cp.w	r8,r10
80006cc8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006ccc:	e0 69 07 9c 	mov	r9,1948
80006cd0:	72 0a       	ld.w	r10,r9[0x0]
80006cd2:	14 38       	cp.w	r8,r10
80006cd4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006cd8:	68 28       	ld.w	r8,r4[0x8]
80006cda:	70 18       	ld.w	r8,r8[0x4]
80006cdc:	e0 18 ff fc 	andl	r8,0xfffc
80006ce0:	0e 38       	cp.w	r8,r7
80006ce2:	5f 39       	srlo	r9
80006ce4:	0e 18       	sub	r8,r7
80006ce6:	58 f8       	cp.w	r8,15
80006ce8:	5f aa       	srle	r10
80006cea:	f5 e9 10 09 	or	r9,r10,r9
80006cee:	c0 50       	breq	80006cf8 <_malloc_r+0x418>
80006cf0:	0a 9c       	mov	r12,r5
80006cf2:	fe b0 f0 9d 	rcall	80004e2c <__malloc_unlock>
80006cf6:	d8 3a       	popm	r0-r7,pc,r12=0
80006cf8:	68 26       	ld.w	r6,r4[0x8]
80006cfa:	a1 a8       	sbr	r8,0x0
80006cfc:	0e 99       	mov	r9,r7
80006cfe:	a1 a9       	sbr	r9,0x0
80006d00:	8d 19       	st.w	r6[0x4],r9
80006d02:	ec 07 00 07 	add	r7,r6,r7
80006d06:	0a 9c       	mov	r12,r5
80006d08:	89 27       	st.w	r4[0x8],r7
80006d0a:	8f 18       	st.w	r7[0x4],r8
80006d0c:	fe b0 f0 90 	rcall	80004e2c <__malloc_unlock>
80006d10:	ec cc ff f8 	sub	r12,r6,-8
80006d14:	d8 32       	popm	r0-r7,pc
80006d16:	d7 03       	nop

80006d18 <memcpy>:
80006d18:	58 8a       	cp.w	r10,8
80006d1a:	c2 f5       	brlt	80006d78 <memcpy+0x60>
80006d1c:	f9 eb 10 09 	or	r9,r12,r11
80006d20:	e2 19 00 03 	andl	r9,0x3,COH
80006d24:	e0 81 00 97 	brne	80006e52 <memcpy+0x13a>
80006d28:	e0 4a 00 20 	cp.w	r10,32
80006d2c:	c3 b4       	brge	80006da2 <memcpy+0x8a>
80006d2e:	f4 08 14 02 	asr	r8,r10,0x2
80006d32:	f0 09 11 08 	rsub	r9,r8,8
80006d36:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80006d3a:	76 69       	ld.w	r9,r11[0x18]
80006d3c:	99 69       	st.w	r12[0x18],r9
80006d3e:	76 59       	ld.w	r9,r11[0x14]
80006d40:	99 59       	st.w	r12[0x14],r9
80006d42:	76 49       	ld.w	r9,r11[0x10]
80006d44:	99 49       	st.w	r12[0x10],r9
80006d46:	76 39       	ld.w	r9,r11[0xc]
80006d48:	99 39       	st.w	r12[0xc],r9
80006d4a:	76 29       	ld.w	r9,r11[0x8]
80006d4c:	99 29       	st.w	r12[0x8],r9
80006d4e:	76 19       	ld.w	r9,r11[0x4]
80006d50:	99 19       	st.w	r12[0x4],r9
80006d52:	76 09       	ld.w	r9,r11[0x0]
80006d54:	99 09       	st.w	r12[0x0],r9
80006d56:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006d5a:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006d5e:	e0 1a 00 03 	andl	r10,0x3
80006d62:	f4 0a 11 04 	rsub	r10,r10,4
80006d66:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006d6a:	17 a9       	ld.ub	r9,r11[0x2]
80006d6c:	b0 a9       	st.b	r8[0x2],r9
80006d6e:	17 99       	ld.ub	r9,r11[0x1]
80006d70:	b0 99       	st.b	r8[0x1],r9
80006d72:	17 89       	ld.ub	r9,r11[0x0]
80006d74:	b0 89       	st.b	r8[0x0],r9
80006d76:	5e fc       	retal	r12
80006d78:	f4 0a 11 09 	rsub	r10,r10,9
80006d7c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006d80:	17 f9       	ld.ub	r9,r11[0x7]
80006d82:	b8 f9       	st.b	r12[0x7],r9
80006d84:	17 e9       	ld.ub	r9,r11[0x6]
80006d86:	b8 e9       	st.b	r12[0x6],r9
80006d88:	17 d9       	ld.ub	r9,r11[0x5]
80006d8a:	b8 d9       	st.b	r12[0x5],r9
80006d8c:	17 c9       	ld.ub	r9,r11[0x4]
80006d8e:	b8 c9       	st.b	r12[0x4],r9
80006d90:	17 b9       	ld.ub	r9,r11[0x3]
80006d92:	b8 b9       	st.b	r12[0x3],r9
80006d94:	17 a9       	ld.ub	r9,r11[0x2]
80006d96:	b8 a9       	st.b	r12[0x2],r9
80006d98:	17 99       	ld.ub	r9,r11[0x1]
80006d9a:	b8 99       	st.b	r12[0x1],r9
80006d9c:	17 89       	ld.ub	r9,r11[0x0]
80006d9e:	b8 89       	st.b	r12[0x0],r9
80006da0:	5e fc       	retal	r12
80006da2:	eb cd 40 c0 	pushm	r6-r7,lr
80006da6:	18 99       	mov	r9,r12
80006da8:	22 0a       	sub	r10,32
80006daa:	b7 07       	ld.d	r6,r11++
80006dac:	b3 26       	st.d	r9++,r6
80006dae:	b7 07       	ld.d	r6,r11++
80006db0:	b3 26       	st.d	r9++,r6
80006db2:	b7 07       	ld.d	r6,r11++
80006db4:	b3 26       	st.d	r9++,r6
80006db6:	b7 07       	ld.d	r6,r11++
80006db8:	b3 26       	st.d	r9++,r6
80006dba:	22 0a       	sub	r10,32
80006dbc:	cf 74       	brge	80006daa <memcpy+0x92>
80006dbe:	2f 0a       	sub	r10,-16
80006dc0:	c0 65       	brlt	80006dcc <memcpy+0xb4>
80006dc2:	b7 07       	ld.d	r6,r11++
80006dc4:	b3 26       	st.d	r9++,r6
80006dc6:	b7 07       	ld.d	r6,r11++
80006dc8:	b3 26       	st.d	r9++,r6
80006dca:	21 0a       	sub	r10,16
80006dcc:	5c 3a       	neg	r10
80006dce:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006dd2:	d7 03       	nop
80006dd4:	d7 03       	nop
80006dd6:	f7 36 00 0e 	ld.ub	r6,r11[14]
80006dda:	f3 66 00 0e 	st.b	r9[14],r6
80006dde:	f7 36 00 0d 	ld.ub	r6,r11[13]
80006de2:	f3 66 00 0d 	st.b	r9[13],r6
80006de6:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006dea:	f3 66 00 0c 	st.b	r9[12],r6
80006dee:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006df2:	f3 66 00 0b 	st.b	r9[11],r6
80006df6:	f7 36 00 0a 	ld.ub	r6,r11[10]
80006dfa:	f3 66 00 0a 	st.b	r9[10],r6
80006dfe:	f7 36 00 09 	ld.ub	r6,r11[9]
80006e02:	f3 66 00 09 	st.b	r9[9],r6
80006e06:	f7 36 00 08 	ld.ub	r6,r11[8]
80006e0a:	f3 66 00 08 	st.b	r9[8],r6
80006e0e:	f7 36 00 07 	ld.ub	r6,r11[7]
80006e12:	f3 66 00 07 	st.b	r9[7],r6
80006e16:	f7 36 00 06 	ld.ub	r6,r11[6]
80006e1a:	f3 66 00 06 	st.b	r9[6],r6
80006e1e:	f7 36 00 05 	ld.ub	r6,r11[5]
80006e22:	f3 66 00 05 	st.b	r9[5],r6
80006e26:	f7 36 00 04 	ld.ub	r6,r11[4]
80006e2a:	f3 66 00 04 	st.b	r9[4],r6
80006e2e:	f7 36 00 03 	ld.ub	r6,r11[3]
80006e32:	f3 66 00 03 	st.b	r9[3],r6
80006e36:	f7 36 00 02 	ld.ub	r6,r11[2]
80006e3a:	f3 66 00 02 	st.b	r9[2],r6
80006e3e:	f7 36 00 01 	ld.ub	r6,r11[1]
80006e42:	f3 66 00 01 	st.b	r9[1],r6
80006e46:	f7 36 00 00 	ld.ub	r6,r11[0]
80006e4a:	f3 66 00 00 	st.b	r9[0],r6
80006e4e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006e52:	20 1a       	sub	r10,1
80006e54:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006e58:	f8 0a 0b 09 	st.b	r12[r10],r9
80006e5c:	cf b1       	brne	80006e52 <memcpy+0x13a>
80006e5e:	5e fc       	retal	r12

80006e60 <memset>:
80006e60:	18 98       	mov	r8,r12
80006e62:	c0 38       	rjmp	80006e68 <memset+0x8>
80006e64:	10 cb       	st.b	r8++,r11
80006e66:	20 1a       	sub	r10,1
80006e68:	58 0a       	cp.w	r10,0
80006e6a:	cf d1       	brne	80006e64 <memset+0x4>
80006e6c:	5e fc       	retal	r12
80006e6e:	d7 03       	nop

80006e70 <_realloc_r>:
80006e70:	d4 31       	pushm	r0-r7,lr
80006e72:	20 1d       	sub	sp,4
80006e74:	16 94       	mov	r4,r11
80006e76:	18 92       	mov	r2,r12
80006e78:	14 9b       	mov	r11,r10
80006e7a:	58 04       	cp.w	r4,0
80006e7c:	c0 51       	brne	80006e86 <_realloc_r+0x16>
80006e7e:	fe b0 fd 31 	rcall	800068e0 <_malloc_r>
80006e82:	18 95       	mov	r5,r12
80006e84:	c5 39       	rjmp	8000712a <_realloc_r+0x2ba>
80006e86:	50 0a       	stdsp	sp[0x0],r10
80006e88:	fe b0 ef c4 	rcall	80004e10 <__malloc_lock>
80006e8c:	40 0b       	lddsp	r11,sp[0x0]
80006e8e:	f6 c8 ff f5 	sub	r8,r11,-11
80006e92:	e8 c1 00 08 	sub	r1,r4,8
80006e96:	10 96       	mov	r6,r8
80006e98:	62 1c       	ld.w	r12,r1[0x4]
80006e9a:	e0 16 ff f8 	andl	r6,0xfff8
80006e9e:	59 68       	cp.w	r8,22
80006ea0:	f9 b6 08 10 	movls	r6,16
80006ea4:	16 36       	cp.w	r6,r11
80006ea6:	5f 38       	srlo	r8
80006ea8:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006eac:	c0 50       	breq	80006eb6 <_realloc_r+0x46>
80006eae:	30 c8       	mov	r8,12
80006eb0:	30 05       	mov	r5,0
80006eb2:	85 38       	st.w	r2[0xc],r8
80006eb4:	c3 b9       	rjmp	8000712a <_realloc_r+0x2ba>
80006eb6:	18 90       	mov	r0,r12
80006eb8:	e0 10 ff fc 	andl	r0,0xfffc
80006ebc:	0c 30       	cp.w	r0,r6
80006ebe:	e0 84 01 0b 	brge	800070d4 <_realloc_r+0x264>
80006ec2:	e0 68 01 1c 	mov	r8,284
80006ec6:	e2 00 00 09 	add	r9,r1,r0
80006eca:	70 25       	ld.w	r5,r8[0x8]
80006ecc:	0a 39       	cp.w	r9,r5
80006ece:	c0 90       	breq	80006ee0 <_realloc_r+0x70>
80006ed0:	72 1a       	ld.w	r10,r9[0x4]
80006ed2:	a1 ca       	cbr	r10,0x0
80006ed4:	f2 0a 00 0a 	add	r10,r9,r10
80006ed8:	74 1a       	ld.w	r10,r10[0x4]
80006eda:	ed ba 00 00 	bld	r10,0x0
80006ede:	c2 20       	breq	80006f22 <_realloc_r+0xb2>
80006ee0:	72 1a       	ld.w	r10,r9[0x4]
80006ee2:	e0 1a ff fc 	andl	r10,0xfffc
80006ee6:	f4 00 00 03 	add	r3,r10,r0
80006eea:	0a 39       	cp.w	r9,r5
80006eec:	c1 31       	brne	80006f12 <_realloc_r+0xa2>
80006eee:	ec c7 ff f0 	sub	r7,r6,-16
80006ef2:	0e 33       	cp.w	r3,r7
80006ef4:	c1 95       	brlt	80006f26 <_realloc_r+0xb6>
80006ef6:	e2 06 00 09 	add	r9,r1,r6
80006efa:	0c 13       	sub	r3,r6
80006efc:	a1 a3       	sbr	r3,0x0
80006efe:	93 13       	st.w	r9[0x4],r3
80006f00:	91 29       	st.w	r8[0x8],r9
80006f02:	04 9c       	mov	r12,r2
80006f04:	62 18       	ld.w	r8,r1[0x4]
80006f06:	08 95       	mov	r5,r4
80006f08:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006f0c:	10 46       	or	r6,r8
80006f0e:	83 16       	st.w	r1[0x4],r6
80006f10:	c0 b9       	rjmp	80007126 <_realloc_r+0x2b6>
80006f12:	0c 33       	cp.w	r3,r6
80006f14:	c0 95       	brlt	80006f26 <_realloc_r+0xb6>
80006f16:	72 28       	ld.w	r8,r9[0x8]
80006f18:	02 97       	mov	r7,r1
80006f1a:	72 39       	ld.w	r9,r9[0xc]
80006f1c:	93 28       	st.w	r9[0x8],r8
80006f1e:	91 39       	st.w	r8[0xc],r9
80006f20:	cd c8       	rjmp	800070d8 <_realloc_r+0x268>
80006f22:	30 0a       	mov	r10,0
80006f24:	14 99       	mov	r9,r10
80006f26:	ed bc 00 00 	bld	r12,0x0
80006f2a:	e0 80 00 95 	breq	80007054 <_realloc_r+0x1e4>
80006f2e:	62 07       	ld.w	r7,r1[0x0]
80006f30:	e2 07 01 07 	sub	r7,r1,r7
80006f34:	6e 1c       	ld.w	r12,r7[0x4]
80006f36:	e0 1c ff fc 	andl	r12,0xfffc
80006f3a:	58 09       	cp.w	r9,0
80006f3c:	c5 60       	breq	80006fe8 <_realloc_r+0x178>
80006f3e:	f8 00 00 03 	add	r3,r12,r0
80006f42:	0a 39       	cp.w	r9,r5
80006f44:	c4 81       	brne	80006fd4 <_realloc_r+0x164>
80006f46:	14 03       	add	r3,r10
80006f48:	ec c9 ff f0 	sub	r9,r6,-16
80006f4c:	12 33       	cp.w	r3,r9
80006f4e:	c4 d5       	brlt	80006fe8 <_realloc_r+0x178>
80006f50:	6e 3a       	ld.w	r10,r7[0xc]
80006f52:	6e 29       	ld.w	r9,r7[0x8]
80006f54:	95 29       	st.w	r10[0x8],r9
80006f56:	93 3a       	st.w	r9[0xc],r10
80006f58:	ee c5 ff f8 	sub	r5,r7,-8
80006f5c:	e0 ca 00 04 	sub	r10,r0,4
80006f60:	e0 4a 00 24 	cp.w	r10,36
80006f64:	e0 8b 00 25 	brhi	80006fae <_realloc_r+0x13e>
80006f68:	0a 99       	mov	r9,r5
80006f6a:	59 3a       	cp.w	r10,19
80006f6c:	e0 88 00 1a 	brls	80006fa0 <_realloc_r+0x130>
80006f70:	09 09       	ld.w	r9,r4++
80006f72:	8b 09       	st.w	r5[0x0],r9
80006f74:	09 09       	ld.w	r9,r4++
80006f76:	8f 39       	st.w	r7[0xc],r9
80006f78:	ee c9 ff f0 	sub	r9,r7,-16
80006f7c:	59 ba       	cp.w	r10,27
80006f7e:	e0 88 00 11 	brls	80006fa0 <_realloc_r+0x130>
80006f82:	09 0b       	ld.w	r11,r4++
80006f84:	93 0b       	st.w	r9[0x0],r11
80006f86:	09 09       	ld.w	r9,r4++
80006f88:	8f 59       	st.w	r7[0x14],r9
80006f8a:	ee c9 ff e8 	sub	r9,r7,-24
80006f8e:	e0 4a 00 24 	cp.w	r10,36
80006f92:	c0 71       	brne	80006fa0 <_realloc_r+0x130>
80006f94:	09 0a       	ld.w	r10,r4++
80006f96:	93 0a       	st.w	r9[0x0],r10
80006f98:	ee c9 ff e0 	sub	r9,r7,-32
80006f9c:	09 0a       	ld.w	r10,r4++
80006f9e:	8f 7a       	st.w	r7[0x1c],r10
80006fa0:	09 0a       	ld.w	r10,r4++
80006fa2:	12 aa       	st.w	r9++,r10
80006fa4:	68 0a       	ld.w	r10,r4[0x0]
80006fa6:	93 0a       	st.w	r9[0x0],r10
80006fa8:	68 1a       	ld.w	r10,r4[0x4]
80006faa:	93 1a       	st.w	r9[0x4],r10
80006fac:	c0 78       	rjmp	80006fba <_realloc_r+0x14a>
80006fae:	50 08       	stdsp	sp[0x0],r8
80006fb0:	08 9b       	mov	r11,r4
80006fb2:	0a 9c       	mov	r12,r5
80006fb4:	e0 a0 04 08 	rcall	800077c4 <memmove>
80006fb8:	40 08       	lddsp	r8,sp[0x0]
80006fba:	ee 06 00 09 	add	r9,r7,r6
80006fbe:	0c 13       	sub	r3,r6
80006fc0:	a1 a3       	sbr	r3,0x0
80006fc2:	93 13       	st.w	r9[0x4],r3
80006fc4:	91 29       	st.w	r8[0x8],r9
80006fc6:	04 9c       	mov	r12,r2
80006fc8:	6e 18       	ld.w	r8,r7[0x4]
80006fca:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006fce:	10 46       	or	r6,r8
80006fd0:	8f 16       	st.w	r7[0x4],r6
80006fd2:	ca a8       	rjmp	80007126 <_realloc_r+0x2b6>
80006fd4:	14 03       	add	r3,r10
80006fd6:	0c 33       	cp.w	r3,r6
80006fd8:	c0 85       	brlt	80006fe8 <_realloc_r+0x178>
80006fda:	72 28       	ld.w	r8,r9[0x8]
80006fdc:	72 39       	ld.w	r9,r9[0xc]
80006fde:	93 28       	st.w	r9[0x8],r8
80006fe0:	91 39       	st.w	r8[0xc],r9
80006fe2:	6e 28       	ld.w	r8,r7[0x8]
80006fe4:	6e 39       	ld.w	r9,r7[0xc]
80006fe6:	c0 78       	rjmp	80006ff4 <_realloc_r+0x184>
80006fe8:	f8 00 00 03 	add	r3,r12,r0
80006fec:	0c 33       	cp.w	r3,r6
80006fee:	c3 35       	brlt	80007054 <_realloc_r+0x1e4>
80006ff0:	6e 39       	ld.w	r9,r7[0xc]
80006ff2:	6e 28       	ld.w	r8,r7[0x8]
80006ff4:	93 28       	st.w	r9[0x8],r8
80006ff6:	91 39       	st.w	r8[0xc],r9
80006ff8:	e0 ca 00 04 	sub	r10,r0,4
80006ffc:	ee cc ff f8 	sub	r12,r7,-8
80007000:	e0 4a 00 24 	cp.w	r10,36
80007004:	e0 8b 00 24 	brhi	8000704c <_realloc_r+0x1dc>
80007008:	59 3a       	cp.w	r10,19
8000700a:	e0 88 00 1a 	brls	8000703e <_realloc_r+0x1ce>
8000700e:	09 08       	ld.w	r8,r4++
80007010:	99 08       	st.w	r12[0x0],r8
80007012:	09 08       	ld.w	r8,r4++
80007014:	8f 38       	st.w	r7[0xc],r8
80007016:	ee cc ff f0 	sub	r12,r7,-16
8000701a:	59 ba       	cp.w	r10,27
8000701c:	e0 88 00 11 	brls	8000703e <_realloc_r+0x1ce>
80007020:	09 08       	ld.w	r8,r4++
80007022:	99 08       	st.w	r12[0x0],r8
80007024:	09 08       	ld.w	r8,r4++
80007026:	8f 58       	st.w	r7[0x14],r8
80007028:	ee cc ff e8 	sub	r12,r7,-24
8000702c:	e0 4a 00 24 	cp.w	r10,36
80007030:	c0 71       	brne	8000703e <_realloc_r+0x1ce>
80007032:	09 08       	ld.w	r8,r4++
80007034:	99 08       	st.w	r12[0x0],r8
80007036:	ee cc ff e0 	sub	r12,r7,-32
8000703a:	09 08       	ld.w	r8,r4++
8000703c:	8f 78       	st.w	r7[0x1c],r8
8000703e:	09 08       	ld.w	r8,r4++
80007040:	18 a8       	st.w	r12++,r8
80007042:	68 08       	ld.w	r8,r4[0x0]
80007044:	99 08       	st.w	r12[0x0],r8
80007046:	68 18       	ld.w	r8,r4[0x4]
80007048:	99 18       	st.w	r12[0x4],r8
8000704a:	c4 78       	rjmp	800070d8 <_realloc_r+0x268>
8000704c:	08 9b       	mov	r11,r4
8000704e:	e0 a0 03 bb 	rcall	800077c4 <memmove>
80007052:	c4 38       	rjmp	800070d8 <_realloc_r+0x268>
80007054:	04 9c       	mov	r12,r2
80007056:	fe b0 fc 45 	rcall	800068e0 <_malloc_r>
8000705a:	18 95       	mov	r5,r12
8000705c:	c3 a0       	breq	800070d0 <_realloc_r+0x260>
8000705e:	62 18       	ld.w	r8,r1[0x4]
80007060:	f8 c9 00 08 	sub	r9,r12,8
80007064:	a1 c8       	cbr	r8,0x0
80007066:	e2 08 00 08 	add	r8,r1,r8
8000706a:	10 39       	cp.w	r9,r8
8000706c:	c0 71       	brne	8000707a <_realloc_r+0x20a>
8000706e:	72 13       	ld.w	r3,r9[0x4]
80007070:	02 97       	mov	r7,r1
80007072:	e0 13 ff fc 	andl	r3,0xfffc
80007076:	00 03       	add	r3,r0
80007078:	c3 08       	rjmp	800070d8 <_realloc_r+0x268>
8000707a:	e0 ca 00 04 	sub	r10,r0,4
8000707e:	e0 4a 00 24 	cp.w	r10,36
80007082:	e0 8b 00 20 	brhi	800070c2 <_realloc_r+0x252>
80007086:	08 99       	mov	r9,r4
80007088:	18 98       	mov	r8,r12
8000708a:	59 3a       	cp.w	r10,19
8000708c:	e0 88 00 14 	brls	800070b4 <_realloc_r+0x244>
80007090:	13 0b       	ld.w	r11,r9++
80007092:	10 ab       	st.w	r8++,r11
80007094:	13 0b       	ld.w	r11,r9++
80007096:	10 ab       	st.w	r8++,r11
80007098:	59 ba       	cp.w	r10,27
8000709a:	e0 88 00 0d 	brls	800070b4 <_realloc_r+0x244>
8000709e:	13 0b       	ld.w	r11,r9++
800070a0:	10 ab       	st.w	r8++,r11
800070a2:	13 0b       	ld.w	r11,r9++
800070a4:	10 ab       	st.w	r8++,r11
800070a6:	e0 4a 00 24 	cp.w	r10,36
800070aa:	c0 51       	brne	800070b4 <_realloc_r+0x244>
800070ac:	13 0a       	ld.w	r10,r9++
800070ae:	10 aa       	st.w	r8++,r10
800070b0:	13 0a       	ld.w	r10,r9++
800070b2:	10 aa       	st.w	r8++,r10
800070b4:	13 0a       	ld.w	r10,r9++
800070b6:	10 aa       	st.w	r8++,r10
800070b8:	72 0a       	ld.w	r10,r9[0x0]
800070ba:	91 0a       	st.w	r8[0x0],r10
800070bc:	72 19       	ld.w	r9,r9[0x4]
800070be:	91 19       	st.w	r8[0x4],r9
800070c0:	c0 48       	rjmp	800070c8 <_realloc_r+0x258>
800070c2:	08 9b       	mov	r11,r4
800070c4:	e0 a0 03 80 	rcall	800077c4 <memmove>
800070c8:	08 9b       	mov	r11,r4
800070ca:	04 9c       	mov	r12,r2
800070cc:	e0 a0 02 92 	rcall	800075f0 <_free_r>
800070d0:	04 9c       	mov	r12,r2
800070d2:	c2 a8       	rjmp	80007126 <_realloc_r+0x2b6>
800070d4:	00 93       	mov	r3,r0
800070d6:	02 97       	mov	r7,r1
800070d8:	e6 06 01 09 	sub	r9,r3,r6
800070dc:	6e 18       	ld.w	r8,r7[0x4]
800070de:	58 f9       	cp.w	r9,15
800070e0:	e0 88 00 16 	brls	8000710c <_realloc_r+0x29c>
800070e4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800070e8:	ed e8 10 08 	or	r8,r6,r8
800070ec:	8f 18       	st.w	r7[0x4],r8
800070ee:	12 98       	mov	r8,r9
800070f0:	a1 a8       	sbr	r8,0x0
800070f2:	ee 06 00 0b 	add	r11,r7,r6
800070f6:	f6 09 00 09 	add	r9,r11,r9
800070fa:	97 18       	st.w	r11[0x4],r8
800070fc:	72 18       	ld.w	r8,r9[0x4]
800070fe:	a1 a8       	sbr	r8,0x0
80007100:	2f 8b       	sub	r11,-8
80007102:	93 18       	st.w	r9[0x4],r8
80007104:	04 9c       	mov	r12,r2
80007106:	e0 a0 02 75 	rcall	800075f0 <_free_r>
8000710a:	c0 b8       	rjmp	80007120 <_realloc_r+0x2b0>
8000710c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007110:	e7 e8 10 08 	or	r8,r3,r8
80007114:	8f 18       	st.w	r7[0x4],r8
80007116:	ee 03 00 03 	add	r3,r7,r3
8000711a:	66 18       	ld.w	r8,r3[0x4]
8000711c:	a1 a8       	sbr	r8,0x0
8000711e:	87 18       	st.w	r3[0x4],r8
80007120:	04 9c       	mov	r12,r2
80007122:	ee c5 ff f8 	sub	r5,r7,-8
80007126:	fe b0 ee 83 	rcall	80004e2c <__malloc_unlock>
8000712a:	0a 9c       	mov	r12,r5
8000712c:	2f fd       	sub	sp,-4
8000712e:	d8 32       	popm	r0-r7,pc

80007130 <_sbrk_r>:
80007130:	d4 21       	pushm	r4-r7,lr
80007132:	30 08       	mov	r8,0
80007134:	18 97       	mov	r7,r12
80007136:	e0 66 08 10 	mov	r6,2064
8000713a:	16 9c       	mov	r12,r11
8000713c:	8d 08       	st.w	r6[0x0],r8
8000713e:	c7 1c       	rcall	80007220 <_sbrk>
80007140:	5b fc       	cp.w	r12,-1
80007142:	c0 51       	brne	8000714c <_sbrk_r+0x1c>
80007144:	6c 08       	ld.w	r8,r6[0x0]
80007146:	58 08       	cp.w	r8,0
80007148:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000714c:	d8 22       	popm	r4-r7,pc
8000714e:	d7 03       	nop

80007150 <strncpy>:
80007150:	30 08       	mov	r8,0
80007152:	10 3a       	cp.w	r10,r8
80007154:	5e 0c       	reteq	r12
80007156:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000715a:	f8 08 0b 09 	st.b	r12[r8],r9
8000715e:	2f f8       	sub	r8,-1
80007160:	58 09       	cp.w	r9,0
80007162:	cf 81       	brne	80007152 <strncpy+0x2>
80007164:	10 3a       	cp.w	r10,r8
80007166:	5e 0c       	reteq	r12
80007168:	f8 08 0b 09 	st.b	r12[r8],r9
8000716c:	2f f8       	sub	r8,-1
8000716e:	cf bb       	rjmp	80007164 <strncpy+0x14>

80007170 <_init_argv>:
80007170:	30 e8       	mov	r8,14
80007172:	d6 73       	breakpoint
80007174:	3f fc       	mov	r12,-1
80007176:	35 8b       	mov	r11,88
80007178:	5e fc       	retal	r12

8000717a <_exit>:
8000717a:	30 d8       	mov	r8,13
8000717c:	d6 73       	breakpoint
8000717e:	3f fc       	mov	r12,-1
80007180:	35 8b       	mov	r11,88
80007182:	c0 08       	rjmp	80007182 <_exit+0x8>

80007184 <_close>:
80007184:	30 28       	mov	r8,2
80007186:	d6 73       	breakpoint
80007188:	3f fc       	mov	r12,-1
8000718a:	35 8b       	mov	r11,88
8000718c:	58 0c       	cp.w	r12,0
8000718e:	5e 4c       	retge	r12
80007190:	e0 6a 08 10 	mov	r10,2064
80007194:	95 0b       	st.w	r10[0x0],r11
80007196:	5e fc       	retal	r12

80007198 <_lseek>:
80007198:	30 58       	mov	r8,5
8000719a:	d6 73       	breakpoint
8000719c:	3f fc       	mov	r12,-1
8000719e:	35 8b       	mov	r11,88
800071a0:	58 0c       	cp.w	r12,0
800071a2:	5e 4c       	retge	r12
800071a4:	e0 6a 08 10 	mov	r10,2064
800071a8:	95 0b       	st.w	r10[0x0],r11
800071aa:	5e fc       	retal	r12

800071ac <isatty>:
800071ac:	30 b8       	mov	r8,11
800071ae:	d6 73       	breakpoint
800071b0:	3f fc       	mov	r12,-1
800071b2:	35 8b       	mov	r11,88
800071b4:	58 0c       	cp.w	r12,0
800071b6:	5e 4c       	retge	r12
800071b8:	e0 6a 08 10 	mov	r10,2064
800071bc:	95 0b       	st.w	r10[0x0],r11
800071be:	5e fc       	retal	r12

800071c0 <_fstat_host>:
800071c0:	30 98       	mov	r8,9
800071c2:	d6 73       	breakpoint
800071c4:	3f fc       	mov	r12,-1
800071c6:	35 8b       	mov	r11,88
800071c8:	58 0c       	cp.w	r12,0
800071ca:	5e 4c       	retge	r12
800071cc:	e0 6a 08 10 	mov	r10,2064
800071d0:	95 0b       	st.w	r10[0x0],r11
800071d2:	5e fc       	retal	r12

800071d4 <_fstat>:
800071d4:	d4 21       	pushm	r4-r7,lr
800071d6:	21 0d       	sub	sp,64
800071d8:	16 97       	mov	r7,r11
800071da:	1a 9b       	mov	r11,sp
800071dc:	cf 2f       	rcall	800071c0 <_fstat_host>
800071de:	c0 34       	brge	800071e4 <_fstat+0x10>
800071e0:	3f fc       	mov	r12,-1
800071e2:	c1 c8       	rjmp	8000721a <_fstat+0x46>
800071e4:	40 08       	lddsp	r8,sp[0x0]
800071e6:	ae 08       	st.h	r7[0x0],r8
800071e8:	40 18       	lddsp	r8,sp[0x4]
800071ea:	ae 18       	st.h	r7[0x2],r8
800071ec:	40 28       	lddsp	r8,sp[0x8]
800071ee:	8f 18       	st.w	r7[0x4],r8
800071f0:	40 38       	lddsp	r8,sp[0xc]
800071f2:	ae 48       	st.h	r7[0x8],r8
800071f4:	40 48       	lddsp	r8,sp[0x10]
800071f6:	ae 58       	st.h	r7[0xa],r8
800071f8:	40 58       	lddsp	r8,sp[0x14]
800071fa:	ae 68       	st.h	r7[0xc],r8
800071fc:	40 68       	lddsp	r8,sp[0x18]
800071fe:	ae 78       	st.h	r7[0xe],r8
80007200:	40 88       	lddsp	r8,sp[0x20]
80007202:	8f 48       	st.w	r7[0x10],r8
80007204:	40 a8       	lddsp	r8,sp[0x28]
80007206:	8f b8       	st.w	r7[0x2c],r8
80007208:	40 c8       	lddsp	r8,sp[0x30]
8000720a:	8f c8       	st.w	r7[0x30],r8
8000720c:	40 d8       	lddsp	r8,sp[0x34]
8000720e:	8f 58       	st.w	r7[0x14],r8
80007210:	40 e8       	lddsp	r8,sp[0x38]
80007212:	30 0c       	mov	r12,0
80007214:	8f 78       	st.w	r7[0x1c],r8
80007216:	40 f8       	lddsp	r8,sp[0x3c]
80007218:	8f 98       	st.w	r7[0x24],r8
8000721a:	2f 0d       	sub	sp,-64
8000721c:	d8 22       	popm	r4-r7,pc
8000721e:	d7 03       	nop

80007220 <_sbrk>:
80007220:	d4 01       	pushm	lr
80007222:	e0 68 07 d0 	mov	r8,2000
80007226:	70 09       	ld.w	r9,r8[0x0]
80007228:	58 09       	cp.w	r9,0
8000722a:	c0 41       	brne	80007232 <_sbrk+0x12>
8000722c:	e0 69 08 18 	mov	r9,2072
80007230:	91 09       	st.w	r8[0x0],r9
80007232:	e0 69 07 d0 	mov	r9,2000
80007236:	e0 6a f0 00 	mov	r10,61440
8000723a:	72 08       	ld.w	r8,r9[0x0]
8000723c:	f0 0c 00 0c 	add	r12,r8,r12
80007240:	14 3c       	cp.w	r12,r10
80007242:	e0 8b 00 04 	brhi	8000724a <_sbrk+0x2a>
80007246:	93 0c       	st.w	r9[0x0],r12
80007248:	c0 58       	rjmp	80007252 <_sbrk+0x32>
8000724a:	ce 1c       	rcall	8000740c <__errno>
8000724c:	30 c8       	mov	r8,12
8000724e:	99 08       	st.w	r12[0x0],r8
80007250:	3f f8       	mov	r8,-1
80007252:	10 9c       	mov	r12,r8
80007254:	d8 02       	popm	pc
80007256:	d7 03       	nop

80007258 <_vsprintf_r>:
80007258:	d4 01       	pushm	lr
8000725a:	21 7d       	sub	sp,92
8000725c:	e0 68 ff ff 	mov	r8,65535
80007260:	ea 18 7f ff 	orh	r8,0x7fff
80007264:	50 58       	stdsp	sp[0x14],r8
80007266:	50 28       	stdsp	sp[0x8],r8
80007268:	e0 68 02 08 	mov	r8,520
8000726c:	ba 68       	st.h	sp[0xc],r8
8000726e:	3f f8       	mov	r8,-1
80007270:	50 4b       	stdsp	sp[0x10],r11
80007272:	50 0b       	stdsp	sp[0x0],r11
80007274:	ba 78       	st.h	sp[0xe],r8
80007276:	1a 9b       	mov	r11,sp
80007278:	e0 a0 04 9e 	rcall	80007bb4 <_vfprintf_r>
8000727c:	30 09       	mov	r9,0
8000727e:	40 08       	lddsp	r8,sp[0x0]
80007280:	b0 89       	st.b	r8[0x0],r9
80007282:	2e 9d       	sub	sp,-92
80007284:	d8 02       	popm	pc
80007286:	d7 03       	nop

80007288 <vsprintf>:
80007288:	d4 01       	pushm	lr
8000728a:	e0 68 01 18 	mov	r8,280
8000728e:	14 99       	mov	r9,r10
80007290:	16 9a       	mov	r10,r11
80007292:	18 9b       	mov	r11,r12
80007294:	70 0c       	ld.w	r12,r8[0x0]
80007296:	ce 1f       	rcall	80007258 <_vsprintf_r>
80007298:	d8 02       	popm	pc
8000729a:	d7 03       	nop

8000729c <__register_exitproc>:
8000729c:	d4 31       	pushm	r0-r7,lr
8000729e:	fe c8 ad 6a 	sub	r8,pc,-21142
800072a2:	70 03       	ld.w	r3,r8[0x0]
800072a4:	67 24       	ld.w	r4,r3[0x48]
800072a6:	e6 c8 ff b4 	sub	r8,r3,-76
800072aa:	58 04       	cp.w	r4,0
800072ac:	f0 04 17 00 	moveq	r4,r8
800072b0:	e7 f4 0a 12 	st.weq	r3[0x48],r4
800072b4:	18 97       	mov	r7,r12
800072b6:	16 96       	mov	r6,r11
800072b8:	14 95       	mov	r5,r10
800072ba:	12 92       	mov	r2,r9
800072bc:	68 18       	ld.w	r8,r4[0x4]
800072be:	59 f8       	cp.w	r8,31
800072c0:	e0 8a 00 0e 	brle	800072dc <__register_exitproc+0x40>
800072c4:	e0 6c 00 8c 	mov	r12,140
800072c8:	fe b0 fb 04 	rcall	800068d0 <malloc>
800072cc:	18 94       	mov	r4,r12
800072ce:	c3 80       	breq	8000733e <__register_exitproc+0xa2>
800072d0:	67 28       	ld.w	r8,r3[0x48]
800072d2:	99 08       	st.w	r12[0x0],r8
800072d4:	e7 4c 00 48 	st.w	r3[72],r12
800072d8:	30 08       	mov	r8,0
800072da:	99 18       	st.w	r12[0x4],r8
800072dc:	58 07       	cp.w	r7,0
800072de:	c2 70       	breq	8000732c <__register_exitproc+0x90>
800072e0:	e8 fc 00 88 	ld.w	r12,r4[136]
800072e4:	58 0c       	cp.w	r12,0
800072e6:	c0 d1       	brne	80007300 <__register_exitproc+0x64>
800072e8:	e0 6c 01 08 	mov	r12,264
800072ec:	fe b0 fa f2 	rcall	800068d0 <malloc>
800072f0:	c2 70       	breq	8000733e <__register_exitproc+0xa2>
800072f2:	30 08       	mov	r8,0
800072f4:	e9 4c 00 88 	st.w	r4[136],r12
800072f8:	f9 48 01 04 	st.w	r12[260],r8
800072fc:	f9 48 01 00 	st.w	r12[256],r8
80007300:	68 18       	ld.w	r8,r4[0x4]
80007302:	f0 c9 ff e0 	sub	r9,r8,-32
80007306:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
8000730a:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
8000730e:	30 1a       	mov	r10,1
80007310:	f8 f9 01 00 	ld.w	r9,r12[256]
80007314:	f4 08 09 48 	lsl	r8,r10,r8
80007318:	10 49       	or	r9,r8
8000731a:	f9 49 01 00 	st.w	r12[256],r9
8000731e:	58 27       	cp.w	r7,2
80007320:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
80007324:	f3 d8 e0 38 	oreq	r8,r9,r8
80007328:	f9 f8 0a 41 	st.weq	r12[0x104],r8
8000732c:	68 18       	ld.w	r8,r4[0x4]
8000732e:	30 0c       	mov	r12,0
80007330:	f0 c9 ff ff 	sub	r9,r8,-1
80007334:	2f e8       	sub	r8,-2
80007336:	89 19       	st.w	r4[0x4],r9
80007338:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
8000733c:	d8 32       	popm	r0-r7,pc
8000733e:	dc 3a       	popm	r0-r7,pc,r12=-1

80007340 <__call_exitprocs>:
80007340:	d4 31       	pushm	r0-r7,lr
80007342:	20 3d       	sub	sp,12
80007344:	fe c8 ae 10 	sub	r8,pc,-20976
80007348:	50 2c       	stdsp	sp[0x8],r12
8000734a:	70 08       	ld.w	r8,r8[0x0]
8000734c:	16 91       	mov	r1,r11
8000734e:	50 08       	stdsp	sp[0x0],r8
80007350:	2b 88       	sub	r8,-72
80007352:	50 18       	stdsp	sp[0x4],r8
80007354:	40 0a       	lddsp	r10,sp[0x0]
80007356:	40 14       	lddsp	r4,sp[0x4]
80007358:	75 27       	ld.w	r7,r10[0x48]
8000735a:	c5 58       	rjmp	80007404 <__call_exitprocs+0xc4>
8000735c:	6e 15       	ld.w	r5,r7[0x4]
8000735e:	ee f6 00 88 	ld.w	r6,r7[136]
80007362:	ea c2 ff ff 	sub	r2,r5,-1
80007366:	20 15       	sub	r5,1
80007368:	ee 02 00 22 	add	r2,r7,r2<<0x2
8000736c:	ec 05 00 23 	add	r3,r6,r5<<0x2
80007370:	c3 58       	rjmp	800073da <__call_exitprocs+0x9a>
80007372:	58 01       	cp.w	r1,0
80007374:	c0 70       	breq	80007382 <__call_exitprocs+0x42>
80007376:	58 06       	cp.w	r6,0
80007378:	c2 e0       	breq	800073d4 <__call_exitprocs+0x94>
8000737a:	e6 f8 00 80 	ld.w	r8,r3[128]
8000737e:	02 38       	cp.w	r8,r1
80007380:	c2 a1       	brne	800073d4 <__call_exitprocs+0x94>
80007382:	6e 19       	ld.w	r9,r7[0x4]
80007384:	64 08       	ld.w	r8,r2[0x0]
80007386:	20 19       	sub	r9,1
80007388:	12 35       	cp.w	r5,r9
8000738a:	ef f5 0a 01 	st.weq	r7[0x4],r5
8000738e:	f9 b9 01 00 	movne	r9,0
80007392:	e5 f9 1a 00 	st.wne	r2[0x0],r9
80007396:	58 08       	cp.w	r8,0
80007398:	c1 e0       	breq	800073d4 <__call_exitprocs+0x94>
8000739a:	6e 10       	ld.w	r0,r7[0x4]
8000739c:	58 06       	cp.w	r6,0
8000739e:	c0 90       	breq	800073b0 <__call_exitprocs+0x70>
800073a0:	30 1a       	mov	r10,1
800073a2:	f4 05 09 49 	lsl	r9,r10,r5
800073a6:	ec fa 01 00 	ld.w	r10,r6[256]
800073aa:	f3 ea 00 0a 	and	r10,r9,r10
800073ae:	c0 31       	brne	800073b4 <__call_exitprocs+0x74>
800073b0:	5d 18       	icall	r8
800073b2:	c0 b8       	rjmp	800073c8 <__call_exitprocs+0x88>
800073b4:	ec fa 01 04 	ld.w	r10,r6[260]
800073b8:	66 0b       	ld.w	r11,r3[0x0]
800073ba:	14 69       	and	r9,r10
800073bc:	c0 41       	brne	800073c4 <__call_exitprocs+0x84>
800073be:	40 2c       	lddsp	r12,sp[0x8]
800073c0:	5d 18       	icall	r8
800073c2:	c0 38       	rjmp	800073c8 <__call_exitprocs+0x88>
800073c4:	16 9c       	mov	r12,r11
800073c6:	5d 18       	icall	r8
800073c8:	6e 18       	ld.w	r8,r7[0x4]
800073ca:	10 30       	cp.w	r0,r8
800073cc:	cc 41       	brne	80007354 <__call_exitprocs+0x14>
800073ce:	68 08       	ld.w	r8,r4[0x0]
800073d0:	0e 38       	cp.w	r8,r7
800073d2:	cc 11       	brne	80007354 <__call_exitprocs+0x14>
800073d4:	20 15       	sub	r5,1
800073d6:	20 43       	sub	r3,4
800073d8:	20 42       	sub	r2,4
800073da:	58 05       	cp.w	r5,0
800073dc:	cc b4       	brge	80007372 <__call_exitprocs+0x32>
800073de:	6e 18       	ld.w	r8,r7[0x4]
800073e0:	58 08       	cp.w	r8,0
800073e2:	c0 f1       	brne	80007400 <__call_exitprocs+0xc0>
800073e4:	6e 08       	ld.w	r8,r7[0x0]
800073e6:	58 08       	cp.w	r8,0
800073e8:	c0 c0       	breq	80007400 <__call_exitprocs+0xc0>
800073ea:	89 08       	st.w	r4[0x0],r8
800073ec:	58 06       	cp.w	r6,0
800073ee:	c0 40       	breq	800073f6 <__call_exitprocs+0xb6>
800073f0:	0c 9c       	mov	r12,r6
800073f2:	fe b0 fa 67 	rcall	800068c0 <free>
800073f6:	0e 9c       	mov	r12,r7
800073f8:	fe b0 fa 64 	rcall	800068c0 <free>
800073fc:	68 07       	ld.w	r7,r4[0x0]
800073fe:	c0 38       	rjmp	80007404 <__call_exitprocs+0xc4>
80007400:	0e 94       	mov	r4,r7
80007402:	6e 07       	ld.w	r7,r7[0x0]
80007404:	58 07       	cp.w	r7,0
80007406:	ca b1       	brne	8000735c <__call_exitprocs+0x1c>
80007408:	2f dd       	sub	sp,-12
8000740a:	d8 32       	popm	r0-r7,pc

8000740c <__errno>:
8000740c:	e0 68 01 18 	mov	r8,280
80007410:	70 0c       	ld.w	r12,r8[0x0]
80007412:	2f 4c       	sub	r12,-12
80007414:	5e fc       	retal	r12
80007416:	d7 03       	nop

80007418 <__sfp_lock_acquire>:
80007418:	5e fc       	retal	r12

8000741a <__sfp_lock_release>:
8000741a:	5e fc       	retal	r12

8000741c <_cleanup_r>:
8000741c:	d4 01       	pushm	lr
8000741e:	fe cb ca 82 	sub	r11,pc,-13694
80007422:	ca dd       	rcall	8000777c <_fwalk>
80007424:	d8 02       	popm	pc
80007426:	d7 03       	nop

80007428 <__sfmoreglue>:
80007428:	d4 21       	pushm	r4-r7,lr
8000742a:	16 95       	mov	r5,r11
8000742c:	f6 06 10 5c 	mul	r6,r11,92
80007430:	ec cb ff f4 	sub	r11,r6,-12
80007434:	fe b0 fa 56 	rcall	800068e0 <_malloc_r>
80007438:	18 97       	mov	r7,r12
8000743a:	c0 90       	breq	8000744c <__sfmoreglue+0x24>
8000743c:	99 15       	st.w	r12[0x4],r5
8000743e:	30 0b       	mov	r11,0
80007440:	2f 4c       	sub	r12,-12
80007442:	0c 9a       	mov	r10,r6
80007444:	8f 2c       	st.w	r7[0x8],r12
80007446:	8f 0b       	st.w	r7[0x0],r11
80007448:	fe b0 fd 0c 	rcall	80006e60 <memset>
8000744c:	0e 9c       	mov	r12,r7
8000744e:	d8 22       	popm	r4-r7,pc

80007450 <__sfp>:
80007450:	d4 21       	pushm	r4-r7,lr
80007452:	fe c8 af 1e 	sub	r8,pc,-20706
80007456:	18 96       	mov	r6,r12
80007458:	70 07       	ld.w	r7,r8[0x0]
8000745a:	6e 68       	ld.w	r8,r7[0x18]
8000745c:	58 08       	cp.w	r8,0
8000745e:	c0 31       	brne	80007464 <__sfp+0x14>
80007460:	0e 9c       	mov	r12,r7
80007462:	c2 dc       	rcall	800074bc <__sinit>
80007464:	ee c7 ff 28 	sub	r7,r7,-216
80007468:	30 05       	mov	r5,0
8000746a:	6e 2c       	ld.w	r12,r7[0x8]
8000746c:	6e 18       	ld.w	r8,r7[0x4]
8000746e:	c0 68       	rjmp	8000747a <__sfp+0x2a>
80007470:	98 69       	ld.sh	r9,r12[0xc]
80007472:	ea 09 19 00 	cp.h	r9,r5
80007476:	c1 10       	breq	80007498 <__sfp+0x48>
80007478:	2a 4c       	sub	r12,-92
8000747a:	20 18       	sub	r8,1
8000747c:	cf a7       	brpl	80007470 <__sfp+0x20>
8000747e:	6e 08       	ld.w	r8,r7[0x0]
80007480:	58 08       	cp.w	r8,0
80007482:	c0 61       	brne	8000748e <__sfp+0x3e>
80007484:	30 4b       	mov	r11,4
80007486:	0c 9c       	mov	r12,r6
80007488:	cd 0f       	rcall	80007428 <__sfmoreglue>
8000748a:	8f 0c       	st.w	r7[0x0],r12
8000748c:	c0 30       	breq	80007492 <__sfp+0x42>
8000748e:	6e 07       	ld.w	r7,r7[0x0]
80007490:	ce db       	rjmp	8000746a <__sfp+0x1a>
80007492:	30 c8       	mov	r8,12
80007494:	8d 38       	st.w	r6[0xc],r8
80007496:	d8 22       	popm	r4-r7,pc
80007498:	30 08       	mov	r8,0
8000749a:	f9 48 00 4c 	st.w	r12[76],r8
8000749e:	99 08       	st.w	r12[0x0],r8
800074a0:	99 28       	st.w	r12[0x8],r8
800074a2:	99 18       	st.w	r12[0x4],r8
800074a4:	99 48       	st.w	r12[0x10],r8
800074a6:	99 58       	st.w	r12[0x14],r8
800074a8:	99 68       	st.w	r12[0x18],r8
800074aa:	99 d8       	st.w	r12[0x34],r8
800074ac:	99 e8       	st.w	r12[0x38],r8
800074ae:	f9 48 00 48 	st.w	r12[72],r8
800074b2:	3f f8       	mov	r8,-1
800074b4:	b8 78       	st.h	r12[0xe],r8
800074b6:	30 18       	mov	r8,1
800074b8:	b8 68       	st.h	r12[0xc],r8
800074ba:	d8 22       	popm	r4-r7,pc

800074bc <__sinit>:
800074bc:	d4 21       	pushm	r4-r7,lr
800074be:	18 96       	mov	r6,r12
800074c0:	78 67       	ld.w	r7,r12[0x18]
800074c2:	58 07       	cp.w	r7,0
800074c4:	c4 91       	brne	80007556 <__sinit+0x9a>
800074c6:	fe c8 00 aa 	sub	r8,pc,170
800074ca:	30 15       	mov	r5,1
800074cc:	99 a8       	st.w	r12[0x28],r8
800074ce:	f9 47 00 d8 	st.w	r12[216],r7
800074d2:	f9 47 00 dc 	st.w	r12[220],r7
800074d6:	f9 47 00 e0 	st.w	r12[224],r7
800074da:	99 65       	st.w	r12[0x18],r5
800074dc:	cb af       	rcall	80007450 <__sfp>
800074de:	8d 0c       	st.w	r6[0x0],r12
800074e0:	0c 9c       	mov	r12,r6
800074e2:	cb 7f       	rcall	80007450 <__sfp>
800074e4:	8d 1c       	st.w	r6[0x4],r12
800074e6:	0c 9c       	mov	r12,r6
800074e8:	cb 4f       	rcall	80007450 <__sfp>
800074ea:	6c 09       	ld.w	r9,r6[0x0]
800074ec:	30 48       	mov	r8,4
800074ee:	93 07       	st.w	r9[0x0],r7
800074f0:	b2 68       	st.h	r9[0xc],r8
800074f2:	93 17       	st.w	r9[0x4],r7
800074f4:	93 27       	st.w	r9[0x8],r7
800074f6:	6c 18       	ld.w	r8,r6[0x4]
800074f8:	b2 77       	st.h	r9[0xe],r7
800074fa:	93 47       	st.w	r9[0x10],r7
800074fc:	93 57       	st.w	r9[0x14],r7
800074fe:	93 67       	st.w	r9[0x18],r7
80007500:	93 89       	st.w	r9[0x20],r9
80007502:	91 07       	st.w	r8[0x0],r7
80007504:	91 17       	st.w	r8[0x4],r7
80007506:	91 27       	st.w	r8[0x8],r7
80007508:	fe ce fc a4 	sub	lr,pc,-860
8000750c:	fe cb fc d8 	sub	r11,pc,-808
80007510:	93 9e       	st.w	r9[0x24],lr
80007512:	93 ab       	st.w	r9[0x28],r11
80007514:	fe ca fd 04 	sub	r10,pc,-764
80007518:	fe c4 fd 14 	sub	r4,pc,-748
8000751c:	93 ba       	st.w	r9[0x2c],r10
8000751e:	93 c4       	st.w	r9[0x30],r4
80007520:	30 99       	mov	r9,9
80007522:	b0 69       	st.h	r8[0xc],r9
80007524:	b0 75       	st.h	r8[0xe],r5
80007526:	91 c4       	st.w	r8[0x30],r4
80007528:	91 47       	st.w	r8[0x10],r7
8000752a:	91 57       	st.w	r8[0x14],r7
8000752c:	91 67       	st.w	r8[0x18],r7
8000752e:	91 88       	st.w	r8[0x20],r8
80007530:	91 9e       	st.w	r8[0x24],lr
80007532:	91 ab       	st.w	r8[0x28],r11
80007534:	91 ba       	st.w	r8[0x2c],r10
80007536:	8d 2c       	st.w	r6[0x8],r12
80007538:	31 28       	mov	r8,18
8000753a:	99 07       	st.w	r12[0x0],r7
8000753c:	b8 68       	st.h	r12[0xc],r8
8000753e:	99 17       	st.w	r12[0x4],r7
80007540:	99 27       	st.w	r12[0x8],r7
80007542:	30 28       	mov	r8,2
80007544:	b8 78       	st.h	r12[0xe],r8
80007546:	99 c4       	st.w	r12[0x30],r4
80007548:	99 67       	st.w	r12[0x18],r7
8000754a:	99 9e       	st.w	r12[0x24],lr
8000754c:	99 ab       	st.w	r12[0x28],r11
8000754e:	99 ba       	st.w	r12[0x2c],r10
80007550:	99 47       	st.w	r12[0x10],r7
80007552:	99 57       	st.w	r12[0x14],r7
80007554:	99 8c       	st.w	r12[0x20],r12
80007556:	d8 22       	popm	r4-r7,pc

80007558 <_malloc_trim_r>:
80007558:	d4 21       	pushm	r4-r7,lr
8000755a:	16 95       	mov	r5,r11
8000755c:	18 97       	mov	r7,r12
8000755e:	fe b0 ec 59 	rcall	80004e10 <__malloc_lock>
80007562:	e0 64 01 1c 	mov	r4,284
80007566:	68 28       	ld.w	r8,r4[0x8]
80007568:	70 16       	ld.w	r6,r8[0x4]
8000756a:	e0 16 ff fc 	andl	r6,0xfffc
8000756e:	ec c8 ff 91 	sub	r8,r6,-111
80007572:	f0 05 01 05 	sub	r5,r8,r5
80007576:	e0 15 ff 80 	andl	r5,0xff80
8000757a:	ea c5 00 80 	sub	r5,r5,128
8000757e:	e0 45 00 7f 	cp.w	r5,127
80007582:	e0 8a 00 25 	brle	800075cc <_malloc_trim_r+0x74>
80007586:	30 0b       	mov	r11,0
80007588:	0e 9c       	mov	r12,r7
8000758a:	fe b0 fd d3 	rcall	80007130 <_sbrk_r>
8000758e:	68 28       	ld.w	r8,r4[0x8]
80007590:	0c 08       	add	r8,r6
80007592:	10 3c       	cp.w	r12,r8
80007594:	c1 c1       	brne	800075cc <_malloc_trim_r+0x74>
80007596:	ea 0b 11 00 	rsub	r11,r5,0
8000759a:	0e 9c       	mov	r12,r7
8000759c:	fe b0 fd ca 	rcall	80007130 <_sbrk_r>
800075a0:	5b fc       	cp.w	r12,-1
800075a2:	c1 91       	brne	800075d4 <_malloc_trim_r+0x7c>
800075a4:	30 0b       	mov	r11,0
800075a6:	0e 9c       	mov	r12,r7
800075a8:	fe b0 fd c4 	rcall	80007130 <_sbrk_r>
800075ac:	68 28       	ld.w	r8,r4[0x8]
800075ae:	f8 08 01 09 	sub	r9,r12,r8
800075b2:	58 f9       	cp.w	r9,15
800075b4:	e0 8a 00 0c 	brle	800075cc <_malloc_trim_r+0x74>
800075b8:	a1 a9       	sbr	r9,0x0
800075ba:	91 19       	st.w	r8[0x4],r9
800075bc:	e0 68 05 28 	mov	r8,1320
800075c0:	70 09       	ld.w	r9,r8[0x0]
800075c2:	e0 68 07 a8 	mov	r8,1960
800075c6:	f8 09 01 09 	sub	r9,r12,r9
800075ca:	91 09       	st.w	r8[0x0],r9
800075cc:	0e 9c       	mov	r12,r7
800075ce:	fe b0 ec 2f 	rcall	80004e2c <__malloc_unlock>
800075d2:	d8 2a       	popm	r4-r7,pc,r12=0
800075d4:	68 28       	ld.w	r8,r4[0x8]
800075d6:	0a 16       	sub	r6,r5
800075d8:	a1 a6       	sbr	r6,0x0
800075da:	91 16       	st.w	r8[0x4],r6
800075dc:	e0 68 07 a8 	mov	r8,1960
800075e0:	70 09       	ld.w	r9,r8[0x0]
800075e2:	0a 19       	sub	r9,r5
800075e4:	0e 9c       	mov	r12,r7
800075e6:	91 09       	st.w	r8[0x0],r9
800075e8:	fe b0 ec 22 	rcall	80004e2c <__malloc_unlock>
800075ec:	da 2a       	popm	r4-r7,pc,r12=1
800075ee:	d7 03       	nop

800075f0 <_free_r>:
800075f0:	d4 21       	pushm	r4-r7,lr
800075f2:	16 96       	mov	r6,r11
800075f4:	18 97       	mov	r7,r12
800075f6:	58 0b       	cp.w	r11,0
800075f8:	e0 80 00 c0 	breq	80007778 <_free_r+0x188>
800075fc:	fe b0 ec 0a 	rcall	80004e10 <__malloc_lock>
80007600:	20 86       	sub	r6,8
80007602:	e0 6a 01 1c 	mov	r10,284
80007606:	6c 18       	ld.w	r8,r6[0x4]
80007608:	74 2e       	ld.w	lr,r10[0x8]
8000760a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000760e:	a1 c8       	cbr	r8,0x0
80007610:	ec 08 00 09 	add	r9,r6,r8
80007614:	72 1b       	ld.w	r11,r9[0x4]
80007616:	e0 1b ff fc 	andl	r11,0xfffc
8000761a:	1c 39       	cp.w	r9,lr
8000761c:	c1 e1       	brne	80007658 <_free_r+0x68>
8000761e:	f6 08 00 08 	add	r8,r11,r8
80007622:	58 0c       	cp.w	r12,0
80007624:	c0 81       	brne	80007634 <_free_r+0x44>
80007626:	6c 09       	ld.w	r9,r6[0x0]
80007628:	12 16       	sub	r6,r9
8000762a:	12 08       	add	r8,r9
8000762c:	6c 3b       	ld.w	r11,r6[0xc]
8000762e:	6c 29       	ld.w	r9,r6[0x8]
80007630:	97 29       	st.w	r11[0x8],r9
80007632:	93 3b       	st.w	r9[0xc],r11
80007634:	10 99       	mov	r9,r8
80007636:	95 26       	st.w	r10[0x8],r6
80007638:	a1 a9       	sbr	r9,0x0
8000763a:	8d 19       	st.w	r6[0x4],r9
8000763c:	e0 69 05 24 	mov	r9,1316
80007640:	72 09       	ld.w	r9,r9[0x0]
80007642:	12 38       	cp.w	r8,r9
80007644:	c0 63       	brcs	80007650 <_free_r+0x60>
80007646:	e0 68 07 a4 	mov	r8,1956
8000764a:	0e 9c       	mov	r12,r7
8000764c:	70 0b       	ld.w	r11,r8[0x0]
8000764e:	c8 5f       	rcall	80007558 <_malloc_trim_r>
80007650:	0e 9c       	mov	r12,r7
80007652:	fe b0 eb ed 	rcall	80004e2c <__malloc_unlock>
80007656:	d8 22       	popm	r4-r7,pc
80007658:	93 1b       	st.w	r9[0x4],r11
8000765a:	58 0c       	cp.w	r12,0
8000765c:	c0 30       	breq	80007662 <_free_r+0x72>
8000765e:	30 0c       	mov	r12,0
80007660:	c1 08       	rjmp	80007680 <_free_r+0x90>
80007662:	6c 0e       	ld.w	lr,r6[0x0]
80007664:	f4 c5 ff f8 	sub	r5,r10,-8
80007668:	1c 16       	sub	r6,lr
8000766a:	1c 08       	add	r8,lr
8000766c:	6c 2e       	ld.w	lr,r6[0x8]
8000766e:	0a 3e       	cp.w	lr,r5
80007670:	f9 bc 00 01 	moveq	r12,1
80007674:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80007678:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000767c:	fd f5 1a 03 	st.wne	lr[0xc],r5
80007680:	f2 0b 00 0e 	add	lr,r9,r11
80007684:	7c 1e       	ld.w	lr,lr[0x4]
80007686:	ed be 00 00 	bld	lr,0x0
8000768a:	c1 40       	breq	800076b2 <_free_r+0xc2>
8000768c:	16 08       	add	r8,r11
8000768e:	58 0c       	cp.w	r12,0
80007690:	c0 d1       	brne	800076aa <_free_r+0xba>
80007692:	e0 6e 01 1c 	mov	lr,284
80007696:	72 2b       	ld.w	r11,r9[0x8]
80007698:	2f 8e       	sub	lr,-8
8000769a:	1c 3b       	cp.w	r11,lr
8000769c:	c0 71       	brne	800076aa <_free_r+0xba>
8000769e:	97 36       	st.w	r11[0xc],r6
800076a0:	97 26       	st.w	r11[0x8],r6
800076a2:	8d 2b       	st.w	r6[0x8],r11
800076a4:	8d 3b       	st.w	r6[0xc],r11
800076a6:	30 1c       	mov	r12,1
800076a8:	c0 58       	rjmp	800076b2 <_free_r+0xc2>
800076aa:	72 2b       	ld.w	r11,r9[0x8]
800076ac:	72 39       	ld.w	r9,r9[0xc]
800076ae:	93 2b       	st.w	r9[0x8],r11
800076b0:	97 39       	st.w	r11[0xc],r9
800076b2:	10 99       	mov	r9,r8
800076b4:	ec 08 09 08 	st.w	r6[r8],r8
800076b8:	a1 a9       	sbr	r9,0x0
800076ba:	8d 19       	st.w	r6[0x4],r9
800076bc:	58 0c       	cp.w	r12,0
800076be:	c5 a1       	brne	80007772 <_free_r+0x182>
800076c0:	e0 48 01 ff 	cp.w	r8,511
800076c4:	e0 8b 00 13 	brhi	800076ea <_free_r+0xfa>
800076c8:	a3 98       	lsr	r8,0x3
800076ca:	f4 08 00 39 	add	r9,r10,r8<<0x3
800076ce:	72 2b       	ld.w	r11,r9[0x8]
800076d0:	8d 39       	st.w	r6[0xc],r9
800076d2:	8d 2b       	st.w	r6[0x8],r11
800076d4:	97 36       	st.w	r11[0xc],r6
800076d6:	93 26       	st.w	r9[0x8],r6
800076d8:	a3 48       	asr	r8,0x2
800076da:	74 19       	ld.w	r9,r10[0x4]
800076dc:	30 1b       	mov	r11,1
800076de:	f6 08 09 48 	lsl	r8,r11,r8
800076e2:	f3 e8 10 08 	or	r8,r9,r8
800076e6:	95 18       	st.w	r10[0x4],r8
800076e8:	c4 58       	rjmp	80007772 <_free_r+0x182>
800076ea:	f0 0b 16 09 	lsr	r11,r8,0x9
800076ee:	58 4b       	cp.w	r11,4
800076f0:	e0 8b 00 06 	brhi	800076fc <_free_r+0x10c>
800076f4:	f0 0b 16 06 	lsr	r11,r8,0x6
800076f8:	2c 8b       	sub	r11,-56
800076fa:	c2 08       	rjmp	8000773a <_free_r+0x14a>
800076fc:	59 4b       	cp.w	r11,20
800076fe:	e0 8b 00 04 	brhi	80007706 <_free_r+0x116>
80007702:	2a 5b       	sub	r11,-91
80007704:	c1 b8       	rjmp	8000773a <_free_r+0x14a>
80007706:	e0 4b 00 54 	cp.w	r11,84
8000770a:	e0 8b 00 06 	brhi	80007716 <_free_r+0x126>
8000770e:	f0 0b 16 0c 	lsr	r11,r8,0xc
80007712:	29 2b       	sub	r11,-110
80007714:	c1 38       	rjmp	8000773a <_free_r+0x14a>
80007716:	e0 4b 01 54 	cp.w	r11,340
8000771a:	e0 8b 00 06 	brhi	80007726 <_free_r+0x136>
8000771e:	f0 0b 16 0f 	lsr	r11,r8,0xf
80007722:	28 9b       	sub	r11,-119
80007724:	c0 b8       	rjmp	8000773a <_free_r+0x14a>
80007726:	e0 4b 05 54 	cp.w	r11,1364
8000772a:	e0 88 00 05 	brls	80007734 <_free_r+0x144>
8000772e:	37 eb       	mov	r11,126
80007730:	c0 58       	rjmp	8000773a <_free_r+0x14a>
80007732:	d7 03       	nop
80007734:	f0 0b 16 12 	lsr	r11,r8,0x12
80007738:	28 4b       	sub	r11,-124
8000773a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000773e:	78 29       	ld.w	r9,r12[0x8]
80007740:	18 39       	cp.w	r9,r12
80007742:	c0 e1       	brne	8000775e <_free_r+0x16e>
80007744:	74 18       	ld.w	r8,r10[0x4]
80007746:	a3 4b       	asr	r11,0x2
80007748:	30 1c       	mov	r12,1
8000774a:	f8 0b 09 4b 	lsl	r11,r12,r11
8000774e:	f1 eb 10 0b 	or	r11,r8,r11
80007752:	12 98       	mov	r8,r9
80007754:	95 1b       	st.w	r10[0x4],r11
80007756:	c0 a8       	rjmp	8000776a <_free_r+0x17a>
80007758:	72 29       	ld.w	r9,r9[0x8]
8000775a:	18 39       	cp.w	r9,r12
8000775c:	c0 60       	breq	80007768 <_free_r+0x178>
8000775e:	72 1a       	ld.w	r10,r9[0x4]
80007760:	e0 1a ff fc 	andl	r10,0xfffc
80007764:	14 38       	cp.w	r8,r10
80007766:	cf 93       	brcs	80007758 <_free_r+0x168>
80007768:	72 38       	ld.w	r8,r9[0xc]
8000776a:	8d 38       	st.w	r6[0xc],r8
8000776c:	8d 29       	st.w	r6[0x8],r9
8000776e:	93 36       	st.w	r9[0xc],r6
80007770:	91 26       	st.w	r8[0x8],r6
80007772:	0e 9c       	mov	r12,r7
80007774:	fe b0 eb 5c 	rcall	80004e2c <__malloc_unlock>
80007778:	d8 22       	popm	r4-r7,pc
8000777a:	d7 03       	nop

8000777c <_fwalk>:
8000777c:	d4 31       	pushm	r0-r7,lr
8000777e:	30 05       	mov	r5,0
80007780:	16 91       	mov	r1,r11
80007782:	f8 c7 ff 28 	sub	r7,r12,-216
80007786:	0a 92       	mov	r2,r5
80007788:	c4 8e       	rcall	80007418 <__sfp_lock_acquire>
8000778a:	3f f3       	mov	r3,-1
8000778c:	c1 68       	rjmp	800077b8 <_fwalk+0x3c>
8000778e:	6e 26       	ld.w	r6,r7[0x8]
80007790:	6e 14       	ld.w	r4,r7[0x4]
80007792:	2f 46       	sub	r6,-12
80007794:	c0 c8       	rjmp	800077ac <_fwalk+0x30>
80007796:	8c 08       	ld.sh	r8,r6[0x0]
80007798:	e4 08 19 00 	cp.h	r8,r2
8000779c:	c0 70       	breq	800077aa <_fwalk+0x2e>
8000779e:	8c 18       	ld.sh	r8,r6[0x2]
800077a0:	e6 08 19 00 	cp.h	r8,r3
800077a4:	c0 30       	breq	800077aa <_fwalk+0x2e>
800077a6:	5d 11       	icall	r1
800077a8:	18 45       	or	r5,r12
800077aa:	2a 46       	sub	r6,-92
800077ac:	20 14       	sub	r4,1
800077ae:	ec cc 00 0c 	sub	r12,r6,12
800077b2:	58 04       	cp.w	r4,0
800077b4:	cf 14       	brge	80007796 <_fwalk+0x1a>
800077b6:	6e 07       	ld.w	r7,r7[0x0]
800077b8:	58 07       	cp.w	r7,0
800077ba:	ce a1       	brne	8000778e <_fwalk+0x12>
800077bc:	c2 fe       	rcall	8000741a <__sfp_lock_release>
800077be:	0a 9c       	mov	r12,r5
800077c0:	d8 32       	popm	r0-r7,pc
800077c2:	d7 03       	nop

800077c4 <memmove>:
800077c4:	d4 01       	pushm	lr
800077c6:	18 3b       	cp.w	r11,r12
800077c8:	c1 92       	brcc	800077fa <memmove+0x36>
800077ca:	f6 0a 00 09 	add	r9,r11,r10
800077ce:	12 3c       	cp.w	r12,r9
800077d0:	c1 52       	brcc	800077fa <memmove+0x36>
800077d2:	f8 0a 00 0b 	add	r11,r12,r10
800077d6:	30 08       	mov	r8,0
800077d8:	c0 68       	rjmp	800077e4 <memmove+0x20>
800077da:	f2 08 07 0e 	ld.ub	lr,r9[r8]
800077de:	20 1a       	sub	r10,1
800077e0:	f6 08 0b 0e 	st.b	r11[r8],lr
800077e4:	20 18       	sub	r8,1
800077e6:	58 0a       	cp.w	r10,0
800077e8:	cf 91       	brne	800077da <memmove+0x16>
800077ea:	d8 02       	popm	pc
800077ec:	f6 08 07 09 	ld.ub	r9,r11[r8]
800077f0:	20 1a       	sub	r10,1
800077f2:	f8 08 0b 09 	st.b	r12[r8],r9
800077f6:	2f f8       	sub	r8,-1
800077f8:	c0 28       	rjmp	800077fc <memmove+0x38>
800077fa:	30 08       	mov	r8,0
800077fc:	58 0a       	cp.w	r10,0
800077fe:	cf 71       	brne	800077ec <memmove+0x28>
80007800:	d8 02       	popm	pc
80007802:	d7 03       	nop

80007804 <__sclose>:
80007804:	d4 01       	pushm	lr
80007806:	96 7b       	ld.sh	r11,r11[0xe]
80007808:	e0 a0 11 e2 	rcall	80009bcc <_close_r>
8000780c:	d8 02       	popm	pc
8000780e:	d7 03       	nop

80007810 <__sseek>:
80007810:	d4 21       	pushm	r4-r7,lr
80007812:	16 97       	mov	r7,r11
80007814:	96 7b       	ld.sh	r11,r11[0xe]
80007816:	e0 a0 1a a5 	rcall	8000ad60 <_lseek_r>
8000781a:	8e 68       	ld.sh	r8,r7[0xc]
8000781c:	10 99       	mov	r9,r8
8000781e:	ad c8       	cbr	r8,0xc
80007820:	ad a9       	sbr	r9,0xc
80007822:	5b fc       	cp.w	r12,-1
80007824:	ef f8 0c 06 	st.heq	r7[0xc],r8
80007828:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000782c:	ef fc 1a 15 	st.wne	r7[0x54],r12
80007830:	d8 22       	popm	r4-r7,pc
80007832:	d7 03       	nop

80007834 <__swrite>:
80007834:	d4 21       	pushm	r4-r7,lr
80007836:	96 68       	ld.sh	r8,r11[0xc]
80007838:	16 97       	mov	r7,r11
8000783a:	14 95       	mov	r5,r10
8000783c:	12 94       	mov	r4,r9
8000783e:	e2 18 01 00 	andl	r8,0x100,COH
80007842:	18 96       	mov	r6,r12
80007844:	c0 60       	breq	80007850 <__swrite+0x1c>
80007846:	30 29       	mov	r9,2
80007848:	30 0a       	mov	r10,0
8000784a:	96 7b       	ld.sh	r11,r11[0xe]
8000784c:	e0 a0 1a 8a 	rcall	8000ad60 <_lseek_r>
80007850:	8e 68       	ld.sh	r8,r7[0xc]
80007852:	ad c8       	cbr	r8,0xc
80007854:	08 99       	mov	r9,r4
80007856:	0a 9a       	mov	r10,r5
80007858:	8e 7b       	ld.sh	r11,r7[0xe]
8000785a:	0c 9c       	mov	r12,r6
8000785c:	ae 68       	st.h	r7[0xc],r8
8000785e:	e0 a0 11 35 	rcall	80009ac8 <_write_r>
80007862:	d8 22       	popm	r4-r7,pc

80007864 <__sread>:
80007864:	d4 21       	pushm	r4-r7,lr
80007866:	16 97       	mov	r7,r11
80007868:	96 7b       	ld.sh	r11,r11[0xe]
8000786a:	e0 a0 1d e3 	rcall	8000b430 <_read_r>
8000786e:	c0 65       	brlt	8000787a <__sread+0x16>
80007870:	6f 58       	ld.w	r8,r7[0x54]
80007872:	18 08       	add	r8,r12
80007874:	ef 48 00 54 	st.w	r7[84],r8
80007878:	d8 22       	popm	r4-r7,pc
8000787a:	8e 68       	ld.sh	r8,r7[0xc]
8000787c:	ad c8       	cbr	r8,0xc
8000787e:	ae 68       	st.h	r7[0xc],r8
80007880:	d8 22       	popm	r4-r7,pc
80007882:	d7 03       	nop

80007884 <get_arg>:
80007884:	d4 31       	pushm	r0-r7,lr
80007886:	20 8d       	sub	sp,32
80007888:	fa c4 ff bc 	sub	r4,sp,-68
8000788c:	50 4b       	stdsp	sp[0x10],r11
8000788e:	68 2e       	ld.w	lr,r4[0x8]
80007890:	50 58       	stdsp	sp[0x14],r8
80007892:	12 96       	mov	r6,r9
80007894:	7c 0b       	ld.w	r11,lr[0x0]
80007896:	70 05       	ld.w	r5,r8[0x0]
80007898:	50 6e       	stdsp	sp[0x18],lr
8000789a:	58 0b       	cp.w	r11,0
8000789c:	f4 0b 17 00 	moveq	r11,r10
800078a0:	68 03       	ld.w	r3,r4[0x0]
800078a2:	68 11       	ld.w	r1,r4[0x4]
800078a4:	40 49       	lddsp	r9,sp[0x10]
800078a6:	30 08       	mov	r8,0
800078a8:	c2 89       	rjmp	80007af8 <get_arg+0x274>
800078aa:	2f fb       	sub	r11,-1
800078ac:	32 5c       	mov	r12,37
800078ae:	17 8a       	ld.ub	r10,r11[0x0]
800078b0:	f8 0a 18 00 	cp.b	r10,r12
800078b4:	5f 1e       	srne	lr
800078b6:	f0 0a 18 00 	cp.b	r10,r8
800078ba:	5f 1c       	srne	r12
800078bc:	fd ec 00 0c 	and	r12,lr,r12
800078c0:	f0 0c 18 00 	cp.b	r12,r8
800078c4:	cf 31       	brne	800078aa <get_arg+0x26>
800078c6:	58 0a       	cp.w	r10,0
800078c8:	e0 80 01 25 	breq	80007b12 <get_arg+0x28e>
800078cc:	30 0c       	mov	r12,0
800078ce:	3f fa       	mov	r10,-1
800078d0:	18 90       	mov	r0,r12
800078d2:	50 3a       	stdsp	sp[0xc],r10
800078d4:	18 94       	mov	r4,r12
800078d6:	18 92       	mov	r2,r12
800078d8:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800078dc:	16 97       	mov	r7,r11
800078de:	50 7c       	stdsp	sp[0x1c],r12
800078e0:	fe cc b0 74 	sub	r12,pc,-20364
800078e4:	0f 3a       	ld.ub	r10,r7++
800078e6:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
800078ea:	40 7c       	lddsp	r12,sp[0x1c]
800078ec:	1c 0c       	add	r12,lr
800078ee:	fe ce b1 4a 	sub	lr,pc,-20150
800078f2:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
800078f6:	20 1e       	sub	lr,1
800078f8:	50 0e       	stdsp	sp[0x0],lr
800078fa:	fe ce b1 c2 	sub	lr,pc,-20030
800078fe:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007902:	50 7c       	stdsp	sp[0x1c],r12
80007904:	40 0c       	lddsp	r12,sp[0x0]
80007906:	58 7c       	cp.w	r12,7
80007908:	e0 8b 00 f1 	brhi	80007aea <get_arg+0x266>
8000790c:	fe ce b3 74 	sub	lr,pc,-19596
80007910:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007914:	36 8b       	mov	r11,104
80007916:	f6 0a 18 00 	cp.b	r10,r11
8000791a:	e0 80 00 e8 	breq	80007aea <get_arg+0x266>
8000791e:	37 1b       	mov	r11,113
80007920:	f6 0a 18 00 	cp.b	r10,r11
80007924:	c0 70       	breq	80007932 <get_arg+0xae>
80007926:	34 cb       	mov	r11,76
80007928:	f6 0a 18 00 	cp.b	r10,r11
8000792c:	c0 51       	brne	80007936 <get_arg+0xb2>
8000792e:	a3 b4       	sbr	r4,0x3
80007930:	cd d8       	rjmp	80007aea <get_arg+0x266>
80007932:	a5 b4       	sbr	r4,0x5
80007934:	cd b8       	rjmp	80007aea <get_arg+0x266>
80007936:	08 9a       	mov	r10,r4
80007938:	0e 9b       	mov	r11,r7
8000793a:	a5 aa       	sbr	r10,0x4
8000793c:	17 3c       	ld.ub	r12,r11++
8000793e:	a5 b4       	sbr	r4,0x5
80007940:	36 ce       	mov	lr,108
80007942:	fc 0c 18 00 	cp.b	r12,lr
80007946:	e0 80 00 d3 	breq	80007aec <get_arg+0x268>
8000794a:	14 94       	mov	r4,r10
8000794c:	cc f8       	rjmp	80007aea <get_arg+0x266>
8000794e:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007952:	36 7c       	mov	r12,103
80007954:	f8 0a 18 00 	cp.b	r10,r12
80007958:	e0 8b 00 27 	brhi	800079a6 <get_arg+0x122>
8000795c:	36 5b       	mov	r11,101
8000795e:	f6 0a 18 00 	cp.b	r10,r11
80007962:	c4 82       	brcc	800079f2 <get_arg+0x16e>
80007964:	34 fb       	mov	r11,79
80007966:	f6 0a 18 00 	cp.b	r10,r11
8000796a:	c4 80       	breq	800079fa <get_arg+0x176>
8000796c:	e0 8b 00 0c 	brhi	80007984 <get_arg+0x100>
80007970:	34 5b       	mov	r11,69
80007972:	f6 0a 18 00 	cp.b	r10,r11
80007976:	c3 e0       	breq	800079f2 <get_arg+0x16e>
80007978:	34 7b       	mov	r11,71
8000797a:	f6 0a 18 00 	cp.b	r10,r11
8000797e:	c3 a0       	breq	800079f2 <get_arg+0x16e>
80007980:	34 4b       	mov	r11,68
80007982:	c0 88       	rjmp	80007992 <get_arg+0x10e>
80007984:	35 8b       	mov	r11,88
80007986:	f6 0a 18 00 	cp.b	r10,r11
8000798a:	c2 c0       	breq	800079e2 <get_arg+0x15e>
8000798c:	e0 8b 00 07 	brhi	8000799a <get_arg+0x116>
80007990:	35 5b       	mov	r11,85
80007992:	f6 0a 18 00 	cp.b	r10,r11
80007996:	c3 51       	brne	80007a00 <get_arg+0x17c>
80007998:	c3 18       	rjmp	800079fa <get_arg+0x176>
8000799a:	36 3b       	mov	r11,99
8000799c:	f6 0a 18 00 	cp.b	r10,r11
800079a0:	c2 f0       	breq	800079fe <get_arg+0x17a>
800079a2:	36 4b       	mov	r11,100
800079a4:	c0 e8       	rjmp	800079c0 <get_arg+0x13c>
800079a6:	37 0b       	mov	r11,112
800079a8:	f6 0a 18 00 	cp.b	r10,r11
800079ac:	c2 50       	breq	800079f6 <get_arg+0x172>
800079ae:	e0 8b 00 0d 	brhi	800079c8 <get_arg+0x144>
800079b2:	36 eb       	mov	r11,110
800079b4:	f6 0a 18 00 	cp.b	r10,r11
800079b8:	c1 f0       	breq	800079f6 <get_arg+0x172>
800079ba:	e0 8b 00 14 	brhi	800079e2 <get_arg+0x15e>
800079be:	36 9b       	mov	r11,105
800079c0:	f6 0a 18 00 	cp.b	r10,r11
800079c4:	c1 e1       	brne	80007a00 <get_arg+0x17c>
800079c6:	c0 e8       	rjmp	800079e2 <get_arg+0x15e>
800079c8:	37 5b       	mov	r11,117
800079ca:	f6 0a 18 00 	cp.b	r10,r11
800079ce:	c0 a0       	breq	800079e2 <get_arg+0x15e>
800079d0:	37 8b       	mov	r11,120
800079d2:	f6 0a 18 00 	cp.b	r10,r11
800079d6:	c0 60       	breq	800079e2 <get_arg+0x15e>
800079d8:	37 3b       	mov	r11,115
800079da:	f6 0a 18 00 	cp.b	r10,r11
800079de:	c1 11       	brne	80007a00 <get_arg+0x17c>
800079e0:	c0 b8       	rjmp	800079f6 <get_arg+0x172>
800079e2:	ed b4 00 04 	bld	r4,0x4
800079e6:	c0 a0       	breq	800079fa <get_arg+0x176>
800079e8:	ed b4 00 05 	bld	r4,0x5
800079ec:	c0 91       	brne	800079fe <get_arg+0x17a>
800079ee:	30 20       	mov	r0,2
800079f0:	c0 88       	rjmp	80007a00 <get_arg+0x17c>
800079f2:	30 40       	mov	r0,4
800079f4:	c0 68       	rjmp	80007a00 <get_arg+0x17c>
800079f6:	30 30       	mov	r0,3
800079f8:	c0 48       	rjmp	80007a00 <get_arg+0x17c>
800079fa:	30 10       	mov	r0,1
800079fc:	c0 28       	rjmp	80007a00 <get_arg+0x17c>
800079fe:	30 00       	mov	r0,0
80007a00:	40 3b       	lddsp	r11,sp[0xc]
80007a02:	5b fb       	cp.w	r11,-1
80007a04:	c0 40       	breq	80007a0c <get_arg+0x188>
80007a06:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007a0a:	c7 08       	rjmp	80007aea <get_arg+0x266>
80007a0c:	58 60       	cp.w	r0,6
80007a0e:	e0 8b 00 6e 	brhi	80007aea <get_arg+0x266>
80007a12:	6c 0a       	ld.w	r10,r6[0x0]
80007a14:	ea cc ff ff 	sub	r12,r5,-1
80007a18:	fe ce b4 60 	sub	lr,pc,-19360
80007a1c:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007a20:	f4 cb ff f8 	sub	r11,r10,-8
80007a24:	8d 0b       	st.w	r6[0x0],r11
80007a26:	f4 ea 00 00 	ld.d	r10,r10[0]
80007a2a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007a2e:	c0 f8       	rjmp	80007a4c <get_arg+0x1c8>
80007a30:	f4 cb ff fc 	sub	r11,r10,-4
80007a34:	8d 0b       	st.w	r6[0x0],r11
80007a36:	74 0a       	ld.w	r10,r10[0x0]
80007a38:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007a3c:	c0 88       	rjmp	80007a4c <get_arg+0x1c8>
80007a3e:	f4 cb ff f8 	sub	r11,r10,-8
80007a42:	8d 0b       	st.w	r6[0x0],r11
80007a44:	f4 ea 00 00 	ld.d	r10,r10[0]
80007a48:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007a4c:	0e 9b       	mov	r11,r7
80007a4e:	18 95       	mov	r5,r12
80007a50:	c4 e8       	rjmp	80007aec <get_arg+0x268>
80007a52:	62 0a       	ld.w	r10,r1[0x0]
80007a54:	5b fa       	cp.w	r10,-1
80007a56:	c0 b1       	brne	80007a6c <get_arg+0x1e8>
80007a58:	50 19       	stdsp	sp[0x4],r9
80007a5a:	50 28       	stdsp	sp[0x8],r8
80007a5c:	e0 6a 00 80 	mov	r10,128
80007a60:	30 0b       	mov	r11,0
80007a62:	02 9c       	mov	r12,r1
80007a64:	fe b0 f9 fe 	rcall	80006e60 <memset>
80007a68:	40 28       	lddsp	r8,sp[0x8]
80007a6a:	40 19       	lddsp	r9,sp[0x4]
80007a6c:	e4 cc 00 01 	sub	r12,r2,1
80007a70:	0e 9b       	mov	r11,r7
80007a72:	50 3c       	stdsp	sp[0xc],r12
80007a74:	f2 0c 0c 49 	max	r9,r9,r12
80007a78:	c3 a8       	rjmp	80007aec <get_arg+0x268>
80007a7a:	62 0a       	ld.w	r10,r1[0x0]
80007a7c:	5b fa       	cp.w	r10,-1
80007a7e:	c0 b1       	brne	80007a94 <get_arg+0x210>
80007a80:	50 19       	stdsp	sp[0x4],r9
80007a82:	50 28       	stdsp	sp[0x8],r8
80007a84:	e0 6a 00 80 	mov	r10,128
80007a88:	30 0b       	mov	r11,0
80007a8a:	02 9c       	mov	r12,r1
80007a8c:	fe b0 f9 ea 	rcall	80006e60 <memset>
80007a90:	40 28       	lddsp	r8,sp[0x8]
80007a92:	40 19       	lddsp	r9,sp[0x4]
80007a94:	20 12       	sub	r2,1
80007a96:	30 0a       	mov	r10,0
80007a98:	0e 9b       	mov	r11,r7
80007a9a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007a9e:	f2 02 0c 49 	max	r9,r9,r2
80007aa2:	c2 58       	rjmp	80007aec <get_arg+0x268>
80007aa4:	16 97       	mov	r7,r11
80007aa6:	6c 0a       	ld.w	r10,r6[0x0]
80007aa8:	f4 cb ff fc 	sub	r11,r10,-4
80007aac:	8d 0b       	st.w	r6[0x0],r11
80007aae:	74 0a       	ld.w	r10,r10[0x0]
80007ab0:	0e 9b       	mov	r11,r7
80007ab2:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007ab6:	2f f5       	sub	r5,-1
80007ab8:	c1 a8       	rjmp	80007aec <get_arg+0x268>
80007aba:	f4 c2 00 30 	sub	r2,r10,48
80007abe:	c0 68       	rjmp	80007aca <get_arg+0x246>
80007ac0:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007ac4:	2f f7       	sub	r7,-1
80007ac6:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007aca:	0f 8a       	ld.ub	r10,r7[0x0]
80007acc:	58 0a       	cp.w	r10,0
80007ace:	c0 e0       	breq	80007aea <get_arg+0x266>
80007ad0:	23 0a       	sub	r10,48
80007ad2:	58 9a       	cp.w	r10,9
80007ad4:	fe 98 ff f6 	brls	80007ac0 <get_arg+0x23c>
80007ad8:	c0 98       	rjmp	80007aea <get_arg+0x266>
80007ada:	2f f7       	sub	r7,-1
80007adc:	0f 8a       	ld.ub	r10,r7[0x0]
80007ade:	58 0a       	cp.w	r10,0
80007ae0:	c0 50       	breq	80007aea <get_arg+0x266>
80007ae2:	23 0a       	sub	r10,48
80007ae4:	58 9a       	cp.w	r10,9
80007ae6:	fe 98 ff fa 	brls	80007ada <get_arg+0x256>
80007aea:	0e 9b       	mov	r11,r7
80007aec:	40 7c       	lddsp	r12,sp[0x1c]
80007aee:	30 ba       	mov	r10,11
80007af0:	f4 0c 18 00 	cp.b	r12,r10
80007af4:	fe 91 fe f2 	brne	800078d8 <get_arg+0x54>
80007af8:	40 42       	lddsp	r2,sp[0x10]
80007afa:	17 8c       	ld.ub	r12,r11[0x0]
80007afc:	0a 32       	cp.w	r2,r5
80007afe:	5f 4a       	srge	r10
80007b00:	f0 0c 18 00 	cp.b	r12,r8
80007b04:	5f 1c       	srne	r12
80007b06:	f9 ea 00 0a 	and	r10,r12,r10
80007b0a:	f0 0a 18 00 	cp.b	r10,r8
80007b0e:	fe 91 fe cf 	brne	800078ac <get_arg+0x28>
80007b12:	30 08       	mov	r8,0
80007b14:	40 4e       	lddsp	lr,sp[0x10]
80007b16:	17 8a       	ld.ub	r10,r11[0x0]
80007b18:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007b1c:	f0 0a 18 00 	cp.b	r10,r8
80007b20:	fc 09 17 10 	movne	r9,lr
80007b24:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007b28:	06 9e       	mov	lr,r3
80007b2a:	c2 a8       	rjmp	80007b7e <get_arg+0x2fa>
80007b2c:	62 0a       	ld.w	r10,r1[0x0]
80007b2e:	58 3a       	cp.w	r10,3
80007b30:	c1 e0       	breq	80007b6c <get_arg+0x2e8>
80007b32:	e0 89 00 07 	brgt	80007b40 <get_arg+0x2bc>
80007b36:	58 1a       	cp.w	r10,1
80007b38:	c1 a0       	breq	80007b6c <get_arg+0x2e8>
80007b3a:	58 2a       	cp.w	r10,2
80007b3c:	c1 81       	brne	80007b6c <get_arg+0x2e8>
80007b3e:	c0 58       	rjmp	80007b48 <get_arg+0x2c4>
80007b40:	58 5a       	cp.w	r10,5
80007b42:	c0 c0       	breq	80007b5a <get_arg+0x2d6>
80007b44:	c0 b5       	brlt	80007b5a <get_arg+0x2d6>
80007b46:	c1 38       	rjmp	80007b6c <get_arg+0x2e8>
80007b48:	6c 0a       	ld.w	r10,r6[0x0]
80007b4a:	f4 cc ff f8 	sub	r12,r10,-8
80007b4e:	8d 0c       	st.w	r6[0x0],r12
80007b50:	f4 e2 00 00 	ld.d	r2,r10[0]
80007b54:	f0 e3 00 00 	st.d	r8[0],r2
80007b58:	c1 08       	rjmp	80007b78 <get_arg+0x2f4>
80007b5a:	6c 0a       	ld.w	r10,r6[0x0]
80007b5c:	f4 cc ff f8 	sub	r12,r10,-8
80007b60:	8d 0c       	st.w	r6[0x0],r12
80007b62:	f4 e2 00 00 	ld.d	r2,r10[0]
80007b66:	f0 e3 00 00 	st.d	r8[0],r2
80007b6a:	c0 78       	rjmp	80007b78 <get_arg+0x2f4>
80007b6c:	6c 0a       	ld.w	r10,r6[0x0]
80007b6e:	f4 cc ff fc 	sub	r12,r10,-4
80007b72:	8d 0c       	st.w	r6[0x0],r12
80007b74:	74 0a       	ld.w	r10,r10[0x0]
80007b76:	91 0a       	st.w	r8[0x0],r10
80007b78:	2f f5       	sub	r5,-1
80007b7a:	2f 88       	sub	r8,-8
80007b7c:	2f c1       	sub	r1,-4
80007b7e:	12 35       	cp.w	r5,r9
80007b80:	fe 9a ff d6 	brle	80007b2c <get_arg+0x2a8>
80007b84:	1c 93       	mov	r3,lr
80007b86:	40 52       	lddsp	r2,sp[0x14]
80007b88:	40 6e       	lddsp	lr,sp[0x18]
80007b8a:	85 05       	st.w	r2[0x0],r5
80007b8c:	9d 0b       	st.w	lr[0x0],r11
80007b8e:	40 4b       	lddsp	r11,sp[0x10]
80007b90:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007b94:	2f 8d       	sub	sp,-32
80007b96:	d8 32       	popm	r0-r7,pc

80007b98 <__sprint_r>:
80007b98:	d4 21       	pushm	r4-r7,lr
80007b9a:	14 97       	mov	r7,r10
80007b9c:	74 28       	ld.w	r8,r10[0x8]
80007b9e:	58 08       	cp.w	r8,0
80007ba0:	c0 41       	brne	80007ba8 <__sprint_r+0x10>
80007ba2:	95 18       	st.w	r10[0x4],r8
80007ba4:	10 9c       	mov	r12,r8
80007ba6:	d8 22       	popm	r4-r7,pc
80007ba8:	e0 a0 17 8a 	rcall	8000aabc <__sfvwrite_r>
80007bac:	30 08       	mov	r8,0
80007bae:	8f 18       	st.w	r7[0x4],r8
80007bb0:	8f 28       	st.w	r7[0x8],r8
80007bb2:	d8 22       	popm	r4-r7,pc

80007bb4 <_vfprintf_r>:
80007bb4:	d4 31       	pushm	r0-r7,lr
80007bb6:	fa cd 06 bc 	sub	sp,sp,1724
80007bba:	51 09       	stdsp	sp[0x40],r9
80007bbc:	16 91       	mov	r1,r11
80007bbe:	14 97       	mov	r7,r10
80007bc0:	18 95       	mov	r5,r12
80007bc2:	e0 a0 18 cb 	rcall	8000ad58 <_localeconv_r>
80007bc6:	78 0c       	ld.w	r12,r12[0x0]
80007bc8:	50 cc       	stdsp	sp[0x30],r12
80007bca:	58 05       	cp.w	r5,0
80007bcc:	c0 70       	breq	80007bda <_vfprintf_r+0x26>
80007bce:	6a 68       	ld.w	r8,r5[0x18]
80007bd0:	58 08       	cp.w	r8,0
80007bd2:	c0 41       	brne	80007bda <_vfprintf_r+0x26>
80007bd4:	0a 9c       	mov	r12,r5
80007bd6:	fe b0 fc 73 	rcall	800074bc <__sinit>
80007bda:	fe c8 b6 a2 	sub	r8,pc,-18782
80007bde:	10 31       	cp.w	r1,r8
80007be0:	c0 31       	brne	80007be6 <_vfprintf_r+0x32>
80007be2:	6a 01       	ld.w	r1,r5[0x0]
80007be4:	c0 c8       	rjmp	80007bfc <_vfprintf_r+0x48>
80007be6:	fe c8 b6 8e 	sub	r8,pc,-18802
80007bea:	10 31       	cp.w	r1,r8
80007bec:	c0 31       	brne	80007bf2 <_vfprintf_r+0x3e>
80007bee:	6a 11       	ld.w	r1,r5[0x4]
80007bf0:	c0 68       	rjmp	80007bfc <_vfprintf_r+0x48>
80007bf2:	fe c8 b6 7a 	sub	r8,pc,-18822
80007bf6:	10 31       	cp.w	r1,r8
80007bf8:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007bfc:	82 68       	ld.sh	r8,r1[0xc]
80007bfe:	ed b8 00 03 	bld	r8,0x3
80007c02:	c0 41       	brne	80007c0a <_vfprintf_r+0x56>
80007c04:	62 48       	ld.w	r8,r1[0x10]
80007c06:	58 08       	cp.w	r8,0
80007c08:	c0 71       	brne	80007c16 <_vfprintf_r+0x62>
80007c0a:	02 9b       	mov	r11,r1
80007c0c:	0a 9c       	mov	r12,r5
80007c0e:	e0 a0 0f 71 	rcall	80009af0 <__swsetup_r>
80007c12:	e0 81 0f 54 	brne	80009aba <_vfprintf_r+0x1f06>
80007c16:	82 68       	ld.sh	r8,r1[0xc]
80007c18:	10 99       	mov	r9,r8
80007c1a:	e2 19 00 1a 	andl	r9,0x1a,COH
80007c1e:	58 a9       	cp.w	r9,10
80007c20:	c3 c1       	brne	80007c98 <_vfprintf_r+0xe4>
80007c22:	82 79       	ld.sh	r9,r1[0xe]
80007c24:	30 0a       	mov	r10,0
80007c26:	f4 09 19 00 	cp.h	r9,r10
80007c2a:	c3 75       	brlt	80007c98 <_vfprintf_r+0xe4>
80007c2c:	a1 d8       	cbr	r8,0x1
80007c2e:	fb 58 05 d0 	st.h	sp[1488],r8
80007c32:	62 88       	ld.w	r8,r1[0x20]
80007c34:	fb 48 05 e4 	st.w	sp[1508],r8
80007c38:	62 a8       	ld.w	r8,r1[0x28]
80007c3a:	fb 48 05 ec 	st.w	sp[1516],r8
80007c3e:	fa c8 ff bc 	sub	r8,sp,-68
80007c42:	fb 48 05 d4 	st.w	sp[1492],r8
80007c46:	fb 48 05 c4 	st.w	sp[1476],r8
80007c4a:	e0 68 04 00 	mov	r8,1024
80007c4e:	fb 48 05 d8 	st.w	sp[1496],r8
80007c52:	fb 48 05 cc 	st.w	sp[1484],r8
80007c56:	30 08       	mov	r8,0
80007c58:	fb 59 05 d2 	st.h	sp[1490],r9
80007c5c:	0e 9a       	mov	r10,r7
80007c5e:	41 09       	lddsp	r9,sp[0x40]
80007c60:	fa c7 fa 3c 	sub	r7,sp,-1476
80007c64:	fb 48 05 dc 	st.w	sp[1500],r8
80007c68:	0a 9c       	mov	r12,r5
80007c6a:	0e 9b       	mov	r11,r7
80007c6c:	ca 4f       	rcall	80007bb4 <_vfprintf_r>
80007c6e:	50 bc       	stdsp	sp[0x2c],r12
80007c70:	c0 95       	brlt	80007c82 <_vfprintf_r+0xce>
80007c72:	0e 9b       	mov	r11,r7
80007c74:	0a 9c       	mov	r12,r5
80007c76:	e0 a0 16 9b 	rcall	8000a9ac <_fflush_r>
80007c7a:	40 be       	lddsp	lr,sp[0x2c]
80007c7c:	f9 be 01 ff 	movne	lr,-1
80007c80:	50 be       	stdsp	sp[0x2c],lr
80007c82:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007c86:	ed b8 00 06 	bld	r8,0x6
80007c8a:	e0 81 0f 1a 	brne	80009abe <_vfprintf_r+0x1f0a>
80007c8e:	82 68       	ld.sh	r8,r1[0xc]
80007c90:	a7 a8       	sbr	r8,0x6
80007c92:	a2 68       	st.h	r1[0xc],r8
80007c94:	e0 8f 0f 15 	bral	80009abe <_vfprintf_r+0x1f0a>
80007c98:	30 08       	mov	r8,0
80007c9a:	fb 48 06 b4 	st.w	sp[1716],r8
80007c9e:	fb 48 06 90 	st.w	sp[1680],r8
80007ca2:	fb 48 06 8c 	st.w	sp[1676],r8
80007ca6:	fb 48 06 b0 	st.w	sp[1712],r8
80007caa:	30 08       	mov	r8,0
80007cac:	30 09       	mov	r9,0
80007cae:	50 a7       	stdsp	sp[0x28],r7
80007cb0:	50 78       	stdsp	sp[0x1c],r8
80007cb2:	fa c3 f9 e0 	sub	r3,sp,-1568
80007cb6:	3f f8       	mov	r8,-1
80007cb8:	50 59       	stdsp	sp[0x14],r9
80007cba:	fb 43 06 88 	st.w	sp[1672],r3
80007cbe:	fb 48 05 44 	st.w	sp[1348],r8
80007cc2:	12 9c       	mov	r12,r9
80007cc4:	50 69       	stdsp	sp[0x18],r9
80007cc6:	50 d9       	stdsp	sp[0x34],r9
80007cc8:	50 e9       	stdsp	sp[0x38],r9
80007cca:	50 b9       	stdsp	sp[0x2c],r9
80007ccc:	12 97       	mov	r7,r9
80007cce:	0a 94       	mov	r4,r5
80007cd0:	40 a2       	lddsp	r2,sp[0x28]
80007cd2:	32 5a       	mov	r10,37
80007cd4:	30 08       	mov	r8,0
80007cd6:	c0 28       	rjmp	80007cda <_vfprintf_r+0x126>
80007cd8:	2f f2       	sub	r2,-1
80007cda:	05 89       	ld.ub	r9,r2[0x0]
80007cdc:	f0 09 18 00 	cp.b	r9,r8
80007ce0:	5f 1b       	srne	r11
80007ce2:	f4 09 18 00 	cp.b	r9,r10
80007ce6:	5f 19       	srne	r9
80007ce8:	f3 eb 00 0b 	and	r11,r9,r11
80007cec:	f0 0b 18 00 	cp.b	r11,r8
80007cf0:	cf 41       	brne	80007cd8 <_vfprintf_r+0x124>
80007cf2:	40 ab       	lddsp	r11,sp[0x28]
80007cf4:	e4 0b 01 06 	sub	r6,r2,r11
80007cf8:	c1 e0       	breq	80007d34 <_vfprintf_r+0x180>
80007cfa:	fa f8 06 90 	ld.w	r8,sp[1680]
80007cfe:	0c 08       	add	r8,r6
80007d00:	87 0b       	st.w	r3[0x0],r11
80007d02:	fb 48 06 90 	st.w	sp[1680],r8
80007d06:	87 16       	st.w	r3[0x4],r6
80007d08:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007d0c:	2f f8       	sub	r8,-1
80007d0e:	fb 48 06 8c 	st.w	sp[1676],r8
80007d12:	58 78       	cp.w	r8,7
80007d14:	e0 89 00 04 	brgt	80007d1c <_vfprintf_r+0x168>
80007d18:	2f 83       	sub	r3,-8
80007d1a:	c0 a8       	rjmp	80007d2e <_vfprintf_r+0x17a>
80007d1c:	fa ca f9 78 	sub	r10,sp,-1672
80007d20:	02 9b       	mov	r11,r1
80007d22:	08 9c       	mov	r12,r4
80007d24:	c3 af       	rcall	80007b98 <__sprint_r>
80007d26:	e0 81 0e c6 	brne	80009ab2 <_vfprintf_r+0x1efe>
80007d2a:	fa c3 f9 e0 	sub	r3,sp,-1568
80007d2e:	40 ba       	lddsp	r10,sp[0x2c]
80007d30:	0c 0a       	add	r10,r6
80007d32:	50 ba       	stdsp	sp[0x2c],r10
80007d34:	05 89       	ld.ub	r9,r2[0x0]
80007d36:	30 08       	mov	r8,0
80007d38:	f0 09 18 00 	cp.b	r9,r8
80007d3c:	e0 80 0e aa 	breq	80009a90 <_vfprintf_r+0x1edc>
80007d40:	30 09       	mov	r9,0
80007d42:	fb 68 06 bb 	st.b	sp[1723],r8
80007d46:	0e 96       	mov	r6,r7
80007d48:	e4 c8 ff ff 	sub	r8,r2,-1
80007d4c:	3f fe       	mov	lr,-1
80007d4e:	50 93       	stdsp	sp[0x24],r3
80007d50:	50 41       	stdsp	sp[0x10],r1
80007d52:	0e 93       	mov	r3,r7
80007d54:	04 91       	mov	r1,r2
80007d56:	50 89       	stdsp	sp[0x20],r9
80007d58:	50 a8       	stdsp	sp[0x28],r8
80007d5a:	50 2e       	stdsp	sp[0x8],lr
80007d5c:	50 39       	stdsp	sp[0xc],r9
80007d5e:	12 95       	mov	r5,r9
80007d60:	12 90       	mov	r0,r9
80007d62:	10 97       	mov	r7,r8
80007d64:	08 92       	mov	r2,r4
80007d66:	c0 78       	rjmp	80007d74 <_vfprintf_r+0x1c0>
80007d68:	3f fc       	mov	r12,-1
80007d6a:	08 97       	mov	r7,r4
80007d6c:	50 2c       	stdsp	sp[0x8],r12
80007d6e:	c0 38       	rjmp	80007d74 <_vfprintf_r+0x1c0>
80007d70:	30 0b       	mov	r11,0
80007d72:	50 3b       	stdsp	sp[0xc],r11
80007d74:	0f 38       	ld.ub	r8,r7++
80007d76:	c0 28       	rjmp	80007d7a <_vfprintf_r+0x1c6>
80007d78:	12 90       	mov	r0,r9
80007d7a:	f0 c9 00 20 	sub	r9,r8,32
80007d7e:	e0 49 00 58 	cp.w	r9,88
80007d82:	e0 8b 0a 30 	brhi	800091e2 <_vfprintf_r+0x162e>
80007d86:	fe ca b7 b2 	sub	r10,pc,-18510
80007d8a:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007d8e:	50 a7       	stdsp	sp[0x28],r7
80007d90:	50 80       	stdsp	sp[0x20],r0
80007d92:	0c 97       	mov	r7,r6
80007d94:	04 94       	mov	r4,r2
80007d96:	06 96       	mov	r6,r3
80007d98:	02 92       	mov	r2,r1
80007d9a:	fe c9 b5 8a 	sub	r9,pc,-19062
80007d9e:	40 93       	lddsp	r3,sp[0x24]
80007da0:	10 90       	mov	r0,r8
80007da2:	40 41       	lddsp	r1,sp[0x10]
80007da4:	50 d9       	stdsp	sp[0x34],r9
80007da6:	e0 8f 08 8e 	bral	80008ec2 <_vfprintf_r+0x130e>
80007daa:	30 08       	mov	r8,0
80007dac:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007db0:	f0 09 18 00 	cp.b	r9,r8
80007db4:	ce 01       	brne	80007d74 <_vfprintf_r+0x1c0>
80007db6:	32 08       	mov	r8,32
80007db8:	c6 e8       	rjmp	80007e94 <_vfprintf_r+0x2e0>
80007dba:	a1 a5       	sbr	r5,0x0
80007dbc:	cd cb       	rjmp	80007d74 <_vfprintf_r+0x1c0>
80007dbe:	0f 89       	ld.ub	r9,r7[0x0]
80007dc0:	f2 c8 00 30 	sub	r8,r9,48
80007dc4:	58 98       	cp.w	r8,9
80007dc6:	e0 8b 00 1d 	brhi	80007e00 <_vfprintf_r+0x24c>
80007dca:	ee c8 ff ff 	sub	r8,r7,-1
80007dce:	30 0b       	mov	r11,0
80007dd0:	23 09       	sub	r9,48
80007dd2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007dd6:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007dda:	11 39       	ld.ub	r9,r8++
80007ddc:	f2 ca 00 30 	sub	r10,r9,48
80007de0:	58 9a       	cp.w	r10,9
80007de2:	fe 98 ff f7 	brls	80007dd0 <_vfprintf_r+0x21c>
80007de6:	e0 49 00 24 	cp.w	r9,36
80007dea:	cc 31       	brne	80007d70 <_vfprintf_r+0x1bc>
80007dec:	e0 4b 00 20 	cp.w	r11,32
80007df0:	e0 89 0e 60 	brgt	80009ab0 <_vfprintf_r+0x1efc>
80007df4:	20 1b       	sub	r11,1
80007df6:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007dfa:	12 3b       	cp.w	r11,r9
80007dfc:	c0 95       	brlt	80007e0e <_vfprintf_r+0x25a>
80007dfe:	c1 08       	rjmp	80007e1e <_vfprintf_r+0x26a>
80007e00:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007e04:	ec ca ff ff 	sub	r10,r6,-1
80007e08:	12 36       	cp.w	r6,r9
80007e0a:	c1 f5       	brlt	80007e48 <_vfprintf_r+0x294>
80007e0c:	c2 68       	rjmp	80007e58 <_vfprintf_r+0x2a4>
80007e0e:	fa ce f9 44 	sub	lr,sp,-1724
80007e12:	10 97       	mov	r7,r8
80007e14:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007e18:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007e1c:	c3 58       	rjmp	80007e86 <_vfprintf_r+0x2d2>
80007e1e:	10 97       	mov	r7,r8
80007e20:	fa c8 f9 50 	sub	r8,sp,-1712
80007e24:	1a d8       	st.w	--sp,r8
80007e26:	fa c8 fa b8 	sub	r8,sp,-1352
80007e2a:	1a d8       	st.w	--sp,r8
80007e2c:	fa c8 fb b4 	sub	r8,sp,-1100
80007e30:	02 9a       	mov	r10,r1
80007e32:	1a d8       	st.w	--sp,r8
80007e34:	04 9c       	mov	r12,r2
80007e36:	fa c8 f9 40 	sub	r8,sp,-1728
80007e3a:	fa c9 ff b4 	sub	r9,sp,-76
80007e3e:	fe b0 fd 23 	rcall	80007884 <get_arg>
80007e42:	2f dd       	sub	sp,-12
80007e44:	78 00       	ld.w	r0,r12[0x0]
80007e46:	c2 08       	rjmp	80007e86 <_vfprintf_r+0x2d2>
80007e48:	fa cc f9 44 	sub	r12,sp,-1724
80007e4c:	14 96       	mov	r6,r10
80007e4e:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007e52:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007e56:	c1 88       	rjmp	80007e86 <_vfprintf_r+0x2d2>
80007e58:	41 08       	lddsp	r8,sp[0x40]
80007e5a:	59 f9       	cp.w	r9,31
80007e5c:	e0 89 00 11 	brgt	80007e7e <_vfprintf_r+0x2ca>
80007e60:	f0 cb ff fc 	sub	r11,r8,-4
80007e64:	51 0b       	stdsp	sp[0x40],r11
80007e66:	70 00       	ld.w	r0,r8[0x0]
80007e68:	fa cb f9 44 	sub	r11,sp,-1724
80007e6c:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007e70:	f1 40 fd 88 	st.w	r8[-632],r0
80007e74:	2f f9       	sub	r9,-1
80007e76:	14 96       	mov	r6,r10
80007e78:	fb 49 06 b4 	st.w	sp[1716],r9
80007e7c:	c0 58       	rjmp	80007e86 <_vfprintf_r+0x2d2>
80007e7e:	70 00       	ld.w	r0,r8[0x0]
80007e80:	14 96       	mov	r6,r10
80007e82:	2f c8       	sub	r8,-4
80007e84:	51 08       	stdsp	sp[0x40],r8
80007e86:	58 00       	cp.w	r0,0
80007e88:	fe 94 ff 76 	brge	80007d74 <_vfprintf_r+0x1c0>
80007e8c:	5c 30       	neg	r0
80007e8e:	a3 a5       	sbr	r5,0x2
80007e90:	c7 2b       	rjmp	80007d74 <_vfprintf_r+0x1c0>
80007e92:	32 b8       	mov	r8,43
80007e94:	fb 68 06 bb 	st.b	sp[1723],r8
80007e98:	c6 eb       	rjmp	80007d74 <_vfprintf_r+0x1c0>
80007e9a:	0f 38       	ld.ub	r8,r7++
80007e9c:	e0 48 00 2a 	cp.w	r8,42
80007ea0:	c0 30       	breq	80007ea6 <_vfprintf_r+0x2f2>
80007ea2:	30 09       	mov	r9,0
80007ea4:	c7 98       	rjmp	80007f96 <_vfprintf_r+0x3e2>
80007ea6:	0f 88       	ld.ub	r8,r7[0x0]
80007ea8:	f0 c9 00 30 	sub	r9,r8,48
80007eac:	58 99       	cp.w	r9,9
80007eae:	e0 8b 00 1f 	brhi	80007eec <_vfprintf_r+0x338>
80007eb2:	ee c4 ff ff 	sub	r4,r7,-1
80007eb6:	30 0b       	mov	r11,0
80007eb8:	23 08       	sub	r8,48
80007eba:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007ebe:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007ec2:	09 38       	ld.ub	r8,r4++
80007ec4:	f0 c9 00 30 	sub	r9,r8,48
80007ec8:	58 99       	cp.w	r9,9
80007eca:	fe 98 ff f7 	brls	80007eb8 <_vfprintf_r+0x304>
80007ece:	e0 48 00 24 	cp.w	r8,36
80007ed2:	fe 91 ff 4f 	brne	80007d70 <_vfprintf_r+0x1bc>
80007ed6:	e0 4b 00 20 	cp.w	r11,32
80007eda:	e0 89 0d eb 	brgt	80009ab0 <_vfprintf_r+0x1efc>
80007ede:	20 1b       	sub	r11,1
80007ee0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ee4:	10 3b       	cp.w	r11,r8
80007ee6:	c0 a5       	brlt	80007efa <_vfprintf_r+0x346>
80007ee8:	c1 18       	rjmp	80007f0a <_vfprintf_r+0x356>
80007eea:	d7 03       	nop
80007eec:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007ef0:	ec c9 ff ff 	sub	r9,r6,-1
80007ef4:	14 36       	cp.w	r6,r10
80007ef6:	c1 f5       	brlt	80007f34 <_vfprintf_r+0x380>
80007ef8:	c2 88       	rjmp	80007f48 <_vfprintf_r+0x394>
80007efa:	fa ca f9 44 	sub	r10,sp,-1724
80007efe:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007f02:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007f06:	50 2b       	stdsp	sp[0x8],r11
80007f08:	c3 c8       	rjmp	80007f80 <_vfprintf_r+0x3cc>
80007f0a:	fa c8 f9 50 	sub	r8,sp,-1712
80007f0e:	1a d8       	st.w	--sp,r8
80007f10:	fa c8 fa b8 	sub	r8,sp,-1352
80007f14:	1a d8       	st.w	--sp,r8
80007f16:	fa c8 fb b4 	sub	r8,sp,-1100
80007f1a:	02 9a       	mov	r10,r1
80007f1c:	1a d8       	st.w	--sp,r8
80007f1e:	04 9c       	mov	r12,r2
80007f20:	fa c8 f9 40 	sub	r8,sp,-1728
80007f24:	fa c9 ff b4 	sub	r9,sp,-76
80007f28:	fe b0 fc ae 	rcall	80007884 <get_arg>
80007f2c:	2f dd       	sub	sp,-12
80007f2e:	78 0c       	ld.w	r12,r12[0x0]
80007f30:	50 2c       	stdsp	sp[0x8],r12
80007f32:	c2 78       	rjmp	80007f80 <_vfprintf_r+0x3cc>
80007f34:	12 96       	mov	r6,r9
80007f36:	0e 94       	mov	r4,r7
80007f38:	fa c9 f9 44 	sub	r9,sp,-1724
80007f3c:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007f40:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007f44:	50 28       	stdsp	sp[0x8],r8
80007f46:	c1 d8       	rjmp	80007f80 <_vfprintf_r+0x3cc>
80007f48:	41 08       	lddsp	r8,sp[0x40]
80007f4a:	59 fa       	cp.w	r10,31
80007f4c:	e0 89 00 14 	brgt	80007f74 <_vfprintf_r+0x3c0>
80007f50:	f0 cb ff fc 	sub	r11,r8,-4
80007f54:	70 08       	ld.w	r8,r8[0x0]
80007f56:	51 0b       	stdsp	sp[0x40],r11
80007f58:	50 28       	stdsp	sp[0x8],r8
80007f5a:	fa c6 f9 44 	sub	r6,sp,-1724
80007f5e:	40 2e       	lddsp	lr,sp[0x8]
80007f60:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007f64:	f1 4e fd 88 	st.w	r8[-632],lr
80007f68:	2f fa       	sub	r10,-1
80007f6a:	0e 94       	mov	r4,r7
80007f6c:	fb 4a 06 b4 	st.w	sp[1716],r10
80007f70:	12 96       	mov	r6,r9
80007f72:	c0 78       	rjmp	80007f80 <_vfprintf_r+0x3cc>
80007f74:	70 0c       	ld.w	r12,r8[0x0]
80007f76:	0e 94       	mov	r4,r7
80007f78:	2f c8       	sub	r8,-4
80007f7a:	50 2c       	stdsp	sp[0x8],r12
80007f7c:	12 96       	mov	r6,r9
80007f7e:	51 08       	stdsp	sp[0x40],r8
80007f80:	40 2b       	lddsp	r11,sp[0x8]
80007f82:	58 0b       	cp.w	r11,0
80007f84:	fe 95 fe f2 	brlt	80007d68 <_vfprintf_r+0x1b4>
80007f88:	08 97       	mov	r7,r4
80007f8a:	cf 5a       	rjmp	80007d74 <_vfprintf_r+0x1c0>
80007f8c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007f90:	0f 38       	ld.ub	r8,r7++
80007f92:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007f96:	f0 ca 00 30 	sub	r10,r8,48
80007f9a:	58 9a       	cp.w	r10,9
80007f9c:	fe 98 ff f8 	brls	80007f8c <_vfprintf_r+0x3d8>
80007fa0:	3f fa       	mov	r10,-1
80007fa2:	f2 0a 0c 49 	max	r9,r9,r10
80007fa6:	50 29       	stdsp	sp[0x8],r9
80007fa8:	ce 9a       	rjmp	80007d7a <_vfprintf_r+0x1c6>
80007faa:	a7 b5       	sbr	r5,0x7
80007fac:	ce 4a       	rjmp	80007d74 <_vfprintf_r+0x1c0>
80007fae:	30 09       	mov	r9,0
80007fb0:	23 08       	sub	r8,48
80007fb2:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007fb6:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007fba:	0f 38       	ld.ub	r8,r7++
80007fbc:	f0 ca 00 30 	sub	r10,r8,48
80007fc0:	58 9a       	cp.w	r10,9
80007fc2:	fe 98 ff f7 	brls	80007fb0 <_vfprintf_r+0x3fc>
80007fc6:	e0 48 00 24 	cp.w	r8,36
80007fca:	fe 91 fe d7 	brne	80007d78 <_vfprintf_r+0x1c4>
80007fce:	e0 49 00 20 	cp.w	r9,32
80007fd2:	e0 89 0d 6f 	brgt	80009ab0 <_vfprintf_r+0x1efc>
80007fd6:	f2 c3 00 01 	sub	r3,r9,1
80007fda:	30 19       	mov	r9,1
80007fdc:	50 39       	stdsp	sp[0xc],r9
80007fde:	cc ba       	rjmp	80007d74 <_vfprintf_r+0x1c0>
80007fe0:	a3 b5       	sbr	r5,0x3
80007fe2:	cc 9a       	rjmp	80007d74 <_vfprintf_r+0x1c0>
80007fe4:	a7 a5       	sbr	r5,0x6
80007fe6:	cc 7a       	rjmp	80007d74 <_vfprintf_r+0x1c0>
80007fe8:	0a 98       	mov	r8,r5
80007fea:	a5 b5       	sbr	r5,0x5
80007fec:	a5 a8       	sbr	r8,0x4
80007fee:	0f 89       	ld.ub	r9,r7[0x0]
80007ff0:	36 ce       	mov	lr,108
80007ff2:	fc 09 18 00 	cp.b	r9,lr
80007ff6:	f7 b7 00 ff 	subeq	r7,-1
80007ffa:	f0 05 17 10 	movne	r5,r8
80007ffe:	cb ba       	rjmp	80007d74 <_vfprintf_r+0x1c0>
80008000:	a5 b5       	sbr	r5,0x5
80008002:	cb 9a       	rjmp	80007d74 <_vfprintf_r+0x1c0>
80008004:	50 a7       	stdsp	sp[0x28],r7
80008006:	50 80       	stdsp	sp[0x20],r0
80008008:	0c 97       	mov	r7,r6
8000800a:	10 90       	mov	r0,r8
8000800c:	06 96       	mov	r6,r3
8000800e:	04 94       	mov	r4,r2
80008010:	40 93       	lddsp	r3,sp[0x24]
80008012:	02 92       	mov	r2,r1
80008014:	0e 99       	mov	r9,r7
80008016:	40 41       	lddsp	r1,sp[0x10]
80008018:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000801c:	40 3c       	lddsp	r12,sp[0xc]
8000801e:	58 0c       	cp.w	r12,0
80008020:	c1 d0       	breq	8000805a <_vfprintf_r+0x4a6>
80008022:	10 36       	cp.w	r6,r8
80008024:	c0 64       	brge	80008030 <_vfprintf_r+0x47c>
80008026:	fa cb f9 44 	sub	r11,sp,-1724
8000802a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000802e:	c1 d8       	rjmp	80008068 <_vfprintf_r+0x4b4>
80008030:	fa c8 f9 50 	sub	r8,sp,-1712
80008034:	1a d8       	st.w	--sp,r8
80008036:	fa c8 fa b8 	sub	r8,sp,-1352
8000803a:	1a d8       	st.w	--sp,r8
8000803c:	fa c8 fb b4 	sub	r8,sp,-1100
80008040:	1a d8       	st.w	--sp,r8
80008042:	fa c8 f9 40 	sub	r8,sp,-1728
80008046:	fa c9 ff b4 	sub	r9,sp,-76
8000804a:	04 9a       	mov	r10,r2
8000804c:	0c 9b       	mov	r11,r6
8000804e:	08 9c       	mov	r12,r4
80008050:	fe b0 fc 1a 	rcall	80007884 <get_arg>
80008054:	2f dd       	sub	sp,-12
80008056:	19 b8       	ld.ub	r8,r12[0x3]
80008058:	c2 28       	rjmp	8000809c <_vfprintf_r+0x4e8>
8000805a:	2f f7       	sub	r7,-1
8000805c:	10 39       	cp.w	r9,r8
8000805e:	c0 84       	brge	8000806e <_vfprintf_r+0x4ba>
80008060:	fa ca f9 44 	sub	r10,sp,-1724
80008064:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008068:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000806c:	c1 88       	rjmp	8000809c <_vfprintf_r+0x4e8>
8000806e:	41 09       	lddsp	r9,sp[0x40]
80008070:	59 f8       	cp.w	r8,31
80008072:	e0 89 00 12 	brgt	80008096 <_vfprintf_r+0x4e2>
80008076:	f2 ca ff fc 	sub	r10,r9,-4
8000807a:	51 0a       	stdsp	sp[0x40],r10
8000807c:	72 09       	ld.w	r9,r9[0x0]
8000807e:	fa c6 f9 44 	sub	r6,sp,-1724
80008082:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008086:	2f f8       	sub	r8,-1
80008088:	f5 49 fd 88 	st.w	r10[-632],r9
8000808c:	fb 48 06 b4 	st.w	sp[1716],r8
80008090:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008094:	c0 48       	rjmp	8000809c <_vfprintf_r+0x4e8>
80008096:	13 b8       	ld.ub	r8,r9[0x3]
80008098:	2f c9       	sub	r9,-4
8000809a:	51 09       	stdsp	sp[0x40],r9
8000809c:	fb 68 06 60 	st.b	sp[1632],r8
800080a0:	30 0e       	mov	lr,0
800080a2:	30 08       	mov	r8,0
800080a4:	30 12       	mov	r2,1
800080a6:	fb 68 06 bb 	st.b	sp[1723],r8
800080aa:	50 2e       	stdsp	sp[0x8],lr
800080ac:	e0 8f 08 ad 	bral	80009206 <_vfprintf_r+0x1652>
800080b0:	50 a7       	stdsp	sp[0x28],r7
800080b2:	50 80       	stdsp	sp[0x20],r0
800080b4:	0c 97       	mov	r7,r6
800080b6:	04 94       	mov	r4,r2
800080b8:	06 96       	mov	r6,r3
800080ba:	02 92       	mov	r2,r1
800080bc:	40 93       	lddsp	r3,sp[0x24]
800080be:	10 90       	mov	r0,r8
800080c0:	40 41       	lddsp	r1,sp[0x10]
800080c2:	a5 a5       	sbr	r5,0x4
800080c4:	c0 a8       	rjmp	800080d8 <_vfprintf_r+0x524>
800080c6:	50 a7       	stdsp	sp[0x28],r7
800080c8:	50 80       	stdsp	sp[0x20],r0
800080ca:	0c 97       	mov	r7,r6
800080cc:	04 94       	mov	r4,r2
800080ce:	06 96       	mov	r6,r3
800080d0:	02 92       	mov	r2,r1
800080d2:	40 93       	lddsp	r3,sp[0x24]
800080d4:	10 90       	mov	r0,r8
800080d6:	40 41       	lddsp	r1,sp[0x10]
800080d8:	ed b5 00 05 	bld	r5,0x5
800080dc:	c5 11       	brne	8000817e <_vfprintf_r+0x5ca>
800080de:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080e2:	40 3c       	lddsp	r12,sp[0xc]
800080e4:	58 0c       	cp.w	r12,0
800080e6:	c1 e0       	breq	80008122 <_vfprintf_r+0x56e>
800080e8:	10 36       	cp.w	r6,r8
800080ea:	c0 64       	brge	800080f6 <_vfprintf_r+0x542>
800080ec:	fa cb f9 44 	sub	r11,sp,-1724
800080f0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800080f4:	c2 08       	rjmp	80008134 <_vfprintf_r+0x580>
800080f6:	fa c8 f9 50 	sub	r8,sp,-1712
800080fa:	1a d8       	st.w	--sp,r8
800080fc:	fa c8 fa b8 	sub	r8,sp,-1352
80008100:	0c 9b       	mov	r11,r6
80008102:	1a d8       	st.w	--sp,r8
80008104:	fa c8 fb b4 	sub	r8,sp,-1100
80008108:	1a d8       	st.w	--sp,r8
8000810a:	fa c9 ff b4 	sub	r9,sp,-76
8000810e:	fa c8 f9 40 	sub	r8,sp,-1728
80008112:	04 9a       	mov	r10,r2
80008114:	08 9c       	mov	r12,r4
80008116:	fe b0 fb b7 	rcall	80007884 <get_arg>
8000811a:	2f dd       	sub	sp,-12
8000811c:	78 1b       	ld.w	r11,r12[0x4]
8000811e:	78 09       	ld.w	r9,r12[0x0]
80008120:	c2 b8       	rjmp	80008176 <_vfprintf_r+0x5c2>
80008122:	ee ca ff ff 	sub	r10,r7,-1
80008126:	10 37       	cp.w	r7,r8
80008128:	c0 b4       	brge	8000813e <_vfprintf_r+0x58a>
8000812a:	fa c9 f9 44 	sub	r9,sp,-1724
8000812e:	14 97       	mov	r7,r10
80008130:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008134:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008138:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000813c:	c1 d8       	rjmp	80008176 <_vfprintf_r+0x5c2>
8000813e:	41 09       	lddsp	r9,sp[0x40]
80008140:	59 f8       	cp.w	r8,31
80008142:	e0 89 00 14 	brgt	8000816a <_vfprintf_r+0x5b6>
80008146:	f2 cb ff f8 	sub	r11,r9,-8
8000814a:	51 0b       	stdsp	sp[0x40],r11
8000814c:	fa c6 f9 44 	sub	r6,sp,-1724
80008150:	72 1b       	ld.w	r11,r9[0x4]
80008152:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80008156:	72 09       	ld.w	r9,r9[0x0]
80008158:	f9 4b fd 8c 	st.w	r12[-628],r11
8000815c:	f9 49 fd 88 	st.w	r12[-632],r9
80008160:	2f f8       	sub	r8,-1
80008162:	14 97       	mov	r7,r10
80008164:	fb 48 06 b4 	st.w	sp[1716],r8
80008168:	c0 78       	rjmp	80008176 <_vfprintf_r+0x5c2>
8000816a:	f2 c8 ff f8 	sub	r8,r9,-8
8000816e:	72 1b       	ld.w	r11,r9[0x4]
80008170:	14 97       	mov	r7,r10
80008172:	51 08       	stdsp	sp[0x40],r8
80008174:	72 09       	ld.w	r9,r9[0x0]
80008176:	16 98       	mov	r8,r11
80008178:	fa e9 00 00 	st.d	sp[0],r8
8000817c:	ca e8       	rjmp	800082d8 <_vfprintf_r+0x724>
8000817e:	ed b5 00 04 	bld	r5,0x4
80008182:	c1 71       	brne	800081b0 <_vfprintf_r+0x5fc>
80008184:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008188:	40 3e       	lddsp	lr,sp[0xc]
8000818a:	58 0e       	cp.w	lr,0
8000818c:	c0 80       	breq	8000819c <_vfprintf_r+0x5e8>
8000818e:	10 36       	cp.w	r6,r8
80008190:	c6 94       	brge	80008262 <_vfprintf_r+0x6ae>
80008192:	fa cc f9 44 	sub	r12,sp,-1724
80008196:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000819a:	c8 28       	rjmp	8000829e <_vfprintf_r+0x6ea>
8000819c:	ee ca ff ff 	sub	r10,r7,-1
800081a0:	10 37       	cp.w	r7,r8
800081a2:	e0 84 00 81 	brge	800082a4 <_vfprintf_r+0x6f0>
800081a6:	fa cb f9 44 	sub	r11,sp,-1724
800081aa:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081ae:	c7 78       	rjmp	8000829c <_vfprintf_r+0x6e8>
800081b0:	ed b5 00 06 	bld	r5,0x6
800081b4:	c4 b1       	brne	8000824a <_vfprintf_r+0x696>
800081b6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081ba:	40 3c       	lddsp	r12,sp[0xc]
800081bc:	58 0c       	cp.w	r12,0
800081be:	c1 d0       	breq	800081f8 <_vfprintf_r+0x644>
800081c0:	10 36       	cp.w	r6,r8
800081c2:	c0 64       	brge	800081ce <_vfprintf_r+0x61a>
800081c4:	fa cb f9 44 	sub	r11,sp,-1724
800081c8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081cc:	c1 f8       	rjmp	8000820a <_vfprintf_r+0x656>
800081ce:	fa c8 f9 50 	sub	r8,sp,-1712
800081d2:	1a d8       	st.w	--sp,r8
800081d4:	fa c8 fa b8 	sub	r8,sp,-1352
800081d8:	1a d8       	st.w	--sp,r8
800081da:	fa c8 fb b4 	sub	r8,sp,-1100
800081de:	1a d8       	st.w	--sp,r8
800081e0:	fa c8 f9 40 	sub	r8,sp,-1728
800081e4:	fa c9 ff b4 	sub	r9,sp,-76
800081e8:	04 9a       	mov	r10,r2
800081ea:	0c 9b       	mov	r11,r6
800081ec:	08 9c       	mov	r12,r4
800081ee:	fe b0 fb 4b 	rcall	80007884 <get_arg>
800081f2:	2f dd       	sub	sp,-12
800081f4:	98 18       	ld.sh	r8,r12[0x2]
800081f6:	c2 68       	rjmp	80008242 <_vfprintf_r+0x68e>
800081f8:	ee ca ff ff 	sub	r10,r7,-1
800081fc:	10 37       	cp.w	r7,r8
800081fe:	c0 94       	brge	80008210 <_vfprintf_r+0x65c>
80008200:	fa c9 f9 44 	sub	r9,sp,-1724
80008204:	14 97       	mov	r7,r10
80008206:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000820a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000820e:	c1 a8       	rjmp	80008242 <_vfprintf_r+0x68e>
80008210:	41 09       	lddsp	r9,sp[0x40]
80008212:	59 f8       	cp.w	r8,31
80008214:	e0 89 00 13 	brgt	8000823a <_vfprintf_r+0x686>
80008218:	f2 cb ff fc 	sub	r11,r9,-4
8000821c:	51 0b       	stdsp	sp[0x40],r11
8000821e:	72 09       	ld.w	r9,r9[0x0]
80008220:	fa c6 f9 44 	sub	r6,sp,-1724
80008224:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008228:	2f f8       	sub	r8,-1
8000822a:	f7 49 fd 88 	st.w	r11[-632],r9
8000822e:	fb 48 06 b4 	st.w	sp[1716],r8
80008232:	14 97       	mov	r7,r10
80008234:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008238:	c0 58       	rjmp	80008242 <_vfprintf_r+0x68e>
8000823a:	92 18       	ld.sh	r8,r9[0x2]
8000823c:	14 97       	mov	r7,r10
8000823e:	2f c9       	sub	r9,-4
80008240:	51 09       	stdsp	sp[0x40],r9
80008242:	50 18       	stdsp	sp[0x4],r8
80008244:	bf 58       	asr	r8,0x1f
80008246:	50 08       	stdsp	sp[0x0],r8
80008248:	c4 88       	rjmp	800082d8 <_vfprintf_r+0x724>
8000824a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000824e:	40 3c       	lddsp	r12,sp[0xc]
80008250:	58 0c       	cp.w	r12,0
80008252:	c1 d0       	breq	8000828c <_vfprintf_r+0x6d8>
80008254:	10 36       	cp.w	r6,r8
80008256:	c0 64       	brge	80008262 <_vfprintf_r+0x6ae>
80008258:	fa cb f9 44 	sub	r11,sp,-1724
8000825c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008260:	c1 f8       	rjmp	8000829e <_vfprintf_r+0x6ea>
80008262:	fa c8 f9 50 	sub	r8,sp,-1712
80008266:	1a d8       	st.w	--sp,r8
80008268:	fa c8 fa b8 	sub	r8,sp,-1352
8000826c:	0c 9b       	mov	r11,r6
8000826e:	1a d8       	st.w	--sp,r8
80008270:	fa c8 fb b4 	sub	r8,sp,-1100
80008274:	04 9a       	mov	r10,r2
80008276:	1a d8       	st.w	--sp,r8
80008278:	08 9c       	mov	r12,r4
8000827a:	fa c8 f9 40 	sub	r8,sp,-1728
8000827e:	fa c9 ff b4 	sub	r9,sp,-76
80008282:	fe b0 fb 01 	rcall	80007884 <get_arg>
80008286:	2f dd       	sub	sp,-12
80008288:	78 0b       	ld.w	r11,r12[0x0]
8000828a:	c2 48       	rjmp	800082d2 <_vfprintf_r+0x71e>
8000828c:	ee ca ff ff 	sub	r10,r7,-1
80008290:	10 37       	cp.w	r7,r8
80008292:	c0 94       	brge	800082a4 <_vfprintf_r+0x6f0>
80008294:	fa c9 f9 44 	sub	r9,sp,-1724
80008298:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000829c:	14 97       	mov	r7,r10
8000829e:	ec fb fd 88 	ld.w	r11,r6[-632]
800082a2:	c1 88       	rjmp	800082d2 <_vfprintf_r+0x71e>
800082a4:	41 09       	lddsp	r9,sp[0x40]
800082a6:	59 f8       	cp.w	r8,31
800082a8:	e0 89 00 11 	brgt	800082ca <_vfprintf_r+0x716>
800082ac:	f2 cb ff fc 	sub	r11,r9,-4
800082b0:	51 0b       	stdsp	sp[0x40],r11
800082b2:	fa c6 f9 44 	sub	r6,sp,-1724
800082b6:	72 0b       	ld.w	r11,r9[0x0]
800082b8:	ec 08 00 39 	add	r9,r6,r8<<0x3
800082bc:	f3 4b fd 88 	st.w	r9[-632],r11
800082c0:	2f f8       	sub	r8,-1
800082c2:	14 97       	mov	r7,r10
800082c4:	fb 48 06 b4 	st.w	sp[1716],r8
800082c8:	c0 58       	rjmp	800082d2 <_vfprintf_r+0x71e>
800082ca:	72 0b       	ld.w	r11,r9[0x0]
800082cc:	14 97       	mov	r7,r10
800082ce:	2f c9       	sub	r9,-4
800082d0:	51 09       	stdsp	sp[0x40],r9
800082d2:	50 1b       	stdsp	sp[0x4],r11
800082d4:	bf 5b       	asr	r11,0x1f
800082d6:	50 0b       	stdsp	sp[0x0],r11
800082d8:	fa ea 00 00 	ld.d	r10,sp[0]
800082dc:	58 0a       	cp.w	r10,0
800082de:	5c 2b       	cpc	r11
800082e0:	c0 e4       	brge	800082fc <_vfprintf_r+0x748>
800082e2:	30 08       	mov	r8,0
800082e4:	fa ea 00 00 	ld.d	r10,sp[0]
800082e8:	30 09       	mov	r9,0
800082ea:	f0 0a 01 0a 	sub	r10,r8,r10
800082ee:	f2 0b 01 4b 	sbc	r11,r9,r11
800082f2:	32 d8       	mov	r8,45
800082f4:	fa eb 00 00 	st.d	sp[0],r10
800082f8:	fb 68 06 bb 	st.b	sp[1723],r8
800082fc:	30 18       	mov	r8,1
800082fe:	e0 8f 06 fa 	bral	800090f2 <_vfprintf_r+0x153e>
80008302:	50 a7       	stdsp	sp[0x28],r7
80008304:	50 80       	stdsp	sp[0x20],r0
80008306:	0c 97       	mov	r7,r6
80008308:	04 94       	mov	r4,r2
8000830a:	06 96       	mov	r6,r3
8000830c:	02 92       	mov	r2,r1
8000830e:	40 93       	lddsp	r3,sp[0x24]
80008310:	10 90       	mov	r0,r8
80008312:	40 41       	lddsp	r1,sp[0x10]
80008314:	0e 99       	mov	r9,r7
80008316:	ed b5 00 03 	bld	r5,0x3
8000831a:	c4 11       	brne	8000839c <_vfprintf_r+0x7e8>
8000831c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008320:	40 3a       	lddsp	r10,sp[0xc]
80008322:	58 0a       	cp.w	r10,0
80008324:	c1 90       	breq	80008356 <_vfprintf_r+0x7a2>
80008326:	10 36       	cp.w	r6,r8
80008328:	c6 45       	brlt	800083f0 <_vfprintf_r+0x83c>
8000832a:	fa c8 f9 50 	sub	r8,sp,-1712
8000832e:	1a d8       	st.w	--sp,r8
80008330:	fa c8 fa b8 	sub	r8,sp,-1352
80008334:	1a d8       	st.w	--sp,r8
80008336:	fa c8 fb b4 	sub	r8,sp,-1100
8000833a:	0c 9b       	mov	r11,r6
8000833c:	1a d8       	st.w	--sp,r8
8000833e:	04 9a       	mov	r10,r2
80008340:	fa c8 f9 40 	sub	r8,sp,-1728
80008344:	fa c9 ff b4 	sub	r9,sp,-76
80008348:	08 9c       	mov	r12,r4
8000834a:	fe b0 fa 9d 	rcall	80007884 <get_arg>
8000834e:	2f dd       	sub	sp,-12
80008350:	78 16       	ld.w	r6,r12[0x4]
80008352:	50 76       	stdsp	sp[0x1c],r6
80008354:	c4 88       	rjmp	800083e4 <_vfprintf_r+0x830>
80008356:	2f f7       	sub	r7,-1
80008358:	10 39       	cp.w	r9,r8
8000835a:	c0 c4       	brge	80008372 <_vfprintf_r+0x7be>
8000835c:	fa ce f9 44 	sub	lr,sp,-1724
80008360:	fc 06 00 36 	add	r6,lr,r6<<0x3
80008364:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008368:	50 7c       	stdsp	sp[0x1c],r12
8000836a:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000836e:	50 56       	stdsp	sp[0x14],r6
80008370:	c6 68       	rjmp	8000843c <_vfprintf_r+0x888>
80008372:	41 09       	lddsp	r9,sp[0x40]
80008374:	59 f8       	cp.w	r8,31
80008376:	e0 89 00 10 	brgt	80008396 <_vfprintf_r+0x7e2>
8000837a:	f2 ca ff f8 	sub	r10,r9,-8
8000837e:	72 1b       	ld.w	r11,r9[0x4]
80008380:	51 0a       	stdsp	sp[0x40],r10
80008382:	72 09       	ld.w	r9,r9[0x0]
80008384:	fa ca f9 44 	sub	r10,sp,-1724
80008388:	50 7b       	stdsp	sp[0x1c],r11
8000838a:	50 59       	stdsp	sp[0x14],r9
8000838c:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008390:	40 5b       	lddsp	r11,sp[0x14]
80008392:	40 7a       	lddsp	r10,sp[0x1c]
80008394:	c4 78       	rjmp	80008422 <_vfprintf_r+0x86e>
80008396:	72 18       	ld.w	r8,r9[0x4]
80008398:	50 78       	stdsp	sp[0x1c],r8
8000839a:	c4 c8       	rjmp	80008432 <_vfprintf_r+0x87e>
8000839c:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083a0:	40 3e       	lddsp	lr,sp[0xc]
800083a2:	58 0e       	cp.w	lr,0
800083a4:	c2 30       	breq	800083ea <_vfprintf_r+0x836>
800083a6:	10 36       	cp.w	r6,r8
800083a8:	c0 94       	brge	800083ba <_vfprintf_r+0x806>
800083aa:	fa cc f9 44 	sub	r12,sp,-1724
800083ae:	f8 06 00 36 	add	r6,r12,r6<<0x3
800083b2:	ec fb fd 8c 	ld.w	r11,r6[-628]
800083b6:	50 7b       	stdsp	sp[0x1c],r11
800083b8:	cd 9b       	rjmp	8000836a <_vfprintf_r+0x7b6>
800083ba:	fa c8 f9 50 	sub	r8,sp,-1712
800083be:	1a d8       	st.w	--sp,r8
800083c0:	fa c8 fa b8 	sub	r8,sp,-1352
800083c4:	04 9a       	mov	r10,r2
800083c6:	1a d8       	st.w	--sp,r8
800083c8:	fa c8 fb b4 	sub	r8,sp,-1100
800083cc:	0c 9b       	mov	r11,r6
800083ce:	1a d8       	st.w	--sp,r8
800083d0:	08 9c       	mov	r12,r4
800083d2:	fa c8 f9 40 	sub	r8,sp,-1728
800083d6:	fa c9 ff b4 	sub	r9,sp,-76
800083da:	fe b0 fa 55 	rcall	80007884 <get_arg>
800083de:	2f dd       	sub	sp,-12
800083e0:	78 1a       	ld.w	r10,r12[0x4]
800083e2:	50 7a       	stdsp	sp[0x1c],r10
800083e4:	78 0c       	ld.w	r12,r12[0x0]
800083e6:	50 5c       	stdsp	sp[0x14],r12
800083e8:	c2 a8       	rjmp	8000843c <_vfprintf_r+0x888>
800083ea:	2f f7       	sub	r7,-1
800083ec:	10 39       	cp.w	r9,r8
800083ee:	c0 94       	brge	80008400 <_vfprintf_r+0x84c>
800083f0:	fa c9 f9 44 	sub	r9,sp,-1724
800083f4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800083f8:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800083fc:	50 78       	stdsp	sp[0x1c],r8
800083fe:	cb 6b       	rjmp	8000836a <_vfprintf_r+0x7b6>
80008400:	41 09       	lddsp	r9,sp[0x40]
80008402:	59 f8       	cp.w	r8,31
80008404:	e0 89 00 15 	brgt	8000842e <_vfprintf_r+0x87a>
80008408:	f2 ca ff f8 	sub	r10,r9,-8
8000840c:	72 16       	ld.w	r6,r9[0x4]
8000840e:	72 09       	ld.w	r9,r9[0x0]
80008410:	51 0a       	stdsp	sp[0x40],r10
80008412:	50 59       	stdsp	sp[0x14],r9
80008414:	fa ce f9 44 	sub	lr,sp,-1724
80008418:	50 76       	stdsp	sp[0x1c],r6
8000841a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000841e:	40 5b       	lddsp	r11,sp[0x14]
80008420:	0c 9a       	mov	r10,r6
80008422:	f2 eb fd 88 	st.d	r9[-632],r10
80008426:	2f f8       	sub	r8,-1
80008428:	fb 48 06 b4 	st.w	sp[1716],r8
8000842c:	c0 88       	rjmp	8000843c <_vfprintf_r+0x888>
8000842e:	72 1c       	ld.w	r12,r9[0x4]
80008430:	50 7c       	stdsp	sp[0x1c],r12
80008432:	f2 c8 ff f8 	sub	r8,r9,-8
80008436:	51 08       	stdsp	sp[0x40],r8
80008438:	72 09       	ld.w	r9,r9[0x0]
8000843a:	50 59       	stdsp	sp[0x14],r9
8000843c:	40 5b       	lddsp	r11,sp[0x14]
8000843e:	40 7a       	lddsp	r10,sp[0x1c]
80008440:	e0 a0 18 0c 	rcall	8000b458 <__isinfd>
80008444:	18 96       	mov	r6,r12
80008446:	c1 70       	breq	80008474 <_vfprintf_r+0x8c0>
80008448:	30 08       	mov	r8,0
8000844a:	30 09       	mov	r9,0
8000844c:	40 5b       	lddsp	r11,sp[0x14]
8000844e:	40 7a       	lddsp	r10,sp[0x1c]
80008450:	e0 a0 1b 82 	rcall	8000bb54 <__avr32_f64_cmp_lt>
80008454:	c0 40       	breq	8000845c <_vfprintf_r+0x8a8>
80008456:	32 d8       	mov	r8,45
80008458:	fb 68 06 bb 	st.b	sp[1723],r8
8000845c:	fe c8 bc 38 	sub	r8,pc,-17352
80008460:	fe c6 bc 38 	sub	r6,pc,-17352
80008464:	a7 d5       	cbr	r5,0x7
80008466:	e0 40 00 47 	cp.w	r0,71
8000846a:	f0 06 17 a0 	movle	r6,r8
8000846e:	30 32       	mov	r2,3
80008470:	e0 8f 06 ce 	bral	8000920c <_vfprintf_r+0x1658>
80008474:	40 5b       	lddsp	r11,sp[0x14]
80008476:	40 7a       	lddsp	r10,sp[0x1c]
80008478:	e0 a0 18 05 	rcall	8000b482 <__isnand>
8000847c:	c0 e0       	breq	80008498 <_vfprintf_r+0x8e4>
8000847e:	50 26       	stdsp	sp[0x8],r6
80008480:	fe c8 bc 54 	sub	r8,pc,-17324
80008484:	fe c6 bc 54 	sub	r6,pc,-17324
80008488:	a7 d5       	cbr	r5,0x7
8000848a:	e0 40 00 47 	cp.w	r0,71
8000848e:	f0 06 17 a0 	movle	r6,r8
80008492:	30 32       	mov	r2,3
80008494:	e0 8f 06 c2 	bral	80009218 <_vfprintf_r+0x1664>
80008498:	40 2a       	lddsp	r10,sp[0x8]
8000849a:	5b fa       	cp.w	r10,-1
8000849c:	c0 41       	brne	800084a4 <_vfprintf_r+0x8f0>
8000849e:	30 69       	mov	r9,6
800084a0:	50 29       	stdsp	sp[0x8],r9
800084a2:	c1 18       	rjmp	800084c4 <_vfprintf_r+0x910>
800084a4:	e0 40 00 47 	cp.w	r0,71
800084a8:	5f 09       	sreq	r9
800084aa:	e0 40 00 67 	cp.w	r0,103
800084ae:	5f 08       	sreq	r8
800084b0:	f3 e8 10 08 	or	r8,r9,r8
800084b4:	f8 08 18 00 	cp.b	r8,r12
800084b8:	c0 60       	breq	800084c4 <_vfprintf_r+0x910>
800084ba:	40 28       	lddsp	r8,sp[0x8]
800084bc:	58 08       	cp.w	r8,0
800084be:	f9 b8 00 01 	moveq	r8,1
800084c2:	50 28       	stdsp	sp[0x8],r8
800084c4:	40 78       	lddsp	r8,sp[0x1c]
800084c6:	40 59       	lddsp	r9,sp[0x14]
800084c8:	fa e9 06 94 	st.d	sp[1684],r8
800084cc:	a9 a5       	sbr	r5,0x8
800084ce:	fa f8 06 94 	ld.w	r8,sp[1684]
800084d2:	58 08       	cp.w	r8,0
800084d4:	c0 65       	brlt	800084e0 <_vfprintf_r+0x92c>
800084d6:	40 5e       	lddsp	lr,sp[0x14]
800084d8:	30 0c       	mov	r12,0
800084da:	50 6e       	stdsp	sp[0x18],lr
800084dc:	50 9c       	stdsp	sp[0x24],r12
800084de:	c0 78       	rjmp	800084ec <_vfprintf_r+0x938>
800084e0:	40 5b       	lddsp	r11,sp[0x14]
800084e2:	32 da       	mov	r10,45
800084e4:	ee 1b 80 00 	eorh	r11,0x8000
800084e8:	50 9a       	stdsp	sp[0x24],r10
800084ea:	50 6b       	stdsp	sp[0x18],r11
800084ec:	e0 40 00 46 	cp.w	r0,70
800084f0:	5f 09       	sreq	r9
800084f2:	e0 40 00 66 	cp.w	r0,102
800084f6:	5f 08       	sreq	r8
800084f8:	f3 e8 10 08 	or	r8,r9,r8
800084fc:	50 48       	stdsp	sp[0x10],r8
800084fe:	c0 40       	breq	80008506 <_vfprintf_r+0x952>
80008500:	40 22       	lddsp	r2,sp[0x8]
80008502:	30 39       	mov	r9,3
80008504:	c1 08       	rjmp	80008524 <_vfprintf_r+0x970>
80008506:	e0 40 00 45 	cp.w	r0,69
8000850a:	5f 09       	sreq	r9
8000850c:	e0 40 00 65 	cp.w	r0,101
80008510:	5f 08       	sreq	r8
80008512:	40 22       	lddsp	r2,sp[0x8]
80008514:	10 49       	or	r9,r8
80008516:	2f f2       	sub	r2,-1
80008518:	40 46       	lddsp	r6,sp[0x10]
8000851a:	ec 09 18 00 	cp.b	r9,r6
8000851e:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008522:	30 29       	mov	r9,2
80008524:	fa c8 f9 5c 	sub	r8,sp,-1700
80008528:	1a d8       	st.w	--sp,r8
8000852a:	fa c8 f9 54 	sub	r8,sp,-1708
8000852e:	1a d8       	st.w	--sp,r8
80008530:	fa c8 f9 4c 	sub	r8,sp,-1716
80008534:	08 9c       	mov	r12,r4
80008536:	1a d8       	st.w	--sp,r8
80008538:	04 98       	mov	r8,r2
8000853a:	40 9b       	lddsp	r11,sp[0x24]
8000853c:	40 aa       	lddsp	r10,sp[0x28]
8000853e:	e0 a0 0b e7 	rcall	80009d0c <_dtoa_r>
80008542:	e0 40 00 47 	cp.w	r0,71
80008546:	5f 19       	srne	r9
80008548:	e0 40 00 67 	cp.w	r0,103
8000854c:	5f 18       	srne	r8
8000854e:	18 96       	mov	r6,r12
80008550:	2f dd       	sub	sp,-12
80008552:	f3 e8 00 08 	and	r8,r9,r8
80008556:	c0 41       	brne	8000855e <_vfprintf_r+0x9aa>
80008558:	ed b5 00 00 	bld	r5,0x0
8000855c:	c3 01       	brne	800085bc <_vfprintf_r+0xa08>
8000855e:	ec 02 00 0e 	add	lr,r6,r2
80008562:	50 3e       	stdsp	sp[0xc],lr
80008564:	40 4c       	lddsp	r12,sp[0x10]
80008566:	58 0c       	cp.w	r12,0
80008568:	c1 50       	breq	80008592 <_vfprintf_r+0x9de>
8000856a:	0d 89       	ld.ub	r9,r6[0x0]
8000856c:	33 08       	mov	r8,48
8000856e:	f0 09 18 00 	cp.b	r9,r8
80008572:	c0 b1       	brne	80008588 <_vfprintf_r+0x9d4>
80008574:	30 08       	mov	r8,0
80008576:	30 09       	mov	r9,0
80008578:	40 6b       	lddsp	r11,sp[0x18]
8000857a:	40 7a       	lddsp	r10,sp[0x1c]
8000857c:	e0 a0 1a a5 	rcall	8000bac6 <__avr32_f64_cmp_eq>
80008580:	fb b2 00 01 	rsubeq	r2,1
80008584:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008588:	40 3b       	lddsp	r11,sp[0xc]
8000858a:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000858e:	10 0b       	add	r11,r8
80008590:	50 3b       	stdsp	sp[0xc],r11
80008592:	40 6b       	lddsp	r11,sp[0x18]
80008594:	30 08       	mov	r8,0
80008596:	30 09       	mov	r9,0
80008598:	40 7a       	lddsp	r10,sp[0x1c]
8000859a:	e0 a0 1a 96 	rcall	8000bac6 <__avr32_f64_cmp_eq>
8000859e:	c0 90       	breq	800085b0 <_vfprintf_r+0x9fc>
800085a0:	40 3a       	lddsp	r10,sp[0xc]
800085a2:	fb 4a 06 a4 	st.w	sp[1700],r10
800085a6:	c0 58       	rjmp	800085b0 <_vfprintf_r+0x9fc>
800085a8:	10 c9       	st.b	r8++,r9
800085aa:	fb 48 06 a4 	st.w	sp[1700],r8
800085ae:	c0 28       	rjmp	800085b2 <_vfprintf_r+0x9fe>
800085b0:	33 09       	mov	r9,48
800085b2:	fa f8 06 a4 	ld.w	r8,sp[1700]
800085b6:	40 3e       	lddsp	lr,sp[0xc]
800085b8:	1c 38       	cp.w	r8,lr
800085ba:	cf 73       	brcs	800085a8 <_vfprintf_r+0x9f4>
800085bc:	e0 40 00 47 	cp.w	r0,71
800085c0:	5f 09       	sreq	r9
800085c2:	e0 40 00 67 	cp.w	r0,103
800085c6:	5f 08       	sreq	r8
800085c8:	f3 e8 10 08 	or	r8,r9,r8
800085cc:	fa f9 06 a4 	ld.w	r9,sp[1700]
800085d0:	0c 19       	sub	r9,r6
800085d2:	50 69       	stdsp	sp[0x18],r9
800085d4:	58 08       	cp.w	r8,0
800085d6:	c0 b0       	breq	800085ec <_vfprintf_r+0xa38>
800085d8:	fa f8 06 ac 	ld.w	r8,sp[1708]
800085dc:	5b d8       	cp.w	r8,-3
800085de:	c0 55       	brlt	800085e8 <_vfprintf_r+0xa34>
800085e0:	40 2c       	lddsp	r12,sp[0x8]
800085e2:	18 38       	cp.w	r8,r12
800085e4:	e0 8a 00 6a 	brle	800086b8 <_vfprintf_r+0xb04>
800085e8:	20 20       	sub	r0,2
800085ea:	c0 58       	rjmp	800085f4 <_vfprintf_r+0xa40>
800085ec:	e0 40 00 65 	cp.w	r0,101
800085f0:	e0 89 00 46 	brgt	8000867c <_vfprintf_r+0xac8>
800085f4:	fa fb 06 ac 	ld.w	r11,sp[1708]
800085f8:	fb 60 06 9c 	st.b	sp[1692],r0
800085fc:	20 1b       	sub	r11,1
800085fe:	fb 4b 06 ac 	st.w	sp[1708],r11
80008602:	c0 47       	brpl	8000860a <_vfprintf_r+0xa56>
80008604:	5c 3b       	neg	r11
80008606:	32 d8       	mov	r8,45
80008608:	c0 28       	rjmp	8000860c <_vfprintf_r+0xa58>
8000860a:	32 b8       	mov	r8,43
8000860c:	fb 68 06 9d 	st.b	sp[1693],r8
80008610:	58 9b       	cp.w	r11,9
80008612:	e0 8a 00 1d 	brle	8000864c <_vfprintf_r+0xa98>
80008616:	fa c9 fa 35 	sub	r9,sp,-1483
8000861a:	30 aa       	mov	r10,10
8000861c:	12 98       	mov	r8,r9
8000861e:	0e 9c       	mov	r12,r7
80008620:	0c 92       	mov	r2,r6
80008622:	f6 0a 0c 06 	divs	r6,r11,r10
80008626:	0e 9b       	mov	r11,r7
80008628:	2d 0b       	sub	r11,-48
8000862a:	10 fb       	st.b	--r8,r11
8000862c:	0c 9b       	mov	r11,r6
8000862e:	58 96       	cp.w	r6,9
80008630:	fe 99 ff f9 	brgt	80008622 <_vfprintf_r+0xa6e>
80008634:	2d 0b       	sub	r11,-48
80008636:	18 97       	mov	r7,r12
80008638:	04 96       	mov	r6,r2
8000863a:	10 fb       	st.b	--r8,r11
8000863c:	fa ca f9 62 	sub	r10,sp,-1694
80008640:	c0 38       	rjmp	80008646 <_vfprintf_r+0xa92>
80008642:	11 3b       	ld.ub	r11,r8++
80008644:	14 cb       	st.b	r10++,r11
80008646:	12 38       	cp.w	r8,r9
80008648:	cf d3       	brcs	80008642 <_vfprintf_r+0xa8e>
8000864a:	c0 98       	rjmp	8000865c <_vfprintf_r+0xaa8>
8000864c:	2d 0b       	sub	r11,-48
8000864e:	33 08       	mov	r8,48
80008650:	fb 6b 06 9f 	st.b	sp[1695],r11
80008654:	fb 68 06 9e 	st.b	sp[1694],r8
80008658:	fa ca f9 60 	sub	r10,sp,-1696
8000865c:	fa c8 f9 64 	sub	r8,sp,-1692
80008660:	f4 08 01 08 	sub	r8,r10,r8
80008664:	50 e8       	stdsp	sp[0x38],r8
80008666:	10 92       	mov	r2,r8
80008668:	40 6b       	lddsp	r11,sp[0x18]
8000866a:	16 02       	add	r2,r11
8000866c:	58 1b       	cp.w	r11,1
8000866e:	e0 89 00 05 	brgt	80008678 <_vfprintf_r+0xac4>
80008672:	ed b5 00 00 	bld	r5,0x0
80008676:	c3 51       	brne	800086e0 <_vfprintf_r+0xb2c>
80008678:	2f f2       	sub	r2,-1
8000867a:	c3 38       	rjmp	800086e0 <_vfprintf_r+0xb2c>
8000867c:	e0 40 00 66 	cp.w	r0,102
80008680:	c1 c1       	brne	800086b8 <_vfprintf_r+0xb04>
80008682:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008686:	58 02       	cp.w	r2,0
80008688:	e0 8a 00 0c 	brle	800086a0 <_vfprintf_r+0xaec>
8000868c:	40 2a       	lddsp	r10,sp[0x8]
8000868e:	58 0a       	cp.w	r10,0
80008690:	c0 41       	brne	80008698 <_vfprintf_r+0xae4>
80008692:	ed b5 00 00 	bld	r5,0x0
80008696:	c2 51       	brne	800086e0 <_vfprintf_r+0xb2c>
80008698:	2f f2       	sub	r2,-1
8000869a:	40 29       	lddsp	r9,sp[0x8]
8000869c:	12 02       	add	r2,r9
8000869e:	c0 b8       	rjmp	800086b4 <_vfprintf_r+0xb00>
800086a0:	40 28       	lddsp	r8,sp[0x8]
800086a2:	58 08       	cp.w	r8,0
800086a4:	c0 61       	brne	800086b0 <_vfprintf_r+0xafc>
800086a6:	ed b5 00 00 	bld	r5,0x0
800086aa:	c0 30       	breq	800086b0 <_vfprintf_r+0xafc>
800086ac:	30 12       	mov	r2,1
800086ae:	c1 98       	rjmp	800086e0 <_vfprintf_r+0xb2c>
800086b0:	40 22       	lddsp	r2,sp[0x8]
800086b2:	2f e2       	sub	r2,-2
800086b4:	36 60       	mov	r0,102
800086b6:	c1 58       	rjmp	800086e0 <_vfprintf_r+0xb2c>
800086b8:	fa f2 06 ac 	ld.w	r2,sp[1708]
800086bc:	40 6e       	lddsp	lr,sp[0x18]
800086be:	1c 32       	cp.w	r2,lr
800086c0:	c0 65       	brlt	800086cc <_vfprintf_r+0xb18>
800086c2:	ed b5 00 00 	bld	r5,0x0
800086c6:	f7 b2 00 ff 	subeq	r2,-1
800086ca:	c0 a8       	rjmp	800086de <_vfprintf_r+0xb2a>
800086cc:	e4 08 11 02 	rsub	r8,r2,2
800086d0:	40 6c       	lddsp	r12,sp[0x18]
800086d2:	58 02       	cp.w	r2,0
800086d4:	f0 02 17 a0 	movle	r2,r8
800086d8:	f9 b2 09 01 	movgt	r2,1
800086dc:	18 02       	add	r2,r12
800086de:	36 70       	mov	r0,103
800086e0:	40 9b       	lddsp	r11,sp[0x24]
800086e2:	58 0b       	cp.w	r11,0
800086e4:	e0 80 05 94 	breq	8000920c <_vfprintf_r+0x1658>
800086e8:	32 d8       	mov	r8,45
800086ea:	fb 68 06 bb 	st.b	sp[1723],r8
800086ee:	e0 8f 05 93 	bral	80009214 <_vfprintf_r+0x1660>
800086f2:	50 a7       	stdsp	sp[0x28],r7
800086f4:	04 94       	mov	r4,r2
800086f6:	0c 97       	mov	r7,r6
800086f8:	02 92       	mov	r2,r1
800086fa:	06 96       	mov	r6,r3
800086fc:	40 41       	lddsp	r1,sp[0x10]
800086fe:	40 93       	lddsp	r3,sp[0x24]
80008700:	0e 99       	mov	r9,r7
80008702:	ed b5 00 05 	bld	r5,0x5
80008706:	c4 81       	brne	80008796 <_vfprintf_r+0xbe2>
80008708:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000870c:	40 3e       	lddsp	lr,sp[0xc]
8000870e:	58 0e       	cp.w	lr,0
80008710:	c1 d0       	breq	8000874a <_vfprintf_r+0xb96>
80008712:	10 36       	cp.w	r6,r8
80008714:	c0 64       	brge	80008720 <_vfprintf_r+0xb6c>
80008716:	fa cc f9 44 	sub	r12,sp,-1724
8000871a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000871e:	c1 d8       	rjmp	80008758 <_vfprintf_r+0xba4>
80008720:	fa c8 f9 50 	sub	r8,sp,-1712
80008724:	1a d8       	st.w	--sp,r8
80008726:	fa c8 fa b8 	sub	r8,sp,-1352
8000872a:	04 9a       	mov	r10,r2
8000872c:	1a d8       	st.w	--sp,r8
8000872e:	fa c8 fb b4 	sub	r8,sp,-1100
80008732:	0c 9b       	mov	r11,r6
80008734:	1a d8       	st.w	--sp,r8
80008736:	08 9c       	mov	r12,r4
80008738:	fa c8 f9 40 	sub	r8,sp,-1728
8000873c:	fa c9 ff b4 	sub	r9,sp,-76
80008740:	fe b0 f8 a2 	rcall	80007884 <get_arg>
80008744:	2f dd       	sub	sp,-12
80008746:	78 0a       	ld.w	r10,r12[0x0]
80008748:	c2 08       	rjmp	80008788 <_vfprintf_r+0xbd4>
8000874a:	2f f7       	sub	r7,-1
8000874c:	10 39       	cp.w	r9,r8
8000874e:	c0 84       	brge	8000875e <_vfprintf_r+0xbaa>
80008750:	fa cb f9 44 	sub	r11,sp,-1724
80008754:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008758:	ec fa fd 88 	ld.w	r10,r6[-632]
8000875c:	c1 68       	rjmp	80008788 <_vfprintf_r+0xbd4>
8000875e:	41 09       	lddsp	r9,sp[0x40]
80008760:	59 f8       	cp.w	r8,31
80008762:	e0 89 00 10 	brgt	80008782 <_vfprintf_r+0xbce>
80008766:	f2 ca ff fc 	sub	r10,r9,-4
8000876a:	51 0a       	stdsp	sp[0x40],r10
8000876c:	fa c6 f9 44 	sub	r6,sp,-1724
80008770:	72 0a       	ld.w	r10,r9[0x0]
80008772:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008776:	f3 4a fd 88 	st.w	r9[-632],r10
8000877a:	2f f8       	sub	r8,-1
8000877c:	fb 48 06 b4 	st.w	sp[1716],r8
80008780:	c0 48       	rjmp	80008788 <_vfprintf_r+0xbd4>
80008782:	72 0a       	ld.w	r10,r9[0x0]
80008784:	2f c9       	sub	r9,-4
80008786:	51 09       	stdsp	sp[0x40],r9
80008788:	40 be       	lddsp	lr,sp[0x2c]
8000878a:	1c 98       	mov	r8,lr
8000878c:	95 1e       	st.w	r10[0x4],lr
8000878e:	bf 58       	asr	r8,0x1f
80008790:	95 08       	st.w	r10[0x0],r8
80008792:	fe 9f fa 9f 	bral	80007cd0 <_vfprintf_r+0x11c>
80008796:	ed b5 00 04 	bld	r5,0x4
8000879a:	c4 80       	breq	8000882a <_vfprintf_r+0xc76>
8000879c:	e2 15 00 40 	andl	r5,0x40,COH
800087a0:	c4 50       	breq	8000882a <_vfprintf_r+0xc76>
800087a2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087a6:	40 3c       	lddsp	r12,sp[0xc]
800087a8:	58 0c       	cp.w	r12,0
800087aa:	c1 d0       	breq	800087e4 <_vfprintf_r+0xc30>
800087ac:	10 36       	cp.w	r6,r8
800087ae:	c0 64       	brge	800087ba <_vfprintf_r+0xc06>
800087b0:	fa cb f9 44 	sub	r11,sp,-1724
800087b4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087b8:	c1 d8       	rjmp	800087f2 <_vfprintf_r+0xc3e>
800087ba:	fa c8 f9 50 	sub	r8,sp,-1712
800087be:	1a d8       	st.w	--sp,r8
800087c0:	fa c8 fa b8 	sub	r8,sp,-1352
800087c4:	04 9a       	mov	r10,r2
800087c6:	1a d8       	st.w	--sp,r8
800087c8:	fa c8 fb b4 	sub	r8,sp,-1100
800087cc:	0c 9b       	mov	r11,r6
800087ce:	1a d8       	st.w	--sp,r8
800087d0:	08 9c       	mov	r12,r4
800087d2:	fa c8 f9 40 	sub	r8,sp,-1728
800087d6:	fa c9 ff b4 	sub	r9,sp,-76
800087da:	fe b0 f8 55 	rcall	80007884 <get_arg>
800087de:	2f dd       	sub	sp,-12
800087e0:	78 0a       	ld.w	r10,r12[0x0]
800087e2:	c2 08       	rjmp	80008822 <_vfprintf_r+0xc6e>
800087e4:	2f f7       	sub	r7,-1
800087e6:	10 39       	cp.w	r9,r8
800087e8:	c0 84       	brge	800087f8 <_vfprintf_r+0xc44>
800087ea:	fa ca f9 44 	sub	r10,sp,-1724
800087ee:	f4 06 00 36 	add	r6,r10,r6<<0x3
800087f2:	ec fa fd 88 	ld.w	r10,r6[-632]
800087f6:	c1 68       	rjmp	80008822 <_vfprintf_r+0xc6e>
800087f8:	41 09       	lddsp	r9,sp[0x40]
800087fa:	59 f8       	cp.w	r8,31
800087fc:	e0 89 00 10 	brgt	8000881c <_vfprintf_r+0xc68>
80008800:	f2 ca ff fc 	sub	r10,r9,-4
80008804:	51 0a       	stdsp	sp[0x40],r10
80008806:	fa c6 f9 44 	sub	r6,sp,-1724
8000880a:	72 0a       	ld.w	r10,r9[0x0]
8000880c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008810:	f3 4a fd 88 	st.w	r9[-632],r10
80008814:	2f f8       	sub	r8,-1
80008816:	fb 48 06 b4 	st.w	sp[1716],r8
8000881a:	c0 48       	rjmp	80008822 <_vfprintf_r+0xc6e>
8000881c:	72 0a       	ld.w	r10,r9[0x0]
8000881e:	2f c9       	sub	r9,-4
80008820:	51 09       	stdsp	sp[0x40],r9
80008822:	40 be       	lddsp	lr,sp[0x2c]
80008824:	b4 0e       	st.h	r10[0x0],lr
80008826:	fe 9f fa 55 	bral	80007cd0 <_vfprintf_r+0x11c>
8000882a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000882e:	40 3c       	lddsp	r12,sp[0xc]
80008830:	58 0c       	cp.w	r12,0
80008832:	c1 d0       	breq	8000886c <_vfprintf_r+0xcb8>
80008834:	10 36       	cp.w	r6,r8
80008836:	c0 64       	brge	80008842 <_vfprintf_r+0xc8e>
80008838:	fa cb f9 44 	sub	r11,sp,-1724
8000883c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008840:	c1 d8       	rjmp	8000887a <_vfprintf_r+0xcc6>
80008842:	fa c8 f9 50 	sub	r8,sp,-1712
80008846:	1a d8       	st.w	--sp,r8
80008848:	fa c8 fa b8 	sub	r8,sp,-1352
8000884c:	04 9a       	mov	r10,r2
8000884e:	1a d8       	st.w	--sp,r8
80008850:	fa c8 fb b4 	sub	r8,sp,-1100
80008854:	0c 9b       	mov	r11,r6
80008856:	1a d8       	st.w	--sp,r8
80008858:	08 9c       	mov	r12,r4
8000885a:	fa c8 f9 40 	sub	r8,sp,-1728
8000885e:	fa c9 ff b4 	sub	r9,sp,-76
80008862:	fe b0 f8 11 	rcall	80007884 <get_arg>
80008866:	2f dd       	sub	sp,-12
80008868:	78 0a       	ld.w	r10,r12[0x0]
8000886a:	c2 08       	rjmp	800088aa <_vfprintf_r+0xcf6>
8000886c:	2f f7       	sub	r7,-1
8000886e:	10 39       	cp.w	r9,r8
80008870:	c0 84       	brge	80008880 <_vfprintf_r+0xccc>
80008872:	fa ca f9 44 	sub	r10,sp,-1724
80008876:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000887a:	ec fa fd 88 	ld.w	r10,r6[-632]
8000887e:	c1 68       	rjmp	800088aa <_vfprintf_r+0xcf6>
80008880:	41 09       	lddsp	r9,sp[0x40]
80008882:	59 f8       	cp.w	r8,31
80008884:	e0 89 00 10 	brgt	800088a4 <_vfprintf_r+0xcf0>
80008888:	f2 ca ff fc 	sub	r10,r9,-4
8000888c:	51 0a       	stdsp	sp[0x40],r10
8000888e:	fa c6 f9 44 	sub	r6,sp,-1724
80008892:	72 0a       	ld.w	r10,r9[0x0]
80008894:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008898:	f3 4a fd 88 	st.w	r9[-632],r10
8000889c:	2f f8       	sub	r8,-1
8000889e:	fb 48 06 b4 	st.w	sp[1716],r8
800088a2:	c0 48       	rjmp	800088aa <_vfprintf_r+0xcf6>
800088a4:	72 0a       	ld.w	r10,r9[0x0]
800088a6:	2f c9       	sub	r9,-4
800088a8:	51 09       	stdsp	sp[0x40],r9
800088aa:	40 be       	lddsp	lr,sp[0x2c]
800088ac:	95 0e       	st.w	r10[0x0],lr
800088ae:	fe 9f fa 11 	bral	80007cd0 <_vfprintf_r+0x11c>
800088b2:	50 a7       	stdsp	sp[0x28],r7
800088b4:	50 80       	stdsp	sp[0x20],r0
800088b6:	0c 97       	mov	r7,r6
800088b8:	04 94       	mov	r4,r2
800088ba:	06 96       	mov	r6,r3
800088bc:	02 92       	mov	r2,r1
800088be:	40 93       	lddsp	r3,sp[0x24]
800088c0:	10 90       	mov	r0,r8
800088c2:	40 41       	lddsp	r1,sp[0x10]
800088c4:	a5 a5       	sbr	r5,0x4
800088c6:	c0 a8       	rjmp	800088da <_vfprintf_r+0xd26>
800088c8:	50 a7       	stdsp	sp[0x28],r7
800088ca:	50 80       	stdsp	sp[0x20],r0
800088cc:	0c 97       	mov	r7,r6
800088ce:	04 94       	mov	r4,r2
800088d0:	06 96       	mov	r6,r3
800088d2:	02 92       	mov	r2,r1
800088d4:	40 93       	lddsp	r3,sp[0x24]
800088d6:	10 90       	mov	r0,r8
800088d8:	40 41       	lddsp	r1,sp[0x10]
800088da:	ed b5 00 05 	bld	r5,0x5
800088de:	c5 d1       	brne	80008998 <_vfprintf_r+0xde4>
800088e0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088e4:	40 3c       	lddsp	r12,sp[0xc]
800088e6:	58 0c       	cp.w	r12,0
800088e8:	c2 60       	breq	80008934 <_vfprintf_r+0xd80>
800088ea:	10 36       	cp.w	r6,r8
800088ec:	c0 a4       	brge	80008900 <_vfprintf_r+0xd4c>
800088ee:	fa cb f9 44 	sub	r11,sp,-1724
800088f2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800088f6:	ec e8 fd 88 	ld.d	r8,r6[-632]
800088fa:	fa e9 00 00 	st.d	sp[0],r8
800088fe:	c1 88       	rjmp	8000892e <_vfprintf_r+0xd7a>
80008900:	fa c8 f9 50 	sub	r8,sp,-1712
80008904:	1a d8       	st.w	--sp,r8
80008906:	fa c8 fa b8 	sub	r8,sp,-1352
8000890a:	04 9a       	mov	r10,r2
8000890c:	1a d8       	st.w	--sp,r8
8000890e:	0c 9b       	mov	r11,r6
80008910:	fa c8 fb b4 	sub	r8,sp,-1100
80008914:	08 9c       	mov	r12,r4
80008916:	1a d8       	st.w	--sp,r8
80008918:	fa c8 f9 40 	sub	r8,sp,-1728
8000891c:	fa c9 ff b4 	sub	r9,sp,-76
80008920:	fe b0 f7 b2 	rcall	80007884 <get_arg>
80008924:	2f dd       	sub	sp,-12
80008926:	f8 ea 00 00 	ld.d	r10,r12[0]
8000892a:	fa eb 00 00 	st.d	sp[0],r10
8000892e:	30 08       	mov	r8,0
80008930:	e0 8f 03 de 	bral	800090ec <_vfprintf_r+0x1538>
80008934:	ee ca ff ff 	sub	r10,r7,-1
80008938:	10 37       	cp.w	r7,r8
8000893a:	c0 b4       	brge	80008950 <_vfprintf_r+0xd9c>
8000893c:	fa c9 f9 44 	sub	r9,sp,-1724
80008940:	14 97       	mov	r7,r10
80008942:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008946:	ec ea fd 88 	ld.d	r10,r6[-632]
8000894a:	fa eb 00 00 	st.d	sp[0],r10
8000894e:	c1 88       	rjmp	8000897e <_vfprintf_r+0xdca>
80008950:	41 09       	lddsp	r9,sp[0x40]
80008952:	59 f8       	cp.w	r8,31
80008954:	e0 89 00 18 	brgt	80008984 <_vfprintf_r+0xdd0>
80008958:	f2 e6 00 00 	ld.d	r6,r9[0]
8000895c:	f2 cb ff f8 	sub	r11,r9,-8
80008960:	fa e7 00 00 	st.d	sp[0],r6
80008964:	51 0b       	stdsp	sp[0x40],r11
80008966:	fa c6 f9 44 	sub	r6,sp,-1724
8000896a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000896e:	fa e6 00 00 	ld.d	r6,sp[0]
80008972:	f2 e7 fd 88 	st.d	r9[-632],r6
80008976:	2f f8       	sub	r8,-1
80008978:	14 97       	mov	r7,r10
8000897a:	fb 48 06 b4 	st.w	sp[1716],r8
8000897e:	40 38       	lddsp	r8,sp[0xc]
80008980:	e0 8f 03 b6 	bral	800090ec <_vfprintf_r+0x1538>
80008984:	f2 e6 00 00 	ld.d	r6,r9[0]
80008988:	40 38       	lddsp	r8,sp[0xc]
8000898a:	fa e7 00 00 	st.d	sp[0],r6
8000898e:	2f 89       	sub	r9,-8
80008990:	14 97       	mov	r7,r10
80008992:	51 09       	stdsp	sp[0x40],r9
80008994:	e0 8f 03 ac 	bral	800090ec <_vfprintf_r+0x1538>
80008998:	ed b5 00 04 	bld	r5,0x4
8000899c:	c1 61       	brne	800089c8 <_vfprintf_r+0xe14>
8000899e:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089a2:	40 3e       	lddsp	lr,sp[0xc]
800089a4:	58 0e       	cp.w	lr,0
800089a6:	c0 80       	breq	800089b6 <_vfprintf_r+0xe02>
800089a8:	10 36       	cp.w	r6,r8
800089aa:	c6 74       	brge	80008a78 <_vfprintf_r+0xec4>
800089ac:	fa cc f9 44 	sub	r12,sp,-1724
800089b0:	f8 06 00 36 	add	r6,r12,r6<<0x3
800089b4:	c8 08       	rjmp	80008ab4 <_vfprintf_r+0xf00>
800089b6:	ee ca ff ff 	sub	r10,r7,-1
800089ba:	10 37       	cp.w	r7,r8
800089bc:	c7 f4       	brge	80008aba <_vfprintf_r+0xf06>
800089be:	fa cb f9 44 	sub	r11,sp,-1724
800089c2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800089c6:	c7 68       	rjmp	80008ab2 <_vfprintf_r+0xefe>
800089c8:	ed b5 00 06 	bld	r5,0x6
800089cc:	c4 a1       	brne	80008a60 <_vfprintf_r+0xeac>
800089ce:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089d2:	40 3c       	lddsp	r12,sp[0xc]
800089d4:	58 0c       	cp.w	r12,0
800089d6:	c1 d0       	breq	80008a10 <_vfprintf_r+0xe5c>
800089d8:	10 36       	cp.w	r6,r8
800089da:	c0 64       	brge	800089e6 <_vfprintf_r+0xe32>
800089dc:	fa cb f9 44 	sub	r11,sp,-1724
800089e0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800089e4:	c1 f8       	rjmp	80008a22 <_vfprintf_r+0xe6e>
800089e6:	fa c8 f9 50 	sub	r8,sp,-1712
800089ea:	1a d8       	st.w	--sp,r8
800089ec:	fa c8 fa b8 	sub	r8,sp,-1352
800089f0:	1a d8       	st.w	--sp,r8
800089f2:	fa c8 fb b4 	sub	r8,sp,-1100
800089f6:	1a d8       	st.w	--sp,r8
800089f8:	fa c8 f9 40 	sub	r8,sp,-1728
800089fc:	fa c9 ff b4 	sub	r9,sp,-76
80008a00:	04 9a       	mov	r10,r2
80008a02:	0c 9b       	mov	r11,r6
80008a04:	08 9c       	mov	r12,r4
80008a06:	fe b0 f7 3f 	rcall	80007884 <get_arg>
80008a0a:	2f dd       	sub	sp,-12
80008a0c:	98 18       	ld.sh	r8,r12[0x2]
80008a0e:	c2 68       	rjmp	80008a5a <_vfprintf_r+0xea6>
80008a10:	ee ca ff ff 	sub	r10,r7,-1
80008a14:	10 37       	cp.w	r7,r8
80008a16:	c0 94       	brge	80008a28 <_vfprintf_r+0xe74>
80008a18:	fa c9 f9 44 	sub	r9,sp,-1724
80008a1c:	14 97       	mov	r7,r10
80008a1e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008a22:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008a26:	c1 a8       	rjmp	80008a5a <_vfprintf_r+0xea6>
80008a28:	41 09       	lddsp	r9,sp[0x40]
80008a2a:	59 f8       	cp.w	r8,31
80008a2c:	e0 89 00 13 	brgt	80008a52 <_vfprintf_r+0xe9e>
80008a30:	f2 cb ff fc 	sub	r11,r9,-4
80008a34:	51 0b       	stdsp	sp[0x40],r11
80008a36:	72 09       	ld.w	r9,r9[0x0]
80008a38:	fa c6 f9 44 	sub	r6,sp,-1724
80008a3c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008a40:	2f f8       	sub	r8,-1
80008a42:	f7 49 fd 88 	st.w	r11[-632],r9
80008a46:	fb 48 06 b4 	st.w	sp[1716],r8
80008a4a:	14 97       	mov	r7,r10
80008a4c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008a50:	c0 58       	rjmp	80008a5a <_vfprintf_r+0xea6>
80008a52:	92 18       	ld.sh	r8,r9[0x2]
80008a54:	14 97       	mov	r7,r10
80008a56:	2f c9       	sub	r9,-4
80008a58:	51 09       	stdsp	sp[0x40],r9
80008a5a:	5c 78       	castu.h	r8
80008a5c:	50 18       	stdsp	sp[0x4],r8
80008a5e:	c4 68       	rjmp	80008aea <_vfprintf_r+0xf36>
80008a60:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a64:	40 3c       	lddsp	r12,sp[0xc]
80008a66:	58 0c       	cp.w	r12,0
80008a68:	c1 d0       	breq	80008aa2 <_vfprintf_r+0xeee>
80008a6a:	10 36       	cp.w	r6,r8
80008a6c:	c0 64       	brge	80008a78 <_vfprintf_r+0xec4>
80008a6e:	fa cb f9 44 	sub	r11,sp,-1724
80008a72:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a76:	c1 f8       	rjmp	80008ab4 <_vfprintf_r+0xf00>
80008a78:	fa c8 f9 50 	sub	r8,sp,-1712
80008a7c:	1a d8       	st.w	--sp,r8
80008a7e:	fa c8 fa b8 	sub	r8,sp,-1352
80008a82:	0c 9b       	mov	r11,r6
80008a84:	1a d8       	st.w	--sp,r8
80008a86:	fa c8 fb b4 	sub	r8,sp,-1100
80008a8a:	04 9a       	mov	r10,r2
80008a8c:	1a d8       	st.w	--sp,r8
80008a8e:	08 9c       	mov	r12,r4
80008a90:	fa c8 f9 40 	sub	r8,sp,-1728
80008a94:	fa c9 ff b4 	sub	r9,sp,-76
80008a98:	fe b0 f6 f6 	rcall	80007884 <get_arg>
80008a9c:	2f dd       	sub	sp,-12
80008a9e:	78 0b       	ld.w	r11,r12[0x0]
80008aa0:	c2 48       	rjmp	80008ae8 <_vfprintf_r+0xf34>
80008aa2:	ee ca ff ff 	sub	r10,r7,-1
80008aa6:	10 37       	cp.w	r7,r8
80008aa8:	c0 94       	brge	80008aba <_vfprintf_r+0xf06>
80008aaa:	fa c9 f9 44 	sub	r9,sp,-1724
80008aae:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ab2:	14 97       	mov	r7,r10
80008ab4:	ec fb fd 88 	ld.w	r11,r6[-632]
80008ab8:	c1 88       	rjmp	80008ae8 <_vfprintf_r+0xf34>
80008aba:	41 09       	lddsp	r9,sp[0x40]
80008abc:	59 f8       	cp.w	r8,31
80008abe:	e0 89 00 11 	brgt	80008ae0 <_vfprintf_r+0xf2c>
80008ac2:	f2 cb ff fc 	sub	r11,r9,-4
80008ac6:	51 0b       	stdsp	sp[0x40],r11
80008ac8:	fa c6 f9 44 	sub	r6,sp,-1724
80008acc:	72 0b       	ld.w	r11,r9[0x0]
80008ace:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ad2:	f3 4b fd 88 	st.w	r9[-632],r11
80008ad6:	2f f8       	sub	r8,-1
80008ad8:	14 97       	mov	r7,r10
80008ada:	fb 48 06 b4 	st.w	sp[1716],r8
80008ade:	c0 58       	rjmp	80008ae8 <_vfprintf_r+0xf34>
80008ae0:	72 0b       	ld.w	r11,r9[0x0]
80008ae2:	14 97       	mov	r7,r10
80008ae4:	2f c9       	sub	r9,-4
80008ae6:	51 09       	stdsp	sp[0x40],r9
80008ae8:	50 1b       	stdsp	sp[0x4],r11
80008aea:	30 0e       	mov	lr,0
80008aec:	50 0e       	stdsp	sp[0x0],lr
80008aee:	1c 98       	mov	r8,lr
80008af0:	e0 8f 02 fe 	bral	800090ec <_vfprintf_r+0x1538>
80008af4:	50 a7       	stdsp	sp[0x28],r7
80008af6:	50 80       	stdsp	sp[0x20],r0
80008af8:	0c 97       	mov	r7,r6
80008afa:	04 94       	mov	r4,r2
80008afc:	06 96       	mov	r6,r3
80008afe:	02 92       	mov	r2,r1
80008b00:	40 93       	lddsp	r3,sp[0x24]
80008b02:	40 41       	lddsp	r1,sp[0x10]
80008b04:	0e 99       	mov	r9,r7
80008b06:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b0a:	40 3c       	lddsp	r12,sp[0xc]
80008b0c:	58 0c       	cp.w	r12,0
80008b0e:	c1 d0       	breq	80008b48 <_vfprintf_r+0xf94>
80008b10:	10 36       	cp.w	r6,r8
80008b12:	c0 64       	brge	80008b1e <_vfprintf_r+0xf6a>
80008b14:	fa cb f9 44 	sub	r11,sp,-1724
80008b18:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b1c:	c1 d8       	rjmp	80008b56 <_vfprintf_r+0xfa2>
80008b1e:	fa c8 f9 50 	sub	r8,sp,-1712
80008b22:	1a d8       	st.w	--sp,r8
80008b24:	fa c8 fa b8 	sub	r8,sp,-1352
80008b28:	1a d8       	st.w	--sp,r8
80008b2a:	fa c8 fb b4 	sub	r8,sp,-1100
80008b2e:	1a d8       	st.w	--sp,r8
80008b30:	fa c9 ff b4 	sub	r9,sp,-76
80008b34:	fa c8 f9 40 	sub	r8,sp,-1728
80008b38:	04 9a       	mov	r10,r2
80008b3a:	0c 9b       	mov	r11,r6
80008b3c:	08 9c       	mov	r12,r4
80008b3e:	fe b0 f6 a3 	rcall	80007884 <get_arg>
80008b42:	2f dd       	sub	sp,-12
80008b44:	78 09       	ld.w	r9,r12[0x0]
80008b46:	c2 18       	rjmp	80008b88 <_vfprintf_r+0xfd4>
80008b48:	2f f7       	sub	r7,-1
80008b4a:	10 39       	cp.w	r9,r8
80008b4c:	c0 84       	brge	80008b5c <_vfprintf_r+0xfa8>
80008b4e:	fa ca f9 44 	sub	r10,sp,-1724
80008b52:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008b56:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008b5a:	c1 78       	rjmp	80008b88 <_vfprintf_r+0xfd4>
80008b5c:	41 09       	lddsp	r9,sp[0x40]
80008b5e:	59 f8       	cp.w	r8,31
80008b60:	e0 89 00 10 	brgt	80008b80 <_vfprintf_r+0xfcc>
80008b64:	f2 ca ff fc 	sub	r10,r9,-4
80008b68:	51 0a       	stdsp	sp[0x40],r10
80008b6a:	fa c6 f9 44 	sub	r6,sp,-1724
80008b6e:	72 09       	ld.w	r9,r9[0x0]
80008b70:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008b74:	f5 49 fd 88 	st.w	r10[-632],r9
80008b78:	2f f8       	sub	r8,-1
80008b7a:	fb 48 06 b4 	st.w	sp[1716],r8
80008b7e:	c0 58       	rjmp	80008b88 <_vfprintf_r+0xfd4>
80008b80:	f2 c8 ff fc 	sub	r8,r9,-4
80008b84:	51 08       	stdsp	sp[0x40],r8
80008b86:	72 09       	ld.w	r9,r9[0x0]
80008b88:	33 08       	mov	r8,48
80008b8a:	fb 68 06 b8 	st.b	sp[1720],r8
80008b8e:	37 88       	mov	r8,120
80008b90:	30 0e       	mov	lr,0
80008b92:	fb 68 06 b9 	st.b	sp[1721],r8
80008b96:	fe cc c3 62 	sub	r12,pc,-15518
80008b9a:	50 19       	stdsp	sp[0x4],r9
80008b9c:	a1 b5       	sbr	r5,0x1
80008b9e:	50 0e       	stdsp	sp[0x0],lr
80008ba0:	50 dc       	stdsp	sp[0x34],r12
80008ba2:	30 28       	mov	r8,2
80008ba4:	37 80       	mov	r0,120
80008ba6:	e0 8f 02 a3 	bral	800090ec <_vfprintf_r+0x1538>
80008baa:	50 a7       	stdsp	sp[0x28],r7
80008bac:	50 80       	stdsp	sp[0x20],r0
80008bae:	10 90       	mov	r0,r8
80008bb0:	30 08       	mov	r8,0
80008bb2:	fb 68 06 bb 	st.b	sp[1723],r8
80008bb6:	0c 97       	mov	r7,r6
80008bb8:	04 94       	mov	r4,r2
80008bba:	06 96       	mov	r6,r3
80008bbc:	02 92       	mov	r2,r1
80008bbe:	40 93       	lddsp	r3,sp[0x24]
80008bc0:	40 41       	lddsp	r1,sp[0x10]
80008bc2:	0e 99       	mov	r9,r7
80008bc4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008bc8:	40 3b       	lddsp	r11,sp[0xc]
80008bca:	58 0b       	cp.w	r11,0
80008bcc:	c1 d0       	breq	80008c06 <_vfprintf_r+0x1052>
80008bce:	10 36       	cp.w	r6,r8
80008bd0:	c0 64       	brge	80008bdc <_vfprintf_r+0x1028>
80008bd2:	fa ca f9 44 	sub	r10,sp,-1724
80008bd6:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008bda:	c1 d8       	rjmp	80008c14 <_vfprintf_r+0x1060>
80008bdc:	fa c8 f9 50 	sub	r8,sp,-1712
80008be0:	1a d8       	st.w	--sp,r8
80008be2:	fa c8 fa b8 	sub	r8,sp,-1352
80008be6:	1a d8       	st.w	--sp,r8
80008be8:	fa c8 fb b4 	sub	r8,sp,-1100
80008bec:	0c 9b       	mov	r11,r6
80008bee:	1a d8       	st.w	--sp,r8
80008bf0:	04 9a       	mov	r10,r2
80008bf2:	fa c8 f9 40 	sub	r8,sp,-1728
80008bf6:	fa c9 ff b4 	sub	r9,sp,-76
80008bfa:	08 9c       	mov	r12,r4
80008bfc:	fe b0 f6 44 	rcall	80007884 <get_arg>
80008c00:	2f dd       	sub	sp,-12
80008c02:	78 06       	ld.w	r6,r12[0x0]
80008c04:	c2 08       	rjmp	80008c44 <_vfprintf_r+0x1090>
80008c06:	2f f7       	sub	r7,-1
80008c08:	10 39       	cp.w	r9,r8
80008c0a:	c0 84       	brge	80008c1a <_vfprintf_r+0x1066>
80008c0c:	fa c9 f9 44 	sub	r9,sp,-1724
80008c10:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008c14:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008c18:	c1 68       	rjmp	80008c44 <_vfprintf_r+0x1090>
80008c1a:	41 09       	lddsp	r9,sp[0x40]
80008c1c:	59 f8       	cp.w	r8,31
80008c1e:	e0 89 00 10 	brgt	80008c3e <_vfprintf_r+0x108a>
80008c22:	f2 ca ff fc 	sub	r10,r9,-4
80008c26:	51 0a       	stdsp	sp[0x40],r10
80008c28:	72 06       	ld.w	r6,r9[0x0]
80008c2a:	fa ce f9 44 	sub	lr,sp,-1724
80008c2e:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008c32:	f3 46 fd 88 	st.w	r9[-632],r6
80008c36:	2f f8       	sub	r8,-1
80008c38:	fb 48 06 b4 	st.w	sp[1716],r8
80008c3c:	c0 48       	rjmp	80008c44 <_vfprintf_r+0x1090>
80008c3e:	72 06       	ld.w	r6,r9[0x0]
80008c40:	2f c9       	sub	r9,-4
80008c42:	51 09       	stdsp	sp[0x40],r9
80008c44:	40 2c       	lddsp	r12,sp[0x8]
80008c46:	58 0c       	cp.w	r12,0
80008c48:	c1 05       	brlt	80008c68 <_vfprintf_r+0x10b4>
80008c4a:	18 9a       	mov	r10,r12
80008c4c:	30 0b       	mov	r11,0
80008c4e:	0c 9c       	mov	r12,r6
80008c50:	e0 a0 10 fa 	rcall	8000ae44 <memchr>
80008c54:	e0 80 02 df 	breq	80009212 <_vfprintf_r+0x165e>
80008c58:	f8 06 01 02 	sub	r2,r12,r6
80008c5c:	40 2b       	lddsp	r11,sp[0x8]
80008c5e:	16 32       	cp.w	r2,r11
80008c60:	e0 89 02 d9 	brgt	80009212 <_vfprintf_r+0x165e>
80008c64:	e0 8f 02 d4 	bral	8000920c <_vfprintf_r+0x1658>
80008c68:	30 0a       	mov	r10,0
80008c6a:	0c 9c       	mov	r12,r6
80008c6c:	50 2a       	stdsp	sp[0x8],r10
80008c6e:	e0 a0 14 18 	rcall	8000b49e <strlen>
80008c72:	18 92       	mov	r2,r12
80008c74:	e0 8f 02 d2 	bral	80009218 <_vfprintf_r+0x1664>
80008c78:	50 a7       	stdsp	sp[0x28],r7
80008c7a:	50 80       	stdsp	sp[0x20],r0
80008c7c:	0c 97       	mov	r7,r6
80008c7e:	04 94       	mov	r4,r2
80008c80:	06 96       	mov	r6,r3
80008c82:	02 92       	mov	r2,r1
80008c84:	40 93       	lddsp	r3,sp[0x24]
80008c86:	10 90       	mov	r0,r8
80008c88:	40 41       	lddsp	r1,sp[0x10]
80008c8a:	a5 a5       	sbr	r5,0x4
80008c8c:	c0 a8       	rjmp	80008ca0 <_vfprintf_r+0x10ec>
80008c8e:	50 a7       	stdsp	sp[0x28],r7
80008c90:	50 80       	stdsp	sp[0x20],r0
80008c92:	0c 97       	mov	r7,r6
80008c94:	04 94       	mov	r4,r2
80008c96:	06 96       	mov	r6,r3
80008c98:	02 92       	mov	r2,r1
80008c9a:	40 93       	lddsp	r3,sp[0x24]
80008c9c:	10 90       	mov	r0,r8
80008c9e:	40 41       	lddsp	r1,sp[0x10]
80008ca0:	ed b5 00 05 	bld	r5,0x5
80008ca4:	c5 61       	brne	80008d50 <_vfprintf_r+0x119c>
80008ca6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008caa:	40 39       	lddsp	r9,sp[0xc]
80008cac:	58 09       	cp.w	r9,0
80008cae:	c2 10       	breq	80008cf0 <_vfprintf_r+0x113c>
80008cb0:	10 36       	cp.w	r6,r8
80008cb2:	c0 74       	brge	80008cc0 <_vfprintf_r+0x110c>
80008cb4:	fa c8 f9 44 	sub	r8,sp,-1724
80008cb8:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008cbc:	c2 38       	rjmp	80008d02 <_vfprintf_r+0x114e>
80008cbe:	d7 03       	nop
80008cc0:	fa c8 f9 50 	sub	r8,sp,-1712
80008cc4:	1a d8       	st.w	--sp,r8
80008cc6:	fa c8 fa b8 	sub	r8,sp,-1352
80008cca:	1a d8       	st.w	--sp,r8
80008ccc:	fa c8 fb b4 	sub	r8,sp,-1100
80008cd0:	1a d8       	st.w	--sp,r8
80008cd2:	fa c8 f9 40 	sub	r8,sp,-1728
80008cd6:	fa c9 ff b4 	sub	r9,sp,-76
80008cda:	04 9a       	mov	r10,r2
80008cdc:	0c 9b       	mov	r11,r6
80008cde:	08 9c       	mov	r12,r4
80008ce0:	fe b0 f5 d2 	rcall	80007884 <get_arg>
80008ce4:	2f dd       	sub	sp,-12
80008ce6:	f8 e8 00 00 	ld.d	r8,r12[0]
80008cea:	fa e9 00 00 	st.d	sp[0],r8
80008cee:	c2 e8       	rjmp	80008d4a <_vfprintf_r+0x1196>
80008cf0:	ee ca ff ff 	sub	r10,r7,-1
80008cf4:	10 37       	cp.w	r7,r8
80008cf6:	c0 b4       	brge	80008d0c <_vfprintf_r+0x1158>
80008cf8:	fa c8 f9 44 	sub	r8,sp,-1724
80008cfc:	14 97       	mov	r7,r10
80008cfe:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008d02:	ec ea fd 88 	ld.d	r10,r6[-632]
80008d06:	fa eb 00 00 	st.d	sp[0],r10
80008d0a:	c2 08       	rjmp	80008d4a <_vfprintf_r+0x1196>
80008d0c:	41 09       	lddsp	r9,sp[0x40]
80008d0e:	59 f8       	cp.w	r8,31
80008d10:	e0 89 00 16 	brgt	80008d3c <_vfprintf_r+0x1188>
80008d14:	f2 e6 00 00 	ld.d	r6,r9[0]
80008d18:	f2 cb ff f8 	sub	r11,r9,-8
80008d1c:	fa e7 00 00 	st.d	sp[0],r6
80008d20:	51 0b       	stdsp	sp[0x40],r11
80008d22:	fa c6 f9 44 	sub	r6,sp,-1724
80008d26:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d2a:	fa e6 00 00 	ld.d	r6,sp[0]
80008d2e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008d32:	2f f8       	sub	r8,-1
80008d34:	14 97       	mov	r7,r10
80008d36:	fb 48 06 b4 	st.w	sp[1716],r8
80008d3a:	c0 88       	rjmp	80008d4a <_vfprintf_r+0x1196>
80008d3c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008d40:	2f 89       	sub	r9,-8
80008d42:	fa e7 00 00 	st.d	sp[0],r6
80008d46:	51 09       	stdsp	sp[0x40],r9
80008d48:	14 97       	mov	r7,r10
80008d4a:	30 18       	mov	r8,1
80008d4c:	e0 8f 01 d0 	bral	800090ec <_vfprintf_r+0x1538>
80008d50:	ed b5 00 04 	bld	r5,0x4
80008d54:	c1 61       	brne	80008d80 <_vfprintf_r+0x11cc>
80008d56:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d5a:	40 3e       	lddsp	lr,sp[0xc]
80008d5c:	58 0e       	cp.w	lr,0
80008d5e:	c0 80       	breq	80008d6e <_vfprintf_r+0x11ba>
80008d60:	10 36       	cp.w	r6,r8
80008d62:	c6 74       	brge	80008e30 <_vfprintf_r+0x127c>
80008d64:	fa cc f9 44 	sub	r12,sp,-1724
80008d68:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008d6c:	c8 08       	rjmp	80008e6c <_vfprintf_r+0x12b8>
80008d6e:	ee ca ff ff 	sub	r10,r7,-1
80008d72:	10 37       	cp.w	r7,r8
80008d74:	c7 f4       	brge	80008e72 <_vfprintf_r+0x12be>
80008d76:	fa cb f9 44 	sub	r11,sp,-1724
80008d7a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d7e:	c7 68       	rjmp	80008e6a <_vfprintf_r+0x12b6>
80008d80:	ed b5 00 06 	bld	r5,0x6
80008d84:	c4 a1       	brne	80008e18 <_vfprintf_r+0x1264>
80008d86:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d8a:	40 3c       	lddsp	r12,sp[0xc]
80008d8c:	58 0c       	cp.w	r12,0
80008d8e:	c1 d0       	breq	80008dc8 <_vfprintf_r+0x1214>
80008d90:	10 36       	cp.w	r6,r8
80008d92:	c0 64       	brge	80008d9e <_vfprintf_r+0x11ea>
80008d94:	fa cb f9 44 	sub	r11,sp,-1724
80008d98:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d9c:	c1 f8       	rjmp	80008dda <_vfprintf_r+0x1226>
80008d9e:	fa c8 f9 50 	sub	r8,sp,-1712
80008da2:	1a d8       	st.w	--sp,r8
80008da4:	fa c8 fa b8 	sub	r8,sp,-1352
80008da8:	1a d8       	st.w	--sp,r8
80008daa:	fa c8 fb b4 	sub	r8,sp,-1100
80008dae:	1a d8       	st.w	--sp,r8
80008db0:	fa c8 f9 40 	sub	r8,sp,-1728
80008db4:	fa c9 ff b4 	sub	r9,sp,-76
80008db8:	04 9a       	mov	r10,r2
80008dba:	0c 9b       	mov	r11,r6
80008dbc:	08 9c       	mov	r12,r4
80008dbe:	fe b0 f5 63 	rcall	80007884 <get_arg>
80008dc2:	2f dd       	sub	sp,-12
80008dc4:	98 18       	ld.sh	r8,r12[0x2]
80008dc6:	c2 68       	rjmp	80008e12 <_vfprintf_r+0x125e>
80008dc8:	ee ca ff ff 	sub	r10,r7,-1
80008dcc:	10 37       	cp.w	r7,r8
80008dce:	c0 94       	brge	80008de0 <_vfprintf_r+0x122c>
80008dd0:	fa c9 f9 44 	sub	r9,sp,-1724
80008dd4:	14 97       	mov	r7,r10
80008dd6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008dda:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008dde:	c1 a8       	rjmp	80008e12 <_vfprintf_r+0x125e>
80008de0:	41 09       	lddsp	r9,sp[0x40]
80008de2:	59 f8       	cp.w	r8,31
80008de4:	e0 89 00 13 	brgt	80008e0a <_vfprintf_r+0x1256>
80008de8:	f2 cb ff fc 	sub	r11,r9,-4
80008dec:	51 0b       	stdsp	sp[0x40],r11
80008dee:	72 09       	ld.w	r9,r9[0x0]
80008df0:	fa c6 f9 44 	sub	r6,sp,-1724
80008df4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008df8:	2f f8       	sub	r8,-1
80008dfa:	f7 49 fd 88 	st.w	r11[-632],r9
80008dfe:	fb 48 06 b4 	st.w	sp[1716],r8
80008e02:	14 97       	mov	r7,r10
80008e04:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008e08:	c0 58       	rjmp	80008e12 <_vfprintf_r+0x125e>
80008e0a:	92 18       	ld.sh	r8,r9[0x2]
80008e0c:	14 97       	mov	r7,r10
80008e0e:	2f c9       	sub	r9,-4
80008e10:	51 09       	stdsp	sp[0x40],r9
80008e12:	5c 78       	castu.h	r8
80008e14:	50 18       	stdsp	sp[0x4],r8
80008e16:	c4 68       	rjmp	80008ea2 <_vfprintf_r+0x12ee>
80008e18:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e1c:	40 3c       	lddsp	r12,sp[0xc]
80008e1e:	58 0c       	cp.w	r12,0
80008e20:	c1 d0       	breq	80008e5a <_vfprintf_r+0x12a6>
80008e22:	10 36       	cp.w	r6,r8
80008e24:	c0 64       	brge	80008e30 <_vfprintf_r+0x127c>
80008e26:	fa cb f9 44 	sub	r11,sp,-1724
80008e2a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e2e:	c1 f8       	rjmp	80008e6c <_vfprintf_r+0x12b8>
80008e30:	fa c8 f9 50 	sub	r8,sp,-1712
80008e34:	1a d8       	st.w	--sp,r8
80008e36:	fa c8 fa b8 	sub	r8,sp,-1352
80008e3a:	0c 9b       	mov	r11,r6
80008e3c:	1a d8       	st.w	--sp,r8
80008e3e:	fa c8 fb b4 	sub	r8,sp,-1100
80008e42:	04 9a       	mov	r10,r2
80008e44:	1a d8       	st.w	--sp,r8
80008e46:	08 9c       	mov	r12,r4
80008e48:	fa c8 f9 40 	sub	r8,sp,-1728
80008e4c:	fa c9 ff b4 	sub	r9,sp,-76
80008e50:	fe b0 f5 1a 	rcall	80007884 <get_arg>
80008e54:	2f dd       	sub	sp,-12
80008e56:	78 0b       	ld.w	r11,r12[0x0]
80008e58:	c2 48       	rjmp	80008ea0 <_vfprintf_r+0x12ec>
80008e5a:	ee ca ff ff 	sub	r10,r7,-1
80008e5e:	10 37       	cp.w	r7,r8
80008e60:	c0 94       	brge	80008e72 <_vfprintf_r+0x12be>
80008e62:	fa c9 f9 44 	sub	r9,sp,-1724
80008e66:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e6a:	14 97       	mov	r7,r10
80008e6c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008e70:	c1 88       	rjmp	80008ea0 <_vfprintf_r+0x12ec>
80008e72:	41 09       	lddsp	r9,sp[0x40]
80008e74:	59 f8       	cp.w	r8,31
80008e76:	e0 89 00 11 	brgt	80008e98 <_vfprintf_r+0x12e4>
80008e7a:	f2 cb ff fc 	sub	r11,r9,-4
80008e7e:	51 0b       	stdsp	sp[0x40],r11
80008e80:	fa c6 f9 44 	sub	r6,sp,-1724
80008e84:	72 0b       	ld.w	r11,r9[0x0]
80008e86:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e8a:	f3 4b fd 88 	st.w	r9[-632],r11
80008e8e:	2f f8       	sub	r8,-1
80008e90:	14 97       	mov	r7,r10
80008e92:	fb 48 06 b4 	st.w	sp[1716],r8
80008e96:	c0 58       	rjmp	80008ea0 <_vfprintf_r+0x12ec>
80008e98:	72 0b       	ld.w	r11,r9[0x0]
80008e9a:	14 97       	mov	r7,r10
80008e9c:	2f c9       	sub	r9,-4
80008e9e:	51 09       	stdsp	sp[0x40],r9
80008ea0:	50 1b       	stdsp	sp[0x4],r11
80008ea2:	30 0e       	mov	lr,0
80008ea4:	30 18       	mov	r8,1
80008ea6:	50 0e       	stdsp	sp[0x0],lr
80008ea8:	c2 29       	rjmp	800090ec <_vfprintf_r+0x1538>
80008eaa:	50 a7       	stdsp	sp[0x28],r7
80008eac:	50 80       	stdsp	sp[0x20],r0
80008eae:	0c 97       	mov	r7,r6
80008eb0:	04 94       	mov	r4,r2
80008eb2:	06 96       	mov	r6,r3
80008eb4:	02 92       	mov	r2,r1
80008eb6:	fe cc c6 82 	sub	r12,pc,-14718
80008eba:	40 93       	lddsp	r3,sp[0x24]
80008ebc:	10 90       	mov	r0,r8
80008ebe:	40 41       	lddsp	r1,sp[0x10]
80008ec0:	50 dc       	stdsp	sp[0x34],r12
80008ec2:	ed b5 00 05 	bld	r5,0x5
80008ec6:	c5 51       	brne	80008f70 <_vfprintf_r+0x13bc>
80008ec8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ecc:	40 3b       	lddsp	r11,sp[0xc]
80008ece:	58 0b       	cp.w	r11,0
80008ed0:	c2 20       	breq	80008f14 <_vfprintf_r+0x1360>
80008ed2:	10 36       	cp.w	r6,r8
80008ed4:	c0 a4       	brge	80008ee8 <_vfprintf_r+0x1334>
80008ed6:	fa ca f9 44 	sub	r10,sp,-1724
80008eda:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008ede:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008ee2:	fa e9 00 00 	st.d	sp[0],r8
80008ee6:	cf 28       	rjmp	800090ca <_vfprintf_r+0x1516>
80008ee8:	fa c8 f9 50 	sub	r8,sp,-1712
80008eec:	1a d8       	st.w	--sp,r8
80008eee:	fa c8 fa b8 	sub	r8,sp,-1352
80008ef2:	04 9a       	mov	r10,r2
80008ef4:	1a d8       	st.w	--sp,r8
80008ef6:	0c 9b       	mov	r11,r6
80008ef8:	fa c8 fb b4 	sub	r8,sp,-1100
80008efc:	08 9c       	mov	r12,r4
80008efe:	1a d8       	st.w	--sp,r8
80008f00:	fa c8 f9 40 	sub	r8,sp,-1728
80008f04:	fa c9 ff b4 	sub	r9,sp,-76
80008f08:	fe b0 f4 be 	rcall	80007884 <get_arg>
80008f0c:	2f dd       	sub	sp,-12
80008f0e:	f8 ea 00 00 	ld.d	r10,r12[0]
80008f12:	c0 c8       	rjmp	80008f2a <_vfprintf_r+0x1376>
80008f14:	ee ca ff ff 	sub	r10,r7,-1
80008f18:	10 37       	cp.w	r7,r8
80008f1a:	c0 b4       	brge	80008f30 <_vfprintf_r+0x137c>
80008f1c:	fa c9 f9 44 	sub	r9,sp,-1724
80008f20:	14 97       	mov	r7,r10
80008f22:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f26:	ec ea fd 88 	ld.d	r10,r6[-632]
80008f2a:	fa eb 00 00 	st.d	sp[0],r10
80008f2e:	cc e8       	rjmp	800090ca <_vfprintf_r+0x1516>
80008f30:	41 09       	lddsp	r9,sp[0x40]
80008f32:	59 f8       	cp.w	r8,31
80008f34:	e0 89 00 16 	brgt	80008f60 <_vfprintf_r+0x13ac>
80008f38:	f2 e6 00 00 	ld.d	r6,r9[0]
80008f3c:	f2 cb ff f8 	sub	r11,r9,-8
80008f40:	fa e7 00 00 	st.d	sp[0],r6
80008f44:	51 0b       	stdsp	sp[0x40],r11
80008f46:	fa c6 f9 44 	sub	r6,sp,-1724
80008f4a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008f4e:	fa e6 00 00 	ld.d	r6,sp[0]
80008f52:	f2 e7 fd 88 	st.d	r9[-632],r6
80008f56:	2f f8       	sub	r8,-1
80008f58:	14 97       	mov	r7,r10
80008f5a:	fb 48 06 b4 	st.w	sp[1716],r8
80008f5e:	cb 68       	rjmp	800090ca <_vfprintf_r+0x1516>
80008f60:	f2 e6 00 00 	ld.d	r6,r9[0]
80008f64:	2f 89       	sub	r9,-8
80008f66:	fa e7 00 00 	st.d	sp[0],r6
80008f6a:	51 09       	stdsp	sp[0x40],r9
80008f6c:	14 97       	mov	r7,r10
80008f6e:	ca e8       	rjmp	800090ca <_vfprintf_r+0x1516>
80008f70:	ed b5 00 04 	bld	r5,0x4
80008f74:	c1 71       	brne	80008fa2 <_vfprintf_r+0x13ee>
80008f76:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f7a:	40 3e       	lddsp	lr,sp[0xc]
80008f7c:	58 0e       	cp.w	lr,0
80008f7e:	c0 80       	breq	80008f8e <_vfprintf_r+0x13da>
80008f80:	10 36       	cp.w	r6,r8
80008f82:	c6 94       	brge	80009054 <_vfprintf_r+0x14a0>
80008f84:	fa cc f9 44 	sub	r12,sp,-1724
80008f88:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008f8c:	c8 28       	rjmp	80009090 <_vfprintf_r+0x14dc>
80008f8e:	ee ca ff ff 	sub	r10,r7,-1
80008f92:	10 37       	cp.w	r7,r8
80008f94:	e0 84 00 81 	brge	80009096 <_vfprintf_r+0x14e2>
80008f98:	fa cb f9 44 	sub	r11,sp,-1724
80008f9c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fa0:	c7 78       	rjmp	8000908e <_vfprintf_r+0x14da>
80008fa2:	ed b5 00 06 	bld	r5,0x6
80008fa6:	c4 b1       	brne	8000903c <_vfprintf_r+0x1488>
80008fa8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fac:	40 3c       	lddsp	r12,sp[0xc]
80008fae:	58 0c       	cp.w	r12,0
80008fb0:	c1 d0       	breq	80008fea <_vfprintf_r+0x1436>
80008fb2:	10 36       	cp.w	r6,r8
80008fb4:	c0 64       	brge	80008fc0 <_vfprintf_r+0x140c>
80008fb6:	fa cb f9 44 	sub	r11,sp,-1724
80008fba:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fbe:	c1 f8       	rjmp	80008ffc <_vfprintf_r+0x1448>
80008fc0:	fa c8 f9 50 	sub	r8,sp,-1712
80008fc4:	1a d8       	st.w	--sp,r8
80008fc6:	fa c8 fa b8 	sub	r8,sp,-1352
80008fca:	1a d8       	st.w	--sp,r8
80008fcc:	fa c8 fb b4 	sub	r8,sp,-1100
80008fd0:	1a d8       	st.w	--sp,r8
80008fd2:	fa c8 f9 40 	sub	r8,sp,-1728
80008fd6:	fa c9 ff b4 	sub	r9,sp,-76
80008fda:	04 9a       	mov	r10,r2
80008fdc:	0c 9b       	mov	r11,r6
80008fde:	08 9c       	mov	r12,r4
80008fe0:	fe b0 f4 52 	rcall	80007884 <get_arg>
80008fe4:	2f dd       	sub	sp,-12
80008fe6:	98 18       	ld.sh	r8,r12[0x2]
80008fe8:	c2 78       	rjmp	80009036 <_vfprintf_r+0x1482>
80008fea:	ee ca ff ff 	sub	r10,r7,-1
80008fee:	10 37       	cp.w	r7,r8
80008ff0:	c0 a4       	brge	80009004 <_vfprintf_r+0x1450>
80008ff2:	fa c9 f9 44 	sub	r9,sp,-1724
80008ff6:	14 97       	mov	r7,r10
80008ff8:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ffc:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009000:	c1 b8       	rjmp	80009036 <_vfprintf_r+0x1482>
80009002:	d7 03       	nop
80009004:	41 09       	lddsp	r9,sp[0x40]
80009006:	59 f8       	cp.w	r8,31
80009008:	e0 89 00 13 	brgt	8000902e <_vfprintf_r+0x147a>
8000900c:	f2 cb ff fc 	sub	r11,r9,-4
80009010:	51 0b       	stdsp	sp[0x40],r11
80009012:	72 09       	ld.w	r9,r9[0x0]
80009014:	fa c6 f9 44 	sub	r6,sp,-1724
80009018:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000901c:	2f f8       	sub	r8,-1
8000901e:	f7 49 fd 88 	st.w	r11[-632],r9
80009022:	fb 48 06 b4 	st.w	sp[1716],r8
80009026:	14 97       	mov	r7,r10
80009028:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000902c:	c0 58       	rjmp	80009036 <_vfprintf_r+0x1482>
8000902e:	92 18       	ld.sh	r8,r9[0x2]
80009030:	14 97       	mov	r7,r10
80009032:	2f c9       	sub	r9,-4
80009034:	51 09       	stdsp	sp[0x40],r9
80009036:	5c 78       	castu.h	r8
80009038:	50 18       	stdsp	sp[0x4],r8
8000903a:	c4 68       	rjmp	800090c6 <_vfprintf_r+0x1512>
8000903c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009040:	40 3c       	lddsp	r12,sp[0xc]
80009042:	58 0c       	cp.w	r12,0
80009044:	c1 d0       	breq	8000907e <_vfprintf_r+0x14ca>
80009046:	10 36       	cp.w	r6,r8
80009048:	c0 64       	brge	80009054 <_vfprintf_r+0x14a0>
8000904a:	fa cb f9 44 	sub	r11,sp,-1724
8000904e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009052:	c1 f8       	rjmp	80009090 <_vfprintf_r+0x14dc>
80009054:	fa c8 f9 50 	sub	r8,sp,-1712
80009058:	1a d8       	st.w	--sp,r8
8000905a:	fa c8 fa b8 	sub	r8,sp,-1352
8000905e:	0c 9b       	mov	r11,r6
80009060:	1a d8       	st.w	--sp,r8
80009062:	fa c8 fb b4 	sub	r8,sp,-1100
80009066:	04 9a       	mov	r10,r2
80009068:	1a d8       	st.w	--sp,r8
8000906a:	08 9c       	mov	r12,r4
8000906c:	fa c8 f9 40 	sub	r8,sp,-1728
80009070:	fa c9 ff b4 	sub	r9,sp,-76
80009074:	fe b0 f4 08 	rcall	80007884 <get_arg>
80009078:	2f dd       	sub	sp,-12
8000907a:	78 0b       	ld.w	r11,r12[0x0]
8000907c:	c2 48       	rjmp	800090c4 <_vfprintf_r+0x1510>
8000907e:	ee ca ff ff 	sub	r10,r7,-1
80009082:	10 37       	cp.w	r7,r8
80009084:	c0 94       	brge	80009096 <_vfprintf_r+0x14e2>
80009086:	fa c9 f9 44 	sub	r9,sp,-1724
8000908a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000908e:	14 97       	mov	r7,r10
80009090:	ec fb fd 88 	ld.w	r11,r6[-632]
80009094:	c1 88       	rjmp	800090c4 <_vfprintf_r+0x1510>
80009096:	41 09       	lddsp	r9,sp[0x40]
80009098:	59 f8       	cp.w	r8,31
8000909a:	e0 89 00 11 	brgt	800090bc <_vfprintf_r+0x1508>
8000909e:	f2 cb ff fc 	sub	r11,r9,-4
800090a2:	51 0b       	stdsp	sp[0x40],r11
800090a4:	fa c6 f9 44 	sub	r6,sp,-1724
800090a8:	72 0b       	ld.w	r11,r9[0x0]
800090aa:	ec 08 00 39 	add	r9,r6,r8<<0x3
800090ae:	f3 4b fd 88 	st.w	r9[-632],r11
800090b2:	2f f8       	sub	r8,-1
800090b4:	14 97       	mov	r7,r10
800090b6:	fb 48 06 b4 	st.w	sp[1716],r8
800090ba:	c0 58       	rjmp	800090c4 <_vfprintf_r+0x1510>
800090bc:	72 0b       	ld.w	r11,r9[0x0]
800090be:	14 97       	mov	r7,r10
800090c0:	2f c9       	sub	r9,-4
800090c2:	51 09       	stdsp	sp[0x40],r9
800090c4:	50 1b       	stdsp	sp[0x4],r11
800090c6:	30 0e       	mov	lr,0
800090c8:	50 0e       	stdsp	sp[0x0],lr
800090ca:	40 08       	lddsp	r8,sp[0x0]
800090cc:	40 1c       	lddsp	r12,sp[0x4]
800090ce:	18 48       	or	r8,r12
800090d0:	5f 19       	srne	r9
800090d2:	0a 98       	mov	r8,r5
800090d4:	eb e9 00 09 	and	r9,r5,r9
800090d8:	a1 b8       	sbr	r8,0x1
800090da:	58 09       	cp.w	r9,0
800090dc:	c0 70       	breq	800090ea <_vfprintf_r+0x1536>
800090de:	10 95       	mov	r5,r8
800090e0:	fb 60 06 b9 	st.b	sp[1721],r0
800090e4:	33 08       	mov	r8,48
800090e6:	fb 68 06 b8 	st.b	sp[1720],r8
800090ea:	30 28       	mov	r8,2
800090ec:	30 09       	mov	r9,0
800090ee:	fb 69 06 bb 	st.b	sp[1723],r9
800090f2:	0a 99       	mov	r9,r5
800090f4:	a7 d9       	cbr	r9,0x7
800090f6:	40 2b       	lddsp	r11,sp[0x8]
800090f8:	40 16       	lddsp	r6,sp[0x4]
800090fa:	58 0b       	cp.w	r11,0
800090fc:	5f 1a       	srne	r10
800090fe:	f2 05 17 40 	movge	r5,r9
80009102:	fa c2 f9 78 	sub	r2,sp,-1672
80009106:	40 09       	lddsp	r9,sp[0x0]
80009108:	0c 49       	or	r9,r6
8000910a:	5f 19       	srne	r9
8000910c:	f5 e9 10 09 	or	r9,r10,r9
80009110:	c5 c0       	breq	800091c8 <_vfprintf_r+0x1614>
80009112:	30 19       	mov	r9,1
80009114:	f2 08 18 00 	cp.b	r8,r9
80009118:	c0 60       	breq	80009124 <_vfprintf_r+0x1570>
8000911a:	30 29       	mov	r9,2
8000911c:	f2 08 18 00 	cp.b	r8,r9
80009120:	c0 41       	brne	80009128 <_vfprintf_r+0x1574>
80009122:	c3 c8       	rjmp	8000919a <_vfprintf_r+0x15e6>
80009124:	04 96       	mov	r6,r2
80009126:	c3 08       	rjmp	80009186 <_vfprintf_r+0x15d2>
80009128:	04 96       	mov	r6,r2
8000912a:	fa e8 00 00 	ld.d	r8,sp[0]
8000912e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80009132:	2d 0a       	sub	r10,-48
80009134:	0c fa       	st.b	--r6,r10
80009136:	f0 0b 16 03 	lsr	r11,r8,0x3
8000913a:	f2 0c 16 03 	lsr	r12,r9,0x3
8000913e:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80009142:	18 99       	mov	r9,r12
80009144:	16 98       	mov	r8,r11
80009146:	58 08       	cp.w	r8,0
80009148:	5c 29       	cpc	r9
8000914a:	cf 21       	brne	8000912e <_vfprintf_r+0x157a>
8000914c:	fa e9 00 00 	st.d	sp[0],r8
80009150:	ed b5 00 00 	bld	r5,0x0
80009154:	c4 51       	brne	800091de <_vfprintf_r+0x162a>
80009156:	33 09       	mov	r9,48
80009158:	f2 0a 18 00 	cp.b	r10,r9
8000915c:	c4 10       	breq	800091de <_vfprintf_r+0x162a>
8000915e:	0c f9       	st.b	--r6,r9
80009160:	c3 f8       	rjmp	800091de <_vfprintf_r+0x162a>
80009162:	fa ea 00 00 	ld.d	r10,sp[0]
80009166:	30 a8       	mov	r8,10
80009168:	30 09       	mov	r9,0
8000916a:	e0 a0 16 b5 	rcall	8000bed4 <__avr32_umod64>
8000916e:	30 a8       	mov	r8,10
80009170:	2d 0a       	sub	r10,-48
80009172:	30 09       	mov	r9,0
80009174:	ac 8a       	st.b	r6[0x0],r10
80009176:	fa ea 00 00 	ld.d	r10,sp[0]
8000917a:	fe b0 ea 59 	rcall	8000662c <__avr32_udiv64>
8000917e:	16 99       	mov	r9,r11
80009180:	14 98       	mov	r8,r10
80009182:	fa e9 00 00 	st.d	sp[0],r8
80009186:	20 16       	sub	r6,1
80009188:	fa ea 00 00 	ld.d	r10,sp[0]
8000918c:	58 9a       	cp.w	r10,9
8000918e:	5c 2b       	cpc	r11
80009190:	fe 9b ff e9 	brhi	80009162 <_vfprintf_r+0x15ae>
80009194:	1b f8       	ld.ub	r8,sp[0x7]
80009196:	2d 08       	sub	r8,-48
80009198:	c2 08       	rjmp	800091d8 <_vfprintf_r+0x1624>
8000919a:	04 96       	mov	r6,r2
8000919c:	fa e8 00 00 	ld.d	r8,sp[0]
800091a0:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800091a4:	40 de       	lddsp	lr,sp[0x34]
800091a6:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800091aa:	0c fa       	st.b	--r6,r10
800091ac:	f2 0b 16 04 	lsr	r11,r9,0x4
800091b0:	f0 0a 16 04 	lsr	r10,r8,0x4
800091b4:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800091b8:	16 99       	mov	r9,r11
800091ba:	14 98       	mov	r8,r10
800091bc:	58 08       	cp.w	r8,0
800091be:	5c 29       	cpc	r9
800091c0:	cf 01       	brne	800091a0 <_vfprintf_r+0x15ec>
800091c2:	fa e9 00 00 	st.d	sp[0],r8
800091c6:	c0 c8       	rjmp	800091de <_vfprintf_r+0x162a>
800091c8:	58 08       	cp.w	r8,0
800091ca:	c0 91       	brne	800091dc <_vfprintf_r+0x1628>
800091cc:	ed b5 00 00 	bld	r5,0x0
800091d0:	c0 61       	brne	800091dc <_vfprintf_r+0x1628>
800091d2:	fa c6 f9 79 	sub	r6,sp,-1671
800091d6:	33 08       	mov	r8,48
800091d8:	ac 88       	st.b	r6[0x0],r8
800091da:	c0 28       	rjmp	800091de <_vfprintf_r+0x162a>
800091dc:	04 96       	mov	r6,r2
800091de:	0c 12       	sub	r2,r6
800091e0:	c1 c8       	rjmp	80009218 <_vfprintf_r+0x1664>
800091e2:	50 a7       	stdsp	sp[0x28],r7
800091e4:	50 80       	stdsp	sp[0x20],r0
800091e6:	40 93       	lddsp	r3,sp[0x24]
800091e8:	0c 97       	mov	r7,r6
800091ea:	10 90       	mov	r0,r8
800091ec:	04 94       	mov	r4,r2
800091ee:	40 41       	lddsp	r1,sp[0x10]
800091f0:	58 08       	cp.w	r8,0
800091f2:	e0 80 04 4f 	breq	80009a90 <_vfprintf_r+0x1edc>
800091f6:	fb 68 06 60 	st.b	sp[1632],r8
800091fa:	30 0c       	mov	r12,0
800091fc:	30 08       	mov	r8,0
800091fe:	30 12       	mov	r2,1
80009200:	fb 68 06 bb 	st.b	sp[1723],r8
80009204:	50 2c       	stdsp	sp[0x8],r12
80009206:	fa c6 f9 a0 	sub	r6,sp,-1632
8000920a:	c0 78       	rjmp	80009218 <_vfprintf_r+0x1664>
8000920c:	30 0b       	mov	r11,0
8000920e:	50 2b       	stdsp	sp[0x8],r11
80009210:	c0 48       	rjmp	80009218 <_vfprintf_r+0x1664>
80009212:	40 22       	lddsp	r2,sp[0x8]
80009214:	30 0a       	mov	r10,0
80009216:	50 2a       	stdsp	sp[0x8],r10
80009218:	40 29       	lddsp	r9,sp[0x8]
8000921a:	e4 09 0c 49 	max	r9,r2,r9
8000921e:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009222:	50 39       	stdsp	sp[0xc],r9
80009224:	0a 9e       	mov	lr,r5
80009226:	30 09       	mov	r9,0
80009228:	e2 1e 00 02 	andl	lr,0x2,COH
8000922c:	f2 08 18 00 	cp.b	r8,r9
80009230:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009234:	f7 b8 01 ff 	subne	r8,-1
80009238:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000923c:	0a 9b       	mov	r11,r5
8000923e:	58 0e       	cp.w	lr,0
80009240:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009244:	f7 bc 01 fe 	subne	r12,-2
80009248:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000924c:	e2 1b 00 84 	andl	r11,0x84,COH
80009250:	50 fe       	stdsp	sp[0x3c],lr
80009252:	50 9b       	stdsp	sp[0x24],r11
80009254:	c4 71       	brne	800092e2 <_vfprintf_r+0x172e>
80009256:	40 8a       	lddsp	r10,sp[0x20]
80009258:	40 39       	lddsp	r9,sp[0xc]
8000925a:	12 1a       	sub	r10,r9
8000925c:	50 4a       	stdsp	sp[0x10],r10
8000925e:	58 0a       	cp.w	r10,0
80009260:	e0 89 00 20 	brgt	800092a0 <_vfprintf_r+0x16ec>
80009264:	c3 f8       	rjmp	800092e2 <_vfprintf_r+0x172e>
80009266:	2f 09       	sub	r9,-16
80009268:	2f f8       	sub	r8,-1
8000926a:	fe ce ca 1e 	sub	lr,pc,-13794
8000926e:	31 0c       	mov	r12,16
80009270:	fb 49 06 90 	st.w	sp[1680],r9
80009274:	87 0e       	st.w	r3[0x0],lr
80009276:	87 1c       	st.w	r3[0x4],r12
80009278:	fb 48 06 8c 	st.w	sp[1676],r8
8000927c:	58 78       	cp.w	r8,7
8000927e:	e0 89 00 04 	brgt	80009286 <_vfprintf_r+0x16d2>
80009282:	2f 83       	sub	r3,-8
80009284:	c0 b8       	rjmp	8000929a <_vfprintf_r+0x16e6>
80009286:	fa ca f9 78 	sub	r10,sp,-1672
8000928a:	02 9b       	mov	r11,r1
8000928c:	08 9c       	mov	r12,r4
8000928e:	fe b0 f4 85 	rcall	80007b98 <__sprint_r>
80009292:	e0 81 04 10 	brne	80009ab2 <_vfprintf_r+0x1efe>
80009296:	fa c3 f9 e0 	sub	r3,sp,-1568
8000929a:	40 4b       	lddsp	r11,sp[0x10]
8000929c:	21 0b       	sub	r11,16
8000929e:	50 4b       	stdsp	sp[0x10],r11
800092a0:	fa f9 06 90 	ld.w	r9,sp[1680]
800092a4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092a8:	fe ca ca 5c 	sub	r10,pc,-13732
800092ac:	40 4e       	lddsp	lr,sp[0x10]
800092ae:	59 0e       	cp.w	lr,16
800092b0:	fe 99 ff db 	brgt	80009266 <_vfprintf_r+0x16b2>
800092b4:	1c 09       	add	r9,lr
800092b6:	2f f8       	sub	r8,-1
800092b8:	87 0a       	st.w	r3[0x0],r10
800092ba:	fb 49 06 90 	st.w	sp[1680],r9
800092be:	87 1e       	st.w	r3[0x4],lr
800092c0:	fb 48 06 8c 	st.w	sp[1676],r8
800092c4:	58 78       	cp.w	r8,7
800092c6:	e0 89 00 04 	brgt	800092ce <_vfprintf_r+0x171a>
800092ca:	2f 83       	sub	r3,-8
800092cc:	c0 b8       	rjmp	800092e2 <_vfprintf_r+0x172e>
800092ce:	fa ca f9 78 	sub	r10,sp,-1672
800092d2:	02 9b       	mov	r11,r1
800092d4:	08 9c       	mov	r12,r4
800092d6:	fe b0 f4 61 	rcall	80007b98 <__sprint_r>
800092da:	e0 81 03 ec 	brne	80009ab2 <_vfprintf_r+0x1efe>
800092de:	fa c3 f9 e0 	sub	r3,sp,-1568
800092e2:	30 09       	mov	r9,0
800092e4:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800092e8:	f2 08 18 00 	cp.b	r8,r9
800092ec:	c1 f0       	breq	8000932a <_vfprintf_r+0x1776>
800092ee:	fa f8 06 90 	ld.w	r8,sp[1680]
800092f2:	fa c9 f9 45 	sub	r9,sp,-1723
800092f6:	2f f8       	sub	r8,-1
800092f8:	87 09       	st.w	r3[0x0],r9
800092fa:	fb 48 06 90 	st.w	sp[1680],r8
800092fe:	30 19       	mov	r9,1
80009300:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009304:	87 19       	st.w	r3[0x4],r9
80009306:	2f f8       	sub	r8,-1
80009308:	fb 48 06 8c 	st.w	sp[1676],r8
8000930c:	58 78       	cp.w	r8,7
8000930e:	e0 89 00 04 	brgt	80009316 <_vfprintf_r+0x1762>
80009312:	2f 83       	sub	r3,-8
80009314:	c0 b8       	rjmp	8000932a <_vfprintf_r+0x1776>
80009316:	fa ca f9 78 	sub	r10,sp,-1672
8000931a:	02 9b       	mov	r11,r1
8000931c:	08 9c       	mov	r12,r4
8000931e:	fe b0 f4 3d 	rcall	80007b98 <__sprint_r>
80009322:	e0 81 03 c8 	brne	80009ab2 <_vfprintf_r+0x1efe>
80009326:	fa c3 f9 e0 	sub	r3,sp,-1568
8000932a:	40 fc       	lddsp	r12,sp[0x3c]
8000932c:	58 0c       	cp.w	r12,0
8000932e:	c1 f0       	breq	8000936c <_vfprintf_r+0x17b8>
80009330:	fa f8 06 90 	ld.w	r8,sp[1680]
80009334:	fa c9 f9 48 	sub	r9,sp,-1720
80009338:	2f e8       	sub	r8,-2
8000933a:	87 09       	st.w	r3[0x0],r9
8000933c:	fb 48 06 90 	st.w	sp[1680],r8
80009340:	30 29       	mov	r9,2
80009342:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009346:	87 19       	st.w	r3[0x4],r9
80009348:	2f f8       	sub	r8,-1
8000934a:	fb 48 06 8c 	st.w	sp[1676],r8
8000934e:	58 78       	cp.w	r8,7
80009350:	e0 89 00 04 	brgt	80009358 <_vfprintf_r+0x17a4>
80009354:	2f 83       	sub	r3,-8
80009356:	c0 b8       	rjmp	8000936c <_vfprintf_r+0x17b8>
80009358:	fa ca f9 78 	sub	r10,sp,-1672
8000935c:	02 9b       	mov	r11,r1
8000935e:	08 9c       	mov	r12,r4
80009360:	fe b0 f4 1c 	rcall	80007b98 <__sprint_r>
80009364:	e0 81 03 a7 	brne	80009ab2 <_vfprintf_r+0x1efe>
80009368:	fa c3 f9 e0 	sub	r3,sp,-1568
8000936c:	40 9b       	lddsp	r11,sp[0x24]
8000936e:	e0 4b 00 80 	cp.w	r11,128
80009372:	c4 71       	brne	80009400 <_vfprintf_r+0x184c>
80009374:	40 8a       	lddsp	r10,sp[0x20]
80009376:	40 39       	lddsp	r9,sp[0xc]
80009378:	12 1a       	sub	r10,r9
8000937a:	50 4a       	stdsp	sp[0x10],r10
8000937c:	58 0a       	cp.w	r10,0
8000937e:	e0 89 00 20 	brgt	800093be <_vfprintf_r+0x180a>
80009382:	c3 f8       	rjmp	80009400 <_vfprintf_r+0x184c>
80009384:	2f 09       	sub	r9,-16
80009386:	2f f8       	sub	r8,-1
80009388:	fe ce cb 2c 	sub	lr,pc,-13524
8000938c:	31 0c       	mov	r12,16
8000938e:	fb 49 06 90 	st.w	sp[1680],r9
80009392:	87 0e       	st.w	r3[0x0],lr
80009394:	87 1c       	st.w	r3[0x4],r12
80009396:	fb 48 06 8c 	st.w	sp[1676],r8
8000939a:	58 78       	cp.w	r8,7
8000939c:	e0 89 00 04 	brgt	800093a4 <_vfprintf_r+0x17f0>
800093a0:	2f 83       	sub	r3,-8
800093a2:	c0 b8       	rjmp	800093b8 <_vfprintf_r+0x1804>
800093a4:	fa ca f9 78 	sub	r10,sp,-1672
800093a8:	02 9b       	mov	r11,r1
800093aa:	08 9c       	mov	r12,r4
800093ac:	fe b0 f3 f6 	rcall	80007b98 <__sprint_r>
800093b0:	e0 81 03 81 	brne	80009ab2 <_vfprintf_r+0x1efe>
800093b4:	fa c3 f9 e0 	sub	r3,sp,-1568
800093b8:	40 4b       	lddsp	r11,sp[0x10]
800093ba:	21 0b       	sub	r11,16
800093bc:	50 4b       	stdsp	sp[0x10],r11
800093be:	fa f9 06 90 	ld.w	r9,sp[1680]
800093c2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093c6:	fe ca cb 6a 	sub	r10,pc,-13462
800093ca:	40 4e       	lddsp	lr,sp[0x10]
800093cc:	59 0e       	cp.w	lr,16
800093ce:	fe 99 ff db 	brgt	80009384 <_vfprintf_r+0x17d0>
800093d2:	1c 09       	add	r9,lr
800093d4:	2f f8       	sub	r8,-1
800093d6:	87 0a       	st.w	r3[0x0],r10
800093d8:	fb 49 06 90 	st.w	sp[1680],r9
800093dc:	87 1e       	st.w	r3[0x4],lr
800093de:	fb 48 06 8c 	st.w	sp[1676],r8
800093e2:	58 78       	cp.w	r8,7
800093e4:	e0 89 00 04 	brgt	800093ec <_vfprintf_r+0x1838>
800093e8:	2f 83       	sub	r3,-8
800093ea:	c0 b8       	rjmp	80009400 <_vfprintf_r+0x184c>
800093ec:	fa ca f9 78 	sub	r10,sp,-1672
800093f0:	02 9b       	mov	r11,r1
800093f2:	08 9c       	mov	r12,r4
800093f4:	fe b0 f3 d2 	rcall	80007b98 <__sprint_r>
800093f8:	e0 81 03 5d 	brne	80009ab2 <_vfprintf_r+0x1efe>
800093fc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009400:	40 2c       	lddsp	r12,sp[0x8]
80009402:	04 1c       	sub	r12,r2
80009404:	50 2c       	stdsp	sp[0x8],r12
80009406:	58 0c       	cp.w	r12,0
80009408:	e0 89 00 20 	brgt	80009448 <_vfprintf_r+0x1894>
8000940c:	c3 f8       	rjmp	8000948a <_vfprintf_r+0x18d6>
8000940e:	2f 09       	sub	r9,-16
80009410:	2f f8       	sub	r8,-1
80009412:	fe cb cb b6 	sub	r11,pc,-13386
80009416:	31 0a       	mov	r10,16
80009418:	fb 49 06 90 	st.w	sp[1680],r9
8000941c:	87 0b       	st.w	r3[0x0],r11
8000941e:	87 1a       	st.w	r3[0x4],r10
80009420:	fb 48 06 8c 	st.w	sp[1676],r8
80009424:	58 78       	cp.w	r8,7
80009426:	e0 89 00 04 	brgt	8000942e <_vfprintf_r+0x187a>
8000942a:	2f 83       	sub	r3,-8
8000942c:	c0 b8       	rjmp	80009442 <_vfprintf_r+0x188e>
8000942e:	fa ca f9 78 	sub	r10,sp,-1672
80009432:	02 9b       	mov	r11,r1
80009434:	08 9c       	mov	r12,r4
80009436:	fe b0 f3 b1 	rcall	80007b98 <__sprint_r>
8000943a:	e0 81 03 3c 	brne	80009ab2 <_vfprintf_r+0x1efe>
8000943e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009442:	40 29       	lddsp	r9,sp[0x8]
80009444:	21 09       	sub	r9,16
80009446:	50 29       	stdsp	sp[0x8],r9
80009448:	fa f9 06 90 	ld.w	r9,sp[1680]
8000944c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009450:	fe ca cb f4 	sub	r10,pc,-13324
80009454:	40 2e       	lddsp	lr,sp[0x8]
80009456:	59 0e       	cp.w	lr,16
80009458:	fe 99 ff db 	brgt	8000940e <_vfprintf_r+0x185a>
8000945c:	1c 09       	add	r9,lr
8000945e:	2f f8       	sub	r8,-1
80009460:	87 0a       	st.w	r3[0x0],r10
80009462:	fb 49 06 90 	st.w	sp[1680],r9
80009466:	87 1e       	st.w	r3[0x4],lr
80009468:	fb 48 06 8c 	st.w	sp[1676],r8
8000946c:	58 78       	cp.w	r8,7
8000946e:	e0 89 00 04 	brgt	80009476 <_vfprintf_r+0x18c2>
80009472:	2f 83       	sub	r3,-8
80009474:	c0 b8       	rjmp	8000948a <_vfprintf_r+0x18d6>
80009476:	fa ca f9 78 	sub	r10,sp,-1672
8000947a:	02 9b       	mov	r11,r1
8000947c:	08 9c       	mov	r12,r4
8000947e:	fe b0 f3 8d 	rcall	80007b98 <__sprint_r>
80009482:	e0 81 03 18 	brne	80009ab2 <_vfprintf_r+0x1efe>
80009486:	fa c3 f9 e0 	sub	r3,sp,-1568
8000948a:	ed b5 00 08 	bld	r5,0x8
8000948e:	c0 b0       	breq	800094a4 <_vfprintf_r+0x18f0>
80009490:	fa f8 06 90 	ld.w	r8,sp[1680]
80009494:	87 12       	st.w	r3[0x4],r2
80009496:	87 06       	st.w	r3[0x0],r6
80009498:	f0 02 00 02 	add	r2,r8,r2
8000949c:	fb 42 06 90 	st.w	sp[1680],r2
800094a0:	e0 8f 01 d4 	bral	80009848 <_vfprintf_r+0x1c94>
800094a4:	e0 40 00 65 	cp.w	r0,101
800094a8:	e0 8a 01 d6 	brle	80009854 <_vfprintf_r+0x1ca0>
800094ac:	30 08       	mov	r8,0
800094ae:	30 09       	mov	r9,0
800094b0:	40 5b       	lddsp	r11,sp[0x14]
800094b2:	40 7a       	lddsp	r10,sp[0x1c]
800094b4:	e0 a0 13 09 	rcall	8000bac6 <__avr32_f64_cmp_eq>
800094b8:	c7 90       	breq	800095aa <_vfprintf_r+0x19f6>
800094ba:	fa f8 06 90 	ld.w	r8,sp[1680]
800094be:	fe c9 cc 76 	sub	r9,pc,-13194
800094c2:	2f f8       	sub	r8,-1
800094c4:	87 09       	st.w	r3[0x0],r9
800094c6:	fb 48 06 90 	st.w	sp[1680],r8
800094ca:	30 19       	mov	r9,1
800094cc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094d0:	87 19       	st.w	r3[0x4],r9
800094d2:	2f f8       	sub	r8,-1
800094d4:	fb 48 06 8c 	st.w	sp[1676],r8
800094d8:	58 78       	cp.w	r8,7
800094da:	e0 89 00 05 	brgt	800094e4 <_vfprintf_r+0x1930>
800094de:	2f 83       	sub	r3,-8
800094e0:	c0 c8       	rjmp	800094f8 <_vfprintf_r+0x1944>
800094e2:	d7 03       	nop
800094e4:	fa ca f9 78 	sub	r10,sp,-1672
800094e8:	02 9b       	mov	r11,r1
800094ea:	08 9c       	mov	r12,r4
800094ec:	fe b0 f3 56 	rcall	80007b98 <__sprint_r>
800094f0:	e0 81 02 e1 	brne	80009ab2 <_vfprintf_r+0x1efe>
800094f4:	fa c3 f9 e0 	sub	r3,sp,-1568
800094f8:	fa f8 06 ac 	ld.w	r8,sp[1708]
800094fc:	40 6c       	lddsp	r12,sp[0x18]
800094fe:	18 38       	cp.w	r8,r12
80009500:	c0 55       	brlt	8000950a <_vfprintf_r+0x1956>
80009502:	ed b5 00 00 	bld	r5,0x0
80009506:	e0 81 02 6b 	brne	800099dc <_vfprintf_r+0x1e28>
8000950a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000950e:	2f f8       	sub	r8,-1
80009510:	40 cb       	lddsp	r11,sp[0x30]
80009512:	fb 48 06 90 	st.w	sp[1680],r8
80009516:	30 19       	mov	r9,1
80009518:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000951c:	87 0b       	st.w	r3[0x0],r11
8000951e:	2f f8       	sub	r8,-1
80009520:	87 19       	st.w	r3[0x4],r9
80009522:	fb 48 06 8c 	st.w	sp[1676],r8
80009526:	58 78       	cp.w	r8,7
80009528:	e0 89 00 04 	brgt	80009530 <_vfprintf_r+0x197c>
8000952c:	2f 83       	sub	r3,-8
8000952e:	c0 b8       	rjmp	80009544 <_vfprintf_r+0x1990>
80009530:	fa ca f9 78 	sub	r10,sp,-1672
80009534:	02 9b       	mov	r11,r1
80009536:	08 9c       	mov	r12,r4
80009538:	fe b0 f3 30 	rcall	80007b98 <__sprint_r>
8000953c:	e0 81 02 bb 	brne	80009ab2 <_vfprintf_r+0x1efe>
80009540:	fa c3 f9 e0 	sub	r3,sp,-1568
80009544:	40 66       	lddsp	r6,sp[0x18]
80009546:	20 16       	sub	r6,1
80009548:	58 06       	cp.w	r6,0
8000954a:	e0 89 00 1d 	brgt	80009584 <_vfprintf_r+0x19d0>
8000954e:	e0 8f 02 47 	bral	800099dc <_vfprintf_r+0x1e28>
80009552:	2f 09       	sub	r9,-16
80009554:	2f f8       	sub	r8,-1
80009556:	fb 49 06 90 	st.w	sp[1680],r9
8000955a:	87 02       	st.w	r3[0x0],r2
8000955c:	87 10       	st.w	r3[0x4],r0
8000955e:	fb 48 06 8c 	st.w	sp[1676],r8
80009562:	58 78       	cp.w	r8,7
80009564:	e0 89 00 04 	brgt	8000956c <_vfprintf_r+0x19b8>
80009568:	2f 83       	sub	r3,-8
8000956a:	c0 b8       	rjmp	80009580 <_vfprintf_r+0x19cc>
8000956c:	fa ca f9 78 	sub	r10,sp,-1672
80009570:	02 9b       	mov	r11,r1
80009572:	08 9c       	mov	r12,r4
80009574:	fe b0 f3 12 	rcall	80007b98 <__sprint_r>
80009578:	e0 81 02 9d 	brne	80009ab2 <_vfprintf_r+0x1efe>
8000957c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009580:	21 06       	sub	r6,16
80009582:	c0 48       	rjmp	8000958a <_vfprintf_r+0x19d6>
80009584:	fe c2 cd 28 	sub	r2,pc,-13016
80009588:	31 00       	mov	r0,16
8000958a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000958e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009592:	fe ca cd 36 	sub	r10,pc,-13002
80009596:	59 06       	cp.w	r6,16
80009598:	fe 99 ff dd 	brgt	80009552 <_vfprintf_r+0x199e>
8000959c:	0c 09       	add	r9,r6
8000959e:	87 0a       	st.w	r3[0x0],r10
800095a0:	fb 49 06 90 	st.w	sp[1680],r9
800095a4:	2f f8       	sub	r8,-1
800095a6:	87 16       	st.w	r3[0x4],r6
800095a8:	c5 39       	rjmp	8000984e <_vfprintf_r+0x1c9a>
800095aa:	fa fa 06 ac 	ld.w	r10,sp[1708]
800095ae:	58 0a       	cp.w	r10,0
800095b0:	e0 89 00 92 	brgt	800096d4 <_vfprintf_r+0x1b20>
800095b4:	fa f8 06 90 	ld.w	r8,sp[1680]
800095b8:	fe c9 cd 70 	sub	r9,pc,-12944
800095bc:	2f f8       	sub	r8,-1
800095be:	87 09       	st.w	r3[0x0],r9
800095c0:	fb 48 06 90 	st.w	sp[1680],r8
800095c4:	30 19       	mov	r9,1
800095c6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095ca:	87 19       	st.w	r3[0x4],r9
800095cc:	2f f8       	sub	r8,-1
800095ce:	fb 48 06 8c 	st.w	sp[1676],r8
800095d2:	58 78       	cp.w	r8,7
800095d4:	e0 89 00 04 	brgt	800095dc <_vfprintf_r+0x1a28>
800095d8:	2f 83       	sub	r3,-8
800095da:	c0 b8       	rjmp	800095f0 <_vfprintf_r+0x1a3c>
800095dc:	fa ca f9 78 	sub	r10,sp,-1672
800095e0:	02 9b       	mov	r11,r1
800095e2:	08 9c       	mov	r12,r4
800095e4:	fe b0 f2 da 	rcall	80007b98 <__sprint_r>
800095e8:	e0 81 02 65 	brne	80009ab2 <_vfprintf_r+0x1efe>
800095ec:	fa c3 f9 e0 	sub	r3,sp,-1568
800095f0:	fa f8 06 ac 	ld.w	r8,sp[1708]
800095f4:	58 08       	cp.w	r8,0
800095f6:	c0 81       	brne	80009606 <_vfprintf_r+0x1a52>
800095f8:	40 6a       	lddsp	r10,sp[0x18]
800095fa:	58 0a       	cp.w	r10,0
800095fc:	c0 51       	brne	80009606 <_vfprintf_r+0x1a52>
800095fe:	ed b5 00 00 	bld	r5,0x0
80009602:	e0 81 01 ed 	brne	800099dc <_vfprintf_r+0x1e28>
80009606:	40 c9       	lddsp	r9,sp[0x30]
80009608:	fa f8 06 90 	ld.w	r8,sp[1680]
8000960c:	2f f8       	sub	r8,-1
8000960e:	87 09       	st.w	r3[0x0],r9
80009610:	fb 48 06 90 	st.w	sp[1680],r8
80009614:	30 19       	mov	r9,1
80009616:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000961a:	87 19       	st.w	r3[0x4],r9
8000961c:	2f f8       	sub	r8,-1
8000961e:	fb 48 06 8c 	st.w	sp[1676],r8
80009622:	58 78       	cp.w	r8,7
80009624:	e0 89 00 04 	brgt	8000962c <_vfprintf_r+0x1a78>
80009628:	2f 83       	sub	r3,-8
8000962a:	c0 b8       	rjmp	80009640 <_vfprintf_r+0x1a8c>
8000962c:	fa ca f9 78 	sub	r10,sp,-1672
80009630:	02 9b       	mov	r11,r1
80009632:	08 9c       	mov	r12,r4
80009634:	fe b0 f2 b2 	rcall	80007b98 <__sprint_r>
80009638:	e0 81 02 3d 	brne	80009ab2 <_vfprintf_r+0x1efe>
8000963c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009640:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009644:	5c 32       	neg	r2
80009646:	58 02       	cp.w	r2,0
80009648:	e0 89 00 1d 	brgt	80009682 <_vfprintf_r+0x1ace>
8000964c:	c3 d8       	rjmp	800096c6 <_vfprintf_r+0x1b12>
8000964e:	2f 09       	sub	r9,-16
80009650:	2f f8       	sub	r8,-1
80009652:	31 0e       	mov	lr,16
80009654:	fb 49 06 90 	st.w	sp[1680],r9
80009658:	87 00       	st.w	r3[0x0],r0
8000965a:	87 1e       	st.w	r3[0x4],lr
8000965c:	fb 48 06 8c 	st.w	sp[1676],r8
80009660:	58 78       	cp.w	r8,7
80009662:	e0 89 00 04 	brgt	8000966a <_vfprintf_r+0x1ab6>
80009666:	2f 83       	sub	r3,-8
80009668:	c0 b8       	rjmp	8000967e <_vfprintf_r+0x1aca>
8000966a:	fa ca f9 78 	sub	r10,sp,-1672
8000966e:	02 9b       	mov	r11,r1
80009670:	08 9c       	mov	r12,r4
80009672:	fe b0 f2 93 	rcall	80007b98 <__sprint_r>
80009676:	e0 81 02 1e 	brne	80009ab2 <_vfprintf_r+0x1efe>
8000967a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000967e:	21 02       	sub	r2,16
80009680:	c0 38       	rjmp	80009686 <_vfprintf_r+0x1ad2>
80009682:	fe c0 ce 26 	sub	r0,pc,-12762
80009686:	fa f9 06 90 	ld.w	r9,sp[1680]
8000968a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000968e:	fe ca ce 32 	sub	r10,pc,-12750
80009692:	59 02       	cp.w	r2,16
80009694:	fe 99 ff dd 	brgt	8000964e <_vfprintf_r+0x1a9a>
80009698:	04 09       	add	r9,r2
8000969a:	2f f8       	sub	r8,-1
8000969c:	87 0a       	st.w	r3[0x0],r10
8000969e:	fb 49 06 90 	st.w	sp[1680],r9
800096a2:	87 12       	st.w	r3[0x4],r2
800096a4:	fb 48 06 8c 	st.w	sp[1676],r8
800096a8:	58 78       	cp.w	r8,7
800096aa:	e0 89 00 04 	brgt	800096b2 <_vfprintf_r+0x1afe>
800096ae:	2f 83       	sub	r3,-8
800096b0:	c0 b8       	rjmp	800096c6 <_vfprintf_r+0x1b12>
800096b2:	fa ca f9 78 	sub	r10,sp,-1672
800096b6:	02 9b       	mov	r11,r1
800096b8:	08 9c       	mov	r12,r4
800096ba:	fe b0 f2 6f 	rcall	80007b98 <__sprint_r>
800096be:	e0 81 01 fa 	brne	80009ab2 <_vfprintf_r+0x1efe>
800096c2:	fa c3 f9 e0 	sub	r3,sp,-1568
800096c6:	40 6c       	lddsp	r12,sp[0x18]
800096c8:	fa f8 06 90 	ld.w	r8,sp[1680]
800096cc:	87 06       	st.w	r3[0x0],r6
800096ce:	87 1c       	st.w	r3[0x4],r12
800096d0:	18 08       	add	r8,r12
800096d2:	cb 98       	rjmp	80009844 <_vfprintf_r+0x1c90>
800096d4:	fa f9 06 90 	ld.w	r9,sp[1680]
800096d8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096dc:	40 6b       	lddsp	r11,sp[0x18]
800096de:	16 3a       	cp.w	r10,r11
800096e0:	c6 f5       	brlt	800097be <_vfprintf_r+0x1c0a>
800096e2:	16 09       	add	r9,r11
800096e4:	2f f8       	sub	r8,-1
800096e6:	87 06       	st.w	r3[0x0],r6
800096e8:	fb 49 06 90 	st.w	sp[1680],r9
800096ec:	87 1b       	st.w	r3[0x4],r11
800096ee:	fb 48 06 8c 	st.w	sp[1676],r8
800096f2:	58 78       	cp.w	r8,7
800096f4:	e0 89 00 04 	brgt	800096fc <_vfprintf_r+0x1b48>
800096f8:	2f 83       	sub	r3,-8
800096fa:	c0 b8       	rjmp	80009710 <_vfprintf_r+0x1b5c>
800096fc:	fa ca f9 78 	sub	r10,sp,-1672
80009700:	02 9b       	mov	r11,r1
80009702:	08 9c       	mov	r12,r4
80009704:	fe b0 f2 4a 	rcall	80007b98 <__sprint_r>
80009708:	e0 81 01 d5 	brne	80009ab2 <_vfprintf_r+0x1efe>
8000970c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009710:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009714:	40 6a       	lddsp	r10,sp[0x18]
80009716:	14 16       	sub	r6,r10
80009718:	58 06       	cp.w	r6,0
8000971a:	e0 89 00 1c 	brgt	80009752 <_vfprintf_r+0x1b9e>
8000971e:	c3 d8       	rjmp	80009798 <_vfprintf_r+0x1be4>
80009720:	2f 09       	sub	r9,-16
80009722:	2f f8       	sub	r8,-1
80009724:	fb 49 06 90 	st.w	sp[1680],r9
80009728:	87 02       	st.w	r3[0x0],r2
8000972a:	87 10       	st.w	r3[0x4],r0
8000972c:	fb 48 06 8c 	st.w	sp[1676],r8
80009730:	58 78       	cp.w	r8,7
80009732:	e0 89 00 04 	brgt	8000973a <_vfprintf_r+0x1b86>
80009736:	2f 83       	sub	r3,-8
80009738:	c0 b8       	rjmp	8000974e <_vfprintf_r+0x1b9a>
8000973a:	fa ca f9 78 	sub	r10,sp,-1672
8000973e:	02 9b       	mov	r11,r1
80009740:	08 9c       	mov	r12,r4
80009742:	fe b0 f2 2b 	rcall	80007b98 <__sprint_r>
80009746:	e0 81 01 b6 	brne	80009ab2 <_vfprintf_r+0x1efe>
8000974a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000974e:	21 06       	sub	r6,16
80009750:	c0 48       	rjmp	80009758 <_vfprintf_r+0x1ba4>
80009752:	fe c2 ce f6 	sub	r2,pc,-12554
80009756:	31 00       	mov	r0,16
80009758:	fa f9 06 90 	ld.w	r9,sp[1680]
8000975c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009760:	fe ca cf 04 	sub	r10,pc,-12540
80009764:	59 06       	cp.w	r6,16
80009766:	fe 99 ff dd 	brgt	80009720 <_vfprintf_r+0x1b6c>
8000976a:	0c 09       	add	r9,r6
8000976c:	2f f8       	sub	r8,-1
8000976e:	87 0a       	st.w	r3[0x0],r10
80009770:	fb 49 06 90 	st.w	sp[1680],r9
80009774:	87 16       	st.w	r3[0x4],r6
80009776:	fb 48 06 8c 	st.w	sp[1676],r8
8000977a:	58 78       	cp.w	r8,7
8000977c:	e0 89 00 04 	brgt	80009784 <_vfprintf_r+0x1bd0>
80009780:	2f 83       	sub	r3,-8
80009782:	c0 b8       	rjmp	80009798 <_vfprintf_r+0x1be4>
80009784:	fa ca f9 78 	sub	r10,sp,-1672
80009788:	02 9b       	mov	r11,r1
8000978a:	08 9c       	mov	r12,r4
8000978c:	fe b0 f2 06 	rcall	80007b98 <__sprint_r>
80009790:	e0 81 01 91 	brne	80009ab2 <_vfprintf_r+0x1efe>
80009794:	fa c3 f9 e0 	sub	r3,sp,-1568
80009798:	ed b5 00 00 	bld	r5,0x0
8000979c:	e0 81 01 20 	brne	800099dc <_vfprintf_r+0x1e28>
800097a0:	40 c9       	lddsp	r9,sp[0x30]
800097a2:	fa f8 06 90 	ld.w	r8,sp[1680]
800097a6:	2f f8       	sub	r8,-1
800097a8:	87 09       	st.w	r3[0x0],r9
800097aa:	fb 48 06 90 	st.w	sp[1680],r8
800097ae:	30 19       	mov	r9,1
800097b0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097b4:	87 19       	st.w	r3[0x4],r9
800097b6:	2f f8       	sub	r8,-1
800097b8:	fb 48 06 8c 	st.w	sp[1676],r8
800097bc:	c0 29       	rjmp	800099c0 <_vfprintf_r+0x1e0c>
800097be:	14 09       	add	r9,r10
800097c0:	2f f8       	sub	r8,-1
800097c2:	fb 49 06 90 	st.w	sp[1680],r9
800097c6:	87 06       	st.w	r3[0x0],r6
800097c8:	87 1a       	st.w	r3[0x4],r10
800097ca:	fb 48 06 8c 	st.w	sp[1676],r8
800097ce:	58 78       	cp.w	r8,7
800097d0:	e0 89 00 04 	brgt	800097d8 <_vfprintf_r+0x1c24>
800097d4:	2f 83       	sub	r3,-8
800097d6:	c0 b8       	rjmp	800097ec <_vfprintf_r+0x1c38>
800097d8:	fa ca f9 78 	sub	r10,sp,-1672
800097dc:	02 9b       	mov	r11,r1
800097de:	08 9c       	mov	r12,r4
800097e0:	fe b0 f1 dc 	rcall	80007b98 <__sprint_r>
800097e4:	e0 81 01 67 	brne	80009ab2 <_vfprintf_r+0x1efe>
800097e8:	fa c3 f9 e0 	sub	r3,sp,-1568
800097ec:	40 c8       	lddsp	r8,sp[0x30]
800097ee:	87 08       	st.w	r3[0x0],r8
800097f0:	fa f8 06 90 	ld.w	r8,sp[1680]
800097f4:	2f f8       	sub	r8,-1
800097f6:	30 19       	mov	r9,1
800097f8:	fb 48 06 90 	st.w	sp[1680],r8
800097fc:	87 19       	st.w	r3[0x4],r9
800097fe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009802:	2f f8       	sub	r8,-1
80009804:	fb 48 06 8c 	st.w	sp[1676],r8
80009808:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000980c:	58 78       	cp.w	r8,7
8000980e:	e0 89 00 04 	brgt	80009816 <_vfprintf_r+0x1c62>
80009812:	2f 83       	sub	r3,-8
80009814:	c0 b8       	rjmp	8000982a <_vfprintf_r+0x1c76>
80009816:	fa ca f9 78 	sub	r10,sp,-1672
8000981a:	02 9b       	mov	r11,r1
8000981c:	08 9c       	mov	r12,r4
8000981e:	fe b0 f1 bd 	rcall	80007b98 <__sprint_r>
80009822:	e0 81 01 48 	brne	80009ab2 <_vfprintf_r+0x1efe>
80009826:	fa c3 f9 e0 	sub	r3,sp,-1568
8000982a:	04 06       	add	r6,r2
8000982c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009830:	87 06       	st.w	r3[0x0],r6
80009832:	fa f9 06 90 	ld.w	r9,sp[1680]
80009836:	40 66       	lddsp	r6,sp[0x18]
80009838:	40 6e       	lddsp	lr,sp[0x18]
8000983a:	10 16       	sub	r6,r8
8000983c:	f2 08 01 08 	sub	r8,r9,r8
80009840:	87 16       	st.w	r3[0x4],r6
80009842:	1c 08       	add	r8,lr
80009844:	fb 48 06 90 	st.w	sp[1680],r8
80009848:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000984c:	2f f8       	sub	r8,-1
8000984e:	fb 48 06 8c 	st.w	sp[1676],r8
80009852:	cb 78       	rjmp	800099c0 <_vfprintf_r+0x1e0c>
80009854:	40 6c       	lddsp	r12,sp[0x18]
80009856:	58 1c       	cp.w	r12,1
80009858:	e0 89 00 06 	brgt	80009864 <_vfprintf_r+0x1cb0>
8000985c:	ed b5 00 00 	bld	r5,0x0
80009860:	e0 81 00 85 	brne	8000996a <_vfprintf_r+0x1db6>
80009864:	fa f8 06 90 	ld.w	r8,sp[1680]
80009868:	2f f8       	sub	r8,-1
8000986a:	30 19       	mov	r9,1
8000986c:	fb 48 06 90 	st.w	sp[1680],r8
80009870:	87 06       	st.w	r3[0x0],r6
80009872:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009876:	87 19       	st.w	r3[0x4],r9
80009878:	2f f8       	sub	r8,-1
8000987a:	fb 48 06 8c 	st.w	sp[1676],r8
8000987e:	58 78       	cp.w	r8,7
80009880:	e0 89 00 04 	brgt	80009888 <_vfprintf_r+0x1cd4>
80009884:	2f 83       	sub	r3,-8
80009886:	c0 b8       	rjmp	8000989c <_vfprintf_r+0x1ce8>
80009888:	fa ca f9 78 	sub	r10,sp,-1672
8000988c:	02 9b       	mov	r11,r1
8000988e:	08 9c       	mov	r12,r4
80009890:	fe b0 f1 84 	rcall	80007b98 <__sprint_r>
80009894:	e0 81 01 0f 	brne	80009ab2 <_vfprintf_r+0x1efe>
80009898:	fa c3 f9 e0 	sub	r3,sp,-1568
8000989c:	fa f8 06 90 	ld.w	r8,sp[1680]
800098a0:	2f f8       	sub	r8,-1
800098a2:	40 cb       	lddsp	r11,sp[0x30]
800098a4:	fb 48 06 90 	st.w	sp[1680],r8
800098a8:	30 19       	mov	r9,1
800098aa:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098ae:	87 0b       	st.w	r3[0x0],r11
800098b0:	2f f8       	sub	r8,-1
800098b2:	87 19       	st.w	r3[0x4],r9
800098b4:	fb 48 06 8c 	st.w	sp[1676],r8
800098b8:	58 78       	cp.w	r8,7
800098ba:	e0 89 00 05 	brgt	800098c4 <_vfprintf_r+0x1d10>
800098be:	2f 83       	sub	r3,-8
800098c0:	c0 c8       	rjmp	800098d8 <_vfprintf_r+0x1d24>
800098c2:	d7 03       	nop
800098c4:	fa ca f9 78 	sub	r10,sp,-1672
800098c8:	02 9b       	mov	r11,r1
800098ca:	08 9c       	mov	r12,r4
800098cc:	fe b0 f1 66 	rcall	80007b98 <__sprint_r>
800098d0:	e0 81 00 f1 	brne	80009ab2 <_vfprintf_r+0x1efe>
800098d4:	fa c3 f9 e0 	sub	r3,sp,-1568
800098d8:	30 08       	mov	r8,0
800098da:	30 09       	mov	r9,0
800098dc:	40 5b       	lddsp	r11,sp[0x14]
800098de:	40 7a       	lddsp	r10,sp[0x1c]
800098e0:	e0 a0 10 f3 	rcall	8000bac6 <__avr32_f64_cmp_eq>
800098e4:	40 68       	lddsp	r8,sp[0x18]
800098e6:	20 18       	sub	r8,1
800098e8:	58 0c       	cp.w	r12,0
800098ea:	c0 d1       	brne	80009904 <_vfprintf_r+0x1d50>
800098ec:	2f f6       	sub	r6,-1
800098ee:	87 18       	st.w	r3[0x4],r8
800098f0:	87 06       	st.w	r3[0x0],r6
800098f2:	fa f6 06 90 	ld.w	r6,sp[1680]
800098f6:	10 06       	add	r6,r8
800098f8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098fc:	fb 46 06 90 	st.w	sp[1680],r6
80009900:	2f f8       	sub	r8,-1
80009902:	c3 18       	rjmp	80009964 <_vfprintf_r+0x1db0>
80009904:	10 96       	mov	r6,r8
80009906:	58 08       	cp.w	r8,0
80009908:	e0 89 00 1c 	brgt	80009940 <_vfprintf_r+0x1d8c>
8000990c:	c4 b8       	rjmp	800099a2 <_vfprintf_r+0x1dee>
8000990e:	2f 09       	sub	r9,-16
80009910:	2f f8       	sub	r8,-1
80009912:	fb 49 06 90 	st.w	sp[1680],r9
80009916:	87 02       	st.w	r3[0x0],r2
80009918:	87 10       	st.w	r3[0x4],r0
8000991a:	fb 48 06 8c 	st.w	sp[1676],r8
8000991e:	58 78       	cp.w	r8,7
80009920:	e0 89 00 04 	brgt	80009928 <_vfprintf_r+0x1d74>
80009924:	2f 83       	sub	r3,-8
80009926:	c0 b8       	rjmp	8000993c <_vfprintf_r+0x1d88>
80009928:	fa ca f9 78 	sub	r10,sp,-1672
8000992c:	02 9b       	mov	r11,r1
8000992e:	08 9c       	mov	r12,r4
80009930:	fe b0 f1 34 	rcall	80007b98 <__sprint_r>
80009934:	e0 81 00 bf 	brne	80009ab2 <_vfprintf_r+0x1efe>
80009938:	fa c3 f9 e0 	sub	r3,sp,-1568
8000993c:	21 06       	sub	r6,16
8000993e:	c0 48       	rjmp	80009946 <_vfprintf_r+0x1d92>
80009940:	fe c2 d0 e4 	sub	r2,pc,-12060
80009944:	31 00       	mov	r0,16
80009946:	fa f9 06 90 	ld.w	r9,sp[1680]
8000994a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000994e:	fe ca d0 f2 	sub	r10,pc,-12046
80009952:	59 06       	cp.w	r6,16
80009954:	fe 99 ff dd 	brgt	8000990e <_vfprintf_r+0x1d5a>
80009958:	0c 09       	add	r9,r6
8000995a:	87 0a       	st.w	r3[0x0],r10
8000995c:	fb 49 06 90 	st.w	sp[1680],r9
80009960:	2f f8       	sub	r8,-1
80009962:	87 16       	st.w	r3[0x4],r6
80009964:	fb 48 06 8c 	st.w	sp[1676],r8
80009968:	c0 e8       	rjmp	80009984 <_vfprintf_r+0x1dd0>
8000996a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000996e:	2f f8       	sub	r8,-1
80009970:	30 19       	mov	r9,1
80009972:	fb 48 06 90 	st.w	sp[1680],r8
80009976:	87 06       	st.w	r3[0x0],r6
80009978:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000997c:	87 19       	st.w	r3[0x4],r9
8000997e:	2f f8       	sub	r8,-1
80009980:	fb 48 06 8c 	st.w	sp[1676],r8
80009984:	58 78       	cp.w	r8,7
80009986:	e0 89 00 04 	brgt	8000998e <_vfprintf_r+0x1dda>
8000998a:	2f 83       	sub	r3,-8
8000998c:	c0 b8       	rjmp	800099a2 <_vfprintf_r+0x1dee>
8000998e:	fa ca f9 78 	sub	r10,sp,-1672
80009992:	02 9b       	mov	r11,r1
80009994:	08 9c       	mov	r12,r4
80009996:	fe b0 f1 01 	rcall	80007b98 <__sprint_r>
8000999a:	e0 81 00 8c 	brne	80009ab2 <_vfprintf_r+0x1efe>
8000999e:	fa c3 f9 e0 	sub	r3,sp,-1568
800099a2:	40 ea       	lddsp	r10,sp[0x38]
800099a4:	fa f8 06 90 	ld.w	r8,sp[1680]
800099a8:	14 08       	add	r8,r10
800099aa:	fa c9 f9 64 	sub	r9,sp,-1692
800099ae:	fb 48 06 90 	st.w	sp[1680],r8
800099b2:	87 1a       	st.w	r3[0x4],r10
800099b4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099b8:	87 09       	st.w	r3[0x0],r9
800099ba:	2f f8       	sub	r8,-1
800099bc:	fb 48 06 8c 	st.w	sp[1676],r8
800099c0:	58 78       	cp.w	r8,7
800099c2:	e0 89 00 04 	brgt	800099ca <_vfprintf_r+0x1e16>
800099c6:	2f 83       	sub	r3,-8
800099c8:	c0 a8       	rjmp	800099dc <_vfprintf_r+0x1e28>
800099ca:	fa ca f9 78 	sub	r10,sp,-1672
800099ce:	02 9b       	mov	r11,r1
800099d0:	08 9c       	mov	r12,r4
800099d2:	fe b0 f0 e3 	rcall	80007b98 <__sprint_r>
800099d6:	c6 e1       	brne	80009ab2 <_vfprintf_r+0x1efe>
800099d8:	fa c3 f9 e0 	sub	r3,sp,-1568
800099dc:	e2 15 00 04 	andl	r5,0x4,COH
800099e0:	c3 f0       	breq	80009a5e <_vfprintf_r+0x1eaa>
800099e2:	40 86       	lddsp	r6,sp[0x20]
800099e4:	40 39       	lddsp	r9,sp[0xc]
800099e6:	12 16       	sub	r6,r9
800099e8:	58 06       	cp.w	r6,0
800099ea:	e0 89 00 1a 	brgt	80009a1e <_vfprintf_r+0x1e6a>
800099ee:	c3 88       	rjmp	80009a5e <_vfprintf_r+0x1eaa>
800099f0:	2f 09       	sub	r9,-16
800099f2:	2f f8       	sub	r8,-1
800099f4:	fb 49 06 90 	st.w	sp[1680],r9
800099f8:	87 05       	st.w	r3[0x0],r5
800099fa:	87 12       	st.w	r3[0x4],r2
800099fc:	fb 48 06 8c 	st.w	sp[1676],r8
80009a00:	58 78       	cp.w	r8,7
80009a02:	e0 89 00 04 	brgt	80009a0a <_vfprintf_r+0x1e56>
80009a06:	2f 83       	sub	r3,-8
80009a08:	c0 98       	rjmp	80009a1a <_vfprintf_r+0x1e66>
80009a0a:	00 9a       	mov	r10,r0
80009a0c:	02 9b       	mov	r11,r1
80009a0e:	08 9c       	mov	r12,r4
80009a10:	fe b0 f0 c4 	rcall	80007b98 <__sprint_r>
80009a14:	c4 f1       	brne	80009ab2 <_vfprintf_r+0x1efe>
80009a16:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a1a:	21 06       	sub	r6,16
80009a1c:	c0 68       	rjmp	80009a28 <_vfprintf_r+0x1e74>
80009a1e:	fe c5 d1 d2 	sub	r5,pc,-11822
80009a22:	31 02       	mov	r2,16
80009a24:	fa c0 f9 78 	sub	r0,sp,-1672
80009a28:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a2c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a30:	fe ca d1 e4 	sub	r10,pc,-11804
80009a34:	59 06       	cp.w	r6,16
80009a36:	fe 99 ff dd 	brgt	800099f0 <_vfprintf_r+0x1e3c>
80009a3a:	0c 09       	add	r9,r6
80009a3c:	2f f8       	sub	r8,-1
80009a3e:	87 0a       	st.w	r3[0x0],r10
80009a40:	87 16       	st.w	r3[0x4],r6
80009a42:	fb 49 06 90 	st.w	sp[1680],r9
80009a46:	fb 48 06 8c 	st.w	sp[1676],r8
80009a4a:	58 78       	cp.w	r8,7
80009a4c:	e0 8a 00 09 	brle	80009a5e <_vfprintf_r+0x1eaa>
80009a50:	fa ca f9 78 	sub	r10,sp,-1672
80009a54:	02 9b       	mov	r11,r1
80009a56:	08 9c       	mov	r12,r4
80009a58:	fe b0 f0 a0 	rcall	80007b98 <__sprint_r>
80009a5c:	c2 b1       	brne	80009ab2 <_vfprintf_r+0x1efe>
80009a5e:	40 bc       	lddsp	r12,sp[0x2c]
80009a60:	40 36       	lddsp	r6,sp[0xc]
80009a62:	40 8e       	lddsp	lr,sp[0x20]
80009a64:	ec 0e 0c 48 	max	r8,r6,lr
80009a68:	10 0c       	add	r12,r8
80009a6a:	50 bc       	stdsp	sp[0x2c],r12
80009a6c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a70:	58 08       	cp.w	r8,0
80009a72:	c0 80       	breq	80009a82 <_vfprintf_r+0x1ece>
80009a74:	fa ca f9 78 	sub	r10,sp,-1672
80009a78:	02 9b       	mov	r11,r1
80009a7a:	08 9c       	mov	r12,r4
80009a7c:	fe b0 f0 8e 	rcall	80007b98 <__sprint_r>
80009a80:	c1 91       	brne	80009ab2 <_vfprintf_r+0x1efe>
80009a82:	30 0b       	mov	r11,0
80009a84:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a88:	fb 4b 06 8c 	st.w	sp[1676],r11
80009a8c:	fe 9f f1 22 	bral	80007cd0 <_vfprintf_r+0x11c>
80009a90:	08 95       	mov	r5,r4
80009a92:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a96:	58 08       	cp.w	r8,0
80009a98:	c0 80       	breq	80009aa8 <_vfprintf_r+0x1ef4>
80009a9a:	08 9c       	mov	r12,r4
80009a9c:	fa ca f9 78 	sub	r10,sp,-1672
80009aa0:	02 9b       	mov	r11,r1
80009aa2:	fe b0 f0 7b 	rcall	80007b98 <__sprint_r>
80009aa6:	c0 61       	brne	80009ab2 <_vfprintf_r+0x1efe>
80009aa8:	30 08       	mov	r8,0
80009aaa:	fb 48 06 8c 	st.w	sp[1676],r8
80009aae:	c0 28       	rjmp	80009ab2 <_vfprintf_r+0x1efe>
80009ab0:	40 41       	lddsp	r1,sp[0x10]
80009ab2:	82 68       	ld.sh	r8,r1[0xc]
80009ab4:	ed b8 00 06 	bld	r8,0x6
80009ab8:	c0 31       	brne	80009abe <_vfprintf_r+0x1f0a>
80009aba:	3f fa       	mov	r10,-1
80009abc:	50 ba       	stdsp	sp[0x2c],r10
80009abe:	40 bc       	lddsp	r12,sp[0x2c]
80009ac0:	fe 3d f9 44 	sub	sp,-1724
80009ac4:	d8 32       	popm	r0-r7,pc
80009ac6:	d7 03       	nop

80009ac8 <_write_r>:
80009ac8:	d4 21       	pushm	r4-r7,lr
80009aca:	16 98       	mov	r8,r11
80009acc:	18 97       	mov	r7,r12
80009ace:	10 9c       	mov	r12,r8
80009ad0:	30 08       	mov	r8,0
80009ad2:	14 9b       	mov	r11,r10
80009ad4:	e0 66 08 10 	mov	r6,2064
80009ad8:	12 9a       	mov	r10,r9
80009ada:	8d 08       	st.w	r6[0x0],r8
80009adc:	fe b0 db d0 	rcall	8000527c <_write>
80009ae0:	5b fc       	cp.w	r12,-1
80009ae2:	c0 51       	brne	80009aec <_write_r+0x24>
80009ae4:	6c 08       	ld.w	r8,r6[0x0]
80009ae6:	58 08       	cp.w	r8,0
80009ae8:	ef f8 1a 03 	st.wne	r7[0xc],r8
80009aec:	d8 22       	popm	r4-r7,pc
80009aee:	d7 03       	nop

80009af0 <__swsetup_r>:
80009af0:	d4 21       	pushm	r4-r7,lr
80009af2:	e0 68 01 18 	mov	r8,280
80009af6:	18 96       	mov	r6,r12
80009af8:	16 97       	mov	r7,r11
80009afa:	70 0c       	ld.w	r12,r8[0x0]
80009afc:	58 0c       	cp.w	r12,0
80009afe:	c0 60       	breq	80009b0a <__swsetup_r+0x1a>
80009b00:	78 68       	ld.w	r8,r12[0x18]
80009b02:	58 08       	cp.w	r8,0
80009b04:	c0 31       	brne	80009b0a <__swsetup_r+0x1a>
80009b06:	fe b0 ec db 	rcall	800074bc <__sinit>
80009b0a:	fe c8 d5 d2 	sub	r8,pc,-10798
80009b0e:	10 37       	cp.w	r7,r8
80009b10:	c0 61       	brne	80009b1c <__swsetup_r+0x2c>
80009b12:	e0 68 01 18 	mov	r8,280
80009b16:	70 08       	ld.w	r8,r8[0x0]
80009b18:	70 07       	ld.w	r7,r8[0x0]
80009b1a:	c1 28       	rjmp	80009b3e <__swsetup_r+0x4e>
80009b1c:	fe c8 d5 c4 	sub	r8,pc,-10812
80009b20:	10 37       	cp.w	r7,r8
80009b22:	c0 61       	brne	80009b2e <__swsetup_r+0x3e>
80009b24:	e0 68 01 18 	mov	r8,280
80009b28:	70 08       	ld.w	r8,r8[0x0]
80009b2a:	70 17       	ld.w	r7,r8[0x4]
80009b2c:	c0 98       	rjmp	80009b3e <__swsetup_r+0x4e>
80009b2e:	fe c8 d5 b6 	sub	r8,pc,-10826
80009b32:	10 37       	cp.w	r7,r8
80009b34:	c0 51       	brne	80009b3e <__swsetup_r+0x4e>
80009b36:	e0 68 01 18 	mov	r8,280
80009b3a:	70 08       	ld.w	r8,r8[0x0]
80009b3c:	70 27       	ld.w	r7,r8[0x8]
80009b3e:	8e 68       	ld.sh	r8,r7[0xc]
80009b40:	ed b8 00 03 	bld	r8,0x3
80009b44:	c1 e0       	breq	80009b80 <__swsetup_r+0x90>
80009b46:	ed b8 00 04 	bld	r8,0x4
80009b4a:	c3 e1       	brne	80009bc6 <__swsetup_r+0xd6>
80009b4c:	ed b8 00 02 	bld	r8,0x2
80009b50:	c1 51       	brne	80009b7a <__swsetup_r+0x8a>
80009b52:	6e db       	ld.w	r11,r7[0x34]
80009b54:	58 0b       	cp.w	r11,0
80009b56:	c0 a0       	breq	80009b6a <__swsetup_r+0x7a>
80009b58:	ee c8 ff bc 	sub	r8,r7,-68
80009b5c:	10 3b       	cp.w	r11,r8
80009b5e:	c0 40       	breq	80009b66 <__swsetup_r+0x76>
80009b60:	0c 9c       	mov	r12,r6
80009b62:	fe b0 ed 47 	rcall	800075f0 <_free_r>
80009b66:	30 08       	mov	r8,0
80009b68:	8f d8       	st.w	r7[0x34],r8
80009b6a:	8e 68       	ld.sh	r8,r7[0xc]
80009b6c:	e0 18 ff db 	andl	r8,0xffdb
80009b70:	ae 68       	st.h	r7[0xc],r8
80009b72:	30 08       	mov	r8,0
80009b74:	8f 18       	st.w	r7[0x4],r8
80009b76:	6e 48       	ld.w	r8,r7[0x10]
80009b78:	8f 08       	st.w	r7[0x0],r8
80009b7a:	8e 68       	ld.sh	r8,r7[0xc]
80009b7c:	a3 b8       	sbr	r8,0x3
80009b7e:	ae 68       	st.h	r7[0xc],r8
80009b80:	6e 48       	ld.w	r8,r7[0x10]
80009b82:	58 08       	cp.w	r8,0
80009b84:	c0 b1       	brne	80009b9a <__swsetup_r+0xaa>
80009b86:	8e 68       	ld.sh	r8,r7[0xc]
80009b88:	e2 18 02 80 	andl	r8,0x280,COH
80009b8c:	e0 48 02 00 	cp.w	r8,512
80009b90:	c0 50       	breq	80009b9a <__swsetup_r+0xaa>
80009b92:	0c 9c       	mov	r12,r6
80009b94:	0e 9b       	mov	r11,r7
80009b96:	e0 a0 08 f9 	rcall	8000ad88 <__smakebuf_r>
80009b9a:	8e 69       	ld.sh	r9,r7[0xc]
80009b9c:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009ba0:	c0 70       	breq	80009bae <__swsetup_r+0xbe>
80009ba2:	30 08       	mov	r8,0
80009ba4:	8f 28       	st.w	r7[0x8],r8
80009ba6:	6e 58       	ld.w	r8,r7[0x14]
80009ba8:	5c 38       	neg	r8
80009baa:	8f 68       	st.w	r7[0x18],r8
80009bac:	c0 68       	rjmp	80009bb8 <__swsetup_r+0xc8>
80009bae:	ed b9 00 01 	bld	r9,0x1
80009bb2:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009bb6:	8f 28       	st.w	r7[0x8],r8
80009bb8:	6e 48       	ld.w	r8,r7[0x10]
80009bba:	58 08       	cp.w	r8,0
80009bbc:	c0 61       	brne	80009bc8 <__swsetup_r+0xd8>
80009bbe:	8e 68       	ld.sh	r8,r7[0xc]
80009bc0:	ed b8 00 07 	bld	r8,0x7
80009bc4:	c0 21       	brne	80009bc8 <__swsetup_r+0xd8>
80009bc6:	dc 2a       	popm	r4-r7,pc,r12=-1
80009bc8:	d8 2a       	popm	r4-r7,pc,r12=0
80009bca:	d7 03       	nop

80009bcc <_close_r>:
80009bcc:	d4 21       	pushm	r4-r7,lr
80009bce:	30 08       	mov	r8,0
80009bd0:	18 97       	mov	r7,r12
80009bd2:	e0 66 08 10 	mov	r6,2064
80009bd6:	16 9c       	mov	r12,r11
80009bd8:	8d 08       	st.w	r6[0x0],r8
80009bda:	fe b0 ea d5 	rcall	80007184 <_close>
80009bde:	5b fc       	cp.w	r12,-1
80009be0:	c0 51       	brne	80009bea <_close_r+0x1e>
80009be2:	6c 08       	ld.w	r8,r6[0x0]
80009be4:	58 08       	cp.w	r8,0
80009be6:	ef f8 1a 03 	st.wne	r7[0xc],r8
80009bea:	d8 22       	popm	r4-r7,pc

80009bec <quorem>:
80009bec:	d4 31       	pushm	r0-r7,lr
80009bee:	20 2d       	sub	sp,8
80009bf0:	18 97       	mov	r7,r12
80009bf2:	78 48       	ld.w	r8,r12[0x10]
80009bf4:	76 46       	ld.w	r6,r11[0x10]
80009bf6:	0c 38       	cp.w	r8,r6
80009bf8:	c0 34       	brge	80009bfe <quorem+0x12>
80009bfa:	30 0c       	mov	r12,0
80009bfc:	c8 58       	rjmp	80009d06 <quorem+0x11a>
80009bfe:	ec c2 ff fc 	sub	r2,r6,-4
80009c02:	f6 c3 ff ec 	sub	r3,r11,-20
80009c06:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009c0a:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009c0e:	2f f9       	sub	r9,-1
80009c10:	20 16       	sub	r6,1
80009c12:	f8 09 0d 08 	divu	r8,r12,r9
80009c16:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009c1a:	ee c4 ff ec 	sub	r4,r7,-20
80009c1e:	10 95       	mov	r5,r8
80009c20:	58 08       	cp.w	r8,0
80009c22:	c4 10       	breq	80009ca4 <quorem+0xb8>
80009c24:	30 09       	mov	r9,0
80009c26:	06 9a       	mov	r10,r3
80009c28:	08 98       	mov	r8,r4
80009c2a:	12 91       	mov	r1,r9
80009c2c:	50 0b       	stdsp	sp[0x0],r11
80009c2e:	70 0e       	ld.w	lr,r8[0x0]
80009c30:	b1 8e       	lsr	lr,0x10
80009c32:	50 1e       	stdsp	sp[0x4],lr
80009c34:	15 0e       	ld.w	lr,r10++
80009c36:	fc 00 16 10 	lsr	r0,lr,0x10
80009c3a:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009c3e:	ea 0e 03 41 	mac	r1,r5,lr
80009c42:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009c46:	b1 81       	lsr	r1,0x10
80009c48:	40 1b       	lddsp	r11,sp[0x4]
80009c4a:	ea 00 02 40 	mul	r0,r5,r0
80009c4e:	e2 00 00 00 	add	r0,r1,r0
80009c52:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009c56:	02 1b       	sub	r11,r1
80009c58:	50 1b       	stdsp	sp[0x4],r11
80009c5a:	70 0b       	ld.w	r11,r8[0x0]
80009c5c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009c60:	02 09       	add	r9,r1
80009c62:	f2 0e 01 0e 	sub	lr,r9,lr
80009c66:	b0 1e       	st.h	r8[0x2],lr
80009c68:	fc 09 14 10 	asr	r9,lr,0x10
80009c6c:	40 1e       	lddsp	lr,sp[0x4]
80009c6e:	fc 09 00 09 	add	r9,lr,r9
80009c72:	b0 09       	st.h	r8[0x0],r9
80009c74:	e0 01 16 10 	lsr	r1,r0,0x10
80009c78:	2f c8       	sub	r8,-4
80009c7a:	b1 49       	asr	r9,0x10
80009c7c:	04 3a       	cp.w	r10,r2
80009c7e:	fe 98 ff d8 	brls	80009c2e <quorem+0x42>
80009c82:	40 0b       	lddsp	r11,sp[0x0]
80009c84:	58 0c       	cp.w	r12,0
80009c86:	c0 f1       	brne	80009ca4 <quorem+0xb8>
80009c88:	ec c8 ff fb 	sub	r8,r6,-5
80009c8c:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009c90:	c0 28       	rjmp	80009c94 <quorem+0xa8>
80009c92:	20 16       	sub	r6,1
80009c94:	20 48       	sub	r8,4
80009c96:	08 38       	cp.w	r8,r4
80009c98:	e0 88 00 05 	brls	80009ca2 <quorem+0xb6>
80009c9c:	70 09       	ld.w	r9,r8[0x0]
80009c9e:	58 09       	cp.w	r9,0
80009ca0:	cf 90       	breq	80009c92 <quorem+0xa6>
80009ca2:	8f 46       	st.w	r7[0x10],r6
80009ca4:	0e 9c       	mov	r12,r7
80009ca6:	e0 a0 09 51 	rcall	8000af48 <__mcmp>
80009caa:	c2 d5       	brlt	80009d04 <quorem+0x118>
80009cac:	2f f5       	sub	r5,-1
80009cae:	08 98       	mov	r8,r4
80009cb0:	30 09       	mov	r9,0
80009cb2:	07 0b       	ld.w	r11,r3++
80009cb4:	f6 0a 16 10 	lsr	r10,r11,0x10
80009cb8:	70 0c       	ld.w	r12,r8[0x0]
80009cba:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009cbe:	f8 0e 16 10 	lsr	lr,r12,0x10
80009cc2:	14 1e       	sub	lr,r10
80009cc4:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009cc8:	16 1a       	sub	r10,r11
80009cca:	12 0a       	add	r10,r9
80009ccc:	b0 1a       	st.h	r8[0x2],r10
80009cce:	b1 4a       	asr	r10,0x10
80009cd0:	fc 0a 00 09 	add	r9,lr,r10
80009cd4:	b0 09       	st.h	r8[0x0],r9
80009cd6:	2f c8       	sub	r8,-4
80009cd8:	b1 49       	asr	r9,0x10
80009cda:	04 33       	cp.w	r3,r2
80009cdc:	fe 98 ff eb 	brls	80009cb2 <quorem+0xc6>
80009ce0:	ec c8 ff fb 	sub	r8,r6,-5
80009ce4:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009ce8:	58 09       	cp.w	r9,0
80009cea:	c0 d1       	brne	80009d04 <quorem+0x118>
80009cec:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009cf0:	c0 28       	rjmp	80009cf4 <quorem+0x108>
80009cf2:	20 16       	sub	r6,1
80009cf4:	20 48       	sub	r8,4
80009cf6:	08 38       	cp.w	r8,r4
80009cf8:	e0 88 00 05 	brls	80009d02 <quorem+0x116>
80009cfc:	70 09       	ld.w	r9,r8[0x0]
80009cfe:	58 09       	cp.w	r9,0
80009d00:	cf 90       	breq	80009cf2 <quorem+0x106>
80009d02:	8f 46       	st.w	r7[0x10],r6
80009d04:	0a 9c       	mov	r12,r5
80009d06:	2f ed       	sub	sp,-8
80009d08:	d8 32       	popm	r0-r7,pc
80009d0a:	d7 03       	nop

80009d0c <_dtoa_r>:
80009d0c:	d4 31       	pushm	r0-r7,lr
80009d0e:	21 ad       	sub	sp,104
80009d10:	fa c4 ff 74 	sub	r4,sp,-140
80009d14:	18 97       	mov	r7,r12
80009d16:	16 95       	mov	r5,r11
80009d18:	68 2c       	ld.w	r12,r4[0x8]
80009d1a:	50 c9       	stdsp	sp[0x30],r9
80009d1c:	68 16       	ld.w	r6,r4[0x4]
80009d1e:	68 09       	ld.w	r9,r4[0x0]
80009d20:	50 e8       	stdsp	sp[0x38],r8
80009d22:	14 94       	mov	r4,r10
80009d24:	51 2c       	stdsp	sp[0x48],r12
80009d26:	fa e5 00 08 	st.d	sp[8],r4
80009d2a:	51 59       	stdsp	sp[0x54],r9
80009d2c:	6e 95       	ld.w	r5,r7[0x24]
80009d2e:	58 05       	cp.w	r5,0
80009d30:	c0 91       	brne	80009d42 <_dtoa_r+0x36>
80009d32:	31 0c       	mov	r12,16
80009d34:	fe b0 e5 ce 	rcall	800068d0 <malloc>
80009d38:	99 35       	st.w	r12[0xc],r5
80009d3a:	8f 9c       	st.w	r7[0x24],r12
80009d3c:	99 15       	st.w	r12[0x4],r5
80009d3e:	99 25       	st.w	r12[0x8],r5
80009d40:	99 05       	st.w	r12[0x0],r5
80009d42:	6e 99       	ld.w	r9,r7[0x24]
80009d44:	72 08       	ld.w	r8,r9[0x0]
80009d46:	58 08       	cp.w	r8,0
80009d48:	c0 f0       	breq	80009d66 <_dtoa_r+0x5a>
80009d4a:	72 1a       	ld.w	r10,r9[0x4]
80009d4c:	91 1a       	st.w	r8[0x4],r10
80009d4e:	30 1a       	mov	r10,1
80009d50:	72 19       	ld.w	r9,r9[0x4]
80009d52:	f4 09 09 49 	lsl	r9,r10,r9
80009d56:	10 9b       	mov	r11,r8
80009d58:	91 29       	st.w	r8[0x8],r9
80009d5a:	0e 9c       	mov	r12,r7
80009d5c:	e0 a0 09 10 	rcall	8000af7c <_Bfree>
80009d60:	6e 98       	ld.w	r8,r7[0x24]
80009d62:	30 09       	mov	r9,0
80009d64:	91 09       	st.w	r8[0x0],r9
80009d66:	40 28       	lddsp	r8,sp[0x8]
80009d68:	10 94       	mov	r4,r8
80009d6a:	58 08       	cp.w	r8,0
80009d6c:	c0 64       	brge	80009d78 <_dtoa_r+0x6c>
80009d6e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009d72:	50 28       	stdsp	sp[0x8],r8
80009d74:	30 18       	mov	r8,1
80009d76:	c0 28       	rjmp	80009d7a <_dtoa_r+0x6e>
80009d78:	30 08       	mov	r8,0
80009d7a:	8d 08       	st.w	r6[0x0],r8
80009d7c:	fc 1c 7f f0 	movh	r12,0x7ff0
80009d80:	40 26       	lddsp	r6,sp[0x8]
80009d82:	0c 98       	mov	r8,r6
80009d84:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009d88:	18 38       	cp.w	r8,r12
80009d8a:	c2 01       	brne	80009dca <_dtoa_r+0xbe>
80009d8c:	e0 68 27 0f 	mov	r8,9999
80009d90:	41 5b       	lddsp	r11,sp[0x54]
80009d92:	97 08       	st.w	r11[0x0],r8
80009d94:	40 3a       	lddsp	r10,sp[0xc]
80009d96:	58 0a       	cp.w	r10,0
80009d98:	c0 71       	brne	80009da6 <_dtoa_r+0x9a>
80009d9a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009d9e:	c0 41       	brne	80009da6 <_dtoa_r+0x9a>
80009da0:	fe cc d4 34 	sub	r12,pc,-11212
80009da4:	c0 38       	rjmp	80009daa <_dtoa_r+0x9e>
80009da6:	fe cc d4 2e 	sub	r12,pc,-11218
80009daa:	41 29       	lddsp	r9,sp[0x48]
80009dac:	58 09       	cp.w	r9,0
80009dae:	e0 80 05 9a 	breq	8000a8e2 <_dtoa_r+0xbd6>
80009db2:	f8 c8 ff fd 	sub	r8,r12,-3
80009db6:	f8 c9 ff f8 	sub	r9,r12,-8
80009dba:	11 8b       	ld.ub	r11,r8[0x0]
80009dbc:	30 0a       	mov	r10,0
80009dbe:	41 25       	lddsp	r5,sp[0x48]
80009dc0:	f4 0b 18 00 	cp.b	r11,r10
80009dc4:	f2 08 17 10 	movne	r8,r9
80009dc8:	c1 68       	rjmp	80009df4 <_dtoa_r+0xe8>
80009dca:	fa ea 00 08 	ld.d	r10,sp[8]
80009dce:	30 08       	mov	r8,0
80009dd0:	fa eb 00 3c 	st.d	sp[60],r10
80009dd4:	30 09       	mov	r9,0
80009dd6:	e0 a0 0e 78 	rcall	8000bac6 <__avr32_f64_cmp_eq>
80009dda:	c1 00       	breq	80009dfa <_dtoa_r+0xee>
80009ddc:	30 18       	mov	r8,1
80009dde:	41 5a       	lddsp	r10,sp[0x54]
80009de0:	95 08       	st.w	r10[0x0],r8
80009de2:	fe cc d5 9a 	sub	r12,pc,-10854
80009de6:	41 29       	lddsp	r9,sp[0x48]
80009de8:	f8 08 00 08 	add	r8,r12,r8
80009dec:	58 09       	cp.w	r9,0
80009dee:	e0 80 05 7a 	breq	8000a8e2 <_dtoa_r+0xbd6>
80009df2:	12 95       	mov	r5,r9
80009df4:	8b 08       	st.w	r5[0x0],r8
80009df6:	e0 8f 05 76 	bral	8000a8e2 <_dtoa_r+0xbd6>
80009dfa:	fa c8 ff 9c 	sub	r8,sp,-100
80009dfe:	fa c9 ff a0 	sub	r9,sp,-96
80009e02:	fa ea 00 3c 	ld.d	r10,sp[60]
80009e06:	0e 9c       	mov	r12,r7
80009e08:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009e0c:	e0 a0 09 0a 	rcall	8000b020 <__d2b>
80009e10:	18 93       	mov	r3,r12
80009e12:	58 05       	cp.w	r5,0
80009e14:	c0 d0       	breq	80009e2e <_dtoa_r+0x122>
80009e16:	fa ea 00 3c 	ld.d	r10,sp[60]
80009e1a:	30 04       	mov	r4,0
80009e1c:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009e20:	ea c5 03 ff 	sub	r5,r5,1023
80009e24:	10 9b       	mov	r11,r8
80009e26:	51 74       	stdsp	sp[0x5c],r4
80009e28:	ea 1b 3f f0 	orh	r11,0x3ff0
80009e2c:	c2 58       	rjmp	80009e76 <_dtoa_r+0x16a>
80009e2e:	41 88       	lddsp	r8,sp[0x60]
80009e30:	41 9c       	lddsp	r12,sp[0x64]
80009e32:	10 0c       	add	r12,r8
80009e34:	f8 c5 fb ce 	sub	r5,r12,-1074
80009e38:	e0 45 00 20 	cp.w	r5,32
80009e3c:	e0 8a 00 0e 	brle	80009e58 <_dtoa_r+0x14c>
80009e40:	f8 cc fb ee 	sub	r12,r12,-1042
80009e44:	40 3b       	lddsp	r11,sp[0xc]
80009e46:	ea 08 11 40 	rsub	r8,r5,64
80009e4a:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009e4e:	ec 08 09 46 	lsl	r6,r6,r8
80009e52:	0c 4c       	or	r12,r6
80009e54:	c0 78       	rjmp	80009e62 <_dtoa_r+0x156>
80009e56:	d7 03       	nop
80009e58:	ea 0c 11 20 	rsub	r12,r5,32
80009e5c:	40 3a       	lddsp	r10,sp[0xc]
80009e5e:	f4 0c 09 4c 	lsl	r12,r10,r12
80009e62:	e0 a0 0d be 	rcall	8000b9de <__avr32_u32_to_f64>
80009e66:	fc 18 fe 10 	movh	r8,0xfe10
80009e6a:	30 19       	mov	r9,1
80009e6c:	ea c5 04 33 	sub	r5,r5,1075
80009e70:	f0 0b 00 0b 	add	r11,r8,r11
80009e74:	51 79       	stdsp	sp[0x5c],r9
80009e76:	30 08       	mov	r8,0
80009e78:	fc 19 3f f8 	movh	r9,0x3ff8
80009e7c:	e0 a0 0c 46 	rcall	8000b708 <__avr32_f64_sub>
80009e80:	e0 68 43 61 	mov	r8,17249
80009e84:	ea 18 63 6f 	orh	r8,0x636f
80009e88:	e0 69 87 a7 	mov	r9,34727
80009e8c:	ea 19 3f d2 	orh	r9,0x3fd2
80009e90:	e0 a0 0b 50 	rcall	8000b530 <__avr32_f64_mul>
80009e94:	e0 68 c8 b3 	mov	r8,51379
80009e98:	ea 18 8b 60 	orh	r8,0x8b60
80009e9c:	e0 69 8a 28 	mov	r9,35368
80009ea0:	ea 19 3f c6 	orh	r9,0x3fc6
80009ea4:	e0 a0 0d 00 	rcall	8000b8a4 <__avr32_f64_add>
80009ea8:	0a 9c       	mov	r12,r5
80009eaa:	14 90       	mov	r0,r10
80009eac:	16 91       	mov	r1,r11
80009eae:	e0 a0 0d 9c 	rcall	8000b9e6 <__avr32_s32_to_f64>
80009eb2:	e0 68 79 fb 	mov	r8,31227
80009eb6:	ea 18 50 9f 	orh	r8,0x509f
80009eba:	e0 69 44 13 	mov	r9,17427
80009ebe:	ea 19 3f d3 	orh	r9,0x3fd3
80009ec2:	e0 a0 0b 37 	rcall	8000b530 <__avr32_f64_mul>
80009ec6:	14 98       	mov	r8,r10
80009ec8:	16 99       	mov	r9,r11
80009eca:	00 9a       	mov	r10,r0
80009ecc:	02 9b       	mov	r11,r1
80009ece:	e0 a0 0c eb 	rcall	8000b8a4 <__avr32_f64_add>
80009ed2:	14 90       	mov	r0,r10
80009ed4:	16 91       	mov	r1,r11
80009ed6:	e0 a0 0d 71 	rcall	8000b9b8 <__avr32_f64_to_s32>
80009eda:	30 08       	mov	r8,0
80009edc:	18 96       	mov	r6,r12
80009ede:	30 09       	mov	r9,0
80009ee0:	00 9a       	mov	r10,r0
80009ee2:	02 9b       	mov	r11,r1
80009ee4:	e0 a0 0e 38 	rcall	8000bb54 <__avr32_f64_cmp_lt>
80009ee8:	c0 c0       	breq	80009f00 <_dtoa_r+0x1f4>
80009eea:	0c 9c       	mov	r12,r6
80009eec:	e0 a0 0d 7d 	rcall	8000b9e6 <__avr32_s32_to_f64>
80009ef0:	14 98       	mov	r8,r10
80009ef2:	16 99       	mov	r9,r11
80009ef4:	00 9a       	mov	r10,r0
80009ef6:	02 9b       	mov	r11,r1
80009ef8:	e0 a0 0d e7 	rcall	8000bac6 <__avr32_f64_cmp_eq>
80009efc:	f7 b6 00 01 	subeq	r6,1
80009f00:	59 66       	cp.w	r6,22
80009f02:	e0 88 00 05 	brls	80009f0c <_dtoa_r+0x200>
80009f06:	30 18       	mov	r8,1
80009f08:	51 48       	stdsp	sp[0x50],r8
80009f0a:	c1 38       	rjmp	80009f30 <_dtoa_r+0x224>
80009f0c:	fe c8 d5 44 	sub	r8,pc,-10940
80009f10:	fa ea 00 3c 	ld.d	r10,sp[60]
80009f14:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009f18:	e0 a0 0e 1e 	rcall	8000bb54 <__avr32_f64_cmp_lt>
80009f1c:	f9 b4 00 00 	moveq	r4,0
80009f20:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009f24:	f7 b6 01 01 	subne	r6,1
80009f28:	f9 bc 01 00 	movne	r12,0
80009f2c:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009f30:	41 90       	lddsp	r0,sp[0x64]
80009f32:	20 10       	sub	r0,1
80009f34:	0a 10       	sub	r0,r5
80009f36:	c0 46       	brmi	80009f3e <_dtoa_r+0x232>
80009f38:	50 40       	stdsp	sp[0x10],r0
80009f3a:	30 00       	mov	r0,0
80009f3c:	c0 48       	rjmp	80009f44 <_dtoa_r+0x238>
80009f3e:	30 0b       	mov	r11,0
80009f40:	5c 30       	neg	r0
80009f42:	50 4b       	stdsp	sp[0x10],r11
80009f44:	ec 02 11 00 	rsub	r2,r6,0
80009f48:	58 06       	cp.w	r6,0
80009f4a:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009f4e:	f5 d6 e4 0a 	addge	r10,r10,r6
80009f52:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009f56:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009f5a:	f9 b2 04 00 	movge	r2,0
80009f5e:	e1 d6 e5 10 	sublt	r0,r0,r6
80009f62:	f9 b9 05 00 	movlt	r9,0
80009f66:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009f6a:	40 c8       	lddsp	r8,sp[0x30]
80009f6c:	58 98       	cp.w	r8,9
80009f6e:	e0 8b 00 20 	brhi	80009fae <_dtoa_r+0x2a2>
80009f72:	58 58       	cp.w	r8,5
80009f74:	f9 b4 0a 01 	movle	r4,1
80009f78:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009f7c:	f7 b5 09 04 	subgt	r5,4
80009f80:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009f84:	f9 b4 09 00 	movgt	r4,0
80009f88:	40 cc       	lddsp	r12,sp[0x30]
80009f8a:	58 3c       	cp.w	r12,3
80009f8c:	c2 d0       	breq	80009fe6 <_dtoa_r+0x2da>
80009f8e:	e0 89 00 05 	brgt	80009f98 <_dtoa_r+0x28c>
80009f92:	58 2c       	cp.w	r12,2
80009f94:	c1 01       	brne	80009fb4 <_dtoa_r+0x2a8>
80009f96:	c1 88       	rjmp	80009fc6 <_dtoa_r+0x2ba>
80009f98:	40 cb       	lddsp	r11,sp[0x30]
80009f9a:	58 4b       	cp.w	r11,4
80009f9c:	c0 60       	breq	80009fa8 <_dtoa_r+0x29c>
80009f9e:	58 5b       	cp.w	r11,5
80009fa0:	c0 a1       	brne	80009fb4 <_dtoa_r+0x2a8>
80009fa2:	30 1a       	mov	r10,1
80009fa4:	50 da       	stdsp	sp[0x34],r10
80009fa6:	c2 28       	rjmp	80009fea <_dtoa_r+0x2de>
80009fa8:	30 19       	mov	r9,1
80009faa:	50 d9       	stdsp	sp[0x34],r9
80009fac:	c0 f8       	rjmp	80009fca <_dtoa_r+0x2be>
80009fae:	30 08       	mov	r8,0
80009fb0:	30 14       	mov	r4,1
80009fb2:	50 c8       	stdsp	sp[0x30],r8
80009fb4:	3f f5       	mov	r5,-1
80009fb6:	30 1c       	mov	r12,1
80009fb8:	30 0b       	mov	r11,0
80009fba:	50 95       	stdsp	sp[0x24],r5
80009fbc:	50 dc       	stdsp	sp[0x34],r12
80009fbe:	0a 91       	mov	r1,r5
80009fc0:	31 28       	mov	r8,18
80009fc2:	50 eb       	stdsp	sp[0x38],r11
80009fc4:	c2 08       	rjmp	8000a004 <_dtoa_r+0x2f8>
80009fc6:	30 0a       	mov	r10,0
80009fc8:	50 da       	stdsp	sp[0x34],r10
80009fca:	40 e9       	lddsp	r9,sp[0x38]
80009fcc:	58 09       	cp.w	r9,0
80009fce:	e0 89 00 07 	brgt	80009fdc <_dtoa_r+0x2d0>
80009fd2:	30 18       	mov	r8,1
80009fd4:	50 98       	stdsp	sp[0x24],r8
80009fd6:	10 91       	mov	r1,r8
80009fd8:	50 e8       	stdsp	sp[0x38],r8
80009fda:	c1 58       	rjmp	8000a004 <_dtoa_r+0x2f8>
80009fdc:	40 e5       	lddsp	r5,sp[0x38]
80009fde:	50 95       	stdsp	sp[0x24],r5
80009fe0:	0a 91       	mov	r1,r5
80009fe2:	0a 98       	mov	r8,r5
80009fe4:	c1 08       	rjmp	8000a004 <_dtoa_r+0x2f8>
80009fe6:	30 0c       	mov	r12,0
80009fe8:	50 dc       	stdsp	sp[0x34],r12
80009fea:	40 eb       	lddsp	r11,sp[0x38]
80009fec:	ec 0b 00 0b 	add	r11,r6,r11
80009ff0:	50 9b       	stdsp	sp[0x24],r11
80009ff2:	16 98       	mov	r8,r11
80009ff4:	2f f8       	sub	r8,-1
80009ff6:	58 08       	cp.w	r8,0
80009ff8:	e0 89 00 05 	brgt	8000a002 <_dtoa_r+0x2f6>
80009ffc:	10 91       	mov	r1,r8
80009ffe:	30 18       	mov	r8,1
8000a000:	c0 28       	rjmp	8000a004 <_dtoa_r+0x2f8>
8000a002:	10 91       	mov	r1,r8
8000a004:	30 09       	mov	r9,0
8000a006:	6e 9a       	ld.w	r10,r7[0x24]
8000a008:	95 19       	st.w	r10[0x4],r9
8000a00a:	30 49       	mov	r9,4
8000a00c:	c0 68       	rjmp	8000a018 <_dtoa_r+0x30c>
8000a00e:	d7 03       	nop
8000a010:	6a 1a       	ld.w	r10,r5[0x4]
8000a012:	a1 79       	lsl	r9,0x1
8000a014:	2f fa       	sub	r10,-1
8000a016:	8b 1a       	st.w	r5[0x4],r10
8000a018:	6e 95       	ld.w	r5,r7[0x24]
8000a01a:	f2 ca ff ec 	sub	r10,r9,-20
8000a01e:	10 3a       	cp.w	r10,r8
8000a020:	fe 98 ff f8 	brls	8000a010 <_dtoa_r+0x304>
8000a024:	6a 1b       	ld.w	r11,r5[0x4]
8000a026:	0e 9c       	mov	r12,r7
8000a028:	e0 a0 07 c4 	rcall	8000afb0 <_Balloc>
8000a02c:	58 e1       	cp.w	r1,14
8000a02e:	5f 88       	srls	r8
8000a030:	8b 0c       	st.w	r5[0x0],r12
8000a032:	f1 e4 00 04 	and	r4,r8,r4
8000a036:	6e 98       	ld.w	r8,r7[0x24]
8000a038:	70 08       	ld.w	r8,r8[0x0]
8000a03a:	50 88       	stdsp	sp[0x20],r8
8000a03c:	e0 80 01 82 	breq	8000a340 <_dtoa_r+0x634>
8000a040:	58 06       	cp.w	r6,0
8000a042:	e0 8a 00 43 	brle	8000a0c8 <_dtoa_r+0x3bc>
8000a046:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a04a:	fe c8 d6 82 	sub	r8,pc,-10622
8000a04e:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a052:	fa e5 00 18 	st.d	sp[24],r4
8000a056:	ec 04 14 04 	asr	r4,r6,0x4
8000a05a:	ed b4 00 04 	bld	r4,0x4
8000a05e:	c0 30       	breq	8000a064 <_dtoa_r+0x358>
8000a060:	30 25       	mov	r5,2
8000a062:	c1 08       	rjmp	8000a082 <_dtoa_r+0x376>
8000a064:	fe c8 d5 d4 	sub	r8,pc,-10796
8000a068:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a06c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a070:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a074:	e0 a0 0d a4 	rcall	8000bbbc <__avr32_f64_div>
8000a078:	30 35       	mov	r5,3
8000a07a:	14 98       	mov	r8,r10
8000a07c:	16 99       	mov	r9,r11
8000a07e:	fa e9 00 08 	st.d	sp[8],r8
8000a082:	fe cc d5 f2 	sub	r12,pc,-10766
8000a086:	50 a3       	stdsp	sp[0x28],r3
8000a088:	0c 93       	mov	r3,r6
8000a08a:	18 96       	mov	r6,r12
8000a08c:	c0 f8       	rjmp	8000a0aa <_dtoa_r+0x39e>
8000a08e:	fa ea 00 18 	ld.d	r10,sp[24]
8000a092:	ed b4 00 00 	bld	r4,0x0
8000a096:	c0 81       	brne	8000a0a6 <_dtoa_r+0x39a>
8000a098:	ec e8 00 00 	ld.d	r8,r6[0]
8000a09c:	2f f5       	sub	r5,-1
8000a09e:	e0 a0 0a 49 	rcall	8000b530 <__avr32_f64_mul>
8000a0a2:	fa eb 00 18 	st.d	sp[24],r10
8000a0a6:	a1 54       	asr	r4,0x1
8000a0a8:	2f 86       	sub	r6,-8
8000a0aa:	58 04       	cp.w	r4,0
8000a0ac:	cf 11       	brne	8000a08e <_dtoa_r+0x382>
8000a0ae:	fa e8 00 18 	ld.d	r8,sp[24]
8000a0b2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a0b6:	06 96       	mov	r6,r3
8000a0b8:	e0 a0 0d 82 	rcall	8000bbbc <__avr32_f64_div>
8000a0bc:	40 a3       	lddsp	r3,sp[0x28]
8000a0be:	14 98       	mov	r8,r10
8000a0c0:	16 99       	mov	r9,r11
8000a0c2:	fa e9 00 08 	st.d	sp[8],r8
8000a0c6:	c2 f8       	rjmp	8000a124 <_dtoa_r+0x418>
8000a0c8:	ec 08 11 00 	rsub	r8,r6,0
8000a0cc:	c0 31       	brne	8000a0d2 <_dtoa_r+0x3c6>
8000a0ce:	30 25       	mov	r5,2
8000a0d0:	c2 a8       	rjmp	8000a124 <_dtoa_r+0x418>
8000a0d2:	fe cc d6 42 	sub	r12,pc,-10686
8000a0d6:	f0 04 14 04 	asr	r4,r8,0x4
8000a0da:	50 1c       	stdsp	sp[0x4],r12
8000a0dc:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a0e0:	fe c9 d7 18 	sub	r9,pc,-10472
8000a0e4:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a0e8:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a0ec:	e0 a0 0a 22 	rcall	8000b530 <__avr32_f64_mul>
8000a0f0:	40 1c       	lddsp	r12,sp[0x4]
8000a0f2:	50 63       	stdsp	sp[0x18],r3
8000a0f4:	30 25       	mov	r5,2
8000a0f6:	0c 93       	mov	r3,r6
8000a0f8:	fa eb 00 08 	st.d	sp[8],r10
8000a0fc:	18 96       	mov	r6,r12
8000a0fe:	c0 f8       	rjmp	8000a11c <_dtoa_r+0x410>
8000a100:	fa ea 00 08 	ld.d	r10,sp[8]
8000a104:	ed b4 00 00 	bld	r4,0x0
8000a108:	c0 81       	brne	8000a118 <_dtoa_r+0x40c>
8000a10a:	ec e8 00 00 	ld.d	r8,r6[0]
8000a10e:	2f f5       	sub	r5,-1
8000a110:	e0 a0 0a 10 	rcall	8000b530 <__avr32_f64_mul>
8000a114:	fa eb 00 08 	st.d	sp[8],r10
8000a118:	a1 54       	asr	r4,0x1
8000a11a:	2f 86       	sub	r6,-8
8000a11c:	58 04       	cp.w	r4,0
8000a11e:	cf 11       	brne	8000a100 <_dtoa_r+0x3f4>
8000a120:	06 96       	mov	r6,r3
8000a122:	40 63       	lddsp	r3,sp[0x18]
8000a124:	41 4a       	lddsp	r10,sp[0x50]
8000a126:	58 0a       	cp.w	r10,0
8000a128:	c2 a0       	breq	8000a17c <_dtoa_r+0x470>
8000a12a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a12e:	58 01       	cp.w	r1,0
8000a130:	5f 94       	srgt	r4
8000a132:	fa e9 00 18 	st.d	sp[24],r8
8000a136:	30 08       	mov	r8,0
8000a138:	fc 19 3f f0 	movh	r9,0x3ff0
8000a13c:	fa ea 00 18 	ld.d	r10,sp[24]
8000a140:	e0 a0 0d 0a 	rcall	8000bb54 <__avr32_f64_cmp_lt>
8000a144:	f9 bc 00 00 	moveq	r12,0
8000a148:	f9 bc 01 01 	movne	r12,1
8000a14c:	e9 ec 00 0c 	and	r12,r4,r12
8000a150:	c1 60       	breq	8000a17c <_dtoa_r+0x470>
8000a152:	40 98       	lddsp	r8,sp[0x24]
8000a154:	58 08       	cp.w	r8,0
8000a156:	e0 8a 00 f1 	brle	8000a338 <_dtoa_r+0x62c>
8000a15a:	30 08       	mov	r8,0
8000a15c:	fc 19 40 24 	movh	r9,0x4024
8000a160:	ec c4 00 01 	sub	r4,r6,1
8000a164:	fa ea 00 18 	ld.d	r10,sp[24]
8000a168:	2f f5       	sub	r5,-1
8000a16a:	50 64       	stdsp	sp[0x18],r4
8000a16c:	e0 a0 09 e2 	rcall	8000b530 <__avr32_f64_mul>
8000a170:	40 94       	lddsp	r4,sp[0x24]
8000a172:	14 98       	mov	r8,r10
8000a174:	16 99       	mov	r9,r11
8000a176:	fa e9 00 08 	st.d	sp[8],r8
8000a17a:	c0 38       	rjmp	8000a180 <_dtoa_r+0x474>
8000a17c:	50 66       	stdsp	sp[0x18],r6
8000a17e:	02 94       	mov	r4,r1
8000a180:	0a 9c       	mov	r12,r5
8000a182:	e0 a0 0c 32 	rcall	8000b9e6 <__avr32_s32_to_f64>
8000a186:	fa e8 00 08 	ld.d	r8,sp[8]
8000a18a:	e0 a0 09 d3 	rcall	8000b530 <__avr32_f64_mul>
8000a18e:	30 08       	mov	r8,0
8000a190:	fc 19 40 1c 	movh	r9,0x401c
8000a194:	e0 a0 0b 88 	rcall	8000b8a4 <__avr32_f64_add>
8000a198:	14 98       	mov	r8,r10
8000a19a:	16 99       	mov	r9,r11
8000a19c:	fa e9 00 28 	st.d	sp[40],r8
8000a1a0:	fc 18 fc c0 	movh	r8,0xfcc0
8000a1a4:	40 a5       	lddsp	r5,sp[0x28]
8000a1a6:	10 05       	add	r5,r8
8000a1a8:	50 a5       	stdsp	sp[0x28],r5
8000a1aa:	58 04       	cp.w	r4,0
8000a1ac:	c2 11       	brne	8000a1ee <_dtoa_r+0x4e2>
8000a1ae:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1b2:	30 08       	mov	r8,0
8000a1b4:	fc 19 40 14 	movh	r9,0x4014
8000a1b8:	e0 a0 0a a8 	rcall	8000b708 <__avr32_f64_sub>
8000a1bc:	40 bc       	lddsp	r12,sp[0x2c]
8000a1be:	fa eb 00 08 	st.d	sp[8],r10
8000a1c2:	14 98       	mov	r8,r10
8000a1c4:	16 99       	mov	r9,r11
8000a1c6:	18 9a       	mov	r10,r12
8000a1c8:	0a 9b       	mov	r11,r5
8000a1ca:	e0 a0 0c c5 	rcall	8000bb54 <__avr32_f64_cmp_lt>
8000a1ce:	e0 81 02 54 	brne	8000a676 <_dtoa_r+0x96a>
8000a1d2:	0a 98       	mov	r8,r5
8000a1d4:	40 b9       	lddsp	r9,sp[0x2c]
8000a1d6:	ee 18 80 00 	eorh	r8,0x8000
8000a1da:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1de:	10 95       	mov	r5,r8
8000a1e0:	12 98       	mov	r8,r9
8000a1e2:	0a 99       	mov	r9,r5
8000a1e4:	e0 a0 0c b8 	rcall	8000bb54 <__avr32_f64_cmp_lt>
8000a1e8:	e0 81 02 3e 	brne	8000a664 <_dtoa_r+0x958>
8000a1ec:	ca 68       	rjmp	8000a338 <_dtoa_r+0x62c>
8000a1ee:	fe c9 d8 26 	sub	r9,pc,-10202
8000a1f2:	e8 c8 00 01 	sub	r8,r4,1
8000a1f6:	40 d5       	lddsp	r5,sp[0x34]
8000a1f8:	58 05       	cp.w	r5,0
8000a1fa:	c4 f0       	breq	8000a298 <_dtoa_r+0x58c>
8000a1fc:	30 0c       	mov	r12,0
8000a1fe:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a202:	51 3c       	stdsp	sp[0x4c],r12
8000a204:	30 0a       	mov	r10,0
8000a206:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a20a:	e0 a0 0c d9 	rcall	8000bbbc <__avr32_f64_div>
8000a20e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a212:	40 85       	lddsp	r5,sp[0x20]
8000a214:	e0 a0 0a 7a 	rcall	8000b708 <__avr32_f64_sub>
8000a218:	fa eb 00 28 	st.d	sp[40],r10
8000a21c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a220:	e0 a0 0b cc 	rcall	8000b9b8 <__avr32_f64_to_s32>
8000a224:	51 6c       	stdsp	sp[0x58],r12
8000a226:	e0 a0 0b e0 	rcall	8000b9e6 <__avr32_s32_to_f64>
8000a22a:	14 98       	mov	r8,r10
8000a22c:	16 99       	mov	r9,r11
8000a22e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a232:	e0 a0 0a 6b 	rcall	8000b708 <__avr32_f64_sub>
8000a236:	fa eb 00 08 	st.d	sp[8],r10
8000a23a:	41 68       	lddsp	r8,sp[0x58]
8000a23c:	2d 08       	sub	r8,-48
8000a23e:	0a c8       	st.b	r5++,r8
8000a240:	41 39       	lddsp	r9,sp[0x4c]
8000a242:	2f f9       	sub	r9,-1
8000a244:	51 39       	stdsp	sp[0x4c],r9
8000a246:	fa e8 00 28 	ld.d	r8,sp[40]
8000a24a:	e0 a0 0c 85 	rcall	8000bb54 <__avr32_f64_cmp_lt>
8000a24e:	e0 81 03 39 	brne	8000a8c0 <_dtoa_r+0xbb4>
8000a252:	fa e8 00 08 	ld.d	r8,sp[8]
8000a256:	30 0a       	mov	r10,0
8000a258:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a25c:	e0 a0 0a 56 	rcall	8000b708 <__avr32_f64_sub>
8000a260:	fa e8 00 28 	ld.d	r8,sp[40]
8000a264:	e0 a0 0c 78 	rcall	8000bb54 <__avr32_f64_cmp_lt>
8000a268:	fa ea 00 28 	ld.d	r10,sp[40]
8000a26c:	30 08       	mov	r8,0
8000a26e:	fc 19 40 24 	movh	r9,0x4024
8000a272:	e0 81 00 da 	brne	8000a426 <_dtoa_r+0x71a>
8000a276:	41 3c       	lddsp	r12,sp[0x4c]
8000a278:	08 3c       	cp.w	r12,r4
8000a27a:	c5 f4       	brge	8000a338 <_dtoa_r+0x62c>
8000a27c:	e0 a0 09 5a 	rcall	8000b530 <__avr32_f64_mul>
8000a280:	30 08       	mov	r8,0
8000a282:	fa eb 00 28 	st.d	sp[40],r10
8000a286:	fc 19 40 24 	movh	r9,0x4024
8000a28a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a28e:	e0 a0 09 51 	rcall	8000b530 <__avr32_f64_mul>
8000a292:	fa eb 00 08 	st.d	sp[8],r10
8000a296:	cc 3b       	rjmp	8000a21c <_dtoa_r+0x510>
8000a298:	40 85       	lddsp	r5,sp[0x20]
8000a29a:	08 05       	add	r5,r4
8000a29c:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a2a0:	51 35       	stdsp	sp[0x4c],r5
8000a2a2:	fa e8 00 28 	ld.d	r8,sp[40]
8000a2a6:	40 85       	lddsp	r5,sp[0x20]
8000a2a8:	e0 a0 09 44 	rcall	8000b530 <__avr32_f64_mul>
8000a2ac:	fa eb 00 28 	st.d	sp[40],r10
8000a2b0:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2b4:	e0 a0 0b 82 	rcall	8000b9b8 <__avr32_f64_to_s32>
8000a2b8:	51 6c       	stdsp	sp[0x58],r12
8000a2ba:	e0 a0 0b 96 	rcall	8000b9e6 <__avr32_s32_to_f64>
8000a2be:	14 98       	mov	r8,r10
8000a2c0:	16 99       	mov	r9,r11
8000a2c2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2c6:	e0 a0 0a 21 	rcall	8000b708 <__avr32_f64_sub>
8000a2ca:	fa eb 00 08 	st.d	sp[8],r10
8000a2ce:	41 68       	lddsp	r8,sp[0x58]
8000a2d0:	2d 08       	sub	r8,-48
8000a2d2:	0a c8       	st.b	r5++,r8
8000a2d4:	41 3c       	lddsp	r12,sp[0x4c]
8000a2d6:	18 35       	cp.w	r5,r12
8000a2d8:	c2 81       	brne	8000a328 <_dtoa_r+0x61c>
8000a2da:	30 08       	mov	r8,0
8000a2dc:	fc 19 3f e0 	movh	r9,0x3fe0
8000a2e0:	fa ea 00 28 	ld.d	r10,sp[40]
8000a2e4:	e0 a0 0a e0 	rcall	8000b8a4 <__avr32_f64_add>
8000a2e8:	40 85       	lddsp	r5,sp[0x20]
8000a2ea:	fa e8 00 08 	ld.d	r8,sp[8]
8000a2ee:	08 05       	add	r5,r4
8000a2f0:	e0 a0 0c 32 	rcall	8000bb54 <__avr32_f64_cmp_lt>
8000a2f4:	e0 81 00 99 	brne	8000a426 <_dtoa_r+0x71a>
8000a2f8:	fa e8 00 28 	ld.d	r8,sp[40]
8000a2fc:	30 0a       	mov	r10,0
8000a2fe:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a302:	e0 a0 0a 03 	rcall	8000b708 <__avr32_f64_sub>
8000a306:	14 98       	mov	r8,r10
8000a308:	16 99       	mov	r9,r11
8000a30a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a30e:	e0 a0 0c 23 	rcall	8000bb54 <__avr32_f64_cmp_lt>
8000a312:	c1 30       	breq	8000a338 <_dtoa_r+0x62c>
8000a314:	33 09       	mov	r9,48
8000a316:	0a 98       	mov	r8,r5
8000a318:	11 7a       	ld.ub	r10,--r8
8000a31a:	f2 0a 18 00 	cp.b	r10,r9
8000a31e:	e0 81 02 d1 	brne	8000a8c0 <_dtoa_r+0xbb4>
8000a322:	10 95       	mov	r5,r8
8000a324:	cf 9b       	rjmp	8000a316 <_dtoa_r+0x60a>
8000a326:	d7 03       	nop
8000a328:	30 08       	mov	r8,0
8000a32a:	fc 19 40 24 	movh	r9,0x4024
8000a32e:	e0 a0 09 01 	rcall	8000b530 <__avr32_f64_mul>
8000a332:	fa eb 00 08 	st.d	sp[8],r10
8000a336:	cb db       	rjmp	8000a2b0 <_dtoa_r+0x5a4>
8000a338:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a33c:	fa eb 00 08 	st.d	sp[8],r10
8000a340:	58 e6       	cp.w	r6,14
8000a342:	5f ab       	srle	r11
8000a344:	41 8a       	lddsp	r10,sp[0x60]
8000a346:	30 08       	mov	r8,0
8000a348:	f4 09 11 ff 	rsub	r9,r10,-1
8000a34c:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a350:	f0 09 18 00 	cp.b	r9,r8
8000a354:	e0 80 00 82 	breq	8000a458 <_dtoa_r+0x74c>
8000a358:	40 ea       	lddsp	r10,sp[0x38]
8000a35a:	58 01       	cp.w	r1,0
8000a35c:	5f a9       	srle	r9
8000a35e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a362:	fe ca d9 9a 	sub	r10,pc,-9830
8000a366:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a36a:	fa e5 00 10 	st.d	sp[16],r4
8000a36e:	f0 09 18 00 	cp.b	r9,r8
8000a372:	c1 40       	breq	8000a39a <_dtoa_r+0x68e>
8000a374:	58 01       	cp.w	r1,0
8000a376:	e0 81 01 77 	brne	8000a664 <_dtoa_r+0x958>
8000a37a:	30 08       	mov	r8,0
8000a37c:	fc 19 40 14 	movh	r9,0x4014
8000a380:	08 9a       	mov	r10,r4
8000a382:	0a 9b       	mov	r11,r5
8000a384:	e0 a0 08 d6 	rcall	8000b530 <__avr32_f64_mul>
8000a388:	fa e8 00 08 	ld.d	r8,sp[8]
8000a38c:	e0 a0 0b b0 	rcall	8000baec <__avr32_f64_cmp_ge>
8000a390:	e0 81 01 6a 	brne	8000a664 <_dtoa_r+0x958>
8000a394:	02 92       	mov	r2,r1
8000a396:	e0 8f 01 72 	bral	8000a67a <_dtoa_r+0x96e>
8000a39a:	40 85       	lddsp	r5,sp[0x20]
8000a39c:	30 14       	mov	r4,1
8000a39e:	fa e8 00 10 	ld.d	r8,sp[16]
8000a3a2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a3a6:	e0 a0 0c 0b 	rcall	8000bbbc <__avr32_f64_div>
8000a3aa:	e0 a0 0b 07 	rcall	8000b9b8 <__avr32_f64_to_s32>
8000a3ae:	18 92       	mov	r2,r12
8000a3b0:	e0 a0 0b 1b 	rcall	8000b9e6 <__avr32_s32_to_f64>
8000a3b4:	fa e8 00 10 	ld.d	r8,sp[16]
8000a3b8:	e0 a0 08 bc 	rcall	8000b530 <__avr32_f64_mul>
8000a3bc:	14 98       	mov	r8,r10
8000a3be:	16 99       	mov	r9,r11
8000a3c0:	fa ea 00 08 	ld.d	r10,sp[8]
8000a3c4:	e0 a0 09 a2 	rcall	8000b708 <__avr32_f64_sub>
8000a3c8:	fa eb 00 08 	st.d	sp[8],r10
8000a3cc:	e4 c8 ff d0 	sub	r8,r2,-48
8000a3d0:	0a c8       	st.b	r5++,r8
8000a3d2:	fc 19 40 24 	movh	r9,0x4024
8000a3d6:	30 08       	mov	r8,0
8000a3d8:	02 34       	cp.w	r4,r1
8000a3da:	c3 31       	brne	8000a440 <_dtoa_r+0x734>
8000a3dc:	fa e8 00 08 	ld.d	r8,sp[8]
8000a3e0:	e0 a0 0a 62 	rcall	8000b8a4 <__avr32_f64_add>
8000a3e4:	16 91       	mov	r1,r11
8000a3e6:	14 90       	mov	r0,r10
8000a3e8:	14 98       	mov	r8,r10
8000a3ea:	02 99       	mov	r9,r1
8000a3ec:	fa ea 00 10 	ld.d	r10,sp[16]
8000a3f0:	e0 a0 0b b2 	rcall	8000bb54 <__avr32_f64_cmp_lt>
8000a3f4:	c1 a1       	brne	8000a428 <_dtoa_r+0x71c>
8000a3f6:	fa e8 00 10 	ld.d	r8,sp[16]
8000a3fa:	00 9a       	mov	r10,r0
8000a3fc:	02 9b       	mov	r11,r1
8000a3fe:	e0 a0 0b 64 	rcall	8000bac6 <__avr32_f64_cmp_eq>
8000a402:	e0 80 02 5e 	breq	8000a8be <_dtoa_r+0xbb2>
8000a406:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a40a:	c0 f1       	brne	8000a428 <_dtoa_r+0x71c>
8000a40c:	e0 8f 02 59 	bral	8000a8be <_dtoa_r+0xbb2>
8000a410:	40 8a       	lddsp	r10,sp[0x20]
8000a412:	14 38       	cp.w	r8,r10
8000a414:	c0 30       	breq	8000a41a <_dtoa_r+0x70e>
8000a416:	10 95       	mov	r5,r8
8000a418:	c0 98       	rjmp	8000a42a <_dtoa_r+0x71e>
8000a41a:	33 08       	mov	r8,48
8000a41c:	40 89       	lddsp	r9,sp[0x20]
8000a41e:	2f f6       	sub	r6,-1
8000a420:	b2 88       	st.b	r9[0x0],r8
8000a422:	40 88       	lddsp	r8,sp[0x20]
8000a424:	c0 88       	rjmp	8000a434 <_dtoa_r+0x728>
8000a426:	40 66       	lddsp	r6,sp[0x18]
8000a428:	33 99       	mov	r9,57
8000a42a:	0a 98       	mov	r8,r5
8000a42c:	11 7a       	ld.ub	r10,--r8
8000a42e:	f2 0a 18 00 	cp.b	r10,r9
8000a432:	ce f0       	breq	8000a410 <_dtoa_r+0x704>
8000a434:	50 66       	stdsp	sp[0x18],r6
8000a436:	11 89       	ld.ub	r9,r8[0x0]
8000a438:	2f f9       	sub	r9,-1
8000a43a:	b0 89       	st.b	r8[0x0],r9
8000a43c:	e0 8f 02 42 	bral	8000a8c0 <_dtoa_r+0xbb4>
8000a440:	e0 a0 08 78 	rcall	8000b530 <__avr32_f64_mul>
8000a444:	2f f4       	sub	r4,-1
8000a446:	fa eb 00 08 	st.d	sp[8],r10
8000a44a:	30 08       	mov	r8,0
8000a44c:	30 09       	mov	r9,0
8000a44e:	e0 a0 0b 3c 	rcall	8000bac6 <__avr32_f64_cmp_eq>
8000a452:	ca 60       	breq	8000a39e <_dtoa_r+0x692>
8000a454:	e0 8f 02 35 	bral	8000a8be <_dtoa_r+0xbb2>
8000a458:	40 d8       	lddsp	r8,sp[0x34]
8000a45a:	58 08       	cp.w	r8,0
8000a45c:	c0 51       	brne	8000a466 <_dtoa_r+0x75a>
8000a45e:	04 98       	mov	r8,r2
8000a460:	00 95       	mov	r5,r0
8000a462:	40 d4       	lddsp	r4,sp[0x34]
8000a464:	c3 78       	rjmp	8000a4d2 <_dtoa_r+0x7c6>
8000a466:	40 c5       	lddsp	r5,sp[0x30]
8000a468:	58 15       	cp.w	r5,1
8000a46a:	e0 89 00 0f 	brgt	8000a488 <_dtoa_r+0x77c>
8000a46e:	41 74       	lddsp	r4,sp[0x5c]
8000a470:	58 04       	cp.w	r4,0
8000a472:	c0 40       	breq	8000a47a <_dtoa_r+0x76e>
8000a474:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a478:	c0 48       	rjmp	8000a480 <_dtoa_r+0x774>
8000a47a:	41 99       	lddsp	r9,sp[0x64]
8000a47c:	f2 09 11 36 	rsub	r9,r9,54
8000a480:	04 98       	mov	r8,r2
8000a482:	00 95       	mov	r5,r0
8000a484:	c1 c8       	rjmp	8000a4bc <_dtoa_r+0x7b0>
8000a486:	d7 03       	nop
8000a488:	e2 c8 00 01 	sub	r8,r1,1
8000a48c:	58 01       	cp.w	r1,0
8000a48e:	e0 05 17 40 	movge	r5,r0
8000a492:	e2 09 17 40 	movge	r9,r1
8000a496:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a49a:	f9 b9 05 00 	movlt	r9,0
8000a49e:	10 32       	cp.w	r2,r8
8000a4a0:	e5 d8 e4 18 	subge	r8,r2,r8
8000a4a4:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a4a8:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a4ac:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a4b0:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a4b4:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a4b8:	f9 b8 05 00 	movlt	r8,0
8000a4bc:	40 4b       	lddsp	r11,sp[0x10]
8000a4be:	12 0b       	add	r11,r9
8000a4c0:	50 08       	stdsp	sp[0x0],r8
8000a4c2:	50 4b       	stdsp	sp[0x10],r11
8000a4c4:	12 00       	add	r0,r9
8000a4c6:	30 1b       	mov	r11,1
8000a4c8:	0e 9c       	mov	r12,r7
8000a4ca:	e0 a0 07 27 	rcall	8000b318 <__i2b>
8000a4ce:	40 08       	lddsp	r8,sp[0x0]
8000a4d0:	18 94       	mov	r4,r12
8000a4d2:	40 4a       	lddsp	r10,sp[0x10]
8000a4d4:	58 05       	cp.w	r5,0
8000a4d6:	5f 99       	srgt	r9
8000a4d8:	58 0a       	cp.w	r10,0
8000a4da:	5f 9a       	srgt	r10
8000a4dc:	f5 e9 00 09 	and	r9,r10,r9
8000a4e0:	c0 80       	breq	8000a4f0 <_dtoa_r+0x7e4>
8000a4e2:	40 4c       	lddsp	r12,sp[0x10]
8000a4e4:	f8 05 0d 49 	min	r9,r12,r5
8000a4e8:	12 1c       	sub	r12,r9
8000a4ea:	12 10       	sub	r0,r9
8000a4ec:	50 4c       	stdsp	sp[0x10],r12
8000a4ee:	12 15       	sub	r5,r9
8000a4f0:	58 02       	cp.w	r2,0
8000a4f2:	e0 8a 00 27 	brle	8000a540 <_dtoa_r+0x834>
8000a4f6:	40 db       	lddsp	r11,sp[0x34]
8000a4f8:	58 0b       	cp.w	r11,0
8000a4fa:	c1 d0       	breq	8000a534 <_dtoa_r+0x828>
8000a4fc:	58 08       	cp.w	r8,0
8000a4fe:	e0 8a 00 17 	brle	8000a52c <_dtoa_r+0x820>
8000a502:	10 9a       	mov	r10,r8
8000a504:	50 08       	stdsp	sp[0x0],r8
8000a506:	08 9b       	mov	r11,r4
8000a508:	0e 9c       	mov	r12,r7
8000a50a:	e0 a0 07 4d 	rcall	8000b3a4 <__pow5mult>
8000a50e:	06 9a       	mov	r10,r3
8000a510:	18 9b       	mov	r11,r12
8000a512:	18 94       	mov	r4,r12
8000a514:	0e 9c       	mov	r12,r7
8000a516:	e0 a0 06 81 	rcall	8000b218 <__multiply>
8000a51a:	18 99       	mov	r9,r12
8000a51c:	06 9b       	mov	r11,r3
8000a51e:	50 19       	stdsp	sp[0x4],r9
8000a520:	0e 9c       	mov	r12,r7
8000a522:	e0 a0 05 2d 	rcall	8000af7c <_Bfree>
8000a526:	40 19       	lddsp	r9,sp[0x4]
8000a528:	40 08       	lddsp	r8,sp[0x0]
8000a52a:	12 93       	mov	r3,r9
8000a52c:	e4 08 01 0a 	sub	r10,r2,r8
8000a530:	c0 80       	breq	8000a540 <_dtoa_r+0x834>
8000a532:	c0 28       	rjmp	8000a536 <_dtoa_r+0x82a>
8000a534:	04 9a       	mov	r10,r2
8000a536:	06 9b       	mov	r11,r3
8000a538:	0e 9c       	mov	r12,r7
8000a53a:	e0 a0 07 35 	rcall	8000b3a4 <__pow5mult>
8000a53e:	18 93       	mov	r3,r12
8000a540:	30 1b       	mov	r11,1
8000a542:	0e 9c       	mov	r12,r7
8000a544:	e0 a0 06 ea 	rcall	8000b318 <__i2b>
8000a548:	41 1a       	lddsp	r10,sp[0x44]
8000a54a:	18 92       	mov	r2,r12
8000a54c:	58 0a       	cp.w	r10,0
8000a54e:	e0 8a 00 07 	brle	8000a55c <_dtoa_r+0x850>
8000a552:	18 9b       	mov	r11,r12
8000a554:	0e 9c       	mov	r12,r7
8000a556:	e0 a0 07 27 	rcall	8000b3a4 <__pow5mult>
8000a55a:	18 92       	mov	r2,r12
8000a55c:	40 c9       	lddsp	r9,sp[0x30]
8000a55e:	58 19       	cp.w	r9,1
8000a560:	e0 89 00 14 	brgt	8000a588 <_dtoa_r+0x87c>
8000a564:	40 38       	lddsp	r8,sp[0xc]
8000a566:	58 08       	cp.w	r8,0
8000a568:	c1 01       	brne	8000a588 <_dtoa_r+0x87c>
8000a56a:	40 29       	lddsp	r9,sp[0x8]
8000a56c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a570:	c0 c1       	brne	8000a588 <_dtoa_r+0x87c>
8000a572:	12 98       	mov	r8,r9
8000a574:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a578:	c0 80       	breq	8000a588 <_dtoa_r+0x87c>
8000a57a:	40 4c       	lddsp	r12,sp[0x10]
8000a57c:	30 1b       	mov	r11,1
8000a57e:	2f fc       	sub	r12,-1
8000a580:	2f f0       	sub	r0,-1
8000a582:	50 4c       	stdsp	sp[0x10],r12
8000a584:	50 6b       	stdsp	sp[0x18],r11
8000a586:	c0 38       	rjmp	8000a58c <_dtoa_r+0x880>
8000a588:	30 0a       	mov	r10,0
8000a58a:	50 6a       	stdsp	sp[0x18],r10
8000a58c:	41 19       	lddsp	r9,sp[0x44]
8000a58e:	58 09       	cp.w	r9,0
8000a590:	c0 31       	brne	8000a596 <_dtoa_r+0x88a>
8000a592:	30 1c       	mov	r12,1
8000a594:	c0 98       	rjmp	8000a5a6 <_dtoa_r+0x89a>
8000a596:	64 48       	ld.w	r8,r2[0x10]
8000a598:	2f c8       	sub	r8,-4
8000a59a:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a59e:	e0 a0 04 5e 	rcall	8000ae5a <__hi0bits>
8000a5a2:	f8 0c 11 20 	rsub	r12,r12,32
8000a5a6:	40 4b       	lddsp	r11,sp[0x10]
8000a5a8:	f8 0b 00 08 	add	r8,r12,r11
8000a5ac:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a5b0:	c0 c0       	breq	8000a5c8 <_dtoa_r+0x8bc>
8000a5b2:	f0 08 11 20 	rsub	r8,r8,32
8000a5b6:	58 48       	cp.w	r8,4
8000a5b8:	e0 8a 00 06 	brle	8000a5c4 <_dtoa_r+0x8b8>
8000a5bc:	20 48       	sub	r8,4
8000a5be:	10 0b       	add	r11,r8
8000a5c0:	50 4b       	stdsp	sp[0x10],r11
8000a5c2:	c0 78       	rjmp	8000a5d0 <_dtoa_r+0x8c4>
8000a5c4:	58 48       	cp.w	r8,4
8000a5c6:	c0 70       	breq	8000a5d4 <_dtoa_r+0x8c8>
8000a5c8:	40 4a       	lddsp	r10,sp[0x10]
8000a5ca:	2e 48       	sub	r8,-28
8000a5cc:	10 0a       	add	r10,r8
8000a5ce:	50 4a       	stdsp	sp[0x10],r10
8000a5d0:	10 00       	add	r0,r8
8000a5d2:	10 05       	add	r5,r8
8000a5d4:	58 00       	cp.w	r0,0
8000a5d6:	e0 8a 00 08 	brle	8000a5e6 <_dtoa_r+0x8da>
8000a5da:	06 9b       	mov	r11,r3
8000a5dc:	00 9a       	mov	r10,r0
8000a5de:	0e 9c       	mov	r12,r7
8000a5e0:	e0 a0 05 d8 	rcall	8000b190 <__lshift>
8000a5e4:	18 93       	mov	r3,r12
8000a5e6:	40 49       	lddsp	r9,sp[0x10]
8000a5e8:	58 09       	cp.w	r9,0
8000a5ea:	e0 8a 00 08 	brle	8000a5fa <_dtoa_r+0x8ee>
8000a5ee:	04 9b       	mov	r11,r2
8000a5f0:	12 9a       	mov	r10,r9
8000a5f2:	0e 9c       	mov	r12,r7
8000a5f4:	e0 a0 05 ce 	rcall	8000b190 <__lshift>
8000a5f8:	18 92       	mov	r2,r12
8000a5fa:	41 48       	lddsp	r8,sp[0x50]
8000a5fc:	58 08       	cp.w	r8,0
8000a5fe:	c1 b0       	breq	8000a634 <_dtoa_r+0x928>
8000a600:	04 9b       	mov	r11,r2
8000a602:	06 9c       	mov	r12,r3
8000a604:	e0 a0 04 a2 	rcall	8000af48 <__mcmp>
8000a608:	c1 64       	brge	8000a634 <_dtoa_r+0x928>
8000a60a:	06 9b       	mov	r11,r3
8000a60c:	30 09       	mov	r9,0
8000a60e:	30 aa       	mov	r10,10
8000a610:	0e 9c       	mov	r12,r7
8000a612:	e0 a0 06 8b 	rcall	8000b328 <__multadd>
8000a616:	20 16       	sub	r6,1
8000a618:	18 93       	mov	r3,r12
8000a61a:	40 dc       	lddsp	r12,sp[0x34]
8000a61c:	58 0c       	cp.w	r12,0
8000a61e:	c0 31       	brne	8000a624 <_dtoa_r+0x918>
8000a620:	40 91       	lddsp	r1,sp[0x24]
8000a622:	c0 98       	rjmp	8000a634 <_dtoa_r+0x928>
8000a624:	08 9b       	mov	r11,r4
8000a626:	40 91       	lddsp	r1,sp[0x24]
8000a628:	30 09       	mov	r9,0
8000a62a:	30 aa       	mov	r10,10
8000a62c:	0e 9c       	mov	r12,r7
8000a62e:	e0 a0 06 7d 	rcall	8000b328 <__multadd>
8000a632:	18 94       	mov	r4,r12
8000a634:	58 01       	cp.w	r1,0
8000a636:	5f a9       	srle	r9
8000a638:	40 cb       	lddsp	r11,sp[0x30]
8000a63a:	58 2b       	cp.w	r11,2
8000a63c:	5f 98       	srgt	r8
8000a63e:	f3 e8 00 08 	and	r8,r9,r8
8000a642:	c2 50       	breq	8000a68c <_dtoa_r+0x980>
8000a644:	58 01       	cp.w	r1,0
8000a646:	c1 11       	brne	8000a668 <_dtoa_r+0x95c>
8000a648:	04 9b       	mov	r11,r2
8000a64a:	02 99       	mov	r9,r1
8000a64c:	30 5a       	mov	r10,5
8000a64e:	0e 9c       	mov	r12,r7
8000a650:	e0 a0 06 6c 	rcall	8000b328 <__multadd>
8000a654:	18 92       	mov	r2,r12
8000a656:	18 9b       	mov	r11,r12
8000a658:	06 9c       	mov	r12,r3
8000a65a:	e0 a0 04 77 	rcall	8000af48 <__mcmp>
8000a65e:	e0 89 00 0f 	brgt	8000a67c <_dtoa_r+0x970>
8000a662:	c0 38       	rjmp	8000a668 <_dtoa_r+0x95c>
8000a664:	30 02       	mov	r2,0
8000a666:	04 94       	mov	r4,r2
8000a668:	40 ea       	lddsp	r10,sp[0x38]
8000a66a:	30 09       	mov	r9,0
8000a66c:	5c da       	com	r10
8000a66e:	40 85       	lddsp	r5,sp[0x20]
8000a670:	50 6a       	stdsp	sp[0x18],r10
8000a672:	50 49       	stdsp	sp[0x10],r9
8000a674:	c0 f9       	rjmp	8000a892 <_dtoa_r+0xb86>
8000a676:	08 92       	mov	r2,r4
8000a678:	40 66       	lddsp	r6,sp[0x18]
8000a67a:	04 94       	mov	r4,r2
8000a67c:	2f f6       	sub	r6,-1
8000a67e:	50 66       	stdsp	sp[0x18],r6
8000a680:	33 18       	mov	r8,49
8000a682:	40 85       	lddsp	r5,sp[0x20]
8000a684:	0a c8       	st.b	r5++,r8
8000a686:	30 08       	mov	r8,0
8000a688:	50 48       	stdsp	sp[0x10],r8
8000a68a:	c0 49       	rjmp	8000a892 <_dtoa_r+0xb86>
8000a68c:	40 dc       	lddsp	r12,sp[0x34]
8000a68e:	58 0c       	cp.w	r12,0
8000a690:	e0 80 00 b5 	breq	8000a7fa <_dtoa_r+0xaee>
8000a694:	58 05       	cp.w	r5,0
8000a696:	e0 8a 00 08 	brle	8000a6a6 <_dtoa_r+0x99a>
8000a69a:	08 9b       	mov	r11,r4
8000a69c:	0a 9a       	mov	r10,r5
8000a69e:	0e 9c       	mov	r12,r7
8000a6a0:	e0 a0 05 78 	rcall	8000b190 <__lshift>
8000a6a4:	18 94       	mov	r4,r12
8000a6a6:	40 6b       	lddsp	r11,sp[0x18]
8000a6a8:	58 0b       	cp.w	r11,0
8000a6aa:	c0 31       	brne	8000a6b0 <_dtoa_r+0x9a4>
8000a6ac:	08 9c       	mov	r12,r4
8000a6ae:	c1 38       	rjmp	8000a6d4 <_dtoa_r+0x9c8>
8000a6b0:	68 1b       	ld.w	r11,r4[0x4]
8000a6b2:	0e 9c       	mov	r12,r7
8000a6b4:	e0 a0 04 7e 	rcall	8000afb0 <_Balloc>
8000a6b8:	68 4a       	ld.w	r10,r4[0x10]
8000a6ba:	18 95       	mov	r5,r12
8000a6bc:	e8 cb ff f4 	sub	r11,r4,-12
8000a6c0:	2f ea       	sub	r10,-2
8000a6c2:	2f 4c       	sub	r12,-12
8000a6c4:	a3 6a       	lsl	r10,0x2
8000a6c6:	fe b0 e3 29 	rcall	80006d18 <memcpy>
8000a6ca:	0a 9b       	mov	r11,r5
8000a6cc:	30 1a       	mov	r10,1
8000a6ce:	0e 9c       	mov	r12,r7
8000a6d0:	e0 a0 05 60 	rcall	8000b190 <__lshift>
8000a6d4:	50 44       	stdsp	sp[0x10],r4
8000a6d6:	40 3a       	lddsp	r10,sp[0xc]
8000a6d8:	30 19       	mov	r9,1
8000a6da:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a6de:	18 94       	mov	r4,r12
8000a6e0:	50 da       	stdsp	sp[0x34],r10
8000a6e2:	40 85       	lddsp	r5,sp[0x20]
8000a6e4:	50 99       	stdsp	sp[0x24],r9
8000a6e6:	50 26       	stdsp	sp[0x8],r6
8000a6e8:	50 e1       	stdsp	sp[0x38],r1
8000a6ea:	04 9b       	mov	r11,r2
8000a6ec:	06 9c       	mov	r12,r3
8000a6ee:	fe b0 fa 7f 	rcall	80009bec <quorem>
8000a6f2:	40 4b       	lddsp	r11,sp[0x10]
8000a6f4:	f8 c0 ff d0 	sub	r0,r12,-48
8000a6f8:	06 9c       	mov	r12,r3
8000a6fa:	e0 a0 04 27 	rcall	8000af48 <__mcmp>
8000a6fe:	08 9a       	mov	r10,r4
8000a700:	50 6c       	stdsp	sp[0x18],r12
8000a702:	04 9b       	mov	r11,r2
8000a704:	0e 9c       	mov	r12,r7
8000a706:	e0 a0 04 dd 	rcall	8000b0c0 <__mdiff>
8000a70a:	18 91       	mov	r1,r12
8000a70c:	78 38       	ld.w	r8,r12[0xc]
8000a70e:	58 08       	cp.w	r8,0
8000a710:	c0 30       	breq	8000a716 <_dtoa_r+0xa0a>
8000a712:	30 16       	mov	r6,1
8000a714:	c0 68       	rjmp	8000a720 <_dtoa_r+0xa14>
8000a716:	18 9b       	mov	r11,r12
8000a718:	06 9c       	mov	r12,r3
8000a71a:	e0 a0 04 17 	rcall	8000af48 <__mcmp>
8000a71e:	18 96       	mov	r6,r12
8000a720:	0e 9c       	mov	r12,r7
8000a722:	02 9b       	mov	r11,r1
8000a724:	e0 a0 04 2c 	rcall	8000af7c <_Bfree>
8000a728:	40 cc       	lddsp	r12,sp[0x30]
8000a72a:	ed ec 10 08 	or	r8,r6,r12
8000a72e:	c0 d1       	brne	8000a748 <_dtoa_r+0xa3c>
8000a730:	40 db       	lddsp	r11,sp[0x34]
8000a732:	58 0b       	cp.w	r11,0
8000a734:	c0 a1       	brne	8000a748 <_dtoa_r+0xa3c>
8000a736:	40 26       	lddsp	r6,sp[0x8]
8000a738:	e0 40 00 39 	cp.w	r0,57
8000a73c:	c3 00       	breq	8000a79c <_dtoa_r+0xa90>
8000a73e:	40 6a       	lddsp	r10,sp[0x18]
8000a740:	58 0a       	cp.w	r10,0
8000a742:	e0 89 00 24 	brgt	8000a78a <_dtoa_r+0xa7e>
8000a746:	c2 f8       	rjmp	8000a7a4 <_dtoa_r+0xa98>
8000a748:	40 69       	lddsp	r9,sp[0x18]
8000a74a:	58 09       	cp.w	r9,0
8000a74c:	c0 85       	brlt	8000a75c <_dtoa_r+0xa50>
8000a74e:	12 98       	mov	r8,r9
8000a750:	40 cc       	lddsp	r12,sp[0x30]
8000a752:	18 48       	or	r8,r12
8000a754:	c1 d1       	brne	8000a78e <_dtoa_r+0xa82>
8000a756:	40 db       	lddsp	r11,sp[0x34]
8000a758:	58 0b       	cp.w	r11,0
8000a75a:	c1 a1       	brne	8000a78e <_dtoa_r+0xa82>
8000a75c:	0c 99       	mov	r9,r6
8000a75e:	40 26       	lddsp	r6,sp[0x8]
8000a760:	58 09       	cp.w	r9,0
8000a762:	e0 8a 00 21 	brle	8000a7a4 <_dtoa_r+0xa98>
8000a766:	06 9b       	mov	r11,r3
8000a768:	30 1a       	mov	r10,1
8000a76a:	0e 9c       	mov	r12,r7
8000a76c:	e0 a0 05 12 	rcall	8000b190 <__lshift>
8000a770:	04 9b       	mov	r11,r2
8000a772:	18 93       	mov	r3,r12
8000a774:	e0 a0 03 ea 	rcall	8000af48 <__mcmp>
8000a778:	e0 89 00 06 	brgt	8000a784 <_dtoa_r+0xa78>
8000a77c:	c1 41       	brne	8000a7a4 <_dtoa_r+0xa98>
8000a77e:	ed b0 00 00 	bld	r0,0x0
8000a782:	c1 11       	brne	8000a7a4 <_dtoa_r+0xa98>
8000a784:	e0 40 00 39 	cp.w	r0,57
8000a788:	c0 a0       	breq	8000a79c <_dtoa_r+0xa90>
8000a78a:	2f f0       	sub	r0,-1
8000a78c:	c0 c8       	rjmp	8000a7a4 <_dtoa_r+0xa98>
8000a78e:	58 06       	cp.w	r6,0
8000a790:	e0 8a 00 0c 	brle	8000a7a8 <_dtoa_r+0xa9c>
8000a794:	40 26       	lddsp	r6,sp[0x8]
8000a796:	e0 40 00 39 	cp.w	r0,57
8000a79a:	c0 41       	brne	8000a7a2 <_dtoa_r+0xa96>
8000a79c:	33 98       	mov	r8,57
8000a79e:	0a c8       	st.b	r5++,r8
8000a7a0:	c6 78       	rjmp	8000a86e <_dtoa_r+0xb62>
8000a7a2:	2f f0       	sub	r0,-1
8000a7a4:	0a c0       	st.b	r5++,r0
8000a7a6:	c7 58       	rjmp	8000a890 <_dtoa_r+0xb84>
8000a7a8:	0a c0       	st.b	r5++,r0
8000a7aa:	40 9a       	lddsp	r10,sp[0x24]
8000a7ac:	40 e9       	lddsp	r9,sp[0x38]
8000a7ae:	12 3a       	cp.w	r10,r9
8000a7b0:	c4 30       	breq	8000a836 <_dtoa_r+0xb2a>
8000a7b2:	06 9b       	mov	r11,r3
8000a7b4:	30 09       	mov	r9,0
8000a7b6:	30 aa       	mov	r10,10
8000a7b8:	0e 9c       	mov	r12,r7
8000a7ba:	e0 a0 05 b7 	rcall	8000b328 <__multadd>
8000a7be:	40 48       	lddsp	r8,sp[0x10]
8000a7c0:	18 93       	mov	r3,r12
8000a7c2:	08 38       	cp.w	r8,r4
8000a7c4:	c0 91       	brne	8000a7d6 <_dtoa_r+0xaca>
8000a7c6:	10 9b       	mov	r11,r8
8000a7c8:	30 09       	mov	r9,0
8000a7ca:	30 aa       	mov	r10,10
8000a7cc:	0e 9c       	mov	r12,r7
8000a7ce:	e0 a0 05 ad 	rcall	8000b328 <__multadd>
8000a7d2:	50 4c       	stdsp	sp[0x10],r12
8000a7d4:	c0 e8       	rjmp	8000a7f0 <_dtoa_r+0xae4>
8000a7d6:	40 4b       	lddsp	r11,sp[0x10]
8000a7d8:	30 09       	mov	r9,0
8000a7da:	30 aa       	mov	r10,10
8000a7dc:	0e 9c       	mov	r12,r7
8000a7de:	e0 a0 05 a5 	rcall	8000b328 <__multadd>
8000a7e2:	08 9b       	mov	r11,r4
8000a7e4:	50 4c       	stdsp	sp[0x10],r12
8000a7e6:	30 09       	mov	r9,0
8000a7e8:	30 aa       	mov	r10,10
8000a7ea:	0e 9c       	mov	r12,r7
8000a7ec:	e0 a0 05 9e 	rcall	8000b328 <__multadd>
8000a7f0:	18 94       	mov	r4,r12
8000a7f2:	40 9c       	lddsp	r12,sp[0x24]
8000a7f4:	2f fc       	sub	r12,-1
8000a7f6:	50 9c       	stdsp	sp[0x24],r12
8000a7f8:	c7 9b       	rjmp	8000a6ea <_dtoa_r+0x9de>
8000a7fa:	30 18       	mov	r8,1
8000a7fc:	06 90       	mov	r0,r3
8000a7fe:	40 85       	lddsp	r5,sp[0x20]
8000a800:	08 93       	mov	r3,r4
8000a802:	0c 94       	mov	r4,r6
8000a804:	10 96       	mov	r6,r8
8000a806:	04 9b       	mov	r11,r2
8000a808:	00 9c       	mov	r12,r0
8000a80a:	fe b0 f9 f1 	rcall	80009bec <quorem>
8000a80e:	2d 0c       	sub	r12,-48
8000a810:	0a cc       	st.b	r5++,r12
8000a812:	02 36       	cp.w	r6,r1
8000a814:	c0 a4       	brge	8000a828 <_dtoa_r+0xb1c>
8000a816:	00 9b       	mov	r11,r0
8000a818:	30 09       	mov	r9,0
8000a81a:	30 aa       	mov	r10,10
8000a81c:	0e 9c       	mov	r12,r7
8000a81e:	2f f6       	sub	r6,-1
8000a820:	e0 a0 05 84 	rcall	8000b328 <__multadd>
8000a824:	18 90       	mov	r0,r12
8000a826:	cf 0b       	rjmp	8000a806 <_dtoa_r+0xafa>
8000a828:	08 96       	mov	r6,r4
8000a82a:	30 0b       	mov	r11,0
8000a82c:	06 94       	mov	r4,r3
8000a82e:	50 4b       	stdsp	sp[0x10],r11
8000a830:	00 93       	mov	r3,r0
8000a832:	18 90       	mov	r0,r12
8000a834:	c0 28       	rjmp	8000a838 <_dtoa_r+0xb2c>
8000a836:	40 26       	lddsp	r6,sp[0x8]
8000a838:	06 9b       	mov	r11,r3
8000a83a:	30 1a       	mov	r10,1
8000a83c:	0e 9c       	mov	r12,r7
8000a83e:	e0 a0 04 a9 	rcall	8000b190 <__lshift>
8000a842:	04 9b       	mov	r11,r2
8000a844:	18 93       	mov	r3,r12
8000a846:	e0 a0 03 81 	rcall	8000af48 <__mcmp>
8000a84a:	e0 89 00 12 	brgt	8000a86e <_dtoa_r+0xb62>
8000a84e:	c1 b1       	brne	8000a884 <_dtoa_r+0xb78>
8000a850:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a854:	c0 d1       	brne	8000a86e <_dtoa_r+0xb62>
8000a856:	c1 78       	rjmp	8000a884 <_dtoa_r+0xb78>
8000a858:	40 89       	lddsp	r9,sp[0x20]
8000a85a:	12 38       	cp.w	r8,r9
8000a85c:	c0 30       	breq	8000a862 <_dtoa_r+0xb56>
8000a85e:	10 95       	mov	r5,r8
8000a860:	c0 88       	rjmp	8000a870 <_dtoa_r+0xb64>
8000a862:	2f f6       	sub	r6,-1
8000a864:	50 66       	stdsp	sp[0x18],r6
8000a866:	33 18       	mov	r8,49
8000a868:	40 8c       	lddsp	r12,sp[0x20]
8000a86a:	b8 88       	st.b	r12[0x0],r8
8000a86c:	c1 38       	rjmp	8000a892 <_dtoa_r+0xb86>
8000a86e:	33 9a       	mov	r10,57
8000a870:	0a 98       	mov	r8,r5
8000a872:	11 79       	ld.ub	r9,--r8
8000a874:	f4 09 18 00 	cp.b	r9,r10
8000a878:	cf 00       	breq	8000a858 <_dtoa_r+0xb4c>
8000a87a:	2f f9       	sub	r9,-1
8000a87c:	b0 89       	st.b	r8[0x0],r9
8000a87e:	c0 98       	rjmp	8000a890 <_dtoa_r+0xb84>
8000a880:	10 95       	mov	r5,r8
8000a882:	c0 28       	rjmp	8000a886 <_dtoa_r+0xb7a>
8000a884:	33 09       	mov	r9,48
8000a886:	0a 98       	mov	r8,r5
8000a888:	11 7a       	ld.ub	r10,--r8
8000a88a:	f2 0a 18 00 	cp.b	r10,r9
8000a88e:	cf 90       	breq	8000a880 <_dtoa_r+0xb74>
8000a890:	50 66       	stdsp	sp[0x18],r6
8000a892:	04 9b       	mov	r11,r2
8000a894:	0e 9c       	mov	r12,r7
8000a896:	e0 a0 03 73 	rcall	8000af7c <_Bfree>
8000a89a:	58 04       	cp.w	r4,0
8000a89c:	c1 20       	breq	8000a8c0 <_dtoa_r+0xbb4>
8000a89e:	40 4b       	lddsp	r11,sp[0x10]
8000a8a0:	08 3b       	cp.w	r11,r4
8000a8a2:	5f 19       	srne	r9
8000a8a4:	58 0b       	cp.w	r11,0
8000a8a6:	5f 18       	srne	r8
8000a8a8:	f3 e8 00 08 	and	r8,r9,r8
8000a8ac:	c0 40       	breq	8000a8b4 <_dtoa_r+0xba8>
8000a8ae:	0e 9c       	mov	r12,r7
8000a8b0:	e0 a0 03 66 	rcall	8000af7c <_Bfree>
8000a8b4:	08 9b       	mov	r11,r4
8000a8b6:	0e 9c       	mov	r12,r7
8000a8b8:	e0 a0 03 62 	rcall	8000af7c <_Bfree>
8000a8bc:	c0 28       	rjmp	8000a8c0 <_dtoa_r+0xbb4>
8000a8be:	50 66       	stdsp	sp[0x18],r6
8000a8c0:	0e 9c       	mov	r12,r7
8000a8c2:	06 9b       	mov	r11,r3
8000a8c4:	e0 a0 03 5c 	rcall	8000af7c <_Bfree>
8000a8c8:	30 08       	mov	r8,0
8000a8ca:	aa 88       	st.b	r5[0x0],r8
8000a8cc:	40 68       	lddsp	r8,sp[0x18]
8000a8ce:	41 5a       	lddsp	r10,sp[0x54]
8000a8d0:	2f f8       	sub	r8,-1
8000a8d2:	41 29       	lddsp	r9,sp[0x48]
8000a8d4:	95 08       	st.w	r10[0x0],r8
8000a8d6:	40 8c       	lddsp	r12,sp[0x20]
8000a8d8:	58 09       	cp.w	r9,0
8000a8da:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a8de:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a8e2:	2e 6d       	sub	sp,-104
8000a8e4:	d8 32       	popm	r0-r7,pc
8000a8e6:	d7 03       	nop

8000a8e8 <_fclose_r>:
8000a8e8:	d4 21       	pushm	r4-r7,lr
8000a8ea:	18 96       	mov	r6,r12
8000a8ec:	16 97       	mov	r7,r11
8000a8ee:	58 0b       	cp.w	r11,0
8000a8f0:	c0 31       	brne	8000a8f6 <_fclose_r+0xe>
8000a8f2:	16 95       	mov	r5,r11
8000a8f4:	c5 28       	rjmp	8000a998 <_fclose_r+0xb0>
8000a8f6:	fe b0 e5 91 	rcall	80007418 <__sfp_lock_acquire>
8000a8fa:	58 06       	cp.w	r6,0
8000a8fc:	c0 70       	breq	8000a90a <_fclose_r+0x22>
8000a8fe:	6c 68       	ld.w	r8,r6[0x18]
8000a900:	58 08       	cp.w	r8,0
8000a902:	c0 41       	brne	8000a90a <_fclose_r+0x22>
8000a904:	0c 9c       	mov	r12,r6
8000a906:	fe b0 e5 db 	rcall	800074bc <__sinit>
8000a90a:	fe c8 e3 d2 	sub	r8,pc,-7214
8000a90e:	10 37       	cp.w	r7,r8
8000a910:	c0 31       	brne	8000a916 <_fclose_r+0x2e>
8000a912:	6c 07       	ld.w	r7,r6[0x0]
8000a914:	c0 c8       	rjmp	8000a92c <_fclose_r+0x44>
8000a916:	fe c8 e3 be 	sub	r8,pc,-7234
8000a91a:	10 37       	cp.w	r7,r8
8000a91c:	c0 31       	brne	8000a922 <_fclose_r+0x3a>
8000a91e:	6c 17       	ld.w	r7,r6[0x4]
8000a920:	c0 68       	rjmp	8000a92c <_fclose_r+0x44>
8000a922:	fe c8 e3 aa 	sub	r8,pc,-7254
8000a926:	10 37       	cp.w	r7,r8
8000a928:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a92c:	8e 69       	ld.sh	r9,r7[0xc]
8000a92e:	30 08       	mov	r8,0
8000a930:	f0 09 19 00 	cp.h	r9,r8
8000a934:	c0 51       	brne	8000a93e <_fclose_r+0x56>
8000a936:	fe b0 e5 72 	rcall	8000741a <__sfp_lock_release>
8000a93a:	30 05       	mov	r5,0
8000a93c:	c2 e8       	rjmp	8000a998 <_fclose_r+0xb0>
8000a93e:	0e 9b       	mov	r11,r7
8000a940:	0c 9c       	mov	r12,r6
8000a942:	c3 5c       	rcall	8000a9ac <_fflush_r>
8000a944:	6e c8       	ld.w	r8,r7[0x30]
8000a946:	18 95       	mov	r5,r12
8000a948:	58 08       	cp.w	r8,0
8000a94a:	c0 60       	breq	8000a956 <_fclose_r+0x6e>
8000a94c:	6e 8b       	ld.w	r11,r7[0x20]
8000a94e:	0c 9c       	mov	r12,r6
8000a950:	5d 18       	icall	r8
8000a952:	f9 b5 05 ff 	movlt	r5,-1
8000a956:	8e 68       	ld.sh	r8,r7[0xc]
8000a958:	ed b8 00 07 	bld	r8,0x7
8000a95c:	c0 51       	brne	8000a966 <_fclose_r+0x7e>
8000a95e:	6e 4b       	ld.w	r11,r7[0x10]
8000a960:	0c 9c       	mov	r12,r6
8000a962:	fe b0 e6 47 	rcall	800075f0 <_free_r>
8000a966:	6e db       	ld.w	r11,r7[0x34]
8000a968:	58 0b       	cp.w	r11,0
8000a96a:	c0 a0       	breq	8000a97e <_fclose_r+0x96>
8000a96c:	ee c8 ff bc 	sub	r8,r7,-68
8000a970:	10 3b       	cp.w	r11,r8
8000a972:	c0 40       	breq	8000a97a <_fclose_r+0x92>
8000a974:	0c 9c       	mov	r12,r6
8000a976:	fe b0 e6 3d 	rcall	800075f0 <_free_r>
8000a97a:	30 08       	mov	r8,0
8000a97c:	8f d8       	st.w	r7[0x34],r8
8000a97e:	6f 2b       	ld.w	r11,r7[0x48]
8000a980:	58 0b       	cp.w	r11,0
8000a982:	c0 70       	breq	8000a990 <_fclose_r+0xa8>
8000a984:	0c 9c       	mov	r12,r6
8000a986:	fe b0 e6 35 	rcall	800075f0 <_free_r>
8000a98a:	30 08       	mov	r8,0
8000a98c:	ef 48 00 48 	st.w	r7[72],r8
8000a990:	30 08       	mov	r8,0
8000a992:	ae 68       	st.h	r7[0xc],r8
8000a994:	fe b0 e5 43 	rcall	8000741a <__sfp_lock_release>
8000a998:	0a 9c       	mov	r12,r5
8000a99a:	d8 22       	popm	r4-r7,pc

8000a99c <fclose>:
8000a99c:	d4 01       	pushm	lr
8000a99e:	e0 68 01 18 	mov	r8,280
8000a9a2:	18 9b       	mov	r11,r12
8000a9a4:	70 0c       	ld.w	r12,r8[0x0]
8000a9a6:	ca 1f       	rcall	8000a8e8 <_fclose_r>
8000a9a8:	d8 02       	popm	pc
8000a9aa:	d7 03       	nop

8000a9ac <_fflush_r>:
8000a9ac:	d4 21       	pushm	r4-r7,lr
8000a9ae:	16 97       	mov	r7,r11
8000a9b0:	18 96       	mov	r6,r12
8000a9b2:	76 48       	ld.w	r8,r11[0x10]
8000a9b4:	58 08       	cp.w	r8,0
8000a9b6:	e0 80 00 81 	breq	8000aab8 <_fflush_r+0x10c>
8000a9ba:	58 0c       	cp.w	r12,0
8000a9bc:	c0 60       	breq	8000a9c8 <_fflush_r+0x1c>
8000a9be:	78 68       	ld.w	r8,r12[0x18]
8000a9c0:	58 08       	cp.w	r8,0
8000a9c2:	c0 31       	brne	8000a9c8 <_fflush_r+0x1c>
8000a9c4:	fe b0 e5 7c 	rcall	800074bc <__sinit>
8000a9c8:	fe c8 e4 90 	sub	r8,pc,-7024
8000a9cc:	10 37       	cp.w	r7,r8
8000a9ce:	c0 31       	brne	8000a9d4 <_fflush_r+0x28>
8000a9d0:	6c 07       	ld.w	r7,r6[0x0]
8000a9d2:	c0 c8       	rjmp	8000a9ea <_fflush_r+0x3e>
8000a9d4:	fe c8 e4 7c 	sub	r8,pc,-7044
8000a9d8:	10 37       	cp.w	r7,r8
8000a9da:	c0 31       	brne	8000a9e0 <_fflush_r+0x34>
8000a9dc:	6c 17       	ld.w	r7,r6[0x4]
8000a9de:	c0 68       	rjmp	8000a9ea <_fflush_r+0x3e>
8000a9e0:	fe c8 e4 68 	sub	r8,pc,-7064
8000a9e4:	10 37       	cp.w	r7,r8
8000a9e6:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a9ea:	8e 6a       	ld.sh	r10,r7[0xc]
8000a9ec:	14 98       	mov	r8,r10
8000a9ee:	ed ba 00 03 	bld	r10,0x3
8000a9f2:	c4 20       	breq	8000aa76 <_fflush_r+0xca>
8000a9f4:	ab ba       	sbr	r10,0xb
8000a9f6:	ae 6a       	st.h	r7[0xc],r10
8000a9f8:	6e 18       	ld.w	r8,r7[0x4]
8000a9fa:	58 08       	cp.w	r8,0
8000a9fc:	e0 89 00 06 	brgt	8000aa08 <_fflush_r+0x5c>
8000aa00:	6f 08       	ld.w	r8,r7[0x40]
8000aa02:	58 08       	cp.w	r8,0
8000aa04:	e0 8a 00 5a 	brle	8000aab8 <_fflush_r+0x10c>
8000aa08:	6e b8       	ld.w	r8,r7[0x2c]
8000aa0a:	58 08       	cp.w	r8,0
8000aa0c:	c5 60       	breq	8000aab8 <_fflush_r+0x10c>
8000aa0e:	e2 1a 10 00 	andl	r10,0x1000,COH
8000aa12:	c0 30       	breq	8000aa18 <_fflush_r+0x6c>
8000aa14:	6f 55       	ld.w	r5,r7[0x54]
8000aa16:	c0 f8       	rjmp	8000aa34 <_fflush_r+0x88>
8000aa18:	30 19       	mov	r9,1
8000aa1a:	6e 8b       	ld.w	r11,r7[0x20]
8000aa1c:	0c 9c       	mov	r12,r6
8000aa1e:	5d 18       	icall	r8
8000aa20:	18 95       	mov	r5,r12
8000aa22:	5b fc       	cp.w	r12,-1
8000aa24:	c0 81       	brne	8000aa34 <_fflush_r+0x88>
8000aa26:	6c 38       	ld.w	r8,r6[0xc]
8000aa28:	59 d8       	cp.w	r8,29
8000aa2a:	c4 70       	breq	8000aab8 <_fflush_r+0x10c>
8000aa2c:	8e 68       	ld.sh	r8,r7[0xc]
8000aa2e:	a7 a8       	sbr	r8,0x6
8000aa30:	ae 68       	st.h	r7[0xc],r8
8000aa32:	d8 22       	popm	r4-r7,pc
8000aa34:	8e 68       	ld.sh	r8,r7[0xc]
8000aa36:	ed b8 00 02 	bld	r8,0x2
8000aa3a:	c0 91       	brne	8000aa4c <_fflush_r+0xa0>
8000aa3c:	6e 18       	ld.w	r8,r7[0x4]
8000aa3e:	10 15       	sub	r5,r8
8000aa40:	6e d8       	ld.w	r8,r7[0x34]
8000aa42:	58 08       	cp.w	r8,0
8000aa44:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000aa48:	eb d8 e1 15 	subne	r5,r5,r8
8000aa4c:	6e b8       	ld.w	r8,r7[0x2c]
8000aa4e:	0c 9c       	mov	r12,r6
8000aa50:	30 09       	mov	r9,0
8000aa52:	0a 9a       	mov	r10,r5
8000aa54:	6e 8b       	ld.w	r11,r7[0x20]
8000aa56:	5d 18       	icall	r8
8000aa58:	8e 68       	ld.sh	r8,r7[0xc]
8000aa5a:	0a 3c       	cp.w	r12,r5
8000aa5c:	c2 61       	brne	8000aaa8 <_fflush_r+0xfc>
8000aa5e:	ab d8       	cbr	r8,0xb
8000aa60:	30 0c       	mov	r12,0
8000aa62:	6e 49       	ld.w	r9,r7[0x10]
8000aa64:	ae 68       	st.h	r7[0xc],r8
8000aa66:	8f 1c       	st.w	r7[0x4],r12
8000aa68:	8f 09       	st.w	r7[0x0],r9
8000aa6a:	ed b8 00 0c 	bld	r8,0xc
8000aa6e:	c2 51       	brne	8000aab8 <_fflush_r+0x10c>
8000aa70:	ef 45 00 54 	st.w	r7[84],r5
8000aa74:	d8 22       	popm	r4-r7,pc
8000aa76:	6e 45       	ld.w	r5,r7[0x10]
8000aa78:	58 05       	cp.w	r5,0
8000aa7a:	c1 f0       	breq	8000aab8 <_fflush_r+0x10c>
8000aa7c:	6e 04       	ld.w	r4,r7[0x0]
8000aa7e:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000aa82:	8f 05       	st.w	r7[0x0],r5
8000aa84:	f9 b8 01 00 	movne	r8,0
8000aa88:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000aa8c:	0a 14       	sub	r4,r5
8000aa8e:	8f 28       	st.w	r7[0x8],r8
8000aa90:	c1 18       	rjmp	8000aab2 <_fflush_r+0x106>
8000aa92:	08 99       	mov	r9,r4
8000aa94:	0a 9a       	mov	r10,r5
8000aa96:	6e a8       	ld.w	r8,r7[0x28]
8000aa98:	6e 8b       	ld.w	r11,r7[0x20]
8000aa9a:	0c 9c       	mov	r12,r6
8000aa9c:	5d 18       	icall	r8
8000aa9e:	18 14       	sub	r4,r12
8000aaa0:	58 0c       	cp.w	r12,0
8000aaa2:	e0 89 00 07 	brgt	8000aab0 <_fflush_r+0x104>
8000aaa6:	8e 68       	ld.sh	r8,r7[0xc]
8000aaa8:	a7 a8       	sbr	r8,0x6
8000aaaa:	3f fc       	mov	r12,-1
8000aaac:	ae 68       	st.h	r7[0xc],r8
8000aaae:	d8 22       	popm	r4-r7,pc
8000aab0:	18 05       	add	r5,r12
8000aab2:	58 04       	cp.w	r4,0
8000aab4:	fe 99 ff ef 	brgt	8000aa92 <_fflush_r+0xe6>
8000aab8:	d8 2a       	popm	r4-r7,pc,r12=0
8000aaba:	d7 03       	nop

8000aabc <__sfvwrite_r>:
8000aabc:	d4 31       	pushm	r0-r7,lr
8000aabe:	20 3d       	sub	sp,12
8000aac0:	14 94       	mov	r4,r10
8000aac2:	18 95       	mov	r5,r12
8000aac4:	16 97       	mov	r7,r11
8000aac6:	74 28       	ld.w	r8,r10[0x8]
8000aac8:	58 08       	cp.w	r8,0
8000aaca:	e0 80 01 43 	breq	8000ad50 <__sfvwrite_r+0x294>
8000aace:	96 68       	ld.sh	r8,r11[0xc]
8000aad0:	ed b8 00 03 	bld	r8,0x3
8000aad4:	c0 41       	brne	8000aadc <__sfvwrite_r+0x20>
8000aad6:	76 48       	ld.w	r8,r11[0x10]
8000aad8:	58 08       	cp.w	r8,0
8000aada:	c0 c1       	brne	8000aaf2 <__sfvwrite_r+0x36>
8000aadc:	0e 9b       	mov	r11,r7
8000aade:	0a 9c       	mov	r12,r5
8000aae0:	fe b0 f8 08 	rcall	80009af0 <__swsetup_r>
8000aae4:	c0 70       	breq	8000aaf2 <__sfvwrite_r+0x36>
8000aae6:	8e 68       	ld.sh	r8,r7[0xc]
8000aae8:	a7 a8       	sbr	r8,0x6
8000aaea:	ae 68       	st.h	r7[0xc],r8
8000aaec:	30 98       	mov	r8,9
8000aaee:	8b 38       	st.w	r5[0xc],r8
8000aaf0:	c2 e9       	rjmp	8000ad4c <__sfvwrite_r+0x290>
8000aaf2:	8e 63       	ld.sh	r3,r7[0xc]
8000aaf4:	68 00       	ld.w	r0,r4[0x0]
8000aaf6:	06 96       	mov	r6,r3
8000aaf8:	e2 16 00 02 	andl	r6,0x2,COH
8000aafc:	c2 10       	breq	8000ab3e <__sfvwrite_r+0x82>
8000aafe:	30 03       	mov	r3,0
8000ab00:	e0 62 04 00 	mov	r2,1024
8000ab04:	06 96       	mov	r6,r3
8000ab06:	c0 48       	rjmp	8000ab0e <__sfvwrite_r+0x52>
8000ab08:	60 03       	ld.w	r3,r0[0x0]
8000ab0a:	60 16       	ld.w	r6,r0[0x4]
8000ab0c:	2f 80       	sub	r0,-8
8000ab0e:	58 06       	cp.w	r6,0
8000ab10:	cf c0       	breq	8000ab08 <__sfvwrite_r+0x4c>
8000ab12:	e0 46 04 00 	cp.w	r6,1024
8000ab16:	ec 09 17 80 	movls	r9,r6
8000ab1a:	e4 09 17 b0 	movhi	r9,r2
8000ab1e:	06 9a       	mov	r10,r3
8000ab20:	6e a8       	ld.w	r8,r7[0x28]
8000ab22:	6e 8b       	ld.w	r11,r7[0x20]
8000ab24:	0a 9c       	mov	r12,r5
8000ab26:	5d 18       	icall	r8
8000ab28:	18 16       	sub	r6,r12
8000ab2a:	58 0c       	cp.w	r12,0
8000ab2c:	e0 8a 01 0d 	brle	8000ad46 <__sfvwrite_r+0x28a>
8000ab30:	68 28       	ld.w	r8,r4[0x8]
8000ab32:	18 18       	sub	r8,r12
8000ab34:	89 28       	st.w	r4[0x8],r8
8000ab36:	e0 80 01 0d 	breq	8000ad50 <__sfvwrite_r+0x294>
8000ab3a:	18 03       	add	r3,r12
8000ab3c:	ce 9b       	rjmp	8000ab0e <__sfvwrite_r+0x52>
8000ab3e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000ab42:	c0 70       	breq	8000ab50 <__sfvwrite_r+0x94>
8000ab44:	50 06       	stdsp	sp[0x0],r6
8000ab46:	0c 93       	mov	r3,r6
8000ab48:	0c 91       	mov	r1,r6
8000ab4a:	50 15       	stdsp	sp[0x4],r5
8000ab4c:	08 92       	mov	r2,r4
8000ab4e:	c9 f8       	rjmp	8000ac8c <__sfvwrite_r+0x1d0>
8000ab50:	06 96       	mov	r6,r3
8000ab52:	08 91       	mov	r1,r4
8000ab54:	c0 48       	rjmp	8000ab5c <__sfvwrite_r+0xa0>
8000ab56:	60 03       	ld.w	r3,r0[0x0]
8000ab58:	60 16       	ld.w	r6,r0[0x4]
8000ab5a:	2f 80       	sub	r0,-8
8000ab5c:	58 06       	cp.w	r6,0
8000ab5e:	cf c0       	breq	8000ab56 <__sfvwrite_r+0x9a>
8000ab60:	8e 68       	ld.sh	r8,r7[0xc]
8000ab62:	6e 24       	ld.w	r4,r7[0x8]
8000ab64:	10 99       	mov	r9,r8
8000ab66:	e2 19 02 00 	andl	r9,0x200,COH
8000ab6a:	c5 70       	breq	8000ac18 <__sfvwrite_r+0x15c>
8000ab6c:	08 36       	cp.w	r6,r4
8000ab6e:	c4 53       	brcs	8000abf8 <__sfvwrite_r+0x13c>
8000ab70:	10 99       	mov	r9,r8
8000ab72:	e2 19 04 80 	andl	r9,0x480,COH
8000ab76:	c4 10       	breq	8000abf8 <__sfvwrite_r+0x13c>
8000ab78:	6e 4b       	ld.w	r11,r7[0x10]
8000ab7a:	6e 09       	ld.w	r9,r7[0x0]
8000ab7c:	16 19       	sub	r9,r11
8000ab7e:	50 09       	stdsp	sp[0x0],r9
8000ab80:	6e 59       	ld.w	r9,r7[0x14]
8000ab82:	10 9c       	mov	r12,r8
8000ab84:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000ab88:	30 28       	mov	r8,2
8000ab8a:	f4 08 0c 08 	divs	r8,r10,r8
8000ab8e:	fa e9 00 04 	st.d	sp[4],r8
8000ab92:	10 94       	mov	r4,r8
8000ab94:	40 09       	lddsp	r9,sp[0x0]
8000ab96:	e2 1c 04 00 	andl	r12,0x400,COH
8000ab9a:	2f f9       	sub	r9,-1
8000ab9c:	0c 09       	add	r9,r6
8000ab9e:	12 38       	cp.w	r8,r9
8000aba0:	f2 04 17 30 	movlo	r4,r9
8000aba4:	58 0c       	cp.w	r12,0
8000aba6:	c1 10       	breq	8000abc8 <__sfvwrite_r+0x10c>
8000aba8:	08 9b       	mov	r11,r4
8000abaa:	0a 9c       	mov	r12,r5
8000abac:	fe b0 de 9a 	rcall	800068e0 <_malloc_r>
8000abb0:	18 92       	mov	r2,r12
8000abb2:	c1 50       	breq	8000abdc <__sfvwrite_r+0x120>
8000abb4:	40 0a       	lddsp	r10,sp[0x0]
8000abb6:	6e 4b       	ld.w	r11,r7[0x10]
8000abb8:	fe b0 e0 b0 	rcall	80006d18 <memcpy>
8000abbc:	8e 68       	ld.sh	r8,r7[0xc]
8000abbe:	e0 18 fb 7f 	andl	r8,0xfb7f
8000abc2:	a7 b8       	sbr	r8,0x7
8000abc4:	ae 68       	st.h	r7[0xc],r8
8000abc6:	c0 e8       	rjmp	8000abe2 <__sfvwrite_r+0x126>
8000abc8:	08 9a       	mov	r10,r4
8000abca:	0a 9c       	mov	r12,r5
8000abcc:	fe b0 e1 52 	rcall	80006e70 <_realloc_r>
8000abd0:	18 92       	mov	r2,r12
8000abd2:	c0 81       	brne	8000abe2 <__sfvwrite_r+0x126>
8000abd4:	6e 4b       	ld.w	r11,r7[0x10]
8000abd6:	0a 9c       	mov	r12,r5
8000abd8:	fe b0 e5 0c 	rcall	800075f0 <_free_r>
8000abdc:	30 c8       	mov	r8,12
8000abde:	8b 38       	st.w	r5[0xc],r8
8000abe0:	cb 38       	rjmp	8000ad46 <__sfvwrite_r+0x28a>
8000abe2:	40 0a       	lddsp	r10,sp[0x0]
8000abe4:	40 09       	lddsp	r9,sp[0x0]
8000abe6:	e8 0a 01 0a 	sub	r10,r4,r10
8000abea:	e4 09 00 08 	add	r8,r2,r9
8000abee:	8f 54       	st.w	r7[0x14],r4
8000abf0:	8f 2a       	st.w	r7[0x8],r10
8000abf2:	8f 08       	st.w	r7[0x0],r8
8000abf4:	8f 42       	st.w	r7[0x10],r2
8000abf6:	0c 94       	mov	r4,r6
8000abf8:	08 36       	cp.w	r6,r4
8000abfa:	ec 04 17 30 	movlo	r4,r6
8000abfe:	06 9b       	mov	r11,r3
8000ac00:	08 9a       	mov	r10,r4
8000ac02:	6e 0c       	ld.w	r12,r7[0x0]
8000ac04:	fe b0 e5 e0 	rcall	800077c4 <memmove>
8000ac08:	6e 08       	ld.w	r8,r7[0x0]
8000ac0a:	08 08       	add	r8,r4
8000ac0c:	8f 08       	st.w	r7[0x0],r8
8000ac0e:	6e 28       	ld.w	r8,r7[0x8]
8000ac10:	08 18       	sub	r8,r4
8000ac12:	0c 94       	mov	r4,r6
8000ac14:	8f 28       	st.w	r7[0x8],r8
8000ac16:	c2 f8       	rjmp	8000ac74 <__sfvwrite_r+0x1b8>
8000ac18:	08 36       	cp.w	r6,r4
8000ac1a:	5f ba       	srhi	r10
8000ac1c:	6e 0c       	ld.w	r12,r7[0x0]
8000ac1e:	6e 48       	ld.w	r8,r7[0x10]
8000ac20:	10 3c       	cp.w	r12,r8
8000ac22:	5f b8       	srhi	r8
8000ac24:	f5 e8 00 08 	and	r8,r10,r8
8000ac28:	f2 08 18 00 	cp.b	r8,r9
8000ac2c:	c0 d0       	breq	8000ac46 <__sfvwrite_r+0x18a>
8000ac2e:	06 9b       	mov	r11,r3
8000ac30:	08 9a       	mov	r10,r4
8000ac32:	fe b0 e5 c9 	rcall	800077c4 <memmove>
8000ac36:	6e 08       	ld.w	r8,r7[0x0]
8000ac38:	08 08       	add	r8,r4
8000ac3a:	0e 9b       	mov	r11,r7
8000ac3c:	8f 08       	st.w	r7[0x0],r8
8000ac3e:	0a 9c       	mov	r12,r5
8000ac40:	cb 6e       	rcall	8000a9ac <_fflush_r>
8000ac42:	c1 90       	breq	8000ac74 <__sfvwrite_r+0x1b8>
8000ac44:	c8 18       	rjmp	8000ad46 <__sfvwrite_r+0x28a>
8000ac46:	6e 59       	ld.w	r9,r7[0x14]
8000ac48:	12 36       	cp.w	r6,r9
8000ac4a:	c0 a3       	brcs	8000ac5e <__sfvwrite_r+0x1a2>
8000ac4c:	6e a8       	ld.w	r8,r7[0x28]
8000ac4e:	06 9a       	mov	r10,r3
8000ac50:	6e 8b       	ld.w	r11,r7[0x20]
8000ac52:	0a 9c       	mov	r12,r5
8000ac54:	5d 18       	icall	r8
8000ac56:	18 94       	mov	r4,r12
8000ac58:	e0 89 00 0e 	brgt	8000ac74 <__sfvwrite_r+0x1b8>
8000ac5c:	c7 58       	rjmp	8000ad46 <__sfvwrite_r+0x28a>
8000ac5e:	0c 9a       	mov	r10,r6
8000ac60:	06 9b       	mov	r11,r3
8000ac62:	fe b0 e5 b1 	rcall	800077c4 <memmove>
8000ac66:	6e 08       	ld.w	r8,r7[0x0]
8000ac68:	0c 08       	add	r8,r6
8000ac6a:	0c 94       	mov	r4,r6
8000ac6c:	8f 08       	st.w	r7[0x0],r8
8000ac6e:	6e 28       	ld.w	r8,r7[0x8]
8000ac70:	0c 18       	sub	r8,r6
8000ac72:	8f 28       	st.w	r7[0x8],r8
8000ac74:	62 28       	ld.w	r8,r1[0x8]
8000ac76:	08 18       	sub	r8,r4
8000ac78:	83 28       	st.w	r1[0x8],r8
8000ac7a:	c6 b0       	breq	8000ad50 <__sfvwrite_r+0x294>
8000ac7c:	08 16       	sub	r6,r4
8000ac7e:	08 03       	add	r3,r4
8000ac80:	c6 eb       	rjmp	8000ab5c <__sfvwrite_r+0xa0>
8000ac82:	60 03       	ld.w	r3,r0[0x0]
8000ac84:	60 11       	ld.w	r1,r0[0x4]
8000ac86:	30 08       	mov	r8,0
8000ac88:	2f 80       	sub	r0,-8
8000ac8a:	50 08       	stdsp	sp[0x0],r8
8000ac8c:	58 01       	cp.w	r1,0
8000ac8e:	cf a0       	breq	8000ac82 <__sfvwrite_r+0x1c6>
8000ac90:	40 0a       	lddsp	r10,sp[0x0]
8000ac92:	58 0a       	cp.w	r10,0
8000ac94:	c1 41       	brne	8000acbc <__sfvwrite_r+0x200>
8000ac96:	e2 c6 ff ff 	sub	r6,r1,-1
8000ac9a:	02 9a       	mov	r10,r1
8000ac9c:	30 ab       	mov	r11,10
8000ac9e:	06 9c       	mov	r12,r3
8000aca0:	cd 2c       	rcall	8000ae44 <memchr>
8000aca2:	f8 c8 ff ff 	sub	r8,r12,-1
8000aca6:	58 0c       	cp.w	r12,0
8000aca8:	f1 d3 e1 16 	subne	r6,r8,r3
8000acac:	f9 b9 01 01 	movne	r9,1
8000acb0:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000acb4:	f9 b8 00 01 	moveq	r8,1
8000acb8:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000acbc:	02 36       	cp.w	r6,r1
8000acbe:	ec 04 17 80 	movls	r4,r6
8000acc2:	e2 04 17 b0 	movhi	r4,r1
8000acc6:	6e 59       	ld.w	r9,r7[0x14]
8000acc8:	6e 25       	ld.w	r5,r7[0x8]
8000acca:	f2 05 00 05 	add	r5,r9,r5
8000acce:	0a 34       	cp.w	r4,r5
8000acd0:	5f 9a       	srgt	r10
8000acd2:	6e 0c       	ld.w	r12,r7[0x0]
8000acd4:	6e 48       	ld.w	r8,r7[0x10]
8000acd6:	10 3c       	cp.w	r12,r8
8000acd8:	5f b8       	srhi	r8
8000acda:	f5 e8 00 08 	and	r8,r10,r8
8000acde:	30 0a       	mov	r10,0
8000ace0:	f4 08 18 00 	cp.b	r8,r10
8000ace4:	c0 d0       	breq	8000acfe <__sfvwrite_r+0x242>
8000ace6:	06 9b       	mov	r11,r3
8000ace8:	0a 9a       	mov	r10,r5
8000acea:	fe b0 e5 6d 	rcall	800077c4 <memmove>
8000acee:	6e 08       	ld.w	r8,r7[0x0]
8000acf0:	0a 08       	add	r8,r5
8000acf2:	0e 9b       	mov	r11,r7
8000acf4:	8f 08       	st.w	r7[0x0],r8
8000acf6:	40 1c       	lddsp	r12,sp[0x4]
8000acf8:	c5 ae       	rcall	8000a9ac <_fflush_r>
8000acfa:	c1 80       	breq	8000ad2a <__sfvwrite_r+0x26e>
8000acfc:	c2 58       	rjmp	8000ad46 <__sfvwrite_r+0x28a>
8000acfe:	12 34       	cp.w	r4,r9
8000ad00:	c0 a5       	brlt	8000ad14 <__sfvwrite_r+0x258>
8000ad02:	6e a8       	ld.w	r8,r7[0x28]
8000ad04:	06 9a       	mov	r10,r3
8000ad06:	6e 8b       	ld.w	r11,r7[0x20]
8000ad08:	40 1c       	lddsp	r12,sp[0x4]
8000ad0a:	5d 18       	icall	r8
8000ad0c:	18 95       	mov	r5,r12
8000ad0e:	e0 89 00 0e 	brgt	8000ad2a <__sfvwrite_r+0x26e>
8000ad12:	c1 a8       	rjmp	8000ad46 <__sfvwrite_r+0x28a>
8000ad14:	08 9a       	mov	r10,r4
8000ad16:	06 9b       	mov	r11,r3
8000ad18:	fe b0 e5 56 	rcall	800077c4 <memmove>
8000ad1c:	6e 08       	ld.w	r8,r7[0x0]
8000ad1e:	08 08       	add	r8,r4
8000ad20:	08 95       	mov	r5,r4
8000ad22:	8f 08       	st.w	r7[0x0],r8
8000ad24:	6e 28       	ld.w	r8,r7[0x8]
8000ad26:	08 18       	sub	r8,r4
8000ad28:	8f 28       	st.w	r7[0x8],r8
8000ad2a:	0a 16       	sub	r6,r5
8000ad2c:	c0 61       	brne	8000ad38 <__sfvwrite_r+0x27c>
8000ad2e:	0e 9b       	mov	r11,r7
8000ad30:	40 1c       	lddsp	r12,sp[0x4]
8000ad32:	c3 de       	rcall	8000a9ac <_fflush_r>
8000ad34:	c0 91       	brne	8000ad46 <__sfvwrite_r+0x28a>
8000ad36:	50 06       	stdsp	sp[0x0],r6
8000ad38:	64 28       	ld.w	r8,r2[0x8]
8000ad3a:	0a 18       	sub	r8,r5
8000ad3c:	85 28       	st.w	r2[0x8],r8
8000ad3e:	c0 90       	breq	8000ad50 <__sfvwrite_r+0x294>
8000ad40:	0a 11       	sub	r1,r5
8000ad42:	0a 03       	add	r3,r5
8000ad44:	ca 4b       	rjmp	8000ac8c <__sfvwrite_r+0x1d0>
8000ad46:	8e 68       	ld.sh	r8,r7[0xc]
8000ad48:	a7 a8       	sbr	r8,0x6
8000ad4a:	ae 68       	st.h	r7[0xc],r8
8000ad4c:	3f fc       	mov	r12,-1
8000ad4e:	c0 28       	rjmp	8000ad52 <__sfvwrite_r+0x296>
8000ad50:	30 0c       	mov	r12,0
8000ad52:	2f dd       	sub	sp,-12
8000ad54:	d8 32       	popm	r0-r7,pc
8000ad56:	d7 03       	nop

8000ad58 <_localeconv_r>:
8000ad58:	fe cc e3 dc 	sub	r12,pc,-7204
8000ad5c:	5e fc       	retal	r12
8000ad5e:	d7 03       	nop

8000ad60 <_lseek_r>:
8000ad60:	d4 21       	pushm	r4-r7,lr
8000ad62:	16 98       	mov	r8,r11
8000ad64:	18 97       	mov	r7,r12
8000ad66:	10 9c       	mov	r12,r8
8000ad68:	30 08       	mov	r8,0
8000ad6a:	14 9b       	mov	r11,r10
8000ad6c:	e0 66 08 10 	mov	r6,2064
8000ad70:	12 9a       	mov	r10,r9
8000ad72:	8d 08       	st.w	r6[0x0],r8
8000ad74:	fe b0 e2 12 	rcall	80007198 <_lseek>
8000ad78:	5b fc       	cp.w	r12,-1
8000ad7a:	c0 51       	brne	8000ad84 <_lseek_r+0x24>
8000ad7c:	6c 08       	ld.w	r8,r6[0x0]
8000ad7e:	58 08       	cp.w	r8,0
8000ad80:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ad84:	d8 22       	popm	r4-r7,pc
8000ad86:	d7 03       	nop

8000ad88 <__smakebuf_r>:
8000ad88:	d4 21       	pushm	r4-r7,lr
8000ad8a:	20 fd       	sub	sp,60
8000ad8c:	96 68       	ld.sh	r8,r11[0xc]
8000ad8e:	16 97       	mov	r7,r11
8000ad90:	18 96       	mov	r6,r12
8000ad92:	e2 18 00 02 	andl	r8,0x2,COH
8000ad96:	c3 d1       	brne	8000ae10 <__smakebuf_r+0x88>
8000ad98:	96 7b       	ld.sh	r11,r11[0xe]
8000ad9a:	f0 0b 19 00 	cp.h	r11,r8
8000ad9e:	c0 55       	brlt	8000ada8 <__smakebuf_r+0x20>
8000ada0:	1a 9a       	mov	r10,sp
8000ada2:	e0 a0 03 b5 	rcall	8000b50c <_fstat_r>
8000ada6:	c0 f4       	brge	8000adc4 <__smakebuf_r+0x3c>
8000ada8:	8e 65       	ld.sh	r5,r7[0xc]
8000adaa:	0a 98       	mov	r8,r5
8000adac:	ab b8       	sbr	r8,0xb
8000adae:	e2 15 00 80 	andl	r5,0x80,COH
8000adb2:	ae 68       	st.h	r7[0xc],r8
8000adb4:	30 04       	mov	r4,0
8000adb6:	e0 68 04 00 	mov	r8,1024
8000adba:	f9 b5 01 40 	movne	r5,64
8000adbe:	f0 05 17 00 	moveq	r5,r8
8000adc2:	c1 c8       	rjmp	8000adfa <__smakebuf_r+0x72>
8000adc4:	40 18       	lddsp	r8,sp[0x4]
8000adc6:	e2 18 f0 00 	andl	r8,0xf000,COH
8000adca:	e0 48 20 00 	cp.w	r8,8192
8000adce:	5f 04       	sreq	r4
8000add0:	e0 48 80 00 	cp.w	r8,32768
8000add4:	c0 e1       	brne	8000adf0 <__smakebuf_r+0x68>
8000add6:	6e b9       	ld.w	r9,r7[0x2c]
8000add8:	fe c8 35 c8 	sub	r8,pc,13768
8000addc:	10 39       	cp.w	r9,r8
8000adde:	c0 91       	brne	8000adf0 <__smakebuf_r+0x68>
8000ade0:	8e 68       	ld.sh	r8,r7[0xc]
8000ade2:	e0 65 04 00 	mov	r5,1024
8000ade6:	ab a8       	sbr	r8,0xa
8000ade8:	ef 45 00 50 	st.w	r7[80],r5
8000adec:	ae 68       	st.h	r7[0xc],r8
8000adee:	c0 68       	rjmp	8000adfa <__smakebuf_r+0x72>
8000adf0:	8e 68       	ld.sh	r8,r7[0xc]
8000adf2:	e0 65 04 00 	mov	r5,1024
8000adf6:	ab b8       	sbr	r8,0xb
8000adf8:	ae 68       	st.h	r7[0xc],r8
8000adfa:	0a 9b       	mov	r11,r5
8000adfc:	0c 9c       	mov	r12,r6
8000adfe:	fe b0 dd 71 	rcall	800068e0 <_malloc_r>
8000ae02:	8e 68       	ld.sh	r8,r7[0xc]
8000ae04:	c0 d1       	brne	8000ae1e <__smakebuf_r+0x96>
8000ae06:	ed b8 00 09 	bld	r8,0x9
8000ae0a:	c1 b0       	breq	8000ae40 <__smakebuf_r+0xb8>
8000ae0c:	a1 b8       	sbr	r8,0x1
8000ae0e:	ae 68       	st.h	r7[0xc],r8
8000ae10:	ee c8 ff b9 	sub	r8,r7,-71
8000ae14:	8f 48       	st.w	r7[0x10],r8
8000ae16:	8f 08       	st.w	r7[0x0],r8
8000ae18:	30 18       	mov	r8,1
8000ae1a:	8f 58       	st.w	r7[0x14],r8
8000ae1c:	c1 28       	rjmp	8000ae40 <__smakebuf_r+0xb8>
8000ae1e:	a7 b8       	sbr	r8,0x7
8000ae20:	8f 4c       	st.w	r7[0x10],r12
8000ae22:	ae 68       	st.h	r7[0xc],r8
8000ae24:	8f 55       	st.w	r7[0x14],r5
8000ae26:	fe c8 3a 0a 	sub	r8,pc,14858
8000ae2a:	8f 0c       	st.w	r7[0x0],r12
8000ae2c:	8d a8       	st.w	r6[0x28],r8
8000ae2e:	58 04       	cp.w	r4,0
8000ae30:	c0 80       	breq	8000ae40 <__smakebuf_r+0xb8>
8000ae32:	8e 7c       	ld.sh	r12,r7[0xe]
8000ae34:	fe b0 e1 bc 	rcall	800071ac <isatty>
8000ae38:	c0 40       	breq	8000ae40 <__smakebuf_r+0xb8>
8000ae3a:	8e 68       	ld.sh	r8,r7[0xc]
8000ae3c:	a1 a8       	sbr	r8,0x0
8000ae3e:	ae 68       	st.h	r7[0xc],r8
8000ae40:	2f 1d       	sub	sp,-60
8000ae42:	d8 22       	popm	r4-r7,pc

8000ae44 <memchr>:
8000ae44:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000ae48:	c0 68       	rjmp	8000ae54 <memchr+0x10>
8000ae4a:	20 1a       	sub	r10,1
8000ae4c:	19 88       	ld.ub	r8,r12[0x0]
8000ae4e:	16 38       	cp.w	r8,r11
8000ae50:	5e 0c       	reteq	r12
8000ae52:	2f fc       	sub	r12,-1
8000ae54:	58 0a       	cp.w	r10,0
8000ae56:	cf a1       	brne	8000ae4a <memchr+0x6>
8000ae58:	5e fa       	retal	r10

8000ae5a <__hi0bits>:
8000ae5a:	18 98       	mov	r8,r12
8000ae5c:	e0 1c 00 00 	andl	r12,0x0
8000ae60:	f0 09 15 10 	lsl	r9,r8,0x10
8000ae64:	58 0c       	cp.w	r12,0
8000ae66:	f2 08 17 00 	moveq	r8,r9
8000ae6a:	f9 bc 00 10 	moveq	r12,16
8000ae6e:	f9 bc 01 00 	movne	r12,0
8000ae72:	10 9a       	mov	r10,r8
8000ae74:	f0 09 15 08 	lsl	r9,r8,0x8
8000ae78:	e6 1a ff 00 	andh	r10,0xff00,COH
8000ae7c:	f7 bc 00 f8 	subeq	r12,-8
8000ae80:	f2 08 17 00 	moveq	r8,r9
8000ae84:	10 9a       	mov	r10,r8
8000ae86:	f0 09 15 04 	lsl	r9,r8,0x4
8000ae8a:	e6 1a f0 00 	andh	r10,0xf000,COH
8000ae8e:	f7 bc 00 fc 	subeq	r12,-4
8000ae92:	f2 08 17 00 	moveq	r8,r9
8000ae96:	10 9a       	mov	r10,r8
8000ae98:	f0 09 15 02 	lsl	r9,r8,0x2
8000ae9c:	e6 1a c0 00 	andh	r10,0xc000,COH
8000aea0:	f7 bc 00 fe 	subeq	r12,-2
8000aea4:	f2 08 17 00 	moveq	r8,r9
8000aea8:	58 08       	cp.w	r8,0
8000aeaa:	5e 5c       	retlt	r12
8000aeac:	ed b8 00 1e 	bld	r8,0x1e
8000aeb0:	f9 bc 01 20 	movne	r12,32
8000aeb4:	f7 bc 00 ff 	subeq	r12,-1
8000aeb8:	5e fc       	retal	r12

8000aeba <__lo0bits>:
8000aeba:	18 99       	mov	r9,r12
8000aebc:	78 08       	ld.w	r8,r12[0x0]
8000aebe:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000aec2:	c1 50       	breq	8000aeec <__lo0bits+0x32>
8000aec4:	ed b8 00 00 	bld	r8,0x0
8000aec8:	c0 21       	brne	8000aecc <__lo0bits+0x12>
8000aeca:	5e fd       	retal	0
8000aecc:	10 9b       	mov	r11,r8
8000aece:	f0 0a 16 01 	lsr	r10,r8,0x1
8000aed2:	e2 1b 00 02 	andl	r11,0x2,COH
8000aed6:	a3 88       	lsr	r8,0x2
8000aed8:	58 0b       	cp.w	r11,0
8000aeda:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000aede:	f9 bc 01 01 	movne	r12,1
8000aee2:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000aee6:	f9 bc 00 02 	moveq	r12,2
8000aeea:	5e fc       	retal	r12
8000aeec:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000aef0:	f0 0b 16 10 	lsr	r11,r8,0x10
8000aef4:	58 0a       	cp.w	r10,0
8000aef6:	f6 08 17 00 	moveq	r8,r11
8000aefa:	f9 bc 00 10 	moveq	r12,16
8000aefe:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000af02:	f0 0a 16 08 	lsr	r10,r8,0x8
8000af06:	58 0b       	cp.w	r11,0
8000af08:	f7 bc 00 f8 	subeq	r12,-8
8000af0c:	f4 08 17 00 	moveq	r8,r10
8000af10:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000af14:	f0 0a 16 04 	lsr	r10,r8,0x4
8000af18:	58 0b       	cp.w	r11,0
8000af1a:	f7 bc 00 fc 	subeq	r12,-4
8000af1e:	f4 08 17 00 	moveq	r8,r10
8000af22:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000af26:	f0 0a 16 02 	lsr	r10,r8,0x2
8000af2a:	58 0b       	cp.w	r11,0
8000af2c:	f7 bc 00 fe 	subeq	r12,-2
8000af30:	f4 08 17 00 	moveq	r8,r10
8000af34:	ed b8 00 00 	bld	r8,0x0
8000af38:	c0 60       	breq	8000af44 <__lo0bits+0x8a>
8000af3a:	a1 98       	lsr	r8,0x1
8000af3c:	c0 31       	brne	8000af42 <__lo0bits+0x88>
8000af3e:	32 0c       	mov	r12,32
8000af40:	5e fc       	retal	r12
8000af42:	2f fc       	sub	r12,-1
8000af44:	93 08       	st.w	r9[0x0],r8
8000af46:	5e fc       	retal	r12

8000af48 <__mcmp>:
8000af48:	d4 01       	pushm	lr
8000af4a:	18 98       	mov	r8,r12
8000af4c:	76 49       	ld.w	r9,r11[0x10]
8000af4e:	78 4c       	ld.w	r12,r12[0x10]
8000af50:	12 1c       	sub	r12,r9
8000af52:	c1 31       	brne	8000af78 <__mcmp+0x30>
8000af54:	2f b9       	sub	r9,-5
8000af56:	a3 69       	lsl	r9,0x2
8000af58:	12 0b       	add	r11,r9
8000af5a:	f0 09 00 09 	add	r9,r8,r9
8000af5e:	2e c8       	sub	r8,-20
8000af60:	13 4e       	ld.w	lr,--r9
8000af62:	17 4a       	ld.w	r10,--r11
8000af64:	14 3e       	cp.w	lr,r10
8000af66:	c0 60       	breq	8000af72 <__mcmp+0x2a>
8000af68:	f9 bc 03 ff 	movlo	r12,-1
8000af6c:	f9 bc 02 01 	movhs	r12,1
8000af70:	d8 02       	popm	pc
8000af72:	10 39       	cp.w	r9,r8
8000af74:	fe 9b ff f6 	brhi	8000af60 <__mcmp+0x18>
8000af78:	d8 02       	popm	pc
8000af7a:	d7 03       	nop

8000af7c <_Bfree>:
8000af7c:	d4 21       	pushm	r4-r7,lr
8000af7e:	18 97       	mov	r7,r12
8000af80:	16 95       	mov	r5,r11
8000af82:	78 96       	ld.w	r6,r12[0x24]
8000af84:	58 06       	cp.w	r6,0
8000af86:	c0 91       	brne	8000af98 <_Bfree+0x1c>
8000af88:	31 0c       	mov	r12,16
8000af8a:	fe b0 dc a3 	rcall	800068d0 <malloc>
8000af8e:	99 36       	st.w	r12[0xc],r6
8000af90:	8f 9c       	st.w	r7[0x24],r12
8000af92:	99 16       	st.w	r12[0x4],r6
8000af94:	99 26       	st.w	r12[0x8],r6
8000af96:	99 06       	st.w	r12[0x0],r6
8000af98:	58 05       	cp.w	r5,0
8000af9a:	c0 90       	breq	8000afac <_Bfree+0x30>
8000af9c:	6a 19       	ld.w	r9,r5[0x4]
8000af9e:	6e 98       	ld.w	r8,r7[0x24]
8000afa0:	70 38       	ld.w	r8,r8[0xc]
8000afa2:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000afa6:	8b 0a       	st.w	r5[0x0],r10
8000afa8:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000afac:	d8 22       	popm	r4-r7,pc
8000afae:	d7 03       	nop

8000afb0 <_Balloc>:
8000afb0:	d4 21       	pushm	r4-r7,lr
8000afb2:	18 97       	mov	r7,r12
8000afb4:	16 96       	mov	r6,r11
8000afb6:	78 95       	ld.w	r5,r12[0x24]
8000afb8:	58 05       	cp.w	r5,0
8000afba:	c0 91       	brne	8000afcc <_Balloc+0x1c>
8000afbc:	31 0c       	mov	r12,16
8000afbe:	fe b0 dc 89 	rcall	800068d0 <malloc>
8000afc2:	99 35       	st.w	r12[0xc],r5
8000afc4:	8f 9c       	st.w	r7[0x24],r12
8000afc6:	99 15       	st.w	r12[0x4],r5
8000afc8:	99 25       	st.w	r12[0x8],r5
8000afca:	99 05       	st.w	r12[0x0],r5
8000afcc:	6e 95       	ld.w	r5,r7[0x24]
8000afce:	6a 38       	ld.w	r8,r5[0xc]
8000afd0:	58 08       	cp.w	r8,0
8000afd2:	c0 b1       	brne	8000afe8 <_Balloc+0x38>
8000afd4:	31 0a       	mov	r10,16
8000afd6:	30 4b       	mov	r11,4
8000afd8:	0e 9c       	mov	r12,r7
8000afda:	e0 a0 02 6d 	rcall	8000b4b4 <_calloc_r>
8000afde:	8b 3c       	st.w	r5[0xc],r12
8000afe0:	6e 98       	ld.w	r8,r7[0x24]
8000afe2:	70 3c       	ld.w	r12,r8[0xc]
8000afe4:	58 0c       	cp.w	r12,0
8000afe6:	c1 b0       	breq	8000b01c <_Balloc+0x6c>
8000afe8:	6e 98       	ld.w	r8,r7[0x24]
8000afea:	70 38       	ld.w	r8,r8[0xc]
8000afec:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000aff0:	70 0c       	ld.w	r12,r8[0x0]
8000aff2:	58 0c       	cp.w	r12,0
8000aff4:	c0 40       	breq	8000affc <_Balloc+0x4c>
8000aff6:	78 09       	ld.w	r9,r12[0x0]
8000aff8:	91 09       	st.w	r8[0x0],r9
8000affa:	c0 e8       	rjmp	8000b016 <_Balloc+0x66>
8000affc:	0e 9c       	mov	r12,r7
8000affe:	30 17       	mov	r7,1
8000b000:	0e 9b       	mov	r11,r7
8000b002:	ee 06 09 47 	lsl	r7,r7,r6
8000b006:	ee ca ff fb 	sub	r10,r7,-5
8000b00a:	a3 6a       	lsl	r10,0x2
8000b00c:	e0 a0 02 54 	rcall	8000b4b4 <_calloc_r>
8000b010:	c0 60       	breq	8000b01c <_Balloc+0x6c>
8000b012:	99 16       	st.w	r12[0x4],r6
8000b014:	99 27       	st.w	r12[0x8],r7
8000b016:	30 08       	mov	r8,0
8000b018:	99 38       	st.w	r12[0xc],r8
8000b01a:	99 48       	st.w	r12[0x10],r8
8000b01c:	d8 22       	popm	r4-r7,pc
8000b01e:	d7 03       	nop

8000b020 <__d2b>:
8000b020:	d4 31       	pushm	r0-r7,lr
8000b022:	20 2d       	sub	sp,8
8000b024:	16 93       	mov	r3,r11
8000b026:	12 96       	mov	r6,r9
8000b028:	10 95       	mov	r5,r8
8000b02a:	14 92       	mov	r2,r10
8000b02c:	30 1b       	mov	r11,1
8000b02e:	cc 1f       	rcall	8000afb0 <_Balloc>
8000b030:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b034:	50 09       	stdsp	sp[0x0],r9
8000b036:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b03a:	b5 a9       	sbr	r9,0x14
8000b03c:	f0 01 16 14 	lsr	r1,r8,0x14
8000b040:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b044:	18 94       	mov	r4,r12
8000b046:	58 02       	cp.w	r2,0
8000b048:	c1 d0       	breq	8000b082 <__d2b+0x62>
8000b04a:	fa cc ff f8 	sub	r12,sp,-8
8000b04e:	18 d2       	st.w	--r12,r2
8000b050:	c3 5f       	rcall	8000aeba <__lo0bits>
8000b052:	40 18       	lddsp	r8,sp[0x4]
8000b054:	c0 d0       	breq	8000b06e <__d2b+0x4e>
8000b056:	40 09       	lddsp	r9,sp[0x0]
8000b058:	f8 0a 11 20 	rsub	r10,r12,32
8000b05c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b060:	f5 e8 10 08 	or	r8,r10,r8
8000b064:	89 58       	st.w	r4[0x14],r8
8000b066:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b06a:	50 09       	stdsp	sp[0x0],r9
8000b06c:	c0 28       	rjmp	8000b070 <__d2b+0x50>
8000b06e:	89 58       	st.w	r4[0x14],r8
8000b070:	40 08       	lddsp	r8,sp[0x0]
8000b072:	58 08       	cp.w	r8,0
8000b074:	f9 b3 01 02 	movne	r3,2
8000b078:	f9 b3 00 01 	moveq	r3,1
8000b07c:	89 68       	st.w	r4[0x18],r8
8000b07e:	89 43       	st.w	r4[0x10],r3
8000b080:	c0 88       	rjmp	8000b090 <__d2b+0x70>
8000b082:	1a 9c       	mov	r12,sp
8000b084:	c1 bf       	rcall	8000aeba <__lo0bits>
8000b086:	30 13       	mov	r3,1
8000b088:	40 08       	lddsp	r8,sp[0x0]
8000b08a:	2e 0c       	sub	r12,-32
8000b08c:	89 43       	st.w	r4[0x10],r3
8000b08e:	89 58       	st.w	r4[0x14],r8
8000b090:	58 01       	cp.w	r1,0
8000b092:	c0 90       	breq	8000b0a4 <__d2b+0x84>
8000b094:	e2 c1 04 33 	sub	r1,r1,1075
8000b098:	18 01       	add	r1,r12
8000b09a:	8d 01       	st.w	r6[0x0],r1
8000b09c:	f8 0c 11 35 	rsub	r12,r12,53
8000b0a0:	8b 0c       	st.w	r5[0x0],r12
8000b0a2:	c0 c8       	rjmp	8000b0ba <__d2b+0x9a>
8000b0a4:	e6 c8 ff fc 	sub	r8,r3,-4
8000b0a8:	f8 cc 04 32 	sub	r12,r12,1074
8000b0ac:	a5 73       	lsl	r3,0x5
8000b0ae:	8d 0c       	st.w	r6[0x0],r12
8000b0b0:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b0b4:	cd 3e       	rcall	8000ae5a <__hi0bits>
8000b0b6:	18 13       	sub	r3,r12
8000b0b8:	8b 03       	st.w	r5[0x0],r3
8000b0ba:	08 9c       	mov	r12,r4
8000b0bc:	2f ed       	sub	sp,-8
8000b0be:	d8 32       	popm	r0-r7,pc

8000b0c0 <__mdiff>:
8000b0c0:	d4 31       	pushm	r0-r7,lr
8000b0c2:	74 48       	ld.w	r8,r10[0x10]
8000b0c4:	76 45       	ld.w	r5,r11[0x10]
8000b0c6:	16 97       	mov	r7,r11
8000b0c8:	14 96       	mov	r6,r10
8000b0ca:	10 15       	sub	r5,r8
8000b0cc:	c1 31       	brne	8000b0f2 <__mdiff+0x32>
8000b0ce:	2f b8       	sub	r8,-5
8000b0d0:	ee ce ff ec 	sub	lr,r7,-20
8000b0d4:	a3 68       	lsl	r8,0x2
8000b0d6:	f4 08 00 0b 	add	r11,r10,r8
8000b0da:	ee 08 00 08 	add	r8,r7,r8
8000b0de:	11 4a       	ld.w	r10,--r8
8000b0e0:	17 49       	ld.w	r9,--r11
8000b0e2:	12 3a       	cp.w	r10,r9
8000b0e4:	c0 30       	breq	8000b0ea <__mdiff+0x2a>
8000b0e6:	c0 e2       	brcc	8000b102 <__mdiff+0x42>
8000b0e8:	c0 78       	rjmp	8000b0f6 <__mdiff+0x36>
8000b0ea:	1c 38       	cp.w	r8,lr
8000b0ec:	fe 9b ff f9 	brhi	8000b0de <__mdiff+0x1e>
8000b0f0:	c4 98       	rjmp	8000b182 <__mdiff+0xc2>
8000b0f2:	58 05       	cp.w	r5,0
8000b0f4:	c0 64       	brge	8000b100 <__mdiff+0x40>
8000b0f6:	0e 98       	mov	r8,r7
8000b0f8:	30 15       	mov	r5,1
8000b0fa:	0c 97       	mov	r7,r6
8000b0fc:	10 96       	mov	r6,r8
8000b0fe:	c0 28       	rjmp	8000b102 <__mdiff+0x42>
8000b100:	30 05       	mov	r5,0
8000b102:	6e 1b       	ld.w	r11,r7[0x4]
8000b104:	c5 6f       	rcall	8000afb0 <_Balloc>
8000b106:	6e 49       	ld.w	r9,r7[0x10]
8000b108:	6c 44       	ld.w	r4,r6[0x10]
8000b10a:	99 35       	st.w	r12[0xc],r5
8000b10c:	2f b4       	sub	r4,-5
8000b10e:	f2 c5 ff fb 	sub	r5,r9,-5
8000b112:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b116:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b11a:	2e c6       	sub	r6,-20
8000b11c:	2e c7       	sub	r7,-20
8000b11e:	f8 c8 ff ec 	sub	r8,r12,-20
8000b122:	30 0a       	mov	r10,0
8000b124:	0f 0e       	ld.w	lr,r7++
8000b126:	0d 0b       	ld.w	r11,r6++
8000b128:	fc 02 16 10 	lsr	r2,lr,0x10
8000b12c:	f6 03 16 10 	lsr	r3,r11,0x10
8000b130:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b134:	e4 03 01 03 	sub	r3,r2,r3
8000b138:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b13c:	fc 0b 01 0b 	sub	r11,lr,r11
8000b140:	f6 0a 00 0a 	add	r10,r11,r10
8000b144:	b0 1a       	st.h	r8[0x2],r10
8000b146:	b1 4a       	asr	r10,0x10
8000b148:	e6 0a 00 0a 	add	r10,r3,r10
8000b14c:	b0 0a       	st.h	r8[0x0],r10
8000b14e:	2f c8       	sub	r8,-4
8000b150:	b1 4a       	asr	r10,0x10
8000b152:	08 36       	cp.w	r6,r4
8000b154:	ce 83       	brcs	8000b124 <__mdiff+0x64>
8000b156:	c0 d8       	rjmp	8000b170 <__mdiff+0xb0>
8000b158:	0f 0b       	ld.w	r11,r7++
8000b15a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b15e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b162:	16 0a       	add	r10,r11
8000b164:	b0 1a       	st.h	r8[0x2],r10
8000b166:	b1 4a       	asr	r10,0x10
8000b168:	1c 0a       	add	r10,lr
8000b16a:	b0 0a       	st.h	r8[0x0],r10
8000b16c:	2f c8       	sub	r8,-4
8000b16e:	b1 4a       	asr	r10,0x10
8000b170:	0a 37       	cp.w	r7,r5
8000b172:	cf 33       	brcs	8000b158 <__mdiff+0x98>
8000b174:	c0 28       	rjmp	8000b178 <__mdiff+0xb8>
8000b176:	20 19       	sub	r9,1
8000b178:	11 4a       	ld.w	r10,--r8
8000b17a:	58 0a       	cp.w	r10,0
8000b17c:	cf d0       	breq	8000b176 <__mdiff+0xb6>
8000b17e:	99 49       	st.w	r12[0x10],r9
8000b180:	d8 32       	popm	r0-r7,pc
8000b182:	30 0b       	mov	r11,0
8000b184:	c1 6f       	rcall	8000afb0 <_Balloc>
8000b186:	30 18       	mov	r8,1
8000b188:	99 48       	st.w	r12[0x10],r8
8000b18a:	30 08       	mov	r8,0
8000b18c:	99 58       	st.w	r12[0x14],r8
8000b18e:	d8 32       	popm	r0-r7,pc

8000b190 <__lshift>:
8000b190:	d4 31       	pushm	r0-r7,lr
8000b192:	16 97       	mov	r7,r11
8000b194:	76 46       	ld.w	r6,r11[0x10]
8000b196:	f4 02 14 05 	asr	r2,r10,0x5
8000b19a:	2f f6       	sub	r6,-1
8000b19c:	14 93       	mov	r3,r10
8000b19e:	18 94       	mov	r4,r12
8000b1a0:	04 06       	add	r6,r2
8000b1a2:	76 1b       	ld.w	r11,r11[0x4]
8000b1a4:	6e 28       	ld.w	r8,r7[0x8]
8000b1a6:	c0 38       	rjmp	8000b1ac <__lshift+0x1c>
8000b1a8:	2f fb       	sub	r11,-1
8000b1aa:	a1 78       	lsl	r8,0x1
8000b1ac:	10 36       	cp.w	r6,r8
8000b1ae:	fe 99 ff fd 	brgt	8000b1a8 <__lshift+0x18>
8000b1b2:	08 9c       	mov	r12,r4
8000b1b4:	cf ee       	rcall	8000afb0 <_Balloc>
8000b1b6:	30 09       	mov	r9,0
8000b1b8:	18 95       	mov	r5,r12
8000b1ba:	f8 c8 ff ec 	sub	r8,r12,-20
8000b1be:	12 9a       	mov	r10,r9
8000b1c0:	c0 38       	rjmp	8000b1c6 <__lshift+0x36>
8000b1c2:	10 aa       	st.w	r8++,r10
8000b1c4:	2f f9       	sub	r9,-1
8000b1c6:	04 39       	cp.w	r9,r2
8000b1c8:	cf d5       	brlt	8000b1c2 <__lshift+0x32>
8000b1ca:	6e 4b       	ld.w	r11,r7[0x10]
8000b1cc:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b1d0:	2f bb       	sub	r11,-5
8000b1d2:	ee c9 ff ec 	sub	r9,r7,-20
8000b1d6:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b1da:	58 03       	cp.w	r3,0
8000b1dc:	c1 30       	breq	8000b202 <__lshift+0x72>
8000b1de:	e6 0c 11 20 	rsub	r12,r3,32
8000b1e2:	30 0a       	mov	r10,0
8000b1e4:	72 02       	ld.w	r2,r9[0x0]
8000b1e6:	e4 03 09 42 	lsl	r2,r2,r3
8000b1ea:	04 4a       	or	r10,r2
8000b1ec:	10 aa       	st.w	r8++,r10
8000b1ee:	13 0a       	ld.w	r10,r9++
8000b1f0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b1f4:	16 39       	cp.w	r9,r11
8000b1f6:	cf 73       	brcs	8000b1e4 <__lshift+0x54>
8000b1f8:	91 0a       	st.w	r8[0x0],r10
8000b1fa:	58 0a       	cp.w	r10,0
8000b1fc:	c0 70       	breq	8000b20a <__lshift+0x7a>
8000b1fe:	2f f6       	sub	r6,-1
8000b200:	c0 58       	rjmp	8000b20a <__lshift+0x7a>
8000b202:	13 0a       	ld.w	r10,r9++
8000b204:	10 aa       	st.w	r8++,r10
8000b206:	16 39       	cp.w	r9,r11
8000b208:	cf d3       	brcs	8000b202 <__lshift+0x72>
8000b20a:	08 9c       	mov	r12,r4
8000b20c:	20 16       	sub	r6,1
8000b20e:	0e 9b       	mov	r11,r7
8000b210:	8b 46       	st.w	r5[0x10],r6
8000b212:	cb 5e       	rcall	8000af7c <_Bfree>
8000b214:	0a 9c       	mov	r12,r5
8000b216:	d8 32       	popm	r0-r7,pc

8000b218 <__multiply>:
8000b218:	d4 31       	pushm	r0-r7,lr
8000b21a:	20 2d       	sub	sp,8
8000b21c:	76 49       	ld.w	r9,r11[0x10]
8000b21e:	74 48       	ld.w	r8,r10[0x10]
8000b220:	16 96       	mov	r6,r11
8000b222:	14 95       	mov	r5,r10
8000b224:	10 39       	cp.w	r9,r8
8000b226:	ec 08 17 50 	movlt	r8,r6
8000b22a:	ea 06 17 50 	movlt	r6,r5
8000b22e:	f0 05 17 50 	movlt	r5,r8
8000b232:	6c 28       	ld.w	r8,r6[0x8]
8000b234:	76 43       	ld.w	r3,r11[0x10]
8000b236:	74 42       	ld.w	r2,r10[0x10]
8000b238:	76 1b       	ld.w	r11,r11[0x4]
8000b23a:	e4 03 00 07 	add	r7,r2,r3
8000b23e:	10 37       	cp.w	r7,r8
8000b240:	f7 bb 09 ff 	subgt	r11,-1
8000b244:	cb 6e       	rcall	8000afb0 <_Balloc>
8000b246:	ee c4 ff fb 	sub	r4,r7,-5
8000b24a:	f8 c9 ff ec 	sub	r9,r12,-20
8000b24e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b252:	30 0a       	mov	r10,0
8000b254:	12 98       	mov	r8,r9
8000b256:	c0 28       	rjmp	8000b25a <__multiply+0x42>
8000b258:	10 aa       	st.w	r8++,r10
8000b25a:	08 38       	cp.w	r8,r4
8000b25c:	cf e3       	brcs	8000b258 <__multiply+0x40>
8000b25e:	2f b3       	sub	r3,-5
8000b260:	2f b2       	sub	r2,-5
8000b262:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b266:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b26a:	ec cb ff ec 	sub	r11,r6,-20
8000b26e:	50 12       	stdsp	sp[0x4],r2
8000b270:	ea ca ff ec 	sub	r10,r5,-20
8000b274:	c4 48       	rjmp	8000b2fc <__multiply+0xe4>
8000b276:	94 95       	ld.uh	r5,r10[0x2]
8000b278:	58 05       	cp.w	r5,0
8000b27a:	c2 00       	breq	8000b2ba <__multiply+0xa2>
8000b27c:	12 98       	mov	r8,r9
8000b27e:	16 96       	mov	r6,r11
8000b280:	30 0e       	mov	lr,0
8000b282:	50 09       	stdsp	sp[0x0],r9
8000b284:	0d 02       	ld.w	r2,r6++
8000b286:	e4 00 16 10 	lsr	r0,r2,0x10
8000b28a:	70 01       	ld.w	r1,r8[0x0]
8000b28c:	70 09       	ld.w	r9,r8[0x0]
8000b28e:	b1 81       	lsr	r1,0x10
8000b290:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b294:	e0 05 03 41 	mac	r1,r0,r5
8000b298:	ab 32       	mul	r2,r5
8000b29a:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b29e:	00 02       	add	r2,r0
8000b2a0:	e4 0e 00 0e 	add	lr,r2,lr
8000b2a4:	b0 1e       	st.h	r8[0x2],lr
8000b2a6:	b1 8e       	lsr	lr,0x10
8000b2a8:	1c 01       	add	r1,lr
8000b2aa:	b0 01       	st.h	r8[0x0],r1
8000b2ac:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b2b0:	2f c8       	sub	r8,-4
8000b2b2:	06 36       	cp.w	r6,r3
8000b2b4:	ce 83       	brcs	8000b284 <__multiply+0x6c>
8000b2b6:	40 09       	lddsp	r9,sp[0x0]
8000b2b8:	91 0e       	st.w	r8[0x0],lr
8000b2ba:	94 86       	ld.uh	r6,r10[0x0]
8000b2bc:	58 06       	cp.w	r6,0
8000b2be:	c1 d0       	breq	8000b2f8 <__multiply+0xe0>
8000b2c0:	72 02       	ld.w	r2,r9[0x0]
8000b2c2:	12 98       	mov	r8,r9
8000b2c4:	16 9e       	mov	lr,r11
8000b2c6:	30 05       	mov	r5,0
8000b2c8:	b0 12       	st.h	r8[0x2],r2
8000b2ca:	1d 01       	ld.w	r1,lr++
8000b2cc:	90 82       	ld.uh	r2,r8[0x0]
8000b2ce:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b2d2:	ad 30       	mul	r0,r6
8000b2d4:	e0 02 00 02 	add	r2,r0,r2
8000b2d8:	e4 05 00 05 	add	r5,r2,r5
8000b2dc:	b0 05       	st.h	r8[0x0],r5
8000b2de:	b1 85       	lsr	r5,0x10
8000b2e0:	b1 81       	lsr	r1,0x10
8000b2e2:	2f c8       	sub	r8,-4
8000b2e4:	ad 31       	mul	r1,r6
8000b2e6:	90 92       	ld.uh	r2,r8[0x2]
8000b2e8:	e2 02 00 02 	add	r2,r1,r2
8000b2ec:	0a 02       	add	r2,r5
8000b2ee:	e4 05 16 10 	lsr	r5,r2,0x10
8000b2f2:	06 3e       	cp.w	lr,r3
8000b2f4:	ce a3       	brcs	8000b2c8 <__multiply+0xb0>
8000b2f6:	91 02       	st.w	r8[0x0],r2
8000b2f8:	2f ca       	sub	r10,-4
8000b2fa:	2f c9       	sub	r9,-4
8000b2fc:	40 18       	lddsp	r8,sp[0x4]
8000b2fe:	10 3a       	cp.w	r10,r8
8000b300:	cb b3       	brcs	8000b276 <__multiply+0x5e>
8000b302:	c0 28       	rjmp	8000b306 <__multiply+0xee>
8000b304:	20 17       	sub	r7,1
8000b306:	58 07       	cp.w	r7,0
8000b308:	e0 8a 00 05 	brle	8000b312 <__multiply+0xfa>
8000b30c:	09 48       	ld.w	r8,--r4
8000b30e:	58 08       	cp.w	r8,0
8000b310:	cf a0       	breq	8000b304 <__multiply+0xec>
8000b312:	99 47       	st.w	r12[0x10],r7
8000b314:	2f ed       	sub	sp,-8
8000b316:	d8 32       	popm	r0-r7,pc

8000b318 <__i2b>:
8000b318:	d4 21       	pushm	r4-r7,lr
8000b31a:	16 97       	mov	r7,r11
8000b31c:	30 1b       	mov	r11,1
8000b31e:	c4 9e       	rcall	8000afb0 <_Balloc>
8000b320:	30 19       	mov	r9,1
8000b322:	99 57       	st.w	r12[0x14],r7
8000b324:	99 49       	st.w	r12[0x10],r9
8000b326:	d8 22       	popm	r4-r7,pc

8000b328 <__multadd>:
8000b328:	d4 31       	pushm	r0-r7,lr
8000b32a:	30 08       	mov	r8,0
8000b32c:	12 95       	mov	r5,r9
8000b32e:	16 97       	mov	r7,r11
8000b330:	18 96       	mov	r6,r12
8000b332:	76 44       	ld.w	r4,r11[0x10]
8000b334:	f6 c9 ff ec 	sub	r9,r11,-20
8000b338:	72 0b       	ld.w	r11,r9[0x0]
8000b33a:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b33e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b342:	f4 0c 02 4c 	mul	r12,r10,r12
8000b346:	f4 0b 03 45 	mac	r5,r10,r11
8000b34a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b34e:	b1 85       	lsr	r5,0x10
8000b350:	18 05       	add	r5,r12
8000b352:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b356:	f8 0b 00 0b 	add	r11,r12,r11
8000b35a:	12 ab       	st.w	r9++,r11
8000b35c:	2f f8       	sub	r8,-1
8000b35e:	b1 85       	lsr	r5,0x10
8000b360:	08 38       	cp.w	r8,r4
8000b362:	ce b5       	brlt	8000b338 <__multadd+0x10>
8000b364:	58 05       	cp.w	r5,0
8000b366:	c1 c0       	breq	8000b39e <__multadd+0x76>
8000b368:	6e 28       	ld.w	r8,r7[0x8]
8000b36a:	10 34       	cp.w	r4,r8
8000b36c:	c1 35       	brlt	8000b392 <__multadd+0x6a>
8000b36e:	6e 1b       	ld.w	r11,r7[0x4]
8000b370:	0c 9c       	mov	r12,r6
8000b372:	2f fb       	sub	r11,-1
8000b374:	c1 ee       	rcall	8000afb0 <_Balloc>
8000b376:	6e 4a       	ld.w	r10,r7[0x10]
8000b378:	ee cb ff f4 	sub	r11,r7,-12
8000b37c:	18 93       	mov	r3,r12
8000b37e:	2f ea       	sub	r10,-2
8000b380:	2f 4c       	sub	r12,-12
8000b382:	a3 6a       	lsl	r10,0x2
8000b384:	fe b0 dc ca 	rcall	80006d18 <memcpy>
8000b388:	0e 9b       	mov	r11,r7
8000b38a:	0c 9c       	mov	r12,r6
8000b38c:	fe b0 fd f8 	rcall	8000af7c <_Bfree>
8000b390:	06 97       	mov	r7,r3
8000b392:	e8 c8 ff ff 	sub	r8,r4,-1
8000b396:	2f b4       	sub	r4,-5
8000b398:	8f 48       	st.w	r7[0x10],r8
8000b39a:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b39e:	0e 9c       	mov	r12,r7
8000b3a0:	d8 32       	popm	r0-r7,pc
8000b3a2:	d7 03       	nop

8000b3a4 <__pow5mult>:
8000b3a4:	d4 31       	pushm	r0-r7,lr
8000b3a6:	14 96       	mov	r6,r10
8000b3a8:	18 97       	mov	r7,r12
8000b3aa:	16 94       	mov	r4,r11
8000b3ac:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b3b0:	c0 90       	breq	8000b3c2 <__pow5mult+0x1e>
8000b3b2:	20 18       	sub	r8,1
8000b3b4:	fe c9 e9 f8 	sub	r9,pc,-5640
8000b3b8:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b3bc:	30 09       	mov	r9,0
8000b3be:	cb 5f       	rcall	8000b328 <__multadd>
8000b3c0:	18 94       	mov	r4,r12
8000b3c2:	a3 46       	asr	r6,0x2
8000b3c4:	c3 40       	breq	8000b42c <__pow5mult+0x88>
8000b3c6:	6e 95       	ld.w	r5,r7[0x24]
8000b3c8:	58 05       	cp.w	r5,0
8000b3ca:	c0 91       	brne	8000b3dc <__pow5mult+0x38>
8000b3cc:	31 0c       	mov	r12,16
8000b3ce:	fe b0 da 81 	rcall	800068d0 <malloc>
8000b3d2:	99 35       	st.w	r12[0xc],r5
8000b3d4:	8f 9c       	st.w	r7[0x24],r12
8000b3d6:	99 15       	st.w	r12[0x4],r5
8000b3d8:	99 25       	st.w	r12[0x8],r5
8000b3da:	99 05       	st.w	r12[0x0],r5
8000b3dc:	6e 93       	ld.w	r3,r7[0x24]
8000b3de:	66 25       	ld.w	r5,r3[0x8]
8000b3e0:	58 05       	cp.w	r5,0
8000b3e2:	c0 c1       	brne	8000b3fa <__pow5mult+0x56>
8000b3e4:	e0 6b 02 71 	mov	r11,625
8000b3e8:	0e 9c       	mov	r12,r7
8000b3ea:	c9 7f       	rcall	8000b318 <__i2b>
8000b3ec:	87 2c       	st.w	r3[0x8],r12
8000b3ee:	30 08       	mov	r8,0
8000b3f0:	18 95       	mov	r5,r12
8000b3f2:	99 08       	st.w	r12[0x0],r8
8000b3f4:	c0 38       	rjmp	8000b3fa <__pow5mult+0x56>
8000b3f6:	06 9c       	mov	r12,r3
8000b3f8:	18 95       	mov	r5,r12
8000b3fa:	ed b6 00 00 	bld	r6,0x0
8000b3fe:	c0 b1       	brne	8000b414 <__pow5mult+0x70>
8000b400:	08 9b       	mov	r11,r4
8000b402:	0a 9a       	mov	r10,r5
8000b404:	0e 9c       	mov	r12,r7
8000b406:	c0 9f       	rcall	8000b218 <__multiply>
8000b408:	08 9b       	mov	r11,r4
8000b40a:	18 93       	mov	r3,r12
8000b40c:	0e 9c       	mov	r12,r7
8000b40e:	06 94       	mov	r4,r3
8000b410:	fe b0 fd b6 	rcall	8000af7c <_Bfree>
8000b414:	a1 56       	asr	r6,0x1
8000b416:	c0 b0       	breq	8000b42c <__pow5mult+0x88>
8000b418:	6a 03       	ld.w	r3,r5[0x0]
8000b41a:	58 03       	cp.w	r3,0
8000b41c:	ce d1       	brne	8000b3f6 <__pow5mult+0x52>
8000b41e:	0a 9a       	mov	r10,r5
8000b420:	0a 9b       	mov	r11,r5
8000b422:	0e 9c       	mov	r12,r7
8000b424:	cf ae       	rcall	8000b218 <__multiply>
8000b426:	8b 0c       	st.w	r5[0x0],r12
8000b428:	99 03       	st.w	r12[0x0],r3
8000b42a:	ce 7b       	rjmp	8000b3f8 <__pow5mult+0x54>
8000b42c:	08 9c       	mov	r12,r4
8000b42e:	d8 32       	popm	r0-r7,pc

8000b430 <_read_r>:
8000b430:	d4 21       	pushm	r4-r7,lr
8000b432:	16 98       	mov	r8,r11
8000b434:	18 97       	mov	r7,r12
8000b436:	10 9c       	mov	r12,r8
8000b438:	30 08       	mov	r8,0
8000b43a:	14 9b       	mov	r11,r10
8000b43c:	e0 66 08 10 	mov	r6,2064
8000b440:	12 9a       	mov	r10,r9
8000b442:	8d 08       	st.w	r6[0x0],r8
8000b444:	fe b0 ce d6 	rcall	800051f0 <_read>
8000b448:	5b fc       	cp.w	r12,-1
8000b44a:	c0 51       	brne	8000b454 <_read_r+0x24>
8000b44c:	6c 08       	ld.w	r8,r6[0x0]
8000b44e:	58 08       	cp.w	r8,0
8000b450:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b454:	d8 22       	popm	r4-r7,pc
8000b456:	d7 03       	nop

8000b458 <__isinfd>:
8000b458:	14 98       	mov	r8,r10
8000b45a:	fc 19 7f f0 	movh	r9,0x7ff0
8000b45e:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b462:	f0 0b 11 00 	rsub	r11,r8,0
8000b466:	f7 e8 10 08 	or	r8,r11,r8
8000b46a:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b46e:	f2 08 01 08 	sub	r8,r9,r8
8000b472:	f0 0c 11 00 	rsub	r12,r8,0
8000b476:	f9 e8 10 08 	or	r8,r12,r8
8000b47a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b47e:	2f fc       	sub	r12,-1
8000b480:	5e fc       	retal	r12

8000b482 <__isnand>:
8000b482:	14 98       	mov	r8,r10
8000b484:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b488:	f0 0c 11 00 	rsub	r12,r8,0
8000b48c:	10 4c       	or	r12,r8
8000b48e:	fc 18 7f f0 	movh	r8,0x7ff0
8000b492:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b496:	f0 0c 01 0c 	sub	r12,r8,r12
8000b49a:	bf 9c       	lsr	r12,0x1f
8000b49c:	5e fc       	retal	r12

8000b49e <strlen>:
8000b49e:	30 09       	mov	r9,0
8000b4a0:	18 98       	mov	r8,r12
8000b4a2:	c0 28       	rjmp	8000b4a6 <strlen+0x8>
8000b4a4:	2f f8       	sub	r8,-1
8000b4a6:	11 8a       	ld.ub	r10,r8[0x0]
8000b4a8:	f2 0a 18 00 	cp.b	r10,r9
8000b4ac:	cf c1       	brne	8000b4a4 <strlen+0x6>
8000b4ae:	f0 0c 01 0c 	sub	r12,r8,r12
8000b4b2:	5e fc       	retal	r12

8000b4b4 <_calloc_r>:
8000b4b4:	d4 21       	pushm	r4-r7,lr
8000b4b6:	f4 0b 02 4b 	mul	r11,r10,r11
8000b4ba:	fe b0 da 13 	rcall	800068e0 <_malloc_r>
8000b4be:	18 97       	mov	r7,r12
8000b4c0:	c2 30       	breq	8000b506 <_calloc_r+0x52>
8000b4c2:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b4c6:	e0 1a ff fc 	andl	r10,0xfffc
8000b4ca:	20 4a       	sub	r10,4
8000b4cc:	e0 4a 00 24 	cp.w	r10,36
8000b4d0:	e0 8b 00 18 	brhi	8000b500 <_calloc_r+0x4c>
8000b4d4:	18 98       	mov	r8,r12
8000b4d6:	59 3a       	cp.w	r10,19
8000b4d8:	e0 88 00 0f 	brls	8000b4f6 <_calloc_r+0x42>
8000b4dc:	30 09       	mov	r9,0
8000b4de:	10 a9       	st.w	r8++,r9
8000b4e0:	10 a9       	st.w	r8++,r9
8000b4e2:	59 ba       	cp.w	r10,27
8000b4e4:	e0 88 00 09 	brls	8000b4f6 <_calloc_r+0x42>
8000b4e8:	10 a9       	st.w	r8++,r9
8000b4ea:	10 a9       	st.w	r8++,r9
8000b4ec:	e0 4a 00 24 	cp.w	r10,36
8000b4f0:	c0 31       	brne	8000b4f6 <_calloc_r+0x42>
8000b4f2:	10 a9       	st.w	r8++,r9
8000b4f4:	10 a9       	st.w	r8++,r9
8000b4f6:	30 09       	mov	r9,0
8000b4f8:	10 a9       	st.w	r8++,r9
8000b4fa:	91 19       	st.w	r8[0x4],r9
8000b4fc:	91 09       	st.w	r8[0x0],r9
8000b4fe:	c0 48       	rjmp	8000b506 <_calloc_r+0x52>
8000b500:	30 0b       	mov	r11,0
8000b502:	fe b0 dc af 	rcall	80006e60 <memset>
8000b506:	0e 9c       	mov	r12,r7
8000b508:	d8 22       	popm	r4-r7,pc
8000b50a:	d7 03       	nop

8000b50c <_fstat_r>:
8000b50c:	d4 21       	pushm	r4-r7,lr
8000b50e:	16 98       	mov	r8,r11
8000b510:	18 97       	mov	r7,r12
8000b512:	10 9c       	mov	r12,r8
8000b514:	30 08       	mov	r8,0
8000b516:	e0 66 08 10 	mov	r6,2064
8000b51a:	14 9b       	mov	r11,r10
8000b51c:	8d 08       	st.w	r6[0x0],r8
8000b51e:	fe b0 de 5b 	rcall	800071d4 <_fstat>
8000b522:	5b fc       	cp.w	r12,-1
8000b524:	c0 51       	brne	8000b52e <_fstat_r+0x22>
8000b526:	6c 08       	ld.w	r8,r6[0x0]
8000b528:	58 08       	cp.w	r8,0
8000b52a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b52e:	d8 22       	popm	r4-r7,pc

8000b530 <__avr32_f64_mul>:
8000b530:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b534:	e0 80 00 dc 	breq	8000b6ec <__avr32_f64_mul_op1_zero>
8000b538:	d4 21       	pushm	r4-r7,lr
8000b53a:	f7 e9 20 0e 	eor	lr,r11,r9
8000b53e:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b542:	30 15       	mov	r5,1
8000b544:	c4 30       	breq	8000b5ca <__avr32_f64_mul_op1_subnormal>
8000b546:	ab 6b       	lsl	r11,0xa
8000b548:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b54c:	ab 6a       	lsl	r10,0xa
8000b54e:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b552:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b556:	c5 c0       	breq	8000b60e <__avr32_f64_mul_op2_subnormal>
8000b558:	a1 78       	lsl	r8,0x1
8000b55a:	5c f9       	rol	r9
8000b55c:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b560:	e0 47 07 ff 	cp.w	r7,2047
8000b564:	c7 70       	breq	8000b652 <__avr32_f64_mul_op_nan_or_inf>
8000b566:	e0 46 07 ff 	cp.w	r6,2047
8000b56a:	c7 40       	breq	8000b652 <__avr32_f64_mul_op_nan_or_inf>
8000b56c:	ee 06 00 0c 	add	r12,r7,r6
8000b570:	e0 2c 03 fe 	sub	r12,1022
8000b574:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b578:	f4 09 07 44 	macu.d	r4,r10,r9
8000b57c:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b580:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b584:	08 07       	add	r7,r4
8000b586:	f4 05 00 4a 	adc	r10,r10,r5
8000b58a:	5c 0b       	acr	r11
8000b58c:	ed bb 00 14 	bld	r11,0x14
8000b590:	c0 50       	breq	8000b59a <__avr32_f64_mul+0x6a>
8000b592:	a1 77       	lsl	r7,0x1
8000b594:	5c fa       	rol	r10
8000b596:	5c fb       	rol	r11
8000b598:	20 1c       	sub	r12,1
8000b59a:	58 0c       	cp.w	r12,0
8000b59c:	e0 8a 00 6f 	brle	8000b67a <__avr32_f64_mul_res_subnormal>
8000b5a0:	e0 4c 07 ff 	cp.w	r12,2047
8000b5a4:	e0 84 00 9c 	brge	8000b6dc <__avr32_f64_mul_res_inf>
8000b5a8:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b5ac:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b5b0:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b5b4:	ee 17 80 00 	eorh	r7,0x8000
8000b5b8:	f1 b7 04 20 	satu	r7,0x1
8000b5bc:	0e 0a       	add	r10,r7
8000b5be:	5c 0b       	acr	r11
8000b5c0:	ed be 00 1f 	bld	lr,0x1f
8000b5c4:	ef bb 00 1f 	bst	r11,0x1f
8000b5c8:	d8 22       	popm	r4-r7,pc

8000b5ca <__avr32_f64_mul_op1_subnormal>:
8000b5ca:	e4 1b 00 0f 	andh	r11,0xf
8000b5ce:	f4 0c 12 00 	clz	r12,r10
8000b5d2:	f6 06 12 00 	clz	r6,r11
8000b5d6:	f7 bc 03 e1 	sublo	r12,-31
8000b5da:	f8 06 17 30 	movlo	r6,r12
8000b5de:	f7 b6 02 01 	subhs	r6,1
8000b5e2:	e0 46 00 20 	cp.w	r6,32
8000b5e6:	c0 d4       	brge	8000b600 <__avr32_f64_mul_op1_subnormal+0x36>
8000b5e8:	ec 0c 11 20 	rsub	r12,r6,32
8000b5ec:	f6 06 09 4b 	lsl	r11,r11,r6
8000b5f0:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b5f4:	18 4b       	or	r11,r12
8000b5f6:	f4 06 09 4a 	lsl	r10,r10,r6
8000b5fa:	20 b6       	sub	r6,11
8000b5fc:	0c 17       	sub	r7,r6
8000b5fe:	ca ab       	rjmp	8000b552 <__avr32_f64_mul+0x22>
8000b600:	f4 06 09 4b 	lsl	r11,r10,r6
8000b604:	c6 40       	breq	8000b6cc <__avr32_f64_mul_res_zero>
8000b606:	30 0a       	mov	r10,0
8000b608:	20 b6       	sub	r6,11
8000b60a:	0c 17       	sub	r7,r6
8000b60c:	ca 3b       	rjmp	8000b552 <__avr32_f64_mul+0x22>

8000b60e <__avr32_f64_mul_op2_subnormal>:
8000b60e:	e4 19 00 0f 	andh	r9,0xf
8000b612:	f0 0c 12 00 	clz	r12,r8
8000b616:	f2 05 12 00 	clz	r5,r9
8000b61a:	f7 bc 03 ea 	sublo	r12,-22
8000b61e:	f8 05 17 30 	movlo	r5,r12
8000b622:	f7 b5 02 0a 	subhs	r5,10
8000b626:	e0 45 00 20 	cp.w	r5,32
8000b62a:	c0 d4       	brge	8000b644 <__avr32_f64_mul_op2_subnormal+0x36>
8000b62c:	ea 0c 11 20 	rsub	r12,r5,32
8000b630:	f2 05 09 49 	lsl	r9,r9,r5
8000b634:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b638:	18 49       	or	r9,r12
8000b63a:	f0 05 09 48 	lsl	r8,r8,r5
8000b63e:	20 25       	sub	r5,2
8000b640:	0a 16       	sub	r6,r5
8000b642:	c8 fb       	rjmp	8000b560 <__avr32_f64_mul+0x30>
8000b644:	f0 05 09 49 	lsl	r9,r8,r5
8000b648:	c4 20       	breq	8000b6cc <__avr32_f64_mul_res_zero>
8000b64a:	30 08       	mov	r8,0
8000b64c:	20 25       	sub	r5,2
8000b64e:	0a 16       	sub	r6,r5
8000b650:	c8 8b       	rjmp	8000b560 <__avr32_f64_mul+0x30>

8000b652 <__avr32_f64_mul_op_nan_or_inf>:
8000b652:	e4 19 00 0f 	andh	r9,0xf
8000b656:	e4 1b 00 0f 	andh	r11,0xf
8000b65a:	14 4b       	or	r11,r10
8000b65c:	10 49       	or	r9,r8
8000b65e:	e0 47 07 ff 	cp.w	r7,2047
8000b662:	c0 91       	brne	8000b674 <__avr32_f64_mul_op1_not_naninf>
8000b664:	58 0b       	cp.w	r11,0
8000b666:	c3 81       	brne	8000b6d6 <__avr32_f64_mul_res_nan>
8000b668:	e0 46 07 ff 	cp.w	r6,2047
8000b66c:	c3 81       	brne	8000b6dc <__avr32_f64_mul_res_inf>
8000b66e:	58 09       	cp.w	r9,0
8000b670:	c3 60       	breq	8000b6dc <__avr32_f64_mul_res_inf>
8000b672:	c3 28       	rjmp	8000b6d6 <__avr32_f64_mul_res_nan>

8000b674 <__avr32_f64_mul_op1_not_naninf>:
8000b674:	58 09       	cp.w	r9,0
8000b676:	c3 30       	breq	8000b6dc <__avr32_f64_mul_res_inf>
8000b678:	c2 f8       	rjmp	8000b6d6 <__avr32_f64_mul_res_nan>

8000b67a <__avr32_f64_mul_res_subnormal>:
8000b67a:	5c 3c       	neg	r12
8000b67c:	2f fc       	sub	r12,-1
8000b67e:	f1 bc 04 c0 	satu	r12,0x6
8000b682:	e0 4c 00 20 	cp.w	r12,32
8000b686:	c1 14       	brge	8000b6a8 <__avr32_f64_mul_res_subnormal+0x2e>
8000b688:	f8 08 11 20 	rsub	r8,r12,32
8000b68c:	0e 46       	or	r6,r7
8000b68e:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b692:	f4 08 09 49 	lsl	r9,r10,r8
8000b696:	12 47       	or	r7,r9
8000b698:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b69c:	f6 08 09 49 	lsl	r9,r11,r8
8000b6a0:	12 4a       	or	r10,r9
8000b6a2:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b6a6:	c8 3b       	rjmp	8000b5ac <__avr32_f64_mul+0x7c>
8000b6a8:	f8 08 11 20 	rsub	r8,r12,32
8000b6ac:	f9 b9 00 00 	moveq	r9,0
8000b6b0:	c0 30       	breq	8000b6b6 <__avr32_f64_mul_res_subnormal+0x3c>
8000b6b2:	f6 08 09 49 	lsl	r9,r11,r8
8000b6b6:	0e 46       	or	r6,r7
8000b6b8:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b6bc:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b6c0:	f3 ea 10 07 	or	r7,r9,r10
8000b6c4:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b6c8:	30 0b       	mov	r11,0
8000b6ca:	c7 1b       	rjmp	8000b5ac <__avr32_f64_mul+0x7c>

8000b6cc <__avr32_f64_mul_res_zero>:
8000b6cc:	1c 9b       	mov	r11,lr
8000b6ce:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b6d2:	30 0a       	mov	r10,0
8000b6d4:	d8 22       	popm	r4-r7,pc

8000b6d6 <__avr32_f64_mul_res_nan>:
8000b6d6:	3f fb       	mov	r11,-1
8000b6d8:	3f fa       	mov	r10,-1
8000b6da:	d8 22       	popm	r4-r7,pc

8000b6dc <__avr32_f64_mul_res_inf>:
8000b6dc:	f0 6b 00 00 	mov	r11,-1048576
8000b6e0:	ed be 00 1f 	bld	lr,0x1f
8000b6e4:	ef bb 00 1f 	bst	r11,0x1f
8000b6e8:	30 0a       	mov	r10,0
8000b6ea:	d8 22       	popm	r4-r7,pc

8000b6ec <__avr32_f64_mul_op1_zero>:
8000b6ec:	f7 e9 20 0b 	eor	r11,r11,r9
8000b6f0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b6f4:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b6f8:	e0 4c 07 ff 	cp.w	r12,2047
8000b6fc:	5e 1c       	retne	r12
8000b6fe:	3f fa       	mov	r10,-1
8000b700:	3f fb       	mov	r11,-1
8000b702:	5e fc       	retal	r12

8000b704 <__avr32_f64_sub_from_add>:
8000b704:	ee 19 80 00 	eorh	r9,0x8000

8000b708 <__avr32_f64_sub>:
8000b708:	f7 e9 20 0c 	eor	r12,r11,r9
8000b70c:	e0 86 00 ca 	brmi	8000b8a0 <__avr32_f64_add_from_sub>
8000b710:	eb cd 40 e0 	pushm	r5-r7,lr
8000b714:	16 9c       	mov	r12,r11
8000b716:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b71a:	bf db       	cbr	r11,0x1f
8000b71c:	bf d9       	cbr	r9,0x1f
8000b71e:	10 3a       	cp.w	r10,r8
8000b720:	f2 0b 13 00 	cpc	r11,r9
8000b724:	c0 92       	brcc	8000b736 <__avr32_f64_sub+0x2e>
8000b726:	16 97       	mov	r7,r11
8000b728:	12 9b       	mov	r11,r9
8000b72a:	0e 99       	mov	r9,r7
8000b72c:	14 97       	mov	r7,r10
8000b72e:	10 9a       	mov	r10,r8
8000b730:	0e 98       	mov	r8,r7
8000b732:	ee 1c 80 00 	eorh	r12,0x8000
8000b736:	f6 07 16 14 	lsr	r7,r11,0x14
8000b73a:	ab 7b       	lsl	r11,0xb
8000b73c:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b740:	ab 7a       	lsl	r10,0xb
8000b742:	bf bb       	sbr	r11,0x1f
8000b744:	f2 06 16 14 	lsr	r6,r9,0x14
8000b748:	c4 40       	breq	8000b7d0 <__avr32_f64_sub_opL_subnormal>
8000b74a:	ab 79       	lsl	r9,0xb
8000b74c:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b750:	ab 78       	lsl	r8,0xb
8000b752:	bf b9       	sbr	r9,0x1f

8000b754 <__avr32_f64_sub_opL_subnormal_done>:
8000b754:	e0 47 07 ff 	cp.w	r7,2047
8000b758:	c4 f0       	breq	8000b7f6 <__avr32_f64_sub_opH_nan_or_inf>
8000b75a:	0e 26       	rsub	r6,r7
8000b75c:	c1 20       	breq	8000b780 <__avr32_f64_sub_shift_done>
8000b75e:	ec 05 11 20 	rsub	r5,r6,32
8000b762:	e0 46 00 20 	cp.w	r6,32
8000b766:	c7 c2       	brcc	8000b85e <__avr32_f64_sub_longshift>
8000b768:	f0 05 09 4e 	lsl	lr,r8,r5
8000b76c:	f2 05 09 45 	lsl	r5,r9,r5
8000b770:	f0 06 0a 48 	lsr	r8,r8,r6
8000b774:	f2 06 0a 49 	lsr	r9,r9,r6
8000b778:	0a 48       	or	r8,r5
8000b77a:	58 0e       	cp.w	lr,0
8000b77c:	5f 1e       	srne	lr
8000b77e:	1c 48       	or	r8,lr

8000b780 <__avr32_f64_sub_shift_done>:
8000b780:	10 1a       	sub	r10,r8
8000b782:	f6 09 01 4b 	sbc	r11,r11,r9
8000b786:	f6 06 12 00 	clz	r6,r11
8000b78a:	c0 e0       	breq	8000b7a6 <__avr32_f64_sub_longnormalize_done>
8000b78c:	c7 83       	brcs	8000b87c <__avr32_f64_sub_longnormalize>
8000b78e:	ec 0e 11 20 	rsub	lr,r6,32
8000b792:	f6 06 09 4b 	lsl	r11,r11,r6
8000b796:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b79a:	1c 4b       	or	r11,lr
8000b79c:	f4 06 09 4a 	lsl	r10,r10,r6
8000b7a0:	0c 17       	sub	r7,r6
8000b7a2:	e0 8a 00 39 	brle	8000b814 <__avr32_f64_sub_subnormal_result>

8000b7a6 <__avr32_f64_sub_longnormalize_done>:
8000b7a6:	f4 09 15 15 	lsl	r9,r10,0x15
8000b7aa:	ab 9a       	lsr	r10,0xb
8000b7ac:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b7b0:	ab 9b       	lsr	r11,0xb
8000b7b2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b7b6:	18 4b       	or	r11,r12

8000b7b8 <__avr32_f64_sub_round>:
8000b7b8:	fc 17 80 00 	movh	r7,0x8000
8000b7bc:	ed ba 00 00 	bld	r10,0x0
8000b7c0:	f7 b7 01 ff 	subne	r7,-1
8000b7c4:	0e 39       	cp.w	r9,r7
8000b7c6:	5f 29       	srhs	r9
8000b7c8:	12 0a       	add	r10,r9
8000b7ca:	5c 0b       	acr	r11
8000b7cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b7d0 <__avr32_f64_sub_opL_subnormal>:
8000b7d0:	ab 79       	lsl	r9,0xb
8000b7d2:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b7d6:	ab 78       	lsl	r8,0xb
8000b7d8:	f3 e8 10 0e 	or	lr,r9,r8
8000b7dc:	f9 b6 01 01 	movne	r6,1
8000b7e0:	ee 0e 11 00 	rsub	lr,r7,0
8000b7e4:	f9 b7 00 01 	moveq	r7,1
8000b7e8:	ef bb 00 1f 	bst	r11,0x1f
8000b7ec:	f7 ea 10 0e 	or	lr,r11,r10
8000b7f0:	f9 b7 00 00 	moveq	r7,0
8000b7f4:	cb 0b       	rjmp	8000b754 <__avr32_f64_sub_opL_subnormal_done>

8000b7f6 <__avr32_f64_sub_opH_nan_or_inf>:
8000b7f6:	bf db       	cbr	r11,0x1f
8000b7f8:	f7 ea 10 0e 	or	lr,r11,r10
8000b7fc:	c0 81       	brne	8000b80c <__avr32_f64_sub_return_nan>
8000b7fe:	e0 46 07 ff 	cp.w	r6,2047
8000b802:	c0 50       	breq	8000b80c <__avr32_f64_sub_return_nan>
8000b804:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b808:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b80c <__avr32_f64_sub_return_nan>:
8000b80c:	3f fa       	mov	r10,-1
8000b80e:	3f fb       	mov	r11,-1
8000b810:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b814 <__avr32_f64_sub_subnormal_result>:
8000b814:	5c 37       	neg	r7
8000b816:	2f f7       	sub	r7,-1
8000b818:	f1 b7 04 c0 	satu	r7,0x6
8000b81c:	e0 47 00 20 	cp.w	r7,32
8000b820:	c1 14       	brge	8000b842 <__avr32_f64_sub_subnormal_result+0x2e>
8000b822:	ee 08 11 20 	rsub	r8,r7,32
8000b826:	f4 08 09 49 	lsl	r9,r10,r8
8000b82a:	5f 16       	srne	r6
8000b82c:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b830:	0c 4a       	or	r10,r6
8000b832:	f6 08 09 49 	lsl	r9,r11,r8
8000b836:	f5 e9 10 0a 	or	r10,r10,r9
8000b83a:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b83e:	30 07       	mov	r7,0
8000b840:	cb 3b       	rjmp	8000b7a6 <__avr32_f64_sub_longnormalize_done>
8000b842:	ee 08 11 40 	rsub	r8,r7,64
8000b846:	f6 08 09 49 	lsl	r9,r11,r8
8000b84a:	14 49       	or	r9,r10
8000b84c:	5f 16       	srne	r6
8000b84e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b852:	0c 4a       	or	r10,r6
8000b854:	30 0b       	mov	r11,0
8000b856:	30 07       	mov	r7,0
8000b858:	ca 7b       	rjmp	8000b7a6 <__avr32_f64_sub_longnormalize_done>
8000b85a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b85e <__avr32_f64_sub_longshift>:
8000b85e:	f1 b6 04 c0 	satu	r6,0x6
8000b862:	f0 0e 17 00 	moveq	lr,r8
8000b866:	c0 40       	breq	8000b86e <__avr32_f64_sub_longshift+0x10>
8000b868:	f2 05 09 4e 	lsl	lr,r9,r5
8000b86c:	10 4e       	or	lr,r8
8000b86e:	f2 06 0a 48 	lsr	r8,r9,r6
8000b872:	30 09       	mov	r9,0
8000b874:	58 0e       	cp.w	lr,0
8000b876:	5f 1e       	srne	lr
8000b878:	1c 48       	or	r8,lr
8000b87a:	c8 3b       	rjmp	8000b780 <__avr32_f64_sub_shift_done>

8000b87c <__avr32_f64_sub_longnormalize>:
8000b87c:	f4 06 12 00 	clz	r6,r10
8000b880:	f9 b7 03 00 	movlo	r7,0
8000b884:	f9 b6 03 00 	movlo	r6,0
8000b888:	f9 bc 03 00 	movlo	r12,0
8000b88c:	f7 b6 02 e0 	subhs	r6,-32
8000b890:	f4 06 09 4b 	lsl	r11,r10,r6
8000b894:	30 0a       	mov	r10,0
8000b896:	0c 17       	sub	r7,r6
8000b898:	fe 9a ff be 	brle	8000b814 <__avr32_f64_sub_subnormal_result>
8000b89c:	c8 5b       	rjmp	8000b7a6 <__avr32_f64_sub_longnormalize_done>
8000b89e:	d7 03       	nop

8000b8a0 <__avr32_f64_add_from_sub>:
8000b8a0:	ee 19 80 00 	eorh	r9,0x8000

8000b8a4 <__avr32_f64_add>:
8000b8a4:	f7 e9 20 0c 	eor	r12,r11,r9
8000b8a8:	fe 96 ff 2e 	brmi	8000b704 <__avr32_f64_sub_from_add>
8000b8ac:	eb cd 40 e0 	pushm	r5-r7,lr
8000b8b0:	16 9c       	mov	r12,r11
8000b8b2:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b8b6:	bf db       	cbr	r11,0x1f
8000b8b8:	bf d9       	cbr	r9,0x1f
8000b8ba:	12 3b       	cp.w	r11,r9
8000b8bc:	c0 72       	brcc	8000b8ca <__avr32_f64_add+0x26>
8000b8be:	16 97       	mov	r7,r11
8000b8c0:	12 9b       	mov	r11,r9
8000b8c2:	0e 99       	mov	r9,r7
8000b8c4:	14 97       	mov	r7,r10
8000b8c6:	10 9a       	mov	r10,r8
8000b8c8:	0e 98       	mov	r8,r7
8000b8ca:	30 0e       	mov	lr,0
8000b8cc:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b8d0:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b8d4:	b5 ab       	sbr	r11,0x14
8000b8d6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b8da:	c6 20       	breq	8000b99e <__avr32_f64_add_op2_subnormal>
8000b8dc:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b8e0:	b5 a9       	sbr	r9,0x14
8000b8e2:	e0 47 07 ff 	cp.w	r7,2047
8000b8e6:	c2 80       	breq	8000b936 <__avr32_f64_add_opH_nan_or_inf>
8000b8e8:	0e 26       	rsub	r6,r7
8000b8ea:	c1 20       	breq	8000b90e <__avr32_f64_add_shift_done>
8000b8ec:	e0 46 00 36 	cp.w	r6,54
8000b8f0:	c1 52       	brcc	8000b91a <__avr32_f64_add_res_of_done>
8000b8f2:	ec 05 11 20 	rsub	r5,r6,32
8000b8f6:	e0 46 00 20 	cp.w	r6,32
8000b8fa:	c3 52       	brcc	8000b964 <__avr32_f64_add_longshift>
8000b8fc:	f0 05 09 4e 	lsl	lr,r8,r5
8000b900:	f2 05 09 45 	lsl	r5,r9,r5
8000b904:	f0 06 0a 48 	lsr	r8,r8,r6
8000b908:	f2 06 0a 49 	lsr	r9,r9,r6
8000b90c:	0a 48       	or	r8,r5

8000b90e <__avr32_f64_add_shift_done>:
8000b90e:	10 0a       	add	r10,r8
8000b910:	f6 09 00 4b 	adc	r11,r11,r9
8000b914:	ed bb 00 15 	bld	r11,0x15
8000b918:	c3 40       	breq	8000b980 <__avr32_f64_add_res_of>

8000b91a <__avr32_f64_add_res_of_done>:
8000b91a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b91e:	18 4b       	or	r11,r12

8000b920 <__avr32_f64_add_round>:
8000b920:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b924:	18 4e       	or	lr,r12
8000b926:	ee 1e 80 00 	eorh	lr,0x8000
8000b92a:	f1 be 04 20 	satu	lr,0x1
8000b92e:	1c 0a       	add	r10,lr
8000b930:	5c 0b       	acr	r11
8000b932:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b936 <__avr32_f64_add_opH_nan_or_inf>:
8000b936:	b5 cb       	cbr	r11,0x14
8000b938:	f7 ea 10 0e 	or	lr,r11,r10
8000b93c:	c1 01       	brne	8000b95c <__avr32_f64_add_return_nan>
8000b93e:	e0 46 07 ff 	cp.w	r6,2047
8000b942:	c0 30       	breq	8000b948 <__avr32_f64_add_opL_nan_or_inf>
8000b944:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b948 <__avr32_f64_add_opL_nan_or_inf>:
8000b948:	b5 c9       	cbr	r9,0x14
8000b94a:	f3 e8 10 0e 	or	lr,r9,r8
8000b94e:	c0 71       	brne	8000b95c <__avr32_f64_add_return_nan>
8000b950:	30 0a       	mov	r10,0
8000b952:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b956:	18 4b       	or	r11,r12
8000b958:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b95c <__avr32_f64_add_return_nan>:
8000b95c:	3f fa       	mov	r10,-1
8000b95e:	3f fb       	mov	r11,-1
8000b960:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b964 <__avr32_f64_add_longshift>:
8000b964:	f1 b6 04 c0 	satu	r6,0x6
8000b968:	f0 0e 17 00 	moveq	lr,r8
8000b96c:	c0 60       	breq	8000b978 <__avr32_f64_add_longshift+0x14>
8000b96e:	f2 05 09 4e 	lsl	lr,r9,r5
8000b972:	58 08       	cp.w	r8,0
8000b974:	5f 18       	srne	r8
8000b976:	10 4e       	or	lr,r8
8000b978:	f2 06 0a 48 	lsr	r8,r9,r6
8000b97c:	30 09       	mov	r9,0
8000b97e:	cc 8b       	rjmp	8000b90e <__avr32_f64_add_shift_done>

8000b980 <__avr32_f64_add_res_of>:
8000b980:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b984:	a1 9b       	lsr	r11,0x1
8000b986:	5d 0a       	ror	r10
8000b988:	5d 0e       	ror	lr
8000b98a:	2f f7       	sub	r7,-1
8000b98c:	e0 47 07 ff 	cp.w	r7,2047
8000b990:	f9 ba 00 00 	moveq	r10,0
8000b994:	f9 bb 00 00 	moveq	r11,0
8000b998:	f9 be 00 00 	moveq	lr,0
8000b99c:	cb fb       	rjmp	8000b91a <__avr32_f64_add_res_of_done>

8000b99e <__avr32_f64_add_op2_subnormal>:
8000b99e:	30 16       	mov	r6,1
8000b9a0:	58 07       	cp.w	r7,0
8000b9a2:	ca 01       	brne	8000b8e2 <__avr32_f64_add+0x3e>
8000b9a4:	b5 cb       	cbr	r11,0x14
8000b9a6:	10 0a       	add	r10,r8
8000b9a8:	f6 09 00 4b 	adc	r11,r11,r9
8000b9ac:	18 4b       	or	r11,r12
8000b9ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b9b2:	d7 03       	nop

8000b9b4 <__avr32_f64_to_u32>:
8000b9b4:	58 0b       	cp.w	r11,0
8000b9b6:	5e 6d       	retmi	0

8000b9b8 <__avr32_f64_to_s32>:
8000b9b8:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b9bc:	b5 9c       	lsr	r12,0x15
8000b9be:	e0 2c 03 ff 	sub	r12,1023
8000b9c2:	5e 3d       	retlo	0
8000b9c4:	f8 0c 11 1f 	rsub	r12,r12,31
8000b9c8:	16 99       	mov	r9,r11
8000b9ca:	ab 7b       	lsl	r11,0xb
8000b9cc:	bf bb       	sbr	r11,0x1f
8000b9ce:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b9d2:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b9d6:	a1 79       	lsl	r9,0x1
8000b9d8:	5e 2b       	reths	r11
8000b9da:	5c 3b       	neg	r11
8000b9dc:	5e fb       	retal	r11

8000b9de <__avr32_u32_to_f64>:
8000b9de:	f8 cb 00 00 	sub	r11,r12,0
8000b9e2:	30 0c       	mov	r12,0
8000b9e4:	c0 38       	rjmp	8000b9ea <__avr32_s32_to_f64+0x4>

8000b9e6 <__avr32_s32_to_f64>:
8000b9e6:	18 9b       	mov	r11,r12
8000b9e8:	5c 4b       	abs	r11
8000b9ea:	30 0a       	mov	r10,0
8000b9ec:	5e 0b       	reteq	r11
8000b9ee:	d4 01       	pushm	lr
8000b9f0:	e0 69 04 1e 	mov	r9,1054
8000b9f4:	f6 08 12 00 	clz	r8,r11
8000b9f8:	c1 70       	breq	8000ba26 <__avr32_s32_to_f64+0x40>
8000b9fa:	c0 c3       	brcs	8000ba12 <__avr32_s32_to_f64+0x2c>
8000b9fc:	f0 0e 11 20 	rsub	lr,r8,32
8000ba00:	f6 08 09 4b 	lsl	r11,r11,r8
8000ba04:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000ba08:	1c 4b       	or	r11,lr
8000ba0a:	f4 08 09 4a 	lsl	r10,r10,r8
8000ba0e:	10 19       	sub	r9,r8
8000ba10:	c0 b8       	rjmp	8000ba26 <__avr32_s32_to_f64+0x40>
8000ba12:	f4 08 12 00 	clz	r8,r10
8000ba16:	f9 b8 03 00 	movlo	r8,0
8000ba1a:	f7 b8 02 e0 	subhs	r8,-32
8000ba1e:	f4 08 09 4b 	lsl	r11,r10,r8
8000ba22:	30 0a       	mov	r10,0
8000ba24:	10 19       	sub	r9,r8
8000ba26:	58 09       	cp.w	r9,0
8000ba28:	e0 89 00 30 	brgt	8000ba88 <__avr32_s32_to_f64+0xa2>
8000ba2c:	5c 39       	neg	r9
8000ba2e:	2f f9       	sub	r9,-1
8000ba30:	e0 49 00 36 	cp.w	r9,54
8000ba34:	c0 43       	brcs	8000ba3c <__avr32_s32_to_f64+0x56>
8000ba36:	30 0b       	mov	r11,0
8000ba38:	30 0a       	mov	r10,0
8000ba3a:	c2 68       	rjmp	8000ba86 <__avr32_s32_to_f64+0xa0>
8000ba3c:	2f 69       	sub	r9,-10
8000ba3e:	f2 08 11 20 	rsub	r8,r9,32
8000ba42:	e0 49 00 20 	cp.w	r9,32
8000ba46:	c0 b2       	brcc	8000ba5c <__avr32_s32_to_f64+0x76>
8000ba48:	f4 08 09 4e 	lsl	lr,r10,r8
8000ba4c:	f6 08 09 48 	lsl	r8,r11,r8
8000ba50:	f4 09 0a 4a 	lsr	r10,r10,r9
8000ba54:	f6 09 0a 4b 	lsr	r11,r11,r9
8000ba58:	10 4b       	or	r11,r8
8000ba5a:	c0 88       	rjmp	8000ba6a <__avr32_s32_to_f64+0x84>
8000ba5c:	f6 08 09 4e 	lsl	lr,r11,r8
8000ba60:	14 4e       	or	lr,r10
8000ba62:	16 9a       	mov	r10,r11
8000ba64:	30 0b       	mov	r11,0
8000ba66:	f4 09 0a 4a 	lsr	r10,r10,r9
8000ba6a:	ed ba 00 00 	bld	r10,0x0
8000ba6e:	c0 92       	brcc	8000ba80 <__avr32_s32_to_f64+0x9a>
8000ba70:	1c 7e       	tst	lr,lr
8000ba72:	c0 41       	brne	8000ba7a <__avr32_s32_to_f64+0x94>
8000ba74:	ed ba 00 01 	bld	r10,0x1
8000ba78:	c0 42       	brcc	8000ba80 <__avr32_s32_to_f64+0x9a>
8000ba7a:	2f fa       	sub	r10,-1
8000ba7c:	f7 bb 02 ff 	subhs	r11,-1
8000ba80:	5c fc       	rol	r12
8000ba82:	5d 0b       	ror	r11
8000ba84:	5d 0a       	ror	r10
8000ba86:	d8 02       	popm	pc
8000ba88:	e0 68 03 ff 	mov	r8,1023
8000ba8c:	ed ba 00 0b 	bld	r10,0xb
8000ba90:	f7 b8 00 ff 	subeq	r8,-1
8000ba94:	10 0a       	add	r10,r8
8000ba96:	5c 0b       	acr	r11
8000ba98:	f7 b9 03 fe 	sublo	r9,-2
8000ba9c:	e0 49 07 ff 	cp.w	r9,2047
8000baa0:	c0 55       	brlt	8000baaa <__avr32_s32_to_f64+0xc4>
8000baa2:	30 0a       	mov	r10,0
8000baa4:	fc 1b ff e0 	movh	r11,0xffe0
8000baa8:	c0 c8       	rjmp	8000bac0 <__floatsidf_return_op1>
8000baaa:	ed bb 00 1f 	bld	r11,0x1f
8000baae:	f7 b9 01 01 	subne	r9,1
8000bab2:	ab 9a       	lsr	r10,0xb
8000bab4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bab8:	a1 7b       	lsl	r11,0x1
8000baba:	ab 9b       	lsr	r11,0xb
8000babc:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000bac0 <__floatsidf_return_op1>:
8000bac0:	a1 7c       	lsl	r12,0x1
8000bac2:	5d 0b       	ror	r11
8000bac4:	d8 02       	popm	pc

8000bac6 <__avr32_f64_cmp_eq>:
8000bac6:	10 3a       	cp.w	r10,r8
8000bac8:	f2 0b 13 00 	cpc	r11,r9
8000bacc:	c0 80       	breq	8000badc <__avr32_f64_cmp_eq+0x16>
8000bace:	a1 7b       	lsl	r11,0x1
8000bad0:	a1 79       	lsl	r9,0x1
8000bad2:	14 4b       	or	r11,r10
8000bad4:	12 4b       	or	r11,r9
8000bad6:	10 4b       	or	r11,r8
8000bad8:	5e 0f       	reteq	1
8000bada:	5e fd       	retal	0
8000badc:	a1 7b       	lsl	r11,0x1
8000bade:	fc 1c ff e0 	movh	r12,0xffe0
8000bae2:	58 0a       	cp.w	r10,0
8000bae4:	f8 0b 13 00 	cpc	r11,r12
8000bae8:	5e 8f       	retls	1
8000baea:	5e fd       	retal	0

8000baec <__avr32_f64_cmp_ge>:
8000baec:	1a de       	st.w	--sp,lr
8000baee:	1a d7       	st.w	--sp,r7
8000baf0:	a1 7b       	lsl	r11,0x1
8000baf2:	5f 3c       	srlo	r12
8000baf4:	a1 79       	lsl	r9,0x1
8000baf6:	5f 37       	srlo	r7
8000baf8:	5c fc       	rol	r12
8000bafa:	fc 1e ff e0 	movh	lr,0xffe0
8000bafe:	58 0a       	cp.w	r10,0
8000bb00:	fc 0b 13 00 	cpc	r11,lr
8000bb04:	e0 8b 00 1d 	brhi	8000bb3e <__avr32_f64_cmp_ge+0x52>
8000bb08:	58 08       	cp.w	r8,0
8000bb0a:	fc 09 13 00 	cpc	r9,lr
8000bb0e:	e0 8b 00 18 	brhi	8000bb3e <__avr32_f64_cmp_ge+0x52>
8000bb12:	58 0b       	cp.w	r11,0
8000bb14:	f5 ba 00 00 	subfeq	r10,0
8000bb18:	c1 50       	breq	8000bb42 <__avr32_f64_cmp_ge+0x56>
8000bb1a:	1b 07       	ld.w	r7,sp++
8000bb1c:	1b 0e       	ld.w	lr,sp++
8000bb1e:	58 3c       	cp.w	r12,3
8000bb20:	c0 a0       	breq	8000bb34 <__avr32_f64_cmp_ge+0x48>
8000bb22:	58 1c       	cp.w	r12,1
8000bb24:	c0 33       	brcs	8000bb2a <__avr32_f64_cmp_ge+0x3e>
8000bb26:	5e 0f       	reteq	1
8000bb28:	5e 1d       	retne	0
8000bb2a:	10 3a       	cp.w	r10,r8
8000bb2c:	f2 0b 13 00 	cpc	r11,r9
8000bb30:	5e 2f       	reths	1
8000bb32:	5e 3d       	retlo	0
8000bb34:	14 38       	cp.w	r8,r10
8000bb36:	f6 09 13 00 	cpc	r9,r11
8000bb3a:	5e 2f       	reths	1
8000bb3c:	5e 3d       	retlo	0
8000bb3e:	1b 07       	ld.w	r7,sp++
8000bb40:	d8 0a       	popm	pc,r12=0
8000bb42:	58 17       	cp.w	r7,1
8000bb44:	5f 0c       	sreq	r12
8000bb46:	58 09       	cp.w	r9,0
8000bb48:	f5 b8 00 00 	subfeq	r8,0
8000bb4c:	1b 07       	ld.w	r7,sp++
8000bb4e:	1b 0e       	ld.w	lr,sp++
8000bb50:	5e 0f       	reteq	1
8000bb52:	5e fc       	retal	r12

8000bb54 <__avr32_f64_cmp_lt>:
8000bb54:	1a de       	st.w	--sp,lr
8000bb56:	1a d7       	st.w	--sp,r7
8000bb58:	a1 7b       	lsl	r11,0x1
8000bb5a:	5f 3c       	srlo	r12
8000bb5c:	a1 79       	lsl	r9,0x1
8000bb5e:	5f 37       	srlo	r7
8000bb60:	5c fc       	rol	r12
8000bb62:	fc 1e ff e0 	movh	lr,0xffe0
8000bb66:	58 0a       	cp.w	r10,0
8000bb68:	fc 0b 13 00 	cpc	r11,lr
8000bb6c:	e0 8b 00 1d 	brhi	8000bba6 <__avr32_f64_cmp_lt+0x52>
8000bb70:	58 08       	cp.w	r8,0
8000bb72:	fc 09 13 00 	cpc	r9,lr
8000bb76:	e0 8b 00 18 	brhi	8000bba6 <__avr32_f64_cmp_lt+0x52>
8000bb7a:	58 0b       	cp.w	r11,0
8000bb7c:	f5 ba 00 00 	subfeq	r10,0
8000bb80:	c1 50       	breq	8000bbaa <__avr32_f64_cmp_lt+0x56>
8000bb82:	1b 07       	ld.w	r7,sp++
8000bb84:	1b 0e       	ld.w	lr,sp++
8000bb86:	58 3c       	cp.w	r12,3
8000bb88:	c0 a0       	breq	8000bb9c <__avr32_f64_cmp_lt+0x48>
8000bb8a:	58 1c       	cp.w	r12,1
8000bb8c:	c0 33       	brcs	8000bb92 <__avr32_f64_cmp_lt+0x3e>
8000bb8e:	5e 0d       	reteq	0
8000bb90:	5e 1f       	retne	1
8000bb92:	10 3a       	cp.w	r10,r8
8000bb94:	f2 0b 13 00 	cpc	r11,r9
8000bb98:	5e 2d       	reths	0
8000bb9a:	5e 3f       	retlo	1
8000bb9c:	14 38       	cp.w	r8,r10
8000bb9e:	f6 09 13 00 	cpc	r9,r11
8000bba2:	5e 2d       	reths	0
8000bba4:	5e 3f       	retlo	1
8000bba6:	1b 07       	ld.w	r7,sp++
8000bba8:	d8 0a       	popm	pc,r12=0
8000bbaa:	58 17       	cp.w	r7,1
8000bbac:	5f 1c       	srne	r12
8000bbae:	58 09       	cp.w	r9,0
8000bbb0:	f5 b8 00 00 	subfeq	r8,0
8000bbb4:	1b 07       	ld.w	r7,sp++
8000bbb6:	1b 0e       	ld.w	lr,sp++
8000bbb8:	5e 0d       	reteq	0
8000bbba:	5e fc       	retal	r12

8000bbbc <__avr32_f64_div>:
8000bbbc:	eb cd 40 ff 	pushm	r0-r7,lr
8000bbc0:	f7 e9 20 0e 	eor	lr,r11,r9
8000bbc4:	f6 07 16 14 	lsr	r7,r11,0x14
8000bbc8:	a9 7b       	lsl	r11,0x9
8000bbca:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000bbce:	a9 7a       	lsl	r10,0x9
8000bbd0:	bd bb       	sbr	r11,0x1d
8000bbd2:	e4 1b 3f ff 	andh	r11,0x3fff
8000bbd6:	ab d7       	cbr	r7,0xb
8000bbd8:	e0 80 00 cc 	breq	8000bd70 <__avr32_f64_div_round_subnormal+0x54>
8000bbdc:	e0 47 07 ff 	cp.w	r7,2047
8000bbe0:	e0 84 00 b5 	brge	8000bd4a <__avr32_f64_div_round_subnormal+0x2e>
8000bbe4:	f2 06 16 14 	lsr	r6,r9,0x14
8000bbe8:	a9 79       	lsl	r9,0x9
8000bbea:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000bbee:	a9 78       	lsl	r8,0x9
8000bbf0:	bd b9       	sbr	r9,0x1d
8000bbf2:	e4 19 3f ff 	andh	r9,0x3fff
8000bbf6:	ab d6       	cbr	r6,0xb
8000bbf8:	e0 80 00 e2 	breq	8000bdbc <__avr32_f64_div_round_subnormal+0xa0>
8000bbfc:	e0 46 07 ff 	cp.w	r6,2047
8000bc00:	e0 84 00 b2 	brge	8000bd64 <__avr32_f64_div_round_subnormal+0x48>
8000bc04:	0c 17       	sub	r7,r6
8000bc06:	fe 37 fc 01 	sub	r7,-1023
8000bc0a:	fc 1c 80 00 	movh	r12,0x8000
8000bc0e:	f8 03 16 01 	lsr	r3,r12,0x1
8000bc12:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000bc16:	5c d4       	com	r4
8000bc18:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000bc1c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bc20:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bc24:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bc28:	ea 03 15 02 	lsl	r3,r5,0x2
8000bc2c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bc30:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bc34:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bc38:	ea 03 15 02 	lsl	r3,r5,0x2
8000bc3c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bc40:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bc44:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bc48:	ea 03 15 02 	lsl	r3,r5,0x2
8000bc4c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bc50:	e4 09 07 40 	macu.d	r0,r2,r9
8000bc54:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bc58:	02 04       	add	r4,r1
8000bc5a:	5c 05       	acr	r5
8000bc5c:	a3 65       	lsl	r5,0x2
8000bc5e:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bc62:	a3 64       	lsl	r4,0x2
8000bc64:	5c 34       	neg	r4
8000bc66:	f8 05 01 45 	sbc	r5,r12,r5
8000bc6a:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bc6e:	e4 05 07 40 	macu.d	r0,r2,r5
8000bc72:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bc76:	02 04       	add	r4,r1
8000bc78:	5c 05       	acr	r5
8000bc7a:	ea 03 15 02 	lsl	r3,r5,0x2
8000bc7e:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bc82:	e8 02 15 02 	lsl	r2,r4,0x2
8000bc86:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bc8a:	e4 09 07 40 	macu.d	r0,r2,r9
8000bc8e:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bc92:	02 04       	add	r4,r1
8000bc94:	5c 05       	acr	r5
8000bc96:	a3 65       	lsl	r5,0x2
8000bc98:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bc9c:	a3 64       	lsl	r4,0x2
8000bc9e:	5c 34       	neg	r4
8000bca0:	f8 05 01 45 	sbc	r5,r12,r5
8000bca4:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bca8:	e4 05 07 40 	macu.d	r0,r2,r5
8000bcac:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bcb0:	02 04       	add	r4,r1
8000bcb2:	5c 05       	acr	r5
8000bcb4:	ea 03 15 02 	lsl	r3,r5,0x2
8000bcb8:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bcbc:	e8 02 15 02 	lsl	r2,r4,0x2
8000bcc0:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000bcc4:	e4 0b 07 40 	macu.d	r0,r2,r11
8000bcc8:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000bccc:	02 02       	add	r2,r1
8000bcce:	5c 03       	acr	r3
8000bcd0:	ed b3 00 1c 	bld	r3,0x1c
8000bcd4:	c0 90       	breq	8000bce6 <__avr32_f64_div+0x12a>
8000bcd6:	a1 72       	lsl	r2,0x1
8000bcd8:	5c f3       	rol	r3
8000bcda:	20 17       	sub	r7,1
8000bcdc:	a3 9a       	lsr	r10,0x3
8000bcde:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000bce2:	a3 9b       	lsr	r11,0x3
8000bce4:	c0 58       	rjmp	8000bcee <__avr32_f64_div+0x132>
8000bce6:	a5 8a       	lsr	r10,0x4
8000bce8:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000bcec:	a5 8b       	lsr	r11,0x4
8000bcee:	58 07       	cp.w	r7,0
8000bcf0:	e0 8a 00 8b 	brle	8000be06 <__avr32_f64_div_res_subnormal>
8000bcf4:	e0 12 ff 00 	andl	r2,0xff00
8000bcf8:	e8 12 00 80 	orl	r2,0x80
8000bcfc:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bd00:	e4 09 07 40 	macu.d	r0,r2,r9
8000bd04:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bd08:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bd0c:	00 05       	add	r5,r0
8000bd0e:	f0 01 00 48 	adc	r8,r8,r1
8000bd12:	5c 09       	acr	r9
8000bd14:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bd18:	58 04       	cp.w	r4,0
8000bd1a:	5c 25       	cpc	r5

8000bd1c <__avr32_f64_div_round_subnormal>:
8000bd1c:	f4 08 13 00 	cpc	r8,r10
8000bd20:	f6 09 13 00 	cpc	r9,r11
8000bd24:	5f 36       	srlo	r6
8000bd26:	f8 06 17 00 	moveq	r6,r12
8000bd2a:	e4 0a 16 08 	lsr	r10,r2,0x8
8000bd2e:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000bd32:	e6 0b 16 08 	lsr	r11,r3,0x8
8000bd36:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bd3a:	ed be 00 1f 	bld	lr,0x1f
8000bd3e:	ef bb 00 1f 	bst	r11,0x1f
8000bd42:	0c 0a       	add	r10,r6
8000bd44:	5c 0b       	acr	r11
8000bd46:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bd4a:	e4 1b 00 0f 	andh	r11,0xf
8000bd4e:	14 4b       	or	r11,r10
8000bd50:	e0 81 00 a7 	brne	8000be9e <__avr32_f64_div_res_subnormal+0x98>
8000bd54:	f2 06 16 14 	lsr	r6,r9,0x14
8000bd58:	ab d6       	cbr	r6,0xb
8000bd5a:	e0 46 07 ff 	cp.w	r6,2047
8000bd5e:	e0 81 00 a4 	brne	8000bea6 <__avr32_f64_div_res_subnormal+0xa0>
8000bd62:	c9 e8       	rjmp	8000be9e <__avr32_f64_div_res_subnormal+0x98>
8000bd64:	e4 19 00 0f 	andh	r9,0xf
8000bd68:	10 49       	or	r9,r8
8000bd6a:	e0 81 00 9a 	brne	8000be9e <__avr32_f64_div_res_subnormal+0x98>
8000bd6e:	c9 28       	rjmp	8000be92 <__avr32_f64_div_res_subnormal+0x8c>
8000bd70:	a3 7b       	lsl	r11,0x3
8000bd72:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000bd76:	a3 7a       	lsl	r10,0x3
8000bd78:	f5 eb 10 04 	or	r4,r10,r11
8000bd7c:	e0 80 00 a0 	breq	8000bebc <__avr32_f64_div_op1_zero>
8000bd80:	f6 04 12 00 	clz	r4,r11
8000bd84:	c1 70       	breq	8000bdb2 <__avr32_f64_div_round_subnormal+0x96>
8000bd86:	c0 c3       	brcs	8000bd9e <__avr32_f64_div_round_subnormal+0x82>
8000bd88:	e8 05 11 20 	rsub	r5,r4,32
8000bd8c:	f6 04 09 4b 	lsl	r11,r11,r4
8000bd90:	f4 05 0a 45 	lsr	r5,r10,r5
8000bd94:	0a 4b       	or	r11,r5
8000bd96:	f4 04 09 4a 	lsl	r10,r10,r4
8000bd9a:	08 17       	sub	r7,r4
8000bd9c:	c0 b8       	rjmp	8000bdb2 <__avr32_f64_div_round_subnormal+0x96>
8000bd9e:	f4 04 12 00 	clz	r4,r10
8000bda2:	f9 b4 03 00 	movlo	r4,0
8000bda6:	f7 b4 02 e0 	subhs	r4,-32
8000bdaa:	f4 04 09 4b 	lsl	r11,r10,r4
8000bdae:	30 0a       	mov	r10,0
8000bdb0:	08 17       	sub	r7,r4
8000bdb2:	a3 8a       	lsr	r10,0x2
8000bdb4:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000bdb8:	a3 8b       	lsr	r11,0x2
8000bdba:	c1 1b       	rjmp	8000bbdc <__avr32_f64_div+0x20>
8000bdbc:	a3 79       	lsl	r9,0x3
8000bdbe:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000bdc2:	a3 78       	lsl	r8,0x3
8000bdc4:	f3 e8 10 04 	or	r4,r9,r8
8000bdc8:	c6 f0       	breq	8000bea6 <__avr32_f64_div_res_subnormal+0xa0>
8000bdca:	f2 04 12 00 	clz	r4,r9
8000bdce:	c1 70       	breq	8000bdfc <__avr32_f64_div_round_subnormal+0xe0>
8000bdd0:	c0 c3       	brcs	8000bde8 <__avr32_f64_div_round_subnormal+0xcc>
8000bdd2:	e8 05 11 20 	rsub	r5,r4,32
8000bdd6:	f2 04 09 49 	lsl	r9,r9,r4
8000bdda:	f0 05 0a 45 	lsr	r5,r8,r5
8000bdde:	0a 49       	or	r9,r5
8000bde0:	f0 04 09 48 	lsl	r8,r8,r4
8000bde4:	08 16       	sub	r6,r4
8000bde6:	c0 b8       	rjmp	8000bdfc <__avr32_f64_div_round_subnormal+0xe0>
8000bde8:	f0 04 12 00 	clz	r4,r8
8000bdec:	f9 b4 03 00 	movlo	r4,0
8000bdf0:	f7 b4 02 e0 	subhs	r4,-32
8000bdf4:	f0 04 09 49 	lsl	r9,r8,r4
8000bdf8:	30 08       	mov	r8,0
8000bdfa:	08 16       	sub	r6,r4
8000bdfc:	a3 88       	lsr	r8,0x2
8000bdfe:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000be02:	a3 89       	lsr	r9,0x2
8000be04:	cf ca       	rjmp	8000bbfc <__avr32_f64_div+0x40>

8000be06 <__avr32_f64_div_res_subnormal>:
8000be06:	5c 37       	neg	r7
8000be08:	2f f7       	sub	r7,-1
8000be0a:	f1 b7 04 c0 	satu	r7,0x6
8000be0e:	e0 47 00 20 	cp.w	r7,32
8000be12:	c1 54       	brge	8000be3c <__avr32_f64_div_res_subnormal+0x36>
8000be14:	ee 06 11 20 	rsub	r6,r7,32
8000be18:	e4 07 0a 42 	lsr	r2,r2,r7
8000be1c:	e6 06 09 4c 	lsl	r12,r3,r6
8000be20:	18 42       	or	r2,r12
8000be22:	e6 07 0a 43 	lsr	r3,r3,r7
8000be26:	f4 06 09 41 	lsl	r1,r10,r6
8000be2a:	f4 07 0a 4a 	lsr	r10,r10,r7
8000be2e:	f6 06 09 4c 	lsl	r12,r11,r6
8000be32:	18 4a       	or	r10,r12
8000be34:	f6 07 0a 4b 	lsr	r11,r11,r7
8000be38:	30 00       	mov	r0,0
8000be3a:	c1 58       	rjmp	8000be64 <__avr32_f64_div_res_subnormal+0x5e>
8000be3c:	ee 06 11 20 	rsub	r6,r7,32
8000be40:	f9 b0 00 00 	moveq	r0,0
8000be44:	f9 bc 00 00 	moveq	r12,0
8000be48:	c0 50       	breq	8000be52 <__avr32_f64_div_res_subnormal+0x4c>
8000be4a:	f4 06 09 40 	lsl	r0,r10,r6
8000be4e:	f6 06 09 4c 	lsl	r12,r11,r6
8000be52:	e6 07 0a 42 	lsr	r2,r3,r7
8000be56:	30 03       	mov	r3,0
8000be58:	f4 07 0a 41 	lsr	r1,r10,r7
8000be5c:	18 41       	or	r1,r12
8000be5e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000be62:	30 0b       	mov	r11,0
8000be64:	e0 12 ff 00 	andl	r2,0xff00
8000be68:	e8 12 00 80 	orl	r2,0x80
8000be6c:	e6 08 06 46 	mulu.d	r6,r3,r8
8000be70:	e4 09 07 46 	macu.d	r6,r2,r9
8000be74:	e4 08 06 44 	mulu.d	r4,r2,r8
8000be78:	e6 09 06 48 	mulu.d	r8,r3,r9
8000be7c:	0c 05       	add	r5,r6
8000be7e:	f0 07 00 48 	adc	r8,r8,r7
8000be82:	5c 09       	acr	r9
8000be84:	30 07       	mov	r7,0
8000be86:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000be8a:	00 34       	cp.w	r4,r0
8000be8c:	e2 05 13 00 	cpc	r5,r1
8000be90:	c4 6b       	rjmp	8000bd1c <__avr32_f64_div_round_subnormal>
8000be92:	1c 9b       	mov	r11,lr
8000be94:	e6 1b 80 00 	andh	r11,0x8000,COH
8000be98:	30 0a       	mov	r10,0
8000be9a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000be9e:	3f fb       	mov	r11,-1
8000bea0:	30 0a       	mov	r10,0
8000bea2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bea6:	f5 eb 10 04 	or	r4,r10,r11
8000beaa:	c0 90       	breq	8000bebc <__avr32_f64_div_op1_zero>
8000beac:	1c 9b       	mov	r11,lr
8000beae:	e6 1b 80 00 	andh	r11,0x8000,COH
8000beb2:	ea 1b 7f f0 	orh	r11,0x7ff0
8000beb6:	30 0a       	mov	r10,0
8000beb8:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000bebc <__avr32_f64_div_op1_zero>:
8000bebc:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000bec0:	ce f0       	breq	8000be9e <__avr32_f64_div_res_subnormal+0x98>
8000bec2:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000bec6:	e0 44 07 ff 	cp.w	r4,2047
8000beca:	ce 41       	brne	8000be92 <__avr32_f64_div_res_subnormal+0x8c>
8000becc:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000bed0:	ce 10       	breq	8000be92 <__avr32_f64_div_res_subnormal+0x8c>
8000bed2:	ce 6b       	rjmp	8000be9e <__avr32_f64_div_res_subnormal+0x98>

8000bed4 <__avr32_umod64>:
8000bed4:	d4 31       	pushm	r0-r7,lr
8000bed6:	1a 97       	mov	r7,sp
8000bed8:	20 3d       	sub	sp,12
8000beda:	10 9c       	mov	r12,r8
8000bedc:	12 95       	mov	r5,r9
8000bede:	14 9e       	mov	lr,r10
8000bee0:	16 91       	mov	r1,r11
8000bee2:	16 96       	mov	r6,r11
8000bee4:	58 09       	cp.w	r9,0
8000bee6:	e0 81 00 81 	brne	8000bfe8 <__avr32_umod64+0x114>
8000beea:	16 38       	cp.w	r8,r11
8000beec:	e0 88 00 12 	brls	8000bf10 <__avr32_umod64+0x3c>
8000bef0:	f0 08 12 00 	clz	r8,r8
8000bef4:	c4 e0       	breq	8000bf90 <__avr32_umod64+0xbc>
8000bef6:	f6 08 09 46 	lsl	r6,r11,r8
8000befa:	f8 08 09 4c 	lsl	r12,r12,r8
8000befe:	f0 0b 11 20 	rsub	r11,r8,32
8000bf02:	f4 08 09 4e 	lsl	lr,r10,r8
8000bf06:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000bf0a:	f7 e6 10 06 	or	r6,r11,r6
8000bf0e:	c4 18       	rjmp	8000bf90 <__avr32_umod64+0xbc>
8000bf10:	58 08       	cp.w	r8,0
8000bf12:	c0 51       	brne	8000bf1c <__avr32_umod64+0x48>
8000bf14:	30 19       	mov	r9,1
8000bf16:	f2 08 0d 08 	divu	r8,r9,r8
8000bf1a:	10 9c       	mov	r12,r8
8000bf1c:	f8 08 12 00 	clz	r8,r12
8000bf20:	c0 31       	brne	8000bf26 <__avr32_umod64+0x52>
8000bf22:	18 16       	sub	r6,r12
8000bf24:	c3 68       	rjmp	8000bf90 <__avr32_umod64+0xbc>
8000bf26:	f0 03 11 20 	rsub	r3,r8,32
8000bf2a:	f4 03 0a 4b 	lsr	r11,r10,r3
8000bf2e:	f8 08 09 4c 	lsl	r12,r12,r8
8000bf32:	ec 08 09 49 	lsl	r9,r6,r8
8000bf36:	ec 03 0a 43 	lsr	r3,r6,r3
8000bf3a:	f7 e9 10 09 	or	r9,r11,r9
8000bf3e:	f8 05 16 10 	lsr	r5,r12,0x10
8000bf42:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bf46:	e6 05 0d 02 	divu	r2,r3,r5
8000bf4a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000bf4e:	ec 02 02 4b 	mul	r11,r6,r2
8000bf52:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000bf56:	16 3e       	cp.w	lr,r11
8000bf58:	c0 72       	brcc	8000bf66 <__avr32_umod64+0x92>
8000bf5a:	18 0e       	add	lr,r12
8000bf5c:	18 3e       	cp.w	lr,r12
8000bf5e:	c0 43       	brcs	8000bf66 <__avr32_umod64+0x92>
8000bf60:	16 3e       	cp.w	lr,r11
8000bf62:	fd dc e3 0e 	addcs	lr,lr,r12
8000bf66:	fc 0b 01 03 	sub	r3,lr,r11
8000bf6a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000bf6e:	e6 05 0d 02 	divu	r2,r3,r5
8000bf72:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bf76:	a5 36       	mul	r6,r2
8000bf78:	0c 39       	cp.w	r9,r6
8000bf7a:	c0 72       	brcc	8000bf88 <__avr32_umod64+0xb4>
8000bf7c:	18 09       	add	r9,r12
8000bf7e:	18 39       	cp.w	r9,r12
8000bf80:	c0 43       	brcs	8000bf88 <__avr32_umod64+0xb4>
8000bf82:	0c 39       	cp.w	r9,r6
8000bf84:	f3 dc e3 09 	addcs	r9,r9,r12
8000bf88:	f2 06 01 06 	sub	r6,r9,r6
8000bf8c:	f4 08 09 4e 	lsl	lr,r10,r8
8000bf90:	f8 0a 16 10 	lsr	r10,r12,0x10
8000bf94:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bf98:	ec 0a 0d 02 	divu	r2,r6,r10
8000bf9c:	fc 09 16 10 	lsr	r9,lr,0x10
8000bfa0:	ea 02 02 4b 	mul	r11,r5,r2
8000bfa4:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bfa8:	16 39       	cp.w	r9,r11
8000bfaa:	c0 72       	brcc	8000bfb8 <__avr32_umod64+0xe4>
8000bfac:	18 09       	add	r9,r12
8000bfae:	18 39       	cp.w	r9,r12
8000bfb0:	c0 43       	brcs	8000bfb8 <__avr32_umod64+0xe4>
8000bfb2:	16 39       	cp.w	r9,r11
8000bfb4:	f3 dc e3 09 	addcs	r9,r9,r12
8000bfb8:	f2 0b 01 0b 	sub	r11,r9,r11
8000bfbc:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000bfc0:	f6 0a 0d 0a 	divu	r10,r11,r10
8000bfc4:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000bfc8:	ea 0a 02 4a 	mul	r10,r5,r10
8000bfcc:	14 3e       	cp.w	lr,r10
8000bfce:	c0 72       	brcc	8000bfdc <__avr32_umod64+0x108>
8000bfd0:	18 0e       	add	lr,r12
8000bfd2:	18 3e       	cp.w	lr,r12
8000bfd4:	c0 43       	brcs	8000bfdc <__avr32_umod64+0x108>
8000bfd6:	14 3e       	cp.w	lr,r10
8000bfd8:	fd dc e3 0e 	addcs	lr,lr,r12
8000bfdc:	fc 0a 01 0a 	sub	r10,lr,r10
8000bfe0:	30 0b       	mov	r11,0
8000bfe2:	f4 08 0a 4a 	lsr	r10,r10,r8
8000bfe6:	c7 b8       	rjmp	8000c0dc <__avr32_umod64+0x208>
8000bfe8:	16 39       	cp.w	r9,r11
8000bfea:	e0 8b 00 79 	brhi	8000c0dc <__avr32_umod64+0x208>
8000bfee:	f2 09 12 00 	clz	r9,r9
8000bff2:	c1 21       	brne	8000c016 <__avr32_umod64+0x142>
8000bff4:	10 3a       	cp.w	r10,r8
8000bff6:	5f 2b       	srhs	r11
8000bff8:	0a 31       	cp.w	r1,r5
8000bffa:	5f ba       	srhi	r10
8000bffc:	f7 ea 10 0a 	or	r10,r11,r10
8000c000:	f2 0a 18 00 	cp.b	r10,r9
8000c004:	c0 60       	breq	8000c010 <__avr32_umod64+0x13c>
8000c006:	fc 08 01 0c 	sub	r12,lr,r8
8000c00a:	e2 05 01 46 	sbc	r6,r1,r5
8000c00e:	18 9e       	mov	lr,r12
8000c010:	0c 9b       	mov	r11,r6
8000c012:	1c 9a       	mov	r10,lr
8000c014:	c6 48       	rjmp	8000c0dc <__avr32_umod64+0x208>
8000c016:	ea 09 09 4c 	lsl	r12,r5,r9
8000c01a:	f2 06 11 20 	rsub	r6,r9,32
8000c01e:	f6 09 09 4b 	lsl	r11,r11,r9
8000c022:	f0 09 09 42 	lsl	r2,r8,r9
8000c026:	ef 46 ff f4 	st.w	r7[-12],r6
8000c02a:	f0 06 0a 48 	lsr	r8,r8,r6
8000c02e:	18 48       	or	r8,r12
8000c030:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c034:	f4 09 09 43 	lsl	r3,r10,r9
8000c038:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c03c:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c040:	16 4a       	or	r10,r11
8000c042:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c046:	f8 0b 0d 04 	divu	r4,r12,r11
8000c04a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c04e:	08 91       	mov	r1,r4
8000c050:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c054:	e8 0e 02 46 	mul	r6,r4,lr
8000c058:	0c 3c       	cp.w	r12,r6
8000c05a:	c0 a2       	brcc	8000c06e <__avr32_umod64+0x19a>
8000c05c:	20 11       	sub	r1,1
8000c05e:	10 0c       	add	r12,r8
8000c060:	10 3c       	cp.w	r12,r8
8000c062:	c0 63       	brcs	8000c06e <__avr32_umod64+0x19a>
8000c064:	0c 3c       	cp.w	r12,r6
8000c066:	f7 b1 03 01 	sublo	r1,1
8000c06a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c06e:	0c 1c       	sub	r12,r6
8000c070:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c074:	f8 0b 0d 04 	divu	r4,r12,r11
8000c078:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c07c:	08 96       	mov	r6,r4
8000c07e:	e8 0e 02 4e 	mul	lr,r4,lr
8000c082:	1c 3b       	cp.w	r11,lr
8000c084:	c0 a2       	brcc	8000c098 <__avr32_umod64+0x1c4>
8000c086:	20 16       	sub	r6,1
8000c088:	10 0b       	add	r11,r8
8000c08a:	10 3b       	cp.w	r11,r8
8000c08c:	c0 63       	brcs	8000c098 <__avr32_umod64+0x1c4>
8000c08e:	1c 3b       	cp.w	r11,lr
8000c090:	f7 b6 03 01 	sublo	r6,1
8000c094:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c098:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c09c:	1c 1b       	sub	r11,lr
8000c09e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c0a2:	00 9e       	mov	lr,r0
8000c0a4:	02 9c       	mov	r12,r1
8000c0a6:	16 3c       	cp.w	r12,r11
8000c0a8:	e0 8b 00 08 	brhi	8000c0b8 <__avr32_umod64+0x1e4>
8000c0ac:	5f 06       	sreq	r6
8000c0ae:	06 30       	cp.w	r0,r3
8000c0b0:	5f ba       	srhi	r10
8000c0b2:	ed ea 00 0a 	and	r10,r6,r10
8000c0b6:	c0 60       	breq	8000c0c2 <__avr32_umod64+0x1ee>
8000c0b8:	fc 02 01 04 	sub	r4,lr,r2
8000c0bc:	f8 08 01 4c 	sbc	r12,r12,r8
8000c0c0:	08 9e       	mov	lr,r4
8000c0c2:	e6 0e 01 0a 	sub	r10,r3,lr
8000c0c6:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c0ca:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c0ce:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c0d2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c0d6:	f8 01 09 4c 	lsl	r12,r12,r1
8000c0da:	18 4a       	or	r10,r12
8000c0dc:	2f dd       	sub	sp,-12
8000c0de:	d8 32       	popm	r0-r7,pc

8000c0e0 <__do_global_ctors_aux>:
8000c0e0:	d4 21       	pushm	r4-r7,lr
8000c0e2:	30 c7       	mov	r7,12
8000c0e4:	c0 28       	rjmp	8000c0e8 <__do_global_ctors_aux+0x8>
8000c0e6:	5d 18       	icall	r8
8000c0e8:	20 47       	sub	r7,4
8000c0ea:	6e 08       	ld.w	r8,r7[0x0]
8000c0ec:	5b f8       	cp.w	r8,-1
8000c0ee:	cf c1       	brne	8000c0e6 <__do_global_ctors_aux+0x6>
8000c0f0:	d8 22       	popm	r4-r7,pc
8000c0f2:	d7 03       	nop

Disassembly of section .exception:

8000c200 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
8000c200:	c0 08       	rjmp	8000c200 <_evba>
	...

8000c204 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
8000c204:	c0 08       	rjmp	8000c204 <_handle_TLB_Multiple_Hit>
	...

8000c208 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
8000c208:	c0 08       	rjmp	8000c208 <_handle_Bus_Error_Data_Fetch>
	...

8000c20c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000c20c:	c0 08       	rjmp	8000c20c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c210 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
8000c210:	c0 08       	rjmp	8000c210 <_handle_NMI>
	...

8000c214 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
8000c214:	c0 08       	rjmp	8000c214 <_handle_Instruction_Address>
	...

8000c218 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
8000c218:	c0 08       	rjmp	8000c218 <_handle_ITLB_Protection>
	...

8000c21c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000c21c:	c0 08       	rjmp	8000c21c <_handle_Breakpoint>
	...

8000c220 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
8000c220:	c0 08       	rjmp	8000c220 <_handle_Illegal_Opcode>
	...

8000c224 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
8000c224:	c0 08       	rjmp	8000c224 <_handle_Unimplemented_Instruction>
	...

8000c228 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
8000c228:	c0 08       	rjmp	8000c228 <_handle_Privilege_Violation>
	...

8000c22c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000c22c:	c0 08       	rjmp	8000c22c <_handle_Floating_Point>
	...

8000c230 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
8000c230:	c0 08       	rjmp	8000c230 <_handle_Coprocessor_Absent>
	...

8000c234 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
8000c234:	c0 08       	rjmp	8000c234 <_handle_Data_Address_Read>
	...

8000c238 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
8000c238:	c0 08       	rjmp	8000c238 <_handle_Data_Address_Write>
	...

8000c23c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000c23c:	c0 08       	rjmp	8000c23c <_handle_DTLB_Protection_Read>
	...

8000c240 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
8000c240:	c0 08       	rjmp	8000c240 <_handle_DTLB_Protection_Write>
	...

8000c244 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
8000c244:	c0 08       	rjmp	8000c244 <_handle_DTLB_Modified>
	...

8000c250 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
8000c250:	c0 08       	rjmp	8000c250 <_handle_ITLB_Miss>
	...

8000c260 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
8000c260:	c0 08       	rjmp	8000c260 <_handle_DTLB_Miss_Read>
	...

8000c270 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
8000c270:	c0 08       	rjmp	8000c270 <_handle_DTLB_Miss_Write>
	...

8000c300 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c300:	fe cf 74 34 	sub	pc,pc,29748

8000c304 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c304:	30 0c       	mov	r12,0
8000c306:	fe b0 c0 73 	rcall	800043ec <_get_interrupt_handler>
8000c30a:	58 0c       	cp.w	r12,0
8000c30c:	f8 0f 17 10 	movne	pc,r12
8000c310:	d6 03       	rete

8000c312 <_int1>:
8000c312:	30 1c       	mov	r12,1
8000c314:	fe b0 c0 6c 	rcall	800043ec <_get_interrupt_handler>
8000c318:	58 0c       	cp.w	r12,0
8000c31a:	f8 0f 17 10 	movne	pc,r12
8000c31e:	d6 03       	rete

8000c320 <_int2>:
8000c320:	30 2c       	mov	r12,2
8000c322:	fe b0 c0 65 	rcall	800043ec <_get_interrupt_handler>
8000c326:	58 0c       	cp.w	r12,0
8000c328:	f8 0f 17 10 	movne	pc,r12
8000c32c:	d6 03       	rete

8000c32e <_int3>:
8000c32e:	30 3c       	mov	r12,3
8000c330:	fe b0 c0 5e 	rcall	800043ec <_get_interrupt_handler>
8000c334:	58 0c       	cp.w	r12,0
8000c336:	f8 0f 17 10 	movne	pc,r12
8000c33a:	d6 03       	rete
8000c33c:	d7 03       	nop
8000c33e:	d7 03       	nop
8000c340:	d7 03       	nop
8000c342:	d7 03       	nop
8000c344:	d7 03       	nop
8000c346:	d7 03       	nop
8000c348:	d7 03       	nop
8000c34a:	d7 03       	nop
8000c34c:	d7 03       	nop
8000c34e:	d7 03       	nop
8000c350:	d7 03       	nop
8000c352:	d7 03       	nop
8000c354:	d7 03       	nop
8000c356:	d7 03       	nop
8000c358:	d7 03       	nop
8000c35a:	d7 03       	nop
8000c35c:	d7 03       	nop
8000c35e:	d7 03       	nop
8000c360:	d7 03       	nop
8000c362:	d7 03       	nop
8000c364:	d7 03       	nop
8000c366:	d7 03       	nop
8000c368:	d7 03       	nop
8000c36a:	d7 03       	nop
8000c36c:	d7 03       	nop
8000c36e:	d7 03       	nop
8000c370:	d7 03       	nop
8000c372:	d7 03       	nop
8000c374:	d7 03       	nop
8000c376:	d7 03       	nop
8000c378:	d7 03       	nop
8000c37a:	d7 03       	nop
8000c37c:	d7 03       	nop
8000c37e:	d7 03       	nop
8000c380:	d7 03       	nop
8000c382:	d7 03       	nop
8000c384:	d7 03       	nop
8000c386:	d7 03       	nop
8000c388:	d7 03       	nop
8000c38a:	d7 03       	nop
8000c38c:	d7 03       	nop
8000c38e:	d7 03       	nop
8000c390:	d7 03       	nop
8000c392:	d7 03       	nop
8000c394:	d7 03       	nop
8000c396:	d7 03       	nop
8000c398:	d7 03       	nop
8000c39a:	d7 03       	nop
8000c39c:	d7 03       	nop
8000c39e:	d7 03       	nop
8000c3a0:	d7 03       	nop
8000c3a2:	d7 03       	nop
8000c3a4:	d7 03       	nop
8000c3a6:	d7 03       	nop
8000c3a8:	d7 03       	nop
8000c3aa:	d7 03       	nop
8000c3ac:	d7 03       	nop
8000c3ae:	d7 03       	nop
8000c3b0:	d7 03       	nop
8000c3b2:	d7 03       	nop
8000c3b4:	d7 03       	nop
8000c3b6:	d7 03       	nop
8000c3b8:	d7 03       	nop
8000c3ba:	d7 03       	nop
8000c3bc:	d7 03       	nop
8000c3be:	d7 03       	nop
8000c3c0:	d7 03       	nop
8000c3c2:	d7 03       	nop
8000c3c4:	d7 03       	nop
8000c3c6:	d7 03       	nop
8000c3c8:	d7 03       	nop
8000c3ca:	d7 03       	nop
8000c3cc:	d7 03       	nop
8000c3ce:	d7 03       	nop
8000c3d0:	d7 03       	nop
8000c3d2:	d7 03       	nop
8000c3d4:	d7 03       	nop
8000c3d6:	d7 03       	nop
8000c3d8:	d7 03       	nop
8000c3da:	d7 03       	nop
8000c3dc:	d7 03       	nop
8000c3de:	d7 03       	nop
8000c3e0:	d7 03       	nop
8000c3e2:	d7 03       	nop
8000c3e4:	d7 03       	nop
8000c3e6:	d7 03       	nop
8000c3e8:	d7 03       	nop
8000c3ea:	d7 03       	nop
8000c3ec:	d7 03       	nop
8000c3ee:	d7 03       	nop
8000c3f0:	d7 03       	nop
8000c3f2:	d7 03       	nop
8000c3f4:	d7 03       	nop
8000c3f6:	d7 03       	nop
8000c3f8:	d7 03       	nop
8000c3fa:	d7 03       	nop
8000c3fc:	d7 03       	nop
8000c3fe:	d7 03       	nop

Disassembly of section .fini:

8000c400 <_fini>:
8000c400:	eb cd 40 40 	pushm	r6,lr
8000c404:	48 26       	lddpc	r6,8000c40c <_fini+0xc>
8000c406:	1e 26       	rsub	r6,pc
8000c408:	c0 48       	rjmp	8000c410 <_fini+0x10>
8000c40a:	d7 03       	nop
8000c40c:	80 00       	ld.sh	r0,r0[0x0]
8000c40e:	c3 ea       	rjmp	8000c08a <__avr32_umod64+0x1b6>
8000c410:	fe b0 ae 3e 	rcall	8000208c <__do_global_dtors_aux>
8000c414:	e3 cd 80 40 	ldm	sp++,r6,pc
