
Lab63_peter.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         0000a15c  80002028  80002028  00002428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  8000c200  8000c200  0000c600  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  8000c400  8000c400  0000c800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       000006a0  8000c418  8000c418  0000c818  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  8 .ctors        00000008  00000008  8000cab8  0000d008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .dtors        00000008  00000010  8000cac0  0000d010  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .jcr          00000004  00000018  8000cac8  0000d018  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got          00000000  0000001c  8000cacc  0000d01c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         00000510  0000001c  8000cacc  0000d01c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .bss          000002c8  00000548  00000548  00000000  2**2
                  ALLOC
 14 .heap         0000e7f0  00000810  00000810  00000000  2**0
                  ALLOC
 15 .comment      00000030  00000000  00000000  0000d52c  2**0
                  CONTENTS, READONLY
 16 .debug_aranges 00001120  00000000  00000000  0000d560  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_pubnames 00001f8a  00000000  00000000  0000e680  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_info   00029e7a  00000000  00000000  0001060a  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_abbrev 00005e9f  00000000  00000000  0003a484  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_line   00012b2b  00000000  00000000  00040323  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_frame  00002eb4  00000000  00000000  00052e50  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_str    000056df  00000000  00000000  00055d04  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_loc    0000a917  00000000  00000000  0005b3e3  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_macinfo 010d0c0a  00000000  00000000  00065cfa  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 26 .debug_ranges 00001178  00000000  00000000  01136904  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	20 28       	sub	r8,2

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

8000200c <_init>:
8000200c:	eb cd 40 40 	pushm	r6,lr
80002010:	48 26       	lddpc	r6,80002018 <_init+0xc>
80002012:	1e 26       	rsub	r6,pc
80002014:	c0 48       	rjmp	8000201c <_init+0x10>
80002016:	d7 03       	nop
80002018:	80 00       	ld.sh	r0,r0[0x0]
8000201a:	1f f6       	ld.ub	r6,pc[0x7]
8000201c:	c5 6c       	rcall	800020c8 <frame_dummy>
8000201e:	e0 a0 50 a9 	rcall	8000c170 <__do_global_ctors_aux>
80002022:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002028 <_stext>:
80002028:	30 07       	mov	r7,0
8000202a:	e0 7a 00 00 	mov	r10,65536
8000202e:	5b fa       	cp.w	r10,-1
80002030:	f4 0d 17 10 	movne	sp,r10
80002034:	49 4b       	lddpc	r11,80002084 <_stext+0x5c>
80002036:	30 8c       	mov	r12,8
80002038:	18 3b       	cp.w	r11,r12
8000203a:	c0 70       	breq	80002048 <_stext+0x20>
8000203c:	e0 6a 05 30 	mov	r10,1328
80002040:	b7 09       	ld.d	r8,r11++
80002042:	b9 28       	st.d	r12++,r8
80002044:	14 3c       	cp.w	r12,r10
80002046:	cf d5       	brlt	80002040 <_stext+0x18>
80002048:	e0 6a 08 10 	mov	r10,2064
8000204c:	e0 6c 05 30 	mov	r12,1328
80002050:	30 08       	mov	r8,0
80002052:	30 09       	mov	r9,0
80002054:	b9 28       	st.d	r12++,r8
80002056:	14 3c       	cp.w	r12,r10
80002058:	cf e5       	brlt	80002054 <_stext+0x2c>
8000205a:	e0 a0 16 ad 	rcall	80004db4 <_init_startup>
8000205e:	48 bc       	lddpc	r12,80002088 <_stext+0x60>
80002060:	e0 a0 24 4c 	rcall	800068f8 <atexit>
80002064:	cd 4f       	rcall	8000200c <_init>
80002066:	1a 9c       	mov	r12,sp
80002068:	30 0b       	mov	r11,0
8000206a:	e0 a0 28 d5 	rcall	80007214 <_init_argv>
8000206e:	5b fc       	cp.w	r12,-1
80002070:	f9 bc 00 00 	moveq	r12,0
80002074:	f9 ba 00 00 	moveq	r10,0
80002078:	14 1d       	sub	sp,r10
8000207a:	e0 a0 0f 99 	rcall	80003fac <main>
8000207e:	e0 a0 24 45 	rcall	80006908 <exit>
80002082:	d7 03       	nop
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	ca b8       	rjmp	800021dc <dip204_init+0xd4>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	c4 00       	breq	8000210a <dip204_init+0x2>

8000208c <__do_global_dtors_aux>:
8000208c:	d4 21       	pushm	r4-r7,lr
8000208e:	e0 68 05 48 	mov	r8,1352
80002092:	11 89       	ld.ub	r9,r8[0x0]
80002094:	30 08       	mov	r8,0
80002096:	f0 09 18 00 	cp.b	r9,r8
8000209a:	c1 61       	brne	800020c6 <__do_global_dtors_aux+0x3a>
8000209c:	31 08       	mov	r8,16
8000209e:	31 46       	mov	r6,20
800020a0:	10 95       	mov	r5,r8
800020a2:	10 16       	sub	r6,r8
800020a4:	e0 67 05 4c 	mov	r7,1356
800020a8:	a3 46       	asr	r6,0x2
800020aa:	20 16       	sub	r6,1
800020ac:	c0 68       	rjmp	800020b8 <__do_global_dtors_aux+0x2c>
800020ae:	2f f8       	sub	r8,-1
800020b0:	8f 08       	st.w	r7[0x0],r8
800020b2:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020b6:	5d 18       	icall	r8
800020b8:	6e 08       	ld.w	r8,r7[0x0]
800020ba:	0c 38       	cp.w	r8,r6
800020bc:	cf 93       	brcs	800020ae <__do_global_dtors_aux+0x22>
800020be:	30 19       	mov	r9,1
800020c0:	e0 68 05 48 	mov	r8,1352
800020c4:	b0 89       	st.b	r8[0x0],r9
800020c6:	d8 22       	popm	r4-r7,pc

800020c8 <frame_dummy>:
800020c8:	d4 01       	pushm	lr
800020ca:	31 8c       	mov	r12,24
800020cc:	78 08       	ld.w	r8,r12[0x0]
800020ce:	58 08       	cp.w	r8,0
800020d0:	c0 50       	breq	800020da <frame_dummy+0x12>
800020d2:	48 38       	lddpc	r8,800020dc <frame_dummy+0x14>
800020d4:	58 08       	cp.w	r8,0
800020d6:	c0 20       	breq	800020da <frame_dummy+0x12>
800020d8:	5d 18       	icall	r8
800020da:	d8 02       	popm	pc
800020dc:	00 00       	add	r0,r0
	...

800020e0 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern bool sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
800020e0:	eb cd 40 80 	pushm	r7,lr
800020e4:	1a 97       	mov	r7,sp
	}
#endif

	switch (CONFIG_SYSCLK_SOURCE) {
	case SYSCLK_SRC_RCSYS:
		return OSC_SLOW_NOMINAL_HZ;
800020e6:	e0 78 c2 00 	mov	r8,115200

	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
800020ea:	10 9c       	mov	r12,r8
800020ec:	e3 cd 80 80 	ldm	sp++,r7,pc

800020f0 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
800020f0:	eb cd 40 80 	pushm	r7,lr
800020f4:	1a 97       	mov	r7,sp
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_CPU_DIV;
800020f6:	f0 1f 00 04 	mcall	80002104 <sysclk_get_cpu_hz+0x14>
800020fa:	18 98       	mov	r8,r12
}
800020fc:	10 9c       	mov	r12,r8
800020fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002102:	00 00       	add	r0,r0
80002104:	80 00       	ld.sh	r0,r0[0x0]
80002106:	20 e0       	sub	r0,14

80002108 <dip204_init>:


/****************************** global functions *****************************/

void dip204_init(backlight_options option, bool backlight_on)
{
80002108:	eb cd 40 8f 	pushm	r0-r3,r7,lr
8000210c:	1a 97       	mov	r7,sp
8000210e:	fa cd 01 ac 	sub	sp,sp,428
80002112:	ef 4c fe b8 	st.w	r7[-328],r12
80002116:	16 98       	mov	r8,r11
80002118:	ef 68 fe b4 	st.b	r7[-332],r8
  pwm_opt_t pwm_opt;  // pwm option config

  if (option == backlight_PWM)
8000211c:	ee f8 fe b8 	ld.w	r8,r7[-328]
80002120:	58 18       	cp.w	r8,1
80002122:	c6 41       	brne	800021ea <dip204_init+0xe2>
  {
    channel_id = DIP204_PWM_CHANNEL;
80002124:	fe f9 0a 84 	ld.w	r9,pc[2692]
80002128:	30 68       	mov	r8,6
8000212a:	93 08       	st.w	r9[0x0],r8
    gpio_enable_module_pin(DIP204_PWM_PIN, DIP204_PWM_FUNCTION);
8000212c:	30 2b       	mov	r11,2
8000212e:	33 2c       	mov	r12,50
80002130:	f0 1f 02 9f 	mcall	80002bac <dip204_init+0xaa4>

    // PWM controller configuration
    pwm_opt.diva=0;
80002134:	30 08       	mov	r8,0
80002136:	ef 48 ff 14 	st.w	r7[-236],r8
    pwm_opt.divb=0;
8000213a:	30 08       	mov	r8,0
8000213c:	ef 48 ff 10 	st.w	r7[-240],r8
    pwm_opt.prea=0;
80002140:	30 08       	mov	r8,0
80002142:	ef 48 ff 1c 	st.w	r7[-228],r8
    pwm_opt.preb=0;
80002146:	30 08       	mov	r8,0
80002148:	ef 48 ff 18 	st.w	r7[-232],r8

    pwm_init(&pwm_opt);
8000214c:	ee c8 00 f0 	sub	r8,r7,240
80002150:	10 9c       	mov	r12,r8
80002152:	f0 1f 02 98 	mcall	80002bb0 <dip204_init+0xaa8>
    pwm_duty = (backlight_on) ? DIP204_PERIOD_MAX - 1 : 1;
80002156:	ef 39 fe b4 	ld.ub	r9,r7[-332]
8000215a:	30 08       	mov	r8,0
8000215c:	f0 09 18 00 	cp.b	r9,r8
80002160:	c0 30       	breq	80002166 <dip204_init+0x5e>
80002162:	33 18       	mov	r8,49
80002164:	c0 28       	rjmp	80002168 <dip204_init+0x60>
80002166:	30 18       	mov	r8,1
80002168:	fe f9 0a 4c 	ld.w	r9,pc[2636]
8000216c:	b2 08       	st.h	r9[0x0],r8
    pwm_channel.CMR.calg = PWM_MODE_LEFT_ALIGNED;   // channel mode
8000216e:	fe fa 0a 4a 	ld.w	r10,pc[2634]
80002172:	74 08       	ld.w	r8,r10[0x0]
80002174:	30 09       	mov	r9,0
80002176:	f1 d9 d1 01 	bfins	r8,r9,0x8,0x1
8000217a:	95 08       	st.w	r10[0x0],r8
    pwm_channel.CMR.cpol = PWM_POLARITY_LOW;   // channel polarity
8000217c:	fe fa 0a 3c 	ld.w	r10,pc[2620]
80002180:	74 08       	ld.w	r8,r10[0x0]
80002182:	30 09       	mov	r9,0
80002184:	f1 d9 d1 21 	bfins	r8,r9,0x9,0x1
80002188:	95 08       	st.w	r10[0x0],r8
    pwm_channel.CMR.cpd = PWM_UPDATE_PERIOD;   // not used the first time
8000218a:	fe fa 0a 2e 	ld.w	r10,pc[2606]
8000218e:	74 08       	ld.w	r8,r10[0x0]
80002190:	30 19       	mov	r9,1
80002192:	f1 d9 d1 41 	bfins	r8,r9,0xa,0x1
80002196:	95 08       	st.w	r10[0x0],r8
    pwm_channel.CMR.cpre = AVR32_PWM_CPRE_MCK_DIV_256;   // channel prescaler
80002198:	fe fa 0a 20 	ld.w	r10,pc[2592]
8000219c:	74 08       	ld.w	r8,r10[0x0]
8000219e:	30 89       	mov	r9,8
800021a0:	f1 d9 d0 04 	bfins	r8,r9,0x0,0x4
800021a4:	95 08       	st.w	r10[0x0],r8
    pwm_channel.cdty = pwm_duty;  // channel duty cycle, should be < CPRD
800021a6:	fe f8 0a 0e 	ld.w	r8,pc[2574]
800021aa:	90 08       	ld.sh	r8,r8[0x0]
800021ac:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800021b0:	fe f8 0a 08 	ld.w	r8,pc[2568]
800021b4:	91 19       	st.w	r8[0x4],r9
    pwm_channel.cprd = DIP204_PERIOD_MAX;  // channel period
800021b6:	fe f9 0a 02 	ld.w	r9,pc[2562]
800021ba:	33 28       	mov	r8,50
800021bc:	93 28       	st.w	r9[0x8],r8
    pwm_channel.cupd = 0;  // channel update is not used here.
800021be:	fe f9 09 fa 	ld.w	r9,pc[2554]
800021c2:	30 08       	mov	r8,0
800021c4:	93 48       	st.w	r9[0x10],r8

    pwm_channel_init(channel_id, &pwm_channel);
800021c6:	fe f8 09 e2 	ld.w	r8,pc[2530]
800021ca:	70 08       	ld.w	r8,r8[0x0]
800021cc:	fe fb 09 ec 	ld.w	r11,pc[2540]
800021d0:	10 9c       	mov	r12,r8
800021d2:	f0 1f 02 7b 	mcall	80002bbc <dip204_init+0xab4>
    // start PWM
    pwm_start_channels(1 << channel_id);
800021d6:	fe f8 09 d2 	ld.w	r8,pc[2514]
800021da:	70 09       	ld.w	r9,r8[0x0]
800021dc:	30 18       	mov	r8,1
800021de:	f0 09 09 48 	lsl	r8,r8,r9
800021e2:	10 9c       	mov	r12,r8
800021e4:	f0 1f 02 77 	mcall	80002bc0 <dip204_init+0xab8>
800021e8:	c0 e8       	rjmp	80002204 <dip204_init+0xfc>
  }
  else
  {
    if (backlight_on)
800021ea:	ef 39 fe b4 	ld.ub	r9,r7[-332]
800021ee:	30 08       	mov	r8,0
800021f0:	f0 09 18 00 	cp.b	r9,r8
800021f4:	c0 50       	breq	800021fe <dip204_init+0xf6>
    {
      gpio_clr_gpio_pin(DIP204_BACKLIGHT_PIN);
800021f6:	33 2c       	mov	r12,50
800021f8:	f0 1f 02 73 	mcall	80002bc4 <dip204_init+0xabc>
800021fc:	c0 48       	rjmp	80002204 <dip204_init+0xfc>
    }
    else
    {
      gpio_set_gpio_pin(DIP204_BACKLIGHT_PIN);
800021fe:	33 2c       	mov	r12,50
80002200:	f0 1f 02 72 	mcall	80002bc8 <dip204_init+0xac0>
    }
  }
  // delay for power on
  delay_ms(20);
80002204:	f0 1f 02 72 	mcall	80002bcc <dip204_init+0xac4>
80002208:	18 99       	mov	r9,r12
8000220a:	31 48       	mov	r8,20
8000220c:	ef 48 ff 24 	st.w	r7[-220],r8
80002210:	ef 49 ff 20 	st.w	r7[-224],r9
80002214:	ee f8 ff 24 	ld.w	r8,r7[-220]
80002218:	ef 48 ff 2c 	st.w	r7[-212],r8
8000221c:	ee f8 ff 20 	ld.w	r8,r7[-224]
80002220:	ef 48 ff 28 	st.w	r7[-216],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002224:	ee f0 ff 2c 	ld.w	r0,r7[-212]
80002228:	30 01       	mov	r1,0
8000222a:	ee f2 ff 28 	ld.w	r2,r7[-216]
8000222e:	30 03       	mov	r3,0
80002230:	e2 02 02 49 	mul	r9,r1,r2
80002234:	e6 00 02 48 	mul	r8,r3,r0
80002238:	10 09       	add	r9,r8
8000223a:	e0 02 06 4a 	mulu.d	r10,r0,r2
8000223e:	16 09       	add	r9,r11
80002240:	12 9b       	mov	r11,r9
80002242:	e0 68 03 e7 	mov	r8,999
80002246:	30 09       	mov	r9,0
80002248:	10 0a       	add	r10,r8
8000224a:	f6 09 00 4b 	adc	r11,r11,r9
8000224e:	e0 68 03 e8 	mov	r8,1000
80002252:	30 09       	mov	r9,0
80002254:	f0 1f 02 5f 	mcall	80002bd0 <dip204_init+0xac8>
80002258:	14 98       	mov	r8,r10
8000225a:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000225c:	ef 48 ff 34 	st.w	r7[-204],r8
80002260:	ee c8 01 44 	sub	r8,r7,324
80002264:	ef 48 ff 30 	st.w	r7[-208],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002268:	e1 b8 00 42 	mfsr	r8,0x108
8000226c:	10 99       	mov	r9,r8
8000226e:	ee f8 ff 30 	ld.w	r8,r7[-208]
80002272:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002274:	ee f8 ff 30 	ld.w	r8,r7[-208]
80002278:	70 09       	ld.w	r9,r8[0x0]
8000227a:	ee f8 ff 34 	ld.w	r8,r7[-204]
8000227e:	10 09       	add	r9,r8
80002280:	ee f8 ff 30 	ld.w	r8,r7[-208]
80002284:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002286:	ee f9 ff 30 	ld.w	r9,r7[-208]
8000228a:	30 08       	mov	r8,0
8000228c:	f3 68 00 08 	st.b	r9[8],r8
80002290:	ee c8 01 44 	sub	r8,r7,324
80002294:	ef 48 ff 38 	st.w	r7[-200],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002298:	e1 b8 00 42 	mfsr	r8,0x108
8000229c:	ef 48 ff 3c 	st.w	r7[-196],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800022a0:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022a4:	f1 39 00 08 	ld.ub	r9,r8[8]
800022a8:	30 28       	mov	r8,2
800022aa:	f0 09 18 00 	cp.b	r9,r8
800022ae:	c0 31       	brne	800022b4 <dip204_init+0x1ac>
    return false;
800022b0:	30 08       	mov	r8,0
800022b2:	c4 38       	rjmp	80002338 <dip204_init+0x230>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800022b4:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022b8:	f1 39 00 08 	ld.ub	r9,r8[8]
800022bc:	30 18       	mov	r8,1
800022be:	f0 09 18 00 	cp.b	r9,r8
800022c2:	c0 31       	brne	800022c8 <dip204_init+0x1c0>
    return true;
800022c4:	30 18       	mov	r8,1
800022c6:	c3 98       	rjmp	80002338 <dip204_init+0x230>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800022c8:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022cc:	70 09       	ld.w	r9,r8[0x0]
800022ce:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022d2:	70 18       	ld.w	r8,r8[0x4]
800022d4:	10 39       	cp.w	r9,r8
800022d6:	e0 88 00 1a 	brls	8000230a <dip204_init+0x202>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800022da:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022de:	70 09       	ld.w	r9,r8[0x0]
800022e0:	ee f8 ff 3c 	ld.w	r8,r7[-196]
800022e4:	12 38       	cp.w	r8,r9
800022e6:	c1 02       	brcc	80002306 <dip204_init+0x1fe>
800022e8:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022ec:	70 19       	ld.w	r9,r8[0x4]
800022ee:	ee f8 ff 3c 	ld.w	r8,r7[-196]
800022f2:	12 38       	cp.w	r8,r9
800022f4:	e0 88 00 09 	brls	80002306 <dip204_init+0x1fe>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800022f8:	ee f9 ff 38 	ld.w	r9,r7[-200]
800022fc:	30 18       	mov	r8,1
800022fe:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002302:	30 18       	mov	r8,1
80002304:	c1 a8       	rjmp	80002338 <dip204_init+0x230>
    }
    return false;
80002306:	30 08       	mov	r8,0
80002308:	c1 88       	rjmp	80002338 <dip204_init+0x230>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000230a:	ee f8 ff 38 	ld.w	r8,r7[-200]
8000230e:	70 09       	ld.w	r9,r8[0x0]
80002310:	ee f8 ff 3c 	ld.w	r8,r7[-196]
80002314:	12 38       	cp.w	r8,r9
80002316:	c0 93       	brcs	80002328 <dip204_init+0x220>
80002318:	ee f8 ff 38 	ld.w	r8,r7[-200]
8000231c:	70 19       	ld.w	r9,r8[0x4]
8000231e:	ee f8 ff 3c 	ld.w	r8,r7[-196]
80002322:	12 38       	cp.w	r8,r9
80002324:	e0 88 00 09 	brls	80002336 <dip204_init+0x22e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002328:	ee f9 ff 38 	ld.w	r9,r7[-200]
8000232c:	30 18       	mov	r8,1
8000232e:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002332:	30 18       	mov	r8,1
80002334:	c0 28       	rjmp	80002338 <dip204_init+0x230>
    }
    return false;
80002336:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002338:	58 08       	cp.w	r8,0
8000233a:	ca b0       	breq	80002290 <dip204_init+0x188>
  // select the LCD chip
  dip204_select();
8000233c:	f0 1f 02 26 	mcall	80002bd4 <dip204_init+0xacc>
  // Send Command Start Byte
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002340:	e0 6c 00 f8 	mov	r12,248
80002344:	f0 1f 02 25 	mcall	80002bd8 <dip204_init+0xad0>
  // Send "extended Function Set" Command  (RE=1)
  dip204_write_byte(0x34);
80002348:	33 4c       	mov	r12,52
8000234a:	f0 1f 02 24 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
8000234e:	f0 1f 02 20 	mcall	80002bcc <dip204_init+0xac4>
80002352:	18 99       	mov	r9,r12
80002354:	30 18       	mov	r8,1
80002356:	ef 48 ff 44 	st.w	r7[-188],r8
8000235a:	ef 49 ff 40 	st.w	r7[-192],r9
8000235e:	ee f8 ff 44 	ld.w	r8,r7[-188]
80002362:	ef 48 ff 4c 	st.w	r7[-180],r8
80002366:	ee f8 ff 40 	ld.w	r8,r7[-192]
8000236a:	ef 48 ff 48 	st.w	r7[-184],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000236e:	ee fc ff 4c 	ld.w	r12,r7[-180]
80002372:	ef 4c fe 60 	st.w	r7[-416],r12
80002376:	30 0b       	mov	r11,0
80002378:	ef 4b fe 5c 	st.w	r7[-420],r11
8000237c:	ee fa ff 48 	ld.w	r10,r7[-184]
80002380:	ef 4a fe 58 	st.w	r7[-424],r10
80002384:	30 09       	mov	r9,0
80002386:	ef 49 fe 54 	st.w	r7[-428],r9
8000238a:	ee f9 fe 5c 	ld.w	r9,r7[-420]
8000238e:	ee f8 fe 58 	ld.w	r8,r7[-424]
80002392:	b1 39       	mul	r9,r8
80002394:	ee f8 fe 54 	ld.w	r8,r7[-428]
80002398:	ee fc fe 60 	ld.w	r12,r7[-416]
8000239c:	b9 38       	mul	r8,r12
8000239e:	10 09       	add	r9,r8
800023a0:	ee f8 fe 60 	ld.w	r8,r7[-416]
800023a4:	ee fc fe 58 	ld.w	r12,r7[-424]
800023a8:	f0 0c 06 4a 	mulu.d	r10,r8,r12
800023ac:	16 09       	add	r9,r11
800023ae:	12 9b       	mov	r11,r9
800023b0:	e0 68 03 e7 	mov	r8,999
800023b4:	30 09       	mov	r9,0
800023b6:	10 0a       	add	r10,r8
800023b8:	f6 09 00 4b 	adc	r11,r11,r9
800023bc:	e0 68 03 e8 	mov	r8,1000
800023c0:	30 09       	mov	r9,0
800023c2:	f0 1f 02 04 	mcall	80002bd0 <dip204_init+0xac8>
800023c6:	14 98       	mov	r8,r10
800023c8:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
800023ca:	ef 48 ff 54 	st.w	r7[-172],r8
800023ce:	ee c8 01 38 	sub	r8,r7,312
800023d2:	ef 48 ff 50 	st.w	r7[-176],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800023d6:	e1 b8 00 42 	mfsr	r8,0x108
800023da:	10 99       	mov	r9,r8
800023dc:	ee f8 ff 50 	ld.w	r8,r7[-176]
800023e0:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800023e2:	ee f8 ff 50 	ld.w	r8,r7[-176]
800023e6:	70 09       	ld.w	r9,r8[0x0]
800023e8:	ee f8 ff 54 	ld.w	r8,r7[-172]
800023ec:	10 09       	add	r9,r8
800023ee:	ee f8 ff 50 	ld.w	r8,r7[-176]
800023f2:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800023f4:	ee f9 ff 50 	ld.w	r9,r7[-176]
800023f8:	30 08       	mov	r8,0
800023fa:	f3 68 00 08 	st.b	r9[8],r8
800023fe:	ee c8 01 38 	sub	r8,r7,312
80002402:	ef 48 ff 58 	st.w	r7[-168],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002406:	e1 b8 00 42 	mfsr	r8,0x108
8000240a:	ef 48 ff 5c 	st.w	r7[-164],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000240e:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002412:	f1 39 00 08 	ld.ub	r9,r8[8]
80002416:	30 28       	mov	r8,2
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c0 31       	brne	80002422 <dip204_init+0x31a>
    return false;
8000241e:	30 08       	mov	r8,0
80002420:	c4 38       	rjmp	800024a6 <dip204_init+0x39e>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002422:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002426:	f1 39 00 08 	ld.ub	r9,r8[8]
8000242a:	30 18       	mov	r8,1
8000242c:	f0 09 18 00 	cp.b	r9,r8
80002430:	c0 31       	brne	80002436 <dip204_init+0x32e>
    return true;
80002432:	30 18       	mov	r8,1
80002434:	c3 98       	rjmp	800024a6 <dip204_init+0x39e>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002436:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000243a:	70 09       	ld.w	r9,r8[0x0]
8000243c:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002440:	70 18       	ld.w	r8,r8[0x4]
80002442:	10 39       	cp.w	r9,r8
80002444:	e0 88 00 1a 	brls	80002478 <dip204_init+0x370>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002448:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000244c:	70 09       	ld.w	r9,r8[0x0]
8000244e:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002452:	12 38       	cp.w	r8,r9
80002454:	c1 02       	brcc	80002474 <dip204_init+0x36c>
80002456:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000245a:	70 19       	ld.w	r9,r8[0x4]
8000245c:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002460:	12 38       	cp.w	r8,r9
80002462:	e0 88 00 09 	brls	80002474 <dip204_init+0x36c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002466:	ee f9 ff 58 	ld.w	r9,r7[-168]
8000246a:	30 18       	mov	r8,1
8000246c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002470:	30 18       	mov	r8,1
80002472:	c1 a8       	rjmp	800024a6 <dip204_init+0x39e>
    }
    return false;
80002474:	30 08       	mov	r8,0
80002476:	c1 88       	rjmp	800024a6 <dip204_init+0x39e>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002478:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000247c:	70 09       	ld.w	r9,r8[0x0]
8000247e:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002482:	12 38       	cp.w	r8,r9
80002484:	c0 93       	brcs	80002496 <dip204_init+0x38e>
80002486:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000248a:	70 19       	ld.w	r9,r8[0x4]
8000248c:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002490:	12 38       	cp.w	r8,r9
80002492:	e0 88 00 09 	brls	800024a4 <dip204_init+0x39c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002496:	ee f9 ff 58 	ld.w	r9,r7[-168]
8000249a:	30 18       	mov	r8,1
8000249c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800024a0:	30 18       	mov	r8,1
800024a2:	c0 28       	rjmp	800024a6 <dip204_init+0x39e>
    }
    return false;
800024a4:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800024a6:	58 08       	cp.w	r8,0
800024a8:	ca b0       	breq	800023fe <dip204_init+0x2f6>
  // Send "Enter 4-Line Mode" Command
  dip204_write_byte(0x09);
800024aa:	30 9c       	mov	r12,9
800024ac:	f0 1f 01 cb 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
800024b0:	f0 1f 01 c7 	mcall	80002bcc <dip204_init+0xac4>
800024b4:	18 99       	mov	r9,r12
800024b6:	30 18       	mov	r8,1
800024b8:	ef 48 ff 64 	st.w	r7[-156],r8
800024bc:	ef 49 ff 60 	st.w	r7[-160],r9
800024c0:	ee f8 ff 64 	ld.w	r8,r7[-156]
800024c4:	ef 48 ff 6c 	st.w	r7[-148],r8
800024c8:	ee f8 ff 60 	ld.w	r8,r7[-160]
800024cc:	ef 48 ff 68 	st.w	r7[-152],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800024d0:	ee fb ff 6c 	ld.w	r11,r7[-148]
800024d4:	ef 4b fe 70 	st.w	r7[-400],r11
800024d8:	30 0a       	mov	r10,0
800024da:	ef 4a fe 6c 	st.w	r7[-404],r10
800024de:	ee f9 ff 68 	ld.w	r9,r7[-152]
800024e2:	ef 49 fe 68 	st.w	r7[-408],r9
800024e6:	30 08       	mov	r8,0
800024e8:	ef 48 fe 64 	st.w	r7[-412],r8
800024ec:	ee f9 fe 6c 	ld.w	r9,r7[-404]
800024f0:	ee fc fe 68 	ld.w	r12,r7[-408]
800024f4:	b9 39       	mul	r9,r12
800024f6:	ee f8 fe 64 	ld.w	r8,r7[-412]
800024fa:	ee fb fe 70 	ld.w	r11,r7[-400]
800024fe:	b7 38       	mul	r8,r11
80002500:	10 09       	add	r9,r8
80002502:	ee f8 fe 70 	ld.w	r8,r7[-400]
80002506:	ee fc fe 68 	ld.w	r12,r7[-408]
8000250a:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000250e:	16 09       	add	r9,r11
80002510:	12 9b       	mov	r11,r9
80002512:	e0 68 03 e7 	mov	r8,999
80002516:	30 09       	mov	r9,0
80002518:	10 0a       	add	r10,r8
8000251a:	f6 09 00 4b 	adc	r11,r11,r9
8000251e:	e0 68 03 e8 	mov	r8,1000
80002522:	30 09       	mov	r9,0
80002524:	f0 1f 01 ab 	mcall	80002bd0 <dip204_init+0xac8>
80002528:	14 98       	mov	r8,r10
8000252a:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000252c:	ef 48 ff 74 	st.w	r7[-140],r8
80002530:	ee c8 01 2c 	sub	r8,r7,300
80002534:	ef 48 ff 70 	st.w	r7[-144],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002538:	e1 b8 00 42 	mfsr	r8,0x108
8000253c:	10 99       	mov	r9,r8
8000253e:	ee f8 ff 70 	ld.w	r8,r7[-144]
80002542:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002544:	ee f8 ff 70 	ld.w	r8,r7[-144]
80002548:	70 09       	ld.w	r9,r8[0x0]
8000254a:	ee f8 ff 74 	ld.w	r8,r7[-140]
8000254e:	10 09       	add	r9,r8
80002550:	ee f8 ff 70 	ld.w	r8,r7[-144]
80002554:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002556:	ee f9 ff 70 	ld.w	r9,r7[-144]
8000255a:	30 08       	mov	r8,0
8000255c:	f3 68 00 08 	st.b	r9[8],r8
80002560:	ee c8 01 2c 	sub	r8,r7,300
80002564:	ef 48 ff 78 	st.w	r7[-136],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002568:	e1 b8 00 42 	mfsr	r8,0x108
8000256c:	ef 48 ff 7c 	st.w	r7[-132],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002570:	ee f8 ff 78 	ld.w	r8,r7[-136]
80002574:	f1 39 00 08 	ld.ub	r9,r8[8]
80002578:	30 28       	mov	r8,2
8000257a:	f0 09 18 00 	cp.b	r9,r8
8000257e:	c0 31       	brne	80002584 <dip204_init+0x47c>
    return false;
80002580:	30 08       	mov	r8,0
80002582:	c4 38       	rjmp	80002608 <dip204_init+0x500>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002584:	ee f8 ff 78 	ld.w	r8,r7[-136]
80002588:	f1 39 00 08 	ld.ub	r9,r8[8]
8000258c:	30 18       	mov	r8,1
8000258e:	f0 09 18 00 	cp.b	r9,r8
80002592:	c0 31       	brne	80002598 <dip204_init+0x490>
    return true;
80002594:	30 18       	mov	r8,1
80002596:	c3 98       	rjmp	80002608 <dip204_init+0x500>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002598:	ee f8 ff 78 	ld.w	r8,r7[-136]
8000259c:	70 09       	ld.w	r9,r8[0x0]
8000259e:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025a2:	70 18       	ld.w	r8,r8[0x4]
800025a4:	10 39       	cp.w	r9,r8
800025a6:	e0 88 00 1a 	brls	800025da <dip204_init+0x4d2>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800025aa:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025ae:	70 09       	ld.w	r9,r8[0x0]
800025b0:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025b4:	12 38       	cp.w	r8,r9
800025b6:	c1 02       	brcc	800025d6 <dip204_init+0x4ce>
800025b8:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025bc:	70 19       	ld.w	r9,r8[0x4]
800025be:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025c2:	12 38       	cp.w	r8,r9
800025c4:	e0 88 00 09 	brls	800025d6 <dip204_init+0x4ce>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800025c8:	ee f9 ff 78 	ld.w	r9,r7[-136]
800025cc:	30 18       	mov	r8,1
800025ce:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800025d2:	30 18       	mov	r8,1
800025d4:	c1 a8       	rjmp	80002608 <dip204_init+0x500>
    }
    return false;
800025d6:	30 08       	mov	r8,0
800025d8:	c1 88       	rjmp	80002608 <dip204_init+0x500>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800025da:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025de:	70 09       	ld.w	r9,r8[0x0]
800025e0:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025e4:	12 38       	cp.w	r8,r9
800025e6:	c0 93       	brcs	800025f8 <dip204_init+0x4f0>
800025e8:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025ec:	70 19       	ld.w	r9,r8[0x4]
800025ee:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025f2:	12 38       	cp.w	r8,r9
800025f4:	e0 88 00 09 	brls	80002606 <dip204_init+0x4fe>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800025f8:	ee f9 ff 78 	ld.w	r9,r7[-136]
800025fc:	30 18       	mov	r8,1
800025fe:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002602:	30 18       	mov	r8,1
80002604:	c0 28       	rjmp	80002608 <dip204_init+0x500>
    }
    return false;
80002606:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002608:	58 08       	cp.w	r8,0
8000260a:	ca b0       	breq	80002560 <dip204_init+0x458>
  // Send "Function Set" Command (RE=0)
  dip204_write_byte(0x30);
8000260c:	33 0c       	mov	r12,48
8000260e:	f0 1f 01 73 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
80002612:	f0 1f 01 6f 	mcall	80002bcc <dip204_init+0xac4>
80002616:	18 99       	mov	r9,r12
80002618:	30 18       	mov	r8,1
8000261a:	ef 48 ff 84 	st.w	r7[-124],r8
8000261e:	ef 49 ff 80 	st.w	r7[-128],r9
80002622:	ee f8 ff 84 	ld.w	r8,r7[-124]
80002626:	ef 48 ff 8c 	st.w	r7[-116],r8
8000262a:	ee f8 ff 80 	ld.w	r8,r7[-128]
8000262e:	ef 48 ff 88 	st.w	r7[-120],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002632:	ee fb ff 8c 	ld.w	r11,r7[-116]
80002636:	ef 4b fe 80 	st.w	r7[-384],r11
8000263a:	30 0a       	mov	r10,0
8000263c:	ef 4a fe 7c 	st.w	r7[-388],r10
80002640:	ee f9 ff 88 	ld.w	r9,r7[-120]
80002644:	ef 49 fe 78 	st.w	r7[-392],r9
80002648:	30 08       	mov	r8,0
8000264a:	ef 48 fe 74 	st.w	r7[-396],r8
8000264e:	ee f9 fe 7c 	ld.w	r9,r7[-388]
80002652:	ee fc fe 78 	ld.w	r12,r7[-392]
80002656:	b9 39       	mul	r9,r12
80002658:	ee f8 fe 74 	ld.w	r8,r7[-396]
8000265c:	ee fb fe 80 	ld.w	r11,r7[-384]
80002660:	b7 38       	mul	r8,r11
80002662:	10 09       	add	r9,r8
80002664:	ee f8 fe 80 	ld.w	r8,r7[-384]
80002668:	ee fc fe 78 	ld.w	r12,r7[-392]
8000266c:	f0 0c 06 4a 	mulu.d	r10,r8,r12
80002670:	16 09       	add	r9,r11
80002672:	12 9b       	mov	r11,r9
80002674:	e0 68 03 e7 	mov	r8,999
80002678:	30 09       	mov	r9,0
8000267a:	10 0a       	add	r10,r8
8000267c:	f6 09 00 4b 	adc	r11,r11,r9
80002680:	e0 68 03 e8 	mov	r8,1000
80002684:	30 09       	mov	r9,0
80002686:	f0 1f 01 53 	mcall	80002bd0 <dip204_init+0xac8>
8000268a:	14 98       	mov	r8,r10
8000268c:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000268e:	ef 48 ff 94 	st.w	r7[-108],r8
80002692:	ee c8 01 20 	sub	r8,r7,288
80002696:	ef 48 ff 90 	st.w	r7[-112],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000269a:	e1 b8 00 42 	mfsr	r8,0x108
8000269e:	10 99       	mov	r9,r8
800026a0:	ee f8 ff 90 	ld.w	r8,r7[-112]
800026a4:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800026a6:	ee f8 ff 90 	ld.w	r8,r7[-112]
800026aa:	70 09       	ld.w	r9,r8[0x0]
800026ac:	ee f8 ff 94 	ld.w	r8,r7[-108]
800026b0:	10 09       	add	r9,r8
800026b2:	ee f8 ff 90 	ld.w	r8,r7[-112]
800026b6:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800026b8:	ee f9 ff 90 	ld.w	r9,r7[-112]
800026bc:	30 08       	mov	r8,0
800026be:	f3 68 00 08 	st.b	r9[8],r8
800026c2:	ee c8 01 20 	sub	r8,r7,288
800026c6:	ef 48 ff 98 	st.w	r7[-104],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800026ca:	e1 b8 00 42 	mfsr	r8,0x108
800026ce:	ef 48 ff 9c 	st.w	r7[-100],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800026d2:	ee f8 ff 98 	ld.w	r8,r7[-104]
800026d6:	f1 39 00 08 	ld.ub	r9,r8[8]
800026da:	30 28       	mov	r8,2
800026dc:	f0 09 18 00 	cp.b	r9,r8
800026e0:	c0 31       	brne	800026e6 <dip204_init+0x5de>
    return false;
800026e2:	30 08       	mov	r8,0
800026e4:	c4 38       	rjmp	8000276a <dip204_init+0x662>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800026e6:	ee f8 ff 98 	ld.w	r8,r7[-104]
800026ea:	f1 39 00 08 	ld.ub	r9,r8[8]
800026ee:	30 18       	mov	r8,1
800026f0:	f0 09 18 00 	cp.b	r9,r8
800026f4:	c0 31       	brne	800026fa <dip204_init+0x5f2>
    return true;
800026f6:	30 18       	mov	r8,1
800026f8:	c3 98       	rjmp	8000276a <dip204_init+0x662>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800026fa:	ee f8 ff 98 	ld.w	r8,r7[-104]
800026fe:	70 09       	ld.w	r9,r8[0x0]
80002700:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002704:	70 18       	ld.w	r8,r8[0x4]
80002706:	10 39       	cp.w	r9,r8
80002708:	e0 88 00 1a 	brls	8000273c <dip204_init+0x634>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000270c:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002710:	70 08       	ld.w	r8,r8[0x0]
80002712:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002716:	10 39       	cp.w	r9,r8
80002718:	c1 02       	brcc	80002738 <dip204_init+0x630>
8000271a:	ee f8 ff 98 	ld.w	r8,r7[-104]
8000271e:	70 18       	ld.w	r8,r8[0x4]
80002720:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002724:	10 39       	cp.w	r9,r8
80002726:	e0 88 00 09 	brls	80002738 <dip204_init+0x630>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000272a:	ee f9 ff 98 	ld.w	r9,r7[-104]
8000272e:	30 18       	mov	r8,1
80002730:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002734:	30 18       	mov	r8,1
80002736:	c1 a8       	rjmp	8000276a <dip204_init+0x662>
    }
    return false;
80002738:	30 08       	mov	r8,0
8000273a:	c1 88       	rjmp	8000276a <dip204_init+0x662>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000273c:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002740:	70 08       	ld.w	r8,r8[0x0]
80002742:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002746:	10 39       	cp.w	r9,r8
80002748:	c0 93       	brcs	8000275a <dip204_init+0x652>
8000274a:	ee f8 ff 98 	ld.w	r8,r7[-104]
8000274e:	70 18       	ld.w	r8,r8[0x4]
80002750:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002754:	10 39       	cp.w	r9,r8
80002756:	e0 88 00 09 	brls	80002768 <dip204_init+0x660>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000275a:	ee f9 ff 98 	ld.w	r9,r7[-104]
8000275e:	30 18       	mov	r8,1
80002760:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002764:	30 18       	mov	r8,1
80002766:	c0 28       	rjmp	8000276a <dip204_init+0x662>
    }
    return false;
80002768:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
8000276a:	58 08       	cp.w	r8,0
8000276c:	ca b0       	breq	800026c2 <dip204_init+0x5ba>
  // Send "Display On Command: Display On, Cursor On, Blink On"
  dip204_write_byte(0x0F);
8000276e:	30 fc       	mov	r12,15
80002770:	f0 1f 01 1a 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
80002774:	f0 1f 01 16 	mcall	80002bcc <dip204_init+0xac4>
80002778:	18 98       	mov	r8,r12
8000277a:	30 19       	mov	r9,1
8000277c:	ef 49 ff a4 	st.w	r7[-92],r9
80002780:	ef 48 ff a0 	st.w	r7[-96],r8
80002784:	ee f8 ff a4 	ld.w	r8,r7[-92]
80002788:	ef 48 ff ac 	st.w	r7[-84],r8
8000278c:	ee f8 ff a0 	ld.w	r8,r7[-96]
80002790:	ef 48 ff a8 	st.w	r7[-88],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002794:	ee fb ff ac 	ld.w	r11,r7[-84]
80002798:	ef 4b fe 90 	st.w	r7[-368],r11
8000279c:	30 0a       	mov	r10,0
8000279e:	ef 4a fe 8c 	st.w	r7[-372],r10
800027a2:	ee f9 ff a8 	ld.w	r9,r7[-88]
800027a6:	ef 49 fe 88 	st.w	r7[-376],r9
800027aa:	30 08       	mov	r8,0
800027ac:	ef 48 fe 84 	st.w	r7[-380],r8
800027b0:	ee fa fe 8c 	ld.w	r10,r7[-372]
800027b4:	ee fc fe 88 	ld.w	r12,r7[-376]
800027b8:	b9 3a       	mul	r10,r12
800027ba:	ee f8 fe 84 	ld.w	r8,r7[-380]
800027be:	ee fb fe 90 	ld.w	r11,r7[-368]
800027c2:	b7 38       	mul	r8,r11
800027c4:	10 0a       	add	r10,r8
800027c6:	ee fc fe 90 	ld.w	r12,r7[-368]
800027ca:	ee fb fe 88 	ld.w	r11,r7[-376]
800027ce:	f8 0b 06 48 	mulu.d	r8,r12,r11
800027d2:	12 0a       	add	r10,r9
800027d4:	14 99       	mov	r9,r10
800027d6:	e0 6a 03 e7 	mov	r10,999
800027da:	30 0b       	mov	r11,0
800027dc:	f0 0a 00 0a 	add	r10,r8,r10
800027e0:	f2 0b 00 4b 	adc	r11,r9,r11
800027e4:	e0 68 03 e8 	mov	r8,1000
800027e8:	30 09       	mov	r9,0
800027ea:	f0 1f 00 fa 	mcall	80002bd0 <dip204_init+0xac8>
800027ee:	14 98       	mov	r8,r10
800027f0:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
800027f2:	ef 48 ff b4 	st.w	r7[-76],r8
800027f6:	ee c8 01 14 	sub	r8,r7,276
800027fa:	ef 48 ff b0 	st.w	r7[-80],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800027fe:	e1 b8 00 42 	mfsr	r8,0x108
80002802:	10 99       	mov	r9,r8
80002804:	ee f8 ff b0 	ld.w	r8,r7[-80]
80002808:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000280a:	ee f8 ff b0 	ld.w	r8,r7[-80]
8000280e:	70 09       	ld.w	r9,r8[0x0]
80002810:	ee f8 ff b4 	ld.w	r8,r7[-76]
80002814:	10 09       	add	r9,r8
80002816:	ee f8 ff b0 	ld.w	r8,r7[-80]
8000281a:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000281c:	ee f9 ff b0 	ld.w	r9,r7[-80]
80002820:	30 08       	mov	r8,0
80002822:	f3 68 00 08 	st.b	r9[8],r8
80002826:	ee c8 01 14 	sub	r8,r7,276
8000282a:	ef 48 ff b8 	st.w	r7[-72],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000282e:	e1 b8 00 42 	mfsr	r8,0x108
80002832:	ef 48 ff bc 	st.w	r7[-68],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002836:	ee f8 ff b8 	ld.w	r8,r7[-72]
8000283a:	f1 39 00 08 	ld.ub	r9,r8[8]
8000283e:	30 28       	mov	r8,2
80002840:	f0 09 18 00 	cp.b	r9,r8
80002844:	c0 31       	brne	8000284a <dip204_init+0x742>
    return false;
80002846:	30 08       	mov	r8,0
80002848:	c4 38       	rjmp	800028ce <dip204_init+0x7c6>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
8000284a:	ee f8 ff b8 	ld.w	r8,r7[-72]
8000284e:	f1 39 00 08 	ld.ub	r9,r8[8]
80002852:	30 18       	mov	r8,1
80002854:	f0 09 18 00 	cp.b	r9,r8
80002858:	c0 31       	brne	8000285e <dip204_init+0x756>
    return true;
8000285a:	30 18       	mov	r8,1
8000285c:	c3 98       	rjmp	800028ce <dip204_init+0x7c6>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000285e:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002862:	70 09       	ld.w	r9,r8[0x0]
80002864:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002868:	70 18       	ld.w	r8,r8[0x4]
8000286a:	10 39       	cp.w	r9,r8
8000286c:	e0 88 00 1a 	brls	800028a0 <dip204_init+0x798>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002870:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002874:	70 08       	ld.w	r8,r8[0x0]
80002876:	ee f9 ff bc 	ld.w	r9,r7[-68]
8000287a:	10 39       	cp.w	r9,r8
8000287c:	c1 02       	brcc	8000289c <dip204_init+0x794>
8000287e:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002882:	70 18       	ld.w	r8,r8[0x4]
80002884:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002888:	10 39       	cp.w	r9,r8
8000288a:	e0 88 00 09 	brls	8000289c <dip204_init+0x794>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000288e:	ee f9 ff b8 	ld.w	r9,r7[-72]
80002892:	30 18       	mov	r8,1
80002894:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002898:	30 18       	mov	r8,1
8000289a:	c1 a8       	rjmp	800028ce <dip204_init+0x7c6>
    }
    return false;
8000289c:	30 08       	mov	r8,0
8000289e:	c1 88       	rjmp	800028ce <dip204_init+0x7c6>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800028a0:	ee f8 ff b8 	ld.w	r8,r7[-72]
800028a4:	70 08       	ld.w	r8,r8[0x0]
800028a6:	ee f9 ff bc 	ld.w	r9,r7[-68]
800028aa:	10 39       	cp.w	r9,r8
800028ac:	c0 93       	brcs	800028be <dip204_init+0x7b6>
800028ae:	ee f8 ff b8 	ld.w	r8,r7[-72]
800028b2:	70 18       	ld.w	r8,r8[0x4]
800028b4:	ee f9 ff bc 	ld.w	r9,r7[-68]
800028b8:	10 39       	cp.w	r9,r8
800028ba:	e0 88 00 09 	brls	800028cc <dip204_init+0x7c4>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800028be:	ee f9 ff b8 	ld.w	r9,r7[-72]
800028c2:	30 18       	mov	r8,1
800028c4:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800028c8:	30 18       	mov	r8,1
800028ca:	c0 28       	rjmp	800028ce <dip204_init+0x7c6>
    }
    return false;
800028cc:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800028ce:	58 08       	cp.w	r8,0
800028d0:	ca b0       	breq	80002826 <dip204_init+0x71e>
  // Send "Display Clear" Command
  dip204_write_byte(0x01);
800028d2:	30 1c       	mov	r12,1
800028d4:	f0 1f 00 c1 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(5);
800028d8:	f0 1f 00 bd 	mcall	80002bcc <dip204_init+0xac4>
800028dc:	18 98       	mov	r8,r12
800028de:	30 59       	mov	r9,5
800028e0:	ef 49 ff c4 	st.w	r7[-60],r9
800028e4:	ef 48 ff c0 	st.w	r7[-64],r8
800028e8:	ee f8 ff c4 	ld.w	r8,r7[-60]
800028ec:	ef 48 ff cc 	st.w	r7[-52],r8
800028f0:	ee f8 ff c0 	ld.w	r8,r7[-64]
800028f4:	ef 48 ff c8 	st.w	r7[-56],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800028f8:	ee fa ff cc 	ld.w	r10,r7[-52]
800028fc:	ef 4a fe a0 	st.w	r7[-352],r10
80002900:	30 09       	mov	r9,0
80002902:	ef 49 fe 9c 	st.w	r7[-356],r9
80002906:	ee f8 ff c8 	ld.w	r8,r7[-56]
8000290a:	ef 48 fe 98 	st.w	r7[-360],r8
8000290e:	30 0c       	mov	r12,0
80002910:	ef 4c fe 94 	st.w	r7[-364],r12
80002914:	ee fa fe 9c 	ld.w	r10,r7[-356]
80002918:	ee fb fe 98 	ld.w	r11,r7[-360]
8000291c:	b7 3a       	mul	r10,r11
8000291e:	ee f8 fe 94 	ld.w	r8,r7[-364]
80002922:	ee f9 fe a0 	ld.w	r9,r7[-352]
80002926:	b3 38       	mul	r8,r9
80002928:	10 0a       	add	r10,r8
8000292a:	ee fc fe a0 	ld.w	r12,r7[-352]
8000292e:	ee fb fe 98 	ld.w	r11,r7[-360]
80002932:	f8 0b 06 48 	mulu.d	r8,r12,r11
80002936:	12 0a       	add	r10,r9
80002938:	14 99       	mov	r9,r10
8000293a:	e0 6a 03 e7 	mov	r10,999
8000293e:	30 0b       	mov	r11,0
80002940:	f0 0a 00 0a 	add	r10,r8,r10
80002944:	f2 0b 00 4b 	adc	r11,r9,r11
80002948:	e0 68 03 e8 	mov	r8,1000
8000294c:	30 09       	mov	r9,0
8000294e:	f0 1f 00 a1 	mcall	80002bd0 <dip204_init+0xac8>
80002952:	14 98       	mov	r8,r10
80002954:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002956:	ef 48 ff d4 	st.w	r7[-44],r8
8000295a:	ee c8 01 08 	sub	r8,r7,264
8000295e:	ef 48 ff d0 	st.w	r7[-48],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002962:	e1 b8 00 42 	mfsr	r8,0x108
80002966:	10 99       	mov	r9,r8
80002968:	ee f8 ff d0 	ld.w	r8,r7[-48]
8000296c:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000296e:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002972:	70 09       	ld.w	r9,r8[0x0]
80002974:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002978:	10 09       	add	r9,r8
8000297a:	ee f8 ff d0 	ld.w	r8,r7[-48]
8000297e:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002980:	ee f9 ff d0 	ld.w	r9,r7[-48]
80002984:	30 08       	mov	r8,0
80002986:	f3 68 00 08 	st.b	r9[8],r8
8000298a:	ee c8 01 08 	sub	r8,r7,264
8000298e:	ef 48 ff d8 	st.w	r7[-40],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002992:	e1 b8 00 42 	mfsr	r8,0x108
80002996:	ef 48 ff dc 	st.w	r7[-36],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000299a:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000299e:	f1 39 00 08 	ld.ub	r9,r8[8]
800029a2:	30 28       	mov	r8,2
800029a4:	f0 09 18 00 	cp.b	r9,r8
800029a8:	c0 31       	brne	800029ae <dip204_init+0x8a6>
    return false;
800029aa:	30 08       	mov	r8,0
800029ac:	c4 38       	rjmp	80002a32 <dip204_init+0x92a>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800029ae:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029b2:	f1 39 00 08 	ld.ub	r9,r8[8]
800029b6:	30 18       	mov	r8,1
800029b8:	f0 09 18 00 	cp.b	r9,r8
800029bc:	c0 31       	brne	800029c2 <dip204_init+0x8ba>
    return true;
800029be:	30 18       	mov	r8,1
800029c0:	c3 98       	rjmp	80002a32 <dip204_init+0x92a>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800029c2:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029c6:	70 09       	ld.w	r9,r8[0x0]
800029c8:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029cc:	70 18       	ld.w	r8,r8[0x4]
800029ce:	10 39       	cp.w	r9,r8
800029d0:	e0 88 00 1a 	brls	80002a04 <dip204_init+0x8fc>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800029d4:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029d8:	70 08       	ld.w	r8,r8[0x0]
800029da:	ee f9 ff dc 	ld.w	r9,r7[-36]
800029de:	10 39       	cp.w	r9,r8
800029e0:	c1 02       	brcc	80002a00 <dip204_init+0x8f8>
800029e2:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029e6:	70 18       	ld.w	r8,r8[0x4]
800029e8:	ee f9 ff dc 	ld.w	r9,r7[-36]
800029ec:	10 39       	cp.w	r9,r8
800029ee:	e0 88 00 09 	brls	80002a00 <dip204_init+0x8f8>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800029f2:	ee f9 ff d8 	ld.w	r9,r7[-40]
800029f6:	30 18       	mov	r8,1
800029f8:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800029fc:	30 18       	mov	r8,1
800029fe:	c1 a8       	rjmp	80002a32 <dip204_init+0x92a>
    }
    return false;
80002a00:	30 08       	mov	r8,0
80002a02:	c1 88       	rjmp	80002a32 <dip204_init+0x92a>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002a04:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002a08:	70 08       	ld.w	r8,r8[0x0]
80002a0a:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002a0e:	10 39       	cp.w	r9,r8
80002a10:	c0 93       	brcs	80002a22 <dip204_init+0x91a>
80002a12:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002a16:	70 18       	ld.w	r8,r8[0x4]
80002a18:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002a1c:	10 39       	cp.w	r9,r8
80002a1e:	e0 88 00 09 	brls	80002a30 <dip204_init+0x928>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002a22:	ee f9 ff d8 	ld.w	r9,r7[-40]
80002a26:	30 18       	mov	r8,1
80002a28:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002a2c:	30 18       	mov	r8,1
80002a2e:	c0 28       	rjmp	80002a32 <dip204_init+0x92a>
    }
    return false;
80002a30:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002a32:	58 08       	cp.w	r8,0
80002a34:	ca b0       	breq	8000298a <dip204_init+0x882>
  // Send "Entry Mode Set Command: Increment Mode, Entire Shift off"
  dip204_write_byte(0x06);
80002a36:	30 6c       	mov	r12,6
80002a38:	f0 1f 00 68 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
80002a3c:	f0 1f 00 64 	mcall	80002bcc <dip204_init+0xac4>
80002a40:	18 98       	mov	r8,r12
80002a42:	30 19       	mov	r9,1
80002a44:	ef 49 ff e4 	st.w	r7[-28],r9
80002a48:	ef 48 ff e0 	st.w	r7[-32],r8
80002a4c:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002a50:	ef 48 ff ec 	st.w	r7[-20],r8
80002a54:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002a58:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002a5c:	ee fa ff ec 	ld.w	r10,r7[-20]
80002a60:	ef 4a fe b0 	st.w	r7[-336],r10
80002a64:	30 09       	mov	r9,0
80002a66:	ef 49 fe ac 	st.w	r7[-340],r9
80002a6a:	ee f8 ff e8 	ld.w	r8,r7[-24]
80002a6e:	ef 48 fe a8 	st.w	r7[-344],r8
80002a72:	30 0c       	mov	r12,0
80002a74:	ef 4c fe a4 	st.w	r7[-348],r12
80002a78:	ee fa fe ac 	ld.w	r10,r7[-340]
80002a7c:	ee fb fe a8 	ld.w	r11,r7[-344]
80002a80:	b7 3a       	mul	r10,r11
80002a82:	ee f8 fe a4 	ld.w	r8,r7[-348]
80002a86:	ee f9 fe b0 	ld.w	r9,r7[-336]
80002a8a:	b3 38       	mul	r8,r9
80002a8c:	10 0a       	add	r10,r8
80002a8e:	ee fc fe b0 	ld.w	r12,r7[-336]
80002a92:	ee fb fe a8 	ld.w	r11,r7[-344]
80002a96:	f8 0b 06 48 	mulu.d	r8,r12,r11
80002a9a:	12 0a       	add	r10,r9
80002a9c:	14 99       	mov	r9,r10
80002a9e:	e0 6a 03 e7 	mov	r10,999
80002aa2:	30 0b       	mov	r11,0
80002aa4:	f0 0a 00 0a 	add	r10,r8,r10
80002aa8:	f2 0b 00 4b 	adc	r11,r9,r11
80002aac:	e0 68 03 e8 	mov	r8,1000
80002ab0:	30 09       	mov	r9,0
80002ab2:	f0 1f 00 48 	mcall	80002bd0 <dip204_init+0xac8>
80002ab6:	14 98       	mov	r8,r10
80002ab8:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002aba:	ef 48 ff f4 	st.w	r7[-12],r8
80002abe:	ee c8 00 fc 	sub	r8,r7,252
80002ac2:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002ac6:	e1 b8 00 42 	mfsr	r8,0x108
80002aca:	10 99       	mov	r9,r8
80002acc:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ad0:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002ad2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ad6:	70 09       	ld.w	r9,r8[0x0]
80002ad8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002adc:	10 09       	add	r9,r8
80002ade:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ae2:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002ae4:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002ae8:	30 08       	mov	r8,0
80002aea:	f3 68 00 08 	st.b	r9[8],r8
80002aee:	ee c8 00 fc 	sub	r8,r7,252
80002af2:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002af6:	e1 b8 00 42 	mfsr	r8,0x108
80002afa:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002afe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b02:	f1 39 00 08 	ld.ub	r9,r8[8]
80002b06:	30 28       	mov	r8,2
80002b08:	f0 09 18 00 	cp.b	r9,r8
80002b0c:	c0 31       	brne	80002b12 <dip204_init+0xa0a>
    return false;
80002b0e:	30 08       	mov	r8,0
80002b10:	c4 38       	rjmp	80002b96 <dip204_init+0xa8e>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002b12:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b16:	f1 39 00 08 	ld.ub	r9,r8[8]
80002b1a:	30 18       	mov	r8,1
80002b1c:	f0 09 18 00 	cp.b	r9,r8
80002b20:	c0 31       	brne	80002b26 <dip204_init+0xa1e>
    return true;
80002b22:	30 18       	mov	r8,1
80002b24:	c3 98       	rjmp	80002b96 <dip204_init+0xa8e>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002b26:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b2a:	70 09       	ld.w	r9,r8[0x0]
80002b2c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b30:	70 18       	ld.w	r8,r8[0x4]
80002b32:	10 39       	cp.w	r9,r8
80002b34:	e0 88 00 1a 	brls	80002b68 <dip204_init+0xa60>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002b38:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b3c:	70 08       	ld.w	r8,r8[0x0]
80002b3e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b42:	10 39       	cp.w	r9,r8
80002b44:	c1 02       	brcc	80002b64 <dip204_init+0xa5c>
80002b46:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b4a:	70 18       	ld.w	r8,r8[0x4]
80002b4c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b50:	10 39       	cp.w	r9,r8
80002b52:	e0 88 00 09 	brls	80002b64 <dip204_init+0xa5c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002b56:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002b5a:	30 18       	mov	r8,1
80002b5c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002b60:	30 18       	mov	r8,1
80002b62:	c1 a8       	rjmp	80002b96 <dip204_init+0xa8e>
    }
    return false;
80002b64:	30 08       	mov	r8,0
80002b66:	c1 88       	rjmp	80002b96 <dip204_init+0xa8e>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002b68:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b6c:	70 08       	ld.w	r8,r8[0x0]
80002b6e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b72:	10 39       	cp.w	r9,r8
80002b74:	c0 93       	brcs	80002b86 <dip204_init+0xa7e>
80002b76:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b7a:	70 18       	ld.w	r8,r8[0x4]
80002b7c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b80:	10 39       	cp.w	r9,r8
80002b82:	e0 88 00 09 	brls	80002b94 <dip204_init+0xa8c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002b86:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002b8a:	30 18       	mov	r8,1
80002b8c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002b90:	30 18       	mov	r8,1
80002b92:	c0 28       	rjmp	80002b96 <dip204_init+0xa8e>
    }
    return false;
80002b94:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002b96:	58 08       	cp.w	r8,0
80002b98:	ca b0       	breq	80002aee <dip204_init+0x9e6>
  dip204_wait_busy();
80002b9a:	f0 1f 00 11 	mcall	80002bdc <dip204_init+0xad4>
  // unselect chip
  dip204_unselect();
80002b9e:	f0 1f 00 11 	mcall	80002be0 <dip204_init+0xad8>
}
80002ba2:	29 5d       	sub	sp,-428
80002ba4:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
80002ba8:	00 00       	add	r0,r0
80002baa:	00 1c       	sub	r12,r0
80002bac:	80 00       	ld.sh	r0,r0[0x0]
80002bae:	41 c0       	lddsp	r0,sp[0x70]
80002bb0:	80 00       	ld.sh	r0,r0[0x0]
80002bb2:	31 b8       	mov	r8,27
80002bb4:	00 00       	add	r0,r0
80002bb6:	05 50       	ld.sh	r0,--r2
80002bb8:	00 00       	add	r0,r0
80002bba:	05 54       	ld.sh	r4,--r2
80002bbc:	80 00       	ld.sh	r0,r0[0x0]
80002bbe:	32 4c       	mov	r12,36
80002bc0:	80 00       	ld.sh	r0,r0[0x0]
80002bc2:	32 d4       	mov	r4,45
80002bc4:	80 00       	ld.sh	r0,r0[0x0]
80002bc6:	43 38       	lddsp	r8,sp[0xcc]
80002bc8:	80 00       	ld.sh	r0,r0[0x0]
80002bca:	42 d0       	lddsp	r0,sp[0xb4]
80002bcc:	80 00       	ld.sh	r0,r0[0x0]
80002bce:	20 f0       	sub	r0,15
80002bd0:	80 00       	ld.sh	r0,r0[0x0]
80002bd2:	66 94       	ld.w	r4,r3[0x24]
80002bd4:	80 00       	ld.sh	r0,r0[0x0]
80002bd6:	2f 50       	sub	r0,-11
80002bd8:	80 00       	ld.sh	r0,r0[0x0]
80002bda:	2f 80       	sub	r0,-8
80002bdc:	80 00       	ld.sh	r0,r0[0x0]
80002bde:	30 64       	mov	r4,6
80002be0:	80 00       	ld.sh	r0,r0[0x0]
80002be2:	2f 68       	sub	r8,-10

80002be4 <dip204_hide_cursor>:
  dip204_unselect();
}


void dip204_hide_cursor(void)
{
80002be4:	eb cd 40 80 	pushm	r7,lr
80002be8:	1a 97       	mov	r7,sp
  /* select the LCD chip */
  dip204_select();
80002bea:	f0 1f 00 08 	mcall	80002c08 <dip204_hide_cursor+0x24>
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002bee:	e0 6c 00 f8 	mov	r12,248
80002bf2:	f0 1f 00 07 	mcall	80002c0c <dip204_hide_cursor+0x28>
  /* Send "Display On Command: Display On, Cursor On, Blink On" */
  dip204_write_byte(0x0C);
80002bf6:	30 cc       	mov	r12,12
80002bf8:	f0 1f 00 05 	mcall	80002c0c <dip204_hide_cursor+0x28>
  dip204_wait_busy();
80002bfc:	f0 1f 00 05 	mcall	80002c10 <dip204_hide_cursor+0x2c>
  /* unselect chip */
  dip204_unselect();
80002c00:	f0 1f 00 05 	mcall	80002c14 <dip204_hide_cursor+0x30>
}
80002c04:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c08:	80 00       	ld.sh	r0,r0[0x0]
80002c0a:	2f 50       	sub	r0,-11
80002c0c:	80 00       	ld.sh	r0,r0[0x0]
80002c0e:	2f 80       	sub	r0,-8
80002c10:	80 00       	ld.sh	r0,r0[0x0]
80002c12:	30 64       	mov	r4,6
80002c14:	80 00       	ld.sh	r0,r0[0x0]
80002c16:	2f 68       	sub	r8,-10

80002c18 <dip204_set_cursor_position>:
  dip204_set_cursor_position(column, line);
}


void dip204_set_cursor_position(unsigned char column, unsigned char line)
{
80002c18:	eb cd 40 80 	pushm	r7,lr
80002c1c:	1a 97       	mov	r7,sp
80002c1e:	20 3d       	sub	sp,12
80002c20:	18 99       	mov	r9,r12
80002c22:	16 98       	mov	r8,r11
80002c24:	ef 69 ff f8 	st.b	r7[-8],r9
80002c28:	ef 68 ff f4 	st.b	r7[-12],r8
  unsigned char address = 0;
80002c2c:	30 08       	mov	r8,0
80002c2e:	ef 68 ff ff 	st.b	r7[-1],r8

  dip204_select();
80002c32:	f0 1f 00 18 	mcall	80002c90 <dip204_set_cursor_position+0x78>
  if ((column <= 20) && (line <= 4))
80002c36:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80002c3a:	31 48       	mov	r8,20
80002c3c:	f0 09 18 00 	cp.b	r9,r8
80002c40:	e0 8b 00 17 	brhi	80002c6e <dip204_set_cursor_position+0x56>
80002c44:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80002c48:	30 48       	mov	r8,4
80002c4a:	f0 09 18 00 	cp.b	r9,r8
80002c4e:	e0 8b 00 10 	brhi	80002c6e <dip204_set_cursor_position+0x56>
  {
    /* Calculate DDRAM address from line and row values */
    address = ( (line-1) * 32 ) + ( column-1 ) + 128;
80002c52:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002c56:	20 18       	sub	r8,1
80002c58:	5c 58       	castu.b	r8
80002c5a:	a5 78       	lsl	r8,0x5
80002c5c:	5c 58       	castu.b	r8
80002c5e:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80002c62:	f2 08 00 08 	add	r8,r9,r8
80002c66:	5c 58       	castu.b	r8
80002c68:	28 18       	sub	r8,-127
80002c6a:	ef 68 ff ff 	st.b	r7[-1],r8
  }
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002c6e:	e0 6c 00 f8 	mov	r12,248
80002c72:	f0 1f 00 09 	mcall	80002c94 <dip204_set_cursor_position+0x7c>
  /* Send Address lower Nibble */
  dip204_write_byte(address);
80002c76:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002c7a:	10 9c       	mov	r12,r8
80002c7c:	f0 1f 00 06 	mcall	80002c94 <dip204_set_cursor_position+0x7c>
  dip204_wait_busy();
80002c80:	f0 1f 00 06 	mcall	80002c98 <dip204_set_cursor_position+0x80>
  dip204_unselect();
80002c84:	f0 1f 00 06 	mcall	80002c9c <dip204_set_cursor_position+0x84>
}
80002c88:	2f dd       	sub	sp,-12
80002c8a:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c8e:	00 00       	add	r0,r0
80002c90:	80 00       	ld.sh	r0,r0[0x0]
80002c92:	2f 50       	sub	r0,-11
80002c94:	80 00       	ld.sh	r0,r0[0x0]
80002c96:	2f 80       	sub	r0,-8
80002c98:	80 00       	ld.sh	r0,r0[0x0]
80002c9a:	30 64       	mov	r4,6
80002c9c:	80 00       	ld.sh	r0,r0[0x0]
80002c9e:	2f 68       	sub	r8,-10

80002ca0 <dip204_clear_display>:


void dip204_clear_display(void)
{
80002ca0:	eb cd 40 8f 	pushm	r0-r3,r7,lr
80002ca4:	1a 97       	mov	r7,sp
80002ca6:	20 bd       	sub	sp,44
  dip204_select();
80002ca8:	f0 1f 00 57 	mcall	80002e04 <dip204_clear_display+0x164>
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002cac:	e0 6c 00 f8 	mov	r12,248
80002cb0:	f0 1f 00 56 	mcall	80002e08 <dip204_clear_display+0x168>
  /* Send Display Clear Command */
  dip204_write_byte(0x01);
80002cb4:	30 1c       	mov	r12,1
80002cb6:	f0 1f 00 55 	mcall	80002e08 <dip204_clear_display+0x168>
  /* Wait for command execution */
  delay_ms(4);
80002cba:	f0 1f 00 55 	mcall	80002e0c <dip204_clear_display+0x16c>
80002cbe:	18 98       	mov	r8,r12
80002cc0:	30 49       	mov	r9,4
80002cc2:	ef 49 ff e4 	st.w	r7[-28],r9
80002cc6:	ef 48 ff e0 	st.w	r7[-32],r8
80002cca:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002cce:	ef 48 ff ec 	st.w	r7[-20],r8
80002cd2:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002cd6:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002cda:	ee f0 ff ec 	ld.w	r0,r7[-20]
80002cde:	30 01       	mov	r1,0
80002ce0:	ee f2 ff e8 	ld.w	r2,r7[-24]
80002ce4:	30 03       	mov	r3,0
80002ce6:	e2 02 02 4a 	mul	r10,r1,r2
80002cea:	e6 00 02 48 	mul	r8,r3,r0
80002cee:	10 0a       	add	r10,r8
80002cf0:	e0 02 06 48 	mulu.d	r8,r0,r2
80002cf4:	12 0a       	add	r10,r9
80002cf6:	14 99       	mov	r9,r10
80002cf8:	e0 6a 03 e7 	mov	r10,999
80002cfc:	30 0b       	mov	r11,0
80002cfe:	f0 0a 00 0a 	add	r10,r8,r10
80002d02:	f2 0b 00 4b 	adc	r11,r9,r11
80002d06:	e0 68 03 e8 	mov	r8,1000
80002d0a:	30 09       	mov	r9,0
80002d0c:	f0 1f 00 41 	mcall	80002e10 <dip204_clear_display+0x170>
80002d10:	14 98       	mov	r8,r10
80002d12:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002d14:	ef 48 ff f4 	st.w	r7[-12],r8
80002d18:	ee c8 00 2c 	sub	r8,r7,44
80002d1c:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002d20:	e1 b8 00 42 	mfsr	r8,0x108
80002d24:	10 99       	mov	r9,r8
80002d26:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d2a:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002d2c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d30:	70 09       	ld.w	r9,r8[0x0]
80002d32:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002d36:	10 09       	add	r9,r8
80002d38:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d3c:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002d3e:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002d42:	30 08       	mov	r8,0
80002d44:	f3 68 00 08 	st.b	r9[8],r8
80002d48:	ee c8 00 2c 	sub	r8,r7,44
80002d4c:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002d50:	e1 b8 00 42 	mfsr	r8,0x108
80002d54:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002d58:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d5c:	f1 39 00 08 	ld.ub	r9,r8[8]
80002d60:	30 28       	mov	r8,2
80002d62:	f0 09 18 00 	cp.b	r9,r8
80002d66:	c0 31       	brne	80002d6c <dip204_clear_display+0xcc>
    return false;
80002d68:	30 08       	mov	r8,0
80002d6a:	c4 38       	rjmp	80002df0 <dip204_clear_display+0x150>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002d6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d70:	f1 39 00 08 	ld.ub	r9,r8[8]
80002d74:	30 18       	mov	r8,1
80002d76:	f0 09 18 00 	cp.b	r9,r8
80002d7a:	c0 31       	brne	80002d80 <dip204_clear_display+0xe0>
    return true;
80002d7c:	30 18       	mov	r8,1
80002d7e:	c3 98       	rjmp	80002df0 <dip204_clear_display+0x150>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002d80:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d84:	70 09       	ld.w	r9,r8[0x0]
80002d86:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d8a:	70 18       	ld.w	r8,r8[0x4]
80002d8c:	10 39       	cp.w	r9,r8
80002d8e:	e0 88 00 1a 	brls	80002dc2 <dip204_clear_display+0x122>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002d92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d96:	70 08       	ld.w	r8,r8[0x0]
80002d98:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002d9c:	10 39       	cp.w	r9,r8
80002d9e:	c1 02       	brcc	80002dbe <dip204_clear_display+0x11e>
80002da0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002da4:	70 18       	ld.w	r8,r8[0x4]
80002da6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002daa:	10 39       	cp.w	r9,r8
80002dac:	e0 88 00 09 	brls	80002dbe <dip204_clear_display+0x11e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002db0:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002db4:	30 18       	mov	r8,1
80002db6:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002dba:	30 18       	mov	r8,1
80002dbc:	c1 a8       	rjmp	80002df0 <dip204_clear_display+0x150>
    }
    return false;
80002dbe:	30 08       	mov	r8,0
80002dc0:	c1 88       	rjmp	80002df0 <dip204_clear_display+0x150>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002dc2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dc6:	70 08       	ld.w	r8,r8[0x0]
80002dc8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002dcc:	10 39       	cp.w	r9,r8
80002dce:	c0 93       	brcs	80002de0 <dip204_clear_display+0x140>
80002dd0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dd4:	70 18       	ld.w	r8,r8[0x4]
80002dd6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002dda:	10 39       	cp.w	r9,r8
80002ddc:	e0 88 00 09 	brls	80002dee <dip204_clear_display+0x14e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002de0:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002de4:	30 18       	mov	r8,1
80002de6:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002dea:	30 18       	mov	r8,1
80002dec:	c0 28       	rjmp	80002df0 <dip204_clear_display+0x150>
    }
    return false;
80002dee:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002df0:	58 08       	cp.w	r8,0
80002df2:	ca b0       	breq	80002d48 <dip204_clear_display+0xa8>
  dip204_wait_busy();
80002df4:	f0 1f 00 08 	mcall	80002e14 <dip204_clear_display+0x174>
  dip204_unselect();
80002df8:	f0 1f 00 08 	mcall	80002e18 <dip204_clear_display+0x178>
}
80002dfc:	2f 5d       	sub	sp,-44
80002dfe:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
80002e02:	00 00       	add	r0,r0
80002e04:	80 00       	ld.sh	r0,r0[0x0]
80002e06:	2f 50       	sub	r0,-11
80002e08:	80 00       	ld.sh	r0,r0[0x0]
80002e0a:	2f 80       	sub	r0,-8
80002e0c:	80 00       	ld.sh	r0,r0[0x0]
80002e0e:	20 f0       	sub	r0,15
80002e10:	80 00       	ld.sh	r0,r0[0x0]
80002e12:	66 94       	ld.w	r4,r3[0x24]
80002e14:	80 00       	ld.sh	r0,r0[0x0]
80002e16:	30 64       	mov	r4,6
80002e18:	80 00       	ld.sh	r0,r0[0x0]
80002e1a:	2f 68       	sub	r8,-10

80002e1c <dip204_write_string>:


void dip204_write_string(const char *string)
{
80002e1c:	eb cd 40 80 	pushm	r7,lr
80002e20:	1a 97       	mov	r7,sp
80002e22:	20 2d       	sub	sp,8
80002e24:	ef 4c ff f8 	st.w	r7[-8],r12
  unsigned char i=0;
80002e28:	30 08       	mov	r8,0
80002e2a:	ef 68 ff ff 	st.b	r7[-1],r8

  dip204_select();
80002e2e:	f0 1f 00 14 	mcall	80002e7c <dip204_write_string+0x60>
  /* for all chars in string */
  while(string[i]!=0)
80002e32:	c1 68       	rjmp	80002e5e <dip204_write_string+0x42>
  {
    /* Send Write Data Start Byte */
    dip204_write_byte(DIP204_WRITE_DATA);
80002e34:	e0 6c 00 fa 	mov	r12,250
80002e38:	f0 1f 00 12 	mcall	80002e80 <dip204_write_string+0x64>
    /* Send byte */
    dip204_write_byte(string[i]);
80002e3c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002e40:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002e44:	f2 08 00 08 	add	r8,r9,r8
80002e48:	11 88       	ld.ub	r8,r8[0x0]
80002e4a:	10 9c       	mov	r12,r8
80002e4c:	f0 1f 00 0d 	mcall	80002e80 <dip204_write_string+0x64>
    /* go to next char */
    i++;
80002e50:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002e54:	2f f8       	sub	r8,-1
80002e56:	ef 68 ff ff 	st.b	r7[-1],r8
    dip204_wait_busy();
80002e5a:	f0 1f 00 0b 	mcall	80002e84 <dip204_write_string+0x68>
{
  unsigned char i=0;

  dip204_select();
  /* for all chars in string */
  while(string[i]!=0)
80002e5e:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002e62:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002e66:	f2 08 00 08 	add	r8,r9,r8
80002e6a:	11 88       	ld.ub	r8,r8[0x0]
80002e6c:	58 08       	cp.w	r8,0
80002e6e:	ce 31       	brne	80002e34 <dip204_write_string+0x18>
    dip204_write_byte(string[i]);
    /* go to next char */
    i++;
    dip204_wait_busy();
  }
  dip204_unselect();
80002e70:	f0 1f 00 06 	mcall	80002e88 <dip204_write_string+0x6c>
}
80002e74:	2f ed       	sub	sp,-8
80002e76:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e7a:	00 00       	add	r0,r0
80002e7c:	80 00       	ld.sh	r0,r0[0x0]
80002e7e:	2f 50       	sub	r0,-11
80002e80:	80 00       	ld.sh	r0,r0[0x0]
80002e82:	2f 80       	sub	r0,-8
80002e84:	80 00       	ld.sh	r0,r0[0x0]
80002e86:	30 64       	mov	r4,6
80002e88:	80 00       	ld.sh	r0,r0[0x0]
80002e8a:	2f 68       	sub	r8,-10

80002e8c <dip204_printf_string>:


void dip204_printf_string(const char *format, ...)
{
80002e8c:	eb cd 40 80 	pushm	r7,lr
80002e90:	1a 97       	mov	r7,sp
80002e92:	20 9d       	sub	sp,36
80002e94:	ee c9 ff f8 	sub	r9,r7,-8
80002e98:	ef 4c ff dc 	st.w	r7[-36],r12
  va_list arg;
  char string[21];
  unsigned char i=0;
80002e9c:	30 08       	mov	r8,0
80002e9e:	ef 68 ff ff 	st.b	r7[-1],r8

  va_start(arg, format);
80002ea2:	f2 c8 00 00 	sub	r8,r9,0
80002ea6:	ef 48 ff f8 	st.w	r7[-8],r8
  i = vsprintf(string, format, arg);
80002eaa:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002eae:	ee c8 00 20 	sub	r8,r7,32
80002eb2:	12 9a       	mov	r10,r9
80002eb4:	ee fb ff dc 	ld.w	r11,r7[-36]
80002eb8:	10 9c       	mov	r12,r8
80002eba:	f0 1f 00 21 	mcall	80002f3c <dip204_printf_string+0xb0>
80002ebe:	18 98       	mov	r8,r12
80002ec0:	ef 68 ff ff 	st.b	r7[-1],r8
  while (i < sizeof(string) - 1) string[i++] = '\0';
80002ec4:	c0 d8       	rjmp	80002ede <dip204_printf_string+0x52>
80002ec6:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002eca:	ee 08 00 09 	add	r9,r7,r8
80002ece:	30 08       	mov	r8,0
80002ed0:	f3 68 ff e0 	st.b	r9[-32],r8
80002ed4:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002ed8:	2f f8       	sub	r8,-1
80002eda:	ef 68 ff ff 	st.b	r7[-1],r8
80002ede:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80002ee2:	31 38       	mov	r8,19
80002ee4:	f0 09 18 00 	cp.b	r9,r8
80002ee8:	fe 98 ff ef 	brls	80002ec6 <dip204_printf_string+0x3a>
  va_end(arg);
  dip204_select();
80002eec:	f0 1f 00 15 	mcall	80002f40 <dip204_printf_string+0xb4>
  /* for all chars in string */
  i = 0;
80002ef0:	30 08       	mov	r8,0
80002ef2:	ef 68 ff ff 	st.b	r7[-1],r8
  while(string[i]!='\0')
80002ef6:	c1 58       	rjmp	80002f20 <dip204_printf_string+0x94>
  {
    /* Send Write Data Start Byte */
    dip204_write_byte(DIP204_WRITE_DATA);
80002ef8:	e0 6c 00 fa 	mov	r12,250
80002efc:	f0 1f 00 12 	mcall	80002f44 <dip204_printf_string+0xb8>
    /* Send byte */
    dip204_write_byte(string[i]);
80002f00:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002f04:	ee 08 00 08 	add	r8,r7,r8
80002f08:	f1 38 ff e0 	ld.ub	r8,r8[-32]
80002f0c:	10 9c       	mov	r12,r8
80002f0e:	f0 1f 00 0e 	mcall	80002f44 <dip204_printf_string+0xb8>
    /* go to next char */
    i++;
80002f12:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002f16:	2f f8       	sub	r8,-1
80002f18:	ef 68 ff ff 	st.b	r7[-1],r8
    dip204_wait_busy();
80002f1c:	f0 1f 00 0b 	mcall	80002f48 <dip204_printf_string+0xbc>
  while (i < sizeof(string) - 1) string[i++] = '\0';
  va_end(arg);
  dip204_select();
  /* for all chars in string */
  i = 0;
  while(string[i]!='\0')
80002f20:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002f24:	ee 08 00 08 	add	r8,r7,r8
80002f28:	f1 38 ff e0 	ld.ub	r8,r8[-32]
80002f2c:	58 08       	cp.w	r8,0
80002f2e:	ce 51       	brne	80002ef8 <dip204_printf_string+0x6c>
    dip204_write_byte(string[i]);
    /* go to next char */
    i++;
    dip204_wait_busy();
  }
  dip204_unselect();
80002f30:	f0 1f 00 07 	mcall	80002f4c <dip204_printf_string+0xc0>
}
80002f34:	2f 7d       	sub	sp,-36
80002f36:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f3a:	00 00       	add	r0,r0
80002f3c:	80 00       	ld.sh	r0,r0[0x0]
80002f3e:	95 70       	st.w	r10[0x1c],r0
80002f40:	80 00       	ld.sh	r0,r0[0x0]
80002f42:	2f 50       	sub	r0,-11
80002f44:	80 00       	ld.sh	r0,r0[0x0]
80002f46:	2f 80       	sub	r0,-8
80002f48:	80 00       	ld.sh	r0,r0[0x0]
80002f4a:	30 64       	mov	r4,6
80002f4c:	80 00       	ld.sh	r0,r0[0x0]
80002f4e:	2f 68       	sub	r8,-10

80002f50 <dip204_select>:

/*! \brief function to select the LCD
 *
 */
static void dip204_select(void)
{
80002f50:	eb cd 40 80 	pushm	r7,lr
80002f54:	1a 97       	mov	r7,sp
  spi_selectChip(DIP204_SPI, DIP204_SPI_NPCS);
80002f56:	30 2b       	mov	r11,2
80002f58:	fe 7c 28 00 	mov	r12,-55296
80002f5c:	f0 1f 00 02 	mcall	80002f64 <dip204_select+0x14>
}
80002f60:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f64:	80 00       	ld.sh	r0,r0[0x0]
80002f66:	34 7a       	mov	r10,71

80002f68 <dip204_unselect>:

/*! \brief function to unselect the LCD
 *
 */
static void dip204_unselect(void)
{
80002f68:	eb cd 40 80 	pushm	r7,lr
80002f6c:	1a 97       	mov	r7,sp
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_unselectChip(DIP204_SPI, DIP204_SPI_NPCS);
80002f6e:	30 2b       	mov	r11,2
80002f70:	fe 7c 28 00 	mov	r12,-55296
80002f74:	f0 1f 00 02 	mcall	80002f7c <dip204_unselect+0x14>
  Assert( SPI_OK==spi_status );
}
80002f78:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f7c:	80 00       	ld.sh	r0,r0[0x0]
80002f7e:	35 12       	mov	r2,81

80002f80 <dip204_write_byte>:
 *
 *  \param  byte  Input. byte to write to the LCD (D7 .. D0)
 *
 */
static void dip204_write_byte(unsigned char byte)
{
80002f80:	eb cd 40 80 	pushm	r7,lr
80002f84:	1a 97       	mov	r7,sp
80002f86:	20 3d       	sub	sp,12
80002f88:	18 98       	mov	r8,r12
80002f8a:	ef 68 ff f4 	st.b	r7[-12],r8
  unsigned char reverse;

  switch (byte)
80002f8e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002f92:	f0 c8 00 f8 	sub	r8,r8,248
80002f96:	58 68       	cp.w	r8,6
80002f98:	e0 8b 00 10 	brhi	80002fb8 <dip204_write_byte+0x38>
80002f9c:	30 19       	mov	r9,1
80002f9e:	f2 08 09 48 	lsl	r8,r9,r8
80002fa2:	e2 18 00 55 	andl	r8,0x55,COH
80002fa6:	c0 90       	breq	80002fb8 <dip204_write_byte+0x38>
    {
      /* send D7 to D0 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, byte);
80002fa8:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002fac:	10 9b       	mov	r11,r8
80002fae:	fe 7c 28 00 	mov	r12,-55296
80002fb2:	f0 1f 00 15 	mcall	80003004 <dip204_write_byte+0x84>
      Assert( SPI_OK==spi_status );
      break;
80002fb6:	c2 48       	rjmp	80002ffe <dip204_write_byte+0x7e>
    }
    /* LSB first for all other data */
    default:
    {
      /* reverse byte */
      reverse = bit_reverse8(byte);
80002fb8:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002fbc:	ef 48 ff fc 	st.w	r7[-4],r8
80002fc0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fc4:	5c 98       	brev	r8
80002fc6:	ef 48 ff fc 	st.w	r7[-4],r8
80002fca:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fce:	b9 88       	lsr	r8,0x18
80002fd0:	ef 68 ff fb 	st.b	r7[-5],r8
      /* send D0 to D3 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, (reverse & 0xF0));
80002fd4:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002fd8:	e2 18 00 f0 	andl	r8,0xf0,COH
80002fdc:	10 9b       	mov	r11,r8
80002fde:	fe 7c 28 00 	mov	r12,-55296
80002fe2:	f0 1f 00 09 	mcall	80003004 <dip204_write_byte+0x84>
      Assert( SPI_OK==spi_status );
      /* send D4 to D7 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, ((reverse << 4) & 0xF0));
80002fe6:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002fea:	a5 68       	lsl	r8,0x4
80002fec:	5c 88       	casts.h	r8
80002fee:	5c 78       	castu.h	r8
80002ff0:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002ff4:	10 9b       	mov	r11,r8
80002ff6:	fe 7c 28 00 	mov	r12,-55296
80002ffa:	f0 1f 00 03 	mcall	80003004 <dip204_write_byte+0x84>
      Assert( SPI_OK==spi_status );
      break;
    }
  }
}
80002ffe:	2f dd       	sub	sp,-12
80003000:	e3 cd 80 80 	ldm	sp++,r7,pc
80003004:	80 00       	ld.sh	r0,r0[0x0]
80003006:	37 1a       	mov	r10,113

80003008 <dip204_read_byte>:
 *
 *  \param  byte  Input. byte read from the LCD (D7 .. D0)
 *
 */
static void dip204_read_byte(unsigned char *byte)
{
80003008:	eb cd 40 80 	pushm	r7,lr
8000300c:	1a 97       	mov	r7,sp
8000300e:	20 3d       	sub	sp,12
80003010:	ef 4c ff f4 	st.w	r7[-12],r12
  unsigned short reverse = 0x00;
80003014:	30 08       	mov	r8,0
80003016:	ef 58 ff fa 	st.h	r7[-6],r8

  /* dummy write */
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_write(DIP204_SPI, 0x00);
8000301a:	30 0b       	mov	r11,0
8000301c:	fe 7c 28 00 	mov	r12,-55296
80003020:	f0 1f 00 0f 	mcall	8000305c <dip204_read_byte+0x54>
  Assert( SPI_OK==spi_status );
  /* read RSR register */
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_read(DIP204_SPI, &reverse);
80003024:	ee c8 00 06 	sub	r8,r7,6
80003028:	10 9b       	mov	r11,r8
8000302a:	fe 7c 28 00 	mov	r12,-55296
8000302e:	f0 1f 00 0d 	mcall	80003060 <dip204_read_byte+0x58>
  Assert( SPI_OK==spi_status );
  /* Revert received byte (issued LSB first by the LCD) */
  *byte = bit_reverse8(reverse);
80003032:	ef 08 ff fa 	ld.sh	r8,r7[-6]
80003036:	5c 58       	castu.b	r8
80003038:	ef 48 ff fc 	st.w	r7[-4],r8
8000303c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003040:	5c 98       	brev	r8
80003042:	ef 48 ff fc 	st.w	r7[-4],r8
80003046:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000304a:	b9 88       	lsr	r8,0x18
8000304c:	5c 58       	castu.b	r8
8000304e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003052:	b2 88       	st.b	r9[0x0],r8
}
80003054:	2f dd       	sub	sp,-12
80003056:	e3 cd 80 80 	ldm	sp++,r7,pc
8000305a:	00 00       	add	r0,r0
8000305c:	80 00       	ld.sh	r0,r0[0x0]
8000305e:	37 1a       	mov	r10,113
80003060:	80 00       	ld.sh	r0,r0[0x0]
80003062:	37 72       	mov	r2,119

80003064 <dip204_wait_busy>:

/*! \brief function to wait for LCD becomes not busy
 *
 */
static void dip204_wait_busy(void)
{
80003064:	eb cd 40 80 	pushm	r7,lr
80003068:	1a 97       	mov	r7,sp
8000306a:	20 1d       	sub	sp,4
  unsigned char status = 0x00;
8000306c:	30 08       	mov	r8,0
8000306e:	ef 68 ff ff 	st.b	r7[-1],r8

  /* send read command to LCD */
  dip204_write_byte(DIP204_READ_COMMAND);
80003072:	e0 6c 00 fc 	mov	r12,252
80003076:	f0 1f 00 09 	mcall	80003098 <dip204_wait_busy+0x34>
  /* read next byte */
  do {
  dip204_read_byte(&status);
8000307a:	ee c8 00 01 	sub	r8,r7,1
8000307e:	10 9c       	mov	r12,r8
80003080:	f0 1f 00 07 	mcall	8000309c <dip204_wait_busy+0x38>
  /* keep D7 to know status */
  }while (status & 0x80);
80003084:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003088:	10 99       	mov	r9,r8
8000308a:	30 08       	mov	r8,0
8000308c:	f0 09 18 00 	cp.b	r9,r8
80003090:	cf 55       	brlt	8000307a <dip204_wait_busy+0x16>
}
80003092:	2f fd       	sub	sp,-4
80003094:	e3 cd 80 80 	ldm	sp++,r7,pc
80003098:	80 00       	ld.sh	r0,r0[0x0]
8000309a:	2f 80       	sub	r0,-8
8000309c:	80 00       	ld.sh	r0,r0[0x0]
8000309e:	30 08       	mov	r8,0

800030a0 <adc_configure>:
 * If not called, ADC channels will have side effects
 *
 * \param *adc Base address of the ADC
 */
void adc_configure(volatile avr32_adc_t *adc)
{
800030a0:	eb cd 40 80 	pushm	r7,lr
800030a4:	1a 97       	mov	r7,sp
800030a6:	20 1d       	sub	sp,4
800030a8:	ef 4c ff fc 	st.w	r7[-4],r12
	adc->mr |= 1 << AVR32_ADC_LOWRES_OFFSET;
#endif

	/* Set Sample/Hold time to max so that the ADC capacitor should be
	 * loaded entirely */
	adc->mr |= 0xF << AVR32_ADC_SHTIM_OFFSET;
800030ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030b0:	70 18       	ld.w	r8,r8[0x4]
800030b2:	10 99       	mov	r9,r8
800030b4:	ea 19 0f 00 	orh	r9,0xf00
800030b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030bc:	91 19       	st.w	r8[0x4],r9

	/* Set Startup to max so that the ADC capacitor should be loaded
	 * entirely */
	adc->mr |= 0x1F << AVR32_ADC_STARTUP_OFFSET;
800030be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030c2:	70 18       	ld.w	r8,r8[0x4]
800030c4:	10 99       	mov	r9,r8
800030c6:	ea 19 00 1f 	orh	r9,0x1f
800030ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030ce:	91 19       	st.w	r8[0x4],r9
}
800030d0:	2f fd       	sub	sp,-4
800030d2:	e3 cd 80 80 	ldm	sp++,r7,pc

800030d6 <adc_start>:

/** \brief Start analog to digital conversion
 * \param *adc Base address of the ADC
 */
void adc_start(volatile avr32_adc_t *adc)
{
800030d6:	eb cd 40 80 	pushm	r7,lr
800030da:	1a 97       	mov	r7,sp
800030dc:	20 1d       	sub	sp,4
800030de:	ef 4c ff fc 	st.w	r7[-4],r12
	Assert( adc != NULL );

	/* start conversion */
	adc->cr = AVR32_ADC_START_MASK;
800030e2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030e6:	30 29       	mov	r9,2
800030e8:	91 09       	st.w	r8[0x0],r9
}
800030ea:	2f fd       	sub	sp,-4
800030ec:	e3 cd 80 80 	ldm	sp++,r7,pc

800030f0 <adc_enable>:
 *
 * \param *adc Base address of the ADC
 * \param  channel   channel to enable (0 to 7)
 */
void adc_enable(volatile avr32_adc_t *adc, uint16_t channel)
{
800030f0:	eb cd 40 80 	pushm	r7,lr
800030f4:	1a 97       	mov	r7,sp
800030f6:	20 2d       	sub	sp,8
800030f8:	ef 4c ff fc 	st.w	r7[-4],r12
800030fc:	16 98       	mov	r8,r11
800030fe:	ef 58 ff f8 	st.h	r7[-8],r8
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB ); /* check if channel exist
	                                              **/

	/* enable channel */
	adc->cher = (1 << channel);
80003102:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003106:	30 19       	mov	r9,1
80003108:	f2 08 09 48 	lsl	r8,r9,r8
8000310c:	10 99       	mov	r9,r8
8000310e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003112:	91 49       	st.w	r8[0x10],r9
}
80003114:	2f ed       	sub	sp,-8
80003116:	e3 cd 80 80 	ldm	sp++,r7,pc

8000311a <adc_check_eoc>:
 * \param  channel   channel to check (0 to 7)
 * \return bool      true if conversion not running
 *                   false if conversion running
 */
bool adc_check_eoc(volatile avr32_adc_t *adc, uint16_t channel)
{
8000311a:	eb cd 40 80 	pushm	r7,lr
8000311e:	1a 97       	mov	r7,sp
80003120:	20 2d       	sub	sp,8
80003122:	ef 4c ff fc 	st.w	r7[-4],r12
80003126:	16 98       	mov	r8,r11
80003128:	ef 58 ff f8 	st.h	r7[-8],r8
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB ); /* check if channel exist
	                                              **/

	/* get SR register : EOC bit for channel */
	return ((adc->sr & (1 << channel)) ? true : false);
8000312c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003130:	70 79       	ld.w	r9,r8[0x1c]
80003132:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003136:	30 1a       	mov	r10,1
80003138:	f4 08 09 48 	lsl	r8,r10,r8
8000313c:	f3 e8 00 08 	and	r8,r9,r8
80003140:	5f 18       	srne	r8
80003142:	5c 58       	castu.b	r8
}
80003144:	10 9c       	mov	r12,r8
80003146:	2f ed       	sub	sp,-8
80003148:	e3 cd 80 80 	ldm	sp++,r7,pc

8000314c <adc_get_value>:
 * \param *adc Base address of the ADC
 * \param  channel   channel to handle (0 to 7)
 * \return The value acquired (unsigned long)
 */
uint32_t adc_get_value(volatile avr32_adc_t *adc, uint16_t channel)
{
8000314c:	eb cd 40 80 	pushm	r7,lr
80003150:	1a 97       	mov	r7,sp
80003152:	20 2d       	sub	sp,8
80003154:	ef 4c ff fc 	st.w	r7[-4],r12
80003158:	16 98       	mov	r8,r11
8000315a:	ef 58 ff f8 	st.h	r7[-8],r8
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB );

	/* wait for end of conversion */
	while (adc_check_eoc(adc, channel) != true) {
8000315e:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003162:	10 9b       	mov	r11,r8
80003164:	ee fc ff fc 	ld.w	r12,r7[-4]
80003168:	f0 1f 00 0b 	mcall	80003194 <adc_get_value+0x48>
8000316c:	18 98       	mov	r8,r12
8000316e:	ec 18 00 01 	eorl	r8,0x1
80003172:	5c 58       	castu.b	r8
80003174:	cf 51       	brne	8000315e <adc_get_value+0x12>
	}

	return *((uint32_t *)((&(adc->cdr0)) + channel));
80003176:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000317a:	f0 c9 ff d0 	sub	r9,r8,-48
8000317e:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003182:	a3 68       	lsl	r8,0x2
80003184:	f2 08 00 08 	add	r8,r9,r8
80003188:	70 08       	ld.w	r8,r8[0x0]
}
8000318a:	10 9c       	mov	r12,r8
8000318c:	2f ed       	sub	sp,-8
8000318e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003192:	00 00       	add	r0,r0
80003194:	80 00       	ld.sh	r0,r0[0x0]
80003196:	31 1a       	mov	r10,17

80003198 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80003198:	eb cd 40 80 	pushm	r7,lr
8000319c:	1a 97       	mov	r7,sp
8000319e:	20 1d       	sub	sp,4
800031a0:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
800031a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031a8:	e6 18 00 01 	andh	r8,0x1,COH
800031ac:	5f 08       	sreq	r8
800031ae:	5c 58       	castu.b	r8
}
800031b0:	10 9c       	mov	r12,r8
800031b2:	2f fd       	sub	sp,-4
800031b4:	e3 cd 80 80 	ldm	sp++,r7,pc

800031b8 <pwm_init>:
#include "compiler.h"
#include "pwm.h"


int pwm_init(const pwm_opt_t *opt)
{
800031b8:	eb cd 40 80 	pushm	r7,lr
800031bc:	1a 97       	mov	r7,sp
800031be:	20 3d       	sub	sp,12
800031c0:	ef 4c ff f4 	st.w	r7[-12],r12
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
800031c4:	fe 78 30 00 	mov	r8,-53248
800031c8:	ef 48 ff f8 	st.w	r7[-8],r8
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
800031cc:	e1 b8 00 00 	mfsr	r8,0x0
800031d0:	10 9c       	mov	r12,r8
800031d2:	f0 1f 00 1e 	mcall	80003248 <pwm_init+0x90>
800031d6:	18 98       	mov	r8,r12
800031d8:	ef 68 ff ff 	st.b	r7[-1],r8

  if (opt == 0 ) // Null pointer.
800031dc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800031e0:	58 08       	cp.w	r8,0
800031e2:	c0 31       	brne	800031e8 <pwm_init+0x30>
    return PWM_INVALID_INPUT;
800031e4:	30 18       	mov	r8,1
800031e6:	c2 c8       	rjmp	8000323e <pwm_init+0x86>

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
800031e8:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800031ec:	30 08       	mov	r8,0
800031ee:	f0 09 18 00 	cp.b	r9,r8
800031f2:	c0 20       	breq	800031f6 <pwm_init+0x3e>
800031f4:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
800031f6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800031fa:	37 f9       	mov	r9,127
800031fc:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
800031fe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003202:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
80003204:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003208:	30 08       	mov	r8,0
8000320a:	f0 09 18 00 	cp.b	r9,r8
8000320e:	c0 20       	breq	80003212 <pwm_init+0x5a>
80003210:	d5 03       	csrf	0x10

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
80003212:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003216:	70 19       	ld.w	r9,r8[0x4]
    ((opt->divb)<<AVR32_PWM_DIVB_OFFSET) |
80003218:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000321c:	70 08       	ld.w	r8,r8[0x0]
8000321e:	b1 68       	lsl	r8,0x10
80003220:	10 49       	or	r9,r8
    ((opt->prea)<<AVR32_PWM_PREA_OFFSET) |
80003222:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003226:	70 38       	ld.w	r8,r8[0xc]
80003228:	a9 68       	lsl	r8,0x8
8000322a:	10 49       	or	r9,r8
    ((opt->preb)<<AVR32_PWM_PREB_OFFSET)
8000322c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003230:	70 28       	ld.w	r8,r8[0x8]
80003232:	b9 68       	lsl	r8,0x18
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
80003234:	10 49       	or	r9,r8
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
80003236:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000323a:	91 09       	st.w	r8[0x0],r9
    ((opt->divb)<<AVR32_PWM_DIVB_OFFSET) |
    ((opt->prea)<<AVR32_PWM_PREA_OFFSET) |
    ((opt->preb)<<AVR32_PWM_PREB_OFFSET)
    ;

  return PWM_SUCCESS;
8000323c:	30 08       	mov	r8,0
}
8000323e:	10 9c       	mov	r12,r8
80003240:	2f dd       	sub	sp,-12
80003242:	e3 cd 80 80 	ldm	sp++,r7,pc
80003246:	00 00       	add	r0,r0
80003248:	80 00       	ld.sh	r0,r0[0x0]
8000324a:	31 98       	mov	r8,25

8000324c <pwm_channel_init>:


int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
8000324c:	eb cd 40 80 	pushm	r7,lr
80003250:	1a 97       	mov	r7,sp
80003252:	20 3d       	sub	sp,12
80003254:	ef 4c ff f8 	st.w	r7[-8],r12
80003258:	ef 4b ff f4 	st.w	r7[-12],r11
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
8000325c:	fe 78 30 00 	mov	r8,-53248
80003260:	ef 48 ff fc 	st.w	r7[-4],r8

  if (pwm_channel == 0) // Null pointer.
80003264:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003268:	58 08       	cp.w	r8,0
8000326a:	c0 31       	brne	80003270 <pwm_channel_init+0x24>
    return PWM_INVALID_ARGUMENT;
8000326c:	30 18       	mov	r8,1
8000326e:	c2 f8       	rjmp	800032cc <pwm_channel_init+0x80>
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
80003270:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003274:	58 68       	cp.w	r8,6
80003276:	e0 88 00 04 	brls	8000327e <pwm_channel_init+0x32>
    return PWM_INVALID_INPUT;
8000327a:	30 18       	mov	r8,1
8000327c:	c2 88       	rjmp	800032cc <pwm_channel_init+0x80>

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
8000327e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003282:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003286:	72 09       	ld.w	r9,r9[0x0]
80003288:	ee fa ff fc 	ld.w	r10,r7[-4]
8000328c:	2f 08       	sub	r8,-16
8000328e:	a5 78       	lsl	r8,0x5
80003290:	f4 08 00 08 	add	r8,r10,r8
80003294:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
80003296:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000329a:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000329e:	72 19       	ld.w	r9,r9[0x4]
800032a0:	ee fa ff fc 	ld.w	r10,r7[-4]
800032a4:	a5 78       	lsl	r8,0x5
800032a6:	f4 08 00 08 	add	r8,r10,r8
800032aa:	f0 c8 fd fc 	sub	r8,r8,-516
800032ae:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
800032b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800032b4:	ee f9 ff f4 	ld.w	r9,r7[-12]
800032b8:	72 29       	ld.w	r9,r9[0x8]
800032ba:	ee fa ff fc 	ld.w	r10,r7[-4]
800032be:	a5 78       	lsl	r8,0x5
800032c0:	f4 08 00 08 	add	r8,r10,r8
800032c4:	f0 c8 fd f8 	sub	r8,r8,-520
800032c8:	91 09       	st.w	r8[0x0],r9

  return PWM_SUCCESS;
800032ca:	30 08       	mov	r8,0
}
800032cc:	10 9c       	mov	r12,r8
800032ce:	2f dd       	sub	sp,-12
800032d0:	e3 cd 80 80 	ldm	sp++,r7,pc

800032d4 <pwm_start_channels>:


int pwm_start_channels(unsigned long channels_bitmask)
{
800032d4:	eb cd 40 80 	pushm	r7,lr
800032d8:	1a 97       	mov	r7,sp
800032da:	20 1d       	sub	sp,4
800032dc:	ef 4c ff fc 	st.w	r7[-4],r12
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
800032e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032e4:	e0 18 ff 80 	andl	r8,0xff80
800032e8:	c0 30       	breq	800032ee <pwm_start_channels+0x1a>
    return PWM_INVALID_INPUT;
800032ea:	30 18       	mov	r8,1
800032ec:	c0 78       	rjmp	800032fa <pwm_start_channels+0x26>

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
800032ee:	fe 78 30 00 	mov	r8,-53248
800032f2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800032f6:	91 19       	st.w	r8[0x4],r9

  return PWM_SUCCESS;
800032f8:	30 08       	mov	r8,0
}
800032fa:	10 9c       	mov	r12,r8
800032fc:	2f fd       	sub	sp,-4
800032fe:	e3 cd 80 80 	ldm	sp++,r7,pc

80003302 <getBaudDiv>:
/** The SPI mutex. */
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
80003302:	eb cd 40 80 	pushm	r7,lr
80003306:	1a 97       	mov	r7,sp
80003308:	20 3d       	sub	sp,12
8000330a:	ef 4c ff f8 	st.w	r7[-8],r12
8000330e:	ef 4b ff f4 	st.w	r7[-12],r11
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80003312:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003316:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000331a:	f2 08 00 08 	add	r8,r9,r8
8000331e:	20 18       	sub	r8,1
80003320:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003324:	f0 09 0d 08 	divu	r8,r8,r9
80003328:	ef 48 ff fc 	st.w	r7[-4],r8

	if (baudDiv <= 0 || baudDiv > 255) {
8000332c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003330:	58 08       	cp.w	r8,0
80003332:	c0 70       	breq	80003340 <getBaudDiv+0x3e>
80003334:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003338:	e0 48 00 ff 	cp.w	r8,255
8000333c:	e0 88 00 04 	brls	80003344 <getBaudDiv+0x42>
		return -1;
80003340:	3f f8       	mov	r8,-1
80003342:	c0 48       	rjmp	8000334a <getBaudDiv+0x48>
	}

	return baudDiv;
80003344:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003348:	5c 88       	casts.h	r8
}
8000334a:	10 9c       	mov	r12,r8
8000334c:	2f dd       	sub	sp,-12
8000334e:	e3 cd 80 80 	ldm	sp++,r7,pc

80003352 <spi_initMaster>:
	return SPI_OK;
}

spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
80003352:	eb cd 40 80 	pushm	r7,lr
80003356:	1a 97       	mov	r7,sp
80003358:	20 3d       	sub	sp,12
8000335a:	ef 4c ff f8 	st.w	r7[-8],r12
8000335e:	ef 4b ff f4 	st.w	r7[-12],r11
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80003362:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003366:	f1 39 00 0d 	ld.ub	r9,r8[13]
8000336a:	30 18       	mov	r8,1
8000336c:	f0 09 18 00 	cp.b	r9,r8
80003370:	e0 88 00 04 	brls	80003378 <spi_initMaster+0x26>
		return SPI_ERROR_ARGUMENT;
80003374:	30 28       	mov	r8,2
80003376:	c3 48       	rjmp	800033de <spi_initMaster+0x8c>
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80003378:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000337c:	e0 69 00 80 	mov	r9,128
80003380:	91 09       	st.w	r8[0x0],r9

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80003382:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003386:	70 18       	ld.w	r8,r8[0x4]
80003388:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.mstr = 1;
8000338c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003390:	30 19       	mov	r9,1
80003392:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
80003396:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
8000339a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000339e:	f1 38 00 0d 	ld.ub	r8,r8[13]
800033a2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800033a6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800033aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033ae:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
800033b2:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.llb = 0;
800033b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033ba:	30 09       	mov	r9,0
800033bc:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
800033c0:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800033c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033c8:	30 f9       	mov	r9,15
800033ca:	f1 d9 d2 04 	bfins	r8,r9,0x10,0x4
800033ce:	ef 48 ff fc 	st.w	r7[-4],r8
	spi->mr = u_avr32_spi_mr.mr;
800033d2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800033d6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800033da:	91 19       	st.w	r8[0x4],r9

	return SPI_OK;
800033dc:	30 08       	mov	r8,0
}
800033de:	10 9c       	mov	r12,r8
800033e0:	2f dd       	sub	sp,-12
800033e2:	e3 cd 80 80 	ldm	sp++,r7,pc

800033e6 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800033e6:	eb cd 40 80 	pushm	r7,lr
800033ea:	1a 97       	mov	r7,sp
800033ec:	20 5d       	sub	sp,20
800033ee:	ef 4c ff f8 	st.w	r7[-8],r12
800033f2:	12 98       	mov	r8,r9
800033f4:	16 99       	mov	r9,r11
800033f6:	ef 69 ff f4 	st.b	r7[-12],r9
800033fa:	14 99       	mov	r9,r10
800033fc:	ef 69 ff f0 	st.b	r7[-16],r9
80003400:	ef 68 ff ec 	st.b	r7[-20],r8
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80003404:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80003408:	30 18       	mov	r8,1
8000340a:	f0 09 18 00 	cp.b	r9,r8
8000340e:	e0 8b 00 09 	brhi	80003420 <spi_selectionMode+0x3a>
80003412:	ef 39 ff f0 	ld.ub	r9,r7[-16]
80003416:	30 18       	mov	r8,1
80003418:	f0 09 18 00 	cp.b	r9,r8
8000341c:	e0 88 00 04 	brls	80003424 <spi_selectionMode+0x3e>
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
80003420:	30 28       	mov	r8,2
80003422:	c2 88       	rjmp	80003472 <spi_selectionMode+0x8c>
	}

	u_avr32_spi_mr.mr = spi->mr;
80003424:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003428:	70 18       	ld.w	r8,r8[0x4]
8000342a:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.ps = variable_ps;
8000342e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003432:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003436:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000343a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000343e:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
80003442:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80003446:	ef 38 ff f0 	ld.ub	r8,r7[-16]
8000344a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000344e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003452:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003456:	f1 d9 d0 41 	bfins	r8,r9,0x2,0x1
8000345a:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.dlybcs = delay;
8000345e:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80003462:	ef 68 ff fc 	st.b	r7[-4],r8
	spi->mr = u_avr32_spi_mr.mr;
80003466:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000346a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000346e:	91 19       	st.w	r8[0x4],r9

	return SPI_OK;
80003470:	30 08       	mov	r8,0
}
80003472:	10 9c       	mov	r12,r8
80003474:	2f bd       	sub	sp,-20
80003476:	e3 cd 80 80 	ldm	sp++,r7,pc

8000347a <spi_selectChip>:

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000347a:	eb cd 40 80 	pushm	r7,lr
8000347e:	1a 97       	mov	r7,sp
80003480:	20 2d       	sub	sp,8
80003482:	ef 4c ff fc 	st.w	r7[-4],r12
80003486:	16 98       	mov	r8,r11
80003488:	ef 68 ff f8 	st.b	r7[-8],r8
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000348c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003490:	70 18       	ld.w	r8,r8[0x4]
80003492:	10 99       	mov	r9,r8
80003494:	ea 19 00 0f 	orh	r9,0xf
80003498:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000349c:	91 19       	st.w	r8[0x4],r9

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
8000349e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034a2:	70 18       	ld.w	r8,r8[0x4]
800034a4:	e2 18 00 04 	andl	r8,0x4,COH
800034a8:	c1 90       	breq	800034da <spi_selectChip+0x60>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800034aa:	ef 39 ff f8 	ld.ub	r9,r7[-8]
800034ae:	30 e8       	mov	r8,14
800034b0:	f0 09 18 00 	cp.b	r9,r8
800034b4:	e0 88 00 04 	brls	800034bc <spi_selectChip+0x42>
			return SPI_ERROR_ARGUMENT;
800034b8:	30 28       	mov	r8,2
800034ba:	c2 88       	rjmp	8000350a <spi_selectChip+0x90>
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800034bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034c0:	70 19       	ld.w	r9,r8[0x4]
				(chip << AVR32_SPI_MR_PCS_OFFSET);
800034c2:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800034c6:	b1 68       	lsl	r8,0x10
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800034c8:	ea 18 ff f0 	orh	r8,0xfff0
800034cc:	e8 18 ff ff 	orl	r8,0xffff
800034d0:	10 69       	and	r9,r8
800034d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034d6:	91 19       	st.w	r8[0x4],r9
800034d8:	c1 88       	rjmp	80003508 <spi_selectChip+0x8e>
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800034da:	ef 39 ff f8 	ld.ub	r9,r7[-8]
800034de:	30 38       	mov	r8,3
800034e0:	f0 09 18 00 	cp.b	r9,r8
800034e4:	e0 88 00 04 	brls	800034ec <spi_selectChip+0x72>
			return SPI_ERROR_ARGUMENT;
800034e8:	30 28       	mov	r8,2
800034ea:	c1 08       	rjmp	8000350a <spi_selectChip+0x90>
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800034ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034f0:	70 19       	ld.w	r9,r8[0x4]
800034f2:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800034f6:	2f 08       	sub	r8,-16
800034f8:	30 1a       	mov	r10,1
800034fa:	f4 08 09 48 	lsl	r8,r10,r8
800034fe:	5c d8       	com	r8
80003500:	10 69       	and	r9,r8
80003502:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003506:	91 19       	st.w	r8[0x4],r9
	}

	return SPI_OK;
80003508:	30 08       	mov	r8,0
}
8000350a:	10 9c       	mov	r12,r8
8000350c:	2f ed       	sub	sp,-8
8000350e:	e3 cd 80 80 	ldm	sp++,r7,pc

80003512 <spi_unselectChip>:

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80003512:	eb cd 40 80 	pushm	r7,lr
80003516:	1a 97       	mov	r7,sp
80003518:	20 3d       	sub	sp,12
8000351a:	ef 4c ff f8 	st.w	r7[-8],r12
8000351e:	16 98       	mov	r8,r11
80003520:	ef 68 ff f4 	st.b	r7[-12],r8
	uint32_t timeout = SPI_TIMEOUT;
80003524:	e0 68 3a 98 	mov	r8,15000
80003528:	ef 48 ff fc 	st.w	r7[-4],r8

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000352c:	c0 f8       	rjmp	8000354a <spi_unselectChip+0x38>
		if (!timeout--) {
8000352e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003532:	58 08       	cp.w	r8,0
80003534:	5f 08       	sreq	r8
80003536:	5c 58       	castu.b	r8
80003538:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000353c:	20 19       	sub	r9,1
8000353e:	ef 49 ff fc 	st.w	r7[-4],r9
80003542:	58 08       	cp.w	r8,0
80003544:	c0 30       	breq	8000354a <spi_unselectChip+0x38>
			return SPI_ERROR_TIMEOUT;
80003546:	30 18       	mov	r8,1
80003548:	c1 68       	rjmp	80003574 <spi_unselectChip+0x62>

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000354a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000354e:	70 48       	ld.w	r8,r8[0x10]
80003550:	e2 18 02 00 	andl	r8,0x200,COH
80003554:	ce d0       	breq	8000352e <spi_unselectChip+0x1c>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80003556:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000355a:	70 18       	ld.w	r8,r8[0x4]
8000355c:	10 99       	mov	r9,r8
8000355e:	ea 19 00 0f 	orh	r9,0xf
80003562:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003566:	91 19       	st.w	r8[0x4],r9

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80003568:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000356c:	fc 19 01 00 	movh	r9,0x100
80003570:	91 09       	st.w	r8[0x0],r9

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
#endif

	return SPI_OK;
80003572:	30 08       	mov	r8,0
}
80003574:	10 9c       	mov	r12,r8
80003576:	2f dd       	sub	sp,-12
80003578:	e3 cd 80 80 	ldm	sp++,r7,pc

8000357c <spi_setupChipReg>:

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
8000357c:	eb cd 40 80 	pushm	r7,lr
80003580:	1a 97       	mov	r7,sp
80003582:	20 5d       	sub	sp,20
80003584:	ef 4c ff f4 	st.w	r7[-12],r12
80003588:	ef 4b ff f0 	st.w	r7[-16],r11
8000358c:	ef 4a ff ec 	st.w	r7[-20],r10
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80003590:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003594:	f1 39 00 0c 	ld.ub	r9,r8[12]
80003598:	30 38       	mov	r8,3
8000359a:	f0 09 18 00 	cp.b	r9,r8
8000359e:	e0 8b 00 1d 	brhi	800035d8 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
800035a2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035a6:	f1 39 00 0b 	ld.ub	r9,r8[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800035aa:	30 18       	mov	r8,1
800035ac:	f0 09 18 00 	cp.b	r9,r8
800035b0:	e0 8b 00 14 	brhi	800035d8 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800035b4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035b8:	f1 39 00 08 	ld.ub	r9,r8[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800035bc:	30 78       	mov	r8,7
800035be:	f0 09 18 00 	cp.b	r9,r8
800035c2:	e0 88 00 0b 	brls	800035d8 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800035c6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035ca:	f1 39 00 08 	ld.ub	r9,r8[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800035ce:	31 08       	mov	r8,16
800035d0:	f0 09 18 00 	cp.b	r9,r8
800035d4:	e0 88 00 04 	brls	800035dc <spi_setupChipReg+0x60>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
800035d8:	30 28       	mov	r8,2
800035da:	c8 d8       	rjmp	800036f4 <spi_setupChipReg+0x178>
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800035dc:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035e0:	70 18       	ld.w	r8,r8[0x4]
800035e2:	ee fb ff ec 	ld.w	r11,r7[-20]
800035e6:	10 9c       	mov	r12,r8
800035e8:	f0 1f 00 45 	mcall	800036fc <spi_setupChipReg+0x180>
800035ec:	18 98       	mov	r8,r12
800035ee:	ef 48 ff fc 	st.w	r7[-4],r8

	if (baudDiv < 0) {
800035f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800035f6:	58 08       	cp.w	r8,0
800035f8:	c0 34       	brge	800035fe <spi_setupChipReg+0x82>
		return SPI_ERROR_ARGUMENT;
800035fa:	30 28       	mov	r8,2
800035fc:	c7 c8       	rjmp	800036f4 <spi_setupChipReg+0x178>
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800035fe:	30 08       	mov	r8,0
80003600:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80003604:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003608:	f1 38 00 0c 	ld.ub	r8,r8[12]
8000360c:	a1 98       	lsr	r8,0x1
8000360e:	5c 58       	castu.b	r8
80003610:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003614:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003618:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000361c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
80003620:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80003624:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003628:	f1 38 00 0c 	ld.ub	r8,r8[12]
8000362c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003630:	5f 08       	sreq	r8
80003632:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003636:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000363a:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
8000363e:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80003642:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003646:	f1 38 00 0b 	ld.ub	r8,r8[11]
8000364a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000364e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003652:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003656:	f1 d9 d0 61 	bfins	r8,r9,0x3,0x1
8000365a:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
8000365e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003662:	f1 38 00 08 	ld.ub	r8,r8[8]
80003666:	20 88       	sub	r8,8
80003668:	5c 58       	castu.b	r8
8000366a:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000366e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003672:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003676:	f1 d9 d0 84 	bfins	r8,r9,0x4,0x4
8000367a:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
8000367e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003682:	5c 58       	castu.b	r8
80003684:	ef 68 ff fa 	st.b	r7[-6],r8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80003688:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000368c:	f1 38 00 09 	ld.ub	r8,r8[9]
80003690:	ef 68 ff f9 	st.b	r7[-7],r8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80003694:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003698:	f1 38 00 0a 	ld.ub	r8,r8[10]
8000369c:	ef 68 ff f8 	st.b	r7[-8],r8

	switch (options->reg) {
800036a0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800036a4:	11 88       	ld.ub	r8,r8[0x0]
800036a6:	58 18       	cp.w	r8,1
800036a8:	c1 10       	breq	800036ca <spi_setupChipReg+0x14e>
800036aa:	e0 89 00 05 	brgt	800036b4 <spi_setupChipReg+0x138>
800036ae:	58 08       	cp.w	r8,0
800036b0:	c0 70       	breq	800036be <spi_setupChipReg+0x142>
800036b2:	c1 e8       	rjmp	800036ee <spi_setupChipReg+0x172>
800036b4:	58 28       	cp.w	r8,2
800036b6:	c1 00       	breq	800036d6 <spi_setupChipReg+0x15a>
800036b8:	58 38       	cp.w	r8,3
800036ba:	c1 40       	breq	800036e2 <spi_setupChipReg+0x166>
800036bc:	c1 98       	rjmp	800036ee <spi_setupChipReg+0x172>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800036be:	ee f9 ff f8 	ld.w	r9,r7[-8]
800036c2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036c6:	91 c9       	st.w	r8[0x30],r9
		break;
800036c8:	c1 58       	rjmp	800036f2 <spi_setupChipReg+0x176>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800036ca:	ee f9 ff f8 	ld.w	r9,r7[-8]
800036ce:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036d2:	91 d9       	st.w	r8[0x34],r9
		break;
800036d4:	c0 f8       	rjmp	800036f2 <spi_setupChipReg+0x176>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800036d6:	ee f9 ff f8 	ld.w	r9,r7[-8]
800036da:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036de:	91 e9       	st.w	r8[0x38],r9
		break;
800036e0:	c0 98       	rjmp	800036f2 <spi_setupChipReg+0x176>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800036e2:	ee f9 ff f8 	ld.w	r9,r7[-8]
800036e6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036ea:	91 f9       	st.w	r8[0x3c],r9
		break;
800036ec:	c0 38       	rjmp	800036f2 <spi_setupChipReg+0x176>

	default:
		return SPI_ERROR_ARGUMENT;
800036ee:	30 28       	mov	r8,2
800036f0:	c0 28       	rjmp	800036f4 <spi_setupChipReg+0x178>
			}
		}
	}
#endif

	return SPI_OK;
800036f2:	30 08       	mov	r8,0
}
800036f4:	10 9c       	mov	r12,r8
800036f6:	2f bd       	sub	sp,-20
800036f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800036fc:	80 00       	ld.sh	r0,r0[0x0]
800036fe:	33 02       	mov	r2,48

80003700 <spi_enable>:

void spi_enable(volatile avr32_spi_t *spi)
{
80003700:	eb cd 40 80 	pushm	r7,lr
80003704:	1a 97       	mov	r7,sp
80003706:	20 1d       	sub	sp,4
80003708:	ef 4c ff fc 	st.w	r7[-4],r12
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000370c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003710:	30 19       	mov	r9,1
80003712:	91 09       	st.w	r8[0x0],r9
}
80003714:	2f fd       	sub	sp,-4
80003716:	e3 cd 80 80 	ldm	sp++,r7,pc

8000371a <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000371a:	eb cd 40 80 	pushm	r7,lr
8000371e:	1a 97       	mov	r7,sp
80003720:	20 3d       	sub	sp,12
80003722:	ef 4c ff f8 	st.w	r7[-8],r12
80003726:	16 98       	mov	r8,r11
80003728:	ef 58 ff f4 	st.h	r7[-12],r8
	uint32_t timeout = SPI_TIMEOUT;
8000372c:	e0 68 3a 98 	mov	r8,15000
80003730:	ef 48 ff fc 	st.w	r7[-4],r8

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80003734:	c0 f8       	rjmp	80003752 <spi_write+0x38>
		if (!timeout--) {
80003736:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000373a:	58 08       	cp.w	r8,0
8000373c:	5f 08       	sreq	r8
8000373e:	5c 58       	castu.b	r8
80003740:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003744:	20 19       	sub	r9,1
80003746:	ef 49 ff fc 	st.w	r7[-4],r9
8000374a:	58 08       	cp.w	r8,0
8000374c:	c0 30       	breq	80003752 <spi_write+0x38>
			return SPI_ERROR_TIMEOUT;
8000374e:	30 18       	mov	r8,1
80003750:	c0 d8       	rjmp	8000376a <spi_write+0x50>

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80003752:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003756:	70 48       	ld.w	r8,r8[0x10]
80003758:	e2 18 00 02 	andl	r8,0x2,COH
8000375c:	ce d0       	breq	80003736 <spi_write+0x1c>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000375e:	ef 19 ff f4 	ld.uh	r9,r7[-12]
80003762:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003766:	91 39       	st.w	r8[0xc],r9

	return SPI_OK;
80003768:	30 08       	mov	r8,0
}
8000376a:	10 9c       	mov	r12,r8
8000376c:	2f dd       	sub	sp,-12
8000376e:	e3 cd 80 80 	ldm	sp++,r7,pc

80003772 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80003772:	eb cd 40 80 	pushm	r7,lr
80003776:	1a 97       	mov	r7,sp
80003778:	20 3d       	sub	sp,12
8000377a:	ef 4c ff f8 	st.w	r7[-8],r12
8000377e:	ef 4b ff f4 	st.w	r7[-12],r11
	unsigned int timeout = SPI_TIMEOUT;
80003782:	e0 68 3a 98 	mov	r8,15000
80003786:	ef 48 ff fc 	st.w	r7[-4],r8

	while ((spi->sr &
8000378a:	c0 f8       	rjmp	800037a8 <spi_read+0x36>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
8000378c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003790:	58 08       	cp.w	r8,0
80003792:	5f 08       	sreq	r8
80003794:	5c 58       	castu.b	r8
80003796:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000379a:	20 19       	sub	r9,1
8000379c:	ef 49 ff fc 	st.w	r7[-4],r9
800037a0:	58 08       	cp.w	r8,0
800037a2:	c0 30       	breq	800037a8 <spi_read+0x36>
			return SPI_ERROR_TIMEOUT;
800037a4:	30 18       	mov	r8,1
800037a6:	c1 18       	rjmp	800037c8 <spi_read+0x56>

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800037a8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800037ac:	70 48       	ld.w	r8,r8[0x10]
800037ae:	e2 18 02 01 	andl	r8,0x201,COH
800037b2:	e0 48 02 01 	cp.w	r8,513
800037b6:	ce b1       	brne	8000378c <spi_read+0x1a>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800037b8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800037bc:	70 28       	ld.w	r8,r8[0x8]
800037be:	5c 88       	casts.h	r8
800037c0:	ee f9 ff f4 	ld.w	r9,r7[-12]
800037c4:	b2 08       	st.h	r9[0x0],r8

	return SPI_OK;
800037c6:	30 08       	mov	r8,0
}
800037c8:	10 9c       	mov	r12,r8
800037ca:	2f dd       	sub	sp,-12
800037cc:	e3 cd 80 80 	ldm	sp++,r7,pc

800037d0 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern bool sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
800037d0:	eb cd 40 80 	pushm	r7,lr
800037d4:	1a 97       	mov	r7,sp
	}
#endif

	switch (CONFIG_SYSCLK_SOURCE) {
	case SYSCLK_SRC_RCSYS:
		return OSC_SLOW_NOMINAL_HZ;
800037d6:	e0 78 c2 00 	mov	r8,115200

	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
800037da:	10 9c       	mov	r12,r8
800037dc:	e3 cd 80 80 	ldm	sp++,r7,pc

800037e0 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
800037e0:	eb cd 40 80 	pushm	r7,lr
800037e4:	1a 97       	mov	r7,sp
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_CPU_DIV;
800037e6:	f0 1f 00 04 	mcall	800037f4 <sysclk_get_cpu_hz+0x14>
800037ea:	18 98       	mov	r8,r12
}
800037ec:	10 9c       	mov	r12,r8
800037ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800037f2:	00 00       	add	r0,r0
800037f4:	80 00       	ld.sh	r0,r0[0x0]
800037f6:	37 d0       	mov	r0,125

800037f8 <display_init>:

// Include Files
#include "display_init.h"

void display_init(void)
{
800037f8:	eb cd 40 8f 	pushm	r0-r3,r7,lr
800037fc:	1a 97       	mov	r7,sp
800037fe:	21 0d       	sub	sp,64
	volatile avr32_pm_t* pm = &AVR32_PM;
80003800:	fe 78 0c 00 	mov	r8,-62464
80003804:	ef 48 ff dc 	st.w	r7[-36],r8
	   .spck_delay           = 0,
	   .trans_delay  		 = 8,
	   .stay_act             = 1,
	   .spi_mode             = 0,
	   .modfdis              = 1
	};
80003808:	4f 68       	lddpc	r8,800039e0 <display_init+0x1e8>
8000380a:	ee ca 00 34 	sub	r10,r7,52
8000380e:	10 9b       	mov	r11,r8
80003810:	f6 e8 00 00 	ld.d	r8,r11[0]
80003814:	f4 e9 00 00 	st.d	r10[0],r8
80003818:	f6 e8 00 08 	ld.d	r8,r11[8]
8000381c:	f4 e9 00 08 	st.d	r10[8],r8

	// Switch clock to external 12 MHz crystal
	// 1) Configure OSC0 in crystal mode, external crystal with a FOSC0 Hz frequency.
	pm_enable_osc0_crystal(pm, FOSC0);
80003820:	e0 6b 1b 00 	mov	r11,6912
80003824:	ea 1b 00 b7 	orh	r11,0xb7
80003828:	ee fc ff dc 	ld.w	r12,r7[-36]
8000382c:	f0 1f 00 6e 	mcall	800039e4 <display_init+0x1ec>

	// 2) Enable the OSC0
	pm_enable_clk0(pm, OSC0_STARTUP);
80003830:	30 3b       	mov	r11,3
80003832:	ee fc ff dc 	ld.w	r12,r7[-36]
80003836:	f0 1f 00 6d 	mcall	800039e8 <display_init+0x1f0>

	// 3) Set the main clock source as being OSC0.
	pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
8000383a:	30 1b       	mov	r11,1
8000383c:	ee fc ff dc 	ld.w	r12,r7[-36]
80003840:	f0 1f 00 6b 	mcall	800039ec <display_init+0x1f4>

	// Initialize the delay function
	delay_init(12000000);
	// Delay for a ms, to allow the display to power up properly
	delay_ms(1);
80003844:	f0 1f 00 6b 	mcall	800039f0 <display_init+0x1f8>
80003848:	18 98       	mov	r8,r12
8000384a:	30 19       	mov	r9,1
8000384c:	ef 49 ff e4 	st.w	r7[-28],r9
80003850:	ef 48 ff e0 	st.w	r7[-32],r8
80003854:	ee f8 ff e4 	ld.w	r8,r7[-28]
80003858:	ef 48 ff ec 	st.w	r7[-20],r8
8000385c:	ee f8 ff e0 	ld.w	r8,r7[-32]
80003860:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003864:	ee f0 ff ec 	ld.w	r0,r7[-20]
80003868:	30 01       	mov	r1,0
8000386a:	ee f2 ff e8 	ld.w	r2,r7[-24]
8000386e:	30 03       	mov	r3,0
80003870:	e2 02 02 4a 	mul	r10,r1,r2
80003874:	e6 00 02 48 	mul	r8,r3,r0
80003878:	10 0a       	add	r10,r8
8000387a:	e0 02 06 48 	mulu.d	r8,r0,r2
8000387e:	12 0a       	add	r10,r9
80003880:	14 99       	mov	r9,r10
80003882:	e0 6a 03 e7 	mov	r10,999
80003886:	30 0b       	mov	r11,0
80003888:	f0 0a 00 0a 	add	r10,r8,r10
8000388c:	f2 0b 00 4b 	adc	r11,r9,r11
80003890:	e0 68 03 e8 	mov	r8,1000
80003894:	30 09       	mov	r9,0
80003896:	f0 1f 00 58 	mcall	800039f4 <display_init+0x1fc>
8000389a:	14 98       	mov	r8,r10
8000389c:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000389e:	ef 48 ff f4 	st.w	r7[-12],r8
800038a2:	ee c8 00 40 	sub	r8,r7,64
800038a6:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800038aa:	e1 b8 00 42 	mfsr	r8,0x108
800038ae:	10 99       	mov	r9,r8
800038b0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800038b4:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800038b6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800038ba:	70 09       	ld.w	r9,r8[0x0]
800038bc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800038c0:	10 09       	add	r9,r8
800038c2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800038c6:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800038c8:	ee f9 ff f0 	ld.w	r9,r7[-16]
800038cc:	30 08       	mov	r8,0
800038ce:	f3 68 00 08 	st.b	r9[8],r8
800038d2:	ee c8 00 40 	sub	r8,r7,64
800038d6:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800038da:	e1 b8 00 42 	mfsr	r8,0x108
800038de:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800038e2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800038e6:	f1 39 00 08 	ld.ub	r9,r8[8]
800038ea:	30 28       	mov	r8,2
800038ec:	f0 09 18 00 	cp.b	r9,r8
800038f0:	c0 31       	brne	800038f6 <display_init+0xfe>
    return false;
800038f2:	30 08       	mov	r8,0
800038f4:	c4 38       	rjmp	8000397a <display_init+0x182>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800038f6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800038fa:	f1 39 00 08 	ld.ub	r9,r8[8]
800038fe:	30 18       	mov	r8,1
80003900:	f0 09 18 00 	cp.b	r9,r8
80003904:	c0 31       	brne	8000390a <display_init+0x112>
    return true;
80003906:	30 18       	mov	r8,1
80003908:	c3 98       	rjmp	8000397a <display_init+0x182>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000390a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000390e:	70 09       	ld.w	r9,r8[0x0]
80003910:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003914:	70 18       	ld.w	r8,r8[0x4]
80003916:	10 39       	cp.w	r9,r8
80003918:	e0 88 00 1a 	brls	8000394c <display_init+0x154>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000391c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003920:	70 08       	ld.w	r8,r8[0x0]
80003922:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003926:	10 39       	cp.w	r9,r8
80003928:	c1 02       	brcc	80003948 <display_init+0x150>
8000392a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000392e:	70 18       	ld.w	r8,r8[0x4]
80003930:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003934:	10 39       	cp.w	r9,r8
80003936:	e0 88 00 09 	brls	80003948 <display_init+0x150>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000393a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000393e:	30 18       	mov	r8,1
80003940:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80003944:	30 18       	mov	r8,1
80003946:	c1 a8       	rjmp	8000397a <display_init+0x182>
    }
    return false;
80003948:	30 08       	mov	r8,0
8000394a:	c1 88       	rjmp	8000397a <display_init+0x182>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000394c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003950:	70 08       	ld.w	r8,r8[0x0]
80003952:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003956:	10 39       	cp.w	r9,r8
80003958:	c0 93       	brcs	8000396a <display_init+0x172>
8000395a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000395e:	70 18       	ld.w	r8,r8[0x4]
80003960:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003964:	10 39       	cp.w	r9,r8
80003966:	e0 88 00 09 	brls	80003978 <display_init+0x180>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000396a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000396e:	30 18       	mov	r8,1
80003970:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80003974:	30 18       	mov	r8,1
80003976:	c0 28       	rjmp	8000397a <display_init+0x182>
    }
    return false;
80003978:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
8000397a:	58 08       	cp.w	r8,0
8000397c:	ca b0       	breq	800038d2 <display_init+0xda>

	// Enable the SPI peripheral on GPIO pins
	gpio_enable_module(DIP204_SPI_GPIO_MAP,
8000397e:	30 4b       	mov	r11,4
80003980:	49 ec       	lddpc	r12,800039f8 <display_init+0x200>
80003982:	f0 1f 00 1f 	mcall	800039fc <display_init+0x204>
						sizeof(DIP204_SPI_GPIO_MAP) / 	sizeof(DIP204_SPI_GPIO_MAP[0]));

	// Initialize as SPI master
	spi_initMaster(DIP204_SPI, &spiOptions);
80003986:	ee c8 00 34 	sub	r8,r7,52
8000398a:	10 9b       	mov	r11,r8
8000398c:	fe 7c 28 00 	mov	r12,-55296
80003990:	f0 1f 00 1c 	mcall	80003a00 <display_init+0x208>
	spi_selectionMode(DIP204_SPI, 0, 0, 0);
80003994:	30 09       	mov	r9,0
80003996:	30 0a       	mov	r10,0
80003998:	30 0b       	mov	r11,0
8000399a:	fe 7c 28 00 	mov	r12,-55296
8000399e:	f0 1f 00 1a 	mcall	80003a04 <display_init+0x20c>
	spi_enable(DIP204_SPI);
800039a2:	fe 7c 28 00 	mov	r12,-55296
800039a6:	f0 1f 00 19 	mcall	80003a08 <display_init+0x210>
	spi_setupChipReg(DIP204_SPI, &spiOptions, FOSC0);
800039aa:	ee c8 00 34 	sub	r8,r7,52
800039ae:	e0 6a 1b 00 	mov	r10,6912
800039b2:	ea 1a 00 b7 	orh	r10,0xb7
800039b6:	10 9b       	mov	r11,r8
800039b8:	fe 7c 28 00 	mov	r12,-55296
800039bc:	f0 1f 00 14 	mcall	80003a0c <display_init+0x214>

	dip204_init(backlight_IO, ON);
800039c0:	30 1b       	mov	r11,1
800039c2:	30 0c       	mov	r12,0
800039c4:	f0 1f 00 13 	mcall	80003a10 <display_init+0x218>
	dip204_clear_display();
800039c8:	f0 1f 00 13 	mcall	80003a14 <display_init+0x21c>
	dip204_hide_cursor();
800039cc:	f0 1f 00 13 	mcall	80003a18 <display_init+0x220>
	dip204_set_cursor_position(1,1);
800039d0:	30 1b       	mov	r11,1
800039d2:	30 1c       	mov	r12,1
800039d4:	f0 1f 00 12 	mcall	80003a1c <display_init+0x224>
}
800039d8:	2f 0d       	sub	sp,-64
800039da:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
800039de:	00 00       	add	r0,r0
800039e0:	80 00       	ld.sh	r0,r0[0x0]
800039e2:	c4 18       	rjmp	80003a64 <initLED+0x44>
800039e4:	80 00       	ld.sh	r0,r0[0x0]
800039e6:	45 e4       	lddsp	r4,sp[0x178]
800039e8:	80 00       	ld.sh	r0,r0[0x0]
800039ea:	46 48       	lddsp	r8,sp[0x190]
800039ec:	80 00       	ld.sh	r0,r0[0x0]
800039ee:	46 f4       	lddsp	r4,sp[0x1bc]
800039f0:	80 00       	ld.sh	r0,r0[0x0]
800039f2:	37 e0       	mov	r0,126
800039f4:	80 00       	ld.sh	r0,r0[0x0]
800039f6:	66 94       	ld.w	r4,r3[0x24]
800039f8:	80 00       	ld.sh	r0,r0[0x0]
800039fa:	c4 28       	rjmp	80003a7e <initLED+0x5e>
800039fc:	80 00       	ld.sh	r0,r0[0x0]
800039fe:	41 50       	lddsp	r0,sp[0x54]
80003a00:	80 00       	ld.sh	r0,r0[0x0]
80003a02:	33 52       	mov	r2,53
80003a04:	80 00       	ld.sh	r0,r0[0x0]
80003a06:	33 e6       	mov	r6,62
80003a08:	80 00       	ld.sh	r0,r0[0x0]
80003a0a:	37 00       	mov	r0,112
80003a0c:	80 00       	ld.sh	r0,r0[0x0]
80003a0e:	35 7c       	mov	r12,87
80003a10:	80 00       	ld.sh	r0,r0[0x0]
80003a12:	21 08       	sub	r8,16
80003a14:	80 00       	ld.sh	r0,r0[0x0]
80003a16:	2c a0       	sub	r0,-54
80003a18:	80 00       	ld.sh	r0,r0[0x0]
80003a1a:	2b e4       	sub	r4,-66
80003a1c:	80 00       	ld.sh	r0,r0[0x0]
80003a1e:	2c 18       	sub	r8,-63

80003a20 <initLED>:
#include "LED.h"

void initLED (void)
{
80003a20:	eb cd 40 80 	pushm	r7,lr
80003a24:	1a 97       	mov	r7,sp
80003a26:	20 1d       	sub	sp,4
	/*
	* First make access to the GPIO port registers
	* shorter to type , just for our convenience
	*/
	volatile avr32_gpio_port_t * led0_port;
	led0_port = &AVR32_GPIO.port[LED0_PORT];
80003a28:	fe 78 11 00 	mov	r8,-61184
80003a2c:	ef 48 ff fc 	st.w	r7[-4],r8
	/*
	* Choose GPIO peripheral function ,
	* by writing a 1 to gpers , GPIO Enable Register Set
	*/
	led0_port->gpers = LED0_BIT_VALUE;
80003a30:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a34:	fc 19 08 00 	movh	r9,0x800
80003a38:	91 19       	st.w	r8[0x4],r9
	led0_port->gpers = LED1_BIT_VALUE;
80003a3a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a3e:	fc 19 10 00 	movh	r9,0x1000
80003a42:	91 19       	st.w	r8[0x4],r9
	led0_port->gpers = LED2_BIT_VALUE;
80003a44:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a48:	fc 19 20 00 	movh	r9,0x2000
80003a4c:	91 19       	st.w	r8[0x4],r9
	/*
	* Set the output value register to 1 in order to
	* turn the LED off (1= off , 0= on in this case ) ,
	* by writing a 1 to ovrs , Output Value Register Set
	*/
	led0_port->ovrs = LED0_BIT_VALUE;
80003a4e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a52:	fc 19 08 00 	movh	r9,0x800
80003a56:	f1 49 00 54 	st.w	r8[84],r9
	led0_port->ovrs = LED1_BIT_VALUE;
80003a5a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a5e:	fc 19 10 00 	movh	r9,0x1000
80003a62:	f1 49 00 54 	st.w	r8[84],r9
	led0_port->ovrs = LED2_BIT_VALUE;
80003a66:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a6a:	fc 19 20 00 	movh	r9,0x2000
80003a6e:	f1 49 00 54 	st.w	r8[84],r9
	/*
	* Set the output enable register ,
	* by writing a 1 to oders , Output Drive Enable
	* Register Set
	*/
	led0_port->oders = LED0_BIT_VALUE;
80003a72:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a76:	fc 19 08 00 	movh	r9,0x800
80003a7a:	f1 49 00 44 	st.w	r8[68],r9
	led0_port->oders = LED1_BIT_VALUE;
80003a7e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a82:	fc 19 10 00 	movh	r9,0x1000
80003a86:	f1 49 00 44 	st.w	r8[68],r9
	led0_port->oders = LED2_BIT_VALUE;
80003a8a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a8e:	fc 19 20 00 	movh	r9,0x2000
80003a92:	f1 49 00 44 	st.w	r8[68],r9
}
80003a96:	2f fd       	sub	sp,-4
80003a98:	e3 cd 80 80 	ldm	sp++,r7,pc

80003a9c <onLED>:
{
	AVR32_GPIO.port[LED0_PORT].ovrt = ledNr;
}

void onLED(int ledNr)
{
80003a9c:	eb cd 40 80 	pushm	r7,lr
80003aa0:	1a 97       	mov	r7,sp
80003aa2:	20 1d       	sub	sp,4
80003aa4:	ef 4c ff fc 	st.w	r7[-4],r12
	AVR32_GPIO.port[LED0_PORT].ovrc = ledNr;
80003aa8:	fe 78 10 00 	mov	r8,-61440
80003aac:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003ab0:	f1 49 01 58 	st.w	r8[344],r9
}
80003ab4:	2f fd       	sub	sp,-4
80003ab6:	e3 cd 80 80 	ldm	sp++,r7,pc
80003aba:	d7 03       	nop
80003abc:	54 65       	stdsp	sp[0x118],r5
80003abe:	6d 70       	ld.w	r0,r6[0x5c]
80003ac0:	65 72       	ld.w	r2,r2[0x5c]
80003ac2:	61 74       	ld.w	r4,r0[0x5c]
80003ac4:	75 72       	ld.w	r2,r10[0x5c]
80003ac6:	65 3a       	ld.w	r10,r2[0x4c]
80003ac8:	00 00       	add	r0,r0
80003aca:	00 00       	add	r0,r0
80003acc:	50 6f       	stdsp	sp[0x18],pc
80003ace:	74 65       	ld.w	r5,r10[0x18]
80003ad0:	6e 74       	ld.w	r4,r7[0x1c]
80003ad2:	69 6f       	ld.w	pc,r4[0x58]
80003ad4:	6d 65       	ld.w	r5,r6[0x58]
80003ad6:	74 65       	ld.w	r5,r10[0x18]
80003ad8:	72 3a       	ld.w	r10,r9[0xc]
80003ada:	00 00       	add	r0,r0
80003adc:	4c 69       	lddpc	r9,80003bf4 <vTemperature+0x3c>
80003ade:	67 68       	ld.w	r8,r3[0x58]
80003ae0:	74 3a       	ld.w	r10,r10[0xc]
80003ae2:	00 00       	add	r0,r0
80003ae4:	54 65       	stdsp	sp[0x118],r5
80003ae6:	6d 70       	ld.w	r0,r6[0x5c]
80003ae8:	65 72       	ld.w	r2,r2[0x5c]
80003aea:	61 74       	ld.w	r4,r0[0x5c]
80003aec:	75 72       	ld.w	r2,r10[0x5c]
80003aee:	65 20       	ld.w	r0,r2[0x48]
80003af0:	25 64       	sub	r4,86
80003af2:	0a 00       	add	r0,r5
80003af4:	50 6f       	stdsp	sp[0x18],pc
80003af6:	74 65       	ld.w	r5,r10[0x18]
80003af8:	6e 74       	ld.w	r4,r7[0x1c]
80003afa:	69 6f       	ld.w	pc,r4[0x58]
80003afc:	6d 65       	ld.w	r5,r6[0x58]
80003afe:	74 65       	ld.w	r5,r10[0x18]
80003b00:	72 20       	ld.w	r0,r9[0x8]
80003b02:	25 64       	sub	r4,86
80003b04:	0a 00       	add	r0,r5
80003b06:	00 00       	add	r0,r0
80003b08:	4c 69       	lddpc	r9,80003c20 <vTemperature+0x68>
80003b0a:	67 68       	ld.w	r8,r3[0x58]
80003b0c:	74 20       	ld.w	r0,r10[0x8]
80003b0e:	25 64       	sub	r4,86
80003b10:	0a 00       	add	r0,r5
80003b12:	00 00       	add	r0,r0
80003b14:	25 30       	sub	r0,83
80003b16:	34 64       	mov	r4,70
80003b18:	00 00       	add	r0,r0
80003b1a:	00 00       	add	r0,r0
80003b1c:	76 43       	ld.w	r3,r11[0x10]
80003b1e:	6f 6e       	ld.w	lr,r7[0x58]
80003b20:	73 75       	ld.w	r5,r9[0x5c]
80003b22:	6d 65       	ld.w	r5,r6[0x58]
80003b24:	72 00       	ld.w	r0,r9[0x0]
80003b26:	00 00       	add	r0,r0
80003b28:	76 54       	ld.w	r4,r11[0x14]
80003b2a:	65 6d       	ld.w	sp,r2[0x58]
80003b2c:	70 65       	ld.w	r5,r8[0x18]
80003b2e:	72 61       	ld.w	r1,r9[0x18]
80003b30:	74 75       	ld.w	r5,r10[0x1c]
80003b32:	72 65       	ld.w	r5,r9[0x18]
80003b34:	00 00       	add	r0,r0
80003b36:	00 00       	add	r0,r0
80003b38:	76 50       	ld.w	r0,r11[0x14]
80003b3a:	6f 74       	ld.w	r4,r7[0x5c]
80003b3c:	65 6e       	ld.w	lr,r2[0x58]
80003b3e:	74 69       	ld.w	r9,r10[0x18]
80003b40:	6f 6d       	ld.w	sp,r7[0x58]
80003b42:	65 74       	ld.w	r4,r2[0x5c]
80003b44:	65 72       	ld.w	r2,r2[0x5c]
80003b46:	00 00       	add	r0,r0
80003b48:	76 4c       	ld.w	r12,r11[0x10]
80003b4a:	69 67       	ld.w	r7,r4[0x58]
80003b4c:	68 74       	ld.w	r4,r4[0x1c]
	...

80003b50 <init_usart>:
xTaskHandle xHandleTemperature;		// Task handle - Temperature
xTaskHandle xHandlePotentiometer;	// Task handle - Potentiometer
xTaskHandle xHandleLight;			// Task handle - Light

void init_usart ( void )
{
80003b50:	eb cd 40 80 	pushm	r7,lr
80003b54:	1a 97       	mov	r7,sp
		. charlength = 8,
		. paritytype = USART_NO_PARITY ,
		. stopbits = USART_1_STOPBIT ,
		. channelmode = USART_NORMAL_CHMODE
	};
	pm_switch_to_osc0 (& AVR32_PM , FOSC0 , OSC0_STARTUP );				// Switch to 12 MHz clock
80003b56:	30 3a       	mov	r10,3
80003b58:	e0 6b 1b 00 	mov	r11,6912
80003b5c:	ea 1b 00 b7 	orh	r11,0xb7
80003b60:	fe 7c 0c 00 	mov	r12,-62464
80003b64:	f0 1f 00 0f 	mcall	80003ba0 <init_usart+0x50>
	gpio_enable_module ( USART_SERIAL_GPIO_MAP , 2);					// Enable usart
80003b68:	30 2b       	mov	r11,2
80003b6a:	48 fc       	lddpc	r12,80003ba4 <init_usart+0x54>
80003b6c:	f0 1f 00 0f 	mcall	80003ba8 <init_usart+0x58>
	gpio_enable_module ( USART_DEBUG_GPIO_MAP , 2);
80003b70:	30 2b       	mov	r11,2
80003b72:	48 fc       	lddpc	r12,80003bac <init_usart+0x5c>
80003b74:	f0 1f 00 0d 	mcall	80003ba8 <init_usart+0x58>
	usart_init_rs232 ( serialPORT_USART , & USART_OPTIONS , FOSC0 );	// Usart options
80003b78:	e0 6a 1b 00 	mov	r10,6912
80003b7c:	ea 1a 00 b7 	orh	r10,0xb7
80003b80:	48 cb       	lddpc	r11,80003bb0 <init_usart+0x60>
80003b82:	fe 7c 18 00 	mov	r12,-59392
80003b86:	f0 1f 00 0c 	mcall	80003bb4 <init_usart+0x64>
	usart_init_rs232 ( configDBG_USART , & USART_OPTIONS , FOSC0 );
80003b8a:	e0 6a 1b 00 	mov	r10,6912
80003b8e:	ea 1a 00 b7 	orh	r10,0xb7
80003b92:	48 8b       	lddpc	r11,80003bb0 <init_usart+0x60>
80003b94:	fe 7c 18 00 	mov	r12,-59392
80003b98:	f0 1f 00 07 	mcall	80003bb4 <init_usart+0x64>
}
80003b9c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003ba0:	80 00       	ld.sh	r0,r0[0x0]
80003ba2:	47 40       	lddsp	r0,sp[0x1d0]
80003ba4:	80 00       	ld.sh	r0,r0[0x0]
80003ba6:	c4 48       	rjmp	80003c2e <vTemperature+0x76>
80003ba8:	80 00       	ld.sh	r0,r0[0x0]
80003baa:	41 50       	lddsp	r0,sp[0x54]
80003bac:	80 00       	ld.sh	r0,r0[0x0]
80003bae:	c4 58       	rjmp	80003c38 <vPotentiometer>
80003bb0:	80 00       	ld.sh	r0,r0[0x0]
80003bb2:	c4 68       	rjmp	80003c3e <vPotentiometer+0x6>
80003bb4:	80 00       	ld.sh	r0,r0[0x0]
80003bb6:	48 f0       	lddpc	r0,80003bf0 <vTemperature+0x38>

80003bb8 <vTemperature>:

void vTemperature(void *pvParameters)
{
80003bb8:	eb cd 40 80 	pushm	r7,lr
80003bbc:	1a 97       	mov	r7,sp
80003bbe:	20 2d       	sub	sp,8
80003bc0:	ef 4c ff f8 	st.w	r7[-8],r12
80003bc4:	c0 28       	rjmp	80003bc8 <vTemperature+0x10>
			if(xSemaphoreGive(xFillCountTemperature) == pdTRUE)
			{
				// Semaphore given
			}
		}
	}
80003bc6:	d7 03       	nop
{
	volatile uint32_t value_to_send;		// Character to send to Consumer
	
	while(1)
	{
		if(xSemaphoreTake(xEmptyCountTemperature, (portTickType)portMAX_DELAY) == pdTRUE)
80003bc8:	49 58       	lddpc	r8,80003c1c <vTemperature+0x64>
80003bca:	70 08       	ld.w	r8,r8[0x0]
80003bcc:	30 09       	mov	r9,0
80003bce:	3f fa       	mov	r10,-1
80003bd0:	30 0b       	mov	r11,0
80003bd2:	10 9c       	mov	r12,r8
80003bd4:	f0 1f 00 13 	mcall	80003c20 <vTemperature+0x68>
80003bd8:	18 98       	mov	r8,r12
80003bda:	58 18       	cp.w	r8,1
80003bdc:	cf 51       	brne	80003bc6 <vTemperature+0xe>
		{
			// Semaphore taken
			adc_start(&AVR32_ADC);
80003bde:	fe 7c 3c 00 	mov	r12,-50176
80003be2:	f0 1f 00 11 	mcall	80003c24 <vTemperature+0x6c>
			value_to_send = adc_get_value(&AVR32_ADC, ADC_TEMPERATURE_CHANNEL);
80003be6:	30 0b       	mov	r11,0
80003be8:	fe 7c 3c 00 	mov	r12,-50176
80003bec:	f0 1f 00 0f 	mcall	80003c28 <vTemperature+0x70>
80003bf0:	18 98       	mov	r8,r12
80003bf2:	ef 48 ff fc 	st.w	r7[-4],r8
			xQueueSendToBack(xQHandleTemperature, &value_to_send, (portTickType)10);
80003bf6:	48 e8       	lddpc	r8,80003c2c <vTemperature+0x74>
80003bf8:	70 08       	ld.w	r8,r8[0x0]
80003bfa:	ee cb 00 04 	sub	r11,r7,4
80003bfe:	30 09       	mov	r9,0
80003c00:	30 aa       	mov	r10,10
80003c02:	10 9c       	mov	r12,r8
80003c04:	f0 1f 00 0b 	mcall	80003c30 <vTemperature+0x78>
		
			if(xSemaphoreGive(xFillCountTemperature) == pdTRUE)
80003c08:	48 b8       	lddpc	r8,80003c34 <vTemperature+0x7c>
80003c0a:	70 08       	ld.w	r8,r8[0x0]
80003c0c:	30 09       	mov	r9,0
80003c0e:	30 0a       	mov	r10,0
80003c10:	30 0b       	mov	r11,0
80003c12:	10 9c       	mov	r12,r8
80003c14:	f0 1f 00 07 	mcall	80003c30 <vTemperature+0x78>
			{
				// Semaphore given
			}
		}
	}
80003c18:	cd 8b       	rjmp	80003bc8 <vTemperature+0x10>
80003c1a:	00 00       	add	r0,r0
80003c1c:	00 00       	add	r0,r0
80003c1e:	07 dc       	ld.ub	r12,r3[0x5]
80003c20:	80 00       	ld.sh	r0,r0[0x0]
80003c22:	56 40       	stdsp	sp[0x190],r0
80003c24:	80 00       	ld.sh	r0,r0[0x0]
80003c26:	30 d6       	mov	r6,13
80003c28:	80 00       	ld.sh	r0,r0[0x0]
80003c2a:	31 4c       	mov	r12,20
80003c2c:	00 00       	add	r0,r0
80003c2e:	07 fc       	ld.ub	r12,r3[0x7]
80003c30:	80 00       	ld.sh	r0,r0[0x0]
80003c32:	54 d8       	stdsp	sp[0x134],r8
80003c34:	00 00       	add	r0,r0
80003c36:	07 d8       	ld.ub	r8,r3[0x5]

80003c38 <vPotentiometer>:
}

void vPotentiometer(void *pvParameters)
{
80003c38:	eb cd 40 80 	pushm	r7,lr
80003c3c:	1a 97       	mov	r7,sp
80003c3e:	20 2d       	sub	sp,8
80003c40:	ef 4c ff f8 	st.w	r7[-8],r12
80003c44:	c0 28       	rjmp	80003c48 <vPotentiometer+0x10>
			if(xSemaphoreGive(xFillCountPotentiometer) == pdTRUE)
			{
				// Semaphore given
			}
		}
	}
80003c46:	d7 03       	nop
{
	volatile uint32_t value_to_send;		// Character to send to Consumer
	
	while(1)
	{		
		if(xSemaphoreTake(xEmptyCountPotentiometer, (portTickType)portMAX_DELAY) == pdTRUE)
80003c48:	49 58       	lddpc	r8,80003c9c <vPotentiometer+0x64>
80003c4a:	70 08       	ld.w	r8,r8[0x0]
80003c4c:	30 09       	mov	r9,0
80003c4e:	3f fa       	mov	r10,-1
80003c50:	30 0b       	mov	r11,0
80003c52:	10 9c       	mov	r12,r8
80003c54:	f0 1f 00 13 	mcall	80003ca0 <vPotentiometer+0x68>
80003c58:	18 98       	mov	r8,r12
80003c5a:	58 18       	cp.w	r8,1
80003c5c:	cf 51       	brne	80003c46 <vPotentiometer+0xe>
		{
			// Semaphore taken
			adc_start(&AVR32_ADC);
80003c5e:	fe 7c 3c 00 	mov	r12,-50176
80003c62:	f0 1f 00 11 	mcall	80003ca4 <vPotentiometer+0x6c>
			value_to_send = adc_get_value(&AVR32_ADC, ADC_POTENTIOMETER_CHANNEL);
80003c66:	30 1b       	mov	r11,1
80003c68:	fe 7c 3c 00 	mov	r12,-50176
80003c6c:	f0 1f 00 0f 	mcall	80003ca8 <vPotentiometer+0x70>
80003c70:	18 98       	mov	r8,r12
80003c72:	ef 48 ff fc 	st.w	r7[-4],r8
			xQueueSendToBack(xQHandlePotentiometer, &value_to_send, (portTickType)10);	
80003c76:	48 e8       	lddpc	r8,80003cac <vPotentiometer+0x74>
80003c78:	70 08       	ld.w	r8,r8[0x0]
80003c7a:	ee cb 00 04 	sub	r11,r7,4
80003c7e:	30 09       	mov	r9,0
80003c80:	30 aa       	mov	r10,10
80003c82:	10 9c       	mov	r12,r8
80003c84:	f0 1f 00 0b 	mcall	80003cb0 <vPotentiometer+0x78>
				
			if(xSemaphoreGive(xFillCountPotentiometer) == pdTRUE)
80003c88:	48 b8       	lddpc	r8,80003cb4 <vPotentiometer+0x7c>
80003c8a:	70 08       	ld.w	r8,r8[0x0]
80003c8c:	30 09       	mov	r9,0
80003c8e:	30 0a       	mov	r10,0
80003c90:	30 0b       	mov	r11,0
80003c92:	10 9c       	mov	r12,r8
80003c94:	f0 1f 00 07 	mcall	80003cb0 <vPotentiometer+0x78>
			{
				// Semaphore given
			}
		}
	}
80003c98:	cd 8b       	rjmp	80003c48 <vPotentiometer+0x10>
80003c9a:	00 00       	add	r0,r0
80003c9c:	00 00       	add	r0,r0
80003c9e:	08 00       	add	r0,r4
80003ca0:	80 00       	ld.sh	r0,r0[0x0]
80003ca2:	56 40       	stdsp	sp[0x190],r0
80003ca4:	80 00       	ld.sh	r0,r0[0x0]
80003ca6:	30 d6       	mov	r6,13
80003ca8:	80 00       	ld.sh	r0,r0[0x0]
80003caa:	31 4c       	mov	r12,20
80003cac:	00 00       	add	r0,r0
80003cae:	07 f4       	ld.ub	r4,r3[0x7]
80003cb0:	80 00       	ld.sh	r0,r0[0x0]
80003cb2:	54 d8       	stdsp	sp[0x134],r8
80003cb4:	00 00       	add	r0,r0
80003cb6:	07 e4       	ld.ub	r4,r3[0x6]

80003cb8 <vLight>:
}

void vLight(void *pvParameters)
{
80003cb8:	eb cd 40 80 	pushm	r7,lr
80003cbc:	1a 97       	mov	r7,sp
80003cbe:	20 2d       	sub	sp,8
80003cc0:	ef 4c ff f8 	st.w	r7[-8],r12
80003cc4:	c0 28       	rjmp	80003cc8 <vLight+0x10>
			if(xSemaphoreGive(xFillCountLight) == pdTRUE)
			{
				// Semaphore given
			}
		}
	}
80003cc6:	d7 03       	nop
{
	volatile uint32_t value_to_send;		// Character to send to Consumer
	
	while(1)
	{		
		if(xSemaphoreTake(xEmptyCountLight, (portTickType)portMAX_DELAY) == pdTRUE)
80003cc8:	49 58       	lddpc	r8,80003d1c <vLight+0x64>
80003cca:	70 08       	ld.w	r8,r8[0x0]
80003ccc:	30 09       	mov	r9,0
80003cce:	3f fa       	mov	r10,-1
80003cd0:	30 0b       	mov	r11,0
80003cd2:	10 9c       	mov	r12,r8
80003cd4:	f0 1f 00 13 	mcall	80003d20 <vLight+0x68>
80003cd8:	18 98       	mov	r8,r12
80003cda:	58 18       	cp.w	r8,1
80003cdc:	cf 51       	brne	80003cc6 <vLight+0xe>
		{
			// Semaphore taken
			adc_start(&AVR32_ADC);
80003cde:	fe 7c 3c 00 	mov	r12,-50176
80003ce2:	f0 1f 00 11 	mcall	80003d24 <vLight+0x6c>
			value_to_send = adc_get_value(&AVR32_ADC, ADC_LIGHT_CHANNEL);
80003ce6:	30 2b       	mov	r11,2
80003ce8:	fe 7c 3c 00 	mov	r12,-50176
80003cec:	f0 1f 00 0f 	mcall	80003d28 <vLight+0x70>
80003cf0:	18 98       	mov	r8,r12
80003cf2:	ef 48 ff fc 	st.w	r7[-4],r8
			xQueueSendToBack(xQHandleLight, &value_to_send, (portTickType)10);
80003cf6:	48 e8       	lddpc	r8,80003d2c <vLight+0x74>
80003cf8:	70 08       	ld.w	r8,r8[0x0]
80003cfa:	ee cb 00 04 	sub	r11,r7,4
80003cfe:	30 09       	mov	r9,0
80003d00:	30 aa       	mov	r10,10
80003d02:	10 9c       	mov	r12,r8
80003d04:	f0 1f 00 0b 	mcall	80003d30 <vLight+0x78>
		
			if(xSemaphoreGive(xFillCountLight) == pdTRUE)
80003d08:	48 b8       	lddpc	r8,80003d34 <vLight+0x7c>
80003d0a:	70 08       	ld.w	r8,r8[0x0]
80003d0c:	30 09       	mov	r9,0
80003d0e:	30 0a       	mov	r10,0
80003d10:	30 0b       	mov	r11,0
80003d12:	10 9c       	mov	r12,r8
80003d14:	f0 1f 00 07 	mcall	80003d30 <vLight+0x78>
			{
				// Semaphore given
			}
		}
	}
80003d18:	cd 8b       	rjmp	80003cc8 <vLight+0x10>
80003d1a:	00 00       	add	r0,r0
80003d1c:	00 00       	add	r0,r0
80003d1e:	07 f8       	ld.ub	r8,r3[0x7]
80003d20:	80 00       	ld.sh	r0,r0[0x0]
80003d22:	56 40       	stdsp	sp[0x190],r0
80003d24:	80 00       	ld.sh	r0,r0[0x0]
80003d26:	30 d6       	mov	r6,13
80003d28:	80 00       	ld.sh	r0,r0[0x0]
80003d2a:	31 4c       	mov	r12,20
80003d2c:	00 00       	add	r0,r0
80003d2e:	07 e8       	ld.ub	r8,r3[0x6]
80003d30:	80 00       	ld.sh	r0,r0[0x0]
80003d32:	54 d8       	stdsp	sp[0x134],r8
80003d34:	00 00       	add	r0,r0
80003d36:	08 04       	add	r4,r4

80003d38 <vConsumer>:
}

void vConsumer( void *pvParameters )
{
80003d38:	eb cd 40 80 	pushm	r7,lr
80003d3c:	1a 97       	mov	r7,sp
80003d3e:	21 5d       	sub	sp,84
80003d40:	ef 4c ff ac 	st.w	r7[-84],r12
	volatile uint32_t temperature_received = 0;		// Value received
80003d44:	30 08       	mov	r8,0
80003d46:	ef 48 ff f0 	st.w	r7[-16],r8
	volatile uint32_t potentiometer_received = 0;	// Value received
80003d4a:	30 08       	mov	r8,0
80003d4c:	ef 48 ff ec 	st.w	r7[-20],r8
	volatile uint32_t light_received = 0;			// Value received
80003d50:	30 08       	mov	r8,0
80003d52:	ef 48 ff e8 	st.w	r7[-24],r8
	volatile uint32_t temp_usart_write = 0;			// Value received
80003d56:	30 08       	mov	r8,0
80003d58:	ef 48 ff e4 	st.w	r7[-28],r8
	volatile uint32_t pot_usart_write = 0;			// Value received
80003d5c:	30 08       	mov	r8,0
80003d5e:	ef 48 ff e0 	st.w	r7[-32],r8
	volatile uint32_t light_usart_write = 0;			// Value received
80003d62:	30 08       	mov	r8,0
80003d64:	ef 48 ff dc 	st.w	r7[-36],r8
	volatile const char * string_temp = "Temperature:";
80003d68:	4f 68       	lddpc	r8,80003f40 <vConsumer+0x208>
80003d6a:	ef 48 ff f4 	st.w	r7[-12],r8
	volatile const char * string_potentiometer = "Potentiometer:";
80003d6e:	4f 68       	lddpc	r8,80003f44 <vConsumer+0x20c>
80003d70:	ef 48 ff f8 	st.w	r7[-8],r8
	volatile const char * string_light = "Light:";
80003d74:	4f 58       	lddpc	r8,80003f48 <vConsumer+0x210>
80003d76:	ef 48 ff fc 	st.w	r7[-4],r8
	volatile char temperature_usart[10];
	volatile char potentiometer_usart[10];
	volatile char light_usart[10];
	
	volatile portTickType xLastWakeTime; // Holds tick count
	xLastWakeTime = xTaskGetTickCount(); // Sets current tick count
80003d7a:	f0 1f 00 75 	mcall	80003f4c <vConsumer+0x214>
80003d7e:	18 98       	mov	r8,r12
80003d80:	ef 48 ff b4 	st.w	r7[-76],r8
	volatile const portTickType xFreq = TASK_DELAY_MS(100); // Holds the period	
80003d84:	36 48       	mov	r8,100
80003d86:	ef 48 ff b0 	st.w	r7[-80],r8
	
	dip204_clear_display();
80003d8a:	f0 1f 00 72 	mcall	80003f50 <vConsumer+0x218>
	dip204_set_cursor_position(1, 1);
80003d8e:	30 1b       	mov	r11,1
80003d90:	30 1c       	mov	r12,1
80003d92:	f0 1f 00 71 	mcall	80003f54 <vConsumer+0x21c>
	dip204_write_string(string_temp);
80003d96:	ee fc ff f4 	ld.w	r12,r7[-12]
80003d9a:	f0 1f 00 70 	mcall	80003f58 <vConsumer+0x220>
	dip204_set_cursor_position(1, 2);
80003d9e:	30 2b       	mov	r11,2
80003da0:	30 1c       	mov	r12,1
80003da2:	f0 1f 00 6d 	mcall	80003f54 <vConsumer+0x21c>
	dip204_write_string(string_potentiometer);
80003da6:	ee fc ff f8 	ld.w	r12,r7[-8]
80003daa:	f0 1f 00 6c 	mcall	80003f58 <vConsumer+0x220>
	dip204_set_cursor_position(1, 3);
80003dae:	30 3b       	mov	r11,3
80003db0:	30 1c       	mov	r12,1
80003db2:	f0 1f 00 69 	mcall	80003f54 <vConsumer+0x21c>
	dip204_write_string(string_light);
80003db6:	ee fc ff fc 	ld.w	r12,r7[-4]
80003dba:	f0 1f 00 68 	mcall	80003f58 <vConsumer+0x220>
	
	onLED(LED3_BIT_VALUE);	// On when Consumer is active
80003dbe:	fc 1c 40 00 	movh	r12,0x4000
80003dc2:	f0 1f 00 67 	mcall	80003f5c <vConsumer+0x224>
	
	while(1)
	{
		if(xSemaphoreTake(xFillCountTemperature, (portTickType)10) == pdTRUE)
80003dc6:	4e 78       	lddpc	r8,80003f60 <vConsumer+0x228>
80003dc8:	70 08       	ld.w	r8,r8[0x0]
80003dca:	30 09       	mov	r9,0
80003dcc:	30 aa       	mov	r10,10
80003dce:	30 0b       	mov	r11,0
80003dd0:	10 9c       	mov	r12,r8
80003dd2:	f0 1f 00 65 	mcall	80003f64 <vConsumer+0x22c>
80003dd6:	18 98       	mov	r8,r12
80003dd8:	58 18       	cp.w	r8,1
80003dda:	c1 61       	brne	80003e06 <vConsumer+0xce>
		{
			// Semaphore taken
			xQueueReceive(xQHandleTemperature, &temperature_received, (portTickType)10);
80003ddc:	4e 38       	lddpc	r8,80003f68 <vConsumer+0x230>
80003dde:	70 08       	ld.w	r8,r8[0x0]
80003de0:	ee cb 00 10 	sub	r11,r7,16
80003de4:	30 09       	mov	r9,0
80003de6:	30 aa       	mov	r10,10
80003de8:	10 9c       	mov	r12,r8
80003dea:	f0 1f 00 5f 	mcall	80003f64 <vConsumer+0x22c>
			temp_usart_write = temperature_received;
80003dee:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003df2:	ef 48 ff e4 	st.w	r7[-28],r8
		
			if(xSemaphoreGive(xEmptyCountTemperature) == pdTRUE)
80003df6:	4d e8       	lddpc	r8,80003f6c <vConsumer+0x234>
80003df8:	70 08       	ld.w	r8,r8[0x0]
80003dfa:	30 09       	mov	r9,0
80003dfc:	30 0a       	mov	r10,0
80003dfe:	30 0b       	mov	r11,0
80003e00:	10 9c       	mov	r12,r8
80003e02:	f0 1f 00 5c 	mcall	80003f70 <vConsumer+0x238>
			{
				// Semaphore given
			}
		}
		
		if(xSemaphoreTake(xFillCountPotentiometer, (portTickType)10) == pdTRUE)
80003e06:	4d c8       	lddpc	r8,80003f74 <vConsumer+0x23c>
80003e08:	70 08       	ld.w	r8,r8[0x0]
80003e0a:	30 09       	mov	r9,0
80003e0c:	30 aa       	mov	r10,10
80003e0e:	30 0b       	mov	r11,0
80003e10:	10 9c       	mov	r12,r8
80003e12:	f0 1f 00 55 	mcall	80003f64 <vConsumer+0x22c>
80003e16:	18 98       	mov	r8,r12
80003e18:	58 18       	cp.w	r8,1
80003e1a:	c1 61       	brne	80003e46 <vConsumer+0x10e>
		{
			// Semaphore taken
			xQueueReceive(xQHandlePotentiometer, &potentiometer_received, (portTickType)10);
80003e1c:	4d 78       	lddpc	r8,80003f78 <vConsumer+0x240>
80003e1e:	70 08       	ld.w	r8,r8[0x0]
80003e20:	ee cb 00 14 	sub	r11,r7,20
80003e24:	30 09       	mov	r9,0
80003e26:	30 aa       	mov	r10,10
80003e28:	10 9c       	mov	r12,r8
80003e2a:	f0 1f 00 4f 	mcall	80003f64 <vConsumer+0x22c>
			pot_usart_write = potentiometer_received;
80003e2e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003e32:	ef 48 ff e0 	st.w	r7[-32],r8
		
			if(xSemaphoreGive(xEmptyCountPotentiometer) == pdTRUE)
80003e36:	4d 28       	lddpc	r8,80003f7c <vConsumer+0x244>
80003e38:	70 08       	ld.w	r8,r8[0x0]
80003e3a:	30 09       	mov	r9,0
80003e3c:	30 0a       	mov	r10,0
80003e3e:	30 0b       	mov	r11,0
80003e40:	10 9c       	mov	r12,r8
80003e42:	f0 1f 00 4c 	mcall	80003f70 <vConsumer+0x238>
			{
				// Semaphore given
			}
		}		

		if(xSemaphoreTake(xFillCountLight, (portTickType)10) == pdTRUE)
80003e46:	4c f8       	lddpc	r8,80003f80 <vConsumer+0x248>
80003e48:	70 08       	ld.w	r8,r8[0x0]
80003e4a:	30 09       	mov	r9,0
80003e4c:	30 aa       	mov	r10,10
80003e4e:	30 0b       	mov	r11,0
80003e50:	10 9c       	mov	r12,r8
80003e52:	f0 1f 00 45 	mcall	80003f64 <vConsumer+0x22c>
80003e56:	18 98       	mov	r8,r12
80003e58:	58 18       	cp.w	r8,1
80003e5a:	c1 61       	brne	80003e86 <vConsumer+0x14e>
		{
			// Semaphore taken
			xQueueReceive(xQHandleLight, &light_received, (portTickType)10);
80003e5c:	4c a8       	lddpc	r8,80003f84 <vConsumer+0x24c>
80003e5e:	70 08       	ld.w	r8,r8[0x0]
80003e60:	ee cb 00 18 	sub	r11,r7,24
80003e64:	30 09       	mov	r9,0
80003e66:	30 aa       	mov	r10,10
80003e68:	10 9c       	mov	r12,r8
80003e6a:	f0 1f 00 3f 	mcall	80003f64 <vConsumer+0x22c>
			light_usart_write = light_received;
80003e6e:	ee f8 ff e8 	ld.w	r8,r7[-24]
80003e72:	ef 48 ff dc 	st.w	r7[-36],r8
		
			if(xSemaphoreGive(xEmptyCountLight) == pdTRUE)
80003e76:	4c 58       	lddpc	r8,80003f88 <vConsumer+0x250>
80003e78:	70 08       	ld.w	r8,r8[0x0]
80003e7a:	30 09       	mov	r9,0
80003e7c:	30 0a       	mov	r10,0
80003e7e:	30 0b       	mov	r11,0
80003e80:	10 9c       	mov	r12,r8
80003e82:	f0 1f 00 3c 	mcall	80003f70 <vConsumer+0x238>
			{
				// Semaphore given
			}
		}

		sprintf(temperature_usart, "Temperature %d\n", temp_usart_write);
80003e86:	ee f9 ff e4 	ld.w	r9,r7[-28]
80003e8a:	ee c8 00 30 	sub	r8,r7,48
80003e8e:	1a d9       	st.w	--sp,r9
80003e90:	4b fb       	lddpc	r11,80003f8c <vConsumer+0x254>
80003e92:	10 9c       	mov	r12,r8
80003e94:	f0 1f 00 3f 	mcall	80003f90 <vConsumer+0x258>
80003e98:	2f fd       	sub	sp,-4
		usart_write_line(serialPORT_USART, temperature_usart);
80003e9a:	ee c8 00 30 	sub	r8,r7,48
80003e9e:	10 9b       	mov	r11,r8
80003ea0:	fe 7c 18 00 	mov	r12,-59392
80003ea4:	f0 1f 00 3c 	mcall	80003f94 <vConsumer+0x25c>
		sprintf(potentiometer_usart, "Potentiometer %d\n", pot_usart_write);
80003ea8:	ee f9 ff e0 	ld.w	r9,r7[-32]
80003eac:	ee c8 00 3c 	sub	r8,r7,60
80003eb0:	1a d9       	st.w	--sp,r9
80003eb2:	4b ab       	lddpc	r11,80003f98 <vConsumer+0x260>
80003eb4:	10 9c       	mov	r12,r8
80003eb6:	f0 1f 00 37 	mcall	80003f90 <vConsumer+0x258>
80003eba:	2f fd       	sub	sp,-4
		usart_write_line(serialPORT_USART, potentiometer_usart);
80003ebc:	ee c8 00 3c 	sub	r8,r7,60
80003ec0:	10 9b       	mov	r11,r8
80003ec2:	fe 7c 18 00 	mov	r12,-59392
80003ec6:	f0 1f 00 34 	mcall	80003f94 <vConsumer+0x25c>
		sprintf(light_usart, "Light %d\n", light_received);
80003eca:	ee f9 ff e8 	ld.w	r9,r7[-24]
80003ece:	ee c8 00 48 	sub	r8,r7,72
80003ed2:	1a d9       	st.w	--sp,r9
80003ed4:	4b 2b       	lddpc	r11,80003f9c <vConsumer+0x264>
80003ed6:	10 9c       	mov	r12,r8
80003ed8:	f0 1f 00 2e 	mcall	80003f90 <vConsumer+0x258>
80003edc:	2f fd       	sub	sp,-4
		usart_write_line(serialPORT_USART, light_usart);
80003ede:	ee c8 00 48 	sub	r8,r7,72
80003ee2:	10 9b       	mov	r11,r8
80003ee4:	fe 7c 18 00 	mov	r12,-59392
80003ee8:	f0 1f 00 2b 	mcall	80003f94 <vConsumer+0x25c>
		dip204_set_cursor_position(15, 1);
80003eec:	30 1b       	mov	r11,1
80003eee:	30 fc       	mov	r12,15
80003ef0:	f0 1f 00 19 	mcall	80003f54 <vConsumer+0x21c>
		dip204_printf_string("%04d", temperature_received); //print value
80003ef4:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003ef8:	1a d8       	st.w	--sp,r8
80003efa:	4a ac       	lddpc	r12,80003fa0 <vConsumer+0x268>
80003efc:	f0 1f 00 2a 	mcall	80003fa4 <vConsumer+0x26c>
80003f00:	2f fd       	sub	sp,-4
		dip204_set_cursor_position(15, 2);
80003f02:	30 2b       	mov	r11,2
80003f04:	30 fc       	mov	r12,15
80003f06:	f0 1f 00 14 	mcall	80003f54 <vConsumer+0x21c>
		dip204_printf_string("%04d", potentiometer_received); //print value
80003f0a:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003f0e:	1a d8       	st.w	--sp,r8
80003f10:	4a 4c       	lddpc	r12,80003fa0 <vConsumer+0x268>
80003f12:	f0 1f 00 25 	mcall	80003fa4 <vConsumer+0x26c>
80003f16:	2f fd       	sub	sp,-4
		dip204_set_cursor_position(15, 3);
80003f18:	30 3b       	mov	r11,3
80003f1a:	30 fc       	mov	r12,15
80003f1c:	f0 1f 00 0e 	mcall	80003f54 <vConsumer+0x21c>
		dip204_printf_string("%04d", light_received); //print value
80003f20:	ee f8 ff e8 	ld.w	r8,r7[-24]
80003f24:	1a d8       	st.w	--sp,r8
80003f26:	49 fc       	lddpc	r12,80003fa0 <vConsumer+0x268>
80003f28:	f0 1f 00 1f 	mcall	80003fa4 <vConsumer+0x26c>
80003f2c:	2f fd       	sub	sp,-4
		
		vTaskDelayUntil(&xLastWakeTime,xFreq);
80003f2e:	ee f9 ff b0 	ld.w	r9,r7[-80]
80003f32:	ee c8 00 4c 	sub	r8,r7,76
80003f36:	12 9b       	mov	r11,r9
80003f38:	10 9c       	mov	r12,r8
80003f3a:	f0 1f 00 1c 	mcall	80003fa8 <vConsumer+0x270>
	}
80003f3e:	c4 4b       	rjmp	80003dc6 <vConsumer+0x8e>
80003f40:	80 00       	ld.sh	r0,r0[0x0]
80003f42:	3a bc       	mov	r12,-85
80003f44:	80 00       	ld.sh	r0,r0[0x0]
80003f46:	3a cc       	mov	r12,-84
80003f48:	80 00       	ld.sh	r0,r0[0x0]
80003f4a:	3a dc       	mov	r12,-83
80003f4c:	80 00       	ld.sh	r0,r0[0x0]
80003f4e:	5e d4       	retvc	r4
80003f50:	80 00       	ld.sh	r0,r0[0x0]
80003f52:	2c a0       	sub	r0,-54
80003f54:	80 00       	ld.sh	r0,r0[0x0]
80003f56:	2c 18       	sub	r8,-63
80003f58:	80 00       	ld.sh	r0,r0[0x0]
80003f5a:	2e 1c       	sub	r12,-31
80003f5c:	80 00       	ld.sh	r0,r0[0x0]
80003f5e:	3a 9c       	mov	r12,-87
80003f60:	00 00       	add	r0,r0
80003f62:	07 d8       	ld.ub	r8,r3[0x5]
80003f64:	80 00       	ld.sh	r0,r0[0x0]
80003f66:	56 40       	stdsp	sp[0x190],r0
80003f68:	00 00       	add	r0,r0
80003f6a:	07 fc       	ld.ub	r12,r3[0x7]
80003f6c:	00 00       	add	r0,r0
80003f6e:	07 dc       	ld.ub	r12,r3[0x5]
80003f70:	80 00       	ld.sh	r0,r0[0x0]
80003f72:	54 d8       	stdsp	sp[0x134],r8
80003f74:	00 00       	add	r0,r0
80003f76:	07 e4       	ld.ub	r4,r3[0x6]
80003f78:	00 00       	add	r0,r0
80003f7a:	07 f4       	ld.ub	r4,r3[0x7]
80003f7c:	00 00       	add	r0,r0
80003f7e:	08 00       	add	r0,r4
80003f80:	00 00       	add	r0,r0
80003f82:	08 04       	add	r4,r4
80003f84:	00 00       	add	r0,r0
80003f86:	07 e8       	ld.ub	r8,r3[0x6]
80003f88:	00 00       	add	r0,r0
80003f8a:	07 f8       	ld.ub	r8,r3[0x7]
80003f8c:	80 00       	ld.sh	r0,r0[0x0]
80003f8e:	3a e4       	mov	r4,-82
80003f90:	80 00       	ld.sh	r0,r0[0x0]
80003f92:	71 b8       	ld.w	r8,r8[0x6c]
80003f94:	80 00       	ld.sh	r0,r0[0x0]
80003f96:	4b 90       	lddpc	r0,80004078 <main+0xcc>
80003f98:	80 00       	ld.sh	r0,r0[0x0]
80003f9a:	3a f4       	mov	r4,-81
80003f9c:	80 00       	ld.sh	r0,r0[0x0]
80003f9e:	3b 08       	mov	r8,-80
80003fa0:	80 00       	ld.sh	r0,r0[0x0]
80003fa2:	3b 14       	mov	r4,-79
80003fa4:	80 00       	ld.sh	r0,r0[0x0]
80003fa6:	2e 8c       	sub	r12,-24
80003fa8:	80 00       	ld.sh	r0,r0[0x0]
80003faa:	5c 4c       	abs	r12

80003fac <main>:
}

int main(void)
{
80003fac:	eb cd 40 80 	pushm	r7,lr
80003fb0:	1a 97       	mov	r7,sp
	initLED();
80003fb2:	f0 1f 00 4d 	mcall	800040e4 <main+0x138>
	init_usart();
80003fb6:	f0 1f 00 4d 	mcall	800040e8 <main+0x13c>
	display_init();
80003fba:	f0 1f 00 4d 	mcall	800040ec <main+0x140>
	dip204_clear_display();
80003fbe:	f0 1f 00 4d 	mcall	800040f0 <main+0x144>
	
	// Configure the ADC module and enable the potentiometer, temperature and light channel
	adc_configure(&AVR32_ADC);
80003fc2:	fe 7c 3c 00 	mov	r12,-50176
80003fc6:	f0 1f 00 4c 	mcall	800040f4 <main+0x148>
	adc_enable(&AVR32_ADC, ADC_POTENTIOMETER_CHANNEL);
80003fca:	30 1b       	mov	r11,1
80003fcc:	fe 7c 3c 00 	mov	r12,-50176
80003fd0:	f0 1f 00 4a 	mcall	800040f8 <main+0x14c>
	adc_enable(&AVR32_ADC, ADC_TEMPERATURE_CHANNEL);
80003fd4:	30 0b       	mov	r11,0
80003fd6:	fe 7c 3c 00 	mov	r12,-50176
80003fda:	f0 1f 00 48 	mcall	800040f8 <main+0x14c>
	adc_enable(&AVR32_ADC, ADC_LIGHT_CHANNEL);
80003fde:	30 2b       	mov	r11,2
80003fe0:	fe 7c 3c 00 	mov	r12,-50176
80003fe4:	f0 1f 00 45 	mcall	800040f8 <main+0x14c>
	
	xFillCountPotentiometer = xSemaphoreCreateCounting(BUFFER_SIZE, 0);
80003fe8:	30 0b       	mov	r11,0
80003fea:	30 1c       	mov	r12,1
80003fec:	f0 1f 00 44 	mcall	800040fc <main+0x150>
80003ff0:	18 99       	mov	r9,r12
80003ff2:	4c 48       	lddpc	r8,80004100 <main+0x154>
80003ff4:	91 09       	st.w	r8[0x0],r9
	xEmptyCountPotentiometer = xSemaphoreCreateCounting(BUFFER_SIZE, BUFFER_SIZE);
80003ff6:	30 1b       	mov	r11,1
80003ff8:	30 1c       	mov	r12,1
80003ffa:	f0 1f 00 41 	mcall	800040fc <main+0x150>
80003ffe:	18 99       	mov	r9,r12
80004000:	4c 18       	lddpc	r8,80004104 <main+0x158>
80004002:	91 09       	st.w	r8[0x0],r9
	
	xFillCountTemperature = xSemaphoreCreateCounting(BUFFER_SIZE, 0);
80004004:	30 0b       	mov	r11,0
80004006:	30 1c       	mov	r12,1
80004008:	f0 1f 00 3d 	mcall	800040fc <main+0x150>
8000400c:	18 99       	mov	r9,r12
8000400e:	4b f8       	lddpc	r8,80004108 <main+0x15c>
80004010:	91 09       	st.w	r8[0x0],r9
	xEmptyCountTemperature = xSemaphoreCreateCounting(BUFFER_SIZE, BUFFER_SIZE);
80004012:	30 1b       	mov	r11,1
80004014:	30 1c       	mov	r12,1
80004016:	f0 1f 00 3a 	mcall	800040fc <main+0x150>
8000401a:	18 99       	mov	r9,r12
8000401c:	4b c8       	lddpc	r8,8000410c <main+0x160>
8000401e:	91 09       	st.w	r8[0x0],r9
	
	xFillCountLight = xSemaphoreCreateCounting(BUFFER_SIZE, 0);
80004020:	30 0b       	mov	r11,0
80004022:	30 1c       	mov	r12,1
80004024:	f0 1f 00 36 	mcall	800040fc <main+0x150>
80004028:	18 99       	mov	r9,r12
8000402a:	4b a8       	lddpc	r8,80004110 <main+0x164>
8000402c:	91 09       	st.w	r8[0x0],r9
	xEmptyCountLight = xSemaphoreCreateCounting(BUFFER_SIZE, BUFFER_SIZE);
8000402e:	30 1b       	mov	r11,1
80004030:	30 1c       	mov	r12,1
80004032:	f0 1f 00 33 	mcall	800040fc <main+0x150>
80004036:	18 99       	mov	r9,r12
80004038:	4b 78       	lddpc	r8,80004114 <main+0x168>
8000403a:	91 09       	st.w	r8[0x0],r9
	
	xQHandlePotentiometer = xQueueCreate(BUFFER_SIZE, sizeof(uint32_t*));
8000403c:	30 4b       	mov	r11,4
8000403e:	30 1c       	mov	r12,1
80004040:	f0 1f 00 36 	mcall	80004118 <main+0x16c>
80004044:	18 99       	mov	r9,r12
80004046:	4b 68       	lddpc	r8,8000411c <main+0x170>
80004048:	91 09       	st.w	r8[0x0],r9
	xQHandleTemperature = xQueueCreate(BUFFER_SIZE, sizeof(uint32_t*));
8000404a:	30 4b       	mov	r11,4
8000404c:	30 1c       	mov	r12,1
8000404e:	f0 1f 00 33 	mcall	80004118 <main+0x16c>
80004052:	18 99       	mov	r9,r12
80004054:	4b 38       	lddpc	r8,80004120 <main+0x174>
80004056:	91 09       	st.w	r8[0x0],r9
	xQHandleLight = xQueueCreate(BUFFER_SIZE, sizeof(uint32_t*));
80004058:	30 4b       	mov	r11,4
8000405a:	30 1c       	mov	r12,1
8000405c:	f0 1f 00 2f 	mcall	80004118 <main+0x16c>
80004060:	18 99       	mov	r9,r12
80004062:	4b 18       	lddpc	r8,80004124 <main+0x178>
80004064:	91 09       	st.w	r8[0x0],r9
	
	xTaskCreate(	vConsumer, "vConsumer", (( unsigned portSHORT ) 2000), NULL, 1, NULL);	
80004066:	4b 1b       	lddpc	r11,80004128 <main+0x17c>
80004068:	30 08       	mov	r8,0
8000406a:	1a d8       	st.w	--sp,r8
8000406c:	30 08       	mov	r8,0
8000406e:	1a d8       	st.w	--sp,r8
80004070:	30 08       	mov	r8,0
80004072:	1a d8       	st.w	--sp,r8
80004074:	30 18       	mov	r8,1
80004076:	30 09       	mov	r9,0
80004078:	e0 6a 07 d0 	mov	r10,2000
8000407c:	4a cc       	lddpc	r12,8000412c <main+0x180>
8000407e:	f0 1f 00 2d 	mcall	80004130 <main+0x184>
80004082:	2f dd       	sub	sp,-12
	xTaskCreate(	vTemperature, "vTemperature", (( unsigned portSHORT ) 2000), NULL, 1,NULL);
80004084:	4a cb       	lddpc	r11,80004134 <main+0x188>
80004086:	30 08       	mov	r8,0
80004088:	1a d8       	st.w	--sp,r8
8000408a:	30 08       	mov	r8,0
8000408c:	1a d8       	st.w	--sp,r8
8000408e:	30 08       	mov	r8,0
80004090:	1a d8       	st.w	--sp,r8
80004092:	30 18       	mov	r8,1
80004094:	30 09       	mov	r9,0
80004096:	e0 6a 07 d0 	mov	r10,2000
8000409a:	4a 8c       	lddpc	r12,80004138 <main+0x18c>
8000409c:	f0 1f 00 25 	mcall	80004130 <main+0x184>
800040a0:	2f dd       	sub	sp,-12
	xTaskCreate(	vPotentiometer, "vPotentiometer", (( unsigned portSHORT ) 2000), NULL, 1, NULL);
800040a2:	4a 7b       	lddpc	r11,8000413c <main+0x190>
800040a4:	30 08       	mov	r8,0
800040a6:	1a d8       	st.w	--sp,r8
800040a8:	30 08       	mov	r8,0
800040aa:	1a d8       	st.w	--sp,r8
800040ac:	30 08       	mov	r8,0
800040ae:	1a d8       	st.w	--sp,r8
800040b0:	30 18       	mov	r8,1
800040b2:	30 09       	mov	r9,0
800040b4:	e0 6a 07 d0 	mov	r10,2000
800040b8:	4a 2c       	lddpc	r12,80004140 <main+0x194>
800040ba:	f0 1f 00 1e 	mcall	80004130 <main+0x184>
800040be:	2f dd       	sub	sp,-12
	xTaskCreate(	vLight, "vLight", (( unsigned portSHORT ) 2000), NULL, 1, NULL);
800040c0:	4a 1b       	lddpc	r11,80004144 <main+0x198>
800040c2:	30 08       	mov	r8,0
800040c4:	1a d8       	st.w	--sp,r8
800040c6:	30 08       	mov	r8,0
800040c8:	1a d8       	st.w	--sp,r8
800040ca:	30 08       	mov	r8,0
800040cc:	1a d8       	st.w	--sp,r8
800040ce:	30 18       	mov	r8,1
800040d0:	30 09       	mov	r9,0
800040d2:	e0 6a 07 d0 	mov	r10,2000
800040d6:	49 dc       	lddpc	r12,80004148 <main+0x19c>
800040d8:	f0 1f 00 16 	mcall	80004130 <main+0x184>
800040dc:	2f dd       	sub	sp,-12
	
	vTaskStartScheduler();		// Starts the schedueling
800040de:	f0 1f 00 1c 	mcall	8000414c <main+0x1a0>

	
	for( ;; )
	{
		
	}
800040e2:	c0 08       	rjmp	800040e2 <main+0x136>
800040e4:	80 00       	ld.sh	r0,r0[0x0]
800040e6:	3a 20       	mov	r0,-94
800040e8:	80 00       	ld.sh	r0,r0[0x0]
800040ea:	3b 50       	mov	r0,-75
800040ec:	80 00       	ld.sh	r0,r0[0x0]
800040ee:	37 f8       	mov	r8,127
800040f0:	80 00       	ld.sh	r0,r0[0x0]
800040f2:	2c a0       	sub	r0,-54
800040f4:	80 00       	ld.sh	r0,r0[0x0]
800040f6:	30 a0       	mov	r0,10
800040f8:	80 00       	ld.sh	r0,r0[0x0]
800040fa:	30 f0       	mov	r0,15
800040fc:	80 00       	ld.sh	r0,r0[0x0]
800040fe:	54 94       	stdsp	sp[0x124],r4
80004100:	00 00       	add	r0,r0
80004102:	07 e4       	ld.ub	r4,r3[0x6]
80004104:	00 00       	add	r0,r0
80004106:	08 00       	add	r0,r4
80004108:	00 00       	add	r0,r0
8000410a:	07 d8       	ld.ub	r8,r3[0x5]
8000410c:	00 00       	add	r0,r0
8000410e:	07 dc       	ld.ub	r12,r3[0x5]
80004110:	00 00       	add	r0,r0
80004112:	08 04       	add	r4,r4
80004114:	00 00       	add	r0,r0
80004116:	07 f8       	ld.ub	r8,r3[0x7]
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	53 7c       	stdsp	sp[0xdc],r12
8000411c:	00 00       	add	r0,r0
8000411e:	07 f4       	ld.ub	r4,r3[0x7]
80004120:	00 00       	add	r0,r0
80004122:	07 fc       	ld.ub	r12,r3[0x7]
80004124:	00 00       	add	r0,r0
80004126:	07 e8       	ld.ub	r8,r3[0x6]
80004128:	80 00       	ld.sh	r0,r0[0x0]
8000412a:	3b 1c       	mov	r12,-79
8000412c:	80 00       	ld.sh	r0,r0[0x0]
8000412e:	3d 38       	mov	r8,-45
80004130:	80 00       	ld.sh	r0,r0[0x0]
80004132:	5a 84       	cp.w	r4,-24
80004134:	80 00       	ld.sh	r0,r0[0x0]
80004136:	3b 28       	mov	r8,-78
80004138:	80 00       	ld.sh	r0,r0[0x0]
8000413a:	3b b8       	mov	r8,-69
8000413c:	80 00       	ld.sh	r0,r0[0x0]
8000413e:	3b 38       	mov	r8,-77
80004140:	80 00       	ld.sh	r0,r0[0x0]
80004142:	3c 38       	mov	r8,-61
80004144:	80 00       	ld.sh	r0,r0[0x0]
80004146:	3b 48       	mov	r8,-76
80004148:	80 00       	ld.sh	r0,r0[0x0]
8000414a:	3c b8       	mov	r8,-53
8000414c:	80 00       	ld.sh	r0,r0[0x0]
8000414e:	5d 2c       	mustr	r12

80004150 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80004150:	eb cd 40 80 	pushm	r7,lr
80004154:	1a 97       	mov	r7,sp
80004156:	20 4d       	sub	sp,16
80004158:	ef 4c ff f4 	st.w	r7[-12],r12
8000415c:	ef 4b ff f0 	st.w	r7[-16],r11
	uint32_t status = GPIO_SUCCESS;
80004160:	30 08       	mov	r8,0
80004162:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t i;

	for (i = 0; i < size; i++) {
80004166:	30 08       	mov	r8,0
80004168:	ef 48 ff fc 	st.w	r7[-4],r8
8000416c:	c1 c8       	rjmp	800041a4 <gpio_enable_module+0x54>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000416e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004172:	70 19       	ld.w	r9,r8[0x4]
80004174:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004178:	70 08       	ld.w	r8,r8[0x0]
8000417a:	12 9b       	mov	r11,r9
8000417c:	10 9c       	mov	r12,r8
8000417e:	f0 1f 00 10 	mcall	800041bc <gpio_enable_module+0x6c>
80004182:	18 98       	mov	r8,r12
80004184:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004188:	f3 e8 10 08 	or	r8,r9,r8
8000418c:	ef 48 ff f8 	st.w	r7[-8],r8
		gpiomap++;
80004190:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004194:	2f 88       	sub	r8,-8
80004196:	ef 48 ff f4 	st.w	r7[-12],r8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000419a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000419e:	2f f8       	sub	r8,-1
800041a0:	ef 48 ff fc 	st.w	r7[-4],r8
800041a4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800041a8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800041ac:	10 39       	cp.w	r9,r8
800041ae:	ce 03       	brcs	8000416e <gpio_enable_module+0x1e>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
800041b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800041b4:	10 9c       	mov	r12,r8
800041b6:	2f cd       	sub	sp,-16
800041b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800041bc:	80 00       	ld.sh	r0,r0[0x0]
800041be:	41 c0       	lddsp	r0,sp[0x70]

800041c0 <gpio_enable_module_pin>:
 * \param function The pin function.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
800041c0:	eb cd 40 80 	pushm	r7,lr
800041c4:	1a 97       	mov	r7,sp
800041c6:	20 3d       	sub	sp,12
800041c8:	ef 4c ff f8 	st.w	r7[-8],r12
800041cc:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800041d0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041d4:	a5 98       	lsr	r8,0x5
800041d6:	a9 68       	lsl	r8,0x8
800041d8:	e0 28 f0 00 	sub	r8,61440
800041dc:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Enable the correct function. */
	switch (function) {
800041e0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800041e4:	58 18       	cp.w	r8,1
800041e6:	c1 e0       	breq	80004222 <gpio_enable_module_pin+0x62>
800041e8:	c0 63       	brcs	800041f4 <gpio_enable_module_pin+0x34>
800041ea:	58 28       	cp.w	r8,2
800041ec:	c3 20       	breq	80004250 <gpio_enable_module_pin+0x90>
800041ee:	58 38       	cp.w	r8,3
800041f0:	c4 70       	breq	8000427e <gpio_enable_module_pin+0xbe>
800041f2:	c5 d8       	rjmp	800042ac <gpio_enable_module_pin+0xec>
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800041f4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041f8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800041fc:	30 19       	mov	r9,1
800041fe:	f2 08 09 48 	lsl	r8,r9,r8
80004202:	10 99       	mov	r9,r8
80004204:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004208:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000420a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000420e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004212:	30 19       	mov	r9,1
80004214:	f2 08 09 48 	lsl	r8,r9,r8
80004218:	10 99       	mov	r9,r8
8000421a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000421e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004220:	c4 88       	rjmp	800042b0 <gpio_enable_module_pin+0xf0>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004222:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004226:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000422a:	30 19       	mov	r9,1
8000422c:	f2 08 09 48 	lsl	r8,r9,r8
80004230:	10 99       	mov	r9,r8
80004232:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004236:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004238:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000423c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004240:	30 19       	mov	r9,1
80004242:	f2 08 09 48 	lsl	r8,r9,r8
80004246:	10 99       	mov	r9,r8
80004248:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000424c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000424e:	c3 18       	rjmp	800042b0 <gpio_enable_module_pin+0xf0>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004250:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004254:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004258:	30 19       	mov	r9,1
8000425a:	f2 08 09 48 	lsl	r8,r9,r8
8000425e:	10 99       	mov	r9,r8
80004260:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004264:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004266:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000426a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000426e:	30 19       	mov	r9,1
80004270:	f2 08 09 48 	lsl	r8,r9,r8
80004274:	10 99       	mov	r9,r8
80004276:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000427a:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000427c:	c1 a8       	rjmp	800042b0 <gpio_enable_module_pin+0xf0>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000427e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004282:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004286:	30 19       	mov	r9,1
80004288:	f2 08 09 48 	lsl	r8,r9,r8
8000428c:	10 99       	mov	r9,r8
8000428e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004292:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004294:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004298:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000429c:	30 19       	mov	r9,1
8000429e:	f2 08 09 48 	lsl	r8,r9,r8
800042a2:	10 99       	mov	r9,r8
800042a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042a8:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800042aa:	c0 38       	rjmp	800042b0 <gpio_enable_module_pin+0xf0>
		gpio_port->pmr2s = 1 << (pin & 0x1F);
		break;
#endif

	default:
		return GPIO_INVALID_ARGUMENT;
800042ac:	30 18       	mov	r8,1
800042ae:	c0 d8       	rjmp	800042c8 <gpio_enable_module_pin+0x108>
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800042b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042b4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800042b8:	30 19       	mov	r9,1
800042ba:	f2 08 09 48 	lsl	r8,r9,r8
800042be:	10 99       	mov	r9,r8
800042c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042c4:	91 29       	st.w	r8[0x8],r9

	return GPIO_SUCCESS;
800042c6:	30 08       	mov	r8,0
}
800042c8:	10 9c       	mov	r12,r8
800042ca:	2f dd       	sub	sp,-12
800042cc:	e3 cd 80 80 	ldm	sp++,r7,pc

800042d0 <gpio_set_gpio_pin>:
/** \brief Drives a GPIO pin to 1.
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
800042d0:	eb cd 40 80 	pushm	r7,lr
800042d4:	1a 97       	mov	r7,sp
800042d6:	20 2d       	sub	sp,8
800042d8:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800042dc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042e0:	a5 98       	lsr	r8,0x5
800042e2:	a9 68       	lsl	r8,0x8
800042e4:	e0 28 f0 00 	sub	r8,61440
800042e8:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
800042ec:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042f0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800042f4:	30 19       	mov	r9,1
800042f6:	f2 08 09 48 	lsl	r8,r9,r8
800042fa:	10 99       	mov	r9,r8
800042fc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004300:	f1 49 00 54 	st.w	r8[84],r9
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80004304:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004308:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000430c:	30 19       	mov	r9,1
8000430e:	f2 08 09 48 	lsl	r8,r9,r8
80004312:	10 99       	mov	r9,r8
80004314:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004318:	f1 49 00 44 	st.w	r8[68],r9
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000431c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004320:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004324:	30 19       	mov	r9,1
80004326:	f2 08 09 48 	lsl	r8,r9,r8
8000432a:	10 99       	mov	r9,r8
8000432c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004330:	91 19       	st.w	r8[0x4],r9
}
80004332:	2f ed       	sub	sp,-8
80004334:	e3 cd 80 80 	ldm	sp++,r7,pc

80004338 <gpio_clr_gpio_pin>:
/** \brief Drives a GPIO pin to 0.
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
80004338:	eb cd 40 80 	pushm	r7,lr
8000433c:	1a 97       	mov	r7,sp
8000433e:	20 2d       	sub	sp,8
80004340:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004344:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004348:	a5 98       	lsr	r8,0x5
8000434a:	a9 68       	lsl	r8,0x8
8000434c:	e0 28 f0 00 	sub	r8,61440
80004350:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80004354:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004358:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000435c:	30 19       	mov	r9,1
8000435e:	f2 08 09 48 	lsl	r8,r9,r8
80004362:	10 99       	mov	r9,r8
80004364:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004368:	f1 49 00 58 	st.w	r8[88],r9
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
8000436c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004370:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004374:	30 19       	mov	r9,1
80004376:	f2 08 09 48 	lsl	r8,r9,r8
8000437a:	10 99       	mov	r9,r8
8000437c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004380:	f1 49 00 44 	st.w	r8[68],r9
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80004384:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004388:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000438c:	30 19       	mov	r9,1
8000438e:	f2 08 09 48 	lsl	r8,r9,r8
80004392:	10 99       	mov	r9,r8
80004394:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004398:	91 19       	st.w	r8[0x4],r9
}
8000439a:	2f ed       	sub	sp,-8
8000439c:	e3 cd 80 80 	ldm	sp++,r7,pc

800043a0 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800043a0:	eb cd 40 80 	pushm	r7,lr
800043a4:	1a 97       	mov	r7,sp
	// Catch unregistered interrupts.
	while (true);
800043a6:	c0 08       	rjmp	800043a6 <_unhandled_interrupt+0x6>

800043a8 <_get_interrupt_handler>:
 *
 * \return Interrupt handler to execute.
 */
__int_handler _get_interrupt_handler(uint32_t int_level);
__int_handler _get_interrupt_handler(uint32_t int_level)
{
800043a8:	eb cd 40 80 	pushm	r7,lr
800043ac:	1a 97       	mov	r7,sp
800043ae:	20 3d       	sub	sp,12
800043b0:	ef 4c ff f4 	st.w	r7[-12],r12
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800043b4:	fe 78 08 00 	mov	r8,-63488
800043b8:	ee f9 ff f4 	ld.w	r9,r7[-12]
800043bc:	f2 09 11 03 	rsub	r9,r9,3
800043c0:	28 09       	sub	r9,-128
800043c2:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800043c6:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800043ca:	fe 78 08 00 	mov	r8,-63488
800043ce:	ee f9 ff f8 	ld.w	r9,r7[-8]
800043d2:	2c 09       	sub	r9,-64
800043d4:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800043d8:	ef 48 ff fc 	st.w	r7[-4],r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800043dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043e0:	58 08       	cp.w	r8,0
800043e2:	c1 30       	breq	80004408 <_get_interrupt_handler+0x60>
		? _int_handler_table[int_grp]._int_line_handler_table[32
800043e4:	ee f9 ff f8 	ld.w	r9,r7[-8]
800043e8:	48 b8       	lddpc	r8,80004414 <_get_interrupt_handler+0x6c>
800043ea:	a1 79       	lsl	r9,0x1
800043ec:	2f f9       	sub	r9,-1
800043ee:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
800043f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043f6:	f0 08 12 00 	clz	r8,r8
800043fa:	f0 08 11 1f 	rsub	r8,r8,31
			- clz(int_req) - 1]
800043fe:	a3 68       	lsl	r8,0x2
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004400:	f2 08 00 08 	add	r8,r9,r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004404:	70 08       	ld.w	r8,r8[0x0]
80004406:	c0 28       	rjmp	8000440a <_get_interrupt_handler+0x62>
80004408:	30 08       	mov	r8,0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000440a:	10 9c       	mov	r12,r8
8000440c:	2f dd       	sub	sp,-12
8000440e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004412:	00 00       	add	r0,r0
80004414:	80 00       	ld.sh	r0,r0[0x0]
80004416:	c4 74       	brge	800044a4 <INTC_init_interrupts+0x78>

80004418 <INTC_init_evba>:
 * \internal
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
80004418:	eb cd 40 80 	pushm	r7,lr
8000441c:	1a 97       	mov	r7,sp
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000441e:	48 38       	lddpc	r8,80004428 <INTC_init_evba+0x10>
80004420:	e3 b8 00 01 	mtsr	0x4,r8
}
80004424:	e3 cd 80 80 	ldm	sp++,r7,pc
80004428:	80 00       	ld.sh	r0,r0[0x0]
8000442a:	c2 00       	breq	8000446a <INTC_init_interrupts+0x3e>

8000442c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
8000442c:	eb cd 40 80 	pushm	r7,lr
80004430:	1a 97       	mov	r7,sp
80004432:	20 2d       	sub	sp,8
	uint32_t int_grp, int_req;

	INTC_init_evba();
80004434:	f0 1f 00 1f 	mcall	800044b0 <INTC_init_interrupts+0x84>

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004438:	30 08       	mov	r8,0
8000443a:	ef 48 ff f8 	st.w	r7[-8],r8
8000443e:	c3 18       	rjmp	800044a0 <INTC_init_interrupts+0x74>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004440:	30 08       	mov	r8,0
80004442:	ef 48 ff fc 	st.w	r7[-4],r8
80004446:	c1 48       	rjmp	8000446e <INTC_init_interrupts+0x42>
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004448:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000444c:	49 a8       	lddpc	r8,800044b4 <INTC_init_interrupts+0x88>
8000444e:	a1 79       	lsl	r9,0x1
80004450:	2f f9       	sub	r9,-1
80004452:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80004456:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000445a:	a3 68       	lsl	r8,0x2
8000445c:	f2 08 00 08 	add	r8,r9,r8
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004460:	49 69       	lddpc	r9,800044b8 <INTC_init_interrupts+0x8c>
80004462:	91 09       	st.w	r8[0x0],r9
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004464:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004468:	2f f8       	sub	r8,-1
8000446a:	ef 48 ff fc 	st.w	r7[-4],r8
	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
8000446e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004472:	49 18       	lddpc	r8,800044b4 <INTC_init_interrupts+0x88>
80004474:	f0 09 03 39 	ld.w	r9,r8[r9<<0x3]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004478:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000447c:	10 39       	cp.w	r9,r8
8000447e:	fe 9b ff e5 	brhi	80004448 <INTC_init_interrupts+0x1c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004482:	fe 78 08 00 	mov	r8,-63488
80004486:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000448a:	48 db       	lddpc	r11,800044bc <INTC_init_interrupts+0x90>
8000448c:	48 da       	lddpc	r10,800044c0 <INTC_init_interrupts+0x94>
8000448e:	f6 0a 01 0a 	sub	r10,r11,r10
80004492:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004496:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000449a:	2f f8       	sub	r8,-1
8000449c:	ef 48 ff f8 	st.w	r7[-8],r8
800044a0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044a4:	59 38       	cp.w	r8,19
800044a6:	fe 98 ff cd 	brls	80004440 <INTC_init_interrupts+0x14>
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	}
}
800044aa:	2f ed       	sub	sp,-8
800044ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800044b0:	80 00       	ld.sh	r0,r0[0x0]
800044b2:	44 18       	lddsp	r8,sp[0x104]
800044b4:	80 00       	ld.sh	r0,r0[0x0]
800044b6:	c4 74       	brge	80004544 <INTC_register_interrupt+0x80>
800044b8:	80 00       	ld.sh	r0,r0[0x0]
800044ba:	43 a0       	lddsp	r0,sp[0xe8]
800044bc:	80 00       	ld.sh	r0,r0[0x0]
800044be:	c3 04       	brge	8000451e <INTC_register_interrupt+0x5a>
800044c0:	80 00       	ld.sh	r0,r0[0x0]
800044c2:	c2 00       	breq	80004502 <INTC_register_interrupt+0x3e>

800044c4 <INTC_register_interrupt>:
 *          be effective.
 *
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
800044c4:	eb cd 40 80 	pushm	r7,lr
800044c8:	1a 97       	mov	r7,sp
800044ca:	20 4d       	sub	sp,16
800044cc:	ef 4c ff f8 	st.w	r7[-8],r12
800044d0:	ef 4b ff f4 	st.w	r7[-12],r11
800044d4:	ef 4a ff f0 	st.w	r7[-16],r10
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800044d8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800044dc:	a5 98       	lsr	r8,0x5
800044de:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800044e2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800044e6:	4a 78       	lddpc	r8,80004580 <INTC_register_interrupt+0xbc>
800044e8:	a1 79       	lsl	r9,0x1
800044ea:	2f f9       	sub	r9,-1
800044ec:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
800044f0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800044f4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800044f8:	a3 68       	lsl	r8,0x2
800044fa:	f2 08 00 08 	add	r8,r9,r8
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800044fe:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004502:	91 09       	st.w	r8[0x0],r9
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004504:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004508:	58 08       	cp.w	r8,0
8000450a:	c0 c1       	brne	80004522 <INTC_register_interrupt+0x5e>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000450c:	fe 78 08 00 	mov	r8,-63488
80004510:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004514:	49 cb       	lddpc	r11,80004584 <INTC_register_interrupt+0xc0>
80004516:	49 da       	lddpc	r10,80004588 <INTC_register_interrupt+0xc4>
80004518:	f6 0a 01 0a 	sub	r10,r11,r10
8000451c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004520:	c2 d8       	rjmp	8000457a <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT1) {
80004522:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004526:	58 18       	cp.w	r8,1
80004528:	c0 d1       	brne	80004542 <INTC_register_interrupt+0x7e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000452a:	fe 78 08 00 	mov	r8,-63488
8000452e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004532:	49 7b       	lddpc	r11,8000458c <INTC_register_interrupt+0xc8>
80004534:	49 5a       	lddpc	r10,80004588 <INTC_register_interrupt+0xc4>
80004536:	f6 0a 01 0a 	sub	r10,r11,r10
8000453a:	bf aa       	sbr	r10,0x1e
8000453c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004540:	c1 d8       	rjmp	8000457a <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT2) {
80004542:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004546:	58 28       	cp.w	r8,2
80004548:	c0 d1       	brne	80004562 <INTC_register_interrupt+0x9e>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000454a:	fe 78 08 00 	mov	r8,-63488
8000454e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004552:	49 0b       	lddpc	r11,80004590 <INTC_register_interrupt+0xcc>
80004554:	48 da       	lddpc	r10,80004588 <INTC_register_interrupt+0xc4>
80004556:	f6 0a 01 0a 	sub	r10,r11,r10
8000455a:	bf ba       	sbr	r10,0x1f
8000455c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004560:	c0 d8       	rjmp	8000457a <INTC_register_interrupt+0xb6>
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004562:	fe 78 08 00 	mov	r8,-63488
80004566:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000456a:	48 bb       	lddpc	r11,80004594 <INTC_register_interrupt+0xd0>
8000456c:	48 7a       	lddpc	r10,80004588 <INTC_register_interrupt+0xc4>
8000456e:	f6 0a 01 0a 	sub	r10,r11,r10
80004572:	ea 1a c0 00 	orh	r10,0xc000
80004576:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	}
}
8000457a:	2f cd       	sub	sp,-16
8000457c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004580:	80 00       	ld.sh	r0,r0[0x0]
80004582:	c4 74       	brge	80004610 <pm_enable_osc0_crystal+0x2c>
80004584:	80 00       	ld.sh	r0,r0[0x0]
80004586:	c3 04       	brge	800045e6 <pm_enable_osc0_crystal+0x2>
80004588:	80 00       	ld.sh	r0,r0[0x0]
8000458a:	c2 00       	breq	800045ca <pm_set_osc0_mode+0x32>
8000458c:	80 00       	ld.sh	r0,r0[0x0]
8000458e:	c3 12       	brcc	800045f0 <pm_enable_osc0_crystal+0xc>
80004590:	80 00       	ld.sh	r0,r0[0x0]
80004592:	c3 20       	breq	800045f6 <pm_enable_osc0_crystal+0x12>
80004594:	80 00       	ld.sh	r0,r0[0x0]
80004596:	c3 2e       	rcall	800041fa <gpio_enable_module_pin+0x3a>

80004598 <pm_set_osc0_mode>:
 *
 * \param pm Base address of the Power Manager (i.e. &AVR32_PM).
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
80004598:	eb cd 40 80 	pushm	r7,lr
8000459c:	1a 97       	mov	r7,sp
8000459e:	20 3d       	sub	sp,12
800045a0:	ef 4c ff f8 	st.w	r7[-8],r12
800045a4:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800045a8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045ac:	70 a8       	ld.w	r8,r8[0x28]
800045ae:	30 09       	mov	r9,0
800045b0:	ef 49 ff fc 	st.w	r7[-4],r9
800045b4:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800045b8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800045bc:	5c 58       	castu.b	r8
800045be:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800045c2:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800045c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800045ca:	f1 d9 d0 03 	bfins	r8,r9,0x0,0x3
800045ce:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800045d2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800045d6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045da:	91 a9       	st.w	r8[0x28],r9
}
800045dc:	2f dd       	sub	sp,-12
800045de:	e3 cd 80 80 	ldm	sp++,r7,pc
800045e2:	d7 03       	nop

800045e4 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
800045e4:	eb cd 40 80 	pushm	r7,lr
800045e8:	1a 97       	mov	r7,sp
800045ea:	20 2d       	sub	sp,8
800045ec:	ef 4c ff fc 	st.w	r7[-4],r12
800045f0:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
800045f4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045f8:	ec 58 bb 9f 	cp.w	r8,899999
800045fc:	e0 88 00 1a 	brls	80004630 <pm_enable_osc0_crystal+0x4c>
80004600:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004604:	e0 69 c6 bf 	mov	r9,50879
80004608:	ea 19 00 2d 	orh	r9,0x2d
8000460c:	12 38       	cp.w	r8,r9
8000460e:	e0 88 00 0f 	brls	8000462c <pm_enable_osc0_crystal+0x48>
80004612:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004616:	e0 69 11 ff 	mov	r9,4607
8000461a:	ea 19 00 7a 	orh	r9,0x7a
8000461e:	12 38       	cp.w	r8,r9
80004620:	e0 8b 00 04 	brhi	80004628 <pm_enable_osc0_crystal+0x44>
80004624:	30 68       	mov	r8,6
80004626:	c0 28       	rjmp	8000462a <pm_enable_osc0_crystal+0x46>
80004628:	30 78       	mov	r8,7
8000462a:	c0 28       	rjmp	8000462e <pm_enable_osc0_crystal+0x4a>
8000462c:	30 58       	mov	r8,5
8000462e:	c0 28       	rjmp	80004632 <pm_enable_osc0_crystal+0x4e>
80004630:	30 48       	mov	r8,4
80004632:	10 9b       	mov	r11,r8
80004634:	ee fc ff fc 	ld.w	r12,r7[-4]
80004638:	f0 1f 00 03 	mcall	80004644 <pm_enable_osc0_crystal+0x60>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000463c:	2f ed       	sub	sp,-8
8000463e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004642:	00 00       	add	r0,r0
80004644:	80 00       	ld.sh	r0,r0[0x0]
80004646:	45 98       	lddsp	r8,sp[0x164]

80004648 <pm_enable_clk0>:


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80004648:	eb cd 40 80 	pushm	r7,lr
8000464c:	1a 97       	mov	r7,sp
8000464e:	20 2d       	sub	sp,8
80004650:	ef 4c ff fc 	st.w	r7[-4],r12
80004654:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_enable_clk0_no_wait(pm, startup);
80004658:	ee fb ff f8 	ld.w	r11,r7[-8]
8000465c:	ee fc ff fc 	ld.w	r12,r7[-4]
80004660:	f0 1f 00 05 	mcall	80004674 <pm_enable_clk0+0x2c>
  pm_wait_for_clk0_ready(pm);
80004664:	ee fc ff fc 	ld.w	r12,r7[-4]
80004668:	f0 1f 00 04 	mcall	80004678 <pm_enable_clk0+0x30>
}
8000466c:	2f ed       	sub	sp,-8
8000466e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004672:	00 00       	add	r0,r0
80004674:	80 00       	ld.sh	r0,r0[0x0]
80004676:	46 7c       	lddsp	r12,sp[0x19c]
80004678:	80 00       	ld.sh	r0,r0[0x0]
8000467a:	46 d6       	lddsp	r6,sp[0x1b4]

8000467c <pm_enable_clk0_no_wait>:
  pm->mcctrl &= ~AVR32_PM_MCCTRL_OSC0EN_MASK;
}


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
8000467c:	eb cd 40 80 	pushm	r7,lr
80004680:	1a 97       	mov	r7,sp
80004682:	20 3d       	sub	sp,12
80004684:	ef 4c ff f8 	st.w	r7[-8],r12
80004688:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
8000468c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004690:	70 a8       	ld.w	r8,r8[0x28]
80004692:	30 09       	mov	r9,0
80004694:	ef 49 ff fc 	st.w	r7[-4],r9
80004698:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
8000469c:	ee f8 ff f4 	ld.w	r8,r7[-12]
800046a0:	5c 58       	castu.b	r8
800046a2:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800046a6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800046aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046ae:	f1 d9 d1 03 	bfins	r8,r9,0x8,0x3
800046b2:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800046b6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800046ba:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046be:	91 a9       	st.w	r8[0x28],r9

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800046c0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046c4:	70 08       	ld.w	r8,r8[0x0]
800046c6:	10 99       	mov	r9,r8
800046c8:	a3 a9       	sbr	r9,0x2
800046ca:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046ce:	91 09       	st.w	r8[0x0],r9
}
800046d0:	2f dd       	sub	sp,-12
800046d2:	e3 cd 80 80 	ldm	sp++,r7,pc

800046d6 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
800046d6:	eb cd 40 80 	pushm	r7,lr
800046da:	1a 97       	mov	r7,sp
800046dc:	20 1d       	sub	sp,4
800046de:	ef 4c ff fc 	st.w	r7[-4],r12
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800046e2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046e6:	71 58       	ld.w	r8,r8[0x54]
800046e8:	e2 18 00 80 	andl	r8,0x80,COH
800046ec:	cf b0       	breq	800046e2 <pm_wait_for_clk0_ready+0xc>
}
800046ee:	2f fd       	sub	sp,-4
800046f0:	e3 cd 80 80 	ldm	sp++,r7,pc

800046f4 <pm_switch_to_clock>:
  return u_avr32_pm_mcctrl.MCCTRL.mcsel;
}


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
800046f4:	eb cd 40 80 	pushm	r7,lr
800046f8:	1a 97       	mov	r7,sp
800046fa:	20 3d       	sub	sp,12
800046fc:	ef 4c ff f8 	st.w	r7[-8],r12
80004700:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80004704:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004708:	70 08       	ld.w	r8,r8[0x0]
8000470a:	30 09       	mov	r9,0
8000470c:	ef 49 ff fc 	st.w	r7[-4],r9
80004710:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80004714:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004718:	5c 58       	castu.b	r8
8000471a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000471e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80004722:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004726:	f1 d9 d0 02 	bfins	r8,r9,0x0,0x2
8000472a:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000472e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004732:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004736:	91 09       	st.w	r8[0x0],r9
}
80004738:	2f dd       	sub	sp,-12
8000473a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000473e:	d7 03       	nop

80004740 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80004740:	eb cd 40 80 	pushm	r7,lr
80004744:	1a 97       	mov	r7,sp
80004746:	20 3d       	sub	sp,12
80004748:	ef 4c ff fc 	st.w	r7[-4],r12
8000474c:	ef 4b ff f8 	st.w	r7[-8],r11
80004750:	ef 4a ff f4 	st.w	r7[-12],r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80004754:	ee fb ff f8 	ld.w	r11,r7[-8]
80004758:	ee fc ff fc 	ld.w	r12,r7[-4]
8000475c:	f0 1f 00 08 	mcall	8000477c <pm_switch_to_osc0+0x3c>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80004760:	ee fb ff f4 	ld.w	r11,r7[-12]
80004764:	ee fc ff fc 	ld.w	r12,r7[-4]
80004768:	f0 1f 00 06 	mcall	80004780 <pm_switch_to_osc0+0x40>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
8000476c:	30 1b       	mov	r11,1
8000476e:	ee fc ff fc 	ld.w	r12,r7[-4]
80004772:	f0 1f 00 05 	mcall	80004784 <pm_switch_to_osc0+0x44>
}
80004776:	2f dd       	sub	sp,-12
80004778:	e3 cd 80 80 	ldm	sp++,r7,pc
8000477c:	80 00       	ld.sh	r0,r0[0x0]
8000477e:	45 e4       	lddsp	r4,sp[0x178]
80004780:	80 00       	ld.sh	r0,r0[0x0]
80004782:	46 48       	lddsp	r8,sp[0x190]
80004784:	80 00       	ld.sh	r0,r0[0x0]
80004786:	46 f4       	lddsp	r4,sp[0x1bc]

80004788 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80004788:	eb cd 40 80 	pushm	r7,lr
8000478c:	1a 97       	mov	r7,sp
8000478e:	20 1d       	sub	sp,4
80004790:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80004794:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004798:	e6 18 00 01 	andh	r8,0x1,COH
8000479c:	5f 08       	sreq	r8
8000479e:	5c 58       	castu.b	r8
}
800047a0:	10 9c       	mov	r12,r8
800047a2:	2f fd       	sub	sp,-4
800047a4:	e3 cd 80 80 	ldm	sp++,r7,pc

800047a8 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800047a8:	eb cd 40 80 	pushm	r7,lr
800047ac:	1a 97       	mov	r7,sp
800047ae:	20 7d       	sub	sp,28
800047b0:	ef 4c ff ec 	st.w	r7[-20],r12
800047b4:	ef 4b ff e8 	st.w	r7[-24],r11
800047b8:	ef 4a ff e4 	st.w	r7[-28],r10
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800047bc:	ee f8 ff e8 	ld.w	r8,r7[-24]
800047c0:	f0 09 15 04 	lsl	r9,r8,0x4
800047c4:	ee f8 ff e4 	ld.w	r8,r7[-28]
800047c8:	10 39       	cp.w	r9,r8
800047ca:	e0 8b 00 04 	brhi	800047d2 <usart_set_async_baudrate+0x2a>
800047ce:	31 08       	mov	r8,16
800047d0:	c0 28       	rjmp	800047d4 <usart_set_async_baudrate+0x2c>
800047d2:	30 88       	mov	r8,8
800047d4:	ef 48 ff f0 	st.w	r7[-16],r8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800047d8:	ee f8 ff e4 	ld.w	r8,r7[-28]
800047dc:	f0 09 15 03 	lsl	r9,r8,0x3
800047e0:	ee fa ff f0 	ld.w	r10,r7[-16]
800047e4:	ee f8 ff e8 	ld.w	r8,r7[-24]
800047e8:	f4 08 02 48 	mul	r8,r10,r8
800047ec:	a1 98       	lsr	r8,0x1
800047ee:	f2 08 00 08 	add	r8,r9,r8
800047f2:	ee fa ff f0 	ld.w	r10,r7[-16]
800047f6:	ee f9 ff e8 	ld.w	r9,r7[-24]
800047fa:	f4 09 02 49 	mul	r9,r10,r9
800047fe:	f0 09 0d 08 	divu	r8,r8,r9
80004802:	ef 48 ff f4 	st.w	r7[-12],r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004806:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000480a:	a3 98       	lsr	r8,0x3
8000480c:	ef 48 ff f8 	st.w	r7[-8],r8
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);
80004810:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004814:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004818:	ef 48 ff fc 	st.w	r7[-4],r8

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
8000481c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004820:	58 08       	cp.w	r8,0
80004822:	c0 70       	breq	80004830 <usart_set_async_baudrate+0x88>
80004824:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004828:	e0 48 ff ff 	cp.w	r8,65535
8000482c:	e0 88 00 04 	brls	80004834 <usart_set_async_baudrate+0x8c>
    return USART_INVALID_INPUT;
80004830:	30 18       	mov	r8,1
80004832:	c2 08       	rjmp	80004872 <usart_set_async_baudrate+0xca>

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004834:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004838:	70 18       	ld.w	r8,r8[0x4]
8000483a:	10 99       	mov	r9,r8
8000483c:	e4 19 ff f7 	andh	r9,0xfff7
80004840:	e0 19 fe cf 	andl	r9,0xfecf
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004844:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004848:	59 08       	cp.w	r8,16
8000484a:	c0 40       	breq	80004852 <usart_set_async_baudrate+0xaa>
8000484c:	e8 68 00 00 	mov	r8,524288
80004850:	c0 28       	rjmp	80004854 <usart_set_async_baudrate+0xac>
80004852:	30 08       	mov	r8,0
80004854:	10 49       	or	r9,r8
80004856:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000485a:	91 19       	st.w	r8[0x4],r9
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
                fp << AVR32_USART_BRGR_FP_OFFSET;
8000485c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004860:	f0 09 15 10 	lsl	r9,r8,0x10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004864:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004868:	10 49       	or	r9,r8
8000486a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000486e:	91 89       	st.w	r8[0x20],r9
                fp << AVR32_USART_BRGR_FP_OFFSET;

  return USART_SUCCESS;
80004870:	30 08       	mov	r8,0
}
80004872:	10 9c       	mov	r12,r8
80004874:	2f 9d       	sub	sp,-28
80004876:	e3 cd 80 80 	ldm	sp++,r7,pc
8000487a:	d7 03       	nop

8000487c <usart_reset>:
 */
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
8000487c:	eb cd 40 80 	pushm	r7,lr
80004880:	1a 97       	mov	r7,sp
80004882:	20 2d       	sub	sp,8
80004884:	ef 4c ff f8 	st.w	r7[-8],r12
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004888:	e1 b8 00 00 	mfsr	r8,0x0
8000488c:	10 9c       	mov	r12,r8
8000488e:	f0 1f 00 18 	mcall	800048ec <usart_reset+0x70>
80004892:	18 98       	mov	r8,r12
80004894:	ef 68 ff ff 	st.b	r7[-1],r8

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80004898:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000489c:	30 08       	mov	r8,0
8000489e:	f0 09 18 00 	cp.b	r9,r8
800048a2:	c0 20       	breq	800048a6 <usart_reset+0x2a>
800048a4:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800048a6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048aa:	3f f9       	mov	r9,-1
800048ac:	91 39       	st.w	r8[0xc],r9
  usart->csr;
800048ae:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048b2:	70 58       	ld.w	r8,r8[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800048b4:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800048b8:	30 08       	mov	r8,0
800048ba:	f0 09 18 00 	cp.b	r9,r8
800048be:	c0 20       	breq	800048c2 <usart_reset+0x46>
800048c0:	d5 03       	csrf	0x10

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800048c2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048c6:	30 09       	mov	r9,0
800048c8:	91 19       	st.w	r8[0x4],r9
  usart->rtor = 0;
800048ca:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048ce:	30 09       	mov	r9,0
800048d0:	91 99       	st.w	r8[0x24],r9
  usart->ttgr = 0;
800048d2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048d6:	30 09       	mov	r9,0
800048d8:	91 a9       	st.w	r8[0x28],r9

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800048da:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048de:	ea 69 61 0c 	mov	r9,680204
800048e2:	91 09       	st.w	r8[0x0],r9
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800048e4:	2f ed       	sub	sp,-8
800048e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800048ea:	00 00       	add	r0,r0
800048ec:	80 00       	ld.sh	r0,r0[0x0]
800048ee:	47 88       	lddsp	r8,sp[0x1e0]

800048f0 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800048f0:	eb cd 40 80 	pushm	r7,lr
800048f4:	1a 97       	mov	r7,sp
800048f6:	20 3d       	sub	sp,12
800048f8:	ef 4c ff fc 	st.w	r7[-4],r12
800048fc:	ef 4b ff f8 	st.w	r7[-8],r11
80004900:	ef 4a ff f4 	st.w	r7[-12],r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004904:	ee fc ff fc 	ld.w	r12,r7[-4]
80004908:	f0 1f 00 54 	mcall	80004a58 <usart_init_rs232+0x168>

  // Check input values.
  if (!opt || // Null pointer.
8000490c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004910:	58 08       	cp.w	r8,0
80004912:	c3 90       	breq	80004984 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80004914:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004918:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000491a:	30 48       	mov	r8,4
8000491c:	f0 09 18 00 	cp.b	r9,r8
80004920:	e0 88 00 32 	brls	80004984 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80004924:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004928:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000492a:	30 98       	mov	r8,9
8000492c:	f0 09 18 00 	cp.b	r9,r8
80004930:	e0 8b 00 2a 	brhi	80004984 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004934:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004938:	11 d9       	ld.ub	r9,r8[0x5]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000493a:	30 78       	mov	r8,7
8000493c:	f0 09 18 00 	cp.b	r9,r8
80004940:	e0 8b 00 22 	brhi	80004984 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
80004944:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004948:	90 39       	ld.sh	r9,r8[0x6]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000494a:	e0 68 01 01 	mov	r8,257
8000494e:	f0 09 19 00 	cp.h	r9,r8
80004952:	e0 8b 00 19 	brhi	80004984 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
80004956:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000495a:	f1 39 00 08 	ld.ub	r9,r8[8]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000495e:	30 38       	mov	r8,3
80004960:	f0 09 18 00 	cp.b	r9,r8
80004964:	e0 8b 00 10 	brhi	80004984 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004968:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000496c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004970:	70 08       	ld.w	r8,r8[0x0]
80004972:	12 9a       	mov	r10,r9
80004974:	10 9b       	mov	r11,r8
80004976:	ee fc ff fc 	ld.w	r12,r7[-4]
8000497a:	f0 1f 00 39 	mcall	80004a5c <usart_init_rs232+0x16c>
8000497e:	18 98       	mov	r8,r12
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004980:	58 18       	cp.w	r8,1
80004982:	c0 31       	brne	80004988 <usart_init_rs232+0x98>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;
80004984:	30 18       	mov	r8,1
80004986:	c6 48       	rjmp	80004a4e <usart_init_rs232+0x15e>

  if (opt->charlength == 9)
80004988:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000498c:	11 c9       	ld.ub	r9,r8[0x4]
8000498e:	30 98       	mov	r8,9
80004990:	f0 09 18 00 	cp.b	r9,r8
80004994:	c0 a1       	brne	800049a8 <usart_init_rs232+0xb8>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004996:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000499a:	70 18       	ld.w	r8,r8[0x4]
8000499c:	10 99       	mov	r9,r8
8000499e:	b1 b9       	sbr	r9,0x11
800049a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800049a4:	91 19       	st.w	r8[0x4],r9
800049a6:	c0 d8       	rjmp	800049c0 <usart_init_rs232+0xd0>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800049a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800049ac:	70 19       	ld.w	r9,r8[0x4]
800049ae:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049b2:	11 c8       	ld.ub	r8,r8[0x4]
800049b4:	20 58       	sub	r8,5
800049b6:	a7 68       	lsl	r8,0x6
800049b8:	10 49       	or	r9,r8
800049ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800049be:	91 19       	st.w	r8[0x4],r9
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800049c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800049c4:	70 19       	ld.w	r9,r8[0x4]
800049c6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049ca:	11 d8       	ld.ub	r8,r8[0x5]
800049cc:	f0 0a 15 09 	lsl	r10,r8,0x9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;
800049d0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049d4:	f1 38 00 08 	ld.ub	r8,r8[8]
800049d8:	af 68       	lsl	r8,0xe
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800049da:	f5 e8 10 08 	or	r8,r10,r8
800049de:	10 49       	or	r9,r8
800049e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800049e4:	91 19       	st.w	r8[0x4],r9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800049e6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049ea:	90 39       	ld.sh	r9,r8[0x6]
800049ec:	30 28       	mov	r8,2
800049ee:	f0 09 19 00 	cp.h	r9,r8
800049f2:	e0 88 00 14 	brls	80004a1a <usart_init_rs232+0x12a>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800049f6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800049fa:	70 18       	ld.w	r8,r8[0x4]
800049fc:	10 99       	mov	r9,r8
800049fe:	ad b9       	sbr	r9,0xd
80004a00:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a04:	91 19       	st.w	r8[0x4],r9
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004a06:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a0a:	90 38       	ld.sh	r8,r8[0x6]
80004a0c:	5c 78       	castu.h	r8
80004a0e:	20 28       	sub	r8,2
80004a10:	10 99       	mov	r9,r8
80004a12:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a16:	91 a9       	st.w	r8[0x28],r9
80004a18:	c0 d8       	rjmp	80004a32 <usart_init_rs232+0x142>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004a1a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a1e:	70 19       	ld.w	r9,r8[0x4]
80004a20:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a24:	90 38       	ld.sh	r8,r8[0x6]
80004a26:	5c 78       	castu.h	r8
80004a28:	ad 68       	lsl	r8,0xc
80004a2a:	10 49       	or	r9,r8
80004a2c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a30:	91 19       	st.w	r8[0x4],r9

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004a32:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a36:	70 18       	ld.w	r8,r8[0x4]
80004a38:	10 99       	mov	r9,r8
80004a3a:	e0 19 ff f0 	andl	r9,0xfff0
80004a3e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a42:	91 19       	st.w	r8[0x4],r9
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004a44:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a48:	35 09       	mov	r9,80
80004a4a:	91 09       	st.w	r8[0x0],r9
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004a4c:	30 08       	mov	r8,0
}
80004a4e:	10 9c       	mov	r12,r8
80004a50:	2f dd       	sub	sp,-12
80004a52:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a56:	00 00       	add	r0,r0
80004a58:	80 00       	ld.sh	r0,r0[0x0]
80004a5a:	48 7c       	lddpc	r12,80004a74 <usart_write_char+0x14>
80004a5c:	80 00       	ld.sh	r0,r0[0x0]
80004a5e:	47 a8       	lddsp	r8,sp[0x1e8]

80004a60 <usart_write_char>:
  return USART_SUCCESS;
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
80004a60:	eb cd 40 80 	pushm	r7,lr
80004a64:	1a 97       	mov	r7,sp
80004a66:	20 3d       	sub	sp,12
80004a68:	ef 4c ff f8 	st.w	r7[-8],r12
80004a6c:	ef 4b ff f4 	st.w	r7[-12],r11
80004a70:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a74:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004a78:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a7c:	70 58       	ld.w	r8,r8[0x14]
80004a7e:	e2 18 00 02 	andl	r8,0x2,COH
80004a82:	5f 18       	srne	r8
  if (usart_tx_ready(usart))
80004a84:	58 08       	cp.w	r8,0
80004a86:	c0 a0       	breq	80004a9a <usart_write_char+0x3a>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004a88:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004a8c:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80004a90:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a94:	91 79       	st.w	r8[0x1c],r9
    return USART_SUCCESS;
80004a96:	30 08       	mov	r8,0
80004a98:	c0 28       	rjmp	80004a9c <usart_write_char+0x3c>
  }
  else
    return USART_TX_BUSY;
80004a9a:	30 28       	mov	r8,2
}
80004a9c:	10 9c       	mov	r12,r8
80004a9e:	2f dd       	sub	sp,-12
80004aa0:	e3 cd 80 80 	ldm	sp++,r7,pc

80004aa4 <usart_putchar>:


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004aa4:	eb cd 40 80 	pushm	r7,lr
80004aa8:	1a 97       	mov	r7,sp
80004aaa:	20 3d       	sub	sp,12
80004aac:	ef 4c ff f8 	st.w	r7[-8],r12
80004ab0:	ef 4b ff f4 	st.w	r7[-12],r11
  int timeout = USART_DEFAULT_TIMEOUT;
80004ab4:	e0 68 27 10 	mov	r8,10000
80004ab8:	ef 48 ff fc 	st.w	r7[-4],r8

  do
  {
    if (!timeout--) return USART_FAILURE;
80004abc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ac0:	58 08       	cp.w	r8,0
80004ac2:	5f 08       	sreq	r8
80004ac4:	5c 58       	castu.b	r8
80004ac6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004aca:	20 19       	sub	r9,1
80004acc:	ef 49 ff fc 	st.w	r7[-4],r9
80004ad0:	58 08       	cp.w	r8,0
80004ad2:	c0 30       	breq	80004ad8 <usart_putchar+0x34>
80004ad4:	3f f8       	mov	r8,-1
80004ad6:	c0 b8       	rjmp	80004aec <usart_putchar+0x48>
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004ad8:	ee fb ff f4 	ld.w	r11,r7[-12]
80004adc:	ee fc ff f8 	ld.w	r12,r7[-8]
80004ae0:	f0 1f 00 05 	mcall	80004af4 <usart_putchar+0x50>
80004ae4:	18 98       	mov	r8,r12
80004ae6:	58 08       	cp.w	r8,0
80004ae8:	ce a1       	brne	80004abc <usart_putchar+0x18>

  return USART_SUCCESS;
80004aea:	30 08       	mov	r8,0
}
80004aec:	10 9c       	mov	r12,r8
80004aee:	2f dd       	sub	sp,-12
80004af0:	e3 cd 80 80 	ldm	sp++,r7,pc
80004af4:	80 00       	ld.sh	r0,r0[0x0]
80004af6:	4a 60       	lddpc	r0,80004b8c <usart_getchar+0x40>

80004af8 <usart_read_char>:


int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
80004af8:	eb cd 40 80 	pushm	r7,lr
80004afc:	1a 97       	mov	r7,sp
80004afe:	20 3d       	sub	sp,12
80004b00:	ef 4c ff f8 	st.w	r7[-8],r12
80004b04:	ef 4b ff f4 	st.w	r7[-12],r11
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004b08:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b0c:	70 58       	ld.w	r8,r8[0x14]
80004b0e:	e2 18 00 e0 	andl	r8,0xe0,COH
80004b12:	c0 30       	breq	80004b18 <usart_read_char+0x20>
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;
80004b14:	30 48       	mov	r8,4
80004b16:	c1 68       	rjmp	80004b42 <usart_read_char+0x4a>
80004b18:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b1c:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004b20:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b24:	70 58       	ld.w	r8,r8[0x14]
80004b26:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004b2a:	c0 b0       	breq	80004b40 <usart_read_char+0x48>
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004b2c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b30:	70 68       	ld.w	r8,r8[0x18]
80004b32:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80004b36:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004b3a:	91 09       	st.w	r8[0x0],r9
    return USART_SUCCESS;
80004b3c:	30 08       	mov	r8,0
80004b3e:	c0 28       	rjmp	80004b42 <usart_read_char+0x4a>
  }
  else
    return USART_RX_EMPTY;
80004b40:	30 38       	mov	r8,3
}
80004b42:	10 9c       	mov	r12,r8
80004b44:	2f dd       	sub	sp,-12
80004b46:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b4a:	d7 03       	nop

80004b4c <usart_getchar>:


int usart_getchar(volatile avr32_usart_t *usart)
{
80004b4c:	eb cd 40 80 	pushm	r7,lr
80004b50:	1a 97       	mov	r7,sp
80004b52:	20 3d       	sub	sp,12
80004b54:	ef 4c ff f4 	st.w	r7[-12],r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004b58:	ee c8 00 08 	sub	r8,r7,8
80004b5c:	10 9b       	mov	r11,r8
80004b5e:	ee fc ff f4 	ld.w	r12,r7[-12]
80004b62:	f0 1f 00 0b 	mcall	80004b8c <usart_getchar+0x40>
80004b66:	18 98       	mov	r8,r12
80004b68:	ef 48 ff fc 	st.w	r7[-4],r8
80004b6c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b70:	58 38       	cp.w	r8,3
80004b72:	cf 30       	breq	80004b58 <usart_getchar+0xc>

  if (ret == USART_RX_ERROR)
80004b74:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b78:	58 48       	cp.w	r8,4
80004b7a:	c0 31       	brne	80004b80 <usart_getchar+0x34>
    return USART_FAILURE;
80004b7c:	3f f8       	mov	r8,-1
80004b7e:	c0 38       	rjmp	80004b84 <usart_getchar+0x38>

  return c;
80004b80:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80004b84:	10 9c       	mov	r12,r8
80004b86:	2f dd       	sub	sp,-12
80004b88:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b8c:	80 00       	ld.sh	r0,r0[0x0]
80004b8e:	4a f8       	lddpc	r8,80004c48 <vListInsertEnd+0x12>

80004b90 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004b90:	eb cd 40 80 	pushm	r7,lr
80004b94:	1a 97       	mov	r7,sp
80004b96:	20 2d       	sub	sp,8
80004b98:	ef 4c ff fc 	st.w	r7[-4],r12
80004b9c:	ef 4b ff f8 	st.w	r7[-8],r11
  while (*string != '\0')
80004ba0:	c0 e8       	rjmp	80004bbc <usart_write_line+0x2c>
    usart_putchar(usart, *string++);
80004ba2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ba6:	11 88       	ld.ub	r8,r8[0x0]
80004ba8:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004bac:	2f f9       	sub	r9,-1
80004bae:	ef 49 ff f8 	st.w	r7[-8],r9
80004bb2:	10 9b       	mov	r11,r8
80004bb4:	ee fc ff fc 	ld.w	r12,r7[-4]
80004bb8:	f0 1f 00 05 	mcall	80004bcc <usart_write_line+0x3c>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80004bbc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004bc0:	11 88       	ld.ub	r8,r8[0x0]
80004bc2:	58 08       	cp.w	r8,0
80004bc4:	ce f1       	brne	80004ba2 <usart_write_line+0x12>
    usart_putchar(usart, *string++);
}
80004bc6:	2f ed       	sub	sp,-8
80004bc8:	e3 cd 80 80 	ldm	sp++,r7,pc
80004bcc:	80 00       	ld.sh	r0,r0[0x0]
80004bce:	4a a4       	lddpc	r4,80004c74 <vListInsertEnd+0x3e>

80004bd0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
80004bd0:	eb cd 40 80 	pushm	r7,lr
80004bd4:	1a 97       	mov	r7,sp
80004bd6:	20 1d       	sub	sp,4
80004bd8:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004bdc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004be0:	2f 88       	sub	r8,-8
80004be2:	10 99       	mov	r9,r8
80004be4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004be8:	91 19       	st.w	r8[0x4],r9

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004bea:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bee:	3f f9       	mov	r9,-1
80004bf0:	91 29       	st.w	r8[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004bf2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bf6:	2f 88       	sub	r8,-8
80004bf8:	10 99       	mov	r9,r8
80004bfa:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bfe:	91 39       	st.w	r8[0xc],r9
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004c00:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c04:	2f 88       	sub	r8,-8
80004c06:	10 99       	mov	r9,r8
80004c08:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c0c:	91 49       	st.w	r8[0x10],r9

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004c0e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c12:	30 09       	mov	r9,0
80004c14:	91 09       	st.w	r8[0x0],r9
}
80004c16:	2f fd       	sub	sp,-4
80004c18:	e3 cd 80 80 	ldm	sp++,r7,pc

80004c1c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
80004c1c:	eb cd 40 80 	pushm	r7,lr
80004c20:	1a 97       	mov	r7,sp
80004c22:	20 1d       	sub	sp,4
80004c24:	ef 4c ff fc 	st.w	r7[-4],r12
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004c28:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c2c:	30 09       	mov	r9,0
80004c2e:	91 49       	st.w	r8[0x10],r9
}
80004c30:	2f fd       	sub	sp,-4
80004c32:	e3 cd 80 80 	ldm	sp++,r7,pc

80004c36 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
80004c36:	eb cd 40 80 	pushm	r7,lr
80004c3a:	1a 97       	mov	r7,sp
80004c3c:	20 3d       	sub	sp,12
80004c3e:	ef 4c ff f8 	st.w	r7[-8],r12
80004c42:	ef 4b ff f4 	st.w	r7[-12],r11

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004c46:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c4a:	70 18       	ld.w	r8,r8[0x4]
80004c4c:	ef 48 ff fc 	st.w	r7[-4],r8

	pxNewListItem->pxNext = pxIndex->pxNext;
80004c50:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c54:	70 19       	ld.w	r9,r8[0x4]
80004c56:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004c5a:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004c5c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c60:	70 19       	ld.w	r9,r8[0x4]
80004c62:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004c66:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004c68:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c6c:	70 18       	ld.w	r8,r8[0x4]
80004c6e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004c72:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004c74:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004c78:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c7c:	91 19       	st.w	r8[0x4],r9
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004c7e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004c82:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c86:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004c88:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004c8c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004c90:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80004c92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c96:	70 08       	ld.w	r8,r8[0x0]
80004c98:	f0 c9 ff ff 	sub	r9,r8,-1
80004c9c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ca0:	91 09       	st.w	r8[0x0],r9
}
80004ca2:	2f dd       	sub	sp,-12
80004ca4:	e3 cd 80 80 	ldm	sp++,r7,pc

80004ca8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
80004ca8:	eb cd 40 80 	pushm	r7,lr
80004cac:	1a 97       	mov	r7,sp
80004cae:	20 4d       	sub	sp,16
80004cb0:	ef 4c ff f4 	st.w	r7[-12],r12
80004cb4:	ef 4b ff f0 	st.w	r7[-16],r11
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004cb8:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004cbc:	70 08       	ld.w	r8,r8[0x0]
80004cbe:	ef 48 ff fc 	st.w	r7[-4],r8
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004cc2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004cc6:	5b f8       	cp.w	r8,-1
80004cc8:	c0 71       	brne	80004cd6 <vListInsert+0x2e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004cca:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004cce:	70 48       	ld.w	r8,r8[0x10]
80004cd0:	ef 48 ff f8 	st.w	r7[-8],r8
80004cd4:	c1 58       	rjmp	80004cfe <vListInsert+0x56>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004cd6:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004cda:	2f 88       	sub	r8,-8
80004cdc:	ef 48 ff f8 	st.w	r7[-8],r8
80004ce0:	c0 68       	rjmp	80004cec <vListInsert+0x44>
80004ce2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ce6:	70 18       	ld.w	r8,r8[0x4]
80004ce8:	ef 48 ff f8 	st.w	r7[-8],r8
80004cec:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004cf0:	70 18       	ld.w	r8,r8[0x4]
80004cf2:	70 09       	ld.w	r9,r8[0x0]
80004cf4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004cf8:	10 39       	cp.w	r9,r8
80004cfa:	fe 98 ff f4 	brls	80004ce2 <vListInsert+0x3a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004cfe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d02:	70 19       	ld.w	r9,r8[0x4]
80004d04:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004d08:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004d0a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004d0e:	70 18       	ld.w	r8,r8[0x4]
80004d10:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004d14:	91 29       	st.w	r8[0x8],r9
	pxNewListItem->pxPrevious = pxIterator;
80004d16:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004d1a:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004d1e:	91 29       	st.w	r8[0x8],r9
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004d20:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004d24:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d28:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004d2a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004d2e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004d32:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80004d34:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d38:	70 08       	ld.w	r8,r8[0x0]
80004d3a:	f0 c9 ff ff 	sub	r9,r8,-1
80004d3e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d42:	91 09       	st.w	r8[0x0],r9
}
80004d44:	2f cd       	sub	sp,-16
80004d46:	e3 cd 80 80 	ldm	sp++,r7,pc

80004d4a <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
80004d4a:	eb cd 40 80 	pushm	r7,lr
80004d4e:	1a 97       	mov	r7,sp
80004d50:	20 2d       	sub	sp,8
80004d52:	ef 4c ff f8 	st.w	r7[-8],r12
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004d56:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d5a:	70 18       	ld.w	r8,r8[0x4]
80004d5c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004d60:	72 29       	ld.w	r9,r9[0x8]
80004d62:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004d64:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d68:	70 28       	ld.w	r8,r8[0x8]
80004d6a:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004d6e:	72 19       	ld.w	r9,r9[0x4]
80004d70:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004d72:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d76:	70 48       	ld.w	r8,r8[0x10]
80004d78:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004d7c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d80:	70 19       	ld.w	r9,r8[0x4]
80004d82:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d86:	10 39       	cp.w	r9,r8
80004d88:	c0 71       	brne	80004d96 <vListRemove+0x4c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004d8a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d8e:	70 29       	ld.w	r9,r8[0x8]
80004d90:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d94:	91 19       	st.w	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004d96:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d9a:	30 09       	mov	r9,0
80004d9c:	91 49       	st.w	r8[0x10],r9
	( pxList->uxNumberOfItems )--;
80004d9e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004da2:	70 08       	ld.w	r8,r8[0x0]
80004da4:	f0 c9 00 01 	sub	r9,r8,1
80004da8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004dac:	91 09       	st.w	r8[0x0],r9
}
80004dae:	2f ed       	sub	sp,-8
80004db0:	e3 cd 80 80 	ldm	sp++,r7,pc

80004db4 <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80004db4:	eb cd 40 80 	pushm	r7,lr
80004db8:	1a 97       	mov	r7,sp
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
80004dba:	48 e8       	lddpc	r8,80004df0 <_init_startup+0x3c>
80004dbc:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
80004dc0:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
80004dc2:	f0 1f 00 0d 	mcall	80004df4 <_init_startup+0x40>
			.channelmode = USART_NORMAL_CHMODE
		};

		/* Initialize the USART used for the debug trace with the configured parameters. */
		extern volatile avr32_usart_t *volatile stdio_usart_base;
		stdio_usart_base = configDBG_USART;
80004dc6:	48 d8       	lddpc	r8,80004df8 <_init_startup+0x44>
80004dc8:	fe 79 18 00 	mov	r9,-59392
80004dcc:	91 09       	st.w	r8[0x0],r9
		gpio_enable_module( DBG_USART_GPIO_MAP,
80004dce:	30 2b       	mov	r11,2
80004dd0:	48 bc       	lddpc	r12,80004dfc <_init_startup+0x48>
80004dd2:	f0 1f 00 0c 	mcall	80004e00 <_init_startup+0x4c>
		                    sizeof( DBG_USART_GPIO_MAP ) / sizeof( DBG_USART_GPIO_MAP[0] ) );
		usart_init_rs232(configDBG_USART, &DBG_USART_OPTIONS, configPBA_CLOCK_HZ);
80004dd6:	e0 6a 1b 00 	mov	r10,6912
80004dda:	ea 1a 00 b7 	orh	r10,0xb7
80004dde:	48 ab       	lddpc	r11,80004e04 <_init_startup+0x50>
80004de0:	fe 7c 18 00 	mov	r12,-59392
80004de4:	f0 1f 00 09 	mcall	80004e08 <_init_startup+0x54>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
80004de8:	30 18       	mov	r8,1
}
80004dea:	10 9c       	mov	r12,r8
80004dec:	e3 cd 80 80 	ldm	sp++,r7,pc
80004df0:	80 00       	ld.sh	r0,r0[0x0]
80004df2:	c2 00       	breq	80004e32 <__malloc_unlock+0xa>
80004df4:	80 00       	ld.sh	r0,r0[0x0]
80004df6:	44 2c       	lddsp	r12,sp[0x108]
80004df8:	00 00       	add	r0,r0
80004dfa:	08 08       	add	r8,r4
80004dfc:	80 00       	ld.sh	r0,r0[0x0]
80004dfe:	c5 14       	brge	80004ea0 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
80004e00:	80 00       	ld.sh	r0,r0[0x0]
80004e02:	41 50       	lddsp	r0,sp[0x54]
80004e04:	80 00       	ld.sh	r0,r0[0x0]
80004e06:	c5 24       	brge	80004eaa <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0xa>
80004e08:	80 00       	ld.sh	r0,r0[0x0]
80004e0a:	48 f0       	lddpc	r0,80004e44 <vTick>

80004e0c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80004e0c:	eb cd 40 80 	pushm	r7,lr
80004e10:	1a 97       	mov	r7,sp
80004e12:	20 1d       	sub	sp,4
80004e14:	ef 4c ff fc 	st.w	r7[-4],r12
	vTaskSuspendAll();
80004e18:	f0 1f 00 03 	mcall	80004e24 <__malloc_lock+0x18>
}
80004e1c:	2f fd       	sub	sp,-4
80004e1e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e22:	00 00       	add	r0,r0
80004e24:	80 00       	ld.sh	r0,r0[0x0]
80004e26:	5d 90       	*unknown*

80004e28 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80004e28:	eb cd 40 80 	pushm	r7,lr
80004e2c:	1a 97       	mov	r7,sp
80004e2e:	20 1d       	sub	sp,4
80004e30:	ef 4c ff fc 	st.w	r7[-4],r12
	xTaskResumeAll();
80004e34:	f0 1f 00 03 	mcall	80004e40 <__malloc_unlock+0x18>
}
80004e38:	2f fd       	sub	sp,-4
80004e3a:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e3e:	00 00       	add	r0,r0
80004e40:	80 00       	ld.sh	r0,r0[0x0]
80004e42:	5d ac       	*unknown*

80004e44 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004e44:	eb cd 00 ff 	pushm	r0-r7
80004e48:	e0 68 00 20 	mov	r8,32
80004e4c:	ea 18 00 00 	orh	r8,0x0
80004e50:	70 00       	ld.w	r0,r8[0x0]
80004e52:	1a d0       	st.w	--sp,r0
80004e54:	7a 90       	ld.w	r0,sp[0x24]
80004e56:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004e5a:	58 10       	cp.w	r0,1
80004e5c:	e0 8b 00 08 	brhi	80004e6c <LABEL_INT_SKIP_SAVE_CONTEXT_234>
80004e60:	e0 68 06 60 	mov	r8,1632
80004e64:	ea 18 00 00 	orh	r8,0x0
80004e68:	70 00       	ld.w	r0,r8[0x0]
80004e6a:	81 0d       	st.w	r0[0x0],sp

80004e6c <LABEL_INT_SKIP_SAVE_CONTEXT_234>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80004e6c:	f0 1f 00 12 	mcall	80004eb4 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80004e70:	f0 1f 00 12 	mcall	80004eb8 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
		vTaskIncrementTick();
80004e74:	f0 1f 00 12 	mcall	80004ebc <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x1c>
	portEXIT_CRITICAL();
80004e78:	f0 1f 00 12 	mcall	80004ec0 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80004e7c:	7a 90       	ld.w	r0,sp[0x24]
80004e7e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004e82:	58 10       	cp.w	r0,1
80004e84:	e0 8b 00 0e 	brhi	80004ea0 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
80004e88:	f0 1f 00 0c 	mcall	80004eb8 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
80004e8c:	f0 1f 00 0e 	mcall	80004ec4 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x24>
80004e90:	f0 1f 00 0c 	mcall	80004ec0 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>
80004e94:	e0 68 06 60 	mov	r8,1632
80004e98:	ea 18 00 00 	orh	r8,0x0
80004e9c:	70 00       	ld.w	r0,r8[0x0]
80004e9e:	60 0d       	ld.w	sp,r0[0x0]

80004ea0 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>:
80004ea0:	1b 00       	ld.w	r0,sp++
80004ea2:	e0 68 00 20 	mov	r8,32
80004ea6:	ea 18 00 00 	orh	r8,0x0
80004eaa:	91 00       	st.w	r8[0x0],r0
80004eac:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004eb0:	d6 03       	rete
80004eb2:	00 00       	add	r0,r0
80004eb4:	80 00       	ld.sh	r0,r0[0x0]
80004eb6:	51 b0       	stdsp	sp[0x6c],r0
80004eb8:	80 00       	ld.sh	r0,r0[0x0]
80004eba:	4f 60       	lddpc	r0,80005090 <pxPortInitialiseStack+0xe8>
80004ebc:	80 00       	ld.sh	r0,r0[0x0]
80004ebe:	5f 04       	sreq	r4
80004ec0:	80 00       	ld.sh	r0,r0[0x0]
80004ec2:	4f 7c       	lddpc	r12,8000509c <pxPortInitialiseStack+0xf4>
80004ec4:	80 00       	ld.sh	r0,r0[0x0]
80004ec6:	60 64       	ld.w	r4,r0[0x18]

80004ec8 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004ec8:	20 6d       	sub	sp,24
80004eca:	eb cd 00 ff 	pushm	r0-r7
80004ece:	fa c7 ff c0 	sub	r7,sp,-64
80004ed2:	ee f0 ff f8 	ld.w	r0,r7[-8]
80004ed6:	ef 40 ff e0 	st.w	r7[-32],r0
80004eda:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004ede:	ef 40 ff e4 	st.w	r7[-28],r0
80004ee2:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80004ee6:	e0 68 00 20 	mov	r8,32
80004eea:	ea 18 00 00 	orh	r8,0x0
80004eee:	70 00       	ld.w	r0,r8[0x0]
80004ef0:	1a d0       	st.w	--sp,r0
80004ef2:	f0 1f 00 1a 	mcall	80004f58 <LABEL_RET_SCALL_260+0x14>
80004ef6:	e0 68 06 60 	mov	r8,1632
80004efa:	ea 18 00 00 	orh	r8,0x0
80004efe:	70 00       	ld.w	r0,r8[0x0]
80004f00:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80004f02:	f0 1f 00 17 	mcall	80004f5c <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
80004f06:	e0 68 06 60 	mov	r8,1632
80004f0a:	ea 18 00 00 	orh	r8,0x0
80004f0e:	70 00       	ld.w	r0,r8[0x0]
80004f10:	60 0d       	ld.w	sp,r0[0x0]
80004f12:	1b 00       	ld.w	r0,sp++
80004f14:	e0 68 00 20 	mov	r8,32
80004f18:	ea 18 00 00 	orh	r8,0x0
80004f1c:	91 00       	st.w	r8[0x0],r0
80004f1e:	fa c7 ff d8 	sub	r7,sp,-40
80004f22:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80004f26:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004f2a:	e0 61 00 20 	mov	r1,32
80004f2e:	ea 11 00 00 	orh	r1,0x0
80004f32:	62 02       	ld.w	r2,r1[0x0]
80004f34:	58 02       	cp.w	r2,0
80004f36:	c0 70       	breq	80004f44 <LABEL_RET_SCALL_260>
80004f38:	e4 c2 00 01 	sub	r2,r2,1
80004f3c:	83 02       	st.w	r1[0x0],r2
80004f3e:	58 02       	cp.w	r2,0
80004f40:	c0 21       	brne	80004f44 <LABEL_RET_SCALL_260>
80004f42:	b1 c0       	cbr	r0,0x10

80004f44 <LABEL_RET_SCALL_260>:
80004f44:	ef 40 ff f8 	st.w	r7[-8],r0
80004f48:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004f4c:	ef 40 ff fc 	st.w	r7[-4],r0
80004f50:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004f54:	2f ad       	sub	sp,-24
80004f56:	d6 13       	rets
80004f58:	80 00       	ld.sh	r0,r0[0x0]
80004f5a:	4f 60       	lddpc	r0,80005130 <pxPortInitialiseStack+0x188>
80004f5c:	80 00       	ld.sh	r0,r0[0x0]
80004f5e:	60 64       	ld.w	r4,r0[0x18]

80004f60 <vPortEnterCritical>:
/* The code generated by the GCC compiler uses the stack in different ways at
different optimisation levels.  The interrupt flags can therefore not always
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
80004f60:	eb cd 40 80 	pushm	r7,lr
80004f64:	1a 97       	mov	r7,sp
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004f66:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80004f68:	48 48       	lddpc	r8,80004f78 <vPortEnterCritical+0x18>
80004f6a:	70 08       	ld.w	r8,r8[0x0]
80004f6c:	f0 c9 ff ff 	sub	r9,r8,-1
80004f70:	48 28       	lddpc	r8,80004f78 <vPortEnterCritical+0x18>
80004f72:	91 09       	st.w	r8[0x0],r9
}
80004f74:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f78:	00 00       	add	r0,r0
80004f7a:	00 20       	rsub	r0,r0

80004f7c <vPortExitCritical>:
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
80004f7c:	eb cd 40 80 	pushm	r7,lr
80004f80:	1a 97       	mov	r7,sp
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004f82:	48 98       	lddpc	r8,80004fa4 <vPortExitCritical+0x28>
80004f84:	70 08       	ld.w	r8,r8[0x0]
80004f86:	58 08       	cp.w	r8,0
80004f88:	c0 c0       	breq	80004fa0 <vPortExitCritical+0x24>
	{
		ulCriticalNesting--;
80004f8a:	48 78       	lddpc	r8,80004fa4 <vPortExitCritical+0x28>
80004f8c:	70 08       	ld.w	r8,r8[0x0]
80004f8e:	f0 c9 00 01 	sub	r9,r8,1
80004f92:	48 58       	lddpc	r8,80004fa4 <vPortExitCritical+0x28>
80004f94:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004f96:	48 48       	lddpc	r8,80004fa4 <vPortExitCritical+0x28>
80004f98:	70 08       	ld.w	r8,r8[0x0]
80004f9a:	58 08       	cp.w	r8,0
80004f9c:	c0 21       	brne	80004fa0 <vPortExitCritical+0x24>
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80004f9e:	d5 03       	csrf	0x10
		}
	}
}
80004fa0:	e3 cd 80 80 	ldm	sp++,r7,pc
80004fa4:	00 00       	add	r0,r0
80004fa6:	00 20       	rsub	r0,r0

80004fa8 <pxPortInitialiseStack>:
 * portSAVE_CONTEXT had been called.
 *
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
80004fa8:	eb cd 40 80 	pushm	r7,lr
80004fac:	1a 97       	mov	r7,sp
80004fae:	20 3d       	sub	sp,12
80004fb0:	ef 4c ff fc 	st.w	r7[-4],r12
80004fb4:	ef 4b ff f8 	st.w	r7[-8],r11
80004fb8:	ef 4a ff f4 	st.w	r7[-12],r10
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
80004fbc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004fc0:	20 48       	sub	r8,4
80004fc2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004fc6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004fca:	e0 69 08 08 	mov	r9,2056
80004fce:	ea 19 08 08 	orh	r9,0x808
80004fd2:	91 09       	st.w	r8[0x0],r9
80004fd4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004fd8:	20 48       	sub	r8,4
80004fda:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80004fde:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004fe2:	e0 69 09 09 	mov	r9,2313
80004fe6:	ea 19 09 09 	orh	r9,0x909
80004fea:	91 09       	st.w	r8[0x0],r9
80004fec:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ff0:	20 48       	sub	r8,4
80004ff2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004ff6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ffa:	e0 69 0a 0a 	mov	r9,2570
80004ffe:	ea 19 0a 0a 	orh	r9,0xa0a
80005002:	91 09       	st.w	r8[0x0],r9
80005004:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005008:	20 48       	sub	r8,4
8000500a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
8000500e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005012:	e0 69 0b 0b 	mov	r9,2827
80005016:	ea 19 0b 0b 	orh	r9,0xb0b
8000501a:	91 09       	st.w	r8[0x0],r9
8000501c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005020:	20 48       	sub	r8,4
80005022:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005026:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000502a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000502e:	91 09       	st.w	r8[0x0],r9
80005030:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005034:	20 48       	sub	r8,4
80005036:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
8000503a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000503e:	e0 69 be ef 	mov	r9,48879
80005042:	ea 19 de ad 	orh	r9,0xdead
80005046:	91 09       	st.w	r8[0x0],r9
80005048:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000504c:	20 48       	sub	r8,4
8000504e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005052:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005056:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000505a:	91 09       	st.w	r8[0x0],r9
8000505c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005060:	20 48       	sub	r8,4
80005062:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005066:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000506a:	fc 19 00 40 	movh	r9,0x40
8000506e:	91 09       	st.w	r8[0x0],r9
80005070:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005074:	20 48       	sub	r8,4
80005076:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
8000507a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000507e:	e0 69 00 ff 	mov	r9,255
80005082:	ea 19 ff 00 	orh	r9,0xff00
80005086:	91 09       	st.w	r8[0x0],r9
80005088:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000508c:	20 48       	sub	r8,4
8000508e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005092:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005096:	e0 69 01 01 	mov	r9,257
8000509a:	ea 19 01 01 	orh	r9,0x101
8000509e:	91 09       	st.w	r8[0x0],r9
800050a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050a4:	20 48       	sub	r8,4
800050a6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
800050aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050ae:	e0 69 02 02 	mov	r9,514
800050b2:	ea 19 02 02 	orh	r9,0x202
800050b6:	91 09       	st.w	r8[0x0],r9
800050b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050bc:	20 48       	sub	r8,4
800050be:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
800050c2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050c6:	e0 69 03 03 	mov	r9,771
800050ca:	ea 19 03 03 	orh	r9,0x303
800050ce:	91 09       	st.w	r8[0x0],r9
800050d0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050d4:	20 48       	sub	r8,4
800050d6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
800050da:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050de:	e0 69 04 04 	mov	r9,1028
800050e2:	ea 19 04 04 	orh	r9,0x404
800050e6:	91 09       	st.w	r8[0x0],r9
800050e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050ec:	20 48       	sub	r8,4
800050ee:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800050f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050f6:	e0 69 05 05 	mov	r9,1285
800050fa:	ea 19 05 05 	orh	r9,0x505
800050fe:	91 09       	st.w	r8[0x0],r9
80005100:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005104:	20 48       	sub	r8,4
80005106:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
8000510a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000510e:	e0 69 06 06 	mov	r9,1542
80005112:	ea 19 06 06 	orh	r9,0x606
80005116:	91 09       	st.w	r8[0x0],r9
80005118:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000511c:	20 48       	sub	r8,4
8000511e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005122:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005126:	e0 69 07 07 	mov	r9,1799
8000512a:	ea 19 07 07 	orh	r9,0x707
8000512e:	91 09       	st.w	r8[0x0],r9
80005130:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005134:	20 48       	sub	r8,4
80005136:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
8000513a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000513e:	30 09       	mov	r9,0
80005140:	91 09       	st.w	r8[0x0],r9

	return pxTopOfStack;
80005142:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005146:	10 9c       	mov	r12,r8
80005148:	2f dd       	sub	sp,-12
8000514a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000514e:	d7 03       	nop

80005150 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005150:	eb cd 40 80 	pushm	r7,lr
80005154:	1a 97       	mov	r7,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
80005156:	f0 1f 00 10 	mcall	80005194 <xPortStartScheduler+0x44>

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000515a:	e0 68 06 60 	mov	r8,1632
8000515e:	ea 18 00 00 	orh	r8,0x0
80005162:	70 00       	ld.w	r0,r8[0x0]
80005164:	60 0d       	ld.w	sp,r0[0x0]
80005166:	1b 00       	ld.w	r0,sp++
80005168:	e0 68 00 20 	mov	r8,32
8000516c:	ea 18 00 00 	orh	r8,0x0
80005170:	91 00       	st.w	r8[0x0],r0
80005172:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005176:	2f ed       	sub	sp,-8
80005178:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000517c:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005180:	e3 b0 00 00 	mtsr	0x0,r0
80005184:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005188:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
8000518c:	30 08       	mov	r8,0
}
8000518e:	10 9c       	mov	r12,r8
80005190:	e3 cd 80 80 	ldm	sp++,r7,pc
80005194:	80 00       	ld.sh	r0,r0[0x0]
80005196:	51 c4       	stdsp	sp[0x70],r4

80005198 <prvScheduleFirstTick>:

/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
80005198:	eb cd 40 80 	pushm	r7,lr
8000519c:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
8000519e:	e0 68 2e e0 	mov	r8,12000
800051a2:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800051a6:	30 08       	mov	r8,0
800051a8:	e3 b8 00 42 	mtsr	0x108,r8
	}
800051ac:	e3 cd 80 80 	ldm	sp++,r7,pc

800051b0 <prvClearCcInt>:

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
800051b0:	eb cd 40 80 	pushm	r7,lr
800051b4:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800051b6:	e1 b8 00 43 	mfsr	r8,0x10c
800051ba:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800051be:	e3 cd 80 80 	ldm	sp++,r7,pc
800051c2:	d7 03       	nop

800051c4 <prvSetupTimerInterrupt>:
#endif
/*-----------------------------------------------------------*/

/* Setup the timer to generate the tick interrupts. */
static void prvSetupTimerInterrupt(void)
{
800051c4:	eb cd 40 80 	pushm	r7,lr
800051c8:	1a 97       	mov	r7,sp
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
800051ca:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
800051cc:	30 0a       	mov	r10,0
800051ce:	30 0b       	mov	r11,0
800051d0:	48 4c       	lddpc	r12,800051e0 <prvSetupTimerInterrupt+0x1c>
800051d2:	f0 1f 00 05 	mcall	800051e4 <prvSetupTimerInterrupt+0x20>
		prvScheduleFirstTick();
800051d6:	f0 1f 00 05 	mcall	800051e8 <prvSetupTimerInterrupt+0x24>
	}
	#endif
}
800051da:	e3 cd 80 80 	ldm	sp++,r7,pc
800051de:	00 00       	add	r0,r0
800051e0:	80 00       	ld.sh	r0,r0[0x0]
800051e2:	4e 44       	lddpc	r4,80005370 <vPortFree+0x2c>
800051e4:	80 00       	ld.sh	r0,r0[0x0]
800051e6:	44 c4       	lddsp	r4,sp[0x130]
800051e8:	80 00       	ld.sh	r0,r0[0x0]
800051ea:	51 98       	stdsp	sp[0x64],r8

800051ec <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
800051ec:	eb cd 40 80 	pushm	r7,lr
800051f0:	1a 97       	mov	r7,sp
800051f2:	20 5d       	sub	sp,20
800051f4:	ef 4c ff f4 	st.w	r7[-12],r12
800051f8:	ef 4b ff f0 	st.w	r7[-16],r11
800051fc:	ef 4a ff ec 	st.w	r7[-20],r10
  int nChars = 0;
80005200:	30 08       	mov	r8,0
80005202:	ef 48 ff f8 	st.w	r7[-8],r8

  if (file != 0)
80005206:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000520a:	58 08       	cp.w	r8,0
8000520c:	c2 40       	breq	80005254 <_read+0x68>
    return -1;
8000520e:	3f f8       	mov	r8,-1
80005210:	c2 b8       	rjmp	80005266 <_read+0x7a>

  for (; len > 0; --len)
  {
    int c = usart_getchar(stdio_usart_base);
80005212:	49 88       	lddpc	r8,80005270 <_read+0x84>
80005214:	70 08       	ld.w	r8,r8[0x0]
80005216:	10 9c       	mov	r12,r8
80005218:	f0 1f 00 17 	mcall	80005274 <_read+0x88>
8000521c:	18 98       	mov	r8,r12
8000521e:	ef 48 ff fc 	st.w	r7[-4],r8
    if (c < 0)
80005222:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005226:	58 08       	cp.w	r8,0
80005228:	c1 c5       	brlt	80005260 <_read+0x74>
      break;

    *ptr++ = c;
8000522a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000522e:	5c 58       	castu.b	r8
80005230:	ee f9 ff f0 	ld.w	r9,r7[-16]
80005234:	b2 88       	st.b	r9[0x0],r8
80005236:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000523a:	2f f8       	sub	r8,-1
8000523c:	ef 48 ff f0 	st.w	r7[-16],r8
    ++nChars;
80005240:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005244:	2f f8       	sub	r8,-1
80005246:	ef 48 ff f8 	st.w	r7[-8],r8
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
8000524a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000524e:	20 18       	sub	r8,1
80005250:	ef 48 ff ec 	st.w	r7[-20],r8
80005254:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005258:	58 08       	cp.w	r8,0
8000525a:	fe 99 ff dc 	brgt	80005212 <_read+0x26>
8000525e:	c0 28       	rjmp	80005262 <_read+0x76>
  {
    int c = usart_getchar(stdio_usart_base);
    if (c < 0)
      break;
80005260:	d7 03       	nop

    *ptr++ = c;
    ++nChars;
  }

  return nChars;
80005262:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80005266:	10 9c       	mov	r12,r8
80005268:	2f bd       	sub	sp,-20
8000526a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000526e:	00 00       	add	r0,r0
80005270:	00 00       	add	r0,r0
80005272:	08 08       	add	r8,r4
80005274:	80 00       	ld.sh	r0,r0[0x0]
80005276:	4b 4c       	lddpc	r12,80005344 <vPortFree>

80005278 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005278:	eb cd 40 80 	pushm	r7,lr
8000527c:	1a 97       	mov	r7,sp
8000527e:	20 4d       	sub	sp,16
80005280:	ef 4c ff f8 	st.w	r7[-8],r12
80005284:	ef 4b ff f4 	st.w	r7[-12],r11
80005288:	ef 4a ff f0 	st.w	r7[-16],r10
  int nChars = 0;
8000528c:	30 08       	mov	r8,0
8000528e:	ef 48 ff fc 	st.w	r7[-4],r8

  if ( (file != 1)
80005292:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005296:	58 18       	cp.w	r8,1
80005298:	c2 90       	breq	800052ea <_write+0x72>
8000529a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000529e:	58 28       	cp.w	r8,2
800052a0:	c2 50       	breq	800052ea <_write+0x72>
800052a2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800052a6:	58 38       	cp.w	r8,3
800052a8:	c2 10       	breq	800052ea <_write+0x72>
       && (file != 2) && (file!=3))
    return -1;
800052aa:	3f f8       	mov	r8,-1
800052ac:	c2 58       	rjmp	800052f6 <_write+0x7e>

  for (; len != 0; --len)
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
800052ae:	ee f8 ff f4 	ld.w	r8,r7[-12]
800052b2:	11 88       	ld.ub	r8,r8[0x0]
800052b4:	10 99       	mov	r9,r8
800052b6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800052ba:	2f f8       	sub	r8,-1
800052bc:	ef 48 ff f4 	st.w	r7[-12],r8
800052c0:	49 08       	lddpc	r8,80005300 <_write+0x88>
800052c2:	70 08       	ld.w	r8,r8[0x0]
800052c4:	12 9b       	mov	r11,r9
800052c6:	10 9c       	mov	r12,r8
800052c8:	f0 1f 00 0f 	mcall	80005304 <_write+0x8c>
800052cc:	18 98       	mov	r8,r12
800052ce:	58 08       	cp.w	r8,0
800052d0:	c0 34       	brge	800052d6 <_write+0x5e>
    {
      return -1;
800052d2:	3f f8       	mov	r8,-1
800052d4:	c1 18       	rjmp	800052f6 <_write+0x7e>
    }

    ++nChars;
800052d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052da:	2f f8       	sub	r8,-1
800052dc:	ef 48 ff fc 	st.w	r7[-4],r8

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800052e0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800052e4:	20 18       	sub	r8,1
800052e6:	ef 48 ff f0 	st.w	r7[-16],r8
800052ea:	ee f8 ff f0 	ld.w	r8,r7[-16]
800052ee:	58 08       	cp.w	r8,0
800052f0:	cd f1       	brne	800052ae <_write+0x36>
    }

    ++nChars;
  }

  return nChars;
800052f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800052f6:	10 9c       	mov	r12,r8
800052f8:	2f cd       	sub	sp,-16
800052fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800052fe:	00 00       	add	r0,r0
80005300:	00 00       	add	r0,r0
80005302:	08 08       	add	r8,r4
80005304:	80 00       	ld.sh	r0,r0[0x0]
80005306:	4a a4       	lddpc	r4,800053ac <xQueueCreate+0x30>

80005308 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005308:	eb cd 40 80 	pushm	r7,lr
8000530c:	1a 97       	mov	r7,sp
8000530e:	20 2d       	sub	sp,8
80005310:	ef 4c ff f8 	st.w	r7[-8],r12
void *pvReturn;

	vTaskSuspendAll();
80005314:	f0 1f 00 09 	mcall	80005338 <pvPortMalloc+0x30>
	{
		pvReturn = malloc( xWantedSize );
80005318:	ee fc ff f8 	ld.w	r12,r7[-8]
8000531c:	f0 1f 00 08 	mcall	8000533c <pvPortMalloc+0x34>
80005320:	18 98       	mov	r8,r12
80005322:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	xTaskResumeAll();
80005326:	f0 1f 00 07 	mcall	80005340 <pvPortMalloc+0x38>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
8000532a:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000532e:	10 9c       	mov	r12,r8
80005330:	2f ed       	sub	sp,-8
80005332:	e3 cd 80 80 	ldm	sp++,r7,pc
80005336:	00 00       	add	r0,r0
80005338:	80 00       	ld.sh	r0,r0[0x0]
8000533a:	5d 90       	*unknown*
8000533c:	80 00       	ld.sh	r0,r0[0x0]
8000533e:	69 38       	ld.w	r8,r4[0x4c]
80005340:	80 00       	ld.sh	r0,r0[0x0]
80005342:	5d ac       	*unknown*

80005344 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005344:	eb cd 40 80 	pushm	r7,lr
80005348:	1a 97       	mov	r7,sp
8000534a:	20 1d       	sub	sp,4
8000534c:	ef 4c ff fc 	st.w	r7[-4],r12
	if( pv )
80005350:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005354:	58 08       	cp.w	r8,0
80005356:	c0 90       	breq	80005368 <vPortFree+0x24>
	{
		vTaskSuspendAll();
80005358:	f0 1f 00 06 	mcall	80005370 <vPortFree+0x2c>
		{
			free( pv );
8000535c:	ee fc ff fc 	ld.w	r12,r7[-4]
80005360:	f0 1f 00 05 	mcall	80005374 <vPortFree+0x30>
		}
		xTaskResumeAll();
80005364:	f0 1f 00 05 	mcall	80005378 <vPortFree+0x34>
	}
}
80005368:	2f fd       	sub	sp,-4
8000536a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000536e:	00 00       	add	r0,r0
80005370:	80 00       	ld.sh	r0,r0[0x0]
80005372:	5d 90       	*unknown*
80005374:	80 00       	ld.sh	r0,r0[0x0]
80005376:	69 28       	ld.w	r8,r4[0x48]
80005378:	80 00       	ld.sh	r0,r0[0x0]
8000537a:	5d ac       	*unknown*

8000537c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
8000537c:	eb cd 40 80 	pushm	r7,lr
80005380:	1a 97       	mov	r7,sp
80005382:	20 5d       	sub	sp,20
80005384:	ef 4c ff f0 	st.w	r7[-16],r12
80005388:	ef 4b ff ec 	st.w	r7[-20],r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
8000538c:	30 08       	mov	r8,0
8000538e:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005392:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005396:	58 08       	cp.w	r8,0
80005398:	c7 20       	breq	8000547c <xQueueCreate+0x100>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000539a:	34 cc       	mov	r12,76
8000539c:	f0 1f 00 3b 	mcall	80005488 <xQueueCreate+0x10c>
800053a0:	18 98       	mov	r8,r12
800053a2:	ef 48 ff f4 	st.w	r7[-12],r8
		if( pxNewQueue != NULL )
800053a6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800053aa:	58 08       	cp.w	r8,0
800053ac:	c6 80       	breq	8000547c <xQueueCreate+0x100>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800053ae:	ee f9 ff f0 	ld.w	r9,r7[-16]
800053b2:	ee f8 ff ec 	ld.w	r8,r7[-20]
800053b6:	f2 08 02 48 	mul	r8,r9,r8
800053ba:	2f f8       	sub	r8,-1
800053bc:	ef 48 ff f8 	st.w	r7[-8],r8

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800053c0:	ee fc ff f8 	ld.w	r12,r7[-8]
800053c4:	f0 1f 00 31 	mcall	80005488 <xQueueCreate+0x10c>
800053c8:	18 98       	mov	r8,r12
800053ca:	10 99       	mov	r9,r8
800053cc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800053d0:	91 09       	st.w	r8[0x0],r9
			if( pxNewQueue->pcHead != NULL )
800053d2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800053d6:	70 08       	ld.w	r8,r8[0x0]
800053d8:	58 08       	cp.w	r8,0
800053da:	c4 d0       	breq	80005474 <xQueueCreate+0xf8>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800053dc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800053e0:	70 09       	ld.w	r9,r8[0x0]
800053e2:	ee fa ff f0 	ld.w	r10,r7[-16]
800053e6:	ee f8 ff ec 	ld.w	r8,r7[-20]
800053ea:	f4 08 02 48 	mul	r8,r10,r8
800053ee:	10 09       	add	r9,r8
800053f0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800053f4:	91 19       	st.w	r8[0x4],r9
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800053f6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800053fa:	30 09       	mov	r9,0
800053fc:	91 e9       	st.w	r8[0x38],r9
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800053fe:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005402:	70 09       	ld.w	r9,r8[0x0]
80005404:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005408:	91 29       	st.w	r8[0x8],r9
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000540a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000540e:	70 09       	ld.w	r9,r8[0x0]
80005410:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005414:	f0 ca 00 01 	sub	r10,r8,1
80005418:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000541c:	f4 08 02 48 	mul	r8,r10,r8
80005420:	10 09       	add	r9,r8
80005422:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005426:	91 39       	st.w	r8[0xc],r9
				pxNewQueue->uxLength = uxQueueLength;
80005428:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000542c:	ee f9 ff f0 	ld.w	r9,r7[-16]
80005430:	91 f9       	st.w	r8[0x3c],r9
				pxNewQueue->uxItemSize = uxItemSize;
80005432:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005436:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000543a:	f1 49 00 40 	st.w	r8[64],r9
				pxNewQueue->xRxLock = queueUNLOCKED;
8000543e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005442:	3f f9       	mov	r9,-1
80005444:	f1 49 00 44 	st.w	r8[68],r9
				pxNewQueue->xTxLock = queueUNLOCKED;
80005448:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000544c:	3f f9       	mov	r9,-1
8000544e:	f1 49 00 48 	st.w	r8[72],r9

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005452:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005456:	2f 08       	sub	r8,-16
80005458:	10 9c       	mov	r12,r8
8000545a:	f0 1f 00 0d 	mcall	8000548c <xQueueCreate+0x110>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000545e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005462:	2d c8       	sub	r8,-36
80005464:	10 9c       	mov	r12,r8
80005466:	f0 1f 00 0a 	mcall	8000548c <xQueueCreate+0x110>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
8000546a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000546e:	ef 48 ff fc 	st.w	r7[-4],r8
80005472:	c0 58       	rjmp	8000547c <xQueueCreate+0x100>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005474:	ee fc ff f4 	ld.w	r12,r7[-12]
80005478:	f0 1f 00 06 	mcall	80005490 <xQueueCreate+0x114>
		}
	}

	configASSERT( xReturn );

	return xReturn;
8000547c:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005480:	10 9c       	mov	r12,r8
80005482:	2f bd       	sub	sp,-20
80005484:	e3 cd 80 80 	ldm	sp++,r7,pc
80005488:	80 00       	ld.sh	r0,r0[0x0]
8000548a:	53 08       	stdsp	sp[0xc0],r8
8000548c:	80 00       	ld.sh	r0,r0[0x0]
8000548e:	4b d0       	lddpc	r0,80005580 <xQueueGenericSend+0xa8>
80005490:	80 00       	ld.sh	r0,r0[0x0]
80005492:	53 44       	stdsp	sp[0xd0],r4

80005494 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
80005494:	eb cd 40 80 	pushm	r7,lr
80005498:	1a 97       	mov	r7,sp
8000549a:	20 3d       	sub	sp,12
8000549c:	ef 4c ff f8 	st.w	r7[-8],r12
800054a0:	ef 4b ff f4 	st.w	r7[-12],r11
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
800054a4:	30 0b       	mov	r11,0
800054a6:	ee fc ff f8 	ld.w	r12,r7[-8]
800054aa:	f0 1f 00 0b 	mcall	800054d4 <xQueueCreateCountingSemaphore+0x40>
800054ae:	18 98       	mov	r8,r12
800054b0:	ef 48 ff fc 	st.w	r7[-4],r8

		if( pxHandle != NULL )
800054b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800054b8:	58 08       	cp.w	r8,0
800054ba:	c0 60       	breq	800054c6 <xQueueCreateCountingSemaphore+0x32>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
800054bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800054c0:	ee f9 ff f4 	ld.w	r9,r7[-12]
800054c4:	91 e9       	st.w	r8[0x38],r9
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
800054c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
	}
800054ca:	10 9c       	mov	r12,r8
800054cc:	2f dd       	sub	sp,-12
800054ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800054d2:	00 00       	add	r0,r0
800054d4:	80 00       	ld.sh	r0,r0[0x0]
800054d6:	53 7c       	stdsp	sp[0xdc],r12

800054d8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800054d8:	eb cd 40 80 	pushm	r7,lr
800054dc:	1a 97       	mov	r7,sp
800054de:	20 7d       	sub	sp,28
800054e0:	ef 4c ff f0 	st.w	r7[-16],r12
800054e4:	ef 4b ff ec 	st.w	r7[-20],r11
800054e8:	ef 4a ff e8 	st.w	r7[-24],r10
800054ec:	ef 49 ff e4 	st.w	r7[-28],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
800054f0:	30 08       	mov	r8,0
800054f2:	ef 48 ff fc 	st.w	r7[-4],r8
800054f6:	c0 28       	rjmp	800054fa <xQueueGenericSend+0x22>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
800054f8:	d7 03       	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800054fa:	f0 1f 00 47 	mcall	80005614 <xQueueGenericSend+0x13c>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800054fe:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005502:	70 e9       	ld.w	r9,r8[0x38]
80005504:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005508:	70 f8       	ld.w	r8,r8[0x3c]
8000550a:	10 39       	cp.w	r9,r8
8000550c:	c1 c2       	brcc	80005544 <xQueueGenericSend+0x6c>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000550e:	ee fa ff e4 	ld.w	r10,r7[-28]
80005512:	ee fb ff ec 	ld.w	r11,r7[-20]
80005516:	ee fc ff f0 	ld.w	r12,r7[-16]
8000551a:	f0 1f 00 40 	mcall	80005618 <xQueueGenericSend+0x140>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000551e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005522:	70 98       	ld.w	r8,r8[0x24]
80005524:	58 08       	cp.w	r8,0
80005526:	c0 b0       	breq	8000553c <xQueueGenericSend+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005528:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000552c:	2d c8       	sub	r8,-36
8000552e:	10 9c       	mov	r12,r8
80005530:	f0 1f 00 3b 	mcall	8000561c <xQueueGenericSend+0x144>
80005534:	18 98       	mov	r8,r12
80005536:	58 18       	cp.w	r8,1
80005538:	c0 21       	brne	8000553c <xQueueGenericSend+0x64>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
8000553a:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
8000553c:	f0 1f 00 39 	mcall	80005620 <xQueueGenericSend+0x148>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005540:	30 18       	mov	r8,1
80005542:	c6 58       	rjmp	8000560c <xQueueGenericSend+0x134>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005544:	ee f8 ff e8 	ld.w	r8,r7[-24]
80005548:	58 08       	cp.w	r8,0
8000554a:	c0 51       	brne	80005554 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000554c:	f0 1f 00 35 	mcall	80005620 <xQueueGenericSend+0x148>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005550:	30 08       	mov	r8,0
80005552:	c5 d8       	rjmp	8000560c <xQueueGenericSend+0x134>
				}
				else if( xEntryTimeSet == pdFALSE )
80005554:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005558:	58 08       	cp.w	r8,0
8000555a:	c0 91       	brne	8000556c <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000555c:	ee c8 00 0c 	sub	r8,r7,12
80005560:	10 9c       	mov	r12,r8
80005562:	f0 1f 00 31 	mcall	80005624 <xQueueGenericSend+0x14c>
					xEntryTimeSet = pdTRUE;
80005566:	30 18       	mov	r8,1
80005568:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}
		}
		taskEXIT_CRITICAL();
8000556c:	f0 1f 00 2d 	mcall	80005620 <xQueueGenericSend+0x148>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005570:	f0 1f 00 2e 	mcall	80005628 <xQueueGenericSend+0x150>
		prvLockQueue( pxQueue );
80005574:	f0 1f 00 28 	mcall	80005614 <xQueueGenericSend+0x13c>
80005578:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000557c:	71 18       	ld.w	r8,r8[0x44]
8000557e:	5b f8       	cp.w	r8,-1
80005580:	c0 61       	brne	8000558c <xQueueGenericSend+0xb4>
80005582:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005586:	30 09       	mov	r9,0
80005588:	f1 49 00 44 	st.w	r8[68],r9
8000558c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005590:	71 28       	ld.w	r8,r8[0x48]
80005592:	5b f8       	cp.w	r8,-1
80005594:	c0 61       	brne	800055a0 <xQueueGenericSend+0xc8>
80005596:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000559a:	30 09       	mov	r9,0
8000559c:	f1 49 00 48 	st.w	r8[72],r9
800055a0:	f0 1f 00 20 	mcall	80005620 <xQueueGenericSend+0x148>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800055a4:	ee c9 00 18 	sub	r9,r7,24
800055a8:	ee c8 00 0c 	sub	r8,r7,12
800055ac:	12 9b       	mov	r11,r9
800055ae:	10 9c       	mov	r12,r8
800055b0:	f0 1f 00 1f 	mcall	8000562c <xQueueGenericSend+0x154>
800055b4:	18 98       	mov	r8,r12
800055b6:	58 08       	cp.w	r8,0
800055b8:	c2 31       	brne	800055fe <xQueueGenericSend+0x126>
		{
			if( prvIsQueueFull( pxQueue ) )
800055ba:	ee fc ff f0 	ld.w	r12,r7[-16]
800055be:	f0 1f 00 1d 	mcall	80005630 <xQueueGenericSend+0x158>
800055c2:	18 98       	mov	r8,r12
800055c4:	58 08       	cp.w	r8,0
800055c6:	c1 50       	breq	800055f0 <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800055c8:	ee f9 ff e8 	ld.w	r9,r7[-24]
800055cc:	ee f8 ff f0 	ld.w	r8,r7[-16]
800055d0:	2f 08       	sub	r8,-16
800055d2:	12 9b       	mov	r11,r9
800055d4:	10 9c       	mov	r12,r8
800055d6:	f0 1f 00 18 	mcall	80005634 <xQueueGenericSend+0x15c>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800055da:	ee fc ff f0 	ld.w	r12,r7[-16]
800055de:	f0 1f 00 17 	mcall	80005638 <xQueueGenericSend+0x160>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800055e2:	f0 1f 00 17 	mcall	8000563c <xQueueGenericSend+0x164>
800055e6:	18 98       	mov	r8,r12
800055e8:	58 08       	cp.w	r8,0
800055ea:	c8 71       	brne	800054f8 <xQueueGenericSend+0x20>
				{
					portYIELD_WITHIN_API();
800055ec:	d7 33       	scall
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
800055ee:	c8 6b       	rjmp	800054fa <xQueueGenericSend+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800055f0:	ee fc ff f0 	ld.w	r12,r7[-16]
800055f4:	f0 1f 00 11 	mcall	80005638 <xQueueGenericSend+0x160>
				( void ) xTaskResumeAll();
800055f8:	f0 1f 00 11 	mcall	8000563c <xQueueGenericSend+0x164>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
800055fc:	c7 fb       	rjmp	800054fa <xQueueGenericSend+0x22>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800055fe:	ee fc ff f0 	ld.w	r12,r7[-16]
80005602:	f0 1f 00 0e 	mcall	80005638 <xQueueGenericSend+0x160>
			( void ) xTaskResumeAll();
80005606:	f0 1f 00 0e 	mcall	8000563c <xQueueGenericSend+0x164>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
8000560a:	30 08       	mov	r8,0
		}
	}
}
8000560c:	10 9c       	mov	r12,r8
8000560e:	2f 9d       	sub	sp,-28
80005610:	e3 cd 80 80 	ldm	sp++,r7,pc
80005614:	80 00       	ld.sh	r0,r0[0x0]
80005616:	4f 60       	lddpc	r0,800057ec <prvCopyDataToQueue>
80005618:	80 00       	ld.sh	r0,r0[0x0]
8000561a:	57 ec       	stdsp	sp[0x1f8],r12
8000561c:	80 00       	ld.sh	r0,r0[0x0]
8000561e:	61 94       	ld.w	r4,r0[0x64]
80005620:	80 00       	ld.sh	r0,r0[0x0]
80005622:	4f 7c       	lddpc	r12,800057fc <prvCopyDataToQueue+0x10>
80005624:	80 00       	ld.sh	r0,r0[0x0]
80005626:	62 64       	ld.w	r4,r1[0x18]
80005628:	80 00       	ld.sh	r0,r0[0x0]
8000562a:	5d 90       	*unknown*
8000562c:	80 00       	ld.sh	r0,r0[0x0]
8000562e:	62 94       	ld.w	r4,r1[0x24]
80005630:	80 00       	ld.sh	r0,r0[0x0]
80005632:	5a 40       	cp.w	r0,-28
80005634:	80 00       	ld.sh	r0,r0[0x0]
80005636:	61 14       	ld.w	r4,r0[0x44]
80005638:	80 00       	ld.sh	r0,r0[0x0]
8000563a:	59 38       	cp.w	r8,19
8000563c:	80 00       	ld.sh	r0,r0[0x0]
8000563e:	5d ac       	*unknown*

80005640 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005640:	eb cd 40 80 	pushm	r7,lr
80005644:	1a 97       	mov	r7,sp
80005646:	20 8d       	sub	sp,32
80005648:	ef 4c ff ec 	st.w	r7[-20],r12
8000564c:	ef 4b ff e8 	st.w	r7[-24],r11
80005650:	ef 4a ff e4 	st.w	r7[-28],r10
80005654:	ef 49 ff e0 	st.w	r7[-32],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
80005658:	30 08       	mov	r8,0
8000565a:	ef 48 ff f8 	st.w	r7[-8],r8
8000565e:	c0 28       	rjmp	80005662 <xQueueGenericReceive+0x22>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
80005660:	d7 03       	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005662:	f0 1f 00 58 	mcall	800057c0 <xQueueGenericReceive+0x180>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005666:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000566a:	70 e8       	ld.w	r8,r8[0x38]
8000566c:	58 08       	cp.w	r8,0
8000566e:	c4 00       	breq	800056ee <xQueueGenericReceive+0xae>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005670:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005674:	70 38       	ld.w	r8,r8[0xc]
80005676:	ef 48 ff fc 	st.w	r7[-4],r8

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000567a:	ee fb ff e8 	ld.w	r11,r7[-24]
8000567e:	ee fc ff ec 	ld.w	r12,r7[-20]
80005682:	f0 1f 00 51 	mcall	800057c4 <xQueueGenericReceive+0x184>

				if( xJustPeeking == pdFALSE )
80005686:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000568a:	58 08       	cp.w	r8,0
8000568c:	c1 91       	brne	800056be <xQueueGenericReceive+0x7e>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000568e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005692:	70 e8       	ld.w	r8,r8[0x38]
80005694:	f0 c9 00 01 	sub	r9,r8,1
80005698:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000569c:	91 e9       	st.w	r8[0x38],r9
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000569e:	ee f8 ff ec 	ld.w	r8,r7[-20]
800056a2:	70 48       	ld.w	r8,r8[0x10]
800056a4:	58 08       	cp.w	r8,0
800056a6:	c2 00       	breq	800056e6 <xQueueGenericReceive+0xa6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800056a8:	ee f8 ff ec 	ld.w	r8,r7[-20]
800056ac:	2f 08       	sub	r8,-16
800056ae:	10 9c       	mov	r12,r8
800056b0:	f0 1f 00 46 	mcall	800057c8 <xQueueGenericReceive+0x188>
800056b4:	18 98       	mov	r8,r12
800056b6:	58 18       	cp.w	r8,1
800056b8:	c1 71       	brne	800056e6 <xQueueGenericReceive+0xa6>
						{
							portYIELD_WITHIN_API();
800056ba:	d7 33       	scall
800056bc:	c1 58       	rjmp	800056e6 <xQueueGenericReceive+0xa6>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800056be:	ee f8 ff ec 	ld.w	r8,r7[-20]
800056c2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800056c6:	91 39       	st.w	r8[0xc],r9

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800056c8:	ee f8 ff ec 	ld.w	r8,r7[-20]
800056cc:	70 98       	ld.w	r8,r8[0x24]
800056ce:	58 08       	cp.w	r8,0
800056d0:	c0 b0       	breq	800056e6 <xQueueGenericReceive+0xa6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800056d2:	ee f8 ff ec 	ld.w	r8,r7[-20]
800056d6:	2d c8       	sub	r8,-36
800056d8:	10 9c       	mov	r12,r8
800056da:	f0 1f 00 3c 	mcall	800057c8 <xQueueGenericReceive+0x188>
800056de:	18 98       	mov	r8,r12
800056e0:	58 08       	cp.w	r8,0
800056e2:	c0 20       	breq	800056e6 <xQueueGenericReceive+0xa6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800056e4:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800056e6:	f0 1f 00 3a 	mcall	800057cc <xQueueGenericReceive+0x18c>
				return pdPASS;
800056ea:	30 18       	mov	r8,1
800056ec:	c6 68       	rjmp	800057b8 <xQueueGenericReceive+0x178>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800056ee:	ee f8 ff e4 	ld.w	r8,r7[-28]
800056f2:	58 08       	cp.w	r8,0
800056f4:	c0 51       	brne	800056fe <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800056f6:	f0 1f 00 36 	mcall	800057cc <xQueueGenericReceive+0x18c>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800056fa:	30 08       	mov	r8,0
800056fc:	c5 e8       	rjmp	800057b8 <xQueueGenericReceive+0x178>
				}
				else if( xEntryTimeSet == pdFALSE )
800056fe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005702:	58 08       	cp.w	r8,0
80005704:	c0 91       	brne	80005716 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005706:	ee c8 00 10 	sub	r8,r7,16
8000570a:	10 9c       	mov	r12,r8
8000570c:	f0 1f 00 31 	mcall	800057d0 <xQueueGenericReceive+0x190>
					xEntryTimeSet = pdTRUE;
80005710:	30 18       	mov	r8,1
80005712:	ef 48 ff f8 	st.w	r7[-8],r8
				}
			}
		}
		taskEXIT_CRITICAL();
80005716:	f0 1f 00 2e 	mcall	800057cc <xQueueGenericReceive+0x18c>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000571a:	f0 1f 00 2f 	mcall	800057d4 <xQueueGenericReceive+0x194>
		prvLockQueue( pxQueue );
8000571e:	f0 1f 00 29 	mcall	800057c0 <xQueueGenericReceive+0x180>
80005722:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005726:	71 18       	ld.w	r8,r8[0x44]
80005728:	5b f8       	cp.w	r8,-1
8000572a:	c0 61       	brne	80005736 <xQueueGenericReceive+0xf6>
8000572c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005730:	30 09       	mov	r9,0
80005732:	f1 49 00 44 	st.w	r8[68],r9
80005736:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000573a:	71 28       	ld.w	r8,r8[0x48]
8000573c:	5b f8       	cp.w	r8,-1
8000573e:	c0 61       	brne	8000574a <xQueueGenericReceive+0x10a>
80005740:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005744:	30 09       	mov	r9,0
80005746:	f1 49 00 48 	st.w	r8[72],r9
8000574a:	f0 1f 00 21 	mcall	800057cc <xQueueGenericReceive+0x18c>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000574e:	ee c9 00 1c 	sub	r9,r7,28
80005752:	ee c8 00 10 	sub	r8,r7,16
80005756:	12 9b       	mov	r11,r9
80005758:	10 9c       	mov	r12,r8
8000575a:	f0 1f 00 20 	mcall	800057d8 <xQueueGenericReceive+0x198>
8000575e:	18 98       	mov	r8,r12
80005760:	58 08       	cp.w	r8,0
80005762:	c2 41       	brne	800057aa <xQueueGenericReceive+0x16a>
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005764:	ee fc ff ec 	ld.w	r12,r7[-20]
80005768:	f0 1f 00 1d 	mcall	800057dc <xQueueGenericReceive+0x19c>
8000576c:	18 98       	mov	r8,r12
8000576e:	58 08       	cp.w	r8,0
80005770:	c1 60       	breq	8000579c <xQueueGenericReceive+0x15c>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005772:	ee f9 ff e4 	ld.w	r9,r7[-28]
80005776:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000577a:	2d c8       	sub	r8,-36
8000577c:	12 9b       	mov	r11,r9
8000577e:	10 9c       	mov	r12,r8
80005780:	f0 1f 00 18 	mcall	800057e0 <xQueueGenericReceive+0x1a0>
				prvUnlockQueue( pxQueue );
80005784:	ee fc ff ec 	ld.w	r12,r7[-20]
80005788:	f0 1f 00 17 	mcall	800057e4 <xQueueGenericReceive+0x1a4>
				if( !xTaskResumeAll() )
8000578c:	f0 1f 00 17 	mcall	800057e8 <xQueueGenericReceive+0x1a8>
80005790:	18 98       	mov	r8,r12
80005792:	58 08       	cp.w	r8,0
80005794:	fe 91 ff 66 	brne	80005660 <xQueueGenericReceive+0x20>
				{
					portYIELD_WITHIN_API();
80005798:	d7 33       	scall
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
8000579a:	c6 4b       	rjmp	80005662 <xQueueGenericReceive+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000579c:	ee fc ff ec 	ld.w	r12,r7[-20]
800057a0:	f0 1f 00 11 	mcall	800057e4 <xQueueGenericReceive+0x1a4>
				( void ) xTaskResumeAll();
800057a4:	f0 1f 00 11 	mcall	800057e8 <xQueueGenericReceive+0x1a8>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800057a8:	c5 db       	rjmp	80005662 <xQueueGenericReceive+0x22>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800057aa:	ee fc ff ec 	ld.w	r12,r7[-20]
800057ae:	f0 1f 00 0e 	mcall	800057e4 <xQueueGenericReceive+0x1a4>
			( void ) xTaskResumeAll();
800057b2:	f0 1f 00 0e 	mcall	800057e8 <xQueueGenericReceive+0x1a8>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
800057b6:	30 08       	mov	r8,0
		}
	}
}
800057b8:	10 9c       	mov	r12,r8
800057ba:	2f 8d       	sub	sp,-32
800057bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800057c0:	80 00       	ld.sh	r0,r0[0x0]
800057c2:	4f 60       	lddpc	r0,80005998 <prvUnlockQueue+0x60>
800057c4:	80 00       	ld.sh	r0,r0[0x0]
800057c6:	58 cc       	cp.w	r12,12
800057c8:	80 00       	ld.sh	r0,r0[0x0]
800057ca:	61 94       	ld.w	r4,r0[0x64]
800057cc:	80 00       	ld.sh	r0,r0[0x0]
800057ce:	4f 7c       	lddpc	r12,800059a8 <prvUnlockQueue+0x70>
800057d0:	80 00       	ld.sh	r0,r0[0x0]
800057d2:	62 64       	ld.w	r4,r1[0x18]
800057d4:	80 00       	ld.sh	r0,r0[0x0]
800057d6:	5d 90       	*unknown*
800057d8:	80 00       	ld.sh	r0,r0[0x0]
800057da:	62 94       	ld.w	r4,r1[0x24]
800057dc:	80 00       	ld.sh	r0,r0[0x0]
800057de:	5a 08       	cp.w	r8,-32
800057e0:	80 00       	ld.sh	r0,r0[0x0]
800057e2:	61 14       	ld.w	r4,r0[0x44]
800057e4:	80 00       	ld.sh	r0,r0[0x0]
800057e6:	59 38       	cp.w	r8,19
800057e8:	80 00       	ld.sh	r0,r0[0x0]
800057ea:	5d ac       	*unknown*

800057ec <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800057ec:	eb cd 40 80 	pushm	r7,lr
800057f0:	1a 97       	mov	r7,sp
800057f2:	20 3d       	sub	sp,12
800057f4:	ef 4c ff fc 	st.w	r7[-4],r12
800057f8:	ef 4b ff f8 	st.w	r7[-8],r11
800057fc:	ef 4a ff f4 	st.w	r7[-12],r10
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005800:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005804:	71 08       	ld.w	r8,r8[0x40]
80005806:	58 08       	cp.w	r8,0
80005808:	c5 40       	breq	800058b0 <prvCopyDataToQueue+0xc4>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000580a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000580e:	58 08       	cp.w	r8,0
80005810:	c2 61       	brne	8000585c <prvCopyDataToQueue+0x70>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005812:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005816:	71 09       	ld.w	r9,r8[0x40]
80005818:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000581c:	70 28       	ld.w	r8,r8[0x8]
8000581e:	12 9a       	mov	r10,r9
80005820:	ee fb ff f8 	ld.w	r11,r7[-8]
80005824:	10 9c       	mov	r12,r8
80005826:	f0 1f 00 29 	mcall	800058c8 <prvCopyDataToQueue+0xdc>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000582a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000582e:	70 29       	ld.w	r9,r8[0x8]
80005830:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005834:	71 08       	ld.w	r8,r8[0x40]
80005836:	10 09       	add	r9,r8
80005838:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000583c:	91 29       	st.w	r8[0x8],r9
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000583e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005842:	70 29       	ld.w	r9,r8[0x8]
80005844:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005848:	70 18       	ld.w	r8,r8[0x4]
8000584a:	10 39       	cp.w	r9,r8
8000584c:	c3 23       	brcs	800058b0 <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000584e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005852:	70 09       	ld.w	r9,r8[0x0]
80005854:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005858:	91 29       	st.w	r8[0x8],r9
8000585a:	c2 b8       	rjmp	800058b0 <prvCopyDataToQueue+0xc4>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000585c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005860:	71 09       	ld.w	r9,r8[0x40]
80005862:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005866:	70 38       	ld.w	r8,r8[0xc]
80005868:	12 9a       	mov	r10,r9
8000586a:	ee fb ff f8 	ld.w	r11,r7[-8]
8000586e:	10 9c       	mov	r12,r8
80005870:	f0 1f 00 16 	mcall	800058c8 <prvCopyDataToQueue+0xdc>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005874:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005878:	70 39       	ld.w	r9,r8[0xc]
8000587a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000587e:	71 08       	ld.w	r8,r8[0x40]
80005880:	5c 38       	neg	r8
80005882:	10 09       	add	r9,r8
80005884:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005888:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000588a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000588e:	70 39       	ld.w	r9,r8[0xc]
80005890:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005894:	70 08       	ld.w	r8,r8[0x0]
80005896:	10 39       	cp.w	r9,r8
80005898:	c0 c2       	brcc	800058b0 <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8000589a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000589e:	70 19       	ld.w	r9,r8[0x4]
800058a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058a4:	71 08       	ld.w	r8,r8[0x40]
800058a6:	5c 38       	neg	r8
800058a8:	10 09       	add	r9,r8
800058aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058ae:	91 39       	st.w	r8[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800058b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058b4:	70 e8       	ld.w	r8,r8[0x38]
800058b6:	f0 c9 ff ff 	sub	r9,r8,-1
800058ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058be:	91 e9       	st.w	r8[0x38],r9
}
800058c0:	2f dd       	sub	sp,-12
800058c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800058c6:	00 00       	add	r0,r0
800058c8:	80 00       	ld.sh	r0,r0[0x0]
800058ca:	6d 80       	ld.w	r0,r6[0x60]

800058cc <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800058cc:	eb cd 40 80 	pushm	r7,lr
800058d0:	1a 97       	mov	r7,sp
800058d2:	20 2d       	sub	sp,8
800058d4:	ef 4c ff fc 	st.w	r7[-4],r12
800058d8:	ef 4b ff f8 	st.w	r7[-8],r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800058dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058e0:	70 08       	ld.w	r8,r8[0x0]
800058e2:	58 08       	cp.w	r8,0
800058e4:	c2 50       	breq	8000592e <prvCopyDataFromQueue+0x62>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
800058e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058ea:	70 39       	ld.w	r9,r8[0xc]
800058ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058f0:	71 08       	ld.w	r8,r8[0x40]
800058f2:	10 09       	add	r9,r8
800058f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058f8:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
800058fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058fe:	70 39       	ld.w	r9,r8[0xc]
80005900:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005904:	70 18       	ld.w	r8,r8[0x4]
80005906:	10 39       	cp.w	r9,r8
80005908:	c0 73       	brcs	80005916 <prvCopyDataFromQueue+0x4a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000590a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000590e:	70 09       	ld.w	r9,r8[0x0]
80005910:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005914:	91 39       	st.w	r8[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005916:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000591a:	71 09       	ld.w	r9,r8[0x40]
8000591c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005920:	70 38       	ld.w	r8,r8[0xc]
80005922:	12 9a       	mov	r10,r9
80005924:	10 9b       	mov	r11,r8
80005926:	ee fc ff f8 	ld.w	r12,r7[-8]
8000592a:	f0 1f 00 03 	mcall	80005934 <prvCopyDataFromQueue+0x68>
	}
}
8000592e:	2f ed       	sub	sp,-8
80005930:	e3 cd 80 80 	ldm	sp++,r7,pc
80005934:	80 00       	ld.sh	r0,r0[0x0]
80005936:	6d 80       	ld.w	r0,r6[0x60]

80005938 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005938:	eb cd 40 80 	pushm	r7,lr
8000593c:	1a 97       	mov	r7,sp
8000593e:	20 1d       	sub	sp,4
80005940:	ef 4c ff fc 	st.w	r7[-4],r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005944:	f0 1f 00 2d 	mcall	800059f8 <prvUnlockQueue+0xc0>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005948:	c1 a8       	rjmp	8000597c <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000594a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000594e:	70 98       	ld.w	r8,r8[0x24]
80005950:	58 08       	cp.w	r8,0
80005952:	c1 c0       	breq	8000598a <prvUnlockQueue+0x52>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005954:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005958:	2d c8       	sub	r8,-36
8000595a:	10 9c       	mov	r12,r8
8000595c:	f0 1f 00 28 	mcall	800059fc <prvUnlockQueue+0xc4>
80005960:	18 98       	mov	r8,r12
80005962:	58 08       	cp.w	r8,0
80005964:	c0 30       	breq	8000596a <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005966:	f0 1f 00 27 	mcall	80005a00 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xTxLock );
8000596a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000596e:	71 28       	ld.w	r8,r8[0x48]
80005970:	f0 c9 00 01 	sub	r9,r8,1
80005974:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005978:	f1 49 00 48 	st.w	r8[72],r9
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000597c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005980:	71 28       	ld.w	r8,r8[0x48]
80005982:	58 08       	cp.w	r8,0
80005984:	fe 99 ff e3 	brgt	8000594a <prvUnlockQueue+0x12>
80005988:	c0 28       	rjmp	8000598c <prvUnlockQueue+0x54>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
8000598a:	d7 03       	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000598c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005990:	3f f9       	mov	r9,-1
80005992:	f1 49 00 48 	st.w	r8[72],r9
	}
	taskEXIT_CRITICAL();
80005996:	f0 1f 00 1c 	mcall	80005a04 <prvUnlockQueue+0xcc>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
8000599a:	f0 1f 00 18 	mcall	800059f8 <prvUnlockQueue+0xc0>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000599e:	c1 a8       	rjmp	800059d2 <prvUnlockQueue+0x9a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800059a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059a4:	70 48       	ld.w	r8,r8[0x10]
800059a6:	58 08       	cp.w	r8,0
800059a8:	c1 c0       	breq	800059e0 <prvUnlockQueue+0xa8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800059aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059ae:	2f 08       	sub	r8,-16
800059b0:	10 9c       	mov	r12,r8
800059b2:	f0 1f 00 13 	mcall	800059fc <prvUnlockQueue+0xc4>
800059b6:	18 98       	mov	r8,r12
800059b8:	58 08       	cp.w	r8,0
800059ba:	c0 30       	breq	800059c0 <prvUnlockQueue+0x88>
				{
					vTaskMissedYield();
800059bc:	f0 1f 00 11 	mcall	80005a00 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xRxLock );
800059c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059c4:	71 18       	ld.w	r8,r8[0x44]
800059c6:	f0 c9 00 01 	sub	r9,r8,1
800059ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059ce:	f1 49 00 44 	st.w	r8[68],r9
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800059d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059d6:	71 18       	ld.w	r8,r8[0x44]
800059d8:	58 08       	cp.w	r8,0
800059da:	fe 99 ff e3 	brgt	800059a0 <prvUnlockQueue+0x68>
800059de:	c0 28       	rjmp	800059e2 <prvUnlockQueue+0xaa>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
800059e0:	d7 03       	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800059e2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059e6:	3f f9       	mov	r9,-1
800059e8:	f1 49 00 44 	st.w	r8[68],r9
	}
	taskEXIT_CRITICAL();
800059ec:	f0 1f 00 06 	mcall	80005a04 <prvUnlockQueue+0xcc>
}
800059f0:	2f fd       	sub	sp,-4
800059f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800059f6:	00 00       	add	r0,r0
800059f8:	80 00       	ld.sh	r0,r0[0x0]
800059fa:	4f 60       	lddpc	r0,80005bd0 <xTaskGenericCreate+0x14c>
800059fc:	80 00       	ld.sh	r0,r0[0x0]
800059fe:	61 94       	ld.w	r4,r0[0x64]
80005a00:	80 00       	ld.sh	r0,r0[0x0]
80005a02:	63 4c       	ld.w	r12,r1[0x50]
80005a04:	80 00       	ld.sh	r0,r0[0x0]
80005a06:	4f 7c       	lddpc	r12,80005be0 <xTaskGenericCreate+0x15c>

80005a08 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
80005a08:	eb cd 40 80 	pushm	r7,lr
80005a0c:	1a 97       	mov	r7,sp
80005a0e:	20 2d       	sub	sp,8
80005a10:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005a14:	f0 1f 00 09 	mcall	80005a38 <prvIsQueueEmpty+0x30>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005a18:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005a1c:	70 e8       	ld.w	r8,r8[0x38]
80005a1e:	58 08       	cp.w	r8,0
80005a20:	5f 08       	sreq	r8
80005a22:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80005a26:	f0 1f 00 06 	mcall	80005a3c <prvIsQueueEmpty+0x34>

	return xReturn;
80005a2a:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005a2e:	10 9c       	mov	r12,r8
80005a30:	2f ed       	sub	sp,-8
80005a32:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a36:	00 00       	add	r0,r0
80005a38:	80 00       	ld.sh	r0,r0[0x0]
80005a3a:	4f 60       	lddpc	r0,80005c10 <xTaskGenericCreate+0x18c>
80005a3c:	80 00       	ld.sh	r0,r0[0x0]
80005a3e:	4f 7c       	lddpc	r12,80005c18 <xTaskGenericCreate+0x194>

80005a40 <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
80005a40:	eb cd 40 80 	pushm	r7,lr
80005a44:	1a 97       	mov	r7,sp
80005a46:	20 2d       	sub	sp,8
80005a48:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005a4c:	f0 1f 00 0a 	mcall	80005a74 <prvIsQueueFull+0x34>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005a50:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005a54:	70 e9       	ld.w	r9,r8[0x38]
80005a56:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005a5a:	70 f8       	ld.w	r8,r8[0x3c]
80005a5c:	10 39       	cp.w	r9,r8
80005a5e:	5f 08       	sreq	r8
80005a60:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80005a64:	f0 1f 00 05 	mcall	80005a78 <prvIsQueueFull+0x38>

	return xReturn;
80005a68:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005a6c:	10 9c       	mov	r12,r8
80005a6e:	2f ed       	sub	sp,-8
80005a70:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a74:	80 00       	ld.sh	r0,r0[0x0]
80005a76:	4f 60       	lddpc	r0,80005c4c <vTaskDelayUntil>
80005a78:	80 00       	ld.sh	r0,r0[0x0]
80005a7a:	4f 7c       	lddpc	r12,80005c54 <vTaskDelayUntil+0x8>
80005a7c:	49 44       	lddpc	r4,80005acc <xTaskGenericCreate+0x48>
80005a7e:	4c 45       	lddpc	r5,80005b8c <xTaskGenericCreate+0x108>
80005a80:	00 00       	add	r0,r0
	...

80005a84 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005a84:	eb cd 40 c0 	pushm	r6-r7,lr
80005a88:	1a 97       	mov	r7,sp
80005a8a:	20 8d       	sub	sp,32
80005a8c:	ee c6 ff f4 	sub	r6,r7,-12
80005a90:	ef 4c ff f0 	st.w	r7[-16],r12
80005a94:	ef 4b ff ec 	st.w	r7[-20],r11
80005a98:	ef 49 ff e4 	st.w	r7[-28],r9
80005a9c:	ef 48 ff e0 	st.w	r7[-32],r8
80005aa0:	14 98       	mov	r8,r10
80005aa2:	ef 58 ff e8 	st.h	r7[-24],r8
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
80005aa6:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80005aaa:	6c 1b       	ld.w	r11,r6[0x4]
80005aac:	10 9c       	mov	r12,r8
80005aae:	f0 1f 00 5a 	mcall	80005c14 <xTaskGenericCreate+0x190>
80005ab2:	18 98       	mov	r8,r12
80005ab4:	ef 48 ff f8 	st.w	r7[-8],r8

	if( pxNewTCB != NULL )
80005ab8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005abc:	58 08       	cp.w	r8,0
80005abe:	e0 80 00 92 	breq	80005be2 <xTaskGenericCreate+0x15e>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
80005ac2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005ac6:	70 c9       	ld.w	r9,r8[0x30]
80005ac8:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80005acc:	20 18       	sub	r8,1
80005ace:	a3 68       	lsl	r8,0x2
80005ad0:	f2 08 00 08 	add	r8,r9,r8
80005ad4:	ef 48 ff fc 	st.w	r7[-4],r8
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005ad8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005adc:	e0 18 ff fc 	andl	r8,0xfffc
80005ae0:	ef 48 ff fc 	st.w	r7[-4],r8
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
80005ae4:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80005ae8:	6c 29       	ld.w	r9,r6[0x8]
80005aea:	ee fa ff e0 	ld.w	r10,r7[-32]
80005aee:	ee fb ff ec 	ld.w	r11,r7[-20]
80005af2:	ee fc ff f8 	ld.w	r12,r7[-8]
80005af6:	f0 1f 00 49 	mcall	80005c18 <xTaskGenericCreate+0x194>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005afa:	ee fa ff e4 	ld.w	r10,r7[-28]
80005afe:	ee fb ff f0 	ld.w	r11,r7[-16]
80005b02:	ee fc ff fc 	ld.w	r12,r7[-4]
80005b06:	f0 1f 00 46 	mcall	80005c1c <xTaskGenericCreate+0x198>
80005b0a:	18 98       	mov	r8,r12
80005b0c:	10 99       	mov	r9,r8
80005b0e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005b12:	91 09       	st.w	r8[0x0],r9
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
80005b14:	6c 08       	ld.w	r8,r6[0x0]
80005b16:	58 08       	cp.w	r8,0
80005b18:	c0 50       	breq	80005b22 <xTaskGenericCreate+0x9e>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005b1a:	6c 08       	ld.w	r8,r6[0x0]
80005b1c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005b20:	91 09       	st.w	r8[0x0],r9
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005b22:	f0 1f 00 40 	mcall	80005c20 <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
80005b26:	4c 08       	lddpc	r8,80005c24 <xTaskGenericCreate+0x1a0>
80005b28:	70 08       	ld.w	r8,r8[0x0]
80005b2a:	f0 c9 ff ff 	sub	r9,r8,-1
80005b2e:	4b e8       	lddpc	r8,80005c24 <xTaskGenericCreate+0x1a0>
80005b30:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005b32:	4b e8       	lddpc	r8,80005c28 <xTaskGenericCreate+0x1a4>
80005b34:	70 08       	ld.w	r8,r8[0x0]
80005b36:	58 08       	cp.w	r8,0
80005b38:	c0 c1       	brne	80005b50 <xTaskGenericCreate+0xcc>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005b3a:	4b c8       	lddpc	r8,80005c28 <xTaskGenericCreate+0x1a4>
80005b3c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005b40:	91 09       	st.w	r8[0x0],r9

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005b42:	4b 98       	lddpc	r8,80005c24 <xTaskGenericCreate+0x1a0>
80005b44:	70 08       	ld.w	r8,r8[0x0]
80005b46:	58 18       	cp.w	r8,1
80005b48:	c1 41       	brne	80005b70 <xTaskGenericCreate+0xec>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
80005b4a:	f0 1f 00 39 	mcall	80005c2c <xTaskGenericCreate+0x1a8>
80005b4e:	c1 18       	rjmp	80005b70 <xTaskGenericCreate+0xec>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005b50:	4b 88       	lddpc	r8,80005c30 <xTaskGenericCreate+0x1ac>
80005b52:	70 08       	ld.w	r8,r8[0x0]
80005b54:	58 08       	cp.w	r8,0
80005b56:	c0 d1       	brne	80005b70 <xTaskGenericCreate+0xec>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005b58:	4b 48       	lddpc	r8,80005c28 <xTaskGenericCreate+0x1a4>
80005b5a:	70 08       	ld.w	r8,r8[0x0]
80005b5c:	70 b9       	ld.w	r9,r8[0x2c]
80005b5e:	ee f8 ff e0 	ld.w	r8,r7[-32]
80005b62:	10 39       	cp.w	r9,r8
80005b64:	e0 8b 00 06 	brhi	80005b70 <xTaskGenericCreate+0xec>
					{
						pxCurrentTCB = pxNewTCB;
80005b68:	4b 08       	lddpc	r8,80005c28 <xTaskGenericCreate+0x1a4>
80005b6a:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005b6e:	91 09       	st.w	r8[0x0],r9
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005b70:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005b74:	70 b9       	ld.w	r9,r8[0x2c]
80005b76:	4b 08       	lddpc	r8,80005c34 <xTaskGenericCreate+0x1b0>
80005b78:	70 08       	ld.w	r8,r8[0x0]
80005b7a:	10 39       	cp.w	r9,r8
80005b7c:	e0 88 00 07 	brls	80005b8a <xTaskGenericCreate+0x106>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005b80:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005b84:	70 b9       	ld.w	r9,r8[0x2c]
80005b86:	4a c8       	lddpc	r8,80005c34 <xTaskGenericCreate+0x1b0>
80005b88:	91 09       	st.w	r8[0x0],r9
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005b8a:	4a c8       	lddpc	r8,80005c38 <xTaskGenericCreate+0x1b4>
80005b8c:	70 08       	ld.w	r8,r8[0x0]
80005b8e:	f0 c9 ff ff 	sub	r9,r8,-1
80005b92:	4a a8       	lddpc	r8,80005c38 <xTaskGenericCreate+0x1b4>
80005b94:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005b96:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005b9a:	70 b9       	ld.w	r9,r8[0x2c]
80005b9c:	4a 88       	lddpc	r8,80005c3c <xTaskGenericCreate+0x1b8>
80005b9e:	70 08       	ld.w	r8,r8[0x0]
80005ba0:	10 39       	cp.w	r9,r8
80005ba2:	e0 88 00 07 	brls	80005bb0 <xTaskGenericCreate+0x12c>
80005ba6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005baa:	70 b9       	ld.w	r9,r8[0x2c]
80005bac:	4a 48       	lddpc	r8,80005c3c <xTaskGenericCreate+0x1b8>
80005bae:	91 09       	st.w	r8[0x0],r9
80005bb0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005bb4:	f0 ca ff fc 	sub	r10,r8,-4
80005bb8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005bbc:	70 b9       	ld.w	r9,r8[0x2c]
80005bbe:	12 98       	mov	r8,r9
80005bc0:	a3 68       	lsl	r8,0x2
80005bc2:	12 08       	add	r8,r9
80005bc4:	a3 68       	lsl	r8,0x2
80005bc6:	10 99       	mov	r9,r8
80005bc8:	49 e8       	lddpc	r8,80005c40 <xTaskGenericCreate+0x1bc>
80005bca:	f2 08 00 08 	add	r8,r9,r8
80005bce:	14 9b       	mov	r11,r10
80005bd0:	10 9c       	mov	r12,r8
80005bd2:	f0 1f 00 1d 	mcall	80005c44 <xTaskGenericCreate+0x1c0>

			xReturn = pdPASS;
80005bd6:	30 18       	mov	r8,1
80005bd8:	ef 48 ff f4 	st.w	r7[-12],r8
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80005bdc:	f0 1f 00 1b 	mcall	80005c48 <xTaskGenericCreate+0x1c4>
80005be0:	c0 48       	rjmp	80005be8 <xTaskGenericCreate+0x164>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
80005be2:	3f f8       	mov	r8,-1
80005be4:	ef 48 ff f4 	st.w	r7[-12],r8
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
80005be8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005bec:	58 18       	cp.w	r8,1
80005bee:	c0 d1       	brne	80005c08 <xTaskGenericCreate+0x184>
	{
		if( xSchedulerRunning != pdFALSE )
80005bf0:	49 08       	lddpc	r8,80005c30 <xTaskGenericCreate+0x1ac>
80005bf2:	70 08       	ld.w	r8,r8[0x0]
80005bf4:	58 08       	cp.w	r8,0
80005bf6:	c0 90       	breq	80005c08 <xTaskGenericCreate+0x184>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005bf8:	48 c8       	lddpc	r8,80005c28 <xTaskGenericCreate+0x1a4>
80005bfa:	70 08       	ld.w	r8,r8[0x0]
80005bfc:	70 b9       	ld.w	r9,r8[0x2c]
80005bfe:	ee f8 ff e0 	ld.w	r8,r7[-32]
80005c02:	10 39       	cp.w	r9,r8
80005c04:	c0 22       	brcc	80005c08 <xTaskGenericCreate+0x184>
			{
				portYIELD_WITHIN_API();
80005c06:	d7 33       	scall
			}
		}
	}

	return xReturn;
80005c08:	ee f8 ff f4 	ld.w	r8,r7[-12]
}
80005c0c:	10 9c       	mov	r12,r8
80005c0e:	2f 8d       	sub	sp,-32
80005c10:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005c14:	80 00       	ld.sh	r0,r0[0x0]
80005c16:	65 d4       	ld.w	r4,r2[0x74]
80005c18:	80 00       	ld.sh	r0,r0[0x0]
80005c1a:	63 8c       	ld.w	r12,r1[0x60]
80005c1c:	80 00       	ld.sh	r0,r0[0x0]
80005c1e:	4f a8       	lddpc	r8,80005e04 <xTaskResumeAll+0x58>
80005c20:	80 00       	ld.sh	r0,r0[0x0]
80005c22:	4f 60       	lddpc	r0,80005df8 <xTaskResumeAll+0x4c>
80005c24:	00 00       	add	r0,r0
80005c26:	07 74       	ld.ub	r4,--r3
80005c28:	00 00       	add	r0,r0
80005c2a:	06 60       	and	r0,r3
80005c2c:	80 00       	ld.sh	r0,r0[0x0]
80005c2e:	64 28       	ld.w	r8,r2[0x8]
80005c30:	00 00       	add	r0,r0
80005c32:	07 84       	ld.ub	r4,r3[0x0]
80005c34:	00 00       	add	r0,r0
80005c36:	07 7c       	ld.ub	r12,--r3
80005c38:	00 00       	add	r0,r0
80005c3a:	07 98       	ld.ub	r8,r3[0x1]
80005c3c:	00 00       	add	r0,r0
80005c3e:	07 80       	ld.ub	r0,r3[0x0]
80005c40:	00 00       	add	r0,r0
80005c42:	06 64       	and	r4,r3
80005c44:	80 00       	ld.sh	r0,r0[0x0]
80005c46:	4c 36       	lddpc	r6,80005d50 <vTaskStartScheduler+0x24>
80005c48:	80 00       	ld.sh	r0,r0[0x0]
80005c4a:	4f 7c       	lddpc	r12,80005e24 <xTaskResumeAll+0x78>

80005c4c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005c4c:	eb cd 40 80 	pushm	r7,lr
80005c50:	1a 97       	mov	r7,sp
80005c52:	20 5d       	sub	sp,20
80005c54:	ef 4c ff f0 	st.w	r7[-16],r12
80005c58:	ef 4b ff ec 	st.w	r7[-20],r11
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
80005c5c:	30 08       	mov	r8,0
80005c5e:	ef 48 ff fc 	st.w	r7[-4],r8

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005c62:	f0 1f 00 2d 	mcall	80005d14 <vTaskDelayUntil+0xc8>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005c66:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005c6a:	70 09       	ld.w	r9,r8[0x0]
80005c6c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005c70:	f2 08 00 08 	add	r8,r9,r8
80005c74:	ef 48 ff f4 	st.w	r7[-12],r8

			if( xTickCount < *pxPreviousWakeTime )
80005c78:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005c7c:	70 09       	ld.w	r9,r8[0x0]
80005c7e:	4a 78       	lddpc	r8,80005d18 <vTaskDelayUntil+0xcc>
80005c80:	70 08       	ld.w	r8,r8[0x0]
80005c82:	10 39       	cp.w	r9,r8
80005c84:	e0 88 00 15 	brls	80005cae <vTaskDelayUntil+0x62>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005c88:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005c8c:	70 09       	ld.w	r9,r8[0x0]
80005c8e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005c92:	10 39       	cp.w	r9,r8
80005c94:	e0 88 00 1f 	brls	80005cd2 <vTaskDelayUntil+0x86>
80005c98:	4a 08       	lddpc	r8,80005d18 <vTaskDelayUntil+0xcc>
80005c9a:	70 08       	ld.w	r8,r8[0x0]
80005c9c:	ee f9 ff f4 	ld.w	r9,r7[-12]
80005ca0:	10 39       	cp.w	r9,r8
80005ca2:	e0 88 00 18 	brls	80005cd2 <vTaskDelayUntil+0x86>
				{
					xShouldDelay = pdTRUE;
80005ca6:	30 18       	mov	r8,1
80005ca8:	ef 48 ff fc 	st.w	r7[-4],r8
80005cac:	c1 38       	rjmp	80005cd2 <vTaskDelayUntil+0x86>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005cae:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005cb2:	70 09       	ld.w	r9,r8[0x0]
80005cb4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005cb8:	10 39       	cp.w	r9,r8
80005cba:	e0 8b 00 09 	brhi	80005ccc <vTaskDelayUntil+0x80>
80005cbe:	49 78       	lddpc	r8,80005d18 <vTaskDelayUntil+0xcc>
80005cc0:	70 08       	ld.w	r8,r8[0x0]
80005cc2:	ee f9 ff f4 	ld.w	r9,r7[-12]
80005cc6:	10 39       	cp.w	r9,r8
80005cc8:	e0 88 00 05 	brls	80005cd2 <vTaskDelayUntil+0x86>
				{
					xShouldDelay = pdTRUE;
80005ccc:	30 18       	mov	r8,1
80005cce:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005cd2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005cd6:	ee f9 ff f4 	ld.w	r9,r7[-12]
80005cda:	91 09       	st.w	r8[0x0],r9

			if( xShouldDelay != pdFALSE )
80005cdc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005ce0:	58 08       	cp.w	r8,0
80005ce2:	c0 b0       	breq	80005cf8 <vTaskDelayUntil+0xac>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005ce4:	48 e8       	lddpc	r8,80005d1c <vTaskDelayUntil+0xd0>
80005ce6:	70 08       	ld.w	r8,r8[0x0]
80005ce8:	2f c8       	sub	r8,-4
80005cea:	10 9c       	mov	r12,r8
80005cec:	f0 1f 00 0d 	mcall	80005d20 <vTaskDelayUntil+0xd4>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005cf0:	ee fc ff f4 	ld.w	r12,r7[-12]
80005cf4:	f0 1f 00 0c 	mcall	80005d24 <vTaskDelayUntil+0xd8>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005cf8:	f0 1f 00 0c 	mcall	80005d28 <vTaskDelayUntil+0xdc>
80005cfc:	18 98       	mov	r8,r12
80005cfe:	ef 48 ff f8 	st.w	r7[-8],r8

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005d02:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d06:	58 08       	cp.w	r8,0
80005d08:	c0 21       	brne	80005d0c <vTaskDelayUntil+0xc0>
		{
			portYIELD_WITHIN_API();
80005d0a:	d7 33       	scall
		}
	}
80005d0c:	2f bd       	sub	sp,-20
80005d0e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d12:	00 00       	add	r0,r0
80005d14:	80 00       	ld.sh	r0,r0[0x0]
80005d16:	5d 90       	*unknown*
80005d18:	00 00       	add	r0,r0
80005d1a:	07 78       	ld.ub	r8,--r3
80005d1c:	00 00       	add	r0,r0
80005d1e:	06 60       	and	r0,r3
80005d20:	80 00       	ld.sh	r0,r0[0x0]
80005d22:	4d 4a       	lddpc	r10,80005e70 <xTaskResumeAll+0xc4>
80005d24:	80 00       	ld.sh	r0,r0[0x0]
80005d26:	65 54       	ld.w	r4,r2[0x54]
80005d28:	80 00       	ld.sh	r0,r0[0x0]
80005d2a:	5d ac       	*unknown*

80005d2c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005d2c:	eb cd 40 80 	pushm	r7,lr
80005d30:	1a 97       	mov	r7,sp
80005d32:	20 1d       	sub	sp,4
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005d34:	49 1b       	lddpc	r11,80005d78 <vTaskStartScheduler+0x4c>
80005d36:	30 08       	mov	r8,0
80005d38:	1a d8       	st.w	--sp,r8
80005d3a:	30 08       	mov	r8,0
80005d3c:	1a d8       	st.w	--sp,r8
80005d3e:	30 08       	mov	r8,0
80005d40:	1a d8       	st.w	--sp,r8
80005d42:	30 08       	mov	r8,0
80005d44:	30 09       	mov	r9,0
80005d46:	e0 6a 01 00 	mov	r10,256
80005d4a:	48 dc       	lddpc	r12,80005d7c <vTaskStartScheduler+0x50>
80005d4c:	f0 1f 00 0d 	mcall	80005d80 <vTaskStartScheduler+0x54>
80005d50:	2f dd       	sub	sp,-12
80005d52:	18 98       	mov	r8,r12
80005d54:	ef 48 ff fc 	st.w	r7[-4],r8
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005d58:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005d5c:	58 18       	cp.w	r8,1
80005d5e:	c0 a1       	brne	80005d72 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005d60:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005d62:	48 98       	lddpc	r8,80005d84 <vTaskStartScheduler+0x58>
80005d64:	30 19       	mov	r9,1
80005d66:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005d68:	48 88       	lddpc	r8,80005d88 <vTaskStartScheduler+0x5c>
80005d6a:	30 09       	mov	r9,0
80005d6c:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005d6e:	f0 1f 00 08 	mcall	80005d8c <vTaskStartScheduler+0x60>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
80005d72:	2f fd       	sub	sp,-4
80005d74:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d78:	80 00       	ld.sh	r0,r0[0x0]
80005d7a:	5a 7c       	cp.w	r12,-25
80005d7c:	80 00       	ld.sh	r0,r0[0x0]
80005d7e:	63 60       	ld.w	r0,r1[0x58]
80005d80:	80 00       	ld.sh	r0,r0[0x0]
80005d82:	5a 84       	cp.w	r4,-24
80005d84:	00 00       	add	r0,r0
80005d86:	07 84       	ld.ub	r4,r3[0x0]
80005d88:	00 00       	add	r0,r0
80005d8a:	07 78       	ld.ub	r8,--r3
80005d8c:	80 00       	ld.sh	r0,r0[0x0]
80005d8e:	51 50       	stdsp	sp[0x54],r0

80005d90 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
80005d90:	eb cd 40 80 	pushm	r7,lr
80005d94:	1a 97       	mov	r7,sp
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005d96:	48 58       	lddpc	r8,80005da8 <vTaskSuspendAll+0x18>
80005d98:	70 08       	ld.w	r8,r8[0x0]
80005d9a:	f0 c9 ff ff 	sub	r9,r8,-1
80005d9e:	48 38       	lddpc	r8,80005da8 <vTaskSuspendAll+0x18>
80005da0:	91 09       	st.w	r8[0x0],r9
}
80005da2:	e3 cd 80 80 	ldm	sp++,r7,pc
80005da6:	00 00       	add	r0,r0
80005da8:	00 00       	add	r0,r0
80005daa:	07 88       	ld.ub	r8,r3[0x0]

80005dac <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005dac:	eb cd 40 c0 	pushm	r6-r7,lr
80005db0:	1a 97       	mov	r7,sp
80005db2:	20 2d       	sub	sp,8
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
80005db4:	30 08       	mov	r8,0
80005db6:	ef 48 ff f8 	st.w	r7[-8],r8
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005dba:	f0 1f 00 3a 	mcall	80005ea0 <xTaskResumeAll+0xf4>
	{
		--uxSchedulerSuspended;
80005dbe:	4b a8       	lddpc	r8,80005ea4 <xTaskResumeAll+0xf8>
80005dc0:	70 08       	ld.w	r8,r8[0x0]
80005dc2:	f0 c9 00 01 	sub	r9,r8,1
80005dc6:	4b 88       	lddpc	r8,80005ea4 <xTaskResumeAll+0xf8>
80005dc8:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005dca:	4b 78       	lddpc	r8,80005ea4 <xTaskResumeAll+0xf8>
80005dcc:	70 08       	ld.w	r8,r8[0x0]
80005dce:	58 08       	cp.w	r8,0
80005dd0:	c5 f1       	brne	80005e8e <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005dd2:	4b 68       	lddpc	r8,80005ea8 <xTaskResumeAll+0xfc>
80005dd4:	70 08       	ld.w	r8,r8[0x0]
80005dd6:	58 08       	cp.w	r8,0
80005dd8:	c5 b0       	breq	80005e8e <xTaskResumeAll+0xe2>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
80005dda:	30 08       	mov	r8,0
80005ddc:	ef 48 ff fc 	st.w	r7[-4],r8

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005de0:	c3 08       	rjmp	80005e40 <xTaskResumeAll+0x94>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005de2:	4b 38       	lddpc	r8,80005eac <xTaskResumeAll+0x100>
80005de4:	70 38       	ld.w	r8,r8[0xc]
80005de6:	70 38       	ld.w	r8,r8[0xc]
80005de8:	10 96       	mov	r6,r8
					vListRemove( &( pxTCB->xEventListItem ) );
80005dea:	ec c8 ff e8 	sub	r8,r6,-24
80005dee:	10 9c       	mov	r12,r8
80005df0:	f0 1f 00 30 	mcall	80005eb0 <xTaskResumeAll+0x104>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005df4:	ec c8 ff fc 	sub	r8,r6,-4
80005df8:	10 9c       	mov	r12,r8
80005dfa:	f0 1f 00 2e 	mcall	80005eb0 <xTaskResumeAll+0x104>
					prvAddTaskToReadyQueue( pxTCB );
80005dfe:	6c b9       	ld.w	r9,r6[0x2c]
80005e00:	4a d8       	lddpc	r8,80005eb4 <xTaskResumeAll+0x108>
80005e02:	70 08       	ld.w	r8,r8[0x0]
80005e04:	10 39       	cp.w	r9,r8
80005e06:	e0 88 00 05 	brls	80005e10 <xTaskResumeAll+0x64>
80005e0a:	6c b9       	ld.w	r9,r6[0x2c]
80005e0c:	4a a8       	lddpc	r8,80005eb4 <xTaskResumeAll+0x108>
80005e0e:	91 09       	st.w	r8[0x0],r9
80005e10:	ec ca ff fc 	sub	r10,r6,-4
80005e14:	6c b9       	ld.w	r9,r6[0x2c]
80005e16:	12 98       	mov	r8,r9
80005e18:	a3 68       	lsl	r8,0x2
80005e1a:	12 08       	add	r8,r9
80005e1c:	a3 68       	lsl	r8,0x2
80005e1e:	10 99       	mov	r9,r8
80005e20:	4a 68       	lddpc	r8,80005eb8 <xTaskResumeAll+0x10c>
80005e22:	f2 08 00 08 	add	r8,r9,r8
80005e26:	14 9b       	mov	r11,r10
80005e28:	10 9c       	mov	r12,r8
80005e2a:	f0 1f 00 25 	mcall	80005ebc <xTaskResumeAll+0x110>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005e2e:	6c b9       	ld.w	r9,r6[0x2c]
80005e30:	4a 48       	lddpc	r8,80005ec0 <xTaskResumeAll+0x114>
80005e32:	70 08       	ld.w	r8,r8[0x0]
80005e34:	70 b8       	ld.w	r8,r8[0x2c]
80005e36:	10 39       	cp.w	r9,r8
80005e38:	c0 43       	brcs	80005e40 <xTaskResumeAll+0x94>
					{
						xYieldRequired = pdTRUE;
80005e3a:	30 18       	mov	r8,1
80005e3c:	ef 48 ff fc 	st.w	r7[-4],r8
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005e40:	49 b8       	lddpc	r8,80005eac <xTaskResumeAll+0x100>
80005e42:	70 08       	ld.w	r8,r8[0x0]
80005e44:	58 08       	cp.w	r8,0
80005e46:	cc e1       	brne	80005de2 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005e48:	49 f8       	lddpc	r8,80005ec4 <xTaskResumeAll+0x118>
80005e4a:	70 08       	ld.w	r8,r8[0x0]
80005e4c:	58 08       	cp.w	r8,0
80005e4e:	c1 10       	breq	80005e70 <xTaskResumeAll+0xc4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005e50:	c0 98       	rjmp	80005e62 <xTaskResumeAll+0xb6>
					{
						vTaskIncrementTick();
80005e52:	f0 1f 00 1e 	mcall	80005ec8 <xTaskResumeAll+0x11c>
						--uxMissedTicks;
80005e56:	49 c8       	lddpc	r8,80005ec4 <xTaskResumeAll+0x118>
80005e58:	70 08       	ld.w	r8,r8[0x0]
80005e5a:	f0 c9 00 01 	sub	r9,r8,1
80005e5e:	49 a8       	lddpc	r8,80005ec4 <xTaskResumeAll+0x118>
80005e60:	91 09       	st.w	r8[0x0],r9
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005e62:	49 98       	lddpc	r8,80005ec4 <xTaskResumeAll+0x118>
80005e64:	70 08       	ld.w	r8,r8[0x0]
80005e66:	58 08       	cp.w	r8,0
80005e68:	cf 51       	brne	80005e52 <xTaskResumeAll+0xa6>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
80005e6a:	30 18       	mov	r8,1
80005e6c:	ef 48 ff fc 	st.w	r7[-4],r8
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005e70:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005e74:	58 18       	cp.w	r8,1
80005e76:	c0 50       	breq	80005e80 <xTaskResumeAll+0xd4>
80005e78:	49 58       	lddpc	r8,80005ecc <xTaskResumeAll+0x120>
80005e7a:	70 08       	ld.w	r8,r8[0x0]
80005e7c:	58 18       	cp.w	r8,1
80005e7e:	c0 81       	brne	80005e8e <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
80005e80:	30 18       	mov	r8,1
80005e82:	ef 48 ff f8 	st.w	r7[-8],r8
					xMissedYield = pdFALSE;
80005e86:	49 28       	lddpc	r8,80005ecc <xTaskResumeAll+0x120>
80005e88:	30 09       	mov	r9,0
80005e8a:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005e8c:	d7 33       	scall
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005e8e:	f0 1f 00 11 	mcall	80005ed0 <xTaskResumeAll+0x124>

	return xAlreadyYielded;
80005e92:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80005e96:	10 9c       	mov	r12,r8
80005e98:	2f ed       	sub	sp,-8
80005e9a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e9e:	00 00       	add	r0,r0
80005ea0:	80 00       	ld.sh	r0,r0[0x0]
80005ea2:	4f 60       	lddpc	r0,80006078 <vTaskSwitchContext+0x14>
80005ea4:	00 00       	add	r0,r0
80005ea6:	07 88       	ld.ub	r8,r3[0x0]
80005ea8:	00 00       	add	r0,r0
80005eaa:	07 74       	ld.ub	r4,--r3
80005eac:	00 00       	add	r0,r0
80005eae:	07 34       	ld.ub	r4,r3++
80005eb0:	80 00       	ld.sh	r0,r0[0x0]
80005eb2:	4d 4a       	lddpc	r10,80006000 <vTaskIncrementTick+0xfc>
80005eb4:	00 00       	add	r0,r0
80005eb6:	07 80       	ld.ub	r0,r3[0x0]
80005eb8:	00 00       	add	r0,r0
80005eba:	06 64       	and	r4,r3
80005ebc:	80 00       	ld.sh	r0,r0[0x0]
80005ebe:	4c 36       	lddpc	r6,80005fc8 <vTaskIncrementTick+0xc4>
80005ec0:	00 00       	add	r0,r0
80005ec2:	06 60       	and	r0,r3
80005ec4:	00 00       	add	r0,r0
80005ec6:	07 8c       	ld.ub	r12,r3[0x0]
80005ec8:	80 00       	ld.sh	r0,r0[0x0]
80005eca:	5f 04       	sreq	r4
80005ecc:	00 00       	add	r0,r0
80005ece:	07 90       	ld.ub	r0,r3[0x1]
80005ed0:	80 00       	ld.sh	r0,r0[0x0]
80005ed2:	4f 7c       	lddpc	r12,800060ac <vTaskSwitchContext+0x48>

80005ed4 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005ed4:	eb cd 40 80 	pushm	r7,lr
80005ed8:	1a 97       	mov	r7,sp
80005eda:	20 1d       	sub	sp,4
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005edc:	f0 1f 00 07 	mcall	80005ef8 <xTaskGetTickCount+0x24>
	{
		xTicks = xTickCount;
80005ee0:	48 78       	lddpc	r8,80005efc <xTaskGetTickCount+0x28>
80005ee2:	70 08       	ld.w	r8,r8[0x0]
80005ee4:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	taskEXIT_CRITICAL();
80005ee8:	f0 1f 00 06 	mcall	80005f00 <xTaskGetTickCount+0x2c>

	return xTicks;
80005eec:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005ef0:	10 9c       	mov	r12,r8
80005ef2:	2f fd       	sub	sp,-4
80005ef4:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ef8:	80 00       	ld.sh	r0,r0[0x0]
80005efa:	4f 60       	lddpc	r0,800060d0 <vTaskSwitchContext+0x6c>
80005efc:	00 00       	add	r0,r0
80005efe:	07 78       	ld.ub	r8,--r3
80005f00:	80 00       	ld.sh	r0,r0[0x0]
80005f02:	4f 7c       	lddpc	r12,800060dc <vTaskSwitchContext+0x78>

80005f04 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005f04:	eb cd 40 80 	pushm	r7,lr
80005f08:	1a 97       	mov	r7,sp
80005f0a:	20 3d       	sub	sp,12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005f0c:	4c b8       	lddpc	r8,80006038 <vTaskIncrementTick+0x134>
80005f0e:	70 08       	ld.w	r8,r8[0x0]
80005f10:	58 08       	cp.w	r8,0
80005f12:	e0 81 00 89 	brne	80006024 <vTaskIncrementTick+0x120>
	{
		++xTickCount;
80005f16:	4c a8       	lddpc	r8,8000603c <vTaskIncrementTick+0x138>
80005f18:	70 08       	ld.w	r8,r8[0x0]
80005f1a:	f0 c9 ff ff 	sub	r9,r8,-1
80005f1e:	4c 88       	lddpc	r8,8000603c <vTaskIncrementTick+0x138>
80005f20:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005f22:	4c 78       	lddpc	r8,8000603c <vTaskIncrementTick+0x138>
80005f24:	70 08       	ld.w	r8,r8[0x0]
80005f26:	58 08       	cp.w	r8,0
80005f28:	c2 71       	brne	80005f76 <vTaskIncrementTick+0x72>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005f2a:	4c 68       	lddpc	r8,80006040 <vTaskIncrementTick+0x13c>
80005f2c:	70 08       	ld.w	r8,r8[0x0]
80005f2e:	ef 48 ff f8 	st.w	r7[-8],r8
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005f32:	4c 58       	lddpc	r8,80006044 <vTaskIncrementTick+0x140>
80005f34:	70 09       	ld.w	r9,r8[0x0]
80005f36:	4c 38       	lddpc	r8,80006040 <vTaskIncrementTick+0x13c>
80005f38:	91 09       	st.w	r8[0x0],r9
			pxOverflowDelayedTaskList = pxTemp;
80005f3a:	4c 38       	lddpc	r8,80006044 <vTaskIncrementTick+0x140>
80005f3c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005f40:	91 09       	st.w	r8[0x0],r9
			xNumOfOverflows++;
80005f42:	4c 28       	lddpc	r8,80006048 <vTaskIncrementTick+0x144>
80005f44:	70 08       	ld.w	r8,r8[0x0]
80005f46:	f0 c9 ff ff 	sub	r9,r8,-1
80005f4a:	4c 08       	lddpc	r8,80006048 <vTaskIncrementTick+0x144>
80005f4c:	91 09       	st.w	r8[0x0],r9

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005f4e:	4b d8       	lddpc	r8,80006040 <vTaskIncrementTick+0x13c>
80005f50:	70 08       	ld.w	r8,r8[0x0]
80005f52:	70 08       	ld.w	r8,r8[0x0]
80005f54:	58 08       	cp.w	r8,0
80005f56:	c0 51       	brne	80005f60 <vTaskIncrementTick+0x5c>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005f58:	4b d8       	lddpc	r8,8000604c <vTaskIncrementTick+0x148>
80005f5a:	3f f9       	mov	r9,-1
80005f5c:	91 09       	st.w	r8[0x0],r9
80005f5e:	c0 c8       	rjmp	80005f76 <vTaskIncrementTick+0x72>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005f60:	4b 88       	lddpc	r8,80006040 <vTaskIncrementTick+0x13c>
80005f62:	70 08       	ld.w	r8,r8[0x0]
80005f64:	70 38       	ld.w	r8,r8[0xc]
80005f66:	70 38       	ld.w	r8,r8[0xc]
80005f68:	ef 48 ff f4 	st.w	r7[-12],r8
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005f6c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005f70:	70 19       	ld.w	r9,r8[0x4]
80005f72:	4b 78       	lddpc	r8,8000604c <vTaskIncrementTick+0x148>
80005f74:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005f76:	4b 28       	lddpc	r8,8000603c <vTaskIncrementTick+0x138>
80005f78:	70 09       	ld.w	r9,r8[0x0]
80005f7a:	4b 58       	lddpc	r8,8000604c <vTaskIncrementTick+0x148>
80005f7c:	70 08       	ld.w	r8,r8[0x0]
80005f7e:	10 39       	cp.w	r9,r8
80005f80:	c5 83       	brcs	80006030 <vTaskIncrementTick+0x12c>
80005f82:	4b 08       	lddpc	r8,80006040 <vTaskIncrementTick+0x13c>
80005f84:	70 08       	ld.w	r8,r8[0x0]
80005f86:	70 08       	ld.w	r8,r8[0x0]
80005f88:	58 08       	cp.w	r8,0
80005f8a:	c0 51       	brne	80005f94 <vTaskIncrementTick+0x90>
80005f8c:	4b 08       	lddpc	r8,8000604c <vTaskIncrementTick+0x148>
80005f8e:	3f f9       	mov	r9,-1
80005f90:	91 09       	st.w	r8[0x0],r9
80005f92:	c4 f8       	rjmp	80006030 <vTaskIncrementTick+0x12c>
80005f94:	4a b8       	lddpc	r8,80006040 <vTaskIncrementTick+0x13c>
80005f96:	70 08       	ld.w	r8,r8[0x0]
80005f98:	70 38       	ld.w	r8,r8[0xc]
80005f9a:	70 38       	ld.w	r8,r8[0xc]
80005f9c:	ef 48 ff f4 	st.w	r7[-12],r8
80005fa0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005fa4:	70 18       	ld.w	r8,r8[0x4]
80005fa6:	ef 48 ff fc 	st.w	r7[-4],r8
80005faa:	4a 58       	lddpc	r8,8000603c <vTaskIncrementTick+0x138>
80005fac:	70 09       	ld.w	r9,r8[0x0]
80005fae:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005fb2:	10 39       	cp.w	r9,r8
80005fb4:	c0 62       	brcc	80005fc0 <vTaskIncrementTick+0xbc>
80005fb6:	4a 68       	lddpc	r8,8000604c <vTaskIncrementTick+0x148>
80005fb8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005fbc:	91 09       	st.w	r8[0x0],r9
80005fbe:	c3 98       	rjmp	80006030 <vTaskIncrementTick+0x12c>
80005fc0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005fc4:	2f c8       	sub	r8,-4
80005fc6:	10 9c       	mov	r12,r8
80005fc8:	f0 1f 00 22 	mcall	80006050 <vTaskIncrementTick+0x14c>
80005fcc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005fd0:	70 a8       	ld.w	r8,r8[0x28]
80005fd2:	58 08       	cp.w	r8,0
80005fd4:	c0 70       	breq	80005fe2 <vTaskIncrementTick+0xde>
80005fd6:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005fda:	2e 88       	sub	r8,-24
80005fdc:	10 9c       	mov	r12,r8
80005fde:	f0 1f 00 1d 	mcall	80006050 <vTaskIncrementTick+0x14c>
80005fe2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005fe6:	70 b9       	ld.w	r9,r8[0x2c]
80005fe8:	49 b8       	lddpc	r8,80006054 <vTaskIncrementTick+0x150>
80005fea:	70 08       	ld.w	r8,r8[0x0]
80005fec:	10 39       	cp.w	r9,r8
80005fee:	e0 88 00 07 	brls	80005ffc <vTaskIncrementTick+0xf8>
80005ff2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005ff6:	70 b9       	ld.w	r9,r8[0x2c]
80005ff8:	49 78       	lddpc	r8,80006054 <vTaskIncrementTick+0x150>
80005ffa:	91 09       	st.w	r8[0x0],r9
80005ffc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006000:	f0 ca ff fc 	sub	r10,r8,-4
80006004:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006008:	70 b9       	ld.w	r9,r8[0x2c]
8000600a:	12 98       	mov	r8,r9
8000600c:	a3 68       	lsl	r8,0x2
8000600e:	12 08       	add	r8,r9
80006010:	a3 68       	lsl	r8,0x2
80006012:	10 99       	mov	r9,r8
80006014:	49 18       	lddpc	r8,80006058 <vTaskIncrementTick+0x154>
80006016:	f2 08 00 08 	add	r8,r9,r8
8000601a:	14 9b       	mov	r11,r10
8000601c:	10 9c       	mov	r12,r8
8000601e:	f0 1f 00 10 	mcall	8000605c <vTaskIncrementTick+0x158>
80006022:	cb 0b       	rjmp	80005f82 <vTaskIncrementTick+0x7e>
	}
	else
	{
		++uxMissedTicks;
80006024:	48 f8       	lddpc	r8,80006060 <vTaskIncrementTick+0x15c>
80006026:	70 08       	ld.w	r8,r8[0x0]
80006028:	f0 c9 ff ff 	sub	r9,r8,-1
8000602c:	48 d8       	lddpc	r8,80006060 <vTaskIncrementTick+0x15c>
8000602e:	91 09       	st.w	r8[0x0],r9
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
80006030:	2f dd       	sub	sp,-12
80006032:	e3 cd 80 80 	ldm	sp++,r7,pc
80006036:	00 00       	add	r0,r0
80006038:	00 00       	add	r0,r0
8000603a:	07 88       	ld.ub	r8,r3[0x0]
8000603c:	00 00       	add	r0,r0
8000603e:	07 78       	ld.ub	r8,--r3
80006040:	00 00       	add	r0,r0
80006042:	07 2c       	ld.uh	r12,r3++
80006044:	00 00       	add	r0,r0
80006046:	07 30       	ld.ub	r0,r3++
80006048:	00 00       	add	r0,r0
8000604a:	07 94       	ld.ub	r4,r3[0x1]
8000604c:	00 00       	add	r0,r0
8000604e:	00 24       	rsub	r4,r0
80006050:	80 00       	ld.sh	r0,r0[0x0]
80006052:	4d 4a       	lddpc	r10,800061a0 <xTaskRemoveFromEventList+0xc>
80006054:	00 00       	add	r0,r0
80006056:	07 80       	ld.ub	r0,r3[0x0]
80006058:	00 00       	add	r0,r0
8000605a:	06 64       	and	r4,r3
8000605c:	80 00       	ld.sh	r0,r0[0x0]
8000605e:	4c 36       	lddpc	r6,80006168 <vTaskPlaceOnEventList+0x54>
80006060:	00 00       	add	r0,r0
80006062:	07 8c       	ld.ub	r12,r3[0x0]

80006064 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
80006064:	eb cd 40 80 	pushm	r7,lr
80006068:	1a 97       	mov	r7,sp
8000606a:	20 1d       	sub	sp,4
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
8000606c:	4a 58       	lddpc	r8,80006100 <vTaskSwitchContext+0x9c>
8000606e:	70 08       	ld.w	r8,r8[0x0]
80006070:	58 08       	cp.w	r8,0
80006072:	c0 c0       	breq	8000608a <vTaskSwitchContext+0x26>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006074:	4a 48       	lddpc	r8,80006104 <vTaskSwitchContext+0xa0>
80006076:	30 19       	mov	r9,1
80006078:	91 09       	st.w	r8[0x0],r9
8000607a:	c3 f8       	rjmp	800060f8 <vTaskSwitchContext+0x94>

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000607c:	4a 38       	lddpc	r8,80006108 <vTaskSwitchContext+0xa4>
8000607e:	70 08       	ld.w	r8,r8[0x0]
80006080:	f0 c9 00 01 	sub	r9,r8,1
80006084:	4a 18       	lddpc	r8,80006108 <vTaskSwitchContext+0xa4>
80006086:	91 09       	st.w	r8[0x0],r9
80006088:	c0 28       	rjmp	8000608c <vTaskSwitchContext+0x28>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000608a:	d7 03       	nop
8000608c:	49 f8       	lddpc	r8,80006108 <vTaskSwitchContext+0xa4>
8000608e:	70 09       	ld.w	r9,r8[0x0]
80006090:	12 98       	mov	r8,r9
80006092:	a3 68       	lsl	r8,0x2
80006094:	12 08       	add	r8,r9
80006096:	a3 68       	lsl	r8,0x2
80006098:	10 99       	mov	r9,r8
8000609a:	49 d8       	lddpc	r8,8000610c <vTaskSwitchContext+0xa8>
8000609c:	f2 08 00 08 	add	r8,r9,r8
800060a0:	70 08       	ld.w	r8,r8[0x0]
800060a2:	58 08       	cp.w	r8,0
800060a4:	ce c0       	breq	8000607c <vTaskSwitchContext+0x18>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800060a6:	49 98       	lddpc	r8,80006108 <vTaskSwitchContext+0xa4>
800060a8:	70 09       	ld.w	r9,r8[0x0]
800060aa:	12 98       	mov	r8,r9
800060ac:	a3 68       	lsl	r8,0x2
800060ae:	12 08       	add	r8,r9
800060b0:	a3 68       	lsl	r8,0x2
800060b2:	10 99       	mov	r9,r8
800060b4:	49 68       	lddpc	r8,8000610c <vTaskSwitchContext+0xa8>
800060b6:	f2 08 00 08 	add	r8,r9,r8
800060ba:	ef 48 ff fc 	st.w	r7[-4],r8
800060be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800060c2:	70 18       	ld.w	r8,r8[0x4]
800060c4:	70 19       	ld.w	r9,r8[0x4]
800060c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800060ca:	91 19       	st.w	r8[0x4],r9
800060cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800060d0:	70 19       	ld.w	r9,r8[0x4]
800060d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800060d6:	2f 88       	sub	r8,-8
800060d8:	10 39       	cp.w	r9,r8
800060da:	c0 81       	brne	800060ea <vTaskSwitchContext+0x86>
800060dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800060e0:	70 18       	ld.w	r8,r8[0x4]
800060e2:	70 19       	ld.w	r9,r8[0x4]
800060e4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800060e8:	91 19       	st.w	r8[0x4],r9
800060ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800060ee:	70 18       	ld.w	r8,r8[0x4]
800060f0:	70 38       	ld.w	r8,r8[0xc]
800060f2:	10 99       	mov	r9,r8
800060f4:	48 78       	lddpc	r8,80006110 <vTaskSwitchContext+0xac>
800060f6:	91 09       	st.w	r8[0x0],r9

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
800060f8:	2f fd       	sub	sp,-4
800060fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800060fe:	00 00       	add	r0,r0
80006100:	00 00       	add	r0,r0
80006102:	07 88       	ld.ub	r8,r3[0x0]
80006104:	00 00       	add	r0,r0
80006106:	07 90       	ld.ub	r0,r3[0x1]
80006108:	00 00       	add	r0,r0
8000610a:	07 80       	ld.ub	r0,r3[0x0]
8000610c:	00 00       	add	r0,r0
8000610e:	06 64       	and	r4,r3
80006110:	00 00       	add	r0,r0
80006112:	06 60       	and	r0,r3

80006114 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006114:	eb cd 40 80 	pushm	r7,lr
80006118:	1a 97       	mov	r7,sp
8000611a:	20 3d       	sub	sp,12
8000611c:	ef 4c ff f8 	st.w	r7[-8],r12
80006120:	ef 4b ff f4 	st.w	r7[-12],r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006124:	49 58       	lddpc	r8,80006178 <vTaskPlaceOnEventList+0x64>
80006126:	70 08       	ld.w	r8,r8[0x0]
80006128:	2e 88       	sub	r8,-24
8000612a:	10 9b       	mov	r11,r8
8000612c:	ee fc ff f8 	ld.w	r12,r7[-8]
80006130:	f0 1f 00 13 	mcall	8000617c <vTaskPlaceOnEventList+0x68>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006134:	49 18       	lddpc	r8,80006178 <vTaskPlaceOnEventList+0x64>
80006136:	70 08       	ld.w	r8,r8[0x0]
80006138:	2f c8       	sub	r8,-4
8000613a:	10 9c       	mov	r12,r8
8000613c:	f0 1f 00 11 	mcall	80006180 <vTaskPlaceOnEventList+0x6c>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006140:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006144:	5b f8       	cp.w	r8,-1
80006146:	c0 91       	brne	80006158 <vTaskPlaceOnEventList+0x44>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006148:	48 c8       	lddpc	r8,80006178 <vTaskPlaceOnEventList+0x64>
8000614a:	70 08       	ld.w	r8,r8[0x0]
8000614c:	2f c8       	sub	r8,-4
8000614e:	10 9b       	mov	r11,r8
80006150:	48 dc       	lddpc	r12,80006184 <vTaskPlaceOnEventList+0x70>
80006152:	f0 1f 00 0e 	mcall	80006188 <vTaskPlaceOnEventList+0x74>
80006156:	c0 d8       	rjmp	80006170 <vTaskPlaceOnEventList+0x5c>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006158:	48 d8       	lddpc	r8,8000618c <vTaskPlaceOnEventList+0x78>
8000615a:	70 09       	ld.w	r9,r8[0x0]
8000615c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006160:	f2 08 00 08 	add	r8,r9,r8
80006164:	ef 48 ff fc 	st.w	r7[-4],r8
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006168:	ee fc ff fc 	ld.w	r12,r7[-4]
8000616c:	f0 1f 00 09 	mcall	80006190 <vTaskPlaceOnEventList+0x7c>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
80006170:	2f dd       	sub	sp,-12
80006172:	e3 cd 80 80 	ldm	sp++,r7,pc
80006176:	00 00       	add	r0,r0
80006178:	00 00       	add	r0,r0
8000617a:	06 60       	and	r0,r3
8000617c:	80 00       	ld.sh	r0,r0[0x0]
8000617e:	4c a8       	lddpc	r8,800062a4 <xTaskCheckForTimeOut+0x10>
80006180:	80 00       	ld.sh	r0,r0[0x0]
80006182:	4d 4a       	lddpc	r10,800062d0 <xTaskCheckForTimeOut+0x3c>
80006184:	00 00       	add	r0,r0
80006186:	07 60       	ld.uh	r0,--r3
80006188:	80 00       	ld.sh	r0,r0[0x0]
8000618a:	4c 36       	lddpc	r6,80006294 <xTaskCheckForTimeOut>
8000618c:	00 00       	add	r0,r0
8000618e:	07 78       	ld.ub	r8,--r3
80006190:	80 00       	ld.sh	r0,r0[0x0]
80006192:	65 54       	ld.w	r4,r2[0x54]

80006194 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006194:	eb cd 40 80 	pushm	r7,lr
80006198:	1a 97       	mov	r7,sp
8000619a:	20 3d       	sub	sp,12
8000619c:	ef 4c ff f4 	st.w	r7[-12],r12
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800061a0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800061a4:	70 38       	ld.w	r8,r8[0xc]
800061a6:	70 38       	ld.w	r8,r8[0xc]
800061a8:	ef 48 ff f8 	st.w	r7[-8],r8
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800061ac:	ee f8 ff f8 	ld.w	r8,r7[-8]
800061b0:	2e 88       	sub	r8,-24
800061b2:	10 9c       	mov	r12,r8
800061b4:	f0 1f 00 25 	mcall	80006248 <xTaskRemoveFromEventList+0xb4>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800061b8:	4a 58       	lddpc	r8,8000624c <xTaskRemoveFromEventList+0xb8>
800061ba:	70 08       	ld.w	r8,r8[0x0]
800061bc:	58 08       	cp.w	r8,0
800061be:	c2 81       	brne	8000620e <xTaskRemoveFromEventList+0x7a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800061c0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800061c4:	2f c8       	sub	r8,-4
800061c6:	10 9c       	mov	r12,r8
800061c8:	f0 1f 00 20 	mcall	80006248 <xTaskRemoveFromEventList+0xb4>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800061cc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800061d0:	70 b9       	ld.w	r9,r8[0x2c]
800061d2:	4a 08       	lddpc	r8,80006250 <xTaskRemoveFromEventList+0xbc>
800061d4:	70 08       	ld.w	r8,r8[0x0]
800061d6:	10 39       	cp.w	r9,r8
800061d8:	e0 88 00 07 	brls	800061e6 <xTaskRemoveFromEventList+0x52>
800061dc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800061e0:	70 b9       	ld.w	r9,r8[0x2c]
800061e2:	49 c8       	lddpc	r8,80006250 <xTaskRemoveFromEventList+0xbc>
800061e4:	91 09       	st.w	r8[0x0],r9
800061e6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800061ea:	f0 ca ff fc 	sub	r10,r8,-4
800061ee:	ee f8 ff f8 	ld.w	r8,r7[-8]
800061f2:	70 b9       	ld.w	r9,r8[0x2c]
800061f4:	12 98       	mov	r8,r9
800061f6:	a3 68       	lsl	r8,0x2
800061f8:	12 08       	add	r8,r9
800061fa:	a3 68       	lsl	r8,0x2
800061fc:	10 99       	mov	r9,r8
800061fe:	49 68       	lddpc	r8,80006254 <xTaskRemoveFromEventList+0xc0>
80006200:	f2 08 00 08 	add	r8,r9,r8
80006204:	14 9b       	mov	r11,r10
80006206:	10 9c       	mov	r12,r8
80006208:	f0 1f 00 14 	mcall	80006258 <xTaskRemoveFromEventList+0xc4>
8000620c:	c0 88       	rjmp	8000621c <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000620e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006212:	2e 88       	sub	r8,-24
80006214:	10 9b       	mov	r11,r8
80006216:	49 2c       	lddpc	r12,8000625c <xTaskRemoveFromEventList+0xc8>
80006218:	f0 1f 00 10 	mcall	80006258 <xTaskRemoveFromEventList+0xc4>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000621c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006220:	70 b9       	ld.w	r9,r8[0x2c]
80006222:	49 08       	lddpc	r8,80006260 <xTaskRemoveFromEventList+0xcc>
80006224:	70 08       	ld.w	r8,r8[0x0]
80006226:	70 b8       	ld.w	r8,r8[0x2c]
80006228:	10 39       	cp.w	r9,r8
8000622a:	c0 53       	brcs	80006234 <xTaskRemoveFromEventList+0xa0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
8000622c:	30 18       	mov	r8,1
8000622e:	ef 48 ff fc 	st.w	r7[-4],r8
80006232:	c0 48       	rjmp	8000623a <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		xReturn = pdFALSE;
80006234:	30 08       	mov	r8,0
80006236:	ef 48 ff fc 	st.w	r7[-4],r8
	}

	return xReturn;
8000623a:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000623e:	10 9c       	mov	r12,r8
80006240:	2f dd       	sub	sp,-12
80006242:	e3 cd 80 80 	ldm	sp++,r7,pc
80006246:	00 00       	add	r0,r0
80006248:	80 00       	ld.sh	r0,r0[0x0]
8000624a:	4d 4a       	lddpc	r10,80006398 <prvInitialiseTCBVariables+0xc>
8000624c:	00 00       	add	r0,r0
8000624e:	07 88       	ld.ub	r8,r3[0x0]
80006250:	00 00       	add	r0,r0
80006252:	07 80       	ld.ub	r0,r3[0x0]
80006254:	00 00       	add	r0,r0
80006256:	06 64       	and	r4,r3
80006258:	80 00       	ld.sh	r0,r0[0x0]
8000625a:	4c 36       	lddpc	r6,80006364 <prvIdleTask+0x4>
8000625c:	00 00       	add	r0,r0
8000625e:	07 34       	ld.ub	r4,r3++
80006260:	00 00       	add	r0,r0
80006262:	06 60       	and	r0,r3

80006264 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
80006264:	eb cd 40 80 	pushm	r7,lr
80006268:	1a 97       	mov	r7,sp
8000626a:	20 1d       	sub	sp,4
8000626c:	ef 4c ff fc 	st.w	r7[-4],r12
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006270:	48 78       	lddpc	r8,8000628c <vTaskSetTimeOutState+0x28>
80006272:	70 09       	ld.w	r9,r8[0x0]
80006274:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006278:	91 09       	st.w	r8[0x0],r9
	pxTimeOut->xTimeOnEntering = xTickCount;
8000627a:	48 68       	lddpc	r8,80006290 <vTaskSetTimeOutState+0x2c>
8000627c:	70 09       	ld.w	r9,r8[0x0]
8000627e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006282:	91 19       	st.w	r8[0x4],r9
}
80006284:	2f fd       	sub	sp,-4
80006286:	e3 cd 80 80 	ldm	sp++,r7,pc
8000628a:	00 00       	add	r0,r0
8000628c:	00 00       	add	r0,r0
8000628e:	07 94       	ld.ub	r4,r3[0x1]
80006290:	00 00       	add	r0,r0
80006292:	07 78       	ld.ub	r8,--r3

80006294 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006294:	eb cd 40 80 	pushm	r7,lr
80006298:	1a 97       	mov	r7,sp
8000629a:	20 3d       	sub	sp,12
8000629c:	ef 4c ff f8 	st.w	r7[-8],r12
800062a0:	ef 4b ff f4 	st.w	r7[-12],r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800062a4:	f0 1f 00 25 	mcall	80006338 <xTaskCheckForTimeOut+0xa4>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800062a8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800062ac:	70 08       	ld.w	r8,r8[0x0]
800062ae:	5b f8       	cp.w	r8,-1
800062b0:	c0 51       	brne	800062ba <xTaskCheckForTimeOut+0x26>
			{
				xReturn = pdFALSE;
800062b2:	30 08       	mov	r8,0
800062b4:	ef 48 ff fc 	st.w	r7[-4],r8
800062b8:	c3 88       	rjmp	80006328 <xTaskCheckForTimeOut+0x94>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800062ba:	ee f8 ff f8 	ld.w	r8,r7[-8]
800062be:	70 09       	ld.w	r9,r8[0x0]
800062c0:	49 f8       	lddpc	r8,8000633c <xTaskCheckForTimeOut+0xa8>
800062c2:	70 08       	ld.w	r8,r8[0x0]
800062c4:	10 39       	cp.w	r9,r8
800062c6:	c0 d0       	breq	800062e0 <xTaskCheckForTimeOut+0x4c>
800062c8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800062cc:	70 19       	ld.w	r9,r8[0x4]
800062ce:	49 d8       	lddpc	r8,80006340 <xTaskCheckForTimeOut+0xac>
800062d0:	70 08       	ld.w	r8,r8[0x0]
800062d2:	10 39       	cp.w	r9,r8
800062d4:	e0 8b 00 06 	brhi	800062e0 <xTaskCheckForTimeOut+0x4c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
800062d8:	30 18       	mov	r8,1
800062da:	ef 48 ff fc 	st.w	r7[-4],r8
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800062de:	c2 58       	rjmp	80006328 <xTaskCheckForTimeOut+0x94>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800062e0:	49 88       	lddpc	r8,80006340 <xTaskCheckForTimeOut+0xac>
800062e2:	70 09       	ld.w	r9,r8[0x0]
800062e4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800062e8:	70 18       	ld.w	r8,r8[0x4]
800062ea:	10 19       	sub	r9,r8
800062ec:	ee f8 ff f4 	ld.w	r8,r7[-12]
800062f0:	70 08       	ld.w	r8,r8[0x0]
800062f2:	10 39       	cp.w	r9,r8
800062f4:	c1 72       	brcc	80006322 <xTaskCheckForTimeOut+0x8e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800062f6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800062fa:	70 09       	ld.w	r9,r8[0x0]
800062fc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006300:	70 1a       	ld.w	r10,r8[0x4]
80006302:	49 08       	lddpc	r8,80006340 <xTaskCheckForTimeOut+0xac>
80006304:	70 08       	ld.w	r8,r8[0x0]
80006306:	f4 08 01 08 	sub	r8,r10,r8
8000630a:	10 09       	add	r9,r8
8000630c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006310:	91 09       	st.w	r8[0x0],r9
			vTaskSetTimeOutState( pxTimeOut );
80006312:	ee fc ff f8 	ld.w	r12,r7[-8]
80006316:	f0 1f 00 0c 	mcall	80006344 <xTaskCheckForTimeOut+0xb0>
			xReturn = pdFALSE;
8000631a:	30 08       	mov	r8,0
8000631c:	ef 48 ff fc 	st.w	r7[-4],r8
80006320:	c0 48       	rjmp	80006328 <xTaskCheckForTimeOut+0x94>
		}
		else
		{
			xReturn = pdTRUE;
80006322:	30 18       	mov	r8,1
80006324:	ef 48 ff fc 	st.w	r7[-4],r8
		}
	}
	taskEXIT_CRITICAL();
80006328:	f0 1f 00 08 	mcall	80006348 <xTaskCheckForTimeOut+0xb4>

	return xReturn;
8000632c:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80006330:	10 9c       	mov	r12,r8
80006332:	2f dd       	sub	sp,-12
80006334:	e3 cd 80 80 	ldm	sp++,r7,pc
80006338:	80 00       	ld.sh	r0,r0[0x0]
8000633a:	4f 60       	lddpc	r0,80006510 <prvCheckTasksWaitingTermination+0x54>
8000633c:	00 00       	add	r0,r0
8000633e:	07 94       	ld.ub	r4,r3[0x1]
80006340:	00 00       	add	r0,r0
80006342:	07 78       	ld.ub	r8,--r3
80006344:	80 00       	ld.sh	r0,r0[0x0]
80006346:	62 64       	ld.w	r4,r1[0x18]
80006348:	80 00       	ld.sh	r0,r0[0x0]
8000634a:	4f 7c       	lddpc	r12,80006524 <prvCheckTasksWaitingTermination+0x68>

8000634c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
8000634c:	eb cd 40 80 	pushm	r7,lr
80006350:	1a 97       	mov	r7,sp
	xMissedYield = pdTRUE;
80006352:	48 38       	lddpc	r8,8000635c <vTaskMissedYield+0x10>
80006354:	30 19       	mov	r9,1
80006356:	91 09       	st.w	r8[0x0],r9
}
80006358:	e3 cd 80 80 	ldm	sp++,r7,pc
8000635c:	00 00       	add	r0,r0
8000635e:	07 90       	ld.ub	r0,r3[0x1]

80006360 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006360:	eb cd 40 80 	pushm	r7,lr
80006364:	1a 97       	mov	r7,sp
80006366:	20 1d       	sub	sp,4
80006368:	ef 4c ff fc 	st.w	r7[-4],r12
8000636c:	c0 28       	rjmp	80006370 <prvIdleTask+0x10>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
8000636e:	d7 03       	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
80006370:	f0 1f 00 05 	mcall	80006384 <prvIdleTask+0x24>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006374:	48 58       	lddpc	r8,80006388 <prvIdleTask+0x28>
80006376:	70 08       	ld.w	r8,r8[0x0]
80006378:	58 18       	cp.w	r8,1
8000637a:	fe 98 ff fa 	brls	8000636e <prvIdleTask+0xe>
			{
				taskYIELD();
8000637e:	d7 33       	scall
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
80006380:	cf 8b       	rjmp	80006370 <prvIdleTask+0x10>
80006382:	00 00       	add	r0,r0
80006384:	80 00       	ld.sh	r0,r0[0x0]
80006386:	64 bc       	ld.w	r12,r2[0x2c]
80006388:	00 00       	add	r0,r0
8000638a:	06 64       	and	r4,r3

8000638c <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
8000638c:	eb cd 40 80 	pushm	r7,lr
80006390:	1a 97       	mov	r7,sp
80006392:	20 5d       	sub	sp,20
80006394:	ef 4c ff fc 	st.w	r7[-4],r12
80006398:	ef 4b ff f8 	st.w	r7[-8],r11
8000639c:	ef 4a ff f4 	st.w	r7[-12],r10
800063a0:	ef 49 ff f0 	st.w	r7[-16],r9
800063a4:	ef 58 ff ec 	st.h	r7[-20],r8
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800063a8:	ee f9 ff f8 	ld.w	r9,r7[-8]
800063ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800063b0:	2c c8       	sub	r8,-52
800063b2:	31 0a       	mov	r10,16
800063b4:	12 9b       	mov	r11,r9
800063b6:	10 9c       	mov	r12,r8
800063b8:	f0 1f 00 1a 	mcall	80006420 <prvInitialiseTCBVariables+0x94>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800063bc:	ee f9 ff fc 	ld.w	r9,r7[-4]
800063c0:	30 08       	mov	r8,0
800063c2:	f3 68 00 43 	st.b	r9[67],r8

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
800063c6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800063ca:	58 78       	cp.w	r8,7
800063cc:	e0 88 00 05 	brls	800063d6 <prvInitialiseTCBVariables+0x4a>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
800063d0:	30 78       	mov	r8,7
800063d2:	ef 48 ff f4 	st.w	r7[-12],r8
	}

	pxTCB->uxPriority = uxPriority;
800063d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800063da:	ee f9 ff f4 	ld.w	r9,r7[-12]
800063de:	91 b9       	st.w	r8[0x2c],r9
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800063e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800063e4:	2f c8       	sub	r8,-4
800063e6:	10 9c       	mov	r12,r8
800063e8:	f0 1f 00 0f 	mcall	80006424 <prvInitialiseTCBVariables+0x98>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800063ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800063f0:	2e 88       	sub	r8,-24
800063f2:	10 9c       	mov	r12,r8
800063f4:	f0 1f 00 0c 	mcall	80006424 <prvInitialiseTCBVariables+0x98>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800063f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800063fc:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006400:	91 49       	st.w	r8[0x10],r9

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006402:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006406:	f0 09 11 08 	rsub	r9,r8,8
8000640a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000640e:	91 69       	st.w	r8[0x18],r9
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006410:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006414:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006418:	91 99       	st.w	r8[0x24],r9
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
8000641a:	2f bd       	sub	sp,-20
8000641c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006420:	80 00       	ld.sh	r0,r0[0x0]
80006422:	71 f4       	ld.w	r4,r8[0x7c]
80006424:	80 00       	ld.sh	r0,r0[0x0]
80006426:	4c 1c       	lddpc	r12,80006528 <prvCheckTasksWaitingTermination+0x6c>

80006428 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
80006428:	eb cd 40 80 	pushm	r7,lr
8000642c:	1a 97       	mov	r7,sp
8000642e:	20 1d       	sub	sp,4
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006430:	30 08       	mov	r8,0
80006432:	ef 48 ff fc 	st.w	r7[-4],r8
80006436:	c1 38       	rjmp	8000645c <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006438:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000643c:	12 98       	mov	r8,r9
8000643e:	a3 68       	lsl	r8,0x2
80006440:	12 08       	add	r8,r9
80006442:	a3 68       	lsl	r8,0x2
80006444:	10 99       	mov	r9,r8
80006446:	49 58       	lddpc	r8,80006498 <prvInitialiseTaskLists+0x70>
80006448:	f2 08 00 08 	add	r8,r9,r8
8000644c:	10 9c       	mov	r12,r8
8000644e:	f0 1f 00 14 	mcall	8000649c <prvInitialiseTaskLists+0x74>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006452:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006456:	2f f8       	sub	r8,-1
80006458:	ef 48 ff fc 	st.w	r7[-4],r8
8000645c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006460:	58 78       	cp.w	r8,7
80006462:	fe 98 ff eb 	brls	80006438 <prvInitialiseTaskLists+0x10>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006466:	48 fc       	lddpc	r12,800064a0 <prvInitialiseTaskLists+0x78>
80006468:	f0 1f 00 0d 	mcall	8000649c <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
8000646c:	48 ec       	lddpc	r12,800064a4 <prvInitialiseTaskLists+0x7c>
8000646e:	f0 1f 00 0c 	mcall	8000649c <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006472:	48 ec       	lddpc	r12,800064a8 <prvInitialiseTaskLists+0x80>
80006474:	f0 1f 00 0a 	mcall	8000649c <prvInitialiseTaskLists+0x74>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006478:	48 dc       	lddpc	r12,800064ac <prvInitialiseTaskLists+0x84>
8000647a:	f0 1f 00 09 	mcall	8000649c <prvInitialiseTaskLists+0x74>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
8000647e:	48 dc       	lddpc	r12,800064b0 <prvInitialiseTaskLists+0x88>
80006480:	f0 1f 00 07 	mcall	8000649c <prvInitialiseTaskLists+0x74>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006484:	48 c8       	lddpc	r8,800064b4 <prvInitialiseTaskLists+0x8c>
80006486:	48 79       	lddpc	r9,800064a0 <prvInitialiseTaskLists+0x78>
80006488:	91 09       	st.w	r8[0x0],r9
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000648a:	48 c8       	lddpc	r8,800064b8 <prvInitialiseTaskLists+0x90>
8000648c:	48 69       	lddpc	r9,800064a4 <prvInitialiseTaskLists+0x7c>
8000648e:	91 09       	st.w	r8[0x0],r9
}
80006490:	2f fd       	sub	sp,-4
80006492:	e3 cd 80 80 	ldm	sp++,r7,pc
80006496:	00 00       	add	r0,r0
80006498:	00 00       	add	r0,r0
8000649a:	06 64       	and	r4,r3
8000649c:	80 00       	ld.sh	r0,r0[0x0]
8000649e:	4b d0       	lddpc	r0,80006590 <prvAddCurrentTaskToDelayedList+0x3c>
800064a0:	00 00       	add	r0,r0
800064a2:	07 04       	ld.w	r4,r3++
800064a4:	00 00       	add	r0,r0
800064a6:	07 18       	ld.sh	r8,r3++
800064a8:	00 00       	add	r0,r0
800064aa:	07 34       	ld.ub	r4,r3++
800064ac:	00 00       	add	r0,r0
800064ae:	07 48       	ld.w	r8,--r3
800064b0:	00 00       	add	r0,r0
800064b2:	07 60       	ld.uh	r0,--r3
800064b4:	00 00       	add	r0,r0
800064b6:	07 2c       	ld.uh	r12,r3++
800064b8:	00 00       	add	r0,r0
800064ba:	07 30       	ld.ub	r0,r3++

800064bc <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
800064bc:	eb cd 40 80 	pushm	r7,lr
800064c0:	1a 97       	mov	r7,sp
800064c2:	20 2d       	sub	sp,8
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800064c4:	49 b8       	lddpc	r8,80006530 <prvCheckTasksWaitingTermination+0x74>
800064c6:	70 08       	ld.w	r8,r8[0x0]
800064c8:	58 08       	cp.w	r8,0
800064ca:	c2 f0       	breq	80006528 <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
800064cc:	f0 1f 00 1a 	mcall	80006534 <prvCheckTasksWaitingTermination+0x78>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800064d0:	49 a8       	lddpc	r8,80006538 <prvCheckTasksWaitingTermination+0x7c>
800064d2:	70 08       	ld.w	r8,r8[0x0]
800064d4:	58 08       	cp.w	r8,0
800064d6:	5f 08       	sreq	r8
800064d8:	ef 48 ff f8 	st.w	r7[-8],r8
			xTaskResumeAll();
800064dc:	f0 1f 00 18 	mcall	8000653c <prvCheckTasksWaitingTermination+0x80>

			if( xListIsEmpty == pdFALSE )
800064e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800064e4:	58 08       	cp.w	r8,0
800064e6:	c2 11       	brne	80006528 <prvCheckTasksWaitingTermination+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800064e8:	f0 1f 00 16 	mcall	80006540 <prvCheckTasksWaitingTermination+0x84>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800064ec:	49 38       	lddpc	r8,80006538 <prvCheckTasksWaitingTermination+0x7c>
800064ee:	2f 88       	sub	r8,-8
800064f0:	70 18       	ld.w	r8,r8[0x4]
800064f2:	70 38       	ld.w	r8,r8[0xc]
800064f4:	ef 48 ff fc 	st.w	r7[-4],r8
					vListRemove( &( pxTCB->xGenericListItem ) );
800064f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800064fc:	2f c8       	sub	r8,-4
800064fe:	10 9c       	mov	r12,r8
80006500:	f0 1f 00 11 	mcall	80006544 <prvCheckTasksWaitingTermination+0x88>
					--uxCurrentNumberOfTasks;
80006504:	49 18       	lddpc	r8,80006548 <prvCheckTasksWaitingTermination+0x8c>
80006506:	70 08       	ld.w	r8,r8[0x0]
80006508:	f0 c9 00 01 	sub	r9,r8,1
8000650c:	48 f8       	lddpc	r8,80006548 <prvCheckTasksWaitingTermination+0x8c>
8000650e:	91 09       	st.w	r8[0x0],r9
					--uxTasksDeleted;
80006510:	48 88       	lddpc	r8,80006530 <prvCheckTasksWaitingTermination+0x74>
80006512:	70 08       	ld.w	r8,r8[0x0]
80006514:	f0 c9 00 01 	sub	r9,r8,1
80006518:	48 68       	lddpc	r8,80006530 <prvCheckTasksWaitingTermination+0x74>
8000651a:	91 09       	st.w	r8[0x0],r9
				}
				taskEXIT_CRITICAL();
8000651c:	f0 1f 00 0c 	mcall	8000654c <prvCheckTasksWaitingTermination+0x90>

				prvDeleteTCB( pxTCB );
80006520:	ee fc ff fc 	ld.w	r12,r7[-4]
80006524:	f0 1f 00 0b 	mcall	80006550 <prvCheckTasksWaitingTermination+0x94>
			}
		}
	}
	#endif
}
80006528:	2f ed       	sub	sp,-8
8000652a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000652e:	00 00       	add	r0,r0
80006530:	00 00       	add	r0,r0
80006532:	07 5c       	ld.sh	r12,--r3
80006534:	80 00       	ld.sh	r0,r0[0x0]
80006536:	5d 90       	*unknown*
80006538:	00 00       	add	r0,r0
8000653a:	07 48       	ld.w	r8,--r3
8000653c:	80 00       	ld.sh	r0,r0[0x0]
8000653e:	5d ac       	*unknown*
80006540:	80 00       	ld.sh	r0,r0[0x0]
80006542:	4f 60       	lddpc	r0,80006718 <__avr32_udiv64+0x84>
80006544:	80 00       	ld.sh	r0,r0[0x0]
80006546:	4d 4a       	lddpc	r10,80006694 <__avr32_udiv64>
80006548:	00 00       	add	r0,r0
8000654a:	07 74       	ld.ub	r4,--r3
8000654c:	80 00       	ld.sh	r0,r0[0x0]
8000654e:	4f 7c       	lddpc	r12,80006728 <__avr32_udiv64+0x94>
80006550:	80 00       	ld.sh	r0,r0[0x0]
80006552:	66 68       	ld.w	r8,r3[0x18]

80006554 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006554:	eb cd 40 80 	pushm	r7,lr
80006558:	1a 97       	mov	r7,sp
8000655a:	20 1d       	sub	sp,4
8000655c:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006560:	49 78       	lddpc	r8,800065bc <prvAddCurrentTaskToDelayedList+0x68>
80006562:	70 08       	ld.w	r8,r8[0x0]
80006564:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006568:	91 19       	st.w	r8[0x4],r9

	if( xTimeToWake < xTickCount )
8000656a:	49 68       	lddpc	r8,800065c0 <prvAddCurrentTaskToDelayedList+0x6c>
8000656c:	70 08       	ld.w	r8,r8[0x0]
8000656e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006572:	10 39       	cp.w	r9,r8
80006574:	c0 c2       	brcc	8000658c <prvAddCurrentTaskToDelayedList+0x38>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006576:	49 28       	lddpc	r8,800065bc <prvAddCurrentTaskToDelayedList+0x68>
80006578:	70 08       	ld.w	r8,r8[0x0]
8000657a:	f0 c9 ff fc 	sub	r9,r8,-4
8000657e:	49 28       	lddpc	r8,800065c4 <prvAddCurrentTaskToDelayedList+0x70>
80006580:	70 08       	ld.w	r8,r8[0x0]
80006582:	12 9b       	mov	r11,r9
80006584:	10 9c       	mov	r12,r8
80006586:	f0 1f 00 11 	mcall	800065c8 <prvAddCurrentTaskToDelayedList+0x74>
8000658a:	c1 58       	rjmp	800065b4 <prvAddCurrentTaskToDelayedList+0x60>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000658c:	48 c8       	lddpc	r8,800065bc <prvAddCurrentTaskToDelayedList+0x68>
8000658e:	70 08       	ld.w	r8,r8[0x0]
80006590:	f0 c9 ff fc 	sub	r9,r8,-4
80006594:	48 e8       	lddpc	r8,800065cc <prvAddCurrentTaskToDelayedList+0x78>
80006596:	70 08       	ld.w	r8,r8[0x0]
80006598:	12 9b       	mov	r11,r9
8000659a:	10 9c       	mov	r12,r8
8000659c:	f0 1f 00 0b 	mcall	800065c8 <prvAddCurrentTaskToDelayedList+0x74>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800065a0:	48 c8       	lddpc	r8,800065d0 <prvAddCurrentTaskToDelayedList+0x7c>
800065a2:	70 08       	ld.w	r8,r8[0x0]
800065a4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800065a8:	10 39       	cp.w	r9,r8
800065aa:	c0 52       	brcc	800065b4 <prvAddCurrentTaskToDelayedList+0x60>
		{
			xNextTaskUnblockTime = xTimeToWake;
800065ac:	48 98       	lddpc	r8,800065d0 <prvAddCurrentTaskToDelayedList+0x7c>
800065ae:	ee f9 ff fc 	ld.w	r9,r7[-4]
800065b2:	91 09       	st.w	r8[0x0],r9
		}
	}
}
800065b4:	2f fd       	sub	sp,-4
800065b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800065ba:	00 00       	add	r0,r0
800065bc:	00 00       	add	r0,r0
800065be:	06 60       	and	r0,r3
800065c0:	00 00       	add	r0,r0
800065c2:	07 78       	ld.ub	r8,--r3
800065c4:	00 00       	add	r0,r0
800065c6:	07 30       	ld.ub	r0,r3++
800065c8:	80 00       	ld.sh	r0,r0[0x0]
800065ca:	4c a8       	lddpc	r8,800066f0 <__avr32_udiv64+0x5c>
800065cc:	00 00       	add	r0,r0
800065ce:	07 2c       	ld.uh	r12,r3++
800065d0:	00 00       	add	r0,r0
800065d2:	00 24       	rsub	r4,r0

800065d4 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
800065d4:	eb cd 40 80 	pushm	r7,lr
800065d8:	1a 97       	mov	r7,sp
800065da:	20 3d       	sub	sp,12
800065dc:	18 98       	mov	r8,r12
800065de:	ef 4b ff f4 	st.w	r7[-12],r11
800065e2:	ef 58 ff f8 	st.h	r7[-8],r8
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800065e6:	34 4c       	mov	r12,68
800065e8:	f0 1f 00 1d 	mcall	8000665c <prvAllocateTCBAndStack+0x88>
800065ec:	18 98       	mov	r8,r12
800065ee:	ef 48 ff fc 	st.w	r7[-4],r8

	if( pxNewTCB != NULL )
800065f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800065f6:	58 08       	cp.w	r8,0
800065f8:	c2 c0       	breq	80006650 <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800065fa:	ee f8 ff f4 	ld.w	r8,r7[-12]
800065fe:	58 08       	cp.w	r8,0
80006600:	c0 91       	brne	80006612 <prvAllocateTCBAndStack+0x3e>
80006602:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80006606:	a3 68       	lsl	r8,0x2
80006608:	10 9c       	mov	r12,r8
8000660a:	f0 1f 00 15 	mcall	8000665c <prvAllocateTCBAndStack+0x88>
8000660e:	18 98       	mov	r8,r12
80006610:	c0 38       	rjmp	80006616 <prvAllocateTCBAndStack+0x42>
80006612:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006616:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000661a:	93 c8       	st.w	r9[0x30],r8

		if( pxNewTCB->pxStack == NULL )
8000661c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006620:	70 c8       	ld.w	r8,r8[0x30]
80006622:	58 08       	cp.w	r8,0
80006624:	c0 91       	brne	80006636 <prvAllocateTCBAndStack+0x62>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006626:	ee fc ff fc 	ld.w	r12,r7[-4]
8000662a:	f0 1f 00 0e 	mcall	80006660 <prvAllocateTCBAndStack+0x8c>
			pxNewTCB = NULL;
8000662e:	30 08       	mov	r8,0
80006630:	ef 48 ff fc 	st.w	r7[-4],r8
80006634:	c0 e8       	rjmp	80006650 <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006636:	ef 18 ff f8 	ld.uh	r8,r7[-8]
8000663a:	f0 09 15 02 	lsl	r9,r8,0x2
8000663e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006642:	70 c8       	ld.w	r8,r8[0x30]
80006644:	12 9a       	mov	r10,r9
80006646:	e0 6b 00 a5 	mov	r11,165
8000664a:	10 9c       	mov	r12,r8
8000664c:	f0 1f 00 06 	mcall	80006664 <prvAllocateTCBAndStack+0x90>
		}
	}

	return pxNewTCB;
80006650:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80006654:	10 9c       	mov	r12,r8
80006656:	2f dd       	sub	sp,-12
80006658:	e3 cd 80 80 	ldm	sp++,r7,pc
8000665c:	80 00       	ld.sh	r0,r0[0x0]
8000665e:	53 08       	stdsp	sp[0xc0],r8
80006660:	80 00       	ld.sh	r0,r0[0x0]
80006662:	53 44       	stdsp	sp[0xd0],r4
80006664:	80 00       	ld.sh	r0,r0[0x0]
80006666:	6e c8       	ld.w	r8,r7[0x30]

80006668 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
80006668:	eb cd 40 80 	pushm	r7,lr
8000666c:	1a 97       	mov	r7,sp
8000666e:	20 1d       	sub	sp,4
80006670:	ef 4c ff fc 	st.w	r7[-4],r12
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006674:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006678:	70 c8       	ld.w	r8,r8[0x30]
8000667a:	10 9c       	mov	r12,r8
8000667c:	f0 1f 00 05 	mcall	80006690 <prvDeleteTCB+0x28>
		vPortFree( pxTCB );
80006680:	ee fc ff fc 	ld.w	r12,r7[-4]
80006684:	f0 1f 00 03 	mcall	80006690 <prvDeleteTCB+0x28>
	}
80006688:	2f fd       	sub	sp,-4
8000668a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000668e:	00 00       	add	r0,r0
80006690:	80 00       	ld.sh	r0,r0[0x0]
80006692:	53 44       	stdsp	sp[0xd0],r4

80006694 <__avr32_udiv64>:
80006694:	d4 31       	pushm	r0-r7,lr
80006696:	1a 97       	mov	r7,sp
80006698:	20 3d       	sub	sp,12
8000669a:	10 9c       	mov	r12,r8
8000669c:	12 9e       	mov	lr,r9
8000669e:	14 93       	mov	r3,r10
800066a0:	58 09       	cp.w	r9,0
800066a2:	e0 81 00 bd 	brne	8000681c <__avr32_udiv64+0x188>
800066a6:	16 38       	cp.w	r8,r11
800066a8:	e0 88 00 40 	brls	80006728 <__avr32_udiv64+0x94>
800066ac:	f0 08 12 00 	clz	r8,r8
800066b0:	c0 d0       	breq	800066ca <__avr32_udiv64+0x36>
800066b2:	f6 08 09 4b 	lsl	r11,r11,r8
800066b6:	f0 09 11 20 	rsub	r9,r8,32
800066ba:	f8 08 09 4c 	lsl	r12,r12,r8
800066be:	f4 09 0a 49 	lsr	r9,r10,r9
800066c2:	f4 08 09 43 	lsl	r3,r10,r8
800066c6:	f3 eb 10 0b 	or	r11,r9,r11
800066ca:	f8 0e 16 10 	lsr	lr,r12,0x10
800066ce:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
800066d2:	f6 0e 0d 00 	divu	r0,r11,lr
800066d6:	e6 0b 16 10 	lsr	r11,r3,0x10
800066da:	00 99       	mov	r9,r0
800066dc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800066e0:	e0 0a 02 48 	mul	r8,r0,r10
800066e4:	10 3b       	cp.w	r11,r8
800066e6:	c0 a2       	brcc	800066fa <__avr32_udiv64+0x66>
800066e8:	20 19       	sub	r9,1
800066ea:	18 0b       	add	r11,r12
800066ec:	18 3b       	cp.w	r11,r12
800066ee:	c0 63       	brcs	800066fa <__avr32_udiv64+0x66>
800066f0:	10 3b       	cp.w	r11,r8
800066f2:	f7 b9 03 01 	sublo	r9,1
800066f6:	f7 dc e3 0b 	addcs	r11,r11,r12
800066fa:	f6 08 01 01 	sub	r1,r11,r8
800066fe:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80006702:	e2 0e 0d 00 	divu	r0,r1,lr
80006706:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000670a:	00 98       	mov	r8,r0
8000670c:	e0 0a 02 4a 	mul	r10,r0,r10
80006710:	14 33       	cp.w	r3,r10
80006712:	c0 82       	brcc	80006722 <__avr32_udiv64+0x8e>
80006714:	20 18       	sub	r8,1
80006716:	18 03       	add	r3,r12
80006718:	18 33       	cp.w	r3,r12
8000671a:	c0 43       	brcs	80006722 <__avr32_udiv64+0x8e>
8000671c:	14 33       	cp.w	r3,r10
8000671e:	f7 b8 03 01 	sublo	r8,1
80006722:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80006726:	cd f8       	rjmp	800068e4 <__avr32_udiv64+0x250>
80006728:	58 08       	cp.w	r8,0
8000672a:	c0 51       	brne	80006734 <__avr32_udiv64+0xa0>
8000672c:	30 19       	mov	r9,1
8000672e:	f2 08 0d 08 	divu	r8,r9,r8
80006732:	10 9c       	mov	r12,r8
80006734:	f8 06 12 00 	clz	r6,r12
80006738:	c0 41       	brne	80006740 <__avr32_udiv64+0xac>
8000673a:	18 1b       	sub	r11,r12
8000673c:	30 19       	mov	r9,1
8000673e:	c4 08       	rjmp	800067be <__avr32_udiv64+0x12a>
80006740:	ec 01 11 20 	rsub	r1,r6,32
80006744:	f4 01 0a 49 	lsr	r9,r10,r1
80006748:	f8 06 09 4c 	lsl	r12,r12,r6
8000674c:	f6 06 09 48 	lsl	r8,r11,r6
80006750:	f6 01 0a 41 	lsr	r1,r11,r1
80006754:	f3 e8 10 08 	or	r8,r9,r8
80006758:	f8 03 16 10 	lsr	r3,r12,0x10
8000675c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
80006760:	e2 03 0d 00 	divu	r0,r1,r3
80006764:	f0 0b 16 10 	lsr	r11,r8,0x10
80006768:	00 9e       	mov	lr,r0
8000676a:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000676e:	e0 05 02 49 	mul	r9,r0,r5
80006772:	12 3b       	cp.w	r11,r9
80006774:	c0 a2       	brcc	80006788 <__avr32_udiv64+0xf4>
80006776:	20 1e       	sub	lr,1
80006778:	18 0b       	add	r11,r12
8000677a:	18 3b       	cp.w	r11,r12
8000677c:	c0 63       	brcs	80006788 <__avr32_udiv64+0xf4>
8000677e:	12 3b       	cp.w	r11,r9
80006780:	f7 be 03 01 	sublo	lr,1
80006784:	f7 dc e3 0b 	addcs	r11,r11,r12
80006788:	12 1b       	sub	r11,r9
8000678a:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000678e:	f6 03 0d 02 	divu	r2,r11,r3
80006792:	f1 e3 11 08 	or	r8,r8,r3<<0x10
80006796:	04 99       	mov	r9,r2
80006798:	e4 05 02 4b 	mul	r11,r2,r5
8000679c:	16 38       	cp.w	r8,r11
8000679e:	c0 a2       	brcc	800067b2 <__avr32_udiv64+0x11e>
800067a0:	20 19       	sub	r9,1
800067a2:	18 08       	add	r8,r12
800067a4:	18 38       	cp.w	r8,r12
800067a6:	c0 63       	brcs	800067b2 <__avr32_udiv64+0x11e>
800067a8:	16 38       	cp.w	r8,r11
800067aa:	f7 b9 03 01 	sublo	r9,1
800067ae:	f1 dc e3 08 	addcs	r8,r8,r12
800067b2:	f4 06 09 43 	lsl	r3,r10,r6
800067b6:	f0 0b 01 0b 	sub	r11,r8,r11
800067ba:	f3 ee 11 09 	or	r9,r9,lr<<0x10
800067be:	f8 06 16 10 	lsr	r6,r12,0x10
800067c2:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
800067c6:	f6 06 0d 00 	divu	r0,r11,r6
800067ca:	e6 0b 16 10 	lsr	r11,r3,0x10
800067ce:	00 9a       	mov	r10,r0
800067d0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800067d4:	e0 0e 02 48 	mul	r8,r0,lr
800067d8:	10 3b       	cp.w	r11,r8
800067da:	c0 a2       	brcc	800067ee <__avr32_udiv64+0x15a>
800067dc:	20 1a       	sub	r10,1
800067de:	18 0b       	add	r11,r12
800067e0:	18 3b       	cp.w	r11,r12
800067e2:	c0 63       	brcs	800067ee <__avr32_udiv64+0x15a>
800067e4:	10 3b       	cp.w	r11,r8
800067e6:	f7 ba 03 01 	sublo	r10,1
800067ea:	f7 dc e3 0b 	addcs	r11,r11,r12
800067ee:	f6 08 01 01 	sub	r1,r11,r8
800067f2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
800067f6:	e2 06 0d 00 	divu	r0,r1,r6
800067fa:	e7 e1 11 03 	or	r3,r3,r1<<0x10
800067fe:	00 98       	mov	r8,r0
80006800:	e0 0e 02 4b 	mul	r11,r0,lr
80006804:	16 33       	cp.w	r3,r11
80006806:	c0 82       	brcc	80006816 <__avr32_udiv64+0x182>
80006808:	20 18       	sub	r8,1
8000680a:	18 03       	add	r3,r12
8000680c:	18 33       	cp.w	r3,r12
8000680e:	c0 43       	brcs	80006816 <__avr32_udiv64+0x182>
80006810:	16 33       	cp.w	r3,r11
80006812:	f7 b8 03 01 	sublo	r8,1
80006816:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000681a:	c6 98       	rjmp	800068ec <__avr32_udiv64+0x258>
8000681c:	16 39       	cp.w	r9,r11
8000681e:	e0 8b 00 65 	brhi	800068e8 <__avr32_udiv64+0x254>
80006822:	f2 09 12 00 	clz	r9,r9
80006826:	c0 b1       	brne	8000683c <__avr32_udiv64+0x1a8>
80006828:	10 3a       	cp.w	r10,r8
8000682a:	5f 2a       	srhs	r10
8000682c:	1c 3b       	cp.w	r11,lr
8000682e:	5f b8       	srhi	r8
80006830:	10 4a       	or	r10,r8
80006832:	f2 0a 18 00 	cp.b	r10,r9
80006836:	c5 90       	breq	800068e8 <__avr32_udiv64+0x254>
80006838:	30 18       	mov	r8,1
8000683a:	c5 98       	rjmp	800068ec <__avr32_udiv64+0x258>
8000683c:	f0 09 09 46 	lsl	r6,r8,r9
80006840:	f2 03 11 20 	rsub	r3,r9,32
80006844:	fc 09 09 4e 	lsl	lr,lr,r9
80006848:	f0 03 0a 48 	lsr	r8,r8,r3
8000684c:	f6 09 09 4c 	lsl	r12,r11,r9
80006850:	f4 03 0a 42 	lsr	r2,r10,r3
80006854:	ef 46 ff f4 	st.w	r7[-12],r6
80006858:	f6 03 0a 43 	lsr	r3,r11,r3
8000685c:	18 42       	or	r2,r12
8000685e:	f1 ee 10 0c 	or	r12,r8,lr
80006862:	f8 01 16 10 	lsr	r1,r12,0x10
80006866:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000686a:	e6 01 0d 04 	divu	r4,r3,r1
8000686e:	e4 03 16 10 	lsr	r3,r2,0x10
80006872:	08 9e       	mov	lr,r4
80006874:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80006878:	e8 06 02 48 	mul	r8,r4,r6
8000687c:	10 33       	cp.w	r3,r8
8000687e:	c0 a2       	brcc	80006892 <__avr32_udiv64+0x1fe>
80006880:	20 1e       	sub	lr,1
80006882:	18 03       	add	r3,r12
80006884:	18 33       	cp.w	r3,r12
80006886:	c0 63       	brcs	80006892 <__avr32_udiv64+0x1fe>
80006888:	10 33       	cp.w	r3,r8
8000688a:	f7 be 03 01 	sublo	lr,1
8000688e:	e7 dc e3 03 	addcs	r3,r3,r12
80006892:	10 13       	sub	r3,r8
80006894:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
80006898:	e6 01 0d 00 	divu	r0,r3,r1
8000689c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800068a0:	00 98       	mov	r8,r0
800068a2:	e0 06 02 46 	mul	r6,r0,r6
800068a6:	0c 3b       	cp.w	r11,r6
800068a8:	c0 a2       	brcc	800068bc <__avr32_udiv64+0x228>
800068aa:	20 18       	sub	r8,1
800068ac:	18 0b       	add	r11,r12
800068ae:	18 3b       	cp.w	r11,r12
800068b0:	c0 63       	brcs	800068bc <__avr32_udiv64+0x228>
800068b2:	0c 3b       	cp.w	r11,r6
800068b4:	f7 dc e3 0b 	addcs	r11,r11,r12
800068b8:	f7 b8 03 01 	sublo	r8,1
800068bc:	f1 ee 11 08 	or	r8,r8,lr<<0x10
800068c0:	ee f4 ff f4 	ld.w	r4,r7[-12]
800068c4:	0c 1b       	sub	r11,r6
800068c6:	f0 04 06 42 	mulu.d	r2,r8,r4
800068ca:	06 95       	mov	r5,r3
800068cc:	16 35       	cp.w	r5,r11
800068ce:	e0 8b 00 0a 	brhi	800068e2 <__avr32_udiv64+0x24e>
800068d2:	5f 0b       	sreq	r11
800068d4:	f4 09 09 49 	lsl	r9,r10,r9
800068d8:	12 32       	cp.w	r2,r9
800068da:	5f b9       	srhi	r9
800068dc:	f7 e9 00 09 	and	r9,r11,r9
800068e0:	c0 60       	breq	800068ec <__avr32_udiv64+0x258>
800068e2:	20 18       	sub	r8,1
800068e4:	30 09       	mov	r9,0
800068e6:	c0 38       	rjmp	800068ec <__avr32_udiv64+0x258>
800068e8:	30 09       	mov	r9,0
800068ea:	12 98       	mov	r8,r9
800068ec:	10 9a       	mov	r10,r8
800068ee:	12 93       	mov	r3,r9
800068f0:	10 92       	mov	r2,r8
800068f2:	12 9b       	mov	r11,r9
800068f4:	2f dd       	sub	sp,-12
800068f6:	d8 32       	popm	r0-r7,pc

800068f8 <atexit>:
800068f8:	d4 01       	pushm	lr
800068fa:	30 09       	mov	r9,0
800068fc:	18 9b       	mov	r11,r12
800068fe:	12 9a       	mov	r10,r9
80006900:	12 9c       	mov	r12,r9
80006902:	e0 a0 16 af 	rcall	80009660 <__register_exitproc>
80006906:	d8 02       	popm	pc

80006908 <exit>:
80006908:	d4 21       	pushm	r4-r7,lr
8000690a:	30 0b       	mov	r11,0
8000690c:	18 97       	mov	r7,r12
8000690e:	e0 a0 16 fb 	rcall	80009704 <__call_exitprocs>
80006912:	fe c8 a3 de 	sub	r8,pc,-23586
80006916:	70 0c       	ld.w	r12,r8[0x0]
80006918:	78 a8       	ld.w	r8,r12[0x28]
8000691a:	58 08       	cp.w	r8,0
8000691c:	c0 20       	breq	80006920 <exit+0x18>
8000691e:	5d 18       	icall	r8
80006920:	0e 9c       	mov	r12,r7
80006922:	e0 a0 04 7e 	rcall	8000721e <_exit>
80006926:	d7 03       	nop

80006928 <free>:
80006928:	d4 01       	pushm	lr
8000692a:	e0 68 01 18 	mov	r8,280
8000692e:	18 9b       	mov	r11,r12
80006930:	70 0c       	ld.w	r12,r8[0x0]
80006932:	e0 a0 1f 45 	rcall	8000a7bc <_free_r>
80006936:	d8 02       	popm	pc

80006938 <malloc>:
80006938:	d4 01       	pushm	lr
8000693a:	e0 68 01 18 	mov	r8,280
8000693e:	18 9b       	mov	r11,r12
80006940:	70 0c       	ld.w	r12,r8[0x0]
80006942:	c0 3c       	rcall	80006948 <_malloc_r>
80006944:	d8 02       	popm	pc
80006946:	d7 03       	nop

80006948 <_malloc_r>:
80006948:	d4 31       	pushm	r0-r7,lr
8000694a:	f6 c8 ff f5 	sub	r8,r11,-11
8000694e:	18 95       	mov	r5,r12
80006950:	10 97       	mov	r7,r8
80006952:	e0 17 ff f8 	andl	r7,0xfff8
80006956:	59 68       	cp.w	r8,22
80006958:	f9 b7 08 10 	movls	r7,16
8000695c:	16 37       	cp.w	r7,r11
8000695e:	5f 38       	srlo	r8
80006960:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006964:	c0 50       	breq	8000696e <_malloc_r+0x26>
80006966:	30 c8       	mov	r8,12
80006968:	99 38       	st.w	r12[0xc],r8
8000696a:	e0 8f 01 fa 	bral	80006d5e <_malloc_r+0x416>
8000696e:	fe b0 f2 4f 	rcall	80004e0c <__malloc_lock>
80006972:	e0 47 01 f7 	cp.w	r7,503
80006976:	e0 8b 00 1d 	brhi	800069b0 <_malloc_r+0x68>
8000697a:	ee 03 16 03 	lsr	r3,r7,0x3
8000697e:	e0 68 01 1c 	mov	r8,284
80006982:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006986:	70 36       	ld.w	r6,r8[0xc]
80006988:	10 36       	cp.w	r6,r8
8000698a:	c0 61       	brne	80006996 <_malloc_r+0x4e>
8000698c:	ec c8 ff f8 	sub	r8,r6,-8
80006990:	70 36       	ld.w	r6,r8[0xc]
80006992:	10 36       	cp.w	r6,r8
80006994:	c0 c0       	breq	800069ac <_malloc_r+0x64>
80006996:	6c 18       	ld.w	r8,r6[0x4]
80006998:	e0 18 ff fc 	andl	r8,0xfffc
8000699c:	6c 3a       	ld.w	r10,r6[0xc]
8000699e:	ec 08 00 09 	add	r9,r6,r8
800069a2:	0a 9c       	mov	r12,r5
800069a4:	6c 28       	ld.w	r8,r6[0x8]
800069a6:	95 28       	st.w	r10[0x8],r8
800069a8:	91 3a       	st.w	r8[0xc],r10
800069aa:	c4 78       	rjmp	80006a38 <_malloc_r+0xf0>
800069ac:	2f e3       	sub	r3,-2
800069ae:	c4 d8       	rjmp	80006a48 <_malloc_r+0x100>
800069b0:	ee 03 16 09 	lsr	r3,r7,0x9
800069b4:	c0 41       	brne	800069bc <_malloc_r+0x74>
800069b6:	ee 03 16 03 	lsr	r3,r7,0x3
800069ba:	c2 68       	rjmp	80006a06 <_malloc_r+0xbe>
800069bc:	58 43       	cp.w	r3,4
800069be:	e0 8b 00 06 	brhi	800069ca <_malloc_r+0x82>
800069c2:	ee 03 16 06 	lsr	r3,r7,0x6
800069c6:	2c 83       	sub	r3,-56
800069c8:	c1 f8       	rjmp	80006a06 <_malloc_r+0xbe>
800069ca:	59 43       	cp.w	r3,20
800069cc:	e0 8b 00 04 	brhi	800069d4 <_malloc_r+0x8c>
800069d0:	2a 53       	sub	r3,-91
800069d2:	c1 a8       	rjmp	80006a06 <_malloc_r+0xbe>
800069d4:	e0 43 00 54 	cp.w	r3,84
800069d8:	e0 8b 00 06 	brhi	800069e4 <_malloc_r+0x9c>
800069dc:	ee 03 16 0c 	lsr	r3,r7,0xc
800069e0:	29 23       	sub	r3,-110
800069e2:	c1 28       	rjmp	80006a06 <_malloc_r+0xbe>
800069e4:	e0 43 01 54 	cp.w	r3,340
800069e8:	e0 8b 00 06 	brhi	800069f4 <_malloc_r+0xac>
800069ec:	ee 03 16 0f 	lsr	r3,r7,0xf
800069f0:	28 93       	sub	r3,-119
800069f2:	c0 a8       	rjmp	80006a06 <_malloc_r+0xbe>
800069f4:	e0 43 05 54 	cp.w	r3,1364
800069f8:	e0 88 00 04 	brls	80006a00 <_malloc_r+0xb8>
800069fc:	37 e3       	mov	r3,126
800069fe:	c0 48       	rjmp	80006a06 <_malloc_r+0xbe>
80006a00:	ee 03 16 12 	lsr	r3,r7,0x12
80006a04:	28 43       	sub	r3,-124
80006a06:	e0 6a 01 1c 	mov	r10,284
80006a0a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006a0e:	74 36       	ld.w	r6,r10[0xc]
80006a10:	c1 98       	rjmp	80006a42 <_malloc_r+0xfa>
80006a12:	6c 19       	ld.w	r9,r6[0x4]
80006a14:	e0 19 ff fc 	andl	r9,0xfffc
80006a18:	f2 07 01 0b 	sub	r11,r9,r7
80006a1c:	58 fb       	cp.w	r11,15
80006a1e:	e0 8a 00 04 	brle	80006a26 <_malloc_r+0xde>
80006a22:	20 13       	sub	r3,1
80006a24:	c1 18       	rjmp	80006a46 <_malloc_r+0xfe>
80006a26:	6c 38       	ld.w	r8,r6[0xc]
80006a28:	58 0b       	cp.w	r11,0
80006a2a:	c0 b5       	brlt	80006a40 <_malloc_r+0xf8>
80006a2c:	6c 2a       	ld.w	r10,r6[0x8]
80006a2e:	ec 09 00 09 	add	r9,r6,r9
80006a32:	0a 9c       	mov	r12,r5
80006a34:	91 2a       	st.w	r8[0x8],r10
80006a36:	95 38       	st.w	r10[0xc],r8
80006a38:	72 18       	ld.w	r8,r9[0x4]
80006a3a:	a1 a8       	sbr	r8,0x0
80006a3c:	93 18       	st.w	r9[0x4],r8
80006a3e:	cb c8       	rjmp	80006bb6 <_malloc_r+0x26e>
80006a40:	10 96       	mov	r6,r8
80006a42:	14 36       	cp.w	r6,r10
80006a44:	ce 71       	brne	80006a12 <_malloc_r+0xca>
80006a46:	2f f3       	sub	r3,-1
80006a48:	e0 6a 01 1c 	mov	r10,284
80006a4c:	f4 cc ff f8 	sub	r12,r10,-8
80006a50:	78 26       	ld.w	r6,r12[0x8]
80006a52:	18 36       	cp.w	r6,r12
80006a54:	c6 c0       	breq	80006b2c <_malloc_r+0x1e4>
80006a56:	6c 19       	ld.w	r9,r6[0x4]
80006a58:	e0 19 ff fc 	andl	r9,0xfffc
80006a5c:	f2 07 01 08 	sub	r8,r9,r7
80006a60:	58 f8       	cp.w	r8,15
80006a62:	e0 89 00 8f 	brgt	80006b80 <_malloc_r+0x238>
80006a66:	99 3c       	st.w	r12[0xc],r12
80006a68:	99 2c       	st.w	r12[0x8],r12
80006a6a:	58 08       	cp.w	r8,0
80006a6c:	c0 55       	brlt	80006a76 <_malloc_r+0x12e>
80006a6e:	ec 09 00 09 	add	r9,r6,r9
80006a72:	0a 9c       	mov	r12,r5
80006a74:	ce 2b       	rjmp	80006a38 <_malloc_r+0xf0>
80006a76:	e0 49 01 ff 	cp.w	r9,511
80006a7a:	e0 8b 00 13 	brhi	80006aa0 <_malloc_r+0x158>
80006a7e:	a3 99       	lsr	r9,0x3
80006a80:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006a84:	70 2b       	ld.w	r11,r8[0x8]
80006a86:	8d 38       	st.w	r6[0xc],r8
80006a88:	8d 2b       	st.w	r6[0x8],r11
80006a8a:	97 36       	st.w	r11[0xc],r6
80006a8c:	91 26       	st.w	r8[0x8],r6
80006a8e:	a3 49       	asr	r9,0x2
80006a90:	74 18       	ld.w	r8,r10[0x4]
80006a92:	30 1b       	mov	r11,1
80006a94:	f6 09 09 49 	lsl	r9,r11,r9
80006a98:	f1 e9 10 09 	or	r9,r8,r9
80006a9c:	95 19       	st.w	r10[0x4],r9
80006a9e:	c4 78       	rjmp	80006b2c <_malloc_r+0x1e4>
80006aa0:	f2 0a 16 09 	lsr	r10,r9,0x9
80006aa4:	58 4a       	cp.w	r10,4
80006aa6:	e0 8b 00 07 	brhi	80006ab4 <_malloc_r+0x16c>
80006aaa:	f2 0a 16 06 	lsr	r10,r9,0x6
80006aae:	2c 8a       	sub	r10,-56
80006ab0:	c2 08       	rjmp	80006af0 <_malloc_r+0x1a8>
80006ab2:	d7 03       	nop
80006ab4:	59 4a       	cp.w	r10,20
80006ab6:	e0 8b 00 04 	brhi	80006abe <_malloc_r+0x176>
80006aba:	2a 5a       	sub	r10,-91
80006abc:	c1 a8       	rjmp	80006af0 <_malloc_r+0x1a8>
80006abe:	e0 4a 00 54 	cp.w	r10,84
80006ac2:	e0 8b 00 06 	brhi	80006ace <_malloc_r+0x186>
80006ac6:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006aca:	29 2a       	sub	r10,-110
80006acc:	c1 28       	rjmp	80006af0 <_malloc_r+0x1a8>
80006ace:	e0 4a 01 54 	cp.w	r10,340
80006ad2:	e0 8b 00 06 	brhi	80006ade <_malloc_r+0x196>
80006ad6:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006ada:	28 9a       	sub	r10,-119
80006adc:	c0 a8       	rjmp	80006af0 <_malloc_r+0x1a8>
80006ade:	e0 4a 05 54 	cp.w	r10,1364
80006ae2:	e0 88 00 04 	brls	80006aea <_malloc_r+0x1a2>
80006ae6:	37 ea       	mov	r10,126
80006ae8:	c0 48       	rjmp	80006af0 <_malloc_r+0x1a8>
80006aea:	f2 0a 16 12 	lsr	r10,r9,0x12
80006aee:	28 4a       	sub	r10,-124
80006af0:	e0 6b 01 1c 	mov	r11,284
80006af4:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006af8:	68 28       	ld.w	r8,r4[0x8]
80006afa:	08 38       	cp.w	r8,r4
80006afc:	c0 e1       	brne	80006b18 <_malloc_r+0x1d0>
80006afe:	76 19       	ld.w	r9,r11[0x4]
80006b00:	a3 4a       	asr	r10,0x2
80006b02:	30 1e       	mov	lr,1
80006b04:	fc 0a 09 4a 	lsl	r10,lr,r10
80006b08:	f3 ea 10 0a 	or	r10,r9,r10
80006b0c:	10 99       	mov	r9,r8
80006b0e:	97 1a       	st.w	r11[0x4],r10
80006b10:	c0 a8       	rjmp	80006b24 <_malloc_r+0x1dc>
80006b12:	70 28       	ld.w	r8,r8[0x8]
80006b14:	08 38       	cp.w	r8,r4
80006b16:	c0 60       	breq	80006b22 <_malloc_r+0x1da>
80006b18:	70 1a       	ld.w	r10,r8[0x4]
80006b1a:	e0 1a ff fc 	andl	r10,0xfffc
80006b1e:	14 39       	cp.w	r9,r10
80006b20:	cf 93       	brcs	80006b12 <_malloc_r+0x1ca>
80006b22:	70 39       	ld.w	r9,r8[0xc]
80006b24:	8d 39       	st.w	r6[0xc],r9
80006b26:	8d 28       	st.w	r6[0x8],r8
80006b28:	91 36       	st.w	r8[0xc],r6
80006b2a:	93 26       	st.w	r9[0x8],r6
80006b2c:	e6 08 14 02 	asr	r8,r3,0x2
80006b30:	30 1b       	mov	r11,1
80006b32:	e0 64 01 1c 	mov	r4,284
80006b36:	f6 08 09 4b 	lsl	r11,r11,r8
80006b3a:	68 18       	ld.w	r8,r4[0x4]
80006b3c:	10 3b       	cp.w	r11,r8
80006b3e:	e0 8b 00 6b 	brhi	80006c14 <_malloc_r+0x2cc>
80006b42:	f7 e8 00 09 	and	r9,r11,r8
80006b46:	c0 b1       	brne	80006b5c <_malloc_r+0x214>
80006b48:	e0 13 ff fc 	andl	r3,0xfffc
80006b4c:	a1 7b       	lsl	r11,0x1
80006b4e:	2f c3       	sub	r3,-4
80006b50:	c0 38       	rjmp	80006b56 <_malloc_r+0x20e>
80006b52:	2f c3       	sub	r3,-4
80006b54:	a1 7b       	lsl	r11,0x1
80006b56:	f7 e8 00 09 	and	r9,r11,r8
80006b5a:	cf c0       	breq	80006b52 <_malloc_r+0x20a>
80006b5c:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006b60:	06 92       	mov	r2,r3
80006b62:	1c 91       	mov	r1,lr
80006b64:	62 36       	ld.w	r6,r1[0xc]
80006b66:	c2 e8       	rjmp	80006bc2 <_malloc_r+0x27a>
80006b68:	6c 1a       	ld.w	r10,r6[0x4]
80006b6a:	e0 1a ff fc 	andl	r10,0xfffc
80006b6e:	f4 07 01 08 	sub	r8,r10,r7
80006b72:	58 f8       	cp.w	r8,15
80006b74:	e0 8a 00 15 	brle	80006b9e <_malloc_r+0x256>
80006b78:	6c 3a       	ld.w	r10,r6[0xc]
80006b7a:	6c 29       	ld.w	r9,r6[0x8]
80006b7c:	95 29       	st.w	r10[0x8],r9
80006b7e:	93 3a       	st.w	r9[0xc],r10
80006b80:	0e 99       	mov	r9,r7
80006b82:	ec 07 00 07 	add	r7,r6,r7
80006b86:	a1 a9       	sbr	r9,0x0
80006b88:	99 37       	st.w	r12[0xc],r7
80006b8a:	99 27       	st.w	r12[0x8],r7
80006b8c:	8d 19       	st.w	r6[0x4],r9
80006b8e:	ee 08 09 08 	st.w	r7[r8],r8
80006b92:	8f 2c       	st.w	r7[0x8],r12
80006b94:	8f 3c       	st.w	r7[0xc],r12
80006b96:	a1 a8       	sbr	r8,0x0
80006b98:	0a 9c       	mov	r12,r5
80006b9a:	8f 18       	st.w	r7[0x4],r8
80006b9c:	c0 d8       	rjmp	80006bb6 <_malloc_r+0x26e>
80006b9e:	6c 39       	ld.w	r9,r6[0xc]
80006ba0:	58 08       	cp.w	r8,0
80006ba2:	c0 f5       	brlt	80006bc0 <_malloc_r+0x278>
80006ba4:	ec 0a 00 0a 	add	r10,r6,r10
80006ba8:	74 18       	ld.w	r8,r10[0x4]
80006baa:	a1 a8       	sbr	r8,0x0
80006bac:	0a 9c       	mov	r12,r5
80006bae:	95 18       	st.w	r10[0x4],r8
80006bb0:	6c 28       	ld.w	r8,r6[0x8]
80006bb2:	93 28       	st.w	r9[0x8],r8
80006bb4:	91 39       	st.w	r8[0xc],r9
80006bb6:	fe b0 f1 39 	rcall	80004e28 <__malloc_unlock>
80006bba:	ec cc ff f8 	sub	r12,r6,-8
80006bbe:	d8 32       	popm	r0-r7,pc
80006bc0:	12 96       	mov	r6,r9
80006bc2:	02 36       	cp.w	r6,r1
80006bc4:	cd 21       	brne	80006b68 <_malloc_r+0x220>
80006bc6:	2f f2       	sub	r2,-1
80006bc8:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006bcc:	c0 30       	breq	80006bd2 <_malloc_r+0x28a>
80006bce:	2f 81       	sub	r1,-8
80006bd0:	cc ab       	rjmp	80006b64 <_malloc_r+0x21c>
80006bd2:	1c 98       	mov	r8,lr
80006bd4:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006bd8:	c0 81       	brne	80006be8 <_malloc_r+0x2a0>
80006bda:	68 19       	ld.w	r9,r4[0x4]
80006bdc:	f6 08 11 ff 	rsub	r8,r11,-1
80006be0:	f3 e8 00 08 	and	r8,r9,r8
80006be4:	89 18       	st.w	r4[0x4],r8
80006be6:	c0 78       	rjmp	80006bf4 <_malloc_r+0x2ac>
80006be8:	f0 c9 00 08 	sub	r9,r8,8
80006bec:	20 13       	sub	r3,1
80006bee:	70 08       	ld.w	r8,r8[0x0]
80006bf0:	12 38       	cp.w	r8,r9
80006bf2:	cf 10       	breq	80006bd4 <_malloc_r+0x28c>
80006bf4:	a1 7b       	lsl	r11,0x1
80006bf6:	68 18       	ld.w	r8,r4[0x4]
80006bf8:	10 3b       	cp.w	r11,r8
80006bfa:	e0 8b 00 0d 	brhi	80006c14 <_malloc_r+0x2cc>
80006bfe:	58 0b       	cp.w	r11,0
80006c00:	c0 a0       	breq	80006c14 <_malloc_r+0x2cc>
80006c02:	04 93       	mov	r3,r2
80006c04:	c0 38       	rjmp	80006c0a <_malloc_r+0x2c2>
80006c06:	2f c3       	sub	r3,-4
80006c08:	a1 7b       	lsl	r11,0x1
80006c0a:	f7 e8 00 09 	and	r9,r11,r8
80006c0e:	ca 71       	brne	80006b5c <_malloc_r+0x214>
80006c10:	cf bb       	rjmp	80006c06 <_malloc_r+0x2be>
80006c12:	d7 03       	nop
80006c14:	68 23       	ld.w	r3,r4[0x8]
80006c16:	66 12       	ld.w	r2,r3[0x4]
80006c18:	e0 12 ff fc 	andl	r2,0xfffc
80006c1c:	0e 32       	cp.w	r2,r7
80006c1e:	5f 39       	srlo	r9
80006c20:	e4 07 01 08 	sub	r8,r2,r7
80006c24:	58 f8       	cp.w	r8,15
80006c26:	5f aa       	srle	r10
80006c28:	f5 e9 10 09 	or	r9,r10,r9
80006c2c:	e0 80 00 9a 	breq	80006d60 <_malloc_r+0x418>
80006c30:	e0 68 07 a4 	mov	r8,1956
80006c34:	70 01       	ld.w	r1,r8[0x0]
80006c36:	e0 68 05 28 	mov	r8,1320
80006c3a:	2f 01       	sub	r1,-16
80006c3c:	70 08       	ld.w	r8,r8[0x0]
80006c3e:	0e 01       	add	r1,r7
80006c40:	5b f8       	cp.w	r8,-1
80006c42:	c0 40       	breq	80006c4a <_malloc_r+0x302>
80006c44:	28 11       	sub	r1,-127
80006c46:	e0 11 ff 80 	andl	r1,0xff80
80006c4a:	02 9b       	mov	r11,r1
80006c4c:	0a 9c       	mov	r12,r5
80006c4e:	e0 a0 02 a5 	rcall	80007198 <_sbrk_r>
80006c52:	18 96       	mov	r6,r12
80006c54:	5b fc       	cp.w	r12,-1
80006c56:	c7 50       	breq	80006d40 <_malloc_r+0x3f8>
80006c58:	e6 02 00 08 	add	r8,r3,r2
80006c5c:	10 3c       	cp.w	r12,r8
80006c5e:	c0 32       	brcc	80006c64 <_malloc_r+0x31c>
80006c60:	08 33       	cp.w	r3,r4
80006c62:	c6 f1       	brne	80006d40 <_malloc_r+0x3f8>
80006c64:	e0 6a 07 a8 	mov	r10,1960
80006c68:	74 09       	ld.w	r9,r10[0x0]
80006c6a:	e2 09 00 09 	add	r9,r1,r9
80006c6e:	95 09       	st.w	r10[0x0],r9
80006c70:	10 36       	cp.w	r6,r8
80006c72:	c0 a1       	brne	80006c86 <_malloc_r+0x33e>
80006c74:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006c78:	c0 71       	brne	80006c86 <_malloc_r+0x33e>
80006c7a:	e2 02 00 02 	add	r2,r1,r2
80006c7e:	68 28       	ld.w	r8,r4[0x8]
80006c80:	a1 a2       	sbr	r2,0x0
80006c82:	91 12       	st.w	r8[0x4],r2
80006c84:	c4 f8       	rjmp	80006d22 <_malloc_r+0x3da>
80006c86:	e0 6a 05 28 	mov	r10,1320
80006c8a:	74 0b       	ld.w	r11,r10[0x0]
80006c8c:	5b fb       	cp.w	r11,-1
80006c8e:	c0 31       	brne	80006c94 <_malloc_r+0x34c>
80006c90:	95 06       	st.w	r10[0x0],r6
80006c92:	c0 78       	rjmp	80006ca0 <_malloc_r+0x358>
80006c94:	ec 09 00 09 	add	r9,r6,r9
80006c98:	e0 6a 07 a8 	mov	r10,1960
80006c9c:	10 19       	sub	r9,r8
80006c9e:	95 09       	st.w	r10[0x0],r9
80006ca0:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006ca4:	f0 09 11 08 	rsub	r9,r8,8
80006ca8:	58 08       	cp.w	r8,0
80006caa:	f2 08 17 10 	movne	r8,r9
80006cae:	ed d8 e1 06 	addne	r6,r6,r8
80006cb2:	28 08       	sub	r8,-128
80006cb4:	ec 01 00 01 	add	r1,r6,r1
80006cb8:	0a 9c       	mov	r12,r5
80006cba:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006cbe:	f0 01 01 01 	sub	r1,r8,r1
80006cc2:	02 9b       	mov	r11,r1
80006cc4:	e0 a0 02 6a 	rcall	80007198 <_sbrk_r>
80006cc8:	e0 68 07 a8 	mov	r8,1960
80006ccc:	5b fc       	cp.w	r12,-1
80006cce:	ec 0c 17 00 	moveq	r12,r6
80006cd2:	f9 b1 00 00 	moveq	r1,0
80006cd6:	70 09       	ld.w	r9,r8[0x0]
80006cd8:	0c 1c       	sub	r12,r6
80006cda:	89 26       	st.w	r4[0x8],r6
80006cdc:	02 0c       	add	r12,r1
80006cde:	12 01       	add	r1,r9
80006ce0:	a1 ac       	sbr	r12,0x0
80006ce2:	91 01       	st.w	r8[0x0],r1
80006ce4:	8d 1c       	st.w	r6[0x4],r12
80006ce6:	08 33       	cp.w	r3,r4
80006ce8:	c1 d0       	breq	80006d22 <_malloc_r+0x3da>
80006cea:	58 f2       	cp.w	r2,15
80006cec:	e0 8b 00 05 	brhi	80006cf6 <_malloc_r+0x3ae>
80006cf0:	30 18       	mov	r8,1
80006cf2:	8d 18       	st.w	r6[0x4],r8
80006cf4:	c2 68       	rjmp	80006d40 <_malloc_r+0x3f8>
80006cf6:	30 59       	mov	r9,5
80006cf8:	20 c2       	sub	r2,12
80006cfa:	e0 12 ff f8 	andl	r2,0xfff8
80006cfe:	e6 02 00 08 	add	r8,r3,r2
80006d02:	91 29       	st.w	r8[0x8],r9
80006d04:	91 19       	st.w	r8[0x4],r9
80006d06:	66 18       	ld.w	r8,r3[0x4]
80006d08:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006d0c:	e5 e8 10 08 	or	r8,r2,r8
80006d10:	87 18       	st.w	r3[0x4],r8
80006d12:	58 f2       	cp.w	r2,15
80006d14:	e0 88 00 07 	brls	80006d22 <_malloc_r+0x3da>
80006d18:	e6 cb ff f8 	sub	r11,r3,-8
80006d1c:	0a 9c       	mov	r12,r5
80006d1e:	e0 a0 1d 4f 	rcall	8000a7bc <_free_r>
80006d22:	e0 69 07 a0 	mov	r9,1952
80006d26:	72 0a       	ld.w	r10,r9[0x0]
80006d28:	e0 68 07 a8 	mov	r8,1960
80006d2c:	70 08       	ld.w	r8,r8[0x0]
80006d2e:	14 38       	cp.w	r8,r10
80006d30:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006d34:	e0 69 07 9c 	mov	r9,1948
80006d38:	72 0a       	ld.w	r10,r9[0x0]
80006d3a:	14 38       	cp.w	r8,r10
80006d3c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006d40:	68 28       	ld.w	r8,r4[0x8]
80006d42:	70 18       	ld.w	r8,r8[0x4]
80006d44:	e0 18 ff fc 	andl	r8,0xfffc
80006d48:	0e 38       	cp.w	r8,r7
80006d4a:	5f 39       	srlo	r9
80006d4c:	0e 18       	sub	r8,r7
80006d4e:	58 f8       	cp.w	r8,15
80006d50:	5f aa       	srle	r10
80006d52:	f5 e9 10 09 	or	r9,r10,r9
80006d56:	c0 50       	breq	80006d60 <_malloc_r+0x418>
80006d58:	0a 9c       	mov	r12,r5
80006d5a:	fe b0 f0 67 	rcall	80004e28 <__malloc_unlock>
80006d5e:	d8 3a       	popm	r0-r7,pc,r12=0
80006d60:	68 26       	ld.w	r6,r4[0x8]
80006d62:	a1 a8       	sbr	r8,0x0
80006d64:	0e 99       	mov	r9,r7
80006d66:	a1 a9       	sbr	r9,0x0
80006d68:	8d 19       	st.w	r6[0x4],r9
80006d6a:	ec 07 00 07 	add	r7,r6,r7
80006d6e:	0a 9c       	mov	r12,r5
80006d70:	89 27       	st.w	r4[0x8],r7
80006d72:	8f 18       	st.w	r7[0x4],r8
80006d74:	fe b0 f0 5a 	rcall	80004e28 <__malloc_unlock>
80006d78:	ec cc ff f8 	sub	r12,r6,-8
80006d7c:	d8 32       	popm	r0-r7,pc
80006d7e:	d7 03       	nop

80006d80 <memcpy>:
80006d80:	58 8a       	cp.w	r10,8
80006d82:	c2 f5       	brlt	80006de0 <memcpy+0x60>
80006d84:	f9 eb 10 09 	or	r9,r12,r11
80006d88:	e2 19 00 03 	andl	r9,0x3,COH
80006d8c:	e0 81 00 97 	brne	80006eba <memcpy+0x13a>
80006d90:	e0 4a 00 20 	cp.w	r10,32
80006d94:	c3 b4       	brge	80006e0a <memcpy+0x8a>
80006d96:	f4 08 14 02 	asr	r8,r10,0x2
80006d9a:	f0 09 11 08 	rsub	r9,r8,8
80006d9e:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80006da2:	76 69       	ld.w	r9,r11[0x18]
80006da4:	99 69       	st.w	r12[0x18],r9
80006da6:	76 59       	ld.w	r9,r11[0x14]
80006da8:	99 59       	st.w	r12[0x14],r9
80006daa:	76 49       	ld.w	r9,r11[0x10]
80006dac:	99 49       	st.w	r12[0x10],r9
80006dae:	76 39       	ld.w	r9,r11[0xc]
80006db0:	99 39       	st.w	r12[0xc],r9
80006db2:	76 29       	ld.w	r9,r11[0x8]
80006db4:	99 29       	st.w	r12[0x8],r9
80006db6:	76 19       	ld.w	r9,r11[0x4]
80006db8:	99 19       	st.w	r12[0x4],r9
80006dba:	76 09       	ld.w	r9,r11[0x0]
80006dbc:	99 09       	st.w	r12[0x0],r9
80006dbe:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006dc2:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006dc6:	e0 1a 00 03 	andl	r10,0x3
80006dca:	f4 0a 11 04 	rsub	r10,r10,4
80006dce:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006dd2:	17 a9       	ld.ub	r9,r11[0x2]
80006dd4:	b0 a9       	st.b	r8[0x2],r9
80006dd6:	17 99       	ld.ub	r9,r11[0x1]
80006dd8:	b0 99       	st.b	r8[0x1],r9
80006dda:	17 89       	ld.ub	r9,r11[0x0]
80006ddc:	b0 89       	st.b	r8[0x0],r9
80006dde:	5e fc       	retal	r12
80006de0:	f4 0a 11 09 	rsub	r10,r10,9
80006de4:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006de8:	17 f9       	ld.ub	r9,r11[0x7]
80006dea:	b8 f9       	st.b	r12[0x7],r9
80006dec:	17 e9       	ld.ub	r9,r11[0x6]
80006dee:	b8 e9       	st.b	r12[0x6],r9
80006df0:	17 d9       	ld.ub	r9,r11[0x5]
80006df2:	b8 d9       	st.b	r12[0x5],r9
80006df4:	17 c9       	ld.ub	r9,r11[0x4]
80006df6:	b8 c9       	st.b	r12[0x4],r9
80006df8:	17 b9       	ld.ub	r9,r11[0x3]
80006dfa:	b8 b9       	st.b	r12[0x3],r9
80006dfc:	17 a9       	ld.ub	r9,r11[0x2]
80006dfe:	b8 a9       	st.b	r12[0x2],r9
80006e00:	17 99       	ld.ub	r9,r11[0x1]
80006e02:	b8 99       	st.b	r12[0x1],r9
80006e04:	17 89       	ld.ub	r9,r11[0x0]
80006e06:	b8 89       	st.b	r12[0x0],r9
80006e08:	5e fc       	retal	r12
80006e0a:	eb cd 40 c0 	pushm	r6-r7,lr
80006e0e:	18 99       	mov	r9,r12
80006e10:	22 0a       	sub	r10,32
80006e12:	b7 07       	ld.d	r6,r11++
80006e14:	b3 26       	st.d	r9++,r6
80006e16:	b7 07       	ld.d	r6,r11++
80006e18:	b3 26       	st.d	r9++,r6
80006e1a:	b7 07       	ld.d	r6,r11++
80006e1c:	b3 26       	st.d	r9++,r6
80006e1e:	b7 07       	ld.d	r6,r11++
80006e20:	b3 26       	st.d	r9++,r6
80006e22:	22 0a       	sub	r10,32
80006e24:	cf 74       	brge	80006e12 <memcpy+0x92>
80006e26:	2f 0a       	sub	r10,-16
80006e28:	c0 65       	brlt	80006e34 <memcpy+0xb4>
80006e2a:	b7 07       	ld.d	r6,r11++
80006e2c:	b3 26       	st.d	r9++,r6
80006e2e:	b7 07       	ld.d	r6,r11++
80006e30:	b3 26       	st.d	r9++,r6
80006e32:	21 0a       	sub	r10,16
80006e34:	5c 3a       	neg	r10
80006e36:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006e3a:	d7 03       	nop
80006e3c:	d7 03       	nop
80006e3e:	f7 36 00 0e 	ld.ub	r6,r11[14]
80006e42:	f3 66 00 0e 	st.b	r9[14],r6
80006e46:	f7 36 00 0d 	ld.ub	r6,r11[13]
80006e4a:	f3 66 00 0d 	st.b	r9[13],r6
80006e4e:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006e52:	f3 66 00 0c 	st.b	r9[12],r6
80006e56:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006e5a:	f3 66 00 0b 	st.b	r9[11],r6
80006e5e:	f7 36 00 0a 	ld.ub	r6,r11[10]
80006e62:	f3 66 00 0a 	st.b	r9[10],r6
80006e66:	f7 36 00 09 	ld.ub	r6,r11[9]
80006e6a:	f3 66 00 09 	st.b	r9[9],r6
80006e6e:	f7 36 00 08 	ld.ub	r6,r11[8]
80006e72:	f3 66 00 08 	st.b	r9[8],r6
80006e76:	f7 36 00 07 	ld.ub	r6,r11[7]
80006e7a:	f3 66 00 07 	st.b	r9[7],r6
80006e7e:	f7 36 00 06 	ld.ub	r6,r11[6]
80006e82:	f3 66 00 06 	st.b	r9[6],r6
80006e86:	f7 36 00 05 	ld.ub	r6,r11[5]
80006e8a:	f3 66 00 05 	st.b	r9[5],r6
80006e8e:	f7 36 00 04 	ld.ub	r6,r11[4]
80006e92:	f3 66 00 04 	st.b	r9[4],r6
80006e96:	f7 36 00 03 	ld.ub	r6,r11[3]
80006e9a:	f3 66 00 03 	st.b	r9[3],r6
80006e9e:	f7 36 00 02 	ld.ub	r6,r11[2]
80006ea2:	f3 66 00 02 	st.b	r9[2],r6
80006ea6:	f7 36 00 01 	ld.ub	r6,r11[1]
80006eaa:	f3 66 00 01 	st.b	r9[1],r6
80006eae:	f7 36 00 00 	ld.ub	r6,r11[0]
80006eb2:	f3 66 00 00 	st.b	r9[0],r6
80006eb6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006eba:	20 1a       	sub	r10,1
80006ebc:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006ec0:	f8 0a 0b 09 	st.b	r12[r10],r9
80006ec4:	cf b1       	brne	80006eba <memcpy+0x13a>
80006ec6:	5e fc       	retal	r12

80006ec8 <memset>:
80006ec8:	18 98       	mov	r8,r12
80006eca:	c0 38       	rjmp	80006ed0 <memset+0x8>
80006ecc:	10 cb       	st.b	r8++,r11
80006ece:	20 1a       	sub	r10,1
80006ed0:	58 0a       	cp.w	r10,0
80006ed2:	cf d1       	brne	80006ecc <memset+0x4>
80006ed4:	5e fc       	retal	r12
80006ed6:	d7 03       	nop

80006ed8 <_realloc_r>:
80006ed8:	d4 31       	pushm	r0-r7,lr
80006eda:	20 1d       	sub	sp,4
80006edc:	16 94       	mov	r4,r11
80006ede:	18 92       	mov	r2,r12
80006ee0:	14 9b       	mov	r11,r10
80006ee2:	58 04       	cp.w	r4,0
80006ee4:	c0 51       	brne	80006eee <_realloc_r+0x16>
80006ee6:	fe b0 fd 31 	rcall	80006948 <_malloc_r>
80006eea:	18 95       	mov	r5,r12
80006eec:	c5 39       	rjmp	80007192 <_realloc_r+0x2ba>
80006eee:	50 0a       	stdsp	sp[0x0],r10
80006ef0:	fe b0 ef 8e 	rcall	80004e0c <__malloc_lock>
80006ef4:	40 0b       	lddsp	r11,sp[0x0]
80006ef6:	f6 c8 ff f5 	sub	r8,r11,-11
80006efa:	e8 c1 00 08 	sub	r1,r4,8
80006efe:	10 96       	mov	r6,r8
80006f00:	62 1c       	ld.w	r12,r1[0x4]
80006f02:	e0 16 ff f8 	andl	r6,0xfff8
80006f06:	59 68       	cp.w	r8,22
80006f08:	f9 b6 08 10 	movls	r6,16
80006f0c:	16 36       	cp.w	r6,r11
80006f0e:	5f 38       	srlo	r8
80006f10:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006f14:	c0 50       	breq	80006f1e <_realloc_r+0x46>
80006f16:	30 c8       	mov	r8,12
80006f18:	30 05       	mov	r5,0
80006f1a:	85 38       	st.w	r2[0xc],r8
80006f1c:	c3 b9       	rjmp	80007192 <_realloc_r+0x2ba>
80006f1e:	18 90       	mov	r0,r12
80006f20:	e0 10 ff fc 	andl	r0,0xfffc
80006f24:	0c 30       	cp.w	r0,r6
80006f26:	e0 84 01 0b 	brge	8000713c <_realloc_r+0x264>
80006f2a:	e0 68 01 1c 	mov	r8,284
80006f2e:	e2 00 00 09 	add	r9,r1,r0
80006f32:	70 25       	ld.w	r5,r8[0x8]
80006f34:	0a 39       	cp.w	r9,r5
80006f36:	c0 90       	breq	80006f48 <_realloc_r+0x70>
80006f38:	72 1a       	ld.w	r10,r9[0x4]
80006f3a:	a1 ca       	cbr	r10,0x0
80006f3c:	f2 0a 00 0a 	add	r10,r9,r10
80006f40:	74 1a       	ld.w	r10,r10[0x4]
80006f42:	ed ba 00 00 	bld	r10,0x0
80006f46:	c2 20       	breq	80006f8a <_realloc_r+0xb2>
80006f48:	72 1a       	ld.w	r10,r9[0x4]
80006f4a:	e0 1a ff fc 	andl	r10,0xfffc
80006f4e:	f4 00 00 03 	add	r3,r10,r0
80006f52:	0a 39       	cp.w	r9,r5
80006f54:	c1 31       	brne	80006f7a <_realloc_r+0xa2>
80006f56:	ec c7 ff f0 	sub	r7,r6,-16
80006f5a:	0e 33       	cp.w	r3,r7
80006f5c:	c1 95       	brlt	80006f8e <_realloc_r+0xb6>
80006f5e:	e2 06 00 09 	add	r9,r1,r6
80006f62:	0c 13       	sub	r3,r6
80006f64:	a1 a3       	sbr	r3,0x0
80006f66:	93 13       	st.w	r9[0x4],r3
80006f68:	91 29       	st.w	r8[0x8],r9
80006f6a:	04 9c       	mov	r12,r2
80006f6c:	62 18       	ld.w	r8,r1[0x4]
80006f6e:	08 95       	mov	r5,r4
80006f70:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006f74:	10 46       	or	r6,r8
80006f76:	83 16       	st.w	r1[0x4],r6
80006f78:	c0 b9       	rjmp	8000718e <_realloc_r+0x2b6>
80006f7a:	0c 33       	cp.w	r3,r6
80006f7c:	c0 95       	brlt	80006f8e <_realloc_r+0xb6>
80006f7e:	72 28       	ld.w	r8,r9[0x8]
80006f80:	02 97       	mov	r7,r1
80006f82:	72 39       	ld.w	r9,r9[0xc]
80006f84:	93 28       	st.w	r9[0x8],r8
80006f86:	91 39       	st.w	r8[0xc],r9
80006f88:	cd c8       	rjmp	80007140 <_realloc_r+0x268>
80006f8a:	30 0a       	mov	r10,0
80006f8c:	14 99       	mov	r9,r10
80006f8e:	ed bc 00 00 	bld	r12,0x0
80006f92:	e0 80 00 95 	breq	800070bc <_realloc_r+0x1e4>
80006f96:	62 07       	ld.w	r7,r1[0x0]
80006f98:	e2 07 01 07 	sub	r7,r1,r7
80006f9c:	6e 1c       	ld.w	r12,r7[0x4]
80006f9e:	e0 1c ff fc 	andl	r12,0xfffc
80006fa2:	58 09       	cp.w	r9,0
80006fa4:	c5 60       	breq	80007050 <_realloc_r+0x178>
80006fa6:	f8 00 00 03 	add	r3,r12,r0
80006faa:	0a 39       	cp.w	r9,r5
80006fac:	c4 81       	brne	8000703c <_realloc_r+0x164>
80006fae:	14 03       	add	r3,r10
80006fb0:	ec c9 ff f0 	sub	r9,r6,-16
80006fb4:	12 33       	cp.w	r3,r9
80006fb6:	c4 d5       	brlt	80007050 <_realloc_r+0x178>
80006fb8:	6e 3a       	ld.w	r10,r7[0xc]
80006fba:	6e 29       	ld.w	r9,r7[0x8]
80006fbc:	95 29       	st.w	r10[0x8],r9
80006fbe:	93 3a       	st.w	r9[0xc],r10
80006fc0:	ee c5 ff f8 	sub	r5,r7,-8
80006fc4:	e0 ca 00 04 	sub	r10,r0,4
80006fc8:	e0 4a 00 24 	cp.w	r10,36
80006fcc:	e0 8b 00 25 	brhi	80007016 <_realloc_r+0x13e>
80006fd0:	0a 99       	mov	r9,r5
80006fd2:	59 3a       	cp.w	r10,19
80006fd4:	e0 88 00 1a 	brls	80007008 <_realloc_r+0x130>
80006fd8:	09 09       	ld.w	r9,r4++
80006fda:	8b 09       	st.w	r5[0x0],r9
80006fdc:	09 09       	ld.w	r9,r4++
80006fde:	8f 39       	st.w	r7[0xc],r9
80006fe0:	ee c9 ff f0 	sub	r9,r7,-16
80006fe4:	59 ba       	cp.w	r10,27
80006fe6:	e0 88 00 11 	brls	80007008 <_realloc_r+0x130>
80006fea:	09 0b       	ld.w	r11,r4++
80006fec:	93 0b       	st.w	r9[0x0],r11
80006fee:	09 09       	ld.w	r9,r4++
80006ff0:	8f 59       	st.w	r7[0x14],r9
80006ff2:	ee c9 ff e8 	sub	r9,r7,-24
80006ff6:	e0 4a 00 24 	cp.w	r10,36
80006ffa:	c0 71       	brne	80007008 <_realloc_r+0x130>
80006ffc:	09 0a       	ld.w	r10,r4++
80006ffe:	93 0a       	st.w	r9[0x0],r10
80007000:	ee c9 ff e0 	sub	r9,r7,-32
80007004:	09 0a       	ld.w	r10,r4++
80007006:	8f 7a       	st.w	r7[0x1c],r10
80007008:	09 0a       	ld.w	r10,r4++
8000700a:	12 aa       	st.w	r9++,r10
8000700c:	68 0a       	ld.w	r10,r4[0x0]
8000700e:	93 0a       	st.w	r9[0x0],r10
80007010:	68 1a       	ld.w	r10,r4[0x4]
80007012:	93 1a       	st.w	r9[0x4],r10
80007014:	c0 78       	rjmp	80007022 <_realloc_r+0x14a>
80007016:	50 08       	stdsp	sp[0x0],r8
80007018:	08 9b       	mov	r11,r4
8000701a:	0a 9c       	mov	r12,r5
8000701c:	e0 a0 1e 73 	rcall	8000ad02 <memmove>
80007020:	40 08       	lddsp	r8,sp[0x0]
80007022:	ee 06 00 09 	add	r9,r7,r6
80007026:	0c 13       	sub	r3,r6
80007028:	a1 a3       	sbr	r3,0x0
8000702a:	93 13       	st.w	r9[0x4],r3
8000702c:	91 29       	st.w	r8[0x8],r9
8000702e:	04 9c       	mov	r12,r2
80007030:	6e 18       	ld.w	r8,r7[0x4]
80007032:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007036:	10 46       	or	r6,r8
80007038:	8f 16       	st.w	r7[0x4],r6
8000703a:	ca a8       	rjmp	8000718e <_realloc_r+0x2b6>
8000703c:	14 03       	add	r3,r10
8000703e:	0c 33       	cp.w	r3,r6
80007040:	c0 85       	brlt	80007050 <_realloc_r+0x178>
80007042:	72 28       	ld.w	r8,r9[0x8]
80007044:	72 39       	ld.w	r9,r9[0xc]
80007046:	93 28       	st.w	r9[0x8],r8
80007048:	91 39       	st.w	r8[0xc],r9
8000704a:	6e 28       	ld.w	r8,r7[0x8]
8000704c:	6e 39       	ld.w	r9,r7[0xc]
8000704e:	c0 78       	rjmp	8000705c <_realloc_r+0x184>
80007050:	f8 00 00 03 	add	r3,r12,r0
80007054:	0c 33       	cp.w	r3,r6
80007056:	c3 35       	brlt	800070bc <_realloc_r+0x1e4>
80007058:	6e 39       	ld.w	r9,r7[0xc]
8000705a:	6e 28       	ld.w	r8,r7[0x8]
8000705c:	93 28       	st.w	r9[0x8],r8
8000705e:	91 39       	st.w	r8[0xc],r9
80007060:	e0 ca 00 04 	sub	r10,r0,4
80007064:	ee cc ff f8 	sub	r12,r7,-8
80007068:	e0 4a 00 24 	cp.w	r10,36
8000706c:	e0 8b 00 24 	brhi	800070b4 <_realloc_r+0x1dc>
80007070:	59 3a       	cp.w	r10,19
80007072:	e0 88 00 1a 	brls	800070a6 <_realloc_r+0x1ce>
80007076:	09 08       	ld.w	r8,r4++
80007078:	99 08       	st.w	r12[0x0],r8
8000707a:	09 08       	ld.w	r8,r4++
8000707c:	8f 38       	st.w	r7[0xc],r8
8000707e:	ee cc ff f0 	sub	r12,r7,-16
80007082:	59 ba       	cp.w	r10,27
80007084:	e0 88 00 11 	brls	800070a6 <_realloc_r+0x1ce>
80007088:	09 08       	ld.w	r8,r4++
8000708a:	99 08       	st.w	r12[0x0],r8
8000708c:	09 08       	ld.w	r8,r4++
8000708e:	8f 58       	st.w	r7[0x14],r8
80007090:	ee cc ff e8 	sub	r12,r7,-24
80007094:	e0 4a 00 24 	cp.w	r10,36
80007098:	c0 71       	brne	800070a6 <_realloc_r+0x1ce>
8000709a:	09 08       	ld.w	r8,r4++
8000709c:	99 08       	st.w	r12[0x0],r8
8000709e:	ee cc ff e0 	sub	r12,r7,-32
800070a2:	09 08       	ld.w	r8,r4++
800070a4:	8f 78       	st.w	r7[0x1c],r8
800070a6:	09 08       	ld.w	r8,r4++
800070a8:	18 a8       	st.w	r12++,r8
800070aa:	68 08       	ld.w	r8,r4[0x0]
800070ac:	99 08       	st.w	r12[0x0],r8
800070ae:	68 18       	ld.w	r8,r4[0x4]
800070b0:	99 18       	st.w	r12[0x4],r8
800070b2:	c4 78       	rjmp	80007140 <_realloc_r+0x268>
800070b4:	08 9b       	mov	r11,r4
800070b6:	e0 a0 1e 26 	rcall	8000ad02 <memmove>
800070ba:	c4 38       	rjmp	80007140 <_realloc_r+0x268>
800070bc:	04 9c       	mov	r12,r2
800070be:	fe b0 fc 45 	rcall	80006948 <_malloc_r>
800070c2:	18 95       	mov	r5,r12
800070c4:	c3 a0       	breq	80007138 <_realloc_r+0x260>
800070c6:	62 18       	ld.w	r8,r1[0x4]
800070c8:	f8 c9 00 08 	sub	r9,r12,8
800070cc:	a1 c8       	cbr	r8,0x0
800070ce:	e2 08 00 08 	add	r8,r1,r8
800070d2:	10 39       	cp.w	r9,r8
800070d4:	c0 71       	brne	800070e2 <_realloc_r+0x20a>
800070d6:	72 13       	ld.w	r3,r9[0x4]
800070d8:	02 97       	mov	r7,r1
800070da:	e0 13 ff fc 	andl	r3,0xfffc
800070de:	00 03       	add	r3,r0
800070e0:	c3 08       	rjmp	80007140 <_realloc_r+0x268>
800070e2:	e0 ca 00 04 	sub	r10,r0,4
800070e6:	e0 4a 00 24 	cp.w	r10,36
800070ea:	e0 8b 00 20 	brhi	8000712a <_realloc_r+0x252>
800070ee:	08 99       	mov	r9,r4
800070f0:	18 98       	mov	r8,r12
800070f2:	59 3a       	cp.w	r10,19
800070f4:	e0 88 00 14 	brls	8000711c <_realloc_r+0x244>
800070f8:	13 0b       	ld.w	r11,r9++
800070fa:	10 ab       	st.w	r8++,r11
800070fc:	13 0b       	ld.w	r11,r9++
800070fe:	10 ab       	st.w	r8++,r11
80007100:	59 ba       	cp.w	r10,27
80007102:	e0 88 00 0d 	brls	8000711c <_realloc_r+0x244>
80007106:	13 0b       	ld.w	r11,r9++
80007108:	10 ab       	st.w	r8++,r11
8000710a:	13 0b       	ld.w	r11,r9++
8000710c:	10 ab       	st.w	r8++,r11
8000710e:	e0 4a 00 24 	cp.w	r10,36
80007112:	c0 51       	brne	8000711c <_realloc_r+0x244>
80007114:	13 0a       	ld.w	r10,r9++
80007116:	10 aa       	st.w	r8++,r10
80007118:	13 0a       	ld.w	r10,r9++
8000711a:	10 aa       	st.w	r8++,r10
8000711c:	13 0a       	ld.w	r10,r9++
8000711e:	10 aa       	st.w	r8++,r10
80007120:	72 0a       	ld.w	r10,r9[0x0]
80007122:	91 0a       	st.w	r8[0x0],r10
80007124:	72 19       	ld.w	r9,r9[0x4]
80007126:	91 19       	st.w	r8[0x4],r9
80007128:	c0 48       	rjmp	80007130 <_realloc_r+0x258>
8000712a:	08 9b       	mov	r11,r4
8000712c:	e0 a0 1d eb 	rcall	8000ad02 <memmove>
80007130:	08 9b       	mov	r11,r4
80007132:	04 9c       	mov	r12,r2
80007134:	e0 a0 1b 44 	rcall	8000a7bc <_free_r>
80007138:	04 9c       	mov	r12,r2
8000713a:	c2 a8       	rjmp	8000718e <_realloc_r+0x2b6>
8000713c:	00 93       	mov	r3,r0
8000713e:	02 97       	mov	r7,r1
80007140:	e6 06 01 09 	sub	r9,r3,r6
80007144:	6e 18       	ld.w	r8,r7[0x4]
80007146:	58 f9       	cp.w	r9,15
80007148:	e0 88 00 16 	brls	80007174 <_realloc_r+0x29c>
8000714c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007150:	ed e8 10 08 	or	r8,r6,r8
80007154:	8f 18       	st.w	r7[0x4],r8
80007156:	12 98       	mov	r8,r9
80007158:	a1 a8       	sbr	r8,0x0
8000715a:	ee 06 00 0b 	add	r11,r7,r6
8000715e:	f6 09 00 09 	add	r9,r11,r9
80007162:	97 18       	st.w	r11[0x4],r8
80007164:	72 18       	ld.w	r8,r9[0x4]
80007166:	a1 a8       	sbr	r8,0x0
80007168:	2f 8b       	sub	r11,-8
8000716a:	93 18       	st.w	r9[0x4],r8
8000716c:	04 9c       	mov	r12,r2
8000716e:	e0 a0 1b 27 	rcall	8000a7bc <_free_r>
80007172:	c0 b8       	rjmp	80007188 <_realloc_r+0x2b0>
80007174:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007178:	e7 e8 10 08 	or	r8,r3,r8
8000717c:	8f 18       	st.w	r7[0x4],r8
8000717e:	ee 03 00 03 	add	r3,r7,r3
80007182:	66 18       	ld.w	r8,r3[0x4]
80007184:	a1 a8       	sbr	r8,0x0
80007186:	87 18       	st.w	r3[0x4],r8
80007188:	04 9c       	mov	r12,r2
8000718a:	ee c5 ff f8 	sub	r5,r7,-8
8000718e:	fe b0 ee 4d 	rcall	80004e28 <__malloc_unlock>
80007192:	0a 9c       	mov	r12,r5
80007194:	2f fd       	sub	sp,-4
80007196:	d8 32       	popm	r0-r7,pc

80007198 <_sbrk_r>:
80007198:	d4 21       	pushm	r4-r7,lr
8000719a:	30 08       	mov	r8,0
8000719c:	18 97       	mov	r7,r12
8000719e:	e0 66 08 0c 	mov	r6,2060
800071a2:	16 9c       	mov	r12,r11
800071a4:	8d 08       	st.w	r6[0x0],r8
800071a6:	c8 fc       	rcall	800072c4 <_sbrk>
800071a8:	5b fc       	cp.w	r12,-1
800071aa:	c0 51       	brne	800071b4 <_sbrk_r+0x1c>
800071ac:	6c 08       	ld.w	r8,r6[0x0]
800071ae:	58 08       	cp.w	r8,0
800071b0:	ef f8 1a 03 	st.wne	r7[0xc],r8
800071b4:	d8 22       	popm	r4-r7,pc
800071b6:	d7 03       	nop

800071b8 <sprintf>:
800071b8:	d4 01       	pushm	lr
800071ba:	21 7d       	sub	sp,92
800071bc:	e0 68 ff ff 	mov	r8,65535
800071c0:	ea 18 7f ff 	orh	r8,0x7fff
800071c4:	50 58       	stdsp	sp[0x14],r8
800071c6:	50 28       	stdsp	sp[0x8],r8
800071c8:	e0 68 02 08 	mov	r8,520
800071cc:	ba 68       	st.h	sp[0xc],r8
800071ce:	3f f8       	mov	r8,-1
800071d0:	ba 78       	st.h	sp[0xe],r8
800071d2:	e0 68 01 18 	mov	r8,280
800071d6:	50 4c       	stdsp	sp[0x10],r12
800071d8:	16 9a       	mov	r10,r11
800071da:	50 0c       	stdsp	sp[0x0],r12
800071dc:	fa c9 ff a0 	sub	r9,sp,-96
800071e0:	70 0c       	ld.w	r12,r8[0x0]
800071e2:	1a 9b       	mov	r11,sp
800071e4:	e0 a0 02 24 	rcall	8000762c <_vfprintf_r>
800071e8:	30 09       	mov	r9,0
800071ea:	40 08       	lddsp	r8,sp[0x0]
800071ec:	b0 89       	st.b	r8[0x0],r9
800071ee:	2e 9d       	sub	sp,-92
800071f0:	d8 02       	popm	pc
800071f2:	d7 03       	nop

800071f4 <strncpy>:
800071f4:	30 08       	mov	r8,0
800071f6:	10 3a       	cp.w	r10,r8
800071f8:	5e 0c       	reteq	r12
800071fa:	f6 08 07 09 	ld.ub	r9,r11[r8]
800071fe:	f8 08 0b 09 	st.b	r12[r8],r9
80007202:	2f f8       	sub	r8,-1
80007204:	58 09       	cp.w	r9,0
80007206:	cf 81       	brne	800071f6 <strncpy+0x2>
80007208:	10 3a       	cp.w	r10,r8
8000720a:	5e 0c       	reteq	r12
8000720c:	f8 08 0b 09 	st.b	r12[r8],r9
80007210:	2f f8       	sub	r8,-1
80007212:	cf bb       	rjmp	80007208 <strncpy+0x14>

80007214 <_init_argv>:
80007214:	30 e8       	mov	r8,14
80007216:	d6 73       	breakpoint
80007218:	3f fc       	mov	r12,-1
8000721a:	35 8b       	mov	r11,88
8000721c:	5e fc       	retal	r12

8000721e <_exit>:
8000721e:	30 d8       	mov	r8,13
80007220:	d6 73       	breakpoint
80007222:	3f fc       	mov	r12,-1
80007224:	35 8b       	mov	r11,88
80007226:	c0 08       	rjmp	80007226 <_exit+0x8>

80007228 <_close>:
80007228:	30 28       	mov	r8,2
8000722a:	d6 73       	breakpoint
8000722c:	3f fc       	mov	r12,-1
8000722e:	35 8b       	mov	r11,88
80007230:	58 0c       	cp.w	r12,0
80007232:	5e 4c       	retge	r12
80007234:	e0 6a 08 0c 	mov	r10,2060
80007238:	95 0b       	st.w	r10[0x0],r11
8000723a:	5e fc       	retal	r12

8000723c <_lseek>:
8000723c:	30 58       	mov	r8,5
8000723e:	d6 73       	breakpoint
80007240:	3f fc       	mov	r12,-1
80007242:	35 8b       	mov	r11,88
80007244:	58 0c       	cp.w	r12,0
80007246:	5e 4c       	retge	r12
80007248:	e0 6a 08 0c 	mov	r10,2060
8000724c:	95 0b       	st.w	r10[0x0],r11
8000724e:	5e fc       	retal	r12

80007250 <isatty>:
80007250:	30 b8       	mov	r8,11
80007252:	d6 73       	breakpoint
80007254:	3f fc       	mov	r12,-1
80007256:	35 8b       	mov	r11,88
80007258:	58 0c       	cp.w	r12,0
8000725a:	5e 4c       	retge	r12
8000725c:	e0 6a 08 0c 	mov	r10,2060
80007260:	95 0b       	st.w	r10[0x0],r11
80007262:	5e fc       	retal	r12

80007264 <_fstat_host>:
80007264:	30 98       	mov	r8,9
80007266:	d6 73       	breakpoint
80007268:	3f fc       	mov	r12,-1
8000726a:	35 8b       	mov	r11,88
8000726c:	58 0c       	cp.w	r12,0
8000726e:	5e 4c       	retge	r12
80007270:	e0 6a 08 0c 	mov	r10,2060
80007274:	95 0b       	st.w	r10[0x0],r11
80007276:	5e fc       	retal	r12

80007278 <_fstat>:
80007278:	d4 21       	pushm	r4-r7,lr
8000727a:	21 0d       	sub	sp,64
8000727c:	16 97       	mov	r7,r11
8000727e:	1a 9b       	mov	r11,sp
80007280:	cf 2f       	rcall	80007264 <_fstat_host>
80007282:	c0 34       	brge	80007288 <_fstat+0x10>
80007284:	3f fc       	mov	r12,-1
80007286:	c1 c8       	rjmp	800072be <_fstat+0x46>
80007288:	40 08       	lddsp	r8,sp[0x0]
8000728a:	ae 08       	st.h	r7[0x0],r8
8000728c:	40 18       	lddsp	r8,sp[0x4]
8000728e:	ae 18       	st.h	r7[0x2],r8
80007290:	40 28       	lddsp	r8,sp[0x8]
80007292:	8f 18       	st.w	r7[0x4],r8
80007294:	40 38       	lddsp	r8,sp[0xc]
80007296:	ae 48       	st.h	r7[0x8],r8
80007298:	40 48       	lddsp	r8,sp[0x10]
8000729a:	ae 58       	st.h	r7[0xa],r8
8000729c:	40 58       	lddsp	r8,sp[0x14]
8000729e:	ae 68       	st.h	r7[0xc],r8
800072a0:	40 68       	lddsp	r8,sp[0x18]
800072a2:	ae 78       	st.h	r7[0xe],r8
800072a4:	40 88       	lddsp	r8,sp[0x20]
800072a6:	8f 48       	st.w	r7[0x10],r8
800072a8:	40 a8       	lddsp	r8,sp[0x28]
800072aa:	8f b8       	st.w	r7[0x2c],r8
800072ac:	40 c8       	lddsp	r8,sp[0x30]
800072ae:	8f c8       	st.w	r7[0x30],r8
800072b0:	40 d8       	lddsp	r8,sp[0x34]
800072b2:	8f 58       	st.w	r7[0x14],r8
800072b4:	40 e8       	lddsp	r8,sp[0x38]
800072b6:	30 0c       	mov	r12,0
800072b8:	8f 78       	st.w	r7[0x1c],r8
800072ba:	40 f8       	lddsp	r8,sp[0x3c]
800072bc:	8f 98       	st.w	r7[0x24],r8
800072be:	2f 0d       	sub	sp,-64
800072c0:	d8 22       	popm	r4-r7,pc
800072c2:	d7 03       	nop

800072c4 <_sbrk>:
800072c4:	d4 01       	pushm	lr
800072c6:	e0 68 07 d0 	mov	r8,2000
800072ca:	70 09       	ld.w	r9,r8[0x0]
800072cc:	58 09       	cp.w	r9,0
800072ce:	c0 41       	brne	800072d6 <_sbrk+0x12>
800072d0:	e0 69 08 10 	mov	r9,2064
800072d4:	91 09       	st.w	r8[0x0],r9
800072d6:	e0 69 07 d0 	mov	r9,2000
800072da:	e0 6a f0 00 	mov	r10,61440
800072de:	72 08       	ld.w	r8,r9[0x0]
800072e0:	f0 0c 00 0c 	add	r12,r8,r12
800072e4:	14 3c       	cp.w	r12,r10
800072e6:	e0 8b 00 04 	brhi	800072ee <_sbrk+0x2a>
800072ea:	93 0c       	st.w	r9[0x0],r12
800072ec:	c0 68       	rjmp	800072f8 <_sbrk+0x34>
800072ee:	e0 a0 18 ef 	rcall	8000a4cc <__errno>
800072f2:	30 c8       	mov	r8,12
800072f4:	99 08       	st.w	r12[0x0],r8
800072f6:	3f f8       	mov	r8,-1
800072f8:	10 9c       	mov	r12,r8
800072fa:	d8 02       	popm	pc

800072fc <get_arg>:
800072fc:	d4 31       	pushm	r0-r7,lr
800072fe:	20 8d       	sub	sp,32
80007300:	fa c4 ff bc 	sub	r4,sp,-68
80007304:	50 4b       	stdsp	sp[0x10],r11
80007306:	68 2e       	ld.w	lr,r4[0x8]
80007308:	50 58       	stdsp	sp[0x14],r8
8000730a:	12 96       	mov	r6,r9
8000730c:	7c 0b       	ld.w	r11,lr[0x0]
8000730e:	70 05       	ld.w	r5,r8[0x0]
80007310:	50 6e       	stdsp	sp[0x18],lr
80007312:	58 0b       	cp.w	r11,0
80007314:	f4 0b 17 00 	moveq	r11,r10
80007318:	68 03       	ld.w	r3,r4[0x0]
8000731a:	68 11       	ld.w	r1,r4[0x4]
8000731c:	40 49       	lddsp	r9,sp[0x10]
8000731e:	30 08       	mov	r8,0
80007320:	c2 89       	rjmp	80007570 <get_arg+0x274>
80007322:	2f fb       	sub	r11,-1
80007324:	32 5c       	mov	r12,37
80007326:	17 8a       	ld.ub	r10,r11[0x0]
80007328:	f8 0a 18 00 	cp.b	r10,r12
8000732c:	5f 1e       	srne	lr
8000732e:	f0 0a 18 00 	cp.b	r10,r8
80007332:	5f 1c       	srne	r12
80007334:	fd ec 00 0c 	and	r12,lr,r12
80007338:	f0 0c 18 00 	cp.b	r12,r8
8000733c:	cf 31       	brne	80007322 <get_arg+0x26>
8000733e:	58 0a       	cp.w	r10,0
80007340:	e0 80 01 25 	breq	8000758a <get_arg+0x28e>
80007344:	30 0c       	mov	r12,0
80007346:	3f fa       	mov	r10,-1
80007348:	18 90       	mov	r0,r12
8000734a:	50 3a       	stdsp	sp[0xc],r10
8000734c:	18 94       	mov	r4,r12
8000734e:	18 92       	mov	r2,r12
80007350:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007354:	16 97       	mov	r7,r11
80007356:	50 7c       	stdsp	sp[0x1c],r12
80007358:	fe cc ab 4c 	sub	r12,pc,-21684
8000735c:	0f 3a       	ld.ub	r10,r7++
8000735e:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007362:	40 7c       	lddsp	r12,sp[0x1c]
80007364:	1c 0c       	add	r12,lr
80007366:	fe ce ac 22 	sub	lr,pc,-21470
8000736a:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000736e:	20 1e       	sub	lr,1
80007370:	50 0e       	stdsp	sp[0x0],lr
80007372:	fe ce ac 9a 	sub	lr,pc,-21350
80007376:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000737a:	50 7c       	stdsp	sp[0x1c],r12
8000737c:	40 0c       	lddsp	r12,sp[0x0]
8000737e:	58 7c       	cp.w	r12,7
80007380:	e0 8b 00 f1 	brhi	80007562 <get_arg+0x266>
80007384:	fe ce ae 4c 	sub	lr,pc,-20916
80007388:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000738c:	36 8b       	mov	r11,104
8000738e:	f6 0a 18 00 	cp.b	r10,r11
80007392:	e0 80 00 e8 	breq	80007562 <get_arg+0x266>
80007396:	37 1b       	mov	r11,113
80007398:	f6 0a 18 00 	cp.b	r10,r11
8000739c:	c0 70       	breq	800073aa <get_arg+0xae>
8000739e:	34 cb       	mov	r11,76
800073a0:	f6 0a 18 00 	cp.b	r10,r11
800073a4:	c0 51       	brne	800073ae <get_arg+0xb2>
800073a6:	a3 b4       	sbr	r4,0x3
800073a8:	cd d8       	rjmp	80007562 <get_arg+0x266>
800073aa:	a5 b4       	sbr	r4,0x5
800073ac:	cd b8       	rjmp	80007562 <get_arg+0x266>
800073ae:	08 9a       	mov	r10,r4
800073b0:	0e 9b       	mov	r11,r7
800073b2:	a5 aa       	sbr	r10,0x4
800073b4:	17 3c       	ld.ub	r12,r11++
800073b6:	a5 b4       	sbr	r4,0x5
800073b8:	36 ce       	mov	lr,108
800073ba:	fc 0c 18 00 	cp.b	r12,lr
800073be:	e0 80 00 d3 	breq	80007564 <get_arg+0x268>
800073c2:	14 94       	mov	r4,r10
800073c4:	cc f8       	rjmp	80007562 <get_arg+0x266>
800073c6:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
800073ca:	36 7c       	mov	r12,103
800073cc:	f8 0a 18 00 	cp.b	r10,r12
800073d0:	e0 8b 00 27 	brhi	8000741e <get_arg+0x122>
800073d4:	36 5b       	mov	r11,101
800073d6:	f6 0a 18 00 	cp.b	r10,r11
800073da:	c4 82       	brcc	8000746a <get_arg+0x16e>
800073dc:	34 fb       	mov	r11,79
800073de:	f6 0a 18 00 	cp.b	r10,r11
800073e2:	c4 80       	breq	80007472 <get_arg+0x176>
800073e4:	e0 8b 00 0c 	brhi	800073fc <get_arg+0x100>
800073e8:	34 5b       	mov	r11,69
800073ea:	f6 0a 18 00 	cp.b	r10,r11
800073ee:	c3 e0       	breq	8000746a <get_arg+0x16e>
800073f0:	34 7b       	mov	r11,71
800073f2:	f6 0a 18 00 	cp.b	r10,r11
800073f6:	c3 a0       	breq	8000746a <get_arg+0x16e>
800073f8:	34 4b       	mov	r11,68
800073fa:	c0 88       	rjmp	8000740a <get_arg+0x10e>
800073fc:	35 8b       	mov	r11,88
800073fe:	f6 0a 18 00 	cp.b	r10,r11
80007402:	c2 c0       	breq	8000745a <get_arg+0x15e>
80007404:	e0 8b 00 07 	brhi	80007412 <get_arg+0x116>
80007408:	35 5b       	mov	r11,85
8000740a:	f6 0a 18 00 	cp.b	r10,r11
8000740e:	c3 51       	brne	80007478 <get_arg+0x17c>
80007410:	c3 18       	rjmp	80007472 <get_arg+0x176>
80007412:	36 3b       	mov	r11,99
80007414:	f6 0a 18 00 	cp.b	r10,r11
80007418:	c2 f0       	breq	80007476 <get_arg+0x17a>
8000741a:	36 4b       	mov	r11,100
8000741c:	c0 e8       	rjmp	80007438 <get_arg+0x13c>
8000741e:	37 0b       	mov	r11,112
80007420:	f6 0a 18 00 	cp.b	r10,r11
80007424:	c2 50       	breq	8000746e <get_arg+0x172>
80007426:	e0 8b 00 0d 	brhi	80007440 <get_arg+0x144>
8000742a:	36 eb       	mov	r11,110
8000742c:	f6 0a 18 00 	cp.b	r10,r11
80007430:	c1 f0       	breq	8000746e <get_arg+0x172>
80007432:	e0 8b 00 14 	brhi	8000745a <get_arg+0x15e>
80007436:	36 9b       	mov	r11,105
80007438:	f6 0a 18 00 	cp.b	r10,r11
8000743c:	c1 e1       	brne	80007478 <get_arg+0x17c>
8000743e:	c0 e8       	rjmp	8000745a <get_arg+0x15e>
80007440:	37 5b       	mov	r11,117
80007442:	f6 0a 18 00 	cp.b	r10,r11
80007446:	c0 a0       	breq	8000745a <get_arg+0x15e>
80007448:	37 8b       	mov	r11,120
8000744a:	f6 0a 18 00 	cp.b	r10,r11
8000744e:	c0 60       	breq	8000745a <get_arg+0x15e>
80007450:	37 3b       	mov	r11,115
80007452:	f6 0a 18 00 	cp.b	r10,r11
80007456:	c1 11       	brne	80007478 <get_arg+0x17c>
80007458:	c0 b8       	rjmp	8000746e <get_arg+0x172>
8000745a:	ed b4 00 04 	bld	r4,0x4
8000745e:	c0 a0       	breq	80007472 <get_arg+0x176>
80007460:	ed b4 00 05 	bld	r4,0x5
80007464:	c0 91       	brne	80007476 <get_arg+0x17a>
80007466:	30 20       	mov	r0,2
80007468:	c0 88       	rjmp	80007478 <get_arg+0x17c>
8000746a:	30 40       	mov	r0,4
8000746c:	c0 68       	rjmp	80007478 <get_arg+0x17c>
8000746e:	30 30       	mov	r0,3
80007470:	c0 48       	rjmp	80007478 <get_arg+0x17c>
80007472:	30 10       	mov	r0,1
80007474:	c0 28       	rjmp	80007478 <get_arg+0x17c>
80007476:	30 00       	mov	r0,0
80007478:	40 3b       	lddsp	r11,sp[0xc]
8000747a:	5b fb       	cp.w	r11,-1
8000747c:	c0 40       	breq	80007484 <get_arg+0x188>
8000747e:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007482:	c7 08       	rjmp	80007562 <get_arg+0x266>
80007484:	58 60       	cp.w	r0,6
80007486:	e0 8b 00 6e 	brhi	80007562 <get_arg+0x266>
8000748a:	6c 0a       	ld.w	r10,r6[0x0]
8000748c:	ea cc ff ff 	sub	r12,r5,-1
80007490:	fe ce af 38 	sub	lr,pc,-20680
80007494:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007498:	f4 cb ff f8 	sub	r11,r10,-8
8000749c:	8d 0b       	st.w	r6[0x0],r11
8000749e:	f4 ea 00 00 	ld.d	r10,r10[0]
800074a2:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800074a6:	c0 f8       	rjmp	800074c4 <get_arg+0x1c8>
800074a8:	f4 cb ff fc 	sub	r11,r10,-4
800074ac:	8d 0b       	st.w	r6[0x0],r11
800074ae:	74 0a       	ld.w	r10,r10[0x0]
800074b0:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800074b4:	c0 88       	rjmp	800074c4 <get_arg+0x1c8>
800074b6:	f4 cb ff f8 	sub	r11,r10,-8
800074ba:	8d 0b       	st.w	r6[0x0],r11
800074bc:	f4 ea 00 00 	ld.d	r10,r10[0]
800074c0:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800074c4:	0e 9b       	mov	r11,r7
800074c6:	18 95       	mov	r5,r12
800074c8:	c4 e8       	rjmp	80007564 <get_arg+0x268>
800074ca:	62 0a       	ld.w	r10,r1[0x0]
800074cc:	5b fa       	cp.w	r10,-1
800074ce:	c0 b1       	brne	800074e4 <get_arg+0x1e8>
800074d0:	50 19       	stdsp	sp[0x4],r9
800074d2:	50 28       	stdsp	sp[0x8],r8
800074d4:	e0 6a 00 80 	mov	r10,128
800074d8:	30 0b       	mov	r11,0
800074da:	02 9c       	mov	r12,r1
800074dc:	fe b0 fc f6 	rcall	80006ec8 <memset>
800074e0:	40 28       	lddsp	r8,sp[0x8]
800074e2:	40 19       	lddsp	r9,sp[0x4]
800074e4:	e4 cc 00 01 	sub	r12,r2,1
800074e8:	0e 9b       	mov	r11,r7
800074ea:	50 3c       	stdsp	sp[0xc],r12
800074ec:	f2 0c 0c 49 	max	r9,r9,r12
800074f0:	c3 a8       	rjmp	80007564 <get_arg+0x268>
800074f2:	62 0a       	ld.w	r10,r1[0x0]
800074f4:	5b fa       	cp.w	r10,-1
800074f6:	c0 b1       	brne	8000750c <get_arg+0x210>
800074f8:	50 19       	stdsp	sp[0x4],r9
800074fa:	50 28       	stdsp	sp[0x8],r8
800074fc:	e0 6a 00 80 	mov	r10,128
80007500:	30 0b       	mov	r11,0
80007502:	02 9c       	mov	r12,r1
80007504:	fe b0 fc e2 	rcall	80006ec8 <memset>
80007508:	40 28       	lddsp	r8,sp[0x8]
8000750a:	40 19       	lddsp	r9,sp[0x4]
8000750c:	20 12       	sub	r2,1
8000750e:	30 0a       	mov	r10,0
80007510:	0e 9b       	mov	r11,r7
80007512:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007516:	f2 02 0c 49 	max	r9,r9,r2
8000751a:	c2 58       	rjmp	80007564 <get_arg+0x268>
8000751c:	16 97       	mov	r7,r11
8000751e:	6c 0a       	ld.w	r10,r6[0x0]
80007520:	f4 cb ff fc 	sub	r11,r10,-4
80007524:	8d 0b       	st.w	r6[0x0],r11
80007526:	74 0a       	ld.w	r10,r10[0x0]
80007528:	0e 9b       	mov	r11,r7
8000752a:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000752e:	2f f5       	sub	r5,-1
80007530:	c1 a8       	rjmp	80007564 <get_arg+0x268>
80007532:	f4 c2 00 30 	sub	r2,r10,48
80007536:	c0 68       	rjmp	80007542 <get_arg+0x246>
80007538:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000753c:	2f f7       	sub	r7,-1
8000753e:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007542:	0f 8a       	ld.ub	r10,r7[0x0]
80007544:	58 0a       	cp.w	r10,0
80007546:	c0 e0       	breq	80007562 <get_arg+0x266>
80007548:	23 0a       	sub	r10,48
8000754a:	58 9a       	cp.w	r10,9
8000754c:	fe 98 ff f6 	brls	80007538 <get_arg+0x23c>
80007550:	c0 98       	rjmp	80007562 <get_arg+0x266>
80007552:	2f f7       	sub	r7,-1
80007554:	0f 8a       	ld.ub	r10,r7[0x0]
80007556:	58 0a       	cp.w	r10,0
80007558:	c0 50       	breq	80007562 <get_arg+0x266>
8000755a:	23 0a       	sub	r10,48
8000755c:	58 9a       	cp.w	r10,9
8000755e:	fe 98 ff fa 	brls	80007552 <get_arg+0x256>
80007562:	0e 9b       	mov	r11,r7
80007564:	40 7c       	lddsp	r12,sp[0x1c]
80007566:	30 ba       	mov	r10,11
80007568:	f4 0c 18 00 	cp.b	r12,r10
8000756c:	fe 91 fe f2 	brne	80007350 <get_arg+0x54>
80007570:	40 42       	lddsp	r2,sp[0x10]
80007572:	17 8c       	ld.ub	r12,r11[0x0]
80007574:	0a 32       	cp.w	r2,r5
80007576:	5f 4a       	srge	r10
80007578:	f0 0c 18 00 	cp.b	r12,r8
8000757c:	5f 1c       	srne	r12
8000757e:	f9 ea 00 0a 	and	r10,r12,r10
80007582:	f0 0a 18 00 	cp.b	r10,r8
80007586:	fe 91 fe cf 	brne	80007324 <get_arg+0x28>
8000758a:	30 08       	mov	r8,0
8000758c:	40 4e       	lddsp	lr,sp[0x10]
8000758e:	17 8a       	ld.ub	r10,r11[0x0]
80007590:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007594:	f0 0a 18 00 	cp.b	r10,r8
80007598:	fc 09 17 10 	movne	r9,lr
8000759c:	e6 05 00 38 	add	r8,r3,r5<<0x3
800075a0:	06 9e       	mov	lr,r3
800075a2:	c2 a8       	rjmp	800075f6 <get_arg+0x2fa>
800075a4:	62 0a       	ld.w	r10,r1[0x0]
800075a6:	58 3a       	cp.w	r10,3
800075a8:	c1 e0       	breq	800075e4 <get_arg+0x2e8>
800075aa:	e0 89 00 07 	brgt	800075b8 <get_arg+0x2bc>
800075ae:	58 1a       	cp.w	r10,1
800075b0:	c1 a0       	breq	800075e4 <get_arg+0x2e8>
800075b2:	58 2a       	cp.w	r10,2
800075b4:	c1 81       	brne	800075e4 <get_arg+0x2e8>
800075b6:	c0 58       	rjmp	800075c0 <get_arg+0x2c4>
800075b8:	58 5a       	cp.w	r10,5
800075ba:	c0 c0       	breq	800075d2 <get_arg+0x2d6>
800075bc:	c0 b5       	brlt	800075d2 <get_arg+0x2d6>
800075be:	c1 38       	rjmp	800075e4 <get_arg+0x2e8>
800075c0:	6c 0a       	ld.w	r10,r6[0x0]
800075c2:	f4 cc ff f8 	sub	r12,r10,-8
800075c6:	8d 0c       	st.w	r6[0x0],r12
800075c8:	f4 e2 00 00 	ld.d	r2,r10[0]
800075cc:	f0 e3 00 00 	st.d	r8[0],r2
800075d0:	c1 08       	rjmp	800075f0 <get_arg+0x2f4>
800075d2:	6c 0a       	ld.w	r10,r6[0x0]
800075d4:	f4 cc ff f8 	sub	r12,r10,-8
800075d8:	8d 0c       	st.w	r6[0x0],r12
800075da:	f4 e2 00 00 	ld.d	r2,r10[0]
800075de:	f0 e3 00 00 	st.d	r8[0],r2
800075e2:	c0 78       	rjmp	800075f0 <get_arg+0x2f4>
800075e4:	6c 0a       	ld.w	r10,r6[0x0]
800075e6:	f4 cc ff fc 	sub	r12,r10,-4
800075ea:	8d 0c       	st.w	r6[0x0],r12
800075ec:	74 0a       	ld.w	r10,r10[0x0]
800075ee:	91 0a       	st.w	r8[0x0],r10
800075f0:	2f f5       	sub	r5,-1
800075f2:	2f 88       	sub	r8,-8
800075f4:	2f c1       	sub	r1,-4
800075f6:	12 35       	cp.w	r5,r9
800075f8:	fe 9a ff d6 	brle	800075a4 <get_arg+0x2a8>
800075fc:	1c 93       	mov	r3,lr
800075fe:	40 52       	lddsp	r2,sp[0x14]
80007600:	40 6e       	lddsp	lr,sp[0x18]
80007602:	85 05       	st.w	r2[0x0],r5
80007604:	9d 0b       	st.w	lr[0x0],r11
80007606:	40 4b       	lddsp	r11,sp[0x10]
80007608:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000760c:	2f 8d       	sub	sp,-32
8000760e:	d8 32       	popm	r0-r7,pc

80007610 <__sprint_r>:
80007610:	d4 21       	pushm	r4-r7,lr
80007612:	14 97       	mov	r7,r10
80007614:	74 28       	ld.w	r8,r10[0x8]
80007616:	58 08       	cp.w	r8,0
80007618:	c0 41       	brne	80007620 <__sprint_r+0x10>
8000761a:	95 18       	st.w	r10[0x4],r8
8000761c:	10 9c       	mov	r12,r8
8000761e:	d8 22       	popm	r4-r7,pc
80007620:	e0 a0 19 94 	rcall	8000a948 <__sfvwrite_r>
80007624:	30 08       	mov	r8,0
80007626:	8f 18       	st.w	r7[0x4],r8
80007628:	8f 28       	st.w	r7[0x8],r8
8000762a:	d8 22       	popm	r4-r7,pc

8000762c <_vfprintf_r>:
8000762c:	d4 31       	pushm	r0-r7,lr
8000762e:	fa cd 06 bc 	sub	sp,sp,1724
80007632:	51 09       	stdsp	sp[0x40],r9
80007634:	16 91       	mov	r1,r11
80007636:	14 97       	mov	r7,r10
80007638:	18 95       	mov	r5,r12
8000763a:	e0 a0 1a f7 	rcall	8000ac28 <_localeconv_r>
8000763e:	78 0c       	ld.w	r12,r12[0x0]
80007640:	50 cc       	stdsp	sp[0x30],r12
80007642:	58 05       	cp.w	r5,0
80007644:	c0 70       	breq	80007652 <_vfprintf_r+0x26>
80007646:	6a 68       	ld.w	r8,r5[0x18]
80007648:	58 08       	cp.w	r8,0
8000764a:	c0 41       	brne	80007652 <_vfprintf_r+0x26>
8000764c:	0a 9c       	mov	r12,r5
8000764e:	e0 a0 18 1d 	rcall	8000a688 <__sinit>
80007652:	fe c8 ad 36 	sub	r8,pc,-21194
80007656:	10 31       	cp.w	r1,r8
80007658:	c0 31       	brne	8000765e <_vfprintf_r+0x32>
8000765a:	6a 01       	ld.w	r1,r5[0x0]
8000765c:	c0 c8       	rjmp	80007674 <_vfprintf_r+0x48>
8000765e:	fe c8 ad 22 	sub	r8,pc,-21214
80007662:	10 31       	cp.w	r1,r8
80007664:	c0 31       	brne	8000766a <_vfprintf_r+0x3e>
80007666:	6a 11       	ld.w	r1,r5[0x4]
80007668:	c0 68       	rjmp	80007674 <_vfprintf_r+0x48>
8000766a:	fe c8 ad 0e 	sub	r8,pc,-21234
8000766e:	10 31       	cp.w	r1,r8
80007670:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007674:	82 68       	ld.sh	r8,r1[0xc]
80007676:	ed b8 00 03 	bld	r8,0x3
8000767a:	c0 41       	brne	80007682 <_vfprintf_r+0x56>
8000767c:	62 48       	ld.w	r8,r1[0x10]
8000767e:	58 08       	cp.w	r8,0
80007680:	c0 71       	brne	8000768e <_vfprintf_r+0x62>
80007682:	02 9b       	mov	r11,r1
80007684:	0a 9c       	mov	r12,r5
80007686:	e0 a0 0f 7f 	rcall	80009584 <__swsetup_r>
8000768a:	e0 81 0f 54 	brne	80009532 <_vfprintf_r+0x1f06>
8000768e:	82 68       	ld.sh	r8,r1[0xc]
80007690:	10 99       	mov	r9,r8
80007692:	e2 19 00 1a 	andl	r9,0x1a,COH
80007696:	58 a9       	cp.w	r9,10
80007698:	c3 c1       	brne	80007710 <_vfprintf_r+0xe4>
8000769a:	82 79       	ld.sh	r9,r1[0xe]
8000769c:	30 0a       	mov	r10,0
8000769e:	f4 09 19 00 	cp.h	r9,r10
800076a2:	c3 75       	brlt	80007710 <_vfprintf_r+0xe4>
800076a4:	a1 d8       	cbr	r8,0x1
800076a6:	fb 58 05 d0 	st.h	sp[1488],r8
800076aa:	62 88       	ld.w	r8,r1[0x20]
800076ac:	fb 48 05 e4 	st.w	sp[1508],r8
800076b0:	62 a8       	ld.w	r8,r1[0x28]
800076b2:	fb 48 05 ec 	st.w	sp[1516],r8
800076b6:	fa c8 ff bc 	sub	r8,sp,-68
800076ba:	fb 48 05 d4 	st.w	sp[1492],r8
800076be:	fb 48 05 c4 	st.w	sp[1476],r8
800076c2:	e0 68 04 00 	mov	r8,1024
800076c6:	fb 48 05 d8 	st.w	sp[1496],r8
800076ca:	fb 48 05 cc 	st.w	sp[1484],r8
800076ce:	30 08       	mov	r8,0
800076d0:	fb 59 05 d2 	st.h	sp[1490],r9
800076d4:	0e 9a       	mov	r10,r7
800076d6:	41 09       	lddsp	r9,sp[0x40]
800076d8:	fa c7 fa 3c 	sub	r7,sp,-1476
800076dc:	fb 48 05 dc 	st.w	sp[1500],r8
800076e0:	0a 9c       	mov	r12,r5
800076e2:	0e 9b       	mov	r11,r7
800076e4:	ca 4f       	rcall	8000762c <_vfprintf_r>
800076e6:	50 bc       	stdsp	sp[0x2c],r12
800076e8:	c0 95       	brlt	800076fa <_vfprintf_r+0xce>
800076ea:	0e 9b       	mov	r11,r7
800076ec:	0a 9c       	mov	r12,r5
800076ee:	e0 a0 16 f5 	rcall	8000a4d8 <_fflush_r>
800076f2:	40 be       	lddsp	lr,sp[0x2c]
800076f4:	f9 be 01 ff 	movne	lr,-1
800076f8:	50 be       	stdsp	sp[0x2c],lr
800076fa:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800076fe:	ed b8 00 06 	bld	r8,0x6
80007702:	e0 81 0f 1a 	brne	80009536 <_vfprintf_r+0x1f0a>
80007706:	82 68       	ld.sh	r8,r1[0xc]
80007708:	a7 a8       	sbr	r8,0x6
8000770a:	a2 68       	st.h	r1[0xc],r8
8000770c:	e0 8f 0f 15 	bral	80009536 <_vfprintf_r+0x1f0a>
80007710:	30 08       	mov	r8,0
80007712:	fb 48 06 b4 	st.w	sp[1716],r8
80007716:	fb 48 06 90 	st.w	sp[1680],r8
8000771a:	fb 48 06 8c 	st.w	sp[1676],r8
8000771e:	fb 48 06 b0 	st.w	sp[1712],r8
80007722:	30 08       	mov	r8,0
80007724:	30 09       	mov	r9,0
80007726:	50 a7       	stdsp	sp[0x28],r7
80007728:	50 78       	stdsp	sp[0x1c],r8
8000772a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000772e:	3f f8       	mov	r8,-1
80007730:	50 59       	stdsp	sp[0x14],r9
80007732:	fb 43 06 88 	st.w	sp[1672],r3
80007736:	fb 48 05 44 	st.w	sp[1348],r8
8000773a:	12 9c       	mov	r12,r9
8000773c:	50 69       	stdsp	sp[0x18],r9
8000773e:	50 d9       	stdsp	sp[0x34],r9
80007740:	50 e9       	stdsp	sp[0x38],r9
80007742:	50 b9       	stdsp	sp[0x2c],r9
80007744:	12 97       	mov	r7,r9
80007746:	0a 94       	mov	r4,r5
80007748:	40 a2       	lddsp	r2,sp[0x28]
8000774a:	32 5a       	mov	r10,37
8000774c:	30 08       	mov	r8,0
8000774e:	c0 28       	rjmp	80007752 <_vfprintf_r+0x126>
80007750:	2f f2       	sub	r2,-1
80007752:	05 89       	ld.ub	r9,r2[0x0]
80007754:	f0 09 18 00 	cp.b	r9,r8
80007758:	5f 1b       	srne	r11
8000775a:	f4 09 18 00 	cp.b	r9,r10
8000775e:	5f 19       	srne	r9
80007760:	f3 eb 00 0b 	and	r11,r9,r11
80007764:	f0 0b 18 00 	cp.b	r11,r8
80007768:	cf 41       	brne	80007750 <_vfprintf_r+0x124>
8000776a:	40 ab       	lddsp	r11,sp[0x28]
8000776c:	e4 0b 01 06 	sub	r6,r2,r11
80007770:	c1 e0       	breq	800077ac <_vfprintf_r+0x180>
80007772:	fa f8 06 90 	ld.w	r8,sp[1680]
80007776:	0c 08       	add	r8,r6
80007778:	87 0b       	st.w	r3[0x0],r11
8000777a:	fb 48 06 90 	st.w	sp[1680],r8
8000777e:	87 16       	st.w	r3[0x4],r6
80007780:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007784:	2f f8       	sub	r8,-1
80007786:	fb 48 06 8c 	st.w	sp[1676],r8
8000778a:	58 78       	cp.w	r8,7
8000778c:	e0 89 00 04 	brgt	80007794 <_vfprintf_r+0x168>
80007790:	2f 83       	sub	r3,-8
80007792:	c0 a8       	rjmp	800077a6 <_vfprintf_r+0x17a>
80007794:	fa ca f9 78 	sub	r10,sp,-1672
80007798:	02 9b       	mov	r11,r1
8000779a:	08 9c       	mov	r12,r4
8000779c:	c3 af       	rcall	80007610 <__sprint_r>
8000779e:	e0 81 0e c6 	brne	8000952a <_vfprintf_r+0x1efe>
800077a2:	fa c3 f9 e0 	sub	r3,sp,-1568
800077a6:	40 ba       	lddsp	r10,sp[0x2c]
800077a8:	0c 0a       	add	r10,r6
800077aa:	50 ba       	stdsp	sp[0x2c],r10
800077ac:	05 89       	ld.ub	r9,r2[0x0]
800077ae:	30 08       	mov	r8,0
800077b0:	f0 09 18 00 	cp.b	r9,r8
800077b4:	e0 80 0e aa 	breq	80009508 <_vfprintf_r+0x1edc>
800077b8:	30 09       	mov	r9,0
800077ba:	fb 68 06 bb 	st.b	sp[1723],r8
800077be:	0e 96       	mov	r6,r7
800077c0:	e4 c8 ff ff 	sub	r8,r2,-1
800077c4:	3f fe       	mov	lr,-1
800077c6:	50 93       	stdsp	sp[0x24],r3
800077c8:	50 41       	stdsp	sp[0x10],r1
800077ca:	0e 93       	mov	r3,r7
800077cc:	04 91       	mov	r1,r2
800077ce:	50 89       	stdsp	sp[0x20],r9
800077d0:	50 a8       	stdsp	sp[0x28],r8
800077d2:	50 2e       	stdsp	sp[0x8],lr
800077d4:	50 39       	stdsp	sp[0xc],r9
800077d6:	12 95       	mov	r5,r9
800077d8:	12 90       	mov	r0,r9
800077da:	10 97       	mov	r7,r8
800077dc:	08 92       	mov	r2,r4
800077de:	c0 78       	rjmp	800077ec <_vfprintf_r+0x1c0>
800077e0:	3f fc       	mov	r12,-1
800077e2:	08 97       	mov	r7,r4
800077e4:	50 2c       	stdsp	sp[0x8],r12
800077e6:	c0 38       	rjmp	800077ec <_vfprintf_r+0x1c0>
800077e8:	30 0b       	mov	r11,0
800077ea:	50 3b       	stdsp	sp[0xc],r11
800077ec:	0f 38       	ld.ub	r8,r7++
800077ee:	c0 28       	rjmp	800077f2 <_vfprintf_r+0x1c6>
800077f0:	12 90       	mov	r0,r9
800077f2:	f0 c9 00 20 	sub	r9,r8,32
800077f6:	e0 49 00 58 	cp.w	r9,88
800077fa:	e0 8b 0a 30 	brhi	80008c5a <_vfprintf_r+0x162e>
800077fe:	fe ca b2 8a 	sub	r10,pc,-19830
80007802:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007806:	50 a7       	stdsp	sp[0x28],r7
80007808:	50 80       	stdsp	sp[0x20],r0
8000780a:	0c 97       	mov	r7,r6
8000780c:	04 94       	mov	r4,r2
8000780e:	06 96       	mov	r6,r3
80007810:	02 92       	mov	r2,r1
80007812:	fe c9 b0 62 	sub	r9,pc,-20382
80007816:	40 93       	lddsp	r3,sp[0x24]
80007818:	10 90       	mov	r0,r8
8000781a:	40 41       	lddsp	r1,sp[0x10]
8000781c:	50 d9       	stdsp	sp[0x34],r9
8000781e:	e0 8f 08 8e 	bral	8000893a <_vfprintf_r+0x130e>
80007822:	30 08       	mov	r8,0
80007824:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007828:	f0 09 18 00 	cp.b	r9,r8
8000782c:	ce 01       	brne	800077ec <_vfprintf_r+0x1c0>
8000782e:	32 08       	mov	r8,32
80007830:	c6 e8       	rjmp	8000790c <_vfprintf_r+0x2e0>
80007832:	a1 a5       	sbr	r5,0x0
80007834:	cd cb       	rjmp	800077ec <_vfprintf_r+0x1c0>
80007836:	0f 89       	ld.ub	r9,r7[0x0]
80007838:	f2 c8 00 30 	sub	r8,r9,48
8000783c:	58 98       	cp.w	r8,9
8000783e:	e0 8b 00 1d 	brhi	80007878 <_vfprintf_r+0x24c>
80007842:	ee c8 ff ff 	sub	r8,r7,-1
80007846:	30 0b       	mov	r11,0
80007848:	23 09       	sub	r9,48
8000784a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000784e:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007852:	11 39       	ld.ub	r9,r8++
80007854:	f2 ca 00 30 	sub	r10,r9,48
80007858:	58 9a       	cp.w	r10,9
8000785a:	fe 98 ff f7 	brls	80007848 <_vfprintf_r+0x21c>
8000785e:	e0 49 00 24 	cp.w	r9,36
80007862:	cc 31       	brne	800077e8 <_vfprintf_r+0x1bc>
80007864:	e0 4b 00 20 	cp.w	r11,32
80007868:	e0 89 0e 60 	brgt	80009528 <_vfprintf_r+0x1efc>
8000786c:	20 1b       	sub	r11,1
8000786e:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007872:	12 3b       	cp.w	r11,r9
80007874:	c0 95       	brlt	80007886 <_vfprintf_r+0x25a>
80007876:	c1 08       	rjmp	80007896 <_vfprintf_r+0x26a>
80007878:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000787c:	ec ca ff ff 	sub	r10,r6,-1
80007880:	12 36       	cp.w	r6,r9
80007882:	c1 f5       	brlt	800078c0 <_vfprintf_r+0x294>
80007884:	c2 68       	rjmp	800078d0 <_vfprintf_r+0x2a4>
80007886:	fa ce f9 44 	sub	lr,sp,-1724
8000788a:	10 97       	mov	r7,r8
8000788c:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007890:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007894:	c3 58       	rjmp	800078fe <_vfprintf_r+0x2d2>
80007896:	10 97       	mov	r7,r8
80007898:	fa c8 f9 50 	sub	r8,sp,-1712
8000789c:	1a d8       	st.w	--sp,r8
8000789e:	fa c8 fa b8 	sub	r8,sp,-1352
800078a2:	1a d8       	st.w	--sp,r8
800078a4:	fa c8 fb b4 	sub	r8,sp,-1100
800078a8:	02 9a       	mov	r10,r1
800078aa:	1a d8       	st.w	--sp,r8
800078ac:	04 9c       	mov	r12,r2
800078ae:	fa c8 f9 40 	sub	r8,sp,-1728
800078b2:	fa c9 ff b4 	sub	r9,sp,-76
800078b6:	fe b0 fd 23 	rcall	800072fc <get_arg>
800078ba:	2f dd       	sub	sp,-12
800078bc:	78 00       	ld.w	r0,r12[0x0]
800078be:	c2 08       	rjmp	800078fe <_vfprintf_r+0x2d2>
800078c0:	fa cc f9 44 	sub	r12,sp,-1724
800078c4:	14 96       	mov	r6,r10
800078c6:	f8 03 00 38 	add	r8,r12,r3<<0x3
800078ca:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800078ce:	c1 88       	rjmp	800078fe <_vfprintf_r+0x2d2>
800078d0:	41 08       	lddsp	r8,sp[0x40]
800078d2:	59 f9       	cp.w	r9,31
800078d4:	e0 89 00 11 	brgt	800078f6 <_vfprintf_r+0x2ca>
800078d8:	f0 cb ff fc 	sub	r11,r8,-4
800078dc:	51 0b       	stdsp	sp[0x40],r11
800078de:	70 00       	ld.w	r0,r8[0x0]
800078e0:	fa cb f9 44 	sub	r11,sp,-1724
800078e4:	f6 09 00 38 	add	r8,r11,r9<<0x3
800078e8:	f1 40 fd 88 	st.w	r8[-632],r0
800078ec:	2f f9       	sub	r9,-1
800078ee:	14 96       	mov	r6,r10
800078f0:	fb 49 06 b4 	st.w	sp[1716],r9
800078f4:	c0 58       	rjmp	800078fe <_vfprintf_r+0x2d2>
800078f6:	70 00       	ld.w	r0,r8[0x0]
800078f8:	14 96       	mov	r6,r10
800078fa:	2f c8       	sub	r8,-4
800078fc:	51 08       	stdsp	sp[0x40],r8
800078fe:	58 00       	cp.w	r0,0
80007900:	fe 94 ff 76 	brge	800077ec <_vfprintf_r+0x1c0>
80007904:	5c 30       	neg	r0
80007906:	a3 a5       	sbr	r5,0x2
80007908:	c7 2b       	rjmp	800077ec <_vfprintf_r+0x1c0>
8000790a:	32 b8       	mov	r8,43
8000790c:	fb 68 06 bb 	st.b	sp[1723],r8
80007910:	c6 eb       	rjmp	800077ec <_vfprintf_r+0x1c0>
80007912:	0f 38       	ld.ub	r8,r7++
80007914:	e0 48 00 2a 	cp.w	r8,42
80007918:	c0 30       	breq	8000791e <_vfprintf_r+0x2f2>
8000791a:	30 09       	mov	r9,0
8000791c:	c7 98       	rjmp	80007a0e <_vfprintf_r+0x3e2>
8000791e:	0f 88       	ld.ub	r8,r7[0x0]
80007920:	f0 c9 00 30 	sub	r9,r8,48
80007924:	58 99       	cp.w	r9,9
80007926:	e0 8b 00 1f 	brhi	80007964 <_vfprintf_r+0x338>
8000792a:	ee c4 ff ff 	sub	r4,r7,-1
8000792e:	30 0b       	mov	r11,0
80007930:	23 08       	sub	r8,48
80007932:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007936:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000793a:	09 38       	ld.ub	r8,r4++
8000793c:	f0 c9 00 30 	sub	r9,r8,48
80007940:	58 99       	cp.w	r9,9
80007942:	fe 98 ff f7 	brls	80007930 <_vfprintf_r+0x304>
80007946:	e0 48 00 24 	cp.w	r8,36
8000794a:	fe 91 ff 4f 	brne	800077e8 <_vfprintf_r+0x1bc>
8000794e:	e0 4b 00 20 	cp.w	r11,32
80007952:	e0 89 0d eb 	brgt	80009528 <_vfprintf_r+0x1efc>
80007956:	20 1b       	sub	r11,1
80007958:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000795c:	10 3b       	cp.w	r11,r8
8000795e:	c0 a5       	brlt	80007972 <_vfprintf_r+0x346>
80007960:	c1 18       	rjmp	80007982 <_vfprintf_r+0x356>
80007962:	d7 03       	nop
80007964:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007968:	ec c9 ff ff 	sub	r9,r6,-1
8000796c:	14 36       	cp.w	r6,r10
8000796e:	c1 f5       	brlt	800079ac <_vfprintf_r+0x380>
80007970:	c2 88       	rjmp	800079c0 <_vfprintf_r+0x394>
80007972:	fa ca f9 44 	sub	r10,sp,-1724
80007976:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000797a:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000797e:	50 2b       	stdsp	sp[0x8],r11
80007980:	c3 c8       	rjmp	800079f8 <_vfprintf_r+0x3cc>
80007982:	fa c8 f9 50 	sub	r8,sp,-1712
80007986:	1a d8       	st.w	--sp,r8
80007988:	fa c8 fa b8 	sub	r8,sp,-1352
8000798c:	1a d8       	st.w	--sp,r8
8000798e:	fa c8 fb b4 	sub	r8,sp,-1100
80007992:	02 9a       	mov	r10,r1
80007994:	1a d8       	st.w	--sp,r8
80007996:	04 9c       	mov	r12,r2
80007998:	fa c8 f9 40 	sub	r8,sp,-1728
8000799c:	fa c9 ff b4 	sub	r9,sp,-76
800079a0:	fe b0 fc ae 	rcall	800072fc <get_arg>
800079a4:	2f dd       	sub	sp,-12
800079a6:	78 0c       	ld.w	r12,r12[0x0]
800079a8:	50 2c       	stdsp	sp[0x8],r12
800079aa:	c2 78       	rjmp	800079f8 <_vfprintf_r+0x3cc>
800079ac:	12 96       	mov	r6,r9
800079ae:	0e 94       	mov	r4,r7
800079b0:	fa c9 f9 44 	sub	r9,sp,-1724
800079b4:	f2 03 00 38 	add	r8,r9,r3<<0x3
800079b8:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800079bc:	50 28       	stdsp	sp[0x8],r8
800079be:	c1 d8       	rjmp	800079f8 <_vfprintf_r+0x3cc>
800079c0:	41 08       	lddsp	r8,sp[0x40]
800079c2:	59 fa       	cp.w	r10,31
800079c4:	e0 89 00 14 	brgt	800079ec <_vfprintf_r+0x3c0>
800079c8:	f0 cb ff fc 	sub	r11,r8,-4
800079cc:	70 08       	ld.w	r8,r8[0x0]
800079ce:	51 0b       	stdsp	sp[0x40],r11
800079d0:	50 28       	stdsp	sp[0x8],r8
800079d2:	fa c6 f9 44 	sub	r6,sp,-1724
800079d6:	40 2e       	lddsp	lr,sp[0x8]
800079d8:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800079dc:	f1 4e fd 88 	st.w	r8[-632],lr
800079e0:	2f fa       	sub	r10,-1
800079e2:	0e 94       	mov	r4,r7
800079e4:	fb 4a 06 b4 	st.w	sp[1716],r10
800079e8:	12 96       	mov	r6,r9
800079ea:	c0 78       	rjmp	800079f8 <_vfprintf_r+0x3cc>
800079ec:	70 0c       	ld.w	r12,r8[0x0]
800079ee:	0e 94       	mov	r4,r7
800079f0:	2f c8       	sub	r8,-4
800079f2:	50 2c       	stdsp	sp[0x8],r12
800079f4:	12 96       	mov	r6,r9
800079f6:	51 08       	stdsp	sp[0x40],r8
800079f8:	40 2b       	lddsp	r11,sp[0x8]
800079fa:	58 0b       	cp.w	r11,0
800079fc:	fe 95 fe f2 	brlt	800077e0 <_vfprintf_r+0x1b4>
80007a00:	08 97       	mov	r7,r4
80007a02:	cf 5a       	rjmp	800077ec <_vfprintf_r+0x1c0>
80007a04:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007a08:	0f 38       	ld.ub	r8,r7++
80007a0a:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007a0e:	f0 ca 00 30 	sub	r10,r8,48
80007a12:	58 9a       	cp.w	r10,9
80007a14:	fe 98 ff f8 	brls	80007a04 <_vfprintf_r+0x3d8>
80007a18:	3f fa       	mov	r10,-1
80007a1a:	f2 0a 0c 49 	max	r9,r9,r10
80007a1e:	50 29       	stdsp	sp[0x8],r9
80007a20:	ce 9a       	rjmp	800077f2 <_vfprintf_r+0x1c6>
80007a22:	a7 b5       	sbr	r5,0x7
80007a24:	ce 4a       	rjmp	800077ec <_vfprintf_r+0x1c0>
80007a26:	30 09       	mov	r9,0
80007a28:	23 08       	sub	r8,48
80007a2a:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007a2e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007a32:	0f 38       	ld.ub	r8,r7++
80007a34:	f0 ca 00 30 	sub	r10,r8,48
80007a38:	58 9a       	cp.w	r10,9
80007a3a:	fe 98 ff f7 	brls	80007a28 <_vfprintf_r+0x3fc>
80007a3e:	e0 48 00 24 	cp.w	r8,36
80007a42:	fe 91 fe d7 	brne	800077f0 <_vfprintf_r+0x1c4>
80007a46:	e0 49 00 20 	cp.w	r9,32
80007a4a:	e0 89 0d 6f 	brgt	80009528 <_vfprintf_r+0x1efc>
80007a4e:	f2 c3 00 01 	sub	r3,r9,1
80007a52:	30 19       	mov	r9,1
80007a54:	50 39       	stdsp	sp[0xc],r9
80007a56:	cc ba       	rjmp	800077ec <_vfprintf_r+0x1c0>
80007a58:	a3 b5       	sbr	r5,0x3
80007a5a:	cc 9a       	rjmp	800077ec <_vfprintf_r+0x1c0>
80007a5c:	a7 a5       	sbr	r5,0x6
80007a5e:	cc 7a       	rjmp	800077ec <_vfprintf_r+0x1c0>
80007a60:	0a 98       	mov	r8,r5
80007a62:	a5 b5       	sbr	r5,0x5
80007a64:	a5 a8       	sbr	r8,0x4
80007a66:	0f 89       	ld.ub	r9,r7[0x0]
80007a68:	36 ce       	mov	lr,108
80007a6a:	fc 09 18 00 	cp.b	r9,lr
80007a6e:	f7 b7 00 ff 	subeq	r7,-1
80007a72:	f0 05 17 10 	movne	r5,r8
80007a76:	cb ba       	rjmp	800077ec <_vfprintf_r+0x1c0>
80007a78:	a5 b5       	sbr	r5,0x5
80007a7a:	cb 9a       	rjmp	800077ec <_vfprintf_r+0x1c0>
80007a7c:	50 a7       	stdsp	sp[0x28],r7
80007a7e:	50 80       	stdsp	sp[0x20],r0
80007a80:	0c 97       	mov	r7,r6
80007a82:	10 90       	mov	r0,r8
80007a84:	06 96       	mov	r6,r3
80007a86:	04 94       	mov	r4,r2
80007a88:	40 93       	lddsp	r3,sp[0x24]
80007a8a:	02 92       	mov	r2,r1
80007a8c:	0e 99       	mov	r9,r7
80007a8e:	40 41       	lddsp	r1,sp[0x10]
80007a90:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a94:	40 3c       	lddsp	r12,sp[0xc]
80007a96:	58 0c       	cp.w	r12,0
80007a98:	c1 d0       	breq	80007ad2 <_vfprintf_r+0x4a6>
80007a9a:	10 36       	cp.w	r6,r8
80007a9c:	c0 64       	brge	80007aa8 <_vfprintf_r+0x47c>
80007a9e:	fa cb f9 44 	sub	r11,sp,-1724
80007aa2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007aa6:	c1 d8       	rjmp	80007ae0 <_vfprintf_r+0x4b4>
80007aa8:	fa c8 f9 50 	sub	r8,sp,-1712
80007aac:	1a d8       	st.w	--sp,r8
80007aae:	fa c8 fa b8 	sub	r8,sp,-1352
80007ab2:	1a d8       	st.w	--sp,r8
80007ab4:	fa c8 fb b4 	sub	r8,sp,-1100
80007ab8:	1a d8       	st.w	--sp,r8
80007aba:	fa c8 f9 40 	sub	r8,sp,-1728
80007abe:	fa c9 ff b4 	sub	r9,sp,-76
80007ac2:	04 9a       	mov	r10,r2
80007ac4:	0c 9b       	mov	r11,r6
80007ac6:	08 9c       	mov	r12,r4
80007ac8:	fe b0 fc 1a 	rcall	800072fc <get_arg>
80007acc:	2f dd       	sub	sp,-12
80007ace:	19 b8       	ld.ub	r8,r12[0x3]
80007ad0:	c2 28       	rjmp	80007b14 <_vfprintf_r+0x4e8>
80007ad2:	2f f7       	sub	r7,-1
80007ad4:	10 39       	cp.w	r9,r8
80007ad6:	c0 84       	brge	80007ae6 <_vfprintf_r+0x4ba>
80007ad8:	fa ca f9 44 	sub	r10,sp,-1724
80007adc:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007ae0:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007ae4:	c1 88       	rjmp	80007b14 <_vfprintf_r+0x4e8>
80007ae6:	41 09       	lddsp	r9,sp[0x40]
80007ae8:	59 f8       	cp.w	r8,31
80007aea:	e0 89 00 12 	brgt	80007b0e <_vfprintf_r+0x4e2>
80007aee:	f2 ca ff fc 	sub	r10,r9,-4
80007af2:	51 0a       	stdsp	sp[0x40],r10
80007af4:	72 09       	ld.w	r9,r9[0x0]
80007af6:	fa c6 f9 44 	sub	r6,sp,-1724
80007afa:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007afe:	2f f8       	sub	r8,-1
80007b00:	f5 49 fd 88 	st.w	r10[-632],r9
80007b04:	fb 48 06 b4 	st.w	sp[1716],r8
80007b08:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007b0c:	c0 48       	rjmp	80007b14 <_vfprintf_r+0x4e8>
80007b0e:	13 b8       	ld.ub	r8,r9[0x3]
80007b10:	2f c9       	sub	r9,-4
80007b12:	51 09       	stdsp	sp[0x40],r9
80007b14:	fb 68 06 60 	st.b	sp[1632],r8
80007b18:	30 0e       	mov	lr,0
80007b1a:	30 08       	mov	r8,0
80007b1c:	30 12       	mov	r2,1
80007b1e:	fb 68 06 bb 	st.b	sp[1723],r8
80007b22:	50 2e       	stdsp	sp[0x8],lr
80007b24:	e0 8f 08 ad 	bral	80008c7e <_vfprintf_r+0x1652>
80007b28:	50 a7       	stdsp	sp[0x28],r7
80007b2a:	50 80       	stdsp	sp[0x20],r0
80007b2c:	0c 97       	mov	r7,r6
80007b2e:	04 94       	mov	r4,r2
80007b30:	06 96       	mov	r6,r3
80007b32:	02 92       	mov	r2,r1
80007b34:	40 93       	lddsp	r3,sp[0x24]
80007b36:	10 90       	mov	r0,r8
80007b38:	40 41       	lddsp	r1,sp[0x10]
80007b3a:	a5 a5       	sbr	r5,0x4
80007b3c:	c0 a8       	rjmp	80007b50 <_vfprintf_r+0x524>
80007b3e:	50 a7       	stdsp	sp[0x28],r7
80007b40:	50 80       	stdsp	sp[0x20],r0
80007b42:	0c 97       	mov	r7,r6
80007b44:	04 94       	mov	r4,r2
80007b46:	06 96       	mov	r6,r3
80007b48:	02 92       	mov	r2,r1
80007b4a:	40 93       	lddsp	r3,sp[0x24]
80007b4c:	10 90       	mov	r0,r8
80007b4e:	40 41       	lddsp	r1,sp[0x10]
80007b50:	ed b5 00 05 	bld	r5,0x5
80007b54:	c5 11       	brne	80007bf6 <_vfprintf_r+0x5ca>
80007b56:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b5a:	40 3c       	lddsp	r12,sp[0xc]
80007b5c:	58 0c       	cp.w	r12,0
80007b5e:	c1 e0       	breq	80007b9a <_vfprintf_r+0x56e>
80007b60:	10 36       	cp.w	r6,r8
80007b62:	c0 64       	brge	80007b6e <_vfprintf_r+0x542>
80007b64:	fa cb f9 44 	sub	r11,sp,-1724
80007b68:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007b6c:	c2 08       	rjmp	80007bac <_vfprintf_r+0x580>
80007b6e:	fa c8 f9 50 	sub	r8,sp,-1712
80007b72:	1a d8       	st.w	--sp,r8
80007b74:	fa c8 fa b8 	sub	r8,sp,-1352
80007b78:	0c 9b       	mov	r11,r6
80007b7a:	1a d8       	st.w	--sp,r8
80007b7c:	fa c8 fb b4 	sub	r8,sp,-1100
80007b80:	1a d8       	st.w	--sp,r8
80007b82:	fa c9 ff b4 	sub	r9,sp,-76
80007b86:	fa c8 f9 40 	sub	r8,sp,-1728
80007b8a:	04 9a       	mov	r10,r2
80007b8c:	08 9c       	mov	r12,r4
80007b8e:	fe b0 fb b7 	rcall	800072fc <get_arg>
80007b92:	2f dd       	sub	sp,-12
80007b94:	78 1b       	ld.w	r11,r12[0x4]
80007b96:	78 09       	ld.w	r9,r12[0x0]
80007b98:	c2 b8       	rjmp	80007bee <_vfprintf_r+0x5c2>
80007b9a:	ee ca ff ff 	sub	r10,r7,-1
80007b9e:	10 37       	cp.w	r7,r8
80007ba0:	c0 b4       	brge	80007bb6 <_vfprintf_r+0x58a>
80007ba2:	fa c9 f9 44 	sub	r9,sp,-1724
80007ba6:	14 97       	mov	r7,r10
80007ba8:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007bac:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007bb0:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007bb4:	c1 d8       	rjmp	80007bee <_vfprintf_r+0x5c2>
80007bb6:	41 09       	lddsp	r9,sp[0x40]
80007bb8:	59 f8       	cp.w	r8,31
80007bba:	e0 89 00 14 	brgt	80007be2 <_vfprintf_r+0x5b6>
80007bbe:	f2 cb ff f8 	sub	r11,r9,-8
80007bc2:	51 0b       	stdsp	sp[0x40],r11
80007bc4:	fa c6 f9 44 	sub	r6,sp,-1724
80007bc8:	72 1b       	ld.w	r11,r9[0x4]
80007bca:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007bce:	72 09       	ld.w	r9,r9[0x0]
80007bd0:	f9 4b fd 8c 	st.w	r12[-628],r11
80007bd4:	f9 49 fd 88 	st.w	r12[-632],r9
80007bd8:	2f f8       	sub	r8,-1
80007bda:	14 97       	mov	r7,r10
80007bdc:	fb 48 06 b4 	st.w	sp[1716],r8
80007be0:	c0 78       	rjmp	80007bee <_vfprintf_r+0x5c2>
80007be2:	f2 c8 ff f8 	sub	r8,r9,-8
80007be6:	72 1b       	ld.w	r11,r9[0x4]
80007be8:	14 97       	mov	r7,r10
80007bea:	51 08       	stdsp	sp[0x40],r8
80007bec:	72 09       	ld.w	r9,r9[0x0]
80007bee:	16 98       	mov	r8,r11
80007bf0:	fa e9 00 00 	st.d	sp[0],r8
80007bf4:	ca e8       	rjmp	80007d50 <_vfprintf_r+0x724>
80007bf6:	ed b5 00 04 	bld	r5,0x4
80007bfa:	c1 71       	brne	80007c28 <_vfprintf_r+0x5fc>
80007bfc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007c00:	40 3e       	lddsp	lr,sp[0xc]
80007c02:	58 0e       	cp.w	lr,0
80007c04:	c0 80       	breq	80007c14 <_vfprintf_r+0x5e8>
80007c06:	10 36       	cp.w	r6,r8
80007c08:	c6 94       	brge	80007cda <_vfprintf_r+0x6ae>
80007c0a:	fa cc f9 44 	sub	r12,sp,-1724
80007c0e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007c12:	c8 28       	rjmp	80007d16 <_vfprintf_r+0x6ea>
80007c14:	ee ca ff ff 	sub	r10,r7,-1
80007c18:	10 37       	cp.w	r7,r8
80007c1a:	e0 84 00 81 	brge	80007d1c <_vfprintf_r+0x6f0>
80007c1e:	fa cb f9 44 	sub	r11,sp,-1724
80007c22:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007c26:	c7 78       	rjmp	80007d14 <_vfprintf_r+0x6e8>
80007c28:	ed b5 00 06 	bld	r5,0x6
80007c2c:	c4 b1       	brne	80007cc2 <_vfprintf_r+0x696>
80007c2e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007c32:	40 3c       	lddsp	r12,sp[0xc]
80007c34:	58 0c       	cp.w	r12,0
80007c36:	c1 d0       	breq	80007c70 <_vfprintf_r+0x644>
80007c38:	10 36       	cp.w	r6,r8
80007c3a:	c0 64       	brge	80007c46 <_vfprintf_r+0x61a>
80007c3c:	fa cb f9 44 	sub	r11,sp,-1724
80007c40:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007c44:	c1 f8       	rjmp	80007c82 <_vfprintf_r+0x656>
80007c46:	fa c8 f9 50 	sub	r8,sp,-1712
80007c4a:	1a d8       	st.w	--sp,r8
80007c4c:	fa c8 fa b8 	sub	r8,sp,-1352
80007c50:	1a d8       	st.w	--sp,r8
80007c52:	fa c8 fb b4 	sub	r8,sp,-1100
80007c56:	1a d8       	st.w	--sp,r8
80007c58:	fa c8 f9 40 	sub	r8,sp,-1728
80007c5c:	fa c9 ff b4 	sub	r9,sp,-76
80007c60:	04 9a       	mov	r10,r2
80007c62:	0c 9b       	mov	r11,r6
80007c64:	08 9c       	mov	r12,r4
80007c66:	fe b0 fb 4b 	rcall	800072fc <get_arg>
80007c6a:	2f dd       	sub	sp,-12
80007c6c:	98 18       	ld.sh	r8,r12[0x2]
80007c6e:	c2 68       	rjmp	80007cba <_vfprintf_r+0x68e>
80007c70:	ee ca ff ff 	sub	r10,r7,-1
80007c74:	10 37       	cp.w	r7,r8
80007c76:	c0 94       	brge	80007c88 <_vfprintf_r+0x65c>
80007c78:	fa c9 f9 44 	sub	r9,sp,-1724
80007c7c:	14 97       	mov	r7,r10
80007c7e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007c82:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007c86:	c1 a8       	rjmp	80007cba <_vfprintf_r+0x68e>
80007c88:	41 09       	lddsp	r9,sp[0x40]
80007c8a:	59 f8       	cp.w	r8,31
80007c8c:	e0 89 00 13 	brgt	80007cb2 <_vfprintf_r+0x686>
80007c90:	f2 cb ff fc 	sub	r11,r9,-4
80007c94:	51 0b       	stdsp	sp[0x40],r11
80007c96:	72 09       	ld.w	r9,r9[0x0]
80007c98:	fa c6 f9 44 	sub	r6,sp,-1724
80007c9c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007ca0:	2f f8       	sub	r8,-1
80007ca2:	f7 49 fd 88 	st.w	r11[-632],r9
80007ca6:	fb 48 06 b4 	st.w	sp[1716],r8
80007caa:	14 97       	mov	r7,r10
80007cac:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007cb0:	c0 58       	rjmp	80007cba <_vfprintf_r+0x68e>
80007cb2:	92 18       	ld.sh	r8,r9[0x2]
80007cb4:	14 97       	mov	r7,r10
80007cb6:	2f c9       	sub	r9,-4
80007cb8:	51 09       	stdsp	sp[0x40],r9
80007cba:	50 18       	stdsp	sp[0x4],r8
80007cbc:	bf 58       	asr	r8,0x1f
80007cbe:	50 08       	stdsp	sp[0x0],r8
80007cc0:	c4 88       	rjmp	80007d50 <_vfprintf_r+0x724>
80007cc2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007cc6:	40 3c       	lddsp	r12,sp[0xc]
80007cc8:	58 0c       	cp.w	r12,0
80007cca:	c1 d0       	breq	80007d04 <_vfprintf_r+0x6d8>
80007ccc:	10 36       	cp.w	r6,r8
80007cce:	c0 64       	brge	80007cda <_vfprintf_r+0x6ae>
80007cd0:	fa cb f9 44 	sub	r11,sp,-1724
80007cd4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007cd8:	c1 f8       	rjmp	80007d16 <_vfprintf_r+0x6ea>
80007cda:	fa c8 f9 50 	sub	r8,sp,-1712
80007cde:	1a d8       	st.w	--sp,r8
80007ce0:	fa c8 fa b8 	sub	r8,sp,-1352
80007ce4:	0c 9b       	mov	r11,r6
80007ce6:	1a d8       	st.w	--sp,r8
80007ce8:	fa c8 fb b4 	sub	r8,sp,-1100
80007cec:	04 9a       	mov	r10,r2
80007cee:	1a d8       	st.w	--sp,r8
80007cf0:	08 9c       	mov	r12,r4
80007cf2:	fa c8 f9 40 	sub	r8,sp,-1728
80007cf6:	fa c9 ff b4 	sub	r9,sp,-76
80007cfa:	fe b0 fb 01 	rcall	800072fc <get_arg>
80007cfe:	2f dd       	sub	sp,-12
80007d00:	78 0b       	ld.w	r11,r12[0x0]
80007d02:	c2 48       	rjmp	80007d4a <_vfprintf_r+0x71e>
80007d04:	ee ca ff ff 	sub	r10,r7,-1
80007d08:	10 37       	cp.w	r7,r8
80007d0a:	c0 94       	brge	80007d1c <_vfprintf_r+0x6f0>
80007d0c:	fa c9 f9 44 	sub	r9,sp,-1724
80007d10:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007d14:	14 97       	mov	r7,r10
80007d16:	ec fb fd 88 	ld.w	r11,r6[-632]
80007d1a:	c1 88       	rjmp	80007d4a <_vfprintf_r+0x71e>
80007d1c:	41 09       	lddsp	r9,sp[0x40]
80007d1e:	59 f8       	cp.w	r8,31
80007d20:	e0 89 00 11 	brgt	80007d42 <_vfprintf_r+0x716>
80007d24:	f2 cb ff fc 	sub	r11,r9,-4
80007d28:	51 0b       	stdsp	sp[0x40],r11
80007d2a:	fa c6 f9 44 	sub	r6,sp,-1724
80007d2e:	72 0b       	ld.w	r11,r9[0x0]
80007d30:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007d34:	f3 4b fd 88 	st.w	r9[-632],r11
80007d38:	2f f8       	sub	r8,-1
80007d3a:	14 97       	mov	r7,r10
80007d3c:	fb 48 06 b4 	st.w	sp[1716],r8
80007d40:	c0 58       	rjmp	80007d4a <_vfprintf_r+0x71e>
80007d42:	72 0b       	ld.w	r11,r9[0x0]
80007d44:	14 97       	mov	r7,r10
80007d46:	2f c9       	sub	r9,-4
80007d48:	51 09       	stdsp	sp[0x40],r9
80007d4a:	50 1b       	stdsp	sp[0x4],r11
80007d4c:	bf 5b       	asr	r11,0x1f
80007d4e:	50 0b       	stdsp	sp[0x0],r11
80007d50:	fa ea 00 00 	ld.d	r10,sp[0]
80007d54:	58 0a       	cp.w	r10,0
80007d56:	5c 2b       	cpc	r11
80007d58:	c0 e4       	brge	80007d74 <_vfprintf_r+0x748>
80007d5a:	30 08       	mov	r8,0
80007d5c:	fa ea 00 00 	ld.d	r10,sp[0]
80007d60:	30 09       	mov	r9,0
80007d62:	f0 0a 01 0a 	sub	r10,r8,r10
80007d66:	f2 0b 01 4b 	sbc	r11,r9,r11
80007d6a:	32 d8       	mov	r8,45
80007d6c:	fa eb 00 00 	st.d	sp[0],r10
80007d70:	fb 68 06 bb 	st.b	sp[1723],r8
80007d74:	30 18       	mov	r8,1
80007d76:	e0 8f 06 fa 	bral	80008b6a <_vfprintf_r+0x153e>
80007d7a:	50 a7       	stdsp	sp[0x28],r7
80007d7c:	50 80       	stdsp	sp[0x20],r0
80007d7e:	0c 97       	mov	r7,r6
80007d80:	04 94       	mov	r4,r2
80007d82:	06 96       	mov	r6,r3
80007d84:	02 92       	mov	r2,r1
80007d86:	40 93       	lddsp	r3,sp[0x24]
80007d88:	10 90       	mov	r0,r8
80007d8a:	40 41       	lddsp	r1,sp[0x10]
80007d8c:	0e 99       	mov	r9,r7
80007d8e:	ed b5 00 03 	bld	r5,0x3
80007d92:	c4 11       	brne	80007e14 <_vfprintf_r+0x7e8>
80007d94:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d98:	40 3a       	lddsp	r10,sp[0xc]
80007d9a:	58 0a       	cp.w	r10,0
80007d9c:	c1 90       	breq	80007dce <_vfprintf_r+0x7a2>
80007d9e:	10 36       	cp.w	r6,r8
80007da0:	c6 45       	brlt	80007e68 <_vfprintf_r+0x83c>
80007da2:	fa c8 f9 50 	sub	r8,sp,-1712
80007da6:	1a d8       	st.w	--sp,r8
80007da8:	fa c8 fa b8 	sub	r8,sp,-1352
80007dac:	1a d8       	st.w	--sp,r8
80007dae:	fa c8 fb b4 	sub	r8,sp,-1100
80007db2:	0c 9b       	mov	r11,r6
80007db4:	1a d8       	st.w	--sp,r8
80007db6:	04 9a       	mov	r10,r2
80007db8:	fa c8 f9 40 	sub	r8,sp,-1728
80007dbc:	fa c9 ff b4 	sub	r9,sp,-76
80007dc0:	08 9c       	mov	r12,r4
80007dc2:	fe b0 fa 9d 	rcall	800072fc <get_arg>
80007dc6:	2f dd       	sub	sp,-12
80007dc8:	78 16       	ld.w	r6,r12[0x4]
80007dca:	50 76       	stdsp	sp[0x1c],r6
80007dcc:	c4 88       	rjmp	80007e5c <_vfprintf_r+0x830>
80007dce:	2f f7       	sub	r7,-1
80007dd0:	10 39       	cp.w	r9,r8
80007dd2:	c0 c4       	brge	80007dea <_vfprintf_r+0x7be>
80007dd4:	fa ce f9 44 	sub	lr,sp,-1724
80007dd8:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007ddc:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007de0:	50 7c       	stdsp	sp[0x1c],r12
80007de2:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007de6:	50 56       	stdsp	sp[0x14],r6
80007de8:	c6 68       	rjmp	80007eb4 <_vfprintf_r+0x888>
80007dea:	41 09       	lddsp	r9,sp[0x40]
80007dec:	59 f8       	cp.w	r8,31
80007dee:	e0 89 00 10 	brgt	80007e0e <_vfprintf_r+0x7e2>
80007df2:	f2 ca ff f8 	sub	r10,r9,-8
80007df6:	72 1b       	ld.w	r11,r9[0x4]
80007df8:	51 0a       	stdsp	sp[0x40],r10
80007dfa:	72 09       	ld.w	r9,r9[0x0]
80007dfc:	fa ca f9 44 	sub	r10,sp,-1724
80007e00:	50 7b       	stdsp	sp[0x1c],r11
80007e02:	50 59       	stdsp	sp[0x14],r9
80007e04:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007e08:	40 5b       	lddsp	r11,sp[0x14]
80007e0a:	40 7a       	lddsp	r10,sp[0x1c]
80007e0c:	c4 78       	rjmp	80007e9a <_vfprintf_r+0x86e>
80007e0e:	72 18       	ld.w	r8,r9[0x4]
80007e10:	50 78       	stdsp	sp[0x1c],r8
80007e12:	c4 c8       	rjmp	80007eaa <_vfprintf_r+0x87e>
80007e14:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e18:	40 3e       	lddsp	lr,sp[0xc]
80007e1a:	58 0e       	cp.w	lr,0
80007e1c:	c2 30       	breq	80007e62 <_vfprintf_r+0x836>
80007e1e:	10 36       	cp.w	r6,r8
80007e20:	c0 94       	brge	80007e32 <_vfprintf_r+0x806>
80007e22:	fa cc f9 44 	sub	r12,sp,-1724
80007e26:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007e2a:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007e2e:	50 7b       	stdsp	sp[0x1c],r11
80007e30:	cd 9b       	rjmp	80007de2 <_vfprintf_r+0x7b6>
80007e32:	fa c8 f9 50 	sub	r8,sp,-1712
80007e36:	1a d8       	st.w	--sp,r8
80007e38:	fa c8 fa b8 	sub	r8,sp,-1352
80007e3c:	04 9a       	mov	r10,r2
80007e3e:	1a d8       	st.w	--sp,r8
80007e40:	fa c8 fb b4 	sub	r8,sp,-1100
80007e44:	0c 9b       	mov	r11,r6
80007e46:	1a d8       	st.w	--sp,r8
80007e48:	08 9c       	mov	r12,r4
80007e4a:	fa c8 f9 40 	sub	r8,sp,-1728
80007e4e:	fa c9 ff b4 	sub	r9,sp,-76
80007e52:	fe b0 fa 55 	rcall	800072fc <get_arg>
80007e56:	2f dd       	sub	sp,-12
80007e58:	78 1a       	ld.w	r10,r12[0x4]
80007e5a:	50 7a       	stdsp	sp[0x1c],r10
80007e5c:	78 0c       	ld.w	r12,r12[0x0]
80007e5e:	50 5c       	stdsp	sp[0x14],r12
80007e60:	c2 a8       	rjmp	80007eb4 <_vfprintf_r+0x888>
80007e62:	2f f7       	sub	r7,-1
80007e64:	10 39       	cp.w	r9,r8
80007e66:	c0 94       	brge	80007e78 <_vfprintf_r+0x84c>
80007e68:	fa c9 f9 44 	sub	r9,sp,-1724
80007e6c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007e70:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80007e74:	50 78       	stdsp	sp[0x1c],r8
80007e76:	cb 6b       	rjmp	80007de2 <_vfprintf_r+0x7b6>
80007e78:	41 09       	lddsp	r9,sp[0x40]
80007e7a:	59 f8       	cp.w	r8,31
80007e7c:	e0 89 00 15 	brgt	80007ea6 <_vfprintf_r+0x87a>
80007e80:	f2 ca ff f8 	sub	r10,r9,-8
80007e84:	72 16       	ld.w	r6,r9[0x4]
80007e86:	72 09       	ld.w	r9,r9[0x0]
80007e88:	51 0a       	stdsp	sp[0x40],r10
80007e8a:	50 59       	stdsp	sp[0x14],r9
80007e8c:	fa ce f9 44 	sub	lr,sp,-1724
80007e90:	50 76       	stdsp	sp[0x1c],r6
80007e92:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007e96:	40 5b       	lddsp	r11,sp[0x14]
80007e98:	0c 9a       	mov	r10,r6
80007e9a:	f2 eb fd 88 	st.d	r9[-632],r10
80007e9e:	2f f8       	sub	r8,-1
80007ea0:	fb 48 06 b4 	st.w	sp[1716],r8
80007ea4:	c0 88       	rjmp	80007eb4 <_vfprintf_r+0x888>
80007ea6:	72 1c       	ld.w	r12,r9[0x4]
80007ea8:	50 7c       	stdsp	sp[0x1c],r12
80007eaa:	f2 c8 ff f8 	sub	r8,r9,-8
80007eae:	51 08       	stdsp	sp[0x40],r8
80007eb0:	72 09       	ld.w	r9,r9[0x0]
80007eb2:	50 59       	stdsp	sp[0x14],r9
80007eb4:	40 5b       	lddsp	r11,sp[0x14]
80007eb6:	40 7a       	lddsp	r10,sp[0x1c]
80007eb8:	e0 a0 1a 2e 	rcall	8000b314 <__isinfd>
80007ebc:	18 96       	mov	r6,r12
80007ebe:	c1 70       	breq	80007eec <_vfprintf_r+0x8c0>
80007ec0:	30 08       	mov	r8,0
80007ec2:	30 09       	mov	r9,0
80007ec4:	40 5b       	lddsp	r11,sp[0x14]
80007ec6:	40 7a       	lddsp	r10,sp[0x1c]
80007ec8:	e0 a0 1e 8e 	rcall	8000bbe4 <__avr32_f64_cmp_lt>
80007ecc:	c0 40       	breq	80007ed4 <_vfprintf_r+0x8a8>
80007ece:	32 d8       	mov	r8,45
80007ed0:	fb 68 06 bb 	st.b	sp[1723],r8
80007ed4:	fe c8 b7 10 	sub	r8,pc,-18672
80007ed8:	fe c6 b7 10 	sub	r6,pc,-18672
80007edc:	a7 d5       	cbr	r5,0x7
80007ede:	e0 40 00 47 	cp.w	r0,71
80007ee2:	f0 06 17 a0 	movle	r6,r8
80007ee6:	30 32       	mov	r2,3
80007ee8:	e0 8f 06 ce 	bral	80008c84 <_vfprintf_r+0x1658>
80007eec:	40 5b       	lddsp	r11,sp[0x14]
80007eee:	40 7a       	lddsp	r10,sp[0x1c]
80007ef0:	e0 a0 1a 27 	rcall	8000b33e <__isnand>
80007ef4:	c0 e0       	breq	80007f10 <_vfprintf_r+0x8e4>
80007ef6:	50 26       	stdsp	sp[0x8],r6
80007ef8:	fe c8 b7 2c 	sub	r8,pc,-18644
80007efc:	fe c6 b7 2c 	sub	r6,pc,-18644
80007f00:	a7 d5       	cbr	r5,0x7
80007f02:	e0 40 00 47 	cp.w	r0,71
80007f06:	f0 06 17 a0 	movle	r6,r8
80007f0a:	30 32       	mov	r2,3
80007f0c:	e0 8f 06 c2 	bral	80008c90 <_vfprintf_r+0x1664>
80007f10:	40 2a       	lddsp	r10,sp[0x8]
80007f12:	5b fa       	cp.w	r10,-1
80007f14:	c0 41       	brne	80007f1c <_vfprintf_r+0x8f0>
80007f16:	30 69       	mov	r9,6
80007f18:	50 29       	stdsp	sp[0x8],r9
80007f1a:	c1 18       	rjmp	80007f3c <_vfprintf_r+0x910>
80007f1c:	e0 40 00 47 	cp.w	r0,71
80007f20:	5f 09       	sreq	r9
80007f22:	e0 40 00 67 	cp.w	r0,103
80007f26:	5f 08       	sreq	r8
80007f28:	f3 e8 10 08 	or	r8,r9,r8
80007f2c:	f8 08 18 00 	cp.b	r8,r12
80007f30:	c0 60       	breq	80007f3c <_vfprintf_r+0x910>
80007f32:	40 28       	lddsp	r8,sp[0x8]
80007f34:	58 08       	cp.w	r8,0
80007f36:	f9 b8 00 01 	moveq	r8,1
80007f3a:	50 28       	stdsp	sp[0x8],r8
80007f3c:	40 78       	lddsp	r8,sp[0x1c]
80007f3e:	40 59       	lddsp	r9,sp[0x14]
80007f40:	fa e9 06 94 	st.d	sp[1684],r8
80007f44:	a9 a5       	sbr	r5,0x8
80007f46:	fa f8 06 94 	ld.w	r8,sp[1684]
80007f4a:	58 08       	cp.w	r8,0
80007f4c:	c0 65       	brlt	80007f58 <_vfprintf_r+0x92c>
80007f4e:	40 5e       	lddsp	lr,sp[0x14]
80007f50:	30 0c       	mov	r12,0
80007f52:	50 6e       	stdsp	sp[0x18],lr
80007f54:	50 9c       	stdsp	sp[0x24],r12
80007f56:	c0 78       	rjmp	80007f64 <_vfprintf_r+0x938>
80007f58:	40 5b       	lddsp	r11,sp[0x14]
80007f5a:	32 da       	mov	r10,45
80007f5c:	ee 1b 80 00 	eorh	r11,0x8000
80007f60:	50 9a       	stdsp	sp[0x24],r10
80007f62:	50 6b       	stdsp	sp[0x18],r11
80007f64:	e0 40 00 46 	cp.w	r0,70
80007f68:	5f 09       	sreq	r9
80007f6a:	e0 40 00 66 	cp.w	r0,102
80007f6e:	5f 08       	sreq	r8
80007f70:	f3 e8 10 08 	or	r8,r9,r8
80007f74:	50 48       	stdsp	sp[0x10],r8
80007f76:	c0 40       	breq	80007f7e <_vfprintf_r+0x952>
80007f78:	40 22       	lddsp	r2,sp[0x8]
80007f7a:	30 39       	mov	r9,3
80007f7c:	c1 08       	rjmp	80007f9c <_vfprintf_r+0x970>
80007f7e:	e0 40 00 45 	cp.w	r0,69
80007f82:	5f 09       	sreq	r9
80007f84:	e0 40 00 65 	cp.w	r0,101
80007f88:	5f 08       	sreq	r8
80007f8a:	40 22       	lddsp	r2,sp[0x8]
80007f8c:	10 49       	or	r9,r8
80007f8e:	2f f2       	sub	r2,-1
80007f90:	40 46       	lddsp	r6,sp[0x10]
80007f92:	ec 09 18 00 	cp.b	r9,r6
80007f96:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80007f9a:	30 29       	mov	r9,2
80007f9c:	fa c8 f9 5c 	sub	r8,sp,-1700
80007fa0:	1a d8       	st.w	--sp,r8
80007fa2:	fa c8 f9 54 	sub	r8,sp,-1708
80007fa6:	1a d8       	st.w	--sp,r8
80007fa8:	fa c8 f9 4c 	sub	r8,sp,-1716
80007fac:	08 9c       	mov	r12,r4
80007fae:	1a d8       	st.w	--sp,r8
80007fb0:	04 98       	mov	r8,r2
80007fb2:	40 9b       	lddsp	r11,sp[0x24]
80007fb4:	40 aa       	lddsp	r10,sp[0x28]
80007fb6:	e0 a0 0c 9d 	rcall	800098f0 <_dtoa_r>
80007fba:	e0 40 00 47 	cp.w	r0,71
80007fbe:	5f 19       	srne	r9
80007fc0:	e0 40 00 67 	cp.w	r0,103
80007fc4:	5f 18       	srne	r8
80007fc6:	18 96       	mov	r6,r12
80007fc8:	2f dd       	sub	sp,-12
80007fca:	f3 e8 00 08 	and	r8,r9,r8
80007fce:	c0 41       	brne	80007fd6 <_vfprintf_r+0x9aa>
80007fd0:	ed b5 00 00 	bld	r5,0x0
80007fd4:	c3 01       	brne	80008034 <_vfprintf_r+0xa08>
80007fd6:	ec 02 00 0e 	add	lr,r6,r2
80007fda:	50 3e       	stdsp	sp[0xc],lr
80007fdc:	40 4c       	lddsp	r12,sp[0x10]
80007fde:	58 0c       	cp.w	r12,0
80007fe0:	c1 50       	breq	8000800a <_vfprintf_r+0x9de>
80007fe2:	0d 89       	ld.ub	r9,r6[0x0]
80007fe4:	33 08       	mov	r8,48
80007fe6:	f0 09 18 00 	cp.b	r9,r8
80007fea:	c0 b1       	brne	80008000 <_vfprintf_r+0x9d4>
80007fec:	30 08       	mov	r8,0
80007fee:	30 09       	mov	r9,0
80007ff0:	40 6b       	lddsp	r11,sp[0x18]
80007ff2:	40 7a       	lddsp	r10,sp[0x1c]
80007ff4:	e0 a0 1d b1 	rcall	8000bb56 <__avr32_f64_cmp_eq>
80007ff8:	fb b2 00 01 	rsubeq	r2,1
80007ffc:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008000:	40 3b       	lddsp	r11,sp[0xc]
80008002:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008006:	10 0b       	add	r11,r8
80008008:	50 3b       	stdsp	sp[0xc],r11
8000800a:	40 6b       	lddsp	r11,sp[0x18]
8000800c:	30 08       	mov	r8,0
8000800e:	30 09       	mov	r9,0
80008010:	40 7a       	lddsp	r10,sp[0x1c]
80008012:	e0 a0 1d a2 	rcall	8000bb56 <__avr32_f64_cmp_eq>
80008016:	c0 90       	breq	80008028 <_vfprintf_r+0x9fc>
80008018:	40 3a       	lddsp	r10,sp[0xc]
8000801a:	fb 4a 06 a4 	st.w	sp[1700],r10
8000801e:	c0 58       	rjmp	80008028 <_vfprintf_r+0x9fc>
80008020:	10 c9       	st.b	r8++,r9
80008022:	fb 48 06 a4 	st.w	sp[1700],r8
80008026:	c0 28       	rjmp	8000802a <_vfprintf_r+0x9fe>
80008028:	33 09       	mov	r9,48
8000802a:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000802e:	40 3e       	lddsp	lr,sp[0xc]
80008030:	1c 38       	cp.w	r8,lr
80008032:	cf 73       	brcs	80008020 <_vfprintf_r+0x9f4>
80008034:	e0 40 00 47 	cp.w	r0,71
80008038:	5f 09       	sreq	r9
8000803a:	e0 40 00 67 	cp.w	r0,103
8000803e:	5f 08       	sreq	r8
80008040:	f3 e8 10 08 	or	r8,r9,r8
80008044:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008048:	0c 19       	sub	r9,r6
8000804a:	50 69       	stdsp	sp[0x18],r9
8000804c:	58 08       	cp.w	r8,0
8000804e:	c0 b0       	breq	80008064 <_vfprintf_r+0xa38>
80008050:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008054:	5b d8       	cp.w	r8,-3
80008056:	c0 55       	brlt	80008060 <_vfprintf_r+0xa34>
80008058:	40 2c       	lddsp	r12,sp[0x8]
8000805a:	18 38       	cp.w	r8,r12
8000805c:	e0 8a 00 6a 	brle	80008130 <_vfprintf_r+0xb04>
80008060:	20 20       	sub	r0,2
80008062:	c0 58       	rjmp	8000806c <_vfprintf_r+0xa40>
80008064:	e0 40 00 65 	cp.w	r0,101
80008068:	e0 89 00 46 	brgt	800080f4 <_vfprintf_r+0xac8>
8000806c:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008070:	fb 60 06 9c 	st.b	sp[1692],r0
80008074:	20 1b       	sub	r11,1
80008076:	fb 4b 06 ac 	st.w	sp[1708],r11
8000807a:	c0 47       	brpl	80008082 <_vfprintf_r+0xa56>
8000807c:	5c 3b       	neg	r11
8000807e:	32 d8       	mov	r8,45
80008080:	c0 28       	rjmp	80008084 <_vfprintf_r+0xa58>
80008082:	32 b8       	mov	r8,43
80008084:	fb 68 06 9d 	st.b	sp[1693],r8
80008088:	58 9b       	cp.w	r11,9
8000808a:	e0 8a 00 1d 	brle	800080c4 <_vfprintf_r+0xa98>
8000808e:	fa c9 fa 35 	sub	r9,sp,-1483
80008092:	30 aa       	mov	r10,10
80008094:	12 98       	mov	r8,r9
80008096:	0e 9c       	mov	r12,r7
80008098:	0c 92       	mov	r2,r6
8000809a:	f6 0a 0c 06 	divs	r6,r11,r10
8000809e:	0e 9b       	mov	r11,r7
800080a0:	2d 0b       	sub	r11,-48
800080a2:	10 fb       	st.b	--r8,r11
800080a4:	0c 9b       	mov	r11,r6
800080a6:	58 96       	cp.w	r6,9
800080a8:	fe 99 ff f9 	brgt	8000809a <_vfprintf_r+0xa6e>
800080ac:	2d 0b       	sub	r11,-48
800080ae:	18 97       	mov	r7,r12
800080b0:	04 96       	mov	r6,r2
800080b2:	10 fb       	st.b	--r8,r11
800080b4:	fa ca f9 62 	sub	r10,sp,-1694
800080b8:	c0 38       	rjmp	800080be <_vfprintf_r+0xa92>
800080ba:	11 3b       	ld.ub	r11,r8++
800080bc:	14 cb       	st.b	r10++,r11
800080be:	12 38       	cp.w	r8,r9
800080c0:	cf d3       	brcs	800080ba <_vfprintf_r+0xa8e>
800080c2:	c0 98       	rjmp	800080d4 <_vfprintf_r+0xaa8>
800080c4:	2d 0b       	sub	r11,-48
800080c6:	33 08       	mov	r8,48
800080c8:	fb 6b 06 9f 	st.b	sp[1695],r11
800080cc:	fb 68 06 9e 	st.b	sp[1694],r8
800080d0:	fa ca f9 60 	sub	r10,sp,-1696
800080d4:	fa c8 f9 64 	sub	r8,sp,-1692
800080d8:	f4 08 01 08 	sub	r8,r10,r8
800080dc:	50 e8       	stdsp	sp[0x38],r8
800080de:	10 92       	mov	r2,r8
800080e0:	40 6b       	lddsp	r11,sp[0x18]
800080e2:	16 02       	add	r2,r11
800080e4:	58 1b       	cp.w	r11,1
800080e6:	e0 89 00 05 	brgt	800080f0 <_vfprintf_r+0xac4>
800080ea:	ed b5 00 00 	bld	r5,0x0
800080ee:	c3 51       	brne	80008158 <_vfprintf_r+0xb2c>
800080f0:	2f f2       	sub	r2,-1
800080f2:	c3 38       	rjmp	80008158 <_vfprintf_r+0xb2c>
800080f4:	e0 40 00 66 	cp.w	r0,102
800080f8:	c1 c1       	brne	80008130 <_vfprintf_r+0xb04>
800080fa:	fa f2 06 ac 	ld.w	r2,sp[1708]
800080fe:	58 02       	cp.w	r2,0
80008100:	e0 8a 00 0c 	brle	80008118 <_vfprintf_r+0xaec>
80008104:	40 2a       	lddsp	r10,sp[0x8]
80008106:	58 0a       	cp.w	r10,0
80008108:	c0 41       	brne	80008110 <_vfprintf_r+0xae4>
8000810a:	ed b5 00 00 	bld	r5,0x0
8000810e:	c2 51       	brne	80008158 <_vfprintf_r+0xb2c>
80008110:	2f f2       	sub	r2,-1
80008112:	40 29       	lddsp	r9,sp[0x8]
80008114:	12 02       	add	r2,r9
80008116:	c0 b8       	rjmp	8000812c <_vfprintf_r+0xb00>
80008118:	40 28       	lddsp	r8,sp[0x8]
8000811a:	58 08       	cp.w	r8,0
8000811c:	c0 61       	brne	80008128 <_vfprintf_r+0xafc>
8000811e:	ed b5 00 00 	bld	r5,0x0
80008122:	c0 30       	breq	80008128 <_vfprintf_r+0xafc>
80008124:	30 12       	mov	r2,1
80008126:	c1 98       	rjmp	80008158 <_vfprintf_r+0xb2c>
80008128:	40 22       	lddsp	r2,sp[0x8]
8000812a:	2f e2       	sub	r2,-2
8000812c:	36 60       	mov	r0,102
8000812e:	c1 58       	rjmp	80008158 <_vfprintf_r+0xb2c>
80008130:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008134:	40 6e       	lddsp	lr,sp[0x18]
80008136:	1c 32       	cp.w	r2,lr
80008138:	c0 65       	brlt	80008144 <_vfprintf_r+0xb18>
8000813a:	ed b5 00 00 	bld	r5,0x0
8000813e:	f7 b2 00 ff 	subeq	r2,-1
80008142:	c0 a8       	rjmp	80008156 <_vfprintf_r+0xb2a>
80008144:	e4 08 11 02 	rsub	r8,r2,2
80008148:	40 6c       	lddsp	r12,sp[0x18]
8000814a:	58 02       	cp.w	r2,0
8000814c:	f0 02 17 a0 	movle	r2,r8
80008150:	f9 b2 09 01 	movgt	r2,1
80008154:	18 02       	add	r2,r12
80008156:	36 70       	mov	r0,103
80008158:	40 9b       	lddsp	r11,sp[0x24]
8000815a:	58 0b       	cp.w	r11,0
8000815c:	e0 80 05 94 	breq	80008c84 <_vfprintf_r+0x1658>
80008160:	32 d8       	mov	r8,45
80008162:	fb 68 06 bb 	st.b	sp[1723],r8
80008166:	e0 8f 05 93 	bral	80008c8c <_vfprintf_r+0x1660>
8000816a:	50 a7       	stdsp	sp[0x28],r7
8000816c:	04 94       	mov	r4,r2
8000816e:	0c 97       	mov	r7,r6
80008170:	02 92       	mov	r2,r1
80008172:	06 96       	mov	r6,r3
80008174:	40 41       	lddsp	r1,sp[0x10]
80008176:	40 93       	lddsp	r3,sp[0x24]
80008178:	0e 99       	mov	r9,r7
8000817a:	ed b5 00 05 	bld	r5,0x5
8000817e:	c4 81       	brne	8000820e <_vfprintf_r+0xbe2>
80008180:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008184:	40 3e       	lddsp	lr,sp[0xc]
80008186:	58 0e       	cp.w	lr,0
80008188:	c1 d0       	breq	800081c2 <_vfprintf_r+0xb96>
8000818a:	10 36       	cp.w	r6,r8
8000818c:	c0 64       	brge	80008198 <_vfprintf_r+0xb6c>
8000818e:	fa cc f9 44 	sub	r12,sp,-1724
80008192:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008196:	c1 d8       	rjmp	800081d0 <_vfprintf_r+0xba4>
80008198:	fa c8 f9 50 	sub	r8,sp,-1712
8000819c:	1a d8       	st.w	--sp,r8
8000819e:	fa c8 fa b8 	sub	r8,sp,-1352
800081a2:	04 9a       	mov	r10,r2
800081a4:	1a d8       	st.w	--sp,r8
800081a6:	fa c8 fb b4 	sub	r8,sp,-1100
800081aa:	0c 9b       	mov	r11,r6
800081ac:	1a d8       	st.w	--sp,r8
800081ae:	08 9c       	mov	r12,r4
800081b0:	fa c8 f9 40 	sub	r8,sp,-1728
800081b4:	fa c9 ff b4 	sub	r9,sp,-76
800081b8:	fe b0 f8 a2 	rcall	800072fc <get_arg>
800081bc:	2f dd       	sub	sp,-12
800081be:	78 0a       	ld.w	r10,r12[0x0]
800081c0:	c2 08       	rjmp	80008200 <_vfprintf_r+0xbd4>
800081c2:	2f f7       	sub	r7,-1
800081c4:	10 39       	cp.w	r9,r8
800081c6:	c0 84       	brge	800081d6 <_vfprintf_r+0xbaa>
800081c8:	fa cb f9 44 	sub	r11,sp,-1724
800081cc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081d0:	ec fa fd 88 	ld.w	r10,r6[-632]
800081d4:	c1 68       	rjmp	80008200 <_vfprintf_r+0xbd4>
800081d6:	41 09       	lddsp	r9,sp[0x40]
800081d8:	59 f8       	cp.w	r8,31
800081da:	e0 89 00 10 	brgt	800081fa <_vfprintf_r+0xbce>
800081de:	f2 ca ff fc 	sub	r10,r9,-4
800081e2:	51 0a       	stdsp	sp[0x40],r10
800081e4:	fa c6 f9 44 	sub	r6,sp,-1724
800081e8:	72 0a       	ld.w	r10,r9[0x0]
800081ea:	ec 08 00 39 	add	r9,r6,r8<<0x3
800081ee:	f3 4a fd 88 	st.w	r9[-632],r10
800081f2:	2f f8       	sub	r8,-1
800081f4:	fb 48 06 b4 	st.w	sp[1716],r8
800081f8:	c0 48       	rjmp	80008200 <_vfprintf_r+0xbd4>
800081fa:	72 0a       	ld.w	r10,r9[0x0]
800081fc:	2f c9       	sub	r9,-4
800081fe:	51 09       	stdsp	sp[0x40],r9
80008200:	40 be       	lddsp	lr,sp[0x2c]
80008202:	1c 98       	mov	r8,lr
80008204:	95 1e       	st.w	r10[0x4],lr
80008206:	bf 58       	asr	r8,0x1f
80008208:	95 08       	st.w	r10[0x0],r8
8000820a:	fe 9f fa 9f 	bral	80007748 <_vfprintf_r+0x11c>
8000820e:	ed b5 00 04 	bld	r5,0x4
80008212:	c4 80       	breq	800082a2 <_vfprintf_r+0xc76>
80008214:	e2 15 00 40 	andl	r5,0x40,COH
80008218:	c4 50       	breq	800082a2 <_vfprintf_r+0xc76>
8000821a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000821e:	40 3c       	lddsp	r12,sp[0xc]
80008220:	58 0c       	cp.w	r12,0
80008222:	c1 d0       	breq	8000825c <_vfprintf_r+0xc30>
80008224:	10 36       	cp.w	r6,r8
80008226:	c0 64       	brge	80008232 <_vfprintf_r+0xc06>
80008228:	fa cb f9 44 	sub	r11,sp,-1724
8000822c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008230:	c1 d8       	rjmp	8000826a <_vfprintf_r+0xc3e>
80008232:	fa c8 f9 50 	sub	r8,sp,-1712
80008236:	1a d8       	st.w	--sp,r8
80008238:	fa c8 fa b8 	sub	r8,sp,-1352
8000823c:	04 9a       	mov	r10,r2
8000823e:	1a d8       	st.w	--sp,r8
80008240:	fa c8 fb b4 	sub	r8,sp,-1100
80008244:	0c 9b       	mov	r11,r6
80008246:	1a d8       	st.w	--sp,r8
80008248:	08 9c       	mov	r12,r4
8000824a:	fa c8 f9 40 	sub	r8,sp,-1728
8000824e:	fa c9 ff b4 	sub	r9,sp,-76
80008252:	fe b0 f8 55 	rcall	800072fc <get_arg>
80008256:	2f dd       	sub	sp,-12
80008258:	78 0a       	ld.w	r10,r12[0x0]
8000825a:	c2 08       	rjmp	8000829a <_vfprintf_r+0xc6e>
8000825c:	2f f7       	sub	r7,-1
8000825e:	10 39       	cp.w	r9,r8
80008260:	c0 84       	brge	80008270 <_vfprintf_r+0xc44>
80008262:	fa ca f9 44 	sub	r10,sp,-1724
80008266:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000826a:	ec fa fd 88 	ld.w	r10,r6[-632]
8000826e:	c1 68       	rjmp	8000829a <_vfprintf_r+0xc6e>
80008270:	41 09       	lddsp	r9,sp[0x40]
80008272:	59 f8       	cp.w	r8,31
80008274:	e0 89 00 10 	brgt	80008294 <_vfprintf_r+0xc68>
80008278:	f2 ca ff fc 	sub	r10,r9,-4
8000827c:	51 0a       	stdsp	sp[0x40],r10
8000827e:	fa c6 f9 44 	sub	r6,sp,-1724
80008282:	72 0a       	ld.w	r10,r9[0x0]
80008284:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008288:	f3 4a fd 88 	st.w	r9[-632],r10
8000828c:	2f f8       	sub	r8,-1
8000828e:	fb 48 06 b4 	st.w	sp[1716],r8
80008292:	c0 48       	rjmp	8000829a <_vfprintf_r+0xc6e>
80008294:	72 0a       	ld.w	r10,r9[0x0]
80008296:	2f c9       	sub	r9,-4
80008298:	51 09       	stdsp	sp[0x40],r9
8000829a:	40 be       	lddsp	lr,sp[0x2c]
8000829c:	b4 0e       	st.h	r10[0x0],lr
8000829e:	fe 9f fa 55 	bral	80007748 <_vfprintf_r+0x11c>
800082a2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082a6:	40 3c       	lddsp	r12,sp[0xc]
800082a8:	58 0c       	cp.w	r12,0
800082aa:	c1 d0       	breq	800082e4 <_vfprintf_r+0xcb8>
800082ac:	10 36       	cp.w	r6,r8
800082ae:	c0 64       	brge	800082ba <_vfprintf_r+0xc8e>
800082b0:	fa cb f9 44 	sub	r11,sp,-1724
800082b4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800082b8:	c1 d8       	rjmp	800082f2 <_vfprintf_r+0xcc6>
800082ba:	fa c8 f9 50 	sub	r8,sp,-1712
800082be:	1a d8       	st.w	--sp,r8
800082c0:	fa c8 fa b8 	sub	r8,sp,-1352
800082c4:	04 9a       	mov	r10,r2
800082c6:	1a d8       	st.w	--sp,r8
800082c8:	fa c8 fb b4 	sub	r8,sp,-1100
800082cc:	0c 9b       	mov	r11,r6
800082ce:	1a d8       	st.w	--sp,r8
800082d0:	08 9c       	mov	r12,r4
800082d2:	fa c8 f9 40 	sub	r8,sp,-1728
800082d6:	fa c9 ff b4 	sub	r9,sp,-76
800082da:	fe b0 f8 11 	rcall	800072fc <get_arg>
800082de:	2f dd       	sub	sp,-12
800082e0:	78 0a       	ld.w	r10,r12[0x0]
800082e2:	c2 08       	rjmp	80008322 <_vfprintf_r+0xcf6>
800082e4:	2f f7       	sub	r7,-1
800082e6:	10 39       	cp.w	r9,r8
800082e8:	c0 84       	brge	800082f8 <_vfprintf_r+0xccc>
800082ea:	fa ca f9 44 	sub	r10,sp,-1724
800082ee:	f4 06 00 36 	add	r6,r10,r6<<0x3
800082f2:	ec fa fd 88 	ld.w	r10,r6[-632]
800082f6:	c1 68       	rjmp	80008322 <_vfprintf_r+0xcf6>
800082f8:	41 09       	lddsp	r9,sp[0x40]
800082fa:	59 f8       	cp.w	r8,31
800082fc:	e0 89 00 10 	brgt	8000831c <_vfprintf_r+0xcf0>
80008300:	f2 ca ff fc 	sub	r10,r9,-4
80008304:	51 0a       	stdsp	sp[0x40],r10
80008306:	fa c6 f9 44 	sub	r6,sp,-1724
8000830a:	72 0a       	ld.w	r10,r9[0x0]
8000830c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008310:	f3 4a fd 88 	st.w	r9[-632],r10
80008314:	2f f8       	sub	r8,-1
80008316:	fb 48 06 b4 	st.w	sp[1716],r8
8000831a:	c0 48       	rjmp	80008322 <_vfprintf_r+0xcf6>
8000831c:	72 0a       	ld.w	r10,r9[0x0]
8000831e:	2f c9       	sub	r9,-4
80008320:	51 09       	stdsp	sp[0x40],r9
80008322:	40 be       	lddsp	lr,sp[0x2c]
80008324:	95 0e       	st.w	r10[0x0],lr
80008326:	fe 9f fa 11 	bral	80007748 <_vfprintf_r+0x11c>
8000832a:	50 a7       	stdsp	sp[0x28],r7
8000832c:	50 80       	stdsp	sp[0x20],r0
8000832e:	0c 97       	mov	r7,r6
80008330:	04 94       	mov	r4,r2
80008332:	06 96       	mov	r6,r3
80008334:	02 92       	mov	r2,r1
80008336:	40 93       	lddsp	r3,sp[0x24]
80008338:	10 90       	mov	r0,r8
8000833a:	40 41       	lddsp	r1,sp[0x10]
8000833c:	a5 a5       	sbr	r5,0x4
8000833e:	c0 a8       	rjmp	80008352 <_vfprintf_r+0xd26>
80008340:	50 a7       	stdsp	sp[0x28],r7
80008342:	50 80       	stdsp	sp[0x20],r0
80008344:	0c 97       	mov	r7,r6
80008346:	04 94       	mov	r4,r2
80008348:	06 96       	mov	r6,r3
8000834a:	02 92       	mov	r2,r1
8000834c:	40 93       	lddsp	r3,sp[0x24]
8000834e:	10 90       	mov	r0,r8
80008350:	40 41       	lddsp	r1,sp[0x10]
80008352:	ed b5 00 05 	bld	r5,0x5
80008356:	c5 d1       	brne	80008410 <_vfprintf_r+0xde4>
80008358:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000835c:	40 3c       	lddsp	r12,sp[0xc]
8000835e:	58 0c       	cp.w	r12,0
80008360:	c2 60       	breq	800083ac <_vfprintf_r+0xd80>
80008362:	10 36       	cp.w	r6,r8
80008364:	c0 a4       	brge	80008378 <_vfprintf_r+0xd4c>
80008366:	fa cb f9 44 	sub	r11,sp,-1724
8000836a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000836e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008372:	fa e9 00 00 	st.d	sp[0],r8
80008376:	c1 88       	rjmp	800083a6 <_vfprintf_r+0xd7a>
80008378:	fa c8 f9 50 	sub	r8,sp,-1712
8000837c:	1a d8       	st.w	--sp,r8
8000837e:	fa c8 fa b8 	sub	r8,sp,-1352
80008382:	04 9a       	mov	r10,r2
80008384:	1a d8       	st.w	--sp,r8
80008386:	0c 9b       	mov	r11,r6
80008388:	fa c8 fb b4 	sub	r8,sp,-1100
8000838c:	08 9c       	mov	r12,r4
8000838e:	1a d8       	st.w	--sp,r8
80008390:	fa c8 f9 40 	sub	r8,sp,-1728
80008394:	fa c9 ff b4 	sub	r9,sp,-76
80008398:	fe b0 f7 b2 	rcall	800072fc <get_arg>
8000839c:	2f dd       	sub	sp,-12
8000839e:	f8 ea 00 00 	ld.d	r10,r12[0]
800083a2:	fa eb 00 00 	st.d	sp[0],r10
800083a6:	30 08       	mov	r8,0
800083a8:	e0 8f 03 de 	bral	80008b64 <_vfprintf_r+0x1538>
800083ac:	ee ca ff ff 	sub	r10,r7,-1
800083b0:	10 37       	cp.w	r7,r8
800083b2:	c0 b4       	brge	800083c8 <_vfprintf_r+0xd9c>
800083b4:	fa c9 f9 44 	sub	r9,sp,-1724
800083b8:	14 97       	mov	r7,r10
800083ba:	f2 06 00 36 	add	r6,r9,r6<<0x3
800083be:	ec ea fd 88 	ld.d	r10,r6[-632]
800083c2:	fa eb 00 00 	st.d	sp[0],r10
800083c6:	c1 88       	rjmp	800083f6 <_vfprintf_r+0xdca>
800083c8:	41 09       	lddsp	r9,sp[0x40]
800083ca:	59 f8       	cp.w	r8,31
800083cc:	e0 89 00 18 	brgt	800083fc <_vfprintf_r+0xdd0>
800083d0:	f2 e6 00 00 	ld.d	r6,r9[0]
800083d4:	f2 cb ff f8 	sub	r11,r9,-8
800083d8:	fa e7 00 00 	st.d	sp[0],r6
800083dc:	51 0b       	stdsp	sp[0x40],r11
800083de:	fa c6 f9 44 	sub	r6,sp,-1724
800083e2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800083e6:	fa e6 00 00 	ld.d	r6,sp[0]
800083ea:	f2 e7 fd 88 	st.d	r9[-632],r6
800083ee:	2f f8       	sub	r8,-1
800083f0:	14 97       	mov	r7,r10
800083f2:	fb 48 06 b4 	st.w	sp[1716],r8
800083f6:	40 38       	lddsp	r8,sp[0xc]
800083f8:	e0 8f 03 b6 	bral	80008b64 <_vfprintf_r+0x1538>
800083fc:	f2 e6 00 00 	ld.d	r6,r9[0]
80008400:	40 38       	lddsp	r8,sp[0xc]
80008402:	fa e7 00 00 	st.d	sp[0],r6
80008406:	2f 89       	sub	r9,-8
80008408:	14 97       	mov	r7,r10
8000840a:	51 09       	stdsp	sp[0x40],r9
8000840c:	e0 8f 03 ac 	bral	80008b64 <_vfprintf_r+0x1538>
80008410:	ed b5 00 04 	bld	r5,0x4
80008414:	c1 61       	brne	80008440 <_vfprintf_r+0xe14>
80008416:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000841a:	40 3e       	lddsp	lr,sp[0xc]
8000841c:	58 0e       	cp.w	lr,0
8000841e:	c0 80       	breq	8000842e <_vfprintf_r+0xe02>
80008420:	10 36       	cp.w	r6,r8
80008422:	c6 74       	brge	800084f0 <_vfprintf_r+0xec4>
80008424:	fa cc f9 44 	sub	r12,sp,-1724
80008428:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000842c:	c8 08       	rjmp	8000852c <_vfprintf_r+0xf00>
8000842e:	ee ca ff ff 	sub	r10,r7,-1
80008432:	10 37       	cp.w	r7,r8
80008434:	c7 f4       	brge	80008532 <_vfprintf_r+0xf06>
80008436:	fa cb f9 44 	sub	r11,sp,-1724
8000843a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000843e:	c7 68       	rjmp	8000852a <_vfprintf_r+0xefe>
80008440:	ed b5 00 06 	bld	r5,0x6
80008444:	c4 a1       	brne	800084d8 <_vfprintf_r+0xeac>
80008446:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000844a:	40 3c       	lddsp	r12,sp[0xc]
8000844c:	58 0c       	cp.w	r12,0
8000844e:	c1 d0       	breq	80008488 <_vfprintf_r+0xe5c>
80008450:	10 36       	cp.w	r6,r8
80008452:	c0 64       	brge	8000845e <_vfprintf_r+0xe32>
80008454:	fa cb f9 44 	sub	r11,sp,-1724
80008458:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000845c:	c1 f8       	rjmp	8000849a <_vfprintf_r+0xe6e>
8000845e:	fa c8 f9 50 	sub	r8,sp,-1712
80008462:	1a d8       	st.w	--sp,r8
80008464:	fa c8 fa b8 	sub	r8,sp,-1352
80008468:	1a d8       	st.w	--sp,r8
8000846a:	fa c8 fb b4 	sub	r8,sp,-1100
8000846e:	1a d8       	st.w	--sp,r8
80008470:	fa c8 f9 40 	sub	r8,sp,-1728
80008474:	fa c9 ff b4 	sub	r9,sp,-76
80008478:	04 9a       	mov	r10,r2
8000847a:	0c 9b       	mov	r11,r6
8000847c:	08 9c       	mov	r12,r4
8000847e:	fe b0 f7 3f 	rcall	800072fc <get_arg>
80008482:	2f dd       	sub	sp,-12
80008484:	98 18       	ld.sh	r8,r12[0x2]
80008486:	c2 68       	rjmp	800084d2 <_vfprintf_r+0xea6>
80008488:	ee ca ff ff 	sub	r10,r7,-1
8000848c:	10 37       	cp.w	r7,r8
8000848e:	c0 94       	brge	800084a0 <_vfprintf_r+0xe74>
80008490:	fa c9 f9 44 	sub	r9,sp,-1724
80008494:	14 97       	mov	r7,r10
80008496:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000849a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000849e:	c1 a8       	rjmp	800084d2 <_vfprintf_r+0xea6>
800084a0:	41 09       	lddsp	r9,sp[0x40]
800084a2:	59 f8       	cp.w	r8,31
800084a4:	e0 89 00 13 	brgt	800084ca <_vfprintf_r+0xe9e>
800084a8:	f2 cb ff fc 	sub	r11,r9,-4
800084ac:	51 0b       	stdsp	sp[0x40],r11
800084ae:	72 09       	ld.w	r9,r9[0x0]
800084b0:	fa c6 f9 44 	sub	r6,sp,-1724
800084b4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800084b8:	2f f8       	sub	r8,-1
800084ba:	f7 49 fd 88 	st.w	r11[-632],r9
800084be:	fb 48 06 b4 	st.w	sp[1716],r8
800084c2:	14 97       	mov	r7,r10
800084c4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800084c8:	c0 58       	rjmp	800084d2 <_vfprintf_r+0xea6>
800084ca:	92 18       	ld.sh	r8,r9[0x2]
800084cc:	14 97       	mov	r7,r10
800084ce:	2f c9       	sub	r9,-4
800084d0:	51 09       	stdsp	sp[0x40],r9
800084d2:	5c 78       	castu.h	r8
800084d4:	50 18       	stdsp	sp[0x4],r8
800084d6:	c4 68       	rjmp	80008562 <_vfprintf_r+0xf36>
800084d8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084dc:	40 3c       	lddsp	r12,sp[0xc]
800084de:	58 0c       	cp.w	r12,0
800084e0:	c1 d0       	breq	8000851a <_vfprintf_r+0xeee>
800084e2:	10 36       	cp.w	r6,r8
800084e4:	c0 64       	brge	800084f0 <_vfprintf_r+0xec4>
800084e6:	fa cb f9 44 	sub	r11,sp,-1724
800084ea:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084ee:	c1 f8       	rjmp	8000852c <_vfprintf_r+0xf00>
800084f0:	fa c8 f9 50 	sub	r8,sp,-1712
800084f4:	1a d8       	st.w	--sp,r8
800084f6:	fa c8 fa b8 	sub	r8,sp,-1352
800084fa:	0c 9b       	mov	r11,r6
800084fc:	1a d8       	st.w	--sp,r8
800084fe:	fa c8 fb b4 	sub	r8,sp,-1100
80008502:	04 9a       	mov	r10,r2
80008504:	1a d8       	st.w	--sp,r8
80008506:	08 9c       	mov	r12,r4
80008508:	fa c8 f9 40 	sub	r8,sp,-1728
8000850c:	fa c9 ff b4 	sub	r9,sp,-76
80008510:	fe b0 f6 f6 	rcall	800072fc <get_arg>
80008514:	2f dd       	sub	sp,-12
80008516:	78 0b       	ld.w	r11,r12[0x0]
80008518:	c2 48       	rjmp	80008560 <_vfprintf_r+0xf34>
8000851a:	ee ca ff ff 	sub	r10,r7,-1
8000851e:	10 37       	cp.w	r7,r8
80008520:	c0 94       	brge	80008532 <_vfprintf_r+0xf06>
80008522:	fa c9 f9 44 	sub	r9,sp,-1724
80008526:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000852a:	14 97       	mov	r7,r10
8000852c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008530:	c1 88       	rjmp	80008560 <_vfprintf_r+0xf34>
80008532:	41 09       	lddsp	r9,sp[0x40]
80008534:	59 f8       	cp.w	r8,31
80008536:	e0 89 00 11 	brgt	80008558 <_vfprintf_r+0xf2c>
8000853a:	f2 cb ff fc 	sub	r11,r9,-4
8000853e:	51 0b       	stdsp	sp[0x40],r11
80008540:	fa c6 f9 44 	sub	r6,sp,-1724
80008544:	72 0b       	ld.w	r11,r9[0x0]
80008546:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000854a:	f3 4b fd 88 	st.w	r9[-632],r11
8000854e:	2f f8       	sub	r8,-1
80008550:	14 97       	mov	r7,r10
80008552:	fb 48 06 b4 	st.w	sp[1716],r8
80008556:	c0 58       	rjmp	80008560 <_vfprintf_r+0xf34>
80008558:	72 0b       	ld.w	r11,r9[0x0]
8000855a:	14 97       	mov	r7,r10
8000855c:	2f c9       	sub	r9,-4
8000855e:	51 09       	stdsp	sp[0x40],r9
80008560:	50 1b       	stdsp	sp[0x4],r11
80008562:	30 0e       	mov	lr,0
80008564:	50 0e       	stdsp	sp[0x0],lr
80008566:	1c 98       	mov	r8,lr
80008568:	e0 8f 02 fe 	bral	80008b64 <_vfprintf_r+0x1538>
8000856c:	50 a7       	stdsp	sp[0x28],r7
8000856e:	50 80       	stdsp	sp[0x20],r0
80008570:	0c 97       	mov	r7,r6
80008572:	04 94       	mov	r4,r2
80008574:	06 96       	mov	r6,r3
80008576:	02 92       	mov	r2,r1
80008578:	40 93       	lddsp	r3,sp[0x24]
8000857a:	40 41       	lddsp	r1,sp[0x10]
8000857c:	0e 99       	mov	r9,r7
8000857e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008582:	40 3c       	lddsp	r12,sp[0xc]
80008584:	58 0c       	cp.w	r12,0
80008586:	c1 d0       	breq	800085c0 <_vfprintf_r+0xf94>
80008588:	10 36       	cp.w	r6,r8
8000858a:	c0 64       	brge	80008596 <_vfprintf_r+0xf6a>
8000858c:	fa cb f9 44 	sub	r11,sp,-1724
80008590:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008594:	c1 d8       	rjmp	800085ce <_vfprintf_r+0xfa2>
80008596:	fa c8 f9 50 	sub	r8,sp,-1712
8000859a:	1a d8       	st.w	--sp,r8
8000859c:	fa c8 fa b8 	sub	r8,sp,-1352
800085a0:	1a d8       	st.w	--sp,r8
800085a2:	fa c8 fb b4 	sub	r8,sp,-1100
800085a6:	1a d8       	st.w	--sp,r8
800085a8:	fa c9 ff b4 	sub	r9,sp,-76
800085ac:	fa c8 f9 40 	sub	r8,sp,-1728
800085b0:	04 9a       	mov	r10,r2
800085b2:	0c 9b       	mov	r11,r6
800085b4:	08 9c       	mov	r12,r4
800085b6:	fe b0 f6 a3 	rcall	800072fc <get_arg>
800085ba:	2f dd       	sub	sp,-12
800085bc:	78 09       	ld.w	r9,r12[0x0]
800085be:	c2 18       	rjmp	80008600 <_vfprintf_r+0xfd4>
800085c0:	2f f7       	sub	r7,-1
800085c2:	10 39       	cp.w	r9,r8
800085c4:	c0 84       	brge	800085d4 <_vfprintf_r+0xfa8>
800085c6:	fa ca f9 44 	sub	r10,sp,-1724
800085ca:	f4 06 00 36 	add	r6,r10,r6<<0x3
800085ce:	ec f9 fd 88 	ld.w	r9,r6[-632]
800085d2:	c1 78       	rjmp	80008600 <_vfprintf_r+0xfd4>
800085d4:	41 09       	lddsp	r9,sp[0x40]
800085d6:	59 f8       	cp.w	r8,31
800085d8:	e0 89 00 10 	brgt	800085f8 <_vfprintf_r+0xfcc>
800085dc:	f2 ca ff fc 	sub	r10,r9,-4
800085e0:	51 0a       	stdsp	sp[0x40],r10
800085e2:	fa c6 f9 44 	sub	r6,sp,-1724
800085e6:	72 09       	ld.w	r9,r9[0x0]
800085e8:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800085ec:	f5 49 fd 88 	st.w	r10[-632],r9
800085f0:	2f f8       	sub	r8,-1
800085f2:	fb 48 06 b4 	st.w	sp[1716],r8
800085f6:	c0 58       	rjmp	80008600 <_vfprintf_r+0xfd4>
800085f8:	f2 c8 ff fc 	sub	r8,r9,-4
800085fc:	51 08       	stdsp	sp[0x40],r8
800085fe:	72 09       	ld.w	r9,r9[0x0]
80008600:	33 08       	mov	r8,48
80008602:	fb 68 06 b8 	st.b	sp[1720],r8
80008606:	37 88       	mov	r8,120
80008608:	30 0e       	mov	lr,0
8000860a:	fb 68 06 b9 	st.b	sp[1721],r8
8000860e:	fe cc be 3a 	sub	r12,pc,-16838
80008612:	50 19       	stdsp	sp[0x4],r9
80008614:	a1 b5       	sbr	r5,0x1
80008616:	50 0e       	stdsp	sp[0x0],lr
80008618:	50 dc       	stdsp	sp[0x34],r12
8000861a:	30 28       	mov	r8,2
8000861c:	37 80       	mov	r0,120
8000861e:	e0 8f 02 a3 	bral	80008b64 <_vfprintf_r+0x1538>
80008622:	50 a7       	stdsp	sp[0x28],r7
80008624:	50 80       	stdsp	sp[0x20],r0
80008626:	10 90       	mov	r0,r8
80008628:	30 08       	mov	r8,0
8000862a:	fb 68 06 bb 	st.b	sp[1723],r8
8000862e:	0c 97       	mov	r7,r6
80008630:	04 94       	mov	r4,r2
80008632:	06 96       	mov	r6,r3
80008634:	02 92       	mov	r2,r1
80008636:	40 93       	lddsp	r3,sp[0x24]
80008638:	40 41       	lddsp	r1,sp[0x10]
8000863a:	0e 99       	mov	r9,r7
8000863c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008640:	40 3b       	lddsp	r11,sp[0xc]
80008642:	58 0b       	cp.w	r11,0
80008644:	c1 d0       	breq	8000867e <_vfprintf_r+0x1052>
80008646:	10 36       	cp.w	r6,r8
80008648:	c0 64       	brge	80008654 <_vfprintf_r+0x1028>
8000864a:	fa ca f9 44 	sub	r10,sp,-1724
8000864e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008652:	c1 d8       	rjmp	8000868c <_vfprintf_r+0x1060>
80008654:	fa c8 f9 50 	sub	r8,sp,-1712
80008658:	1a d8       	st.w	--sp,r8
8000865a:	fa c8 fa b8 	sub	r8,sp,-1352
8000865e:	1a d8       	st.w	--sp,r8
80008660:	fa c8 fb b4 	sub	r8,sp,-1100
80008664:	0c 9b       	mov	r11,r6
80008666:	1a d8       	st.w	--sp,r8
80008668:	04 9a       	mov	r10,r2
8000866a:	fa c8 f9 40 	sub	r8,sp,-1728
8000866e:	fa c9 ff b4 	sub	r9,sp,-76
80008672:	08 9c       	mov	r12,r4
80008674:	fe b0 f6 44 	rcall	800072fc <get_arg>
80008678:	2f dd       	sub	sp,-12
8000867a:	78 06       	ld.w	r6,r12[0x0]
8000867c:	c2 08       	rjmp	800086bc <_vfprintf_r+0x1090>
8000867e:	2f f7       	sub	r7,-1
80008680:	10 39       	cp.w	r9,r8
80008682:	c0 84       	brge	80008692 <_vfprintf_r+0x1066>
80008684:	fa c9 f9 44 	sub	r9,sp,-1724
80008688:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000868c:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008690:	c1 68       	rjmp	800086bc <_vfprintf_r+0x1090>
80008692:	41 09       	lddsp	r9,sp[0x40]
80008694:	59 f8       	cp.w	r8,31
80008696:	e0 89 00 10 	brgt	800086b6 <_vfprintf_r+0x108a>
8000869a:	f2 ca ff fc 	sub	r10,r9,-4
8000869e:	51 0a       	stdsp	sp[0x40],r10
800086a0:	72 06       	ld.w	r6,r9[0x0]
800086a2:	fa ce f9 44 	sub	lr,sp,-1724
800086a6:	fc 08 00 39 	add	r9,lr,r8<<0x3
800086aa:	f3 46 fd 88 	st.w	r9[-632],r6
800086ae:	2f f8       	sub	r8,-1
800086b0:	fb 48 06 b4 	st.w	sp[1716],r8
800086b4:	c0 48       	rjmp	800086bc <_vfprintf_r+0x1090>
800086b6:	72 06       	ld.w	r6,r9[0x0]
800086b8:	2f c9       	sub	r9,-4
800086ba:	51 09       	stdsp	sp[0x40],r9
800086bc:	40 2c       	lddsp	r12,sp[0x8]
800086be:	58 0c       	cp.w	r12,0
800086c0:	c1 05       	brlt	800086e0 <_vfprintf_r+0x10b4>
800086c2:	18 9a       	mov	r10,r12
800086c4:	30 0b       	mov	r11,0
800086c6:	0c 9c       	mov	r12,r6
800086c8:	e0 a0 13 12 	rcall	8000acec <memchr>
800086cc:	e0 80 02 df 	breq	80008c8a <_vfprintf_r+0x165e>
800086d0:	f8 06 01 02 	sub	r2,r12,r6
800086d4:	40 2b       	lddsp	r11,sp[0x8]
800086d6:	16 32       	cp.w	r2,r11
800086d8:	e0 89 02 d9 	brgt	80008c8a <_vfprintf_r+0x165e>
800086dc:	e0 8f 02 d4 	bral	80008c84 <_vfprintf_r+0x1658>
800086e0:	30 0a       	mov	r10,0
800086e2:	0c 9c       	mov	r12,r6
800086e4:	50 2a       	stdsp	sp[0x8],r10
800086e6:	e0 a0 16 73 	rcall	8000b3cc <strlen>
800086ea:	18 92       	mov	r2,r12
800086ec:	e0 8f 02 d2 	bral	80008c90 <_vfprintf_r+0x1664>
800086f0:	50 a7       	stdsp	sp[0x28],r7
800086f2:	50 80       	stdsp	sp[0x20],r0
800086f4:	0c 97       	mov	r7,r6
800086f6:	04 94       	mov	r4,r2
800086f8:	06 96       	mov	r6,r3
800086fa:	02 92       	mov	r2,r1
800086fc:	40 93       	lddsp	r3,sp[0x24]
800086fe:	10 90       	mov	r0,r8
80008700:	40 41       	lddsp	r1,sp[0x10]
80008702:	a5 a5       	sbr	r5,0x4
80008704:	c0 a8       	rjmp	80008718 <_vfprintf_r+0x10ec>
80008706:	50 a7       	stdsp	sp[0x28],r7
80008708:	50 80       	stdsp	sp[0x20],r0
8000870a:	0c 97       	mov	r7,r6
8000870c:	04 94       	mov	r4,r2
8000870e:	06 96       	mov	r6,r3
80008710:	02 92       	mov	r2,r1
80008712:	40 93       	lddsp	r3,sp[0x24]
80008714:	10 90       	mov	r0,r8
80008716:	40 41       	lddsp	r1,sp[0x10]
80008718:	ed b5 00 05 	bld	r5,0x5
8000871c:	c5 61       	brne	800087c8 <_vfprintf_r+0x119c>
8000871e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008722:	40 39       	lddsp	r9,sp[0xc]
80008724:	58 09       	cp.w	r9,0
80008726:	c2 10       	breq	80008768 <_vfprintf_r+0x113c>
80008728:	10 36       	cp.w	r6,r8
8000872a:	c0 74       	brge	80008738 <_vfprintf_r+0x110c>
8000872c:	fa c8 f9 44 	sub	r8,sp,-1724
80008730:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008734:	c2 38       	rjmp	8000877a <_vfprintf_r+0x114e>
80008736:	d7 03       	nop
80008738:	fa c8 f9 50 	sub	r8,sp,-1712
8000873c:	1a d8       	st.w	--sp,r8
8000873e:	fa c8 fa b8 	sub	r8,sp,-1352
80008742:	1a d8       	st.w	--sp,r8
80008744:	fa c8 fb b4 	sub	r8,sp,-1100
80008748:	1a d8       	st.w	--sp,r8
8000874a:	fa c8 f9 40 	sub	r8,sp,-1728
8000874e:	fa c9 ff b4 	sub	r9,sp,-76
80008752:	04 9a       	mov	r10,r2
80008754:	0c 9b       	mov	r11,r6
80008756:	08 9c       	mov	r12,r4
80008758:	fe b0 f5 d2 	rcall	800072fc <get_arg>
8000875c:	2f dd       	sub	sp,-12
8000875e:	f8 e8 00 00 	ld.d	r8,r12[0]
80008762:	fa e9 00 00 	st.d	sp[0],r8
80008766:	c2 e8       	rjmp	800087c2 <_vfprintf_r+0x1196>
80008768:	ee ca ff ff 	sub	r10,r7,-1
8000876c:	10 37       	cp.w	r7,r8
8000876e:	c0 b4       	brge	80008784 <_vfprintf_r+0x1158>
80008770:	fa c8 f9 44 	sub	r8,sp,-1724
80008774:	14 97       	mov	r7,r10
80008776:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000877a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000877e:	fa eb 00 00 	st.d	sp[0],r10
80008782:	c2 08       	rjmp	800087c2 <_vfprintf_r+0x1196>
80008784:	41 09       	lddsp	r9,sp[0x40]
80008786:	59 f8       	cp.w	r8,31
80008788:	e0 89 00 16 	brgt	800087b4 <_vfprintf_r+0x1188>
8000878c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008790:	f2 cb ff f8 	sub	r11,r9,-8
80008794:	fa e7 00 00 	st.d	sp[0],r6
80008798:	51 0b       	stdsp	sp[0x40],r11
8000879a:	fa c6 f9 44 	sub	r6,sp,-1724
8000879e:	ec 08 00 39 	add	r9,r6,r8<<0x3
800087a2:	fa e6 00 00 	ld.d	r6,sp[0]
800087a6:	f2 e7 fd 88 	st.d	r9[-632],r6
800087aa:	2f f8       	sub	r8,-1
800087ac:	14 97       	mov	r7,r10
800087ae:	fb 48 06 b4 	st.w	sp[1716],r8
800087b2:	c0 88       	rjmp	800087c2 <_vfprintf_r+0x1196>
800087b4:	f2 e6 00 00 	ld.d	r6,r9[0]
800087b8:	2f 89       	sub	r9,-8
800087ba:	fa e7 00 00 	st.d	sp[0],r6
800087be:	51 09       	stdsp	sp[0x40],r9
800087c0:	14 97       	mov	r7,r10
800087c2:	30 18       	mov	r8,1
800087c4:	e0 8f 01 d0 	bral	80008b64 <_vfprintf_r+0x1538>
800087c8:	ed b5 00 04 	bld	r5,0x4
800087cc:	c1 61       	brne	800087f8 <_vfprintf_r+0x11cc>
800087ce:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087d2:	40 3e       	lddsp	lr,sp[0xc]
800087d4:	58 0e       	cp.w	lr,0
800087d6:	c0 80       	breq	800087e6 <_vfprintf_r+0x11ba>
800087d8:	10 36       	cp.w	r6,r8
800087da:	c6 74       	brge	800088a8 <_vfprintf_r+0x127c>
800087dc:	fa cc f9 44 	sub	r12,sp,-1724
800087e0:	f8 06 00 36 	add	r6,r12,r6<<0x3
800087e4:	c8 08       	rjmp	800088e4 <_vfprintf_r+0x12b8>
800087e6:	ee ca ff ff 	sub	r10,r7,-1
800087ea:	10 37       	cp.w	r7,r8
800087ec:	c7 f4       	brge	800088ea <_vfprintf_r+0x12be>
800087ee:	fa cb f9 44 	sub	r11,sp,-1724
800087f2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087f6:	c7 68       	rjmp	800088e2 <_vfprintf_r+0x12b6>
800087f8:	ed b5 00 06 	bld	r5,0x6
800087fc:	c4 a1       	brne	80008890 <_vfprintf_r+0x1264>
800087fe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008802:	40 3c       	lddsp	r12,sp[0xc]
80008804:	58 0c       	cp.w	r12,0
80008806:	c1 d0       	breq	80008840 <_vfprintf_r+0x1214>
80008808:	10 36       	cp.w	r6,r8
8000880a:	c0 64       	brge	80008816 <_vfprintf_r+0x11ea>
8000880c:	fa cb f9 44 	sub	r11,sp,-1724
80008810:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008814:	c1 f8       	rjmp	80008852 <_vfprintf_r+0x1226>
80008816:	fa c8 f9 50 	sub	r8,sp,-1712
8000881a:	1a d8       	st.w	--sp,r8
8000881c:	fa c8 fa b8 	sub	r8,sp,-1352
80008820:	1a d8       	st.w	--sp,r8
80008822:	fa c8 fb b4 	sub	r8,sp,-1100
80008826:	1a d8       	st.w	--sp,r8
80008828:	fa c8 f9 40 	sub	r8,sp,-1728
8000882c:	fa c9 ff b4 	sub	r9,sp,-76
80008830:	04 9a       	mov	r10,r2
80008832:	0c 9b       	mov	r11,r6
80008834:	08 9c       	mov	r12,r4
80008836:	fe b0 f5 63 	rcall	800072fc <get_arg>
8000883a:	2f dd       	sub	sp,-12
8000883c:	98 18       	ld.sh	r8,r12[0x2]
8000883e:	c2 68       	rjmp	8000888a <_vfprintf_r+0x125e>
80008840:	ee ca ff ff 	sub	r10,r7,-1
80008844:	10 37       	cp.w	r7,r8
80008846:	c0 94       	brge	80008858 <_vfprintf_r+0x122c>
80008848:	fa c9 f9 44 	sub	r9,sp,-1724
8000884c:	14 97       	mov	r7,r10
8000884e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008852:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008856:	c1 a8       	rjmp	8000888a <_vfprintf_r+0x125e>
80008858:	41 09       	lddsp	r9,sp[0x40]
8000885a:	59 f8       	cp.w	r8,31
8000885c:	e0 89 00 13 	brgt	80008882 <_vfprintf_r+0x1256>
80008860:	f2 cb ff fc 	sub	r11,r9,-4
80008864:	51 0b       	stdsp	sp[0x40],r11
80008866:	72 09       	ld.w	r9,r9[0x0]
80008868:	fa c6 f9 44 	sub	r6,sp,-1724
8000886c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008870:	2f f8       	sub	r8,-1
80008872:	f7 49 fd 88 	st.w	r11[-632],r9
80008876:	fb 48 06 b4 	st.w	sp[1716],r8
8000887a:	14 97       	mov	r7,r10
8000887c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008880:	c0 58       	rjmp	8000888a <_vfprintf_r+0x125e>
80008882:	92 18       	ld.sh	r8,r9[0x2]
80008884:	14 97       	mov	r7,r10
80008886:	2f c9       	sub	r9,-4
80008888:	51 09       	stdsp	sp[0x40],r9
8000888a:	5c 78       	castu.h	r8
8000888c:	50 18       	stdsp	sp[0x4],r8
8000888e:	c4 68       	rjmp	8000891a <_vfprintf_r+0x12ee>
80008890:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008894:	40 3c       	lddsp	r12,sp[0xc]
80008896:	58 0c       	cp.w	r12,0
80008898:	c1 d0       	breq	800088d2 <_vfprintf_r+0x12a6>
8000889a:	10 36       	cp.w	r6,r8
8000889c:	c0 64       	brge	800088a8 <_vfprintf_r+0x127c>
8000889e:	fa cb f9 44 	sub	r11,sp,-1724
800088a2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800088a6:	c1 f8       	rjmp	800088e4 <_vfprintf_r+0x12b8>
800088a8:	fa c8 f9 50 	sub	r8,sp,-1712
800088ac:	1a d8       	st.w	--sp,r8
800088ae:	fa c8 fa b8 	sub	r8,sp,-1352
800088b2:	0c 9b       	mov	r11,r6
800088b4:	1a d8       	st.w	--sp,r8
800088b6:	fa c8 fb b4 	sub	r8,sp,-1100
800088ba:	04 9a       	mov	r10,r2
800088bc:	1a d8       	st.w	--sp,r8
800088be:	08 9c       	mov	r12,r4
800088c0:	fa c8 f9 40 	sub	r8,sp,-1728
800088c4:	fa c9 ff b4 	sub	r9,sp,-76
800088c8:	fe b0 f5 1a 	rcall	800072fc <get_arg>
800088cc:	2f dd       	sub	sp,-12
800088ce:	78 0b       	ld.w	r11,r12[0x0]
800088d0:	c2 48       	rjmp	80008918 <_vfprintf_r+0x12ec>
800088d2:	ee ca ff ff 	sub	r10,r7,-1
800088d6:	10 37       	cp.w	r7,r8
800088d8:	c0 94       	brge	800088ea <_vfprintf_r+0x12be>
800088da:	fa c9 f9 44 	sub	r9,sp,-1724
800088de:	f2 06 00 36 	add	r6,r9,r6<<0x3
800088e2:	14 97       	mov	r7,r10
800088e4:	ec fb fd 88 	ld.w	r11,r6[-632]
800088e8:	c1 88       	rjmp	80008918 <_vfprintf_r+0x12ec>
800088ea:	41 09       	lddsp	r9,sp[0x40]
800088ec:	59 f8       	cp.w	r8,31
800088ee:	e0 89 00 11 	brgt	80008910 <_vfprintf_r+0x12e4>
800088f2:	f2 cb ff fc 	sub	r11,r9,-4
800088f6:	51 0b       	stdsp	sp[0x40],r11
800088f8:	fa c6 f9 44 	sub	r6,sp,-1724
800088fc:	72 0b       	ld.w	r11,r9[0x0]
800088fe:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008902:	f3 4b fd 88 	st.w	r9[-632],r11
80008906:	2f f8       	sub	r8,-1
80008908:	14 97       	mov	r7,r10
8000890a:	fb 48 06 b4 	st.w	sp[1716],r8
8000890e:	c0 58       	rjmp	80008918 <_vfprintf_r+0x12ec>
80008910:	72 0b       	ld.w	r11,r9[0x0]
80008912:	14 97       	mov	r7,r10
80008914:	2f c9       	sub	r9,-4
80008916:	51 09       	stdsp	sp[0x40],r9
80008918:	50 1b       	stdsp	sp[0x4],r11
8000891a:	30 0e       	mov	lr,0
8000891c:	30 18       	mov	r8,1
8000891e:	50 0e       	stdsp	sp[0x0],lr
80008920:	c2 29       	rjmp	80008b64 <_vfprintf_r+0x1538>
80008922:	50 a7       	stdsp	sp[0x28],r7
80008924:	50 80       	stdsp	sp[0x20],r0
80008926:	0c 97       	mov	r7,r6
80008928:	04 94       	mov	r4,r2
8000892a:	06 96       	mov	r6,r3
8000892c:	02 92       	mov	r2,r1
8000892e:	fe cc c1 5a 	sub	r12,pc,-16038
80008932:	40 93       	lddsp	r3,sp[0x24]
80008934:	10 90       	mov	r0,r8
80008936:	40 41       	lddsp	r1,sp[0x10]
80008938:	50 dc       	stdsp	sp[0x34],r12
8000893a:	ed b5 00 05 	bld	r5,0x5
8000893e:	c5 51       	brne	800089e8 <_vfprintf_r+0x13bc>
80008940:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008944:	40 3b       	lddsp	r11,sp[0xc]
80008946:	58 0b       	cp.w	r11,0
80008948:	c2 20       	breq	8000898c <_vfprintf_r+0x1360>
8000894a:	10 36       	cp.w	r6,r8
8000894c:	c0 a4       	brge	80008960 <_vfprintf_r+0x1334>
8000894e:	fa ca f9 44 	sub	r10,sp,-1724
80008952:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008956:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000895a:	fa e9 00 00 	st.d	sp[0],r8
8000895e:	cf 28       	rjmp	80008b42 <_vfprintf_r+0x1516>
80008960:	fa c8 f9 50 	sub	r8,sp,-1712
80008964:	1a d8       	st.w	--sp,r8
80008966:	fa c8 fa b8 	sub	r8,sp,-1352
8000896a:	04 9a       	mov	r10,r2
8000896c:	1a d8       	st.w	--sp,r8
8000896e:	0c 9b       	mov	r11,r6
80008970:	fa c8 fb b4 	sub	r8,sp,-1100
80008974:	08 9c       	mov	r12,r4
80008976:	1a d8       	st.w	--sp,r8
80008978:	fa c8 f9 40 	sub	r8,sp,-1728
8000897c:	fa c9 ff b4 	sub	r9,sp,-76
80008980:	fe b0 f4 be 	rcall	800072fc <get_arg>
80008984:	2f dd       	sub	sp,-12
80008986:	f8 ea 00 00 	ld.d	r10,r12[0]
8000898a:	c0 c8       	rjmp	800089a2 <_vfprintf_r+0x1376>
8000898c:	ee ca ff ff 	sub	r10,r7,-1
80008990:	10 37       	cp.w	r7,r8
80008992:	c0 b4       	brge	800089a8 <_vfprintf_r+0x137c>
80008994:	fa c9 f9 44 	sub	r9,sp,-1724
80008998:	14 97       	mov	r7,r10
8000899a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000899e:	ec ea fd 88 	ld.d	r10,r6[-632]
800089a2:	fa eb 00 00 	st.d	sp[0],r10
800089a6:	cc e8       	rjmp	80008b42 <_vfprintf_r+0x1516>
800089a8:	41 09       	lddsp	r9,sp[0x40]
800089aa:	59 f8       	cp.w	r8,31
800089ac:	e0 89 00 16 	brgt	800089d8 <_vfprintf_r+0x13ac>
800089b0:	f2 e6 00 00 	ld.d	r6,r9[0]
800089b4:	f2 cb ff f8 	sub	r11,r9,-8
800089b8:	fa e7 00 00 	st.d	sp[0],r6
800089bc:	51 0b       	stdsp	sp[0x40],r11
800089be:	fa c6 f9 44 	sub	r6,sp,-1724
800089c2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800089c6:	fa e6 00 00 	ld.d	r6,sp[0]
800089ca:	f2 e7 fd 88 	st.d	r9[-632],r6
800089ce:	2f f8       	sub	r8,-1
800089d0:	14 97       	mov	r7,r10
800089d2:	fb 48 06 b4 	st.w	sp[1716],r8
800089d6:	cb 68       	rjmp	80008b42 <_vfprintf_r+0x1516>
800089d8:	f2 e6 00 00 	ld.d	r6,r9[0]
800089dc:	2f 89       	sub	r9,-8
800089de:	fa e7 00 00 	st.d	sp[0],r6
800089e2:	51 09       	stdsp	sp[0x40],r9
800089e4:	14 97       	mov	r7,r10
800089e6:	ca e8       	rjmp	80008b42 <_vfprintf_r+0x1516>
800089e8:	ed b5 00 04 	bld	r5,0x4
800089ec:	c1 71       	brne	80008a1a <_vfprintf_r+0x13ee>
800089ee:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089f2:	40 3e       	lddsp	lr,sp[0xc]
800089f4:	58 0e       	cp.w	lr,0
800089f6:	c0 80       	breq	80008a06 <_vfprintf_r+0x13da>
800089f8:	10 36       	cp.w	r6,r8
800089fa:	c6 94       	brge	80008acc <_vfprintf_r+0x14a0>
800089fc:	fa cc f9 44 	sub	r12,sp,-1724
80008a00:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008a04:	c8 28       	rjmp	80008b08 <_vfprintf_r+0x14dc>
80008a06:	ee ca ff ff 	sub	r10,r7,-1
80008a0a:	10 37       	cp.w	r7,r8
80008a0c:	e0 84 00 81 	brge	80008b0e <_vfprintf_r+0x14e2>
80008a10:	fa cb f9 44 	sub	r11,sp,-1724
80008a14:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a18:	c7 78       	rjmp	80008b06 <_vfprintf_r+0x14da>
80008a1a:	ed b5 00 06 	bld	r5,0x6
80008a1e:	c4 b1       	brne	80008ab4 <_vfprintf_r+0x1488>
80008a20:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a24:	40 3c       	lddsp	r12,sp[0xc]
80008a26:	58 0c       	cp.w	r12,0
80008a28:	c1 d0       	breq	80008a62 <_vfprintf_r+0x1436>
80008a2a:	10 36       	cp.w	r6,r8
80008a2c:	c0 64       	brge	80008a38 <_vfprintf_r+0x140c>
80008a2e:	fa cb f9 44 	sub	r11,sp,-1724
80008a32:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a36:	c1 f8       	rjmp	80008a74 <_vfprintf_r+0x1448>
80008a38:	fa c8 f9 50 	sub	r8,sp,-1712
80008a3c:	1a d8       	st.w	--sp,r8
80008a3e:	fa c8 fa b8 	sub	r8,sp,-1352
80008a42:	1a d8       	st.w	--sp,r8
80008a44:	fa c8 fb b4 	sub	r8,sp,-1100
80008a48:	1a d8       	st.w	--sp,r8
80008a4a:	fa c8 f9 40 	sub	r8,sp,-1728
80008a4e:	fa c9 ff b4 	sub	r9,sp,-76
80008a52:	04 9a       	mov	r10,r2
80008a54:	0c 9b       	mov	r11,r6
80008a56:	08 9c       	mov	r12,r4
80008a58:	fe b0 f4 52 	rcall	800072fc <get_arg>
80008a5c:	2f dd       	sub	sp,-12
80008a5e:	98 18       	ld.sh	r8,r12[0x2]
80008a60:	c2 78       	rjmp	80008aae <_vfprintf_r+0x1482>
80008a62:	ee ca ff ff 	sub	r10,r7,-1
80008a66:	10 37       	cp.w	r7,r8
80008a68:	c0 a4       	brge	80008a7c <_vfprintf_r+0x1450>
80008a6a:	fa c9 f9 44 	sub	r9,sp,-1724
80008a6e:	14 97       	mov	r7,r10
80008a70:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008a74:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008a78:	c1 b8       	rjmp	80008aae <_vfprintf_r+0x1482>
80008a7a:	d7 03       	nop
80008a7c:	41 09       	lddsp	r9,sp[0x40]
80008a7e:	59 f8       	cp.w	r8,31
80008a80:	e0 89 00 13 	brgt	80008aa6 <_vfprintf_r+0x147a>
80008a84:	f2 cb ff fc 	sub	r11,r9,-4
80008a88:	51 0b       	stdsp	sp[0x40],r11
80008a8a:	72 09       	ld.w	r9,r9[0x0]
80008a8c:	fa c6 f9 44 	sub	r6,sp,-1724
80008a90:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008a94:	2f f8       	sub	r8,-1
80008a96:	f7 49 fd 88 	st.w	r11[-632],r9
80008a9a:	fb 48 06 b4 	st.w	sp[1716],r8
80008a9e:	14 97       	mov	r7,r10
80008aa0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008aa4:	c0 58       	rjmp	80008aae <_vfprintf_r+0x1482>
80008aa6:	92 18       	ld.sh	r8,r9[0x2]
80008aa8:	14 97       	mov	r7,r10
80008aaa:	2f c9       	sub	r9,-4
80008aac:	51 09       	stdsp	sp[0x40],r9
80008aae:	5c 78       	castu.h	r8
80008ab0:	50 18       	stdsp	sp[0x4],r8
80008ab2:	c4 68       	rjmp	80008b3e <_vfprintf_r+0x1512>
80008ab4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ab8:	40 3c       	lddsp	r12,sp[0xc]
80008aba:	58 0c       	cp.w	r12,0
80008abc:	c1 d0       	breq	80008af6 <_vfprintf_r+0x14ca>
80008abe:	10 36       	cp.w	r6,r8
80008ac0:	c0 64       	brge	80008acc <_vfprintf_r+0x14a0>
80008ac2:	fa cb f9 44 	sub	r11,sp,-1724
80008ac6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008aca:	c1 f8       	rjmp	80008b08 <_vfprintf_r+0x14dc>
80008acc:	fa c8 f9 50 	sub	r8,sp,-1712
80008ad0:	1a d8       	st.w	--sp,r8
80008ad2:	fa c8 fa b8 	sub	r8,sp,-1352
80008ad6:	0c 9b       	mov	r11,r6
80008ad8:	1a d8       	st.w	--sp,r8
80008ada:	fa c8 fb b4 	sub	r8,sp,-1100
80008ade:	04 9a       	mov	r10,r2
80008ae0:	1a d8       	st.w	--sp,r8
80008ae2:	08 9c       	mov	r12,r4
80008ae4:	fa c8 f9 40 	sub	r8,sp,-1728
80008ae8:	fa c9 ff b4 	sub	r9,sp,-76
80008aec:	fe b0 f4 08 	rcall	800072fc <get_arg>
80008af0:	2f dd       	sub	sp,-12
80008af2:	78 0b       	ld.w	r11,r12[0x0]
80008af4:	c2 48       	rjmp	80008b3c <_vfprintf_r+0x1510>
80008af6:	ee ca ff ff 	sub	r10,r7,-1
80008afa:	10 37       	cp.w	r7,r8
80008afc:	c0 94       	brge	80008b0e <_vfprintf_r+0x14e2>
80008afe:	fa c9 f9 44 	sub	r9,sp,-1724
80008b02:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008b06:	14 97       	mov	r7,r10
80008b08:	ec fb fd 88 	ld.w	r11,r6[-632]
80008b0c:	c1 88       	rjmp	80008b3c <_vfprintf_r+0x1510>
80008b0e:	41 09       	lddsp	r9,sp[0x40]
80008b10:	59 f8       	cp.w	r8,31
80008b12:	e0 89 00 11 	brgt	80008b34 <_vfprintf_r+0x1508>
80008b16:	f2 cb ff fc 	sub	r11,r9,-4
80008b1a:	51 0b       	stdsp	sp[0x40],r11
80008b1c:	fa c6 f9 44 	sub	r6,sp,-1724
80008b20:	72 0b       	ld.w	r11,r9[0x0]
80008b22:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b26:	f3 4b fd 88 	st.w	r9[-632],r11
80008b2a:	2f f8       	sub	r8,-1
80008b2c:	14 97       	mov	r7,r10
80008b2e:	fb 48 06 b4 	st.w	sp[1716],r8
80008b32:	c0 58       	rjmp	80008b3c <_vfprintf_r+0x1510>
80008b34:	72 0b       	ld.w	r11,r9[0x0]
80008b36:	14 97       	mov	r7,r10
80008b38:	2f c9       	sub	r9,-4
80008b3a:	51 09       	stdsp	sp[0x40],r9
80008b3c:	50 1b       	stdsp	sp[0x4],r11
80008b3e:	30 0e       	mov	lr,0
80008b40:	50 0e       	stdsp	sp[0x0],lr
80008b42:	40 08       	lddsp	r8,sp[0x0]
80008b44:	40 1c       	lddsp	r12,sp[0x4]
80008b46:	18 48       	or	r8,r12
80008b48:	5f 19       	srne	r9
80008b4a:	0a 98       	mov	r8,r5
80008b4c:	eb e9 00 09 	and	r9,r5,r9
80008b50:	a1 b8       	sbr	r8,0x1
80008b52:	58 09       	cp.w	r9,0
80008b54:	c0 70       	breq	80008b62 <_vfprintf_r+0x1536>
80008b56:	10 95       	mov	r5,r8
80008b58:	fb 60 06 b9 	st.b	sp[1721],r0
80008b5c:	33 08       	mov	r8,48
80008b5e:	fb 68 06 b8 	st.b	sp[1720],r8
80008b62:	30 28       	mov	r8,2
80008b64:	30 09       	mov	r9,0
80008b66:	fb 69 06 bb 	st.b	sp[1723],r9
80008b6a:	0a 99       	mov	r9,r5
80008b6c:	a7 d9       	cbr	r9,0x7
80008b6e:	40 2b       	lddsp	r11,sp[0x8]
80008b70:	40 16       	lddsp	r6,sp[0x4]
80008b72:	58 0b       	cp.w	r11,0
80008b74:	5f 1a       	srne	r10
80008b76:	f2 05 17 40 	movge	r5,r9
80008b7a:	fa c2 f9 78 	sub	r2,sp,-1672
80008b7e:	40 09       	lddsp	r9,sp[0x0]
80008b80:	0c 49       	or	r9,r6
80008b82:	5f 19       	srne	r9
80008b84:	f5 e9 10 09 	or	r9,r10,r9
80008b88:	c5 c0       	breq	80008c40 <_vfprintf_r+0x1614>
80008b8a:	30 19       	mov	r9,1
80008b8c:	f2 08 18 00 	cp.b	r8,r9
80008b90:	c0 60       	breq	80008b9c <_vfprintf_r+0x1570>
80008b92:	30 29       	mov	r9,2
80008b94:	f2 08 18 00 	cp.b	r8,r9
80008b98:	c0 41       	brne	80008ba0 <_vfprintf_r+0x1574>
80008b9a:	c3 c8       	rjmp	80008c12 <_vfprintf_r+0x15e6>
80008b9c:	04 96       	mov	r6,r2
80008b9e:	c3 08       	rjmp	80008bfe <_vfprintf_r+0x15d2>
80008ba0:	04 96       	mov	r6,r2
80008ba2:	fa e8 00 00 	ld.d	r8,sp[0]
80008ba6:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008baa:	2d 0a       	sub	r10,-48
80008bac:	0c fa       	st.b	--r6,r10
80008bae:	f0 0b 16 03 	lsr	r11,r8,0x3
80008bb2:	f2 0c 16 03 	lsr	r12,r9,0x3
80008bb6:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008bba:	18 99       	mov	r9,r12
80008bbc:	16 98       	mov	r8,r11
80008bbe:	58 08       	cp.w	r8,0
80008bc0:	5c 29       	cpc	r9
80008bc2:	cf 21       	brne	80008ba6 <_vfprintf_r+0x157a>
80008bc4:	fa e9 00 00 	st.d	sp[0],r8
80008bc8:	ed b5 00 00 	bld	r5,0x0
80008bcc:	c4 51       	brne	80008c56 <_vfprintf_r+0x162a>
80008bce:	33 09       	mov	r9,48
80008bd0:	f2 0a 18 00 	cp.b	r10,r9
80008bd4:	c4 10       	breq	80008c56 <_vfprintf_r+0x162a>
80008bd6:	0c f9       	st.b	--r6,r9
80008bd8:	c3 f8       	rjmp	80008c56 <_vfprintf_r+0x162a>
80008bda:	fa ea 00 00 	ld.d	r10,sp[0]
80008bde:	30 a8       	mov	r8,10
80008be0:	30 09       	mov	r9,0
80008be2:	e0 a0 19 c1 	rcall	8000bf64 <__avr32_umod64>
80008be6:	30 a8       	mov	r8,10
80008be8:	2d 0a       	sub	r10,-48
80008bea:	30 09       	mov	r9,0
80008bec:	ac 8a       	st.b	r6[0x0],r10
80008bee:	fa ea 00 00 	ld.d	r10,sp[0]
80008bf2:	fe b0 ed 51 	rcall	80006694 <__avr32_udiv64>
80008bf6:	16 99       	mov	r9,r11
80008bf8:	14 98       	mov	r8,r10
80008bfa:	fa e9 00 00 	st.d	sp[0],r8
80008bfe:	20 16       	sub	r6,1
80008c00:	fa ea 00 00 	ld.d	r10,sp[0]
80008c04:	58 9a       	cp.w	r10,9
80008c06:	5c 2b       	cpc	r11
80008c08:	fe 9b ff e9 	brhi	80008bda <_vfprintf_r+0x15ae>
80008c0c:	1b f8       	ld.ub	r8,sp[0x7]
80008c0e:	2d 08       	sub	r8,-48
80008c10:	c2 08       	rjmp	80008c50 <_vfprintf_r+0x1624>
80008c12:	04 96       	mov	r6,r2
80008c14:	fa e8 00 00 	ld.d	r8,sp[0]
80008c18:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008c1c:	40 de       	lddsp	lr,sp[0x34]
80008c1e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008c22:	0c fa       	st.b	--r6,r10
80008c24:	f2 0b 16 04 	lsr	r11,r9,0x4
80008c28:	f0 0a 16 04 	lsr	r10,r8,0x4
80008c2c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008c30:	16 99       	mov	r9,r11
80008c32:	14 98       	mov	r8,r10
80008c34:	58 08       	cp.w	r8,0
80008c36:	5c 29       	cpc	r9
80008c38:	cf 01       	brne	80008c18 <_vfprintf_r+0x15ec>
80008c3a:	fa e9 00 00 	st.d	sp[0],r8
80008c3e:	c0 c8       	rjmp	80008c56 <_vfprintf_r+0x162a>
80008c40:	58 08       	cp.w	r8,0
80008c42:	c0 91       	brne	80008c54 <_vfprintf_r+0x1628>
80008c44:	ed b5 00 00 	bld	r5,0x0
80008c48:	c0 61       	brne	80008c54 <_vfprintf_r+0x1628>
80008c4a:	fa c6 f9 79 	sub	r6,sp,-1671
80008c4e:	33 08       	mov	r8,48
80008c50:	ac 88       	st.b	r6[0x0],r8
80008c52:	c0 28       	rjmp	80008c56 <_vfprintf_r+0x162a>
80008c54:	04 96       	mov	r6,r2
80008c56:	0c 12       	sub	r2,r6
80008c58:	c1 c8       	rjmp	80008c90 <_vfprintf_r+0x1664>
80008c5a:	50 a7       	stdsp	sp[0x28],r7
80008c5c:	50 80       	stdsp	sp[0x20],r0
80008c5e:	40 93       	lddsp	r3,sp[0x24]
80008c60:	0c 97       	mov	r7,r6
80008c62:	10 90       	mov	r0,r8
80008c64:	04 94       	mov	r4,r2
80008c66:	40 41       	lddsp	r1,sp[0x10]
80008c68:	58 08       	cp.w	r8,0
80008c6a:	e0 80 04 4f 	breq	80009508 <_vfprintf_r+0x1edc>
80008c6e:	fb 68 06 60 	st.b	sp[1632],r8
80008c72:	30 0c       	mov	r12,0
80008c74:	30 08       	mov	r8,0
80008c76:	30 12       	mov	r2,1
80008c78:	fb 68 06 bb 	st.b	sp[1723],r8
80008c7c:	50 2c       	stdsp	sp[0x8],r12
80008c7e:	fa c6 f9 a0 	sub	r6,sp,-1632
80008c82:	c0 78       	rjmp	80008c90 <_vfprintf_r+0x1664>
80008c84:	30 0b       	mov	r11,0
80008c86:	50 2b       	stdsp	sp[0x8],r11
80008c88:	c0 48       	rjmp	80008c90 <_vfprintf_r+0x1664>
80008c8a:	40 22       	lddsp	r2,sp[0x8]
80008c8c:	30 0a       	mov	r10,0
80008c8e:	50 2a       	stdsp	sp[0x8],r10
80008c90:	40 29       	lddsp	r9,sp[0x8]
80008c92:	e4 09 0c 49 	max	r9,r2,r9
80008c96:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008c9a:	50 39       	stdsp	sp[0xc],r9
80008c9c:	0a 9e       	mov	lr,r5
80008c9e:	30 09       	mov	r9,0
80008ca0:	e2 1e 00 02 	andl	lr,0x2,COH
80008ca4:	f2 08 18 00 	cp.b	r8,r9
80008ca8:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008cac:	f7 b8 01 ff 	subne	r8,-1
80008cb0:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008cb4:	0a 9b       	mov	r11,r5
80008cb6:	58 0e       	cp.w	lr,0
80008cb8:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008cbc:	f7 bc 01 fe 	subne	r12,-2
80008cc0:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008cc4:	e2 1b 00 84 	andl	r11,0x84,COH
80008cc8:	50 fe       	stdsp	sp[0x3c],lr
80008cca:	50 9b       	stdsp	sp[0x24],r11
80008ccc:	c4 71       	brne	80008d5a <_vfprintf_r+0x172e>
80008cce:	40 8a       	lddsp	r10,sp[0x20]
80008cd0:	40 39       	lddsp	r9,sp[0xc]
80008cd2:	12 1a       	sub	r10,r9
80008cd4:	50 4a       	stdsp	sp[0x10],r10
80008cd6:	58 0a       	cp.w	r10,0
80008cd8:	e0 89 00 20 	brgt	80008d18 <_vfprintf_r+0x16ec>
80008cdc:	c3 f8       	rjmp	80008d5a <_vfprintf_r+0x172e>
80008cde:	2f 09       	sub	r9,-16
80008ce0:	2f f8       	sub	r8,-1
80008ce2:	fe ce c4 f6 	sub	lr,pc,-15114
80008ce6:	31 0c       	mov	r12,16
80008ce8:	fb 49 06 90 	st.w	sp[1680],r9
80008cec:	87 0e       	st.w	r3[0x0],lr
80008cee:	87 1c       	st.w	r3[0x4],r12
80008cf0:	fb 48 06 8c 	st.w	sp[1676],r8
80008cf4:	58 78       	cp.w	r8,7
80008cf6:	e0 89 00 04 	brgt	80008cfe <_vfprintf_r+0x16d2>
80008cfa:	2f 83       	sub	r3,-8
80008cfc:	c0 b8       	rjmp	80008d12 <_vfprintf_r+0x16e6>
80008cfe:	fa ca f9 78 	sub	r10,sp,-1672
80008d02:	02 9b       	mov	r11,r1
80008d04:	08 9c       	mov	r12,r4
80008d06:	fe b0 f4 85 	rcall	80007610 <__sprint_r>
80008d0a:	e0 81 04 10 	brne	8000952a <_vfprintf_r+0x1efe>
80008d0e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d12:	40 4b       	lddsp	r11,sp[0x10]
80008d14:	21 0b       	sub	r11,16
80008d16:	50 4b       	stdsp	sp[0x10],r11
80008d18:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d1c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d20:	fe ca c5 34 	sub	r10,pc,-15052
80008d24:	40 4e       	lddsp	lr,sp[0x10]
80008d26:	59 0e       	cp.w	lr,16
80008d28:	fe 99 ff db 	brgt	80008cde <_vfprintf_r+0x16b2>
80008d2c:	1c 09       	add	r9,lr
80008d2e:	2f f8       	sub	r8,-1
80008d30:	87 0a       	st.w	r3[0x0],r10
80008d32:	fb 49 06 90 	st.w	sp[1680],r9
80008d36:	87 1e       	st.w	r3[0x4],lr
80008d38:	fb 48 06 8c 	st.w	sp[1676],r8
80008d3c:	58 78       	cp.w	r8,7
80008d3e:	e0 89 00 04 	brgt	80008d46 <_vfprintf_r+0x171a>
80008d42:	2f 83       	sub	r3,-8
80008d44:	c0 b8       	rjmp	80008d5a <_vfprintf_r+0x172e>
80008d46:	fa ca f9 78 	sub	r10,sp,-1672
80008d4a:	02 9b       	mov	r11,r1
80008d4c:	08 9c       	mov	r12,r4
80008d4e:	fe b0 f4 61 	rcall	80007610 <__sprint_r>
80008d52:	e0 81 03 ec 	brne	8000952a <_vfprintf_r+0x1efe>
80008d56:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d5a:	30 09       	mov	r9,0
80008d5c:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008d60:	f2 08 18 00 	cp.b	r8,r9
80008d64:	c1 f0       	breq	80008da2 <_vfprintf_r+0x1776>
80008d66:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d6a:	fa c9 f9 45 	sub	r9,sp,-1723
80008d6e:	2f f8       	sub	r8,-1
80008d70:	87 09       	st.w	r3[0x0],r9
80008d72:	fb 48 06 90 	st.w	sp[1680],r8
80008d76:	30 19       	mov	r9,1
80008d78:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d7c:	87 19       	st.w	r3[0x4],r9
80008d7e:	2f f8       	sub	r8,-1
80008d80:	fb 48 06 8c 	st.w	sp[1676],r8
80008d84:	58 78       	cp.w	r8,7
80008d86:	e0 89 00 04 	brgt	80008d8e <_vfprintf_r+0x1762>
80008d8a:	2f 83       	sub	r3,-8
80008d8c:	c0 b8       	rjmp	80008da2 <_vfprintf_r+0x1776>
80008d8e:	fa ca f9 78 	sub	r10,sp,-1672
80008d92:	02 9b       	mov	r11,r1
80008d94:	08 9c       	mov	r12,r4
80008d96:	fe b0 f4 3d 	rcall	80007610 <__sprint_r>
80008d9a:	e0 81 03 c8 	brne	8000952a <_vfprintf_r+0x1efe>
80008d9e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008da2:	40 fc       	lddsp	r12,sp[0x3c]
80008da4:	58 0c       	cp.w	r12,0
80008da6:	c1 f0       	breq	80008de4 <_vfprintf_r+0x17b8>
80008da8:	fa f8 06 90 	ld.w	r8,sp[1680]
80008dac:	fa c9 f9 48 	sub	r9,sp,-1720
80008db0:	2f e8       	sub	r8,-2
80008db2:	87 09       	st.w	r3[0x0],r9
80008db4:	fb 48 06 90 	st.w	sp[1680],r8
80008db8:	30 29       	mov	r9,2
80008dba:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008dbe:	87 19       	st.w	r3[0x4],r9
80008dc0:	2f f8       	sub	r8,-1
80008dc2:	fb 48 06 8c 	st.w	sp[1676],r8
80008dc6:	58 78       	cp.w	r8,7
80008dc8:	e0 89 00 04 	brgt	80008dd0 <_vfprintf_r+0x17a4>
80008dcc:	2f 83       	sub	r3,-8
80008dce:	c0 b8       	rjmp	80008de4 <_vfprintf_r+0x17b8>
80008dd0:	fa ca f9 78 	sub	r10,sp,-1672
80008dd4:	02 9b       	mov	r11,r1
80008dd6:	08 9c       	mov	r12,r4
80008dd8:	fe b0 f4 1c 	rcall	80007610 <__sprint_r>
80008ddc:	e0 81 03 a7 	brne	8000952a <_vfprintf_r+0x1efe>
80008de0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008de4:	40 9b       	lddsp	r11,sp[0x24]
80008de6:	e0 4b 00 80 	cp.w	r11,128
80008dea:	c4 71       	brne	80008e78 <_vfprintf_r+0x184c>
80008dec:	40 8a       	lddsp	r10,sp[0x20]
80008dee:	40 39       	lddsp	r9,sp[0xc]
80008df0:	12 1a       	sub	r10,r9
80008df2:	50 4a       	stdsp	sp[0x10],r10
80008df4:	58 0a       	cp.w	r10,0
80008df6:	e0 89 00 20 	brgt	80008e36 <_vfprintf_r+0x180a>
80008dfa:	c3 f8       	rjmp	80008e78 <_vfprintf_r+0x184c>
80008dfc:	2f 09       	sub	r9,-16
80008dfe:	2f f8       	sub	r8,-1
80008e00:	fe ce c6 04 	sub	lr,pc,-14844
80008e04:	31 0c       	mov	r12,16
80008e06:	fb 49 06 90 	st.w	sp[1680],r9
80008e0a:	87 0e       	st.w	r3[0x0],lr
80008e0c:	87 1c       	st.w	r3[0x4],r12
80008e0e:	fb 48 06 8c 	st.w	sp[1676],r8
80008e12:	58 78       	cp.w	r8,7
80008e14:	e0 89 00 04 	brgt	80008e1c <_vfprintf_r+0x17f0>
80008e18:	2f 83       	sub	r3,-8
80008e1a:	c0 b8       	rjmp	80008e30 <_vfprintf_r+0x1804>
80008e1c:	fa ca f9 78 	sub	r10,sp,-1672
80008e20:	02 9b       	mov	r11,r1
80008e22:	08 9c       	mov	r12,r4
80008e24:	fe b0 f3 f6 	rcall	80007610 <__sprint_r>
80008e28:	e0 81 03 81 	brne	8000952a <_vfprintf_r+0x1efe>
80008e2c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e30:	40 4b       	lddsp	r11,sp[0x10]
80008e32:	21 0b       	sub	r11,16
80008e34:	50 4b       	stdsp	sp[0x10],r11
80008e36:	fa f9 06 90 	ld.w	r9,sp[1680]
80008e3a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e3e:	fe ca c6 42 	sub	r10,pc,-14782
80008e42:	40 4e       	lddsp	lr,sp[0x10]
80008e44:	59 0e       	cp.w	lr,16
80008e46:	fe 99 ff db 	brgt	80008dfc <_vfprintf_r+0x17d0>
80008e4a:	1c 09       	add	r9,lr
80008e4c:	2f f8       	sub	r8,-1
80008e4e:	87 0a       	st.w	r3[0x0],r10
80008e50:	fb 49 06 90 	st.w	sp[1680],r9
80008e54:	87 1e       	st.w	r3[0x4],lr
80008e56:	fb 48 06 8c 	st.w	sp[1676],r8
80008e5a:	58 78       	cp.w	r8,7
80008e5c:	e0 89 00 04 	brgt	80008e64 <_vfprintf_r+0x1838>
80008e60:	2f 83       	sub	r3,-8
80008e62:	c0 b8       	rjmp	80008e78 <_vfprintf_r+0x184c>
80008e64:	fa ca f9 78 	sub	r10,sp,-1672
80008e68:	02 9b       	mov	r11,r1
80008e6a:	08 9c       	mov	r12,r4
80008e6c:	fe b0 f3 d2 	rcall	80007610 <__sprint_r>
80008e70:	e0 81 03 5d 	brne	8000952a <_vfprintf_r+0x1efe>
80008e74:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e78:	40 2c       	lddsp	r12,sp[0x8]
80008e7a:	04 1c       	sub	r12,r2
80008e7c:	50 2c       	stdsp	sp[0x8],r12
80008e7e:	58 0c       	cp.w	r12,0
80008e80:	e0 89 00 20 	brgt	80008ec0 <_vfprintf_r+0x1894>
80008e84:	c3 f8       	rjmp	80008f02 <_vfprintf_r+0x18d6>
80008e86:	2f 09       	sub	r9,-16
80008e88:	2f f8       	sub	r8,-1
80008e8a:	fe cb c6 8e 	sub	r11,pc,-14706
80008e8e:	31 0a       	mov	r10,16
80008e90:	fb 49 06 90 	st.w	sp[1680],r9
80008e94:	87 0b       	st.w	r3[0x0],r11
80008e96:	87 1a       	st.w	r3[0x4],r10
80008e98:	fb 48 06 8c 	st.w	sp[1676],r8
80008e9c:	58 78       	cp.w	r8,7
80008e9e:	e0 89 00 04 	brgt	80008ea6 <_vfprintf_r+0x187a>
80008ea2:	2f 83       	sub	r3,-8
80008ea4:	c0 b8       	rjmp	80008eba <_vfprintf_r+0x188e>
80008ea6:	fa ca f9 78 	sub	r10,sp,-1672
80008eaa:	02 9b       	mov	r11,r1
80008eac:	08 9c       	mov	r12,r4
80008eae:	fe b0 f3 b1 	rcall	80007610 <__sprint_r>
80008eb2:	e0 81 03 3c 	brne	8000952a <_vfprintf_r+0x1efe>
80008eb6:	fa c3 f9 e0 	sub	r3,sp,-1568
80008eba:	40 29       	lddsp	r9,sp[0x8]
80008ebc:	21 09       	sub	r9,16
80008ebe:	50 29       	stdsp	sp[0x8],r9
80008ec0:	fa f9 06 90 	ld.w	r9,sp[1680]
80008ec4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ec8:	fe ca c6 cc 	sub	r10,pc,-14644
80008ecc:	40 2e       	lddsp	lr,sp[0x8]
80008ece:	59 0e       	cp.w	lr,16
80008ed0:	fe 99 ff db 	brgt	80008e86 <_vfprintf_r+0x185a>
80008ed4:	1c 09       	add	r9,lr
80008ed6:	2f f8       	sub	r8,-1
80008ed8:	87 0a       	st.w	r3[0x0],r10
80008eda:	fb 49 06 90 	st.w	sp[1680],r9
80008ede:	87 1e       	st.w	r3[0x4],lr
80008ee0:	fb 48 06 8c 	st.w	sp[1676],r8
80008ee4:	58 78       	cp.w	r8,7
80008ee6:	e0 89 00 04 	brgt	80008eee <_vfprintf_r+0x18c2>
80008eea:	2f 83       	sub	r3,-8
80008eec:	c0 b8       	rjmp	80008f02 <_vfprintf_r+0x18d6>
80008eee:	fa ca f9 78 	sub	r10,sp,-1672
80008ef2:	02 9b       	mov	r11,r1
80008ef4:	08 9c       	mov	r12,r4
80008ef6:	fe b0 f3 8d 	rcall	80007610 <__sprint_r>
80008efa:	e0 81 03 18 	brne	8000952a <_vfprintf_r+0x1efe>
80008efe:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f02:	ed b5 00 08 	bld	r5,0x8
80008f06:	c0 b0       	breq	80008f1c <_vfprintf_r+0x18f0>
80008f08:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f0c:	87 12       	st.w	r3[0x4],r2
80008f0e:	87 06       	st.w	r3[0x0],r6
80008f10:	f0 02 00 02 	add	r2,r8,r2
80008f14:	fb 42 06 90 	st.w	sp[1680],r2
80008f18:	e0 8f 01 d4 	bral	800092c0 <_vfprintf_r+0x1c94>
80008f1c:	e0 40 00 65 	cp.w	r0,101
80008f20:	e0 8a 01 d6 	brle	800092cc <_vfprintf_r+0x1ca0>
80008f24:	30 08       	mov	r8,0
80008f26:	30 09       	mov	r9,0
80008f28:	40 5b       	lddsp	r11,sp[0x14]
80008f2a:	40 7a       	lddsp	r10,sp[0x1c]
80008f2c:	e0 a0 16 15 	rcall	8000bb56 <__avr32_f64_cmp_eq>
80008f30:	c7 90       	breq	80009022 <_vfprintf_r+0x19f6>
80008f32:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f36:	fe c9 c7 4e 	sub	r9,pc,-14514
80008f3a:	2f f8       	sub	r8,-1
80008f3c:	87 09       	st.w	r3[0x0],r9
80008f3e:	fb 48 06 90 	st.w	sp[1680],r8
80008f42:	30 19       	mov	r9,1
80008f44:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f48:	87 19       	st.w	r3[0x4],r9
80008f4a:	2f f8       	sub	r8,-1
80008f4c:	fb 48 06 8c 	st.w	sp[1676],r8
80008f50:	58 78       	cp.w	r8,7
80008f52:	e0 89 00 05 	brgt	80008f5c <_vfprintf_r+0x1930>
80008f56:	2f 83       	sub	r3,-8
80008f58:	c0 c8       	rjmp	80008f70 <_vfprintf_r+0x1944>
80008f5a:	d7 03       	nop
80008f5c:	fa ca f9 78 	sub	r10,sp,-1672
80008f60:	02 9b       	mov	r11,r1
80008f62:	08 9c       	mov	r12,r4
80008f64:	fe b0 f3 56 	rcall	80007610 <__sprint_r>
80008f68:	e0 81 02 e1 	brne	8000952a <_vfprintf_r+0x1efe>
80008f6c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f70:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008f74:	40 6c       	lddsp	r12,sp[0x18]
80008f76:	18 38       	cp.w	r8,r12
80008f78:	c0 55       	brlt	80008f82 <_vfprintf_r+0x1956>
80008f7a:	ed b5 00 00 	bld	r5,0x0
80008f7e:	e0 81 02 6b 	brne	80009454 <_vfprintf_r+0x1e28>
80008f82:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f86:	2f f8       	sub	r8,-1
80008f88:	40 cb       	lddsp	r11,sp[0x30]
80008f8a:	fb 48 06 90 	st.w	sp[1680],r8
80008f8e:	30 19       	mov	r9,1
80008f90:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f94:	87 0b       	st.w	r3[0x0],r11
80008f96:	2f f8       	sub	r8,-1
80008f98:	87 19       	st.w	r3[0x4],r9
80008f9a:	fb 48 06 8c 	st.w	sp[1676],r8
80008f9e:	58 78       	cp.w	r8,7
80008fa0:	e0 89 00 04 	brgt	80008fa8 <_vfprintf_r+0x197c>
80008fa4:	2f 83       	sub	r3,-8
80008fa6:	c0 b8       	rjmp	80008fbc <_vfprintf_r+0x1990>
80008fa8:	fa ca f9 78 	sub	r10,sp,-1672
80008fac:	02 9b       	mov	r11,r1
80008fae:	08 9c       	mov	r12,r4
80008fb0:	fe b0 f3 30 	rcall	80007610 <__sprint_r>
80008fb4:	e0 81 02 bb 	brne	8000952a <_vfprintf_r+0x1efe>
80008fb8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fbc:	40 66       	lddsp	r6,sp[0x18]
80008fbe:	20 16       	sub	r6,1
80008fc0:	58 06       	cp.w	r6,0
80008fc2:	e0 89 00 1d 	brgt	80008ffc <_vfprintf_r+0x19d0>
80008fc6:	e0 8f 02 47 	bral	80009454 <_vfprintf_r+0x1e28>
80008fca:	2f 09       	sub	r9,-16
80008fcc:	2f f8       	sub	r8,-1
80008fce:	fb 49 06 90 	st.w	sp[1680],r9
80008fd2:	87 02       	st.w	r3[0x0],r2
80008fd4:	87 10       	st.w	r3[0x4],r0
80008fd6:	fb 48 06 8c 	st.w	sp[1676],r8
80008fda:	58 78       	cp.w	r8,7
80008fdc:	e0 89 00 04 	brgt	80008fe4 <_vfprintf_r+0x19b8>
80008fe0:	2f 83       	sub	r3,-8
80008fe2:	c0 b8       	rjmp	80008ff8 <_vfprintf_r+0x19cc>
80008fe4:	fa ca f9 78 	sub	r10,sp,-1672
80008fe8:	02 9b       	mov	r11,r1
80008fea:	08 9c       	mov	r12,r4
80008fec:	fe b0 f3 12 	rcall	80007610 <__sprint_r>
80008ff0:	e0 81 02 9d 	brne	8000952a <_vfprintf_r+0x1efe>
80008ff4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ff8:	21 06       	sub	r6,16
80008ffa:	c0 48       	rjmp	80009002 <_vfprintf_r+0x19d6>
80008ffc:	fe c2 c8 00 	sub	r2,pc,-14336
80009000:	31 00       	mov	r0,16
80009002:	fa f9 06 90 	ld.w	r9,sp[1680]
80009006:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000900a:	fe ca c8 0e 	sub	r10,pc,-14322
8000900e:	59 06       	cp.w	r6,16
80009010:	fe 99 ff dd 	brgt	80008fca <_vfprintf_r+0x199e>
80009014:	0c 09       	add	r9,r6
80009016:	87 0a       	st.w	r3[0x0],r10
80009018:	fb 49 06 90 	st.w	sp[1680],r9
8000901c:	2f f8       	sub	r8,-1
8000901e:	87 16       	st.w	r3[0x4],r6
80009020:	c5 39       	rjmp	800092c6 <_vfprintf_r+0x1c9a>
80009022:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009026:	58 0a       	cp.w	r10,0
80009028:	e0 89 00 92 	brgt	8000914c <_vfprintf_r+0x1b20>
8000902c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009030:	fe c9 c8 48 	sub	r9,pc,-14264
80009034:	2f f8       	sub	r8,-1
80009036:	87 09       	st.w	r3[0x0],r9
80009038:	fb 48 06 90 	st.w	sp[1680],r8
8000903c:	30 19       	mov	r9,1
8000903e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009042:	87 19       	st.w	r3[0x4],r9
80009044:	2f f8       	sub	r8,-1
80009046:	fb 48 06 8c 	st.w	sp[1676],r8
8000904a:	58 78       	cp.w	r8,7
8000904c:	e0 89 00 04 	brgt	80009054 <_vfprintf_r+0x1a28>
80009050:	2f 83       	sub	r3,-8
80009052:	c0 b8       	rjmp	80009068 <_vfprintf_r+0x1a3c>
80009054:	fa ca f9 78 	sub	r10,sp,-1672
80009058:	02 9b       	mov	r11,r1
8000905a:	08 9c       	mov	r12,r4
8000905c:	fe b0 f2 da 	rcall	80007610 <__sprint_r>
80009060:	e0 81 02 65 	brne	8000952a <_vfprintf_r+0x1efe>
80009064:	fa c3 f9 e0 	sub	r3,sp,-1568
80009068:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000906c:	58 08       	cp.w	r8,0
8000906e:	c0 81       	brne	8000907e <_vfprintf_r+0x1a52>
80009070:	40 6a       	lddsp	r10,sp[0x18]
80009072:	58 0a       	cp.w	r10,0
80009074:	c0 51       	brne	8000907e <_vfprintf_r+0x1a52>
80009076:	ed b5 00 00 	bld	r5,0x0
8000907a:	e0 81 01 ed 	brne	80009454 <_vfprintf_r+0x1e28>
8000907e:	40 c9       	lddsp	r9,sp[0x30]
80009080:	fa f8 06 90 	ld.w	r8,sp[1680]
80009084:	2f f8       	sub	r8,-1
80009086:	87 09       	st.w	r3[0x0],r9
80009088:	fb 48 06 90 	st.w	sp[1680],r8
8000908c:	30 19       	mov	r9,1
8000908e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009092:	87 19       	st.w	r3[0x4],r9
80009094:	2f f8       	sub	r8,-1
80009096:	fb 48 06 8c 	st.w	sp[1676],r8
8000909a:	58 78       	cp.w	r8,7
8000909c:	e0 89 00 04 	brgt	800090a4 <_vfprintf_r+0x1a78>
800090a0:	2f 83       	sub	r3,-8
800090a2:	c0 b8       	rjmp	800090b8 <_vfprintf_r+0x1a8c>
800090a4:	fa ca f9 78 	sub	r10,sp,-1672
800090a8:	02 9b       	mov	r11,r1
800090aa:	08 9c       	mov	r12,r4
800090ac:	fe b0 f2 b2 	rcall	80007610 <__sprint_r>
800090b0:	e0 81 02 3d 	brne	8000952a <_vfprintf_r+0x1efe>
800090b4:	fa c3 f9 e0 	sub	r3,sp,-1568
800090b8:	fa f2 06 ac 	ld.w	r2,sp[1708]
800090bc:	5c 32       	neg	r2
800090be:	58 02       	cp.w	r2,0
800090c0:	e0 89 00 1d 	brgt	800090fa <_vfprintf_r+0x1ace>
800090c4:	c3 d8       	rjmp	8000913e <_vfprintf_r+0x1b12>
800090c6:	2f 09       	sub	r9,-16
800090c8:	2f f8       	sub	r8,-1
800090ca:	31 0e       	mov	lr,16
800090cc:	fb 49 06 90 	st.w	sp[1680],r9
800090d0:	87 00       	st.w	r3[0x0],r0
800090d2:	87 1e       	st.w	r3[0x4],lr
800090d4:	fb 48 06 8c 	st.w	sp[1676],r8
800090d8:	58 78       	cp.w	r8,7
800090da:	e0 89 00 04 	brgt	800090e2 <_vfprintf_r+0x1ab6>
800090de:	2f 83       	sub	r3,-8
800090e0:	c0 b8       	rjmp	800090f6 <_vfprintf_r+0x1aca>
800090e2:	fa ca f9 78 	sub	r10,sp,-1672
800090e6:	02 9b       	mov	r11,r1
800090e8:	08 9c       	mov	r12,r4
800090ea:	fe b0 f2 93 	rcall	80007610 <__sprint_r>
800090ee:	e0 81 02 1e 	brne	8000952a <_vfprintf_r+0x1efe>
800090f2:	fa c3 f9 e0 	sub	r3,sp,-1568
800090f6:	21 02       	sub	r2,16
800090f8:	c0 38       	rjmp	800090fe <_vfprintf_r+0x1ad2>
800090fa:	fe c0 c8 fe 	sub	r0,pc,-14082
800090fe:	fa f9 06 90 	ld.w	r9,sp[1680]
80009102:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009106:	fe ca c9 0a 	sub	r10,pc,-14070
8000910a:	59 02       	cp.w	r2,16
8000910c:	fe 99 ff dd 	brgt	800090c6 <_vfprintf_r+0x1a9a>
80009110:	04 09       	add	r9,r2
80009112:	2f f8       	sub	r8,-1
80009114:	87 0a       	st.w	r3[0x0],r10
80009116:	fb 49 06 90 	st.w	sp[1680],r9
8000911a:	87 12       	st.w	r3[0x4],r2
8000911c:	fb 48 06 8c 	st.w	sp[1676],r8
80009120:	58 78       	cp.w	r8,7
80009122:	e0 89 00 04 	brgt	8000912a <_vfprintf_r+0x1afe>
80009126:	2f 83       	sub	r3,-8
80009128:	c0 b8       	rjmp	8000913e <_vfprintf_r+0x1b12>
8000912a:	fa ca f9 78 	sub	r10,sp,-1672
8000912e:	02 9b       	mov	r11,r1
80009130:	08 9c       	mov	r12,r4
80009132:	fe b0 f2 6f 	rcall	80007610 <__sprint_r>
80009136:	e0 81 01 fa 	brne	8000952a <_vfprintf_r+0x1efe>
8000913a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000913e:	40 6c       	lddsp	r12,sp[0x18]
80009140:	fa f8 06 90 	ld.w	r8,sp[1680]
80009144:	87 06       	st.w	r3[0x0],r6
80009146:	87 1c       	st.w	r3[0x4],r12
80009148:	18 08       	add	r8,r12
8000914a:	cb 98       	rjmp	800092bc <_vfprintf_r+0x1c90>
8000914c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009150:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009154:	40 6b       	lddsp	r11,sp[0x18]
80009156:	16 3a       	cp.w	r10,r11
80009158:	c6 f5       	brlt	80009236 <_vfprintf_r+0x1c0a>
8000915a:	16 09       	add	r9,r11
8000915c:	2f f8       	sub	r8,-1
8000915e:	87 06       	st.w	r3[0x0],r6
80009160:	fb 49 06 90 	st.w	sp[1680],r9
80009164:	87 1b       	st.w	r3[0x4],r11
80009166:	fb 48 06 8c 	st.w	sp[1676],r8
8000916a:	58 78       	cp.w	r8,7
8000916c:	e0 89 00 04 	brgt	80009174 <_vfprintf_r+0x1b48>
80009170:	2f 83       	sub	r3,-8
80009172:	c0 b8       	rjmp	80009188 <_vfprintf_r+0x1b5c>
80009174:	fa ca f9 78 	sub	r10,sp,-1672
80009178:	02 9b       	mov	r11,r1
8000917a:	08 9c       	mov	r12,r4
8000917c:	fe b0 f2 4a 	rcall	80007610 <__sprint_r>
80009180:	e0 81 01 d5 	brne	8000952a <_vfprintf_r+0x1efe>
80009184:	fa c3 f9 e0 	sub	r3,sp,-1568
80009188:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000918c:	40 6a       	lddsp	r10,sp[0x18]
8000918e:	14 16       	sub	r6,r10
80009190:	58 06       	cp.w	r6,0
80009192:	e0 89 00 1c 	brgt	800091ca <_vfprintf_r+0x1b9e>
80009196:	c3 d8       	rjmp	80009210 <_vfprintf_r+0x1be4>
80009198:	2f 09       	sub	r9,-16
8000919a:	2f f8       	sub	r8,-1
8000919c:	fb 49 06 90 	st.w	sp[1680],r9
800091a0:	87 02       	st.w	r3[0x0],r2
800091a2:	87 10       	st.w	r3[0x4],r0
800091a4:	fb 48 06 8c 	st.w	sp[1676],r8
800091a8:	58 78       	cp.w	r8,7
800091aa:	e0 89 00 04 	brgt	800091b2 <_vfprintf_r+0x1b86>
800091ae:	2f 83       	sub	r3,-8
800091b0:	c0 b8       	rjmp	800091c6 <_vfprintf_r+0x1b9a>
800091b2:	fa ca f9 78 	sub	r10,sp,-1672
800091b6:	02 9b       	mov	r11,r1
800091b8:	08 9c       	mov	r12,r4
800091ba:	fe b0 f2 2b 	rcall	80007610 <__sprint_r>
800091be:	e0 81 01 b6 	brne	8000952a <_vfprintf_r+0x1efe>
800091c2:	fa c3 f9 e0 	sub	r3,sp,-1568
800091c6:	21 06       	sub	r6,16
800091c8:	c0 48       	rjmp	800091d0 <_vfprintf_r+0x1ba4>
800091ca:	fe c2 c9 ce 	sub	r2,pc,-13874
800091ce:	31 00       	mov	r0,16
800091d0:	fa f9 06 90 	ld.w	r9,sp[1680]
800091d4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091d8:	fe ca c9 dc 	sub	r10,pc,-13860
800091dc:	59 06       	cp.w	r6,16
800091de:	fe 99 ff dd 	brgt	80009198 <_vfprintf_r+0x1b6c>
800091e2:	0c 09       	add	r9,r6
800091e4:	2f f8       	sub	r8,-1
800091e6:	87 0a       	st.w	r3[0x0],r10
800091e8:	fb 49 06 90 	st.w	sp[1680],r9
800091ec:	87 16       	st.w	r3[0x4],r6
800091ee:	fb 48 06 8c 	st.w	sp[1676],r8
800091f2:	58 78       	cp.w	r8,7
800091f4:	e0 89 00 04 	brgt	800091fc <_vfprintf_r+0x1bd0>
800091f8:	2f 83       	sub	r3,-8
800091fa:	c0 b8       	rjmp	80009210 <_vfprintf_r+0x1be4>
800091fc:	fa ca f9 78 	sub	r10,sp,-1672
80009200:	02 9b       	mov	r11,r1
80009202:	08 9c       	mov	r12,r4
80009204:	fe b0 f2 06 	rcall	80007610 <__sprint_r>
80009208:	e0 81 01 91 	brne	8000952a <_vfprintf_r+0x1efe>
8000920c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009210:	ed b5 00 00 	bld	r5,0x0
80009214:	e0 81 01 20 	brne	80009454 <_vfprintf_r+0x1e28>
80009218:	40 c9       	lddsp	r9,sp[0x30]
8000921a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000921e:	2f f8       	sub	r8,-1
80009220:	87 09       	st.w	r3[0x0],r9
80009222:	fb 48 06 90 	st.w	sp[1680],r8
80009226:	30 19       	mov	r9,1
80009228:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000922c:	87 19       	st.w	r3[0x4],r9
8000922e:	2f f8       	sub	r8,-1
80009230:	fb 48 06 8c 	st.w	sp[1676],r8
80009234:	c0 29       	rjmp	80009438 <_vfprintf_r+0x1e0c>
80009236:	14 09       	add	r9,r10
80009238:	2f f8       	sub	r8,-1
8000923a:	fb 49 06 90 	st.w	sp[1680],r9
8000923e:	87 06       	st.w	r3[0x0],r6
80009240:	87 1a       	st.w	r3[0x4],r10
80009242:	fb 48 06 8c 	st.w	sp[1676],r8
80009246:	58 78       	cp.w	r8,7
80009248:	e0 89 00 04 	brgt	80009250 <_vfprintf_r+0x1c24>
8000924c:	2f 83       	sub	r3,-8
8000924e:	c0 b8       	rjmp	80009264 <_vfprintf_r+0x1c38>
80009250:	fa ca f9 78 	sub	r10,sp,-1672
80009254:	02 9b       	mov	r11,r1
80009256:	08 9c       	mov	r12,r4
80009258:	fe b0 f1 dc 	rcall	80007610 <__sprint_r>
8000925c:	e0 81 01 67 	brne	8000952a <_vfprintf_r+0x1efe>
80009260:	fa c3 f9 e0 	sub	r3,sp,-1568
80009264:	40 c8       	lddsp	r8,sp[0x30]
80009266:	87 08       	st.w	r3[0x0],r8
80009268:	fa f8 06 90 	ld.w	r8,sp[1680]
8000926c:	2f f8       	sub	r8,-1
8000926e:	30 19       	mov	r9,1
80009270:	fb 48 06 90 	st.w	sp[1680],r8
80009274:	87 19       	st.w	r3[0x4],r9
80009276:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000927a:	2f f8       	sub	r8,-1
8000927c:	fb 48 06 8c 	st.w	sp[1676],r8
80009280:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009284:	58 78       	cp.w	r8,7
80009286:	e0 89 00 04 	brgt	8000928e <_vfprintf_r+0x1c62>
8000928a:	2f 83       	sub	r3,-8
8000928c:	c0 b8       	rjmp	800092a2 <_vfprintf_r+0x1c76>
8000928e:	fa ca f9 78 	sub	r10,sp,-1672
80009292:	02 9b       	mov	r11,r1
80009294:	08 9c       	mov	r12,r4
80009296:	fe b0 f1 bd 	rcall	80007610 <__sprint_r>
8000929a:	e0 81 01 48 	brne	8000952a <_vfprintf_r+0x1efe>
8000929e:	fa c3 f9 e0 	sub	r3,sp,-1568
800092a2:	04 06       	add	r6,r2
800092a4:	fa f8 06 ac 	ld.w	r8,sp[1708]
800092a8:	87 06       	st.w	r3[0x0],r6
800092aa:	fa f9 06 90 	ld.w	r9,sp[1680]
800092ae:	40 66       	lddsp	r6,sp[0x18]
800092b0:	40 6e       	lddsp	lr,sp[0x18]
800092b2:	10 16       	sub	r6,r8
800092b4:	f2 08 01 08 	sub	r8,r9,r8
800092b8:	87 16       	st.w	r3[0x4],r6
800092ba:	1c 08       	add	r8,lr
800092bc:	fb 48 06 90 	st.w	sp[1680],r8
800092c0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092c4:	2f f8       	sub	r8,-1
800092c6:	fb 48 06 8c 	st.w	sp[1676],r8
800092ca:	cb 78       	rjmp	80009438 <_vfprintf_r+0x1e0c>
800092cc:	40 6c       	lddsp	r12,sp[0x18]
800092ce:	58 1c       	cp.w	r12,1
800092d0:	e0 89 00 06 	brgt	800092dc <_vfprintf_r+0x1cb0>
800092d4:	ed b5 00 00 	bld	r5,0x0
800092d8:	e0 81 00 85 	brne	800093e2 <_vfprintf_r+0x1db6>
800092dc:	fa f8 06 90 	ld.w	r8,sp[1680]
800092e0:	2f f8       	sub	r8,-1
800092e2:	30 19       	mov	r9,1
800092e4:	fb 48 06 90 	st.w	sp[1680],r8
800092e8:	87 06       	st.w	r3[0x0],r6
800092ea:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092ee:	87 19       	st.w	r3[0x4],r9
800092f0:	2f f8       	sub	r8,-1
800092f2:	fb 48 06 8c 	st.w	sp[1676],r8
800092f6:	58 78       	cp.w	r8,7
800092f8:	e0 89 00 04 	brgt	80009300 <_vfprintf_r+0x1cd4>
800092fc:	2f 83       	sub	r3,-8
800092fe:	c0 b8       	rjmp	80009314 <_vfprintf_r+0x1ce8>
80009300:	fa ca f9 78 	sub	r10,sp,-1672
80009304:	02 9b       	mov	r11,r1
80009306:	08 9c       	mov	r12,r4
80009308:	fe b0 f1 84 	rcall	80007610 <__sprint_r>
8000930c:	e0 81 01 0f 	brne	8000952a <_vfprintf_r+0x1efe>
80009310:	fa c3 f9 e0 	sub	r3,sp,-1568
80009314:	fa f8 06 90 	ld.w	r8,sp[1680]
80009318:	2f f8       	sub	r8,-1
8000931a:	40 cb       	lddsp	r11,sp[0x30]
8000931c:	fb 48 06 90 	st.w	sp[1680],r8
80009320:	30 19       	mov	r9,1
80009322:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009326:	87 0b       	st.w	r3[0x0],r11
80009328:	2f f8       	sub	r8,-1
8000932a:	87 19       	st.w	r3[0x4],r9
8000932c:	fb 48 06 8c 	st.w	sp[1676],r8
80009330:	58 78       	cp.w	r8,7
80009332:	e0 89 00 05 	brgt	8000933c <_vfprintf_r+0x1d10>
80009336:	2f 83       	sub	r3,-8
80009338:	c0 c8       	rjmp	80009350 <_vfprintf_r+0x1d24>
8000933a:	d7 03       	nop
8000933c:	fa ca f9 78 	sub	r10,sp,-1672
80009340:	02 9b       	mov	r11,r1
80009342:	08 9c       	mov	r12,r4
80009344:	fe b0 f1 66 	rcall	80007610 <__sprint_r>
80009348:	e0 81 00 f1 	brne	8000952a <_vfprintf_r+0x1efe>
8000934c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009350:	30 08       	mov	r8,0
80009352:	30 09       	mov	r9,0
80009354:	40 5b       	lddsp	r11,sp[0x14]
80009356:	40 7a       	lddsp	r10,sp[0x1c]
80009358:	e0 a0 13 ff 	rcall	8000bb56 <__avr32_f64_cmp_eq>
8000935c:	40 68       	lddsp	r8,sp[0x18]
8000935e:	20 18       	sub	r8,1
80009360:	58 0c       	cp.w	r12,0
80009362:	c0 d1       	brne	8000937c <_vfprintf_r+0x1d50>
80009364:	2f f6       	sub	r6,-1
80009366:	87 18       	st.w	r3[0x4],r8
80009368:	87 06       	st.w	r3[0x0],r6
8000936a:	fa f6 06 90 	ld.w	r6,sp[1680]
8000936e:	10 06       	add	r6,r8
80009370:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009374:	fb 46 06 90 	st.w	sp[1680],r6
80009378:	2f f8       	sub	r8,-1
8000937a:	c3 18       	rjmp	800093dc <_vfprintf_r+0x1db0>
8000937c:	10 96       	mov	r6,r8
8000937e:	58 08       	cp.w	r8,0
80009380:	e0 89 00 1c 	brgt	800093b8 <_vfprintf_r+0x1d8c>
80009384:	c4 b8       	rjmp	8000941a <_vfprintf_r+0x1dee>
80009386:	2f 09       	sub	r9,-16
80009388:	2f f8       	sub	r8,-1
8000938a:	fb 49 06 90 	st.w	sp[1680],r9
8000938e:	87 02       	st.w	r3[0x0],r2
80009390:	87 10       	st.w	r3[0x4],r0
80009392:	fb 48 06 8c 	st.w	sp[1676],r8
80009396:	58 78       	cp.w	r8,7
80009398:	e0 89 00 04 	brgt	800093a0 <_vfprintf_r+0x1d74>
8000939c:	2f 83       	sub	r3,-8
8000939e:	c0 b8       	rjmp	800093b4 <_vfprintf_r+0x1d88>
800093a0:	fa ca f9 78 	sub	r10,sp,-1672
800093a4:	02 9b       	mov	r11,r1
800093a6:	08 9c       	mov	r12,r4
800093a8:	fe b0 f1 34 	rcall	80007610 <__sprint_r>
800093ac:	e0 81 00 bf 	brne	8000952a <_vfprintf_r+0x1efe>
800093b0:	fa c3 f9 e0 	sub	r3,sp,-1568
800093b4:	21 06       	sub	r6,16
800093b6:	c0 48       	rjmp	800093be <_vfprintf_r+0x1d92>
800093b8:	fe c2 cb bc 	sub	r2,pc,-13380
800093bc:	31 00       	mov	r0,16
800093be:	fa f9 06 90 	ld.w	r9,sp[1680]
800093c2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093c6:	fe ca cb ca 	sub	r10,pc,-13366
800093ca:	59 06       	cp.w	r6,16
800093cc:	fe 99 ff dd 	brgt	80009386 <_vfprintf_r+0x1d5a>
800093d0:	0c 09       	add	r9,r6
800093d2:	87 0a       	st.w	r3[0x0],r10
800093d4:	fb 49 06 90 	st.w	sp[1680],r9
800093d8:	2f f8       	sub	r8,-1
800093da:	87 16       	st.w	r3[0x4],r6
800093dc:	fb 48 06 8c 	st.w	sp[1676],r8
800093e0:	c0 e8       	rjmp	800093fc <_vfprintf_r+0x1dd0>
800093e2:	fa f8 06 90 	ld.w	r8,sp[1680]
800093e6:	2f f8       	sub	r8,-1
800093e8:	30 19       	mov	r9,1
800093ea:	fb 48 06 90 	st.w	sp[1680],r8
800093ee:	87 06       	st.w	r3[0x0],r6
800093f0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093f4:	87 19       	st.w	r3[0x4],r9
800093f6:	2f f8       	sub	r8,-1
800093f8:	fb 48 06 8c 	st.w	sp[1676],r8
800093fc:	58 78       	cp.w	r8,7
800093fe:	e0 89 00 04 	brgt	80009406 <_vfprintf_r+0x1dda>
80009402:	2f 83       	sub	r3,-8
80009404:	c0 b8       	rjmp	8000941a <_vfprintf_r+0x1dee>
80009406:	fa ca f9 78 	sub	r10,sp,-1672
8000940a:	02 9b       	mov	r11,r1
8000940c:	08 9c       	mov	r12,r4
8000940e:	fe b0 f1 01 	rcall	80007610 <__sprint_r>
80009412:	e0 81 00 8c 	brne	8000952a <_vfprintf_r+0x1efe>
80009416:	fa c3 f9 e0 	sub	r3,sp,-1568
8000941a:	40 ea       	lddsp	r10,sp[0x38]
8000941c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009420:	14 08       	add	r8,r10
80009422:	fa c9 f9 64 	sub	r9,sp,-1692
80009426:	fb 48 06 90 	st.w	sp[1680],r8
8000942a:	87 1a       	st.w	r3[0x4],r10
8000942c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009430:	87 09       	st.w	r3[0x0],r9
80009432:	2f f8       	sub	r8,-1
80009434:	fb 48 06 8c 	st.w	sp[1676],r8
80009438:	58 78       	cp.w	r8,7
8000943a:	e0 89 00 04 	brgt	80009442 <_vfprintf_r+0x1e16>
8000943e:	2f 83       	sub	r3,-8
80009440:	c0 a8       	rjmp	80009454 <_vfprintf_r+0x1e28>
80009442:	fa ca f9 78 	sub	r10,sp,-1672
80009446:	02 9b       	mov	r11,r1
80009448:	08 9c       	mov	r12,r4
8000944a:	fe b0 f0 e3 	rcall	80007610 <__sprint_r>
8000944e:	c6 e1       	brne	8000952a <_vfprintf_r+0x1efe>
80009450:	fa c3 f9 e0 	sub	r3,sp,-1568
80009454:	e2 15 00 04 	andl	r5,0x4,COH
80009458:	c3 f0       	breq	800094d6 <_vfprintf_r+0x1eaa>
8000945a:	40 86       	lddsp	r6,sp[0x20]
8000945c:	40 39       	lddsp	r9,sp[0xc]
8000945e:	12 16       	sub	r6,r9
80009460:	58 06       	cp.w	r6,0
80009462:	e0 89 00 1a 	brgt	80009496 <_vfprintf_r+0x1e6a>
80009466:	c3 88       	rjmp	800094d6 <_vfprintf_r+0x1eaa>
80009468:	2f 09       	sub	r9,-16
8000946a:	2f f8       	sub	r8,-1
8000946c:	fb 49 06 90 	st.w	sp[1680],r9
80009470:	87 05       	st.w	r3[0x0],r5
80009472:	87 12       	st.w	r3[0x4],r2
80009474:	fb 48 06 8c 	st.w	sp[1676],r8
80009478:	58 78       	cp.w	r8,7
8000947a:	e0 89 00 04 	brgt	80009482 <_vfprintf_r+0x1e56>
8000947e:	2f 83       	sub	r3,-8
80009480:	c0 98       	rjmp	80009492 <_vfprintf_r+0x1e66>
80009482:	00 9a       	mov	r10,r0
80009484:	02 9b       	mov	r11,r1
80009486:	08 9c       	mov	r12,r4
80009488:	fe b0 f0 c4 	rcall	80007610 <__sprint_r>
8000948c:	c4 f1       	brne	8000952a <_vfprintf_r+0x1efe>
8000948e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009492:	21 06       	sub	r6,16
80009494:	c0 68       	rjmp	800094a0 <_vfprintf_r+0x1e74>
80009496:	fe c5 cc aa 	sub	r5,pc,-13142
8000949a:	31 02       	mov	r2,16
8000949c:	fa c0 f9 78 	sub	r0,sp,-1672
800094a0:	fa f9 06 90 	ld.w	r9,sp[1680]
800094a4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094a8:	fe ca cc bc 	sub	r10,pc,-13124
800094ac:	59 06       	cp.w	r6,16
800094ae:	fe 99 ff dd 	brgt	80009468 <_vfprintf_r+0x1e3c>
800094b2:	0c 09       	add	r9,r6
800094b4:	2f f8       	sub	r8,-1
800094b6:	87 0a       	st.w	r3[0x0],r10
800094b8:	87 16       	st.w	r3[0x4],r6
800094ba:	fb 49 06 90 	st.w	sp[1680],r9
800094be:	fb 48 06 8c 	st.w	sp[1676],r8
800094c2:	58 78       	cp.w	r8,7
800094c4:	e0 8a 00 09 	brle	800094d6 <_vfprintf_r+0x1eaa>
800094c8:	fa ca f9 78 	sub	r10,sp,-1672
800094cc:	02 9b       	mov	r11,r1
800094ce:	08 9c       	mov	r12,r4
800094d0:	fe b0 f0 a0 	rcall	80007610 <__sprint_r>
800094d4:	c2 b1       	brne	8000952a <_vfprintf_r+0x1efe>
800094d6:	40 bc       	lddsp	r12,sp[0x2c]
800094d8:	40 36       	lddsp	r6,sp[0xc]
800094da:	40 8e       	lddsp	lr,sp[0x20]
800094dc:	ec 0e 0c 48 	max	r8,r6,lr
800094e0:	10 0c       	add	r12,r8
800094e2:	50 bc       	stdsp	sp[0x2c],r12
800094e4:	fa f8 06 90 	ld.w	r8,sp[1680]
800094e8:	58 08       	cp.w	r8,0
800094ea:	c0 80       	breq	800094fa <_vfprintf_r+0x1ece>
800094ec:	fa ca f9 78 	sub	r10,sp,-1672
800094f0:	02 9b       	mov	r11,r1
800094f2:	08 9c       	mov	r12,r4
800094f4:	fe b0 f0 8e 	rcall	80007610 <__sprint_r>
800094f8:	c1 91       	brne	8000952a <_vfprintf_r+0x1efe>
800094fa:	30 0b       	mov	r11,0
800094fc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009500:	fb 4b 06 8c 	st.w	sp[1676],r11
80009504:	fe 9f f1 22 	bral	80007748 <_vfprintf_r+0x11c>
80009508:	08 95       	mov	r5,r4
8000950a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000950e:	58 08       	cp.w	r8,0
80009510:	c0 80       	breq	80009520 <_vfprintf_r+0x1ef4>
80009512:	08 9c       	mov	r12,r4
80009514:	fa ca f9 78 	sub	r10,sp,-1672
80009518:	02 9b       	mov	r11,r1
8000951a:	fe b0 f0 7b 	rcall	80007610 <__sprint_r>
8000951e:	c0 61       	brne	8000952a <_vfprintf_r+0x1efe>
80009520:	30 08       	mov	r8,0
80009522:	fb 48 06 8c 	st.w	sp[1676],r8
80009526:	c0 28       	rjmp	8000952a <_vfprintf_r+0x1efe>
80009528:	40 41       	lddsp	r1,sp[0x10]
8000952a:	82 68       	ld.sh	r8,r1[0xc]
8000952c:	ed b8 00 06 	bld	r8,0x6
80009530:	c0 31       	brne	80009536 <_vfprintf_r+0x1f0a>
80009532:	3f fa       	mov	r10,-1
80009534:	50 ba       	stdsp	sp[0x2c],r10
80009536:	40 bc       	lddsp	r12,sp[0x2c]
80009538:	fe 3d f9 44 	sub	sp,-1724
8000953c:	d8 32       	popm	r0-r7,pc
8000953e:	d7 03       	nop

80009540 <_vsprintf_r>:
80009540:	d4 01       	pushm	lr
80009542:	21 7d       	sub	sp,92
80009544:	e0 68 ff ff 	mov	r8,65535
80009548:	ea 18 7f ff 	orh	r8,0x7fff
8000954c:	50 58       	stdsp	sp[0x14],r8
8000954e:	50 28       	stdsp	sp[0x8],r8
80009550:	e0 68 02 08 	mov	r8,520
80009554:	ba 68       	st.h	sp[0xc],r8
80009556:	3f f8       	mov	r8,-1
80009558:	50 4b       	stdsp	sp[0x10],r11
8000955a:	50 0b       	stdsp	sp[0x0],r11
8000955c:	ba 78       	st.h	sp[0xe],r8
8000955e:	1a 9b       	mov	r11,sp
80009560:	fe b0 f0 66 	rcall	8000762c <_vfprintf_r>
80009564:	30 09       	mov	r9,0
80009566:	40 08       	lddsp	r8,sp[0x0]
80009568:	b0 89       	st.b	r8[0x0],r9
8000956a:	2e 9d       	sub	sp,-92
8000956c:	d8 02       	popm	pc
8000956e:	d7 03       	nop

80009570 <vsprintf>:
80009570:	d4 01       	pushm	lr
80009572:	e0 68 01 18 	mov	r8,280
80009576:	14 99       	mov	r9,r10
80009578:	16 9a       	mov	r10,r11
8000957a:	18 9b       	mov	r11,r12
8000957c:	70 0c       	ld.w	r12,r8[0x0]
8000957e:	ce 1f       	rcall	80009540 <_vsprintf_r>
80009580:	d8 02       	popm	pc
80009582:	d7 03       	nop

80009584 <__swsetup_r>:
80009584:	d4 21       	pushm	r4-r7,lr
80009586:	e0 68 01 18 	mov	r8,280
8000958a:	18 96       	mov	r6,r12
8000958c:	16 97       	mov	r7,r11
8000958e:	70 0c       	ld.w	r12,r8[0x0]
80009590:	58 0c       	cp.w	r12,0
80009592:	c0 60       	breq	8000959e <__swsetup_r+0x1a>
80009594:	78 68       	ld.w	r8,r12[0x18]
80009596:	58 08       	cp.w	r8,0
80009598:	c0 31       	brne	8000959e <__swsetup_r+0x1a>
8000959a:	e0 a0 08 77 	rcall	8000a688 <__sinit>
8000959e:	fe c8 cc 82 	sub	r8,pc,-13182
800095a2:	10 37       	cp.w	r7,r8
800095a4:	c0 61       	brne	800095b0 <__swsetup_r+0x2c>
800095a6:	e0 68 01 18 	mov	r8,280
800095aa:	70 08       	ld.w	r8,r8[0x0]
800095ac:	70 07       	ld.w	r7,r8[0x0]
800095ae:	c1 28       	rjmp	800095d2 <__swsetup_r+0x4e>
800095b0:	fe c8 cc 74 	sub	r8,pc,-13196
800095b4:	10 37       	cp.w	r7,r8
800095b6:	c0 61       	brne	800095c2 <__swsetup_r+0x3e>
800095b8:	e0 68 01 18 	mov	r8,280
800095bc:	70 08       	ld.w	r8,r8[0x0]
800095be:	70 17       	ld.w	r7,r8[0x4]
800095c0:	c0 98       	rjmp	800095d2 <__swsetup_r+0x4e>
800095c2:	fe c8 cc 66 	sub	r8,pc,-13210
800095c6:	10 37       	cp.w	r7,r8
800095c8:	c0 51       	brne	800095d2 <__swsetup_r+0x4e>
800095ca:	e0 68 01 18 	mov	r8,280
800095ce:	70 08       	ld.w	r8,r8[0x0]
800095d0:	70 27       	ld.w	r7,r8[0x8]
800095d2:	8e 68       	ld.sh	r8,r7[0xc]
800095d4:	ed b8 00 03 	bld	r8,0x3
800095d8:	c1 e0       	breq	80009614 <__swsetup_r+0x90>
800095da:	ed b8 00 04 	bld	r8,0x4
800095de:	c3 e1       	brne	8000965a <__swsetup_r+0xd6>
800095e0:	ed b8 00 02 	bld	r8,0x2
800095e4:	c1 51       	brne	8000960e <__swsetup_r+0x8a>
800095e6:	6e db       	ld.w	r11,r7[0x34]
800095e8:	58 0b       	cp.w	r11,0
800095ea:	c0 a0       	breq	800095fe <__swsetup_r+0x7a>
800095ec:	ee c8 ff bc 	sub	r8,r7,-68
800095f0:	10 3b       	cp.w	r11,r8
800095f2:	c0 40       	breq	800095fa <__swsetup_r+0x76>
800095f4:	0c 9c       	mov	r12,r6
800095f6:	e0 a0 08 e3 	rcall	8000a7bc <_free_r>
800095fa:	30 08       	mov	r8,0
800095fc:	8f d8       	st.w	r7[0x34],r8
800095fe:	8e 68       	ld.sh	r8,r7[0xc]
80009600:	e0 18 ff db 	andl	r8,0xffdb
80009604:	ae 68       	st.h	r7[0xc],r8
80009606:	30 08       	mov	r8,0
80009608:	8f 18       	st.w	r7[0x4],r8
8000960a:	6e 48       	ld.w	r8,r7[0x10]
8000960c:	8f 08       	st.w	r7[0x0],r8
8000960e:	8e 68       	ld.sh	r8,r7[0xc]
80009610:	a3 b8       	sbr	r8,0x3
80009612:	ae 68       	st.h	r7[0xc],r8
80009614:	6e 48       	ld.w	r8,r7[0x10]
80009616:	58 08       	cp.w	r8,0
80009618:	c0 b1       	brne	8000962e <__swsetup_r+0xaa>
8000961a:	8e 68       	ld.sh	r8,r7[0xc]
8000961c:	e2 18 02 80 	andl	r8,0x280,COH
80009620:	e0 48 02 00 	cp.w	r8,512
80009624:	c0 50       	breq	8000962e <__swsetup_r+0xaa>
80009626:	0c 9c       	mov	r12,r6
80009628:	0e 9b       	mov	r11,r7
8000962a:	e0 a0 0b 03 	rcall	8000ac30 <__smakebuf_r>
8000962e:	8e 69       	ld.sh	r9,r7[0xc]
80009630:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009634:	c0 70       	breq	80009642 <__swsetup_r+0xbe>
80009636:	30 08       	mov	r8,0
80009638:	8f 28       	st.w	r7[0x8],r8
8000963a:	6e 58       	ld.w	r8,r7[0x14]
8000963c:	5c 38       	neg	r8
8000963e:	8f 68       	st.w	r7[0x18],r8
80009640:	c0 68       	rjmp	8000964c <__swsetup_r+0xc8>
80009642:	ed b9 00 01 	bld	r9,0x1
80009646:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000964a:	8f 28       	st.w	r7[0x8],r8
8000964c:	6e 48       	ld.w	r8,r7[0x10]
8000964e:	58 08       	cp.w	r8,0
80009650:	c0 61       	brne	8000965c <__swsetup_r+0xd8>
80009652:	8e 68       	ld.sh	r8,r7[0xc]
80009654:	ed b8 00 07 	bld	r8,0x7
80009658:	c0 21       	brne	8000965c <__swsetup_r+0xd8>
8000965a:	dc 2a       	popm	r4-r7,pc,r12=-1
8000965c:	d8 2a       	popm	r4-r7,pc,r12=0
8000965e:	d7 03       	nop

80009660 <__register_exitproc>:
80009660:	d4 31       	pushm	r0-r7,lr
80009662:	fe c8 d1 2e 	sub	r8,pc,-11986
80009666:	70 03       	ld.w	r3,r8[0x0]
80009668:	67 24       	ld.w	r4,r3[0x48]
8000966a:	e6 c8 ff b4 	sub	r8,r3,-76
8000966e:	58 04       	cp.w	r4,0
80009670:	f0 04 17 00 	moveq	r4,r8
80009674:	e7 f4 0a 12 	st.weq	r3[0x48],r4
80009678:	18 97       	mov	r7,r12
8000967a:	16 96       	mov	r6,r11
8000967c:	14 95       	mov	r5,r10
8000967e:	12 92       	mov	r2,r9
80009680:	68 18       	ld.w	r8,r4[0x4]
80009682:	59 f8       	cp.w	r8,31
80009684:	e0 8a 00 0e 	brle	800096a0 <__register_exitproc+0x40>
80009688:	e0 6c 00 8c 	mov	r12,140
8000968c:	fe b0 e9 56 	rcall	80006938 <malloc>
80009690:	18 94       	mov	r4,r12
80009692:	c3 80       	breq	80009702 <__register_exitproc+0xa2>
80009694:	67 28       	ld.w	r8,r3[0x48]
80009696:	99 08       	st.w	r12[0x0],r8
80009698:	e7 4c 00 48 	st.w	r3[72],r12
8000969c:	30 08       	mov	r8,0
8000969e:	99 18       	st.w	r12[0x4],r8
800096a0:	58 07       	cp.w	r7,0
800096a2:	c2 70       	breq	800096f0 <__register_exitproc+0x90>
800096a4:	e8 fc 00 88 	ld.w	r12,r4[136]
800096a8:	58 0c       	cp.w	r12,0
800096aa:	c0 d1       	brne	800096c4 <__register_exitproc+0x64>
800096ac:	e0 6c 01 08 	mov	r12,264
800096b0:	fe b0 e9 44 	rcall	80006938 <malloc>
800096b4:	c2 70       	breq	80009702 <__register_exitproc+0xa2>
800096b6:	30 08       	mov	r8,0
800096b8:	e9 4c 00 88 	st.w	r4[136],r12
800096bc:	f9 48 01 04 	st.w	r12[260],r8
800096c0:	f9 48 01 00 	st.w	r12[256],r8
800096c4:	68 18       	ld.w	r8,r4[0x4]
800096c6:	f0 c9 ff e0 	sub	r9,r8,-32
800096ca:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
800096ce:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
800096d2:	30 1a       	mov	r10,1
800096d4:	f8 f9 01 00 	ld.w	r9,r12[256]
800096d8:	f4 08 09 48 	lsl	r8,r10,r8
800096dc:	10 49       	or	r9,r8
800096de:	f9 49 01 00 	st.w	r12[256],r9
800096e2:	58 27       	cp.w	r7,2
800096e4:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
800096e8:	f3 d8 e0 38 	oreq	r8,r9,r8
800096ec:	f9 f8 0a 41 	st.weq	r12[0x104],r8
800096f0:	68 18       	ld.w	r8,r4[0x4]
800096f2:	30 0c       	mov	r12,0
800096f4:	f0 c9 ff ff 	sub	r9,r8,-1
800096f8:	2f e8       	sub	r8,-2
800096fa:	89 19       	st.w	r4[0x4],r9
800096fc:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
80009700:	d8 32       	popm	r0-r7,pc
80009702:	dc 3a       	popm	r0-r7,pc,r12=-1

80009704 <__call_exitprocs>:
80009704:	d4 31       	pushm	r0-r7,lr
80009706:	20 3d       	sub	sp,12
80009708:	fe c8 d1 d4 	sub	r8,pc,-11820
8000970c:	50 2c       	stdsp	sp[0x8],r12
8000970e:	70 08       	ld.w	r8,r8[0x0]
80009710:	16 91       	mov	r1,r11
80009712:	50 08       	stdsp	sp[0x0],r8
80009714:	2b 88       	sub	r8,-72
80009716:	50 18       	stdsp	sp[0x4],r8
80009718:	40 0a       	lddsp	r10,sp[0x0]
8000971a:	40 14       	lddsp	r4,sp[0x4]
8000971c:	75 27       	ld.w	r7,r10[0x48]
8000971e:	c5 58       	rjmp	800097c8 <__call_exitprocs+0xc4>
80009720:	6e 15       	ld.w	r5,r7[0x4]
80009722:	ee f6 00 88 	ld.w	r6,r7[136]
80009726:	ea c2 ff ff 	sub	r2,r5,-1
8000972a:	20 15       	sub	r5,1
8000972c:	ee 02 00 22 	add	r2,r7,r2<<0x2
80009730:	ec 05 00 23 	add	r3,r6,r5<<0x2
80009734:	c3 58       	rjmp	8000979e <__call_exitprocs+0x9a>
80009736:	58 01       	cp.w	r1,0
80009738:	c0 70       	breq	80009746 <__call_exitprocs+0x42>
8000973a:	58 06       	cp.w	r6,0
8000973c:	c2 e0       	breq	80009798 <__call_exitprocs+0x94>
8000973e:	e6 f8 00 80 	ld.w	r8,r3[128]
80009742:	02 38       	cp.w	r8,r1
80009744:	c2 a1       	brne	80009798 <__call_exitprocs+0x94>
80009746:	6e 19       	ld.w	r9,r7[0x4]
80009748:	64 08       	ld.w	r8,r2[0x0]
8000974a:	20 19       	sub	r9,1
8000974c:	12 35       	cp.w	r5,r9
8000974e:	ef f5 0a 01 	st.weq	r7[0x4],r5
80009752:	f9 b9 01 00 	movne	r9,0
80009756:	e5 f9 1a 00 	st.wne	r2[0x0],r9
8000975a:	58 08       	cp.w	r8,0
8000975c:	c1 e0       	breq	80009798 <__call_exitprocs+0x94>
8000975e:	6e 10       	ld.w	r0,r7[0x4]
80009760:	58 06       	cp.w	r6,0
80009762:	c0 90       	breq	80009774 <__call_exitprocs+0x70>
80009764:	30 1a       	mov	r10,1
80009766:	f4 05 09 49 	lsl	r9,r10,r5
8000976a:	ec fa 01 00 	ld.w	r10,r6[256]
8000976e:	f3 ea 00 0a 	and	r10,r9,r10
80009772:	c0 31       	brne	80009778 <__call_exitprocs+0x74>
80009774:	5d 18       	icall	r8
80009776:	c0 b8       	rjmp	8000978c <__call_exitprocs+0x88>
80009778:	ec fa 01 04 	ld.w	r10,r6[260]
8000977c:	66 0b       	ld.w	r11,r3[0x0]
8000977e:	14 69       	and	r9,r10
80009780:	c0 41       	brne	80009788 <__call_exitprocs+0x84>
80009782:	40 2c       	lddsp	r12,sp[0x8]
80009784:	5d 18       	icall	r8
80009786:	c0 38       	rjmp	8000978c <__call_exitprocs+0x88>
80009788:	16 9c       	mov	r12,r11
8000978a:	5d 18       	icall	r8
8000978c:	6e 18       	ld.w	r8,r7[0x4]
8000978e:	10 30       	cp.w	r0,r8
80009790:	cc 41       	brne	80009718 <__call_exitprocs+0x14>
80009792:	68 08       	ld.w	r8,r4[0x0]
80009794:	0e 38       	cp.w	r8,r7
80009796:	cc 11       	brne	80009718 <__call_exitprocs+0x14>
80009798:	20 15       	sub	r5,1
8000979a:	20 43       	sub	r3,4
8000979c:	20 42       	sub	r2,4
8000979e:	58 05       	cp.w	r5,0
800097a0:	cc b4       	brge	80009736 <__call_exitprocs+0x32>
800097a2:	6e 18       	ld.w	r8,r7[0x4]
800097a4:	58 08       	cp.w	r8,0
800097a6:	c0 f1       	brne	800097c4 <__call_exitprocs+0xc0>
800097a8:	6e 08       	ld.w	r8,r7[0x0]
800097aa:	58 08       	cp.w	r8,0
800097ac:	c0 c0       	breq	800097c4 <__call_exitprocs+0xc0>
800097ae:	89 08       	st.w	r4[0x0],r8
800097b0:	58 06       	cp.w	r6,0
800097b2:	c0 40       	breq	800097ba <__call_exitprocs+0xb6>
800097b4:	0c 9c       	mov	r12,r6
800097b6:	fe b0 e8 b9 	rcall	80006928 <free>
800097ba:	0e 9c       	mov	r12,r7
800097bc:	fe b0 e8 b6 	rcall	80006928 <free>
800097c0:	68 07       	ld.w	r7,r4[0x0]
800097c2:	c0 38       	rjmp	800097c8 <__call_exitprocs+0xc4>
800097c4:	0e 94       	mov	r4,r7
800097c6:	6e 07       	ld.w	r7,r7[0x0]
800097c8:	58 07       	cp.w	r7,0
800097ca:	ca b1       	brne	80009720 <__call_exitprocs+0x1c>
800097cc:	2f dd       	sub	sp,-12
800097ce:	d8 32       	popm	r0-r7,pc

800097d0 <quorem>:
800097d0:	d4 31       	pushm	r0-r7,lr
800097d2:	20 2d       	sub	sp,8
800097d4:	18 97       	mov	r7,r12
800097d6:	78 48       	ld.w	r8,r12[0x10]
800097d8:	76 46       	ld.w	r6,r11[0x10]
800097da:	0c 38       	cp.w	r8,r6
800097dc:	c0 34       	brge	800097e2 <quorem+0x12>
800097de:	30 0c       	mov	r12,0
800097e0:	c8 58       	rjmp	800098ea <quorem+0x11a>
800097e2:	ec c2 ff fc 	sub	r2,r6,-4
800097e6:	f6 c3 ff ec 	sub	r3,r11,-20
800097ea:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
800097ee:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
800097f2:	2f f9       	sub	r9,-1
800097f4:	20 16       	sub	r6,1
800097f6:	f8 09 0d 08 	divu	r8,r12,r9
800097fa:	f6 02 00 22 	add	r2,r11,r2<<0x2
800097fe:	ee c4 ff ec 	sub	r4,r7,-20
80009802:	10 95       	mov	r5,r8
80009804:	58 08       	cp.w	r8,0
80009806:	c4 10       	breq	80009888 <quorem+0xb8>
80009808:	30 09       	mov	r9,0
8000980a:	06 9a       	mov	r10,r3
8000980c:	08 98       	mov	r8,r4
8000980e:	12 91       	mov	r1,r9
80009810:	50 0b       	stdsp	sp[0x0],r11
80009812:	70 0e       	ld.w	lr,r8[0x0]
80009814:	b1 8e       	lsr	lr,0x10
80009816:	50 1e       	stdsp	sp[0x4],lr
80009818:	15 0e       	ld.w	lr,r10++
8000981a:	fc 00 16 10 	lsr	r0,lr,0x10
8000981e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009822:	ea 0e 03 41 	mac	r1,r5,lr
80009826:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000982a:	b1 81       	lsr	r1,0x10
8000982c:	40 1b       	lddsp	r11,sp[0x4]
8000982e:	ea 00 02 40 	mul	r0,r5,r0
80009832:	e2 00 00 00 	add	r0,r1,r0
80009836:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000983a:	02 1b       	sub	r11,r1
8000983c:	50 1b       	stdsp	sp[0x4],r11
8000983e:	70 0b       	ld.w	r11,r8[0x0]
80009840:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009844:	02 09       	add	r9,r1
80009846:	f2 0e 01 0e 	sub	lr,r9,lr
8000984a:	b0 1e       	st.h	r8[0x2],lr
8000984c:	fc 09 14 10 	asr	r9,lr,0x10
80009850:	40 1e       	lddsp	lr,sp[0x4]
80009852:	fc 09 00 09 	add	r9,lr,r9
80009856:	b0 09       	st.h	r8[0x0],r9
80009858:	e0 01 16 10 	lsr	r1,r0,0x10
8000985c:	2f c8       	sub	r8,-4
8000985e:	b1 49       	asr	r9,0x10
80009860:	04 3a       	cp.w	r10,r2
80009862:	fe 98 ff d8 	brls	80009812 <quorem+0x42>
80009866:	40 0b       	lddsp	r11,sp[0x0]
80009868:	58 0c       	cp.w	r12,0
8000986a:	c0 f1       	brne	80009888 <quorem+0xb8>
8000986c:	ec c8 ff fb 	sub	r8,r6,-5
80009870:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009874:	c0 28       	rjmp	80009878 <quorem+0xa8>
80009876:	20 16       	sub	r6,1
80009878:	20 48       	sub	r8,4
8000987a:	08 38       	cp.w	r8,r4
8000987c:	e0 88 00 05 	brls	80009886 <quorem+0xb6>
80009880:	70 09       	ld.w	r9,r8[0x0]
80009882:	58 09       	cp.w	r9,0
80009884:	cf 90       	breq	80009876 <quorem+0xa6>
80009886:	8f 46       	st.w	r7[0x10],r6
80009888:	0e 9c       	mov	r12,r7
8000988a:	e0 a0 0a d2 	rcall	8000ae2e <__mcmp>
8000988e:	c2 d5       	brlt	800098e8 <quorem+0x118>
80009890:	2f f5       	sub	r5,-1
80009892:	08 98       	mov	r8,r4
80009894:	30 09       	mov	r9,0
80009896:	07 0b       	ld.w	r11,r3++
80009898:	f6 0a 16 10 	lsr	r10,r11,0x10
8000989c:	70 0c       	ld.w	r12,r8[0x0]
8000989e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
800098a2:	f8 0e 16 10 	lsr	lr,r12,0x10
800098a6:	14 1e       	sub	lr,r10
800098a8:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
800098ac:	16 1a       	sub	r10,r11
800098ae:	12 0a       	add	r10,r9
800098b0:	b0 1a       	st.h	r8[0x2],r10
800098b2:	b1 4a       	asr	r10,0x10
800098b4:	fc 0a 00 09 	add	r9,lr,r10
800098b8:	b0 09       	st.h	r8[0x0],r9
800098ba:	2f c8       	sub	r8,-4
800098bc:	b1 49       	asr	r9,0x10
800098be:	04 33       	cp.w	r3,r2
800098c0:	fe 98 ff eb 	brls	80009896 <quorem+0xc6>
800098c4:	ec c8 ff fb 	sub	r8,r6,-5
800098c8:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
800098cc:	58 09       	cp.w	r9,0
800098ce:	c0 d1       	brne	800098e8 <quorem+0x118>
800098d0:	ee 08 00 28 	add	r8,r7,r8<<0x2
800098d4:	c0 28       	rjmp	800098d8 <quorem+0x108>
800098d6:	20 16       	sub	r6,1
800098d8:	20 48       	sub	r8,4
800098da:	08 38       	cp.w	r8,r4
800098dc:	e0 88 00 05 	brls	800098e6 <quorem+0x116>
800098e0:	70 09       	ld.w	r9,r8[0x0]
800098e2:	58 09       	cp.w	r9,0
800098e4:	cf 90       	breq	800098d6 <quorem+0x106>
800098e6:	8f 46       	st.w	r7[0x10],r6
800098e8:	0a 9c       	mov	r12,r5
800098ea:	2f ed       	sub	sp,-8
800098ec:	d8 32       	popm	r0-r7,pc
800098ee:	d7 03       	nop

800098f0 <_dtoa_r>:
800098f0:	d4 31       	pushm	r0-r7,lr
800098f2:	21 ad       	sub	sp,104
800098f4:	fa c4 ff 74 	sub	r4,sp,-140
800098f8:	18 97       	mov	r7,r12
800098fa:	16 95       	mov	r5,r11
800098fc:	68 2c       	ld.w	r12,r4[0x8]
800098fe:	50 c9       	stdsp	sp[0x30],r9
80009900:	68 16       	ld.w	r6,r4[0x4]
80009902:	68 09       	ld.w	r9,r4[0x0]
80009904:	50 e8       	stdsp	sp[0x38],r8
80009906:	14 94       	mov	r4,r10
80009908:	51 2c       	stdsp	sp[0x48],r12
8000990a:	fa e5 00 08 	st.d	sp[8],r4
8000990e:	51 59       	stdsp	sp[0x54],r9
80009910:	6e 95       	ld.w	r5,r7[0x24]
80009912:	58 05       	cp.w	r5,0
80009914:	c0 91       	brne	80009926 <_dtoa_r+0x36>
80009916:	31 0c       	mov	r12,16
80009918:	fe b0 e8 10 	rcall	80006938 <malloc>
8000991c:	99 35       	st.w	r12[0xc],r5
8000991e:	8f 9c       	st.w	r7[0x24],r12
80009920:	99 15       	st.w	r12[0x4],r5
80009922:	99 25       	st.w	r12[0x8],r5
80009924:	99 05       	st.w	r12[0x0],r5
80009926:	6e 99       	ld.w	r9,r7[0x24]
80009928:	72 08       	ld.w	r8,r9[0x0]
8000992a:	58 08       	cp.w	r8,0
8000992c:	c0 f0       	breq	8000994a <_dtoa_r+0x5a>
8000992e:	72 1a       	ld.w	r10,r9[0x4]
80009930:	91 1a       	st.w	r8[0x4],r10
80009932:	30 1a       	mov	r10,1
80009934:	72 19       	ld.w	r9,r9[0x4]
80009936:	f4 09 09 49 	lsl	r9,r10,r9
8000993a:	10 9b       	mov	r11,r8
8000993c:	91 29       	st.w	r8[0x8],r9
8000993e:	0e 9c       	mov	r12,r7
80009940:	e0 a0 0a 90 	rcall	8000ae60 <_Bfree>
80009944:	6e 98       	ld.w	r8,r7[0x24]
80009946:	30 09       	mov	r9,0
80009948:	91 09       	st.w	r8[0x0],r9
8000994a:	40 28       	lddsp	r8,sp[0x8]
8000994c:	10 94       	mov	r4,r8
8000994e:	58 08       	cp.w	r8,0
80009950:	c0 64       	brge	8000995c <_dtoa_r+0x6c>
80009952:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009956:	50 28       	stdsp	sp[0x8],r8
80009958:	30 18       	mov	r8,1
8000995a:	c0 28       	rjmp	8000995e <_dtoa_r+0x6e>
8000995c:	30 08       	mov	r8,0
8000995e:	8d 08       	st.w	r6[0x0],r8
80009960:	fc 1c 7f f0 	movh	r12,0x7ff0
80009964:	40 26       	lddsp	r6,sp[0x8]
80009966:	0c 98       	mov	r8,r6
80009968:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000996c:	18 38       	cp.w	r8,r12
8000996e:	c2 01       	brne	800099ae <_dtoa_r+0xbe>
80009970:	e0 68 27 0f 	mov	r8,9999
80009974:	41 5b       	lddsp	r11,sp[0x54]
80009976:	97 08       	st.w	r11[0x0],r8
80009978:	40 3a       	lddsp	r10,sp[0xc]
8000997a:	58 0a       	cp.w	r10,0
8000997c:	c0 71       	brne	8000998a <_dtoa_r+0x9a>
8000997e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009982:	c0 41       	brne	8000998a <_dtoa_r+0x9a>
80009984:	fe cc d0 78 	sub	r12,pc,-12168
80009988:	c0 38       	rjmp	8000998e <_dtoa_r+0x9e>
8000998a:	fe cc d0 72 	sub	r12,pc,-12174
8000998e:	41 29       	lddsp	r9,sp[0x48]
80009990:	58 09       	cp.w	r9,0
80009992:	e0 80 05 9a 	breq	8000a4c6 <_dtoa_r+0xbd6>
80009996:	f8 c8 ff fd 	sub	r8,r12,-3
8000999a:	f8 c9 ff f8 	sub	r9,r12,-8
8000999e:	11 8b       	ld.ub	r11,r8[0x0]
800099a0:	30 0a       	mov	r10,0
800099a2:	41 25       	lddsp	r5,sp[0x48]
800099a4:	f4 0b 18 00 	cp.b	r11,r10
800099a8:	f2 08 17 10 	movne	r8,r9
800099ac:	c1 68       	rjmp	800099d8 <_dtoa_r+0xe8>
800099ae:	fa ea 00 08 	ld.d	r10,sp[8]
800099b2:	30 08       	mov	r8,0
800099b4:	fa eb 00 3c 	st.d	sp[60],r10
800099b8:	30 09       	mov	r9,0
800099ba:	e0 a0 10 ce 	rcall	8000bb56 <__avr32_f64_cmp_eq>
800099be:	c1 00       	breq	800099de <_dtoa_r+0xee>
800099c0:	30 18       	mov	r8,1
800099c2:	41 5a       	lddsp	r10,sp[0x54]
800099c4:	95 08       	st.w	r10[0x0],r8
800099c6:	fe cc d1 de 	sub	r12,pc,-11810
800099ca:	41 29       	lddsp	r9,sp[0x48]
800099cc:	f8 08 00 08 	add	r8,r12,r8
800099d0:	58 09       	cp.w	r9,0
800099d2:	e0 80 05 7a 	breq	8000a4c6 <_dtoa_r+0xbd6>
800099d6:	12 95       	mov	r5,r9
800099d8:	8b 08       	st.w	r5[0x0],r8
800099da:	e0 8f 05 76 	bral	8000a4c6 <_dtoa_r+0xbd6>
800099de:	fa c8 ff 9c 	sub	r8,sp,-100
800099e2:	fa c9 ff a0 	sub	r9,sp,-96
800099e6:	fa ea 00 3c 	ld.d	r10,sp[60]
800099ea:	0e 9c       	mov	r12,r7
800099ec:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
800099f0:	e0 a0 0a 8a 	rcall	8000af04 <__d2b>
800099f4:	18 93       	mov	r3,r12
800099f6:	58 05       	cp.w	r5,0
800099f8:	c0 d0       	breq	80009a12 <_dtoa_r+0x122>
800099fa:	fa ea 00 3c 	ld.d	r10,sp[60]
800099fe:	30 04       	mov	r4,0
80009a00:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009a04:	ea c5 03 ff 	sub	r5,r5,1023
80009a08:	10 9b       	mov	r11,r8
80009a0a:	51 74       	stdsp	sp[0x5c],r4
80009a0c:	ea 1b 3f f0 	orh	r11,0x3ff0
80009a10:	c2 58       	rjmp	80009a5a <_dtoa_r+0x16a>
80009a12:	41 88       	lddsp	r8,sp[0x60]
80009a14:	41 9c       	lddsp	r12,sp[0x64]
80009a16:	10 0c       	add	r12,r8
80009a18:	f8 c5 fb ce 	sub	r5,r12,-1074
80009a1c:	e0 45 00 20 	cp.w	r5,32
80009a20:	e0 8a 00 0e 	brle	80009a3c <_dtoa_r+0x14c>
80009a24:	f8 cc fb ee 	sub	r12,r12,-1042
80009a28:	40 3b       	lddsp	r11,sp[0xc]
80009a2a:	ea 08 11 40 	rsub	r8,r5,64
80009a2e:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009a32:	ec 08 09 46 	lsl	r6,r6,r8
80009a36:	0c 4c       	or	r12,r6
80009a38:	c0 78       	rjmp	80009a46 <_dtoa_r+0x156>
80009a3a:	d7 03       	nop
80009a3c:	ea 0c 11 20 	rsub	r12,r5,32
80009a40:	40 3a       	lddsp	r10,sp[0xc]
80009a42:	f4 0c 09 4c 	lsl	r12,r10,r12
80009a46:	e0 a0 10 14 	rcall	8000ba6e <__avr32_u32_to_f64>
80009a4a:	fc 18 fe 10 	movh	r8,0xfe10
80009a4e:	30 19       	mov	r9,1
80009a50:	ea c5 04 33 	sub	r5,r5,1075
80009a54:	f0 0b 00 0b 	add	r11,r8,r11
80009a58:	51 79       	stdsp	sp[0x5c],r9
80009a5a:	30 08       	mov	r8,0
80009a5c:	fc 19 3f f8 	movh	r9,0x3ff8
80009a60:	e0 a0 0e 9c 	rcall	8000b798 <__avr32_f64_sub>
80009a64:	e0 68 43 61 	mov	r8,17249
80009a68:	ea 18 63 6f 	orh	r8,0x636f
80009a6c:	e0 69 87 a7 	mov	r9,34727
80009a70:	ea 19 3f d2 	orh	r9,0x3fd2
80009a74:	e0 a0 0d a6 	rcall	8000b5c0 <__avr32_f64_mul>
80009a78:	e0 68 c8 b3 	mov	r8,51379
80009a7c:	ea 18 8b 60 	orh	r8,0x8b60
80009a80:	e0 69 8a 28 	mov	r9,35368
80009a84:	ea 19 3f c6 	orh	r9,0x3fc6
80009a88:	e0 a0 0f 56 	rcall	8000b934 <__avr32_f64_add>
80009a8c:	0a 9c       	mov	r12,r5
80009a8e:	14 90       	mov	r0,r10
80009a90:	16 91       	mov	r1,r11
80009a92:	e0 a0 0f f2 	rcall	8000ba76 <__avr32_s32_to_f64>
80009a96:	e0 68 79 fb 	mov	r8,31227
80009a9a:	ea 18 50 9f 	orh	r8,0x509f
80009a9e:	e0 69 44 13 	mov	r9,17427
80009aa2:	ea 19 3f d3 	orh	r9,0x3fd3
80009aa6:	e0 a0 0d 8d 	rcall	8000b5c0 <__avr32_f64_mul>
80009aaa:	14 98       	mov	r8,r10
80009aac:	16 99       	mov	r9,r11
80009aae:	00 9a       	mov	r10,r0
80009ab0:	02 9b       	mov	r11,r1
80009ab2:	e0 a0 0f 41 	rcall	8000b934 <__avr32_f64_add>
80009ab6:	14 90       	mov	r0,r10
80009ab8:	16 91       	mov	r1,r11
80009aba:	e0 a0 0f c7 	rcall	8000ba48 <__avr32_f64_to_s32>
80009abe:	30 08       	mov	r8,0
80009ac0:	18 96       	mov	r6,r12
80009ac2:	30 09       	mov	r9,0
80009ac4:	00 9a       	mov	r10,r0
80009ac6:	02 9b       	mov	r11,r1
80009ac8:	e0 a0 10 8e 	rcall	8000bbe4 <__avr32_f64_cmp_lt>
80009acc:	c0 c0       	breq	80009ae4 <_dtoa_r+0x1f4>
80009ace:	0c 9c       	mov	r12,r6
80009ad0:	e0 a0 0f d3 	rcall	8000ba76 <__avr32_s32_to_f64>
80009ad4:	14 98       	mov	r8,r10
80009ad6:	16 99       	mov	r9,r11
80009ad8:	00 9a       	mov	r10,r0
80009ada:	02 9b       	mov	r11,r1
80009adc:	e0 a0 10 3d 	rcall	8000bb56 <__avr32_f64_cmp_eq>
80009ae0:	f7 b6 00 01 	subeq	r6,1
80009ae4:	59 66       	cp.w	r6,22
80009ae6:	e0 88 00 05 	brls	80009af0 <_dtoa_r+0x200>
80009aea:	30 18       	mov	r8,1
80009aec:	51 48       	stdsp	sp[0x50],r8
80009aee:	c1 38       	rjmp	80009b14 <_dtoa_r+0x224>
80009af0:	fe c8 d1 28 	sub	r8,pc,-11992
80009af4:	fa ea 00 3c 	ld.d	r10,sp[60]
80009af8:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009afc:	e0 a0 10 74 	rcall	8000bbe4 <__avr32_f64_cmp_lt>
80009b00:	f9 b4 00 00 	moveq	r4,0
80009b04:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009b08:	f7 b6 01 01 	subne	r6,1
80009b0c:	f9 bc 01 00 	movne	r12,0
80009b10:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009b14:	41 90       	lddsp	r0,sp[0x64]
80009b16:	20 10       	sub	r0,1
80009b18:	0a 10       	sub	r0,r5
80009b1a:	c0 46       	brmi	80009b22 <_dtoa_r+0x232>
80009b1c:	50 40       	stdsp	sp[0x10],r0
80009b1e:	30 00       	mov	r0,0
80009b20:	c0 48       	rjmp	80009b28 <_dtoa_r+0x238>
80009b22:	30 0b       	mov	r11,0
80009b24:	5c 30       	neg	r0
80009b26:	50 4b       	stdsp	sp[0x10],r11
80009b28:	ec 02 11 00 	rsub	r2,r6,0
80009b2c:	58 06       	cp.w	r6,0
80009b2e:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009b32:	f5 d6 e4 0a 	addge	r10,r10,r6
80009b36:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009b3a:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009b3e:	f9 b2 04 00 	movge	r2,0
80009b42:	e1 d6 e5 10 	sublt	r0,r0,r6
80009b46:	f9 b9 05 00 	movlt	r9,0
80009b4a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009b4e:	40 c8       	lddsp	r8,sp[0x30]
80009b50:	58 98       	cp.w	r8,9
80009b52:	e0 8b 00 20 	brhi	80009b92 <_dtoa_r+0x2a2>
80009b56:	58 58       	cp.w	r8,5
80009b58:	f9 b4 0a 01 	movle	r4,1
80009b5c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009b60:	f7 b5 09 04 	subgt	r5,4
80009b64:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009b68:	f9 b4 09 00 	movgt	r4,0
80009b6c:	40 cc       	lddsp	r12,sp[0x30]
80009b6e:	58 3c       	cp.w	r12,3
80009b70:	c2 d0       	breq	80009bca <_dtoa_r+0x2da>
80009b72:	e0 89 00 05 	brgt	80009b7c <_dtoa_r+0x28c>
80009b76:	58 2c       	cp.w	r12,2
80009b78:	c1 01       	brne	80009b98 <_dtoa_r+0x2a8>
80009b7a:	c1 88       	rjmp	80009baa <_dtoa_r+0x2ba>
80009b7c:	40 cb       	lddsp	r11,sp[0x30]
80009b7e:	58 4b       	cp.w	r11,4
80009b80:	c0 60       	breq	80009b8c <_dtoa_r+0x29c>
80009b82:	58 5b       	cp.w	r11,5
80009b84:	c0 a1       	brne	80009b98 <_dtoa_r+0x2a8>
80009b86:	30 1a       	mov	r10,1
80009b88:	50 da       	stdsp	sp[0x34],r10
80009b8a:	c2 28       	rjmp	80009bce <_dtoa_r+0x2de>
80009b8c:	30 19       	mov	r9,1
80009b8e:	50 d9       	stdsp	sp[0x34],r9
80009b90:	c0 f8       	rjmp	80009bae <_dtoa_r+0x2be>
80009b92:	30 08       	mov	r8,0
80009b94:	30 14       	mov	r4,1
80009b96:	50 c8       	stdsp	sp[0x30],r8
80009b98:	3f f5       	mov	r5,-1
80009b9a:	30 1c       	mov	r12,1
80009b9c:	30 0b       	mov	r11,0
80009b9e:	50 95       	stdsp	sp[0x24],r5
80009ba0:	50 dc       	stdsp	sp[0x34],r12
80009ba2:	0a 91       	mov	r1,r5
80009ba4:	31 28       	mov	r8,18
80009ba6:	50 eb       	stdsp	sp[0x38],r11
80009ba8:	c2 08       	rjmp	80009be8 <_dtoa_r+0x2f8>
80009baa:	30 0a       	mov	r10,0
80009bac:	50 da       	stdsp	sp[0x34],r10
80009bae:	40 e9       	lddsp	r9,sp[0x38]
80009bb0:	58 09       	cp.w	r9,0
80009bb2:	e0 89 00 07 	brgt	80009bc0 <_dtoa_r+0x2d0>
80009bb6:	30 18       	mov	r8,1
80009bb8:	50 98       	stdsp	sp[0x24],r8
80009bba:	10 91       	mov	r1,r8
80009bbc:	50 e8       	stdsp	sp[0x38],r8
80009bbe:	c1 58       	rjmp	80009be8 <_dtoa_r+0x2f8>
80009bc0:	40 e5       	lddsp	r5,sp[0x38]
80009bc2:	50 95       	stdsp	sp[0x24],r5
80009bc4:	0a 91       	mov	r1,r5
80009bc6:	0a 98       	mov	r8,r5
80009bc8:	c1 08       	rjmp	80009be8 <_dtoa_r+0x2f8>
80009bca:	30 0c       	mov	r12,0
80009bcc:	50 dc       	stdsp	sp[0x34],r12
80009bce:	40 eb       	lddsp	r11,sp[0x38]
80009bd0:	ec 0b 00 0b 	add	r11,r6,r11
80009bd4:	50 9b       	stdsp	sp[0x24],r11
80009bd6:	16 98       	mov	r8,r11
80009bd8:	2f f8       	sub	r8,-1
80009bda:	58 08       	cp.w	r8,0
80009bdc:	e0 89 00 05 	brgt	80009be6 <_dtoa_r+0x2f6>
80009be0:	10 91       	mov	r1,r8
80009be2:	30 18       	mov	r8,1
80009be4:	c0 28       	rjmp	80009be8 <_dtoa_r+0x2f8>
80009be6:	10 91       	mov	r1,r8
80009be8:	30 09       	mov	r9,0
80009bea:	6e 9a       	ld.w	r10,r7[0x24]
80009bec:	95 19       	st.w	r10[0x4],r9
80009bee:	30 49       	mov	r9,4
80009bf0:	c0 68       	rjmp	80009bfc <_dtoa_r+0x30c>
80009bf2:	d7 03       	nop
80009bf4:	6a 1a       	ld.w	r10,r5[0x4]
80009bf6:	a1 79       	lsl	r9,0x1
80009bf8:	2f fa       	sub	r10,-1
80009bfa:	8b 1a       	st.w	r5[0x4],r10
80009bfc:	6e 95       	ld.w	r5,r7[0x24]
80009bfe:	f2 ca ff ec 	sub	r10,r9,-20
80009c02:	10 3a       	cp.w	r10,r8
80009c04:	fe 98 ff f8 	brls	80009bf4 <_dtoa_r+0x304>
80009c08:	6a 1b       	ld.w	r11,r5[0x4]
80009c0a:	0e 9c       	mov	r12,r7
80009c0c:	e0 a0 09 44 	rcall	8000ae94 <_Balloc>
80009c10:	58 e1       	cp.w	r1,14
80009c12:	5f 88       	srls	r8
80009c14:	8b 0c       	st.w	r5[0x0],r12
80009c16:	f1 e4 00 04 	and	r4,r8,r4
80009c1a:	6e 98       	ld.w	r8,r7[0x24]
80009c1c:	70 08       	ld.w	r8,r8[0x0]
80009c1e:	50 88       	stdsp	sp[0x20],r8
80009c20:	e0 80 01 82 	breq	80009f24 <_dtoa_r+0x634>
80009c24:	58 06       	cp.w	r6,0
80009c26:	e0 8a 00 43 	brle	80009cac <_dtoa_r+0x3bc>
80009c2a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009c2e:	fe c8 d2 66 	sub	r8,pc,-11674
80009c32:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009c36:	fa e5 00 18 	st.d	sp[24],r4
80009c3a:	ec 04 14 04 	asr	r4,r6,0x4
80009c3e:	ed b4 00 04 	bld	r4,0x4
80009c42:	c0 30       	breq	80009c48 <_dtoa_r+0x358>
80009c44:	30 25       	mov	r5,2
80009c46:	c1 08       	rjmp	80009c66 <_dtoa_r+0x376>
80009c48:	fe c8 d1 b8 	sub	r8,pc,-11848
80009c4c:	f0 e8 00 20 	ld.d	r8,r8[32]
80009c50:	fa ea 00 3c 	ld.d	r10,sp[60]
80009c54:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009c58:	e0 a0 0f fa 	rcall	8000bc4c <__avr32_f64_div>
80009c5c:	30 35       	mov	r5,3
80009c5e:	14 98       	mov	r8,r10
80009c60:	16 99       	mov	r9,r11
80009c62:	fa e9 00 08 	st.d	sp[8],r8
80009c66:	fe cc d1 d6 	sub	r12,pc,-11818
80009c6a:	50 a3       	stdsp	sp[0x28],r3
80009c6c:	0c 93       	mov	r3,r6
80009c6e:	18 96       	mov	r6,r12
80009c70:	c0 f8       	rjmp	80009c8e <_dtoa_r+0x39e>
80009c72:	fa ea 00 18 	ld.d	r10,sp[24]
80009c76:	ed b4 00 00 	bld	r4,0x0
80009c7a:	c0 81       	brne	80009c8a <_dtoa_r+0x39a>
80009c7c:	ec e8 00 00 	ld.d	r8,r6[0]
80009c80:	2f f5       	sub	r5,-1
80009c82:	e0 a0 0c 9f 	rcall	8000b5c0 <__avr32_f64_mul>
80009c86:	fa eb 00 18 	st.d	sp[24],r10
80009c8a:	a1 54       	asr	r4,0x1
80009c8c:	2f 86       	sub	r6,-8
80009c8e:	58 04       	cp.w	r4,0
80009c90:	cf 11       	brne	80009c72 <_dtoa_r+0x382>
80009c92:	fa e8 00 18 	ld.d	r8,sp[24]
80009c96:	fa ea 00 08 	ld.d	r10,sp[8]
80009c9a:	06 96       	mov	r6,r3
80009c9c:	e0 a0 0f d8 	rcall	8000bc4c <__avr32_f64_div>
80009ca0:	40 a3       	lddsp	r3,sp[0x28]
80009ca2:	14 98       	mov	r8,r10
80009ca4:	16 99       	mov	r9,r11
80009ca6:	fa e9 00 08 	st.d	sp[8],r8
80009caa:	c2 f8       	rjmp	80009d08 <_dtoa_r+0x418>
80009cac:	ec 08 11 00 	rsub	r8,r6,0
80009cb0:	c0 31       	brne	80009cb6 <_dtoa_r+0x3c6>
80009cb2:	30 25       	mov	r5,2
80009cb4:	c2 a8       	rjmp	80009d08 <_dtoa_r+0x418>
80009cb6:	fe cc d2 26 	sub	r12,pc,-11738
80009cba:	f0 04 14 04 	asr	r4,r8,0x4
80009cbe:	50 1c       	stdsp	sp[0x4],r12
80009cc0:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009cc4:	fe c9 d2 fc 	sub	r9,pc,-11524
80009cc8:	fa ea 00 3c 	ld.d	r10,sp[60]
80009ccc:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009cd0:	e0 a0 0c 78 	rcall	8000b5c0 <__avr32_f64_mul>
80009cd4:	40 1c       	lddsp	r12,sp[0x4]
80009cd6:	50 63       	stdsp	sp[0x18],r3
80009cd8:	30 25       	mov	r5,2
80009cda:	0c 93       	mov	r3,r6
80009cdc:	fa eb 00 08 	st.d	sp[8],r10
80009ce0:	18 96       	mov	r6,r12
80009ce2:	c0 f8       	rjmp	80009d00 <_dtoa_r+0x410>
80009ce4:	fa ea 00 08 	ld.d	r10,sp[8]
80009ce8:	ed b4 00 00 	bld	r4,0x0
80009cec:	c0 81       	brne	80009cfc <_dtoa_r+0x40c>
80009cee:	ec e8 00 00 	ld.d	r8,r6[0]
80009cf2:	2f f5       	sub	r5,-1
80009cf4:	e0 a0 0c 66 	rcall	8000b5c0 <__avr32_f64_mul>
80009cf8:	fa eb 00 08 	st.d	sp[8],r10
80009cfc:	a1 54       	asr	r4,0x1
80009cfe:	2f 86       	sub	r6,-8
80009d00:	58 04       	cp.w	r4,0
80009d02:	cf 11       	brne	80009ce4 <_dtoa_r+0x3f4>
80009d04:	06 96       	mov	r6,r3
80009d06:	40 63       	lddsp	r3,sp[0x18]
80009d08:	41 4a       	lddsp	r10,sp[0x50]
80009d0a:	58 0a       	cp.w	r10,0
80009d0c:	c2 a0       	breq	80009d60 <_dtoa_r+0x470>
80009d0e:	fa e8 00 08 	ld.d	r8,sp[8]
80009d12:	58 01       	cp.w	r1,0
80009d14:	5f 94       	srgt	r4
80009d16:	fa e9 00 18 	st.d	sp[24],r8
80009d1a:	30 08       	mov	r8,0
80009d1c:	fc 19 3f f0 	movh	r9,0x3ff0
80009d20:	fa ea 00 18 	ld.d	r10,sp[24]
80009d24:	e0 a0 0f 60 	rcall	8000bbe4 <__avr32_f64_cmp_lt>
80009d28:	f9 bc 00 00 	moveq	r12,0
80009d2c:	f9 bc 01 01 	movne	r12,1
80009d30:	e9 ec 00 0c 	and	r12,r4,r12
80009d34:	c1 60       	breq	80009d60 <_dtoa_r+0x470>
80009d36:	40 98       	lddsp	r8,sp[0x24]
80009d38:	58 08       	cp.w	r8,0
80009d3a:	e0 8a 00 f1 	brle	80009f1c <_dtoa_r+0x62c>
80009d3e:	30 08       	mov	r8,0
80009d40:	fc 19 40 24 	movh	r9,0x4024
80009d44:	ec c4 00 01 	sub	r4,r6,1
80009d48:	fa ea 00 18 	ld.d	r10,sp[24]
80009d4c:	2f f5       	sub	r5,-1
80009d4e:	50 64       	stdsp	sp[0x18],r4
80009d50:	e0 a0 0c 38 	rcall	8000b5c0 <__avr32_f64_mul>
80009d54:	40 94       	lddsp	r4,sp[0x24]
80009d56:	14 98       	mov	r8,r10
80009d58:	16 99       	mov	r9,r11
80009d5a:	fa e9 00 08 	st.d	sp[8],r8
80009d5e:	c0 38       	rjmp	80009d64 <_dtoa_r+0x474>
80009d60:	50 66       	stdsp	sp[0x18],r6
80009d62:	02 94       	mov	r4,r1
80009d64:	0a 9c       	mov	r12,r5
80009d66:	e0 a0 0e 88 	rcall	8000ba76 <__avr32_s32_to_f64>
80009d6a:	fa e8 00 08 	ld.d	r8,sp[8]
80009d6e:	e0 a0 0c 29 	rcall	8000b5c0 <__avr32_f64_mul>
80009d72:	30 08       	mov	r8,0
80009d74:	fc 19 40 1c 	movh	r9,0x401c
80009d78:	e0 a0 0d de 	rcall	8000b934 <__avr32_f64_add>
80009d7c:	14 98       	mov	r8,r10
80009d7e:	16 99       	mov	r9,r11
80009d80:	fa e9 00 28 	st.d	sp[40],r8
80009d84:	fc 18 fc c0 	movh	r8,0xfcc0
80009d88:	40 a5       	lddsp	r5,sp[0x28]
80009d8a:	10 05       	add	r5,r8
80009d8c:	50 a5       	stdsp	sp[0x28],r5
80009d8e:	58 04       	cp.w	r4,0
80009d90:	c2 11       	brne	80009dd2 <_dtoa_r+0x4e2>
80009d92:	fa ea 00 08 	ld.d	r10,sp[8]
80009d96:	30 08       	mov	r8,0
80009d98:	fc 19 40 14 	movh	r9,0x4014
80009d9c:	e0 a0 0c fe 	rcall	8000b798 <__avr32_f64_sub>
80009da0:	40 bc       	lddsp	r12,sp[0x2c]
80009da2:	fa eb 00 08 	st.d	sp[8],r10
80009da6:	14 98       	mov	r8,r10
80009da8:	16 99       	mov	r9,r11
80009daa:	18 9a       	mov	r10,r12
80009dac:	0a 9b       	mov	r11,r5
80009dae:	e0 a0 0f 1b 	rcall	8000bbe4 <__avr32_f64_cmp_lt>
80009db2:	e0 81 02 54 	brne	8000a25a <_dtoa_r+0x96a>
80009db6:	0a 98       	mov	r8,r5
80009db8:	40 b9       	lddsp	r9,sp[0x2c]
80009dba:	ee 18 80 00 	eorh	r8,0x8000
80009dbe:	fa ea 00 08 	ld.d	r10,sp[8]
80009dc2:	10 95       	mov	r5,r8
80009dc4:	12 98       	mov	r8,r9
80009dc6:	0a 99       	mov	r9,r5
80009dc8:	e0 a0 0f 0e 	rcall	8000bbe4 <__avr32_f64_cmp_lt>
80009dcc:	e0 81 02 3e 	brne	8000a248 <_dtoa_r+0x958>
80009dd0:	ca 68       	rjmp	80009f1c <_dtoa_r+0x62c>
80009dd2:	fe c9 d4 0a 	sub	r9,pc,-11254
80009dd6:	e8 c8 00 01 	sub	r8,r4,1
80009dda:	40 d5       	lddsp	r5,sp[0x34]
80009ddc:	58 05       	cp.w	r5,0
80009dde:	c4 f0       	breq	80009e7c <_dtoa_r+0x58c>
80009de0:	30 0c       	mov	r12,0
80009de2:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009de6:	51 3c       	stdsp	sp[0x4c],r12
80009de8:	30 0a       	mov	r10,0
80009dea:	fc 1b 3f e0 	movh	r11,0x3fe0
80009dee:	e0 a0 0f 2f 	rcall	8000bc4c <__avr32_f64_div>
80009df2:	fa e8 00 28 	ld.d	r8,sp[40]
80009df6:	40 85       	lddsp	r5,sp[0x20]
80009df8:	e0 a0 0c d0 	rcall	8000b798 <__avr32_f64_sub>
80009dfc:	fa eb 00 28 	st.d	sp[40],r10
80009e00:	fa ea 00 08 	ld.d	r10,sp[8]
80009e04:	e0 a0 0e 22 	rcall	8000ba48 <__avr32_f64_to_s32>
80009e08:	51 6c       	stdsp	sp[0x58],r12
80009e0a:	e0 a0 0e 36 	rcall	8000ba76 <__avr32_s32_to_f64>
80009e0e:	14 98       	mov	r8,r10
80009e10:	16 99       	mov	r9,r11
80009e12:	fa ea 00 08 	ld.d	r10,sp[8]
80009e16:	e0 a0 0c c1 	rcall	8000b798 <__avr32_f64_sub>
80009e1a:	fa eb 00 08 	st.d	sp[8],r10
80009e1e:	41 68       	lddsp	r8,sp[0x58]
80009e20:	2d 08       	sub	r8,-48
80009e22:	0a c8       	st.b	r5++,r8
80009e24:	41 39       	lddsp	r9,sp[0x4c]
80009e26:	2f f9       	sub	r9,-1
80009e28:	51 39       	stdsp	sp[0x4c],r9
80009e2a:	fa e8 00 28 	ld.d	r8,sp[40]
80009e2e:	e0 a0 0e db 	rcall	8000bbe4 <__avr32_f64_cmp_lt>
80009e32:	e0 81 03 39 	brne	8000a4a4 <_dtoa_r+0xbb4>
80009e36:	fa e8 00 08 	ld.d	r8,sp[8]
80009e3a:	30 0a       	mov	r10,0
80009e3c:	fc 1b 3f f0 	movh	r11,0x3ff0
80009e40:	e0 a0 0c ac 	rcall	8000b798 <__avr32_f64_sub>
80009e44:	fa e8 00 28 	ld.d	r8,sp[40]
80009e48:	e0 a0 0e ce 	rcall	8000bbe4 <__avr32_f64_cmp_lt>
80009e4c:	fa ea 00 28 	ld.d	r10,sp[40]
80009e50:	30 08       	mov	r8,0
80009e52:	fc 19 40 24 	movh	r9,0x4024
80009e56:	e0 81 00 da 	brne	8000a00a <_dtoa_r+0x71a>
80009e5a:	41 3c       	lddsp	r12,sp[0x4c]
80009e5c:	08 3c       	cp.w	r12,r4
80009e5e:	c5 f4       	brge	80009f1c <_dtoa_r+0x62c>
80009e60:	e0 a0 0b b0 	rcall	8000b5c0 <__avr32_f64_mul>
80009e64:	30 08       	mov	r8,0
80009e66:	fa eb 00 28 	st.d	sp[40],r10
80009e6a:	fc 19 40 24 	movh	r9,0x4024
80009e6e:	fa ea 00 08 	ld.d	r10,sp[8]
80009e72:	e0 a0 0b a7 	rcall	8000b5c0 <__avr32_f64_mul>
80009e76:	fa eb 00 08 	st.d	sp[8],r10
80009e7a:	cc 3b       	rjmp	80009e00 <_dtoa_r+0x510>
80009e7c:	40 85       	lddsp	r5,sp[0x20]
80009e7e:	08 05       	add	r5,r4
80009e80:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009e84:	51 35       	stdsp	sp[0x4c],r5
80009e86:	fa e8 00 28 	ld.d	r8,sp[40]
80009e8a:	40 85       	lddsp	r5,sp[0x20]
80009e8c:	e0 a0 0b 9a 	rcall	8000b5c0 <__avr32_f64_mul>
80009e90:	fa eb 00 28 	st.d	sp[40],r10
80009e94:	fa ea 00 08 	ld.d	r10,sp[8]
80009e98:	e0 a0 0d d8 	rcall	8000ba48 <__avr32_f64_to_s32>
80009e9c:	51 6c       	stdsp	sp[0x58],r12
80009e9e:	e0 a0 0d ec 	rcall	8000ba76 <__avr32_s32_to_f64>
80009ea2:	14 98       	mov	r8,r10
80009ea4:	16 99       	mov	r9,r11
80009ea6:	fa ea 00 08 	ld.d	r10,sp[8]
80009eaa:	e0 a0 0c 77 	rcall	8000b798 <__avr32_f64_sub>
80009eae:	fa eb 00 08 	st.d	sp[8],r10
80009eb2:	41 68       	lddsp	r8,sp[0x58]
80009eb4:	2d 08       	sub	r8,-48
80009eb6:	0a c8       	st.b	r5++,r8
80009eb8:	41 3c       	lddsp	r12,sp[0x4c]
80009eba:	18 35       	cp.w	r5,r12
80009ebc:	c2 81       	brne	80009f0c <_dtoa_r+0x61c>
80009ebe:	30 08       	mov	r8,0
80009ec0:	fc 19 3f e0 	movh	r9,0x3fe0
80009ec4:	fa ea 00 28 	ld.d	r10,sp[40]
80009ec8:	e0 a0 0d 36 	rcall	8000b934 <__avr32_f64_add>
80009ecc:	40 85       	lddsp	r5,sp[0x20]
80009ece:	fa e8 00 08 	ld.d	r8,sp[8]
80009ed2:	08 05       	add	r5,r4
80009ed4:	e0 a0 0e 88 	rcall	8000bbe4 <__avr32_f64_cmp_lt>
80009ed8:	e0 81 00 99 	brne	8000a00a <_dtoa_r+0x71a>
80009edc:	fa e8 00 28 	ld.d	r8,sp[40]
80009ee0:	30 0a       	mov	r10,0
80009ee2:	fc 1b 3f e0 	movh	r11,0x3fe0
80009ee6:	e0 a0 0c 59 	rcall	8000b798 <__avr32_f64_sub>
80009eea:	14 98       	mov	r8,r10
80009eec:	16 99       	mov	r9,r11
80009eee:	fa ea 00 08 	ld.d	r10,sp[8]
80009ef2:	e0 a0 0e 79 	rcall	8000bbe4 <__avr32_f64_cmp_lt>
80009ef6:	c1 30       	breq	80009f1c <_dtoa_r+0x62c>
80009ef8:	33 09       	mov	r9,48
80009efa:	0a 98       	mov	r8,r5
80009efc:	11 7a       	ld.ub	r10,--r8
80009efe:	f2 0a 18 00 	cp.b	r10,r9
80009f02:	e0 81 02 d1 	brne	8000a4a4 <_dtoa_r+0xbb4>
80009f06:	10 95       	mov	r5,r8
80009f08:	cf 9b       	rjmp	80009efa <_dtoa_r+0x60a>
80009f0a:	d7 03       	nop
80009f0c:	30 08       	mov	r8,0
80009f0e:	fc 19 40 24 	movh	r9,0x4024
80009f12:	e0 a0 0b 57 	rcall	8000b5c0 <__avr32_f64_mul>
80009f16:	fa eb 00 08 	st.d	sp[8],r10
80009f1a:	cb db       	rjmp	80009e94 <_dtoa_r+0x5a4>
80009f1c:	fa ea 00 3c 	ld.d	r10,sp[60]
80009f20:	fa eb 00 08 	st.d	sp[8],r10
80009f24:	58 e6       	cp.w	r6,14
80009f26:	5f ab       	srle	r11
80009f28:	41 8a       	lddsp	r10,sp[0x60]
80009f2a:	30 08       	mov	r8,0
80009f2c:	f4 09 11 ff 	rsub	r9,r10,-1
80009f30:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80009f34:	f0 09 18 00 	cp.b	r9,r8
80009f38:	e0 80 00 82 	breq	8000a03c <_dtoa_r+0x74c>
80009f3c:	40 ea       	lddsp	r10,sp[0x38]
80009f3e:	58 01       	cp.w	r1,0
80009f40:	5f a9       	srle	r9
80009f42:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80009f46:	fe ca d5 7e 	sub	r10,pc,-10882
80009f4a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80009f4e:	fa e5 00 10 	st.d	sp[16],r4
80009f52:	f0 09 18 00 	cp.b	r9,r8
80009f56:	c1 40       	breq	80009f7e <_dtoa_r+0x68e>
80009f58:	58 01       	cp.w	r1,0
80009f5a:	e0 81 01 77 	brne	8000a248 <_dtoa_r+0x958>
80009f5e:	30 08       	mov	r8,0
80009f60:	fc 19 40 14 	movh	r9,0x4014
80009f64:	08 9a       	mov	r10,r4
80009f66:	0a 9b       	mov	r11,r5
80009f68:	e0 a0 0b 2c 	rcall	8000b5c0 <__avr32_f64_mul>
80009f6c:	fa e8 00 08 	ld.d	r8,sp[8]
80009f70:	e0 a0 0e 06 	rcall	8000bb7c <__avr32_f64_cmp_ge>
80009f74:	e0 81 01 6a 	brne	8000a248 <_dtoa_r+0x958>
80009f78:	02 92       	mov	r2,r1
80009f7a:	e0 8f 01 72 	bral	8000a25e <_dtoa_r+0x96e>
80009f7e:	40 85       	lddsp	r5,sp[0x20]
80009f80:	30 14       	mov	r4,1
80009f82:	fa e8 00 10 	ld.d	r8,sp[16]
80009f86:	fa ea 00 08 	ld.d	r10,sp[8]
80009f8a:	e0 a0 0e 61 	rcall	8000bc4c <__avr32_f64_div>
80009f8e:	e0 a0 0d 5d 	rcall	8000ba48 <__avr32_f64_to_s32>
80009f92:	18 92       	mov	r2,r12
80009f94:	e0 a0 0d 71 	rcall	8000ba76 <__avr32_s32_to_f64>
80009f98:	fa e8 00 10 	ld.d	r8,sp[16]
80009f9c:	e0 a0 0b 12 	rcall	8000b5c0 <__avr32_f64_mul>
80009fa0:	14 98       	mov	r8,r10
80009fa2:	16 99       	mov	r9,r11
80009fa4:	fa ea 00 08 	ld.d	r10,sp[8]
80009fa8:	e0 a0 0b f8 	rcall	8000b798 <__avr32_f64_sub>
80009fac:	fa eb 00 08 	st.d	sp[8],r10
80009fb0:	e4 c8 ff d0 	sub	r8,r2,-48
80009fb4:	0a c8       	st.b	r5++,r8
80009fb6:	fc 19 40 24 	movh	r9,0x4024
80009fba:	30 08       	mov	r8,0
80009fbc:	02 34       	cp.w	r4,r1
80009fbe:	c3 31       	brne	8000a024 <_dtoa_r+0x734>
80009fc0:	fa e8 00 08 	ld.d	r8,sp[8]
80009fc4:	e0 a0 0c b8 	rcall	8000b934 <__avr32_f64_add>
80009fc8:	16 91       	mov	r1,r11
80009fca:	14 90       	mov	r0,r10
80009fcc:	14 98       	mov	r8,r10
80009fce:	02 99       	mov	r9,r1
80009fd0:	fa ea 00 10 	ld.d	r10,sp[16]
80009fd4:	e0 a0 0e 08 	rcall	8000bbe4 <__avr32_f64_cmp_lt>
80009fd8:	c1 a1       	brne	8000a00c <_dtoa_r+0x71c>
80009fda:	fa e8 00 10 	ld.d	r8,sp[16]
80009fde:	00 9a       	mov	r10,r0
80009fe0:	02 9b       	mov	r11,r1
80009fe2:	e0 a0 0d ba 	rcall	8000bb56 <__avr32_f64_cmp_eq>
80009fe6:	e0 80 02 5e 	breq	8000a4a2 <_dtoa_r+0xbb2>
80009fea:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80009fee:	c0 f1       	brne	8000a00c <_dtoa_r+0x71c>
80009ff0:	e0 8f 02 59 	bral	8000a4a2 <_dtoa_r+0xbb2>
80009ff4:	40 8a       	lddsp	r10,sp[0x20]
80009ff6:	14 38       	cp.w	r8,r10
80009ff8:	c0 30       	breq	80009ffe <_dtoa_r+0x70e>
80009ffa:	10 95       	mov	r5,r8
80009ffc:	c0 98       	rjmp	8000a00e <_dtoa_r+0x71e>
80009ffe:	33 08       	mov	r8,48
8000a000:	40 89       	lddsp	r9,sp[0x20]
8000a002:	2f f6       	sub	r6,-1
8000a004:	b2 88       	st.b	r9[0x0],r8
8000a006:	40 88       	lddsp	r8,sp[0x20]
8000a008:	c0 88       	rjmp	8000a018 <_dtoa_r+0x728>
8000a00a:	40 66       	lddsp	r6,sp[0x18]
8000a00c:	33 99       	mov	r9,57
8000a00e:	0a 98       	mov	r8,r5
8000a010:	11 7a       	ld.ub	r10,--r8
8000a012:	f2 0a 18 00 	cp.b	r10,r9
8000a016:	ce f0       	breq	80009ff4 <_dtoa_r+0x704>
8000a018:	50 66       	stdsp	sp[0x18],r6
8000a01a:	11 89       	ld.ub	r9,r8[0x0]
8000a01c:	2f f9       	sub	r9,-1
8000a01e:	b0 89       	st.b	r8[0x0],r9
8000a020:	e0 8f 02 42 	bral	8000a4a4 <_dtoa_r+0xbb4>
8000a024:	e0 a0 0a ce 	rcall	8000b5c0 <__avr32_f64_mul>
8000a028:	2f f4       	sub	r4,-1
8000a02a:	fa eb 00 08 	st.d	sp[8],r10
8000a02e:	30 08       	mov	r8,0
8000a030:	30 09       	mov	r9,0
8000a032:	e0 a0 0d 92 	rcall	8000bb56 <__avr32_f64_cmp_eq>
8000a036:	ca 60       	breq	80009f82 <_dtoa_r+0x692>
8000a038:	e0 8f 02 35 	bral	8000a4a2 <_dtoa_r+0xbb2>
8000a03c:	40 d8       	lddsp	r8,sp[0x34]
8000a03e:	58 08       	cp.w	r8,0
8000a040:	c0 51       	brne	8000a04a <_dtoa_r+0x75a>
8000a042:	04 98       	mov	r8,r2
8000a044:	00 95       	mov	r5,r0
8000a046:	40 d4       	lddsp	r4,sp[0x34]
8000a048:	c3 78       	rjmp	8000a0b6 <_dtoa_r+0x7c6>
8000a04a:	40 c5       	lddsp	r5,sp[0x30]
8000a04c:	58 15       	cp.w	r5,1
8000a04e:	e0 89 00 0f 	brgt	8000a06c <_dtoa_r+0x77c>
8000a052:	41 74       	lddsp	r4,sp[0x5c]
8000a054:	58 04       	cp.w	r4,0
8000a056:	c0 40       	breq	8000a05e <_dtoa_r+0x76e>
8000a058:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a05c:	c0 48       	rjmp	8000a064 <_dtoa_r+0x774>
8000a05e:	41 99       	lddsp	r9,sp[0x64]
8000a060:	f2 09 11 36 	rsub	r9,r9,54
8000a064:	04 98       	mov	r8,r2
8000a066:	00 95       	mov	r5,r0
8000a068:	c1 c8       	rjmp	8000a0a0 <_dtoa_r+0x7b0>
8000a06a:	d7 03       	nop
8000a06c:	e2 c8 00 01 	sub	r8,r1,1
8000a070:	58 01       	cp.w	r1,0
8000a072:	e0 05 17 40 	movge	r5,r0
8000a076:	e2 09 17 40 	movge	r9,r1
8000a07a:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a07e:	f9 b9 05 00 	movlt	r9,0
8000a082:	10 32       	cp.w	r2,r8
8000a084:	e5 d8 e4 18 	subge	r8,r2,r8
8000a088:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a08c:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a090:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a094:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a098:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a09c:	f9 b8 05 00 	movlt	r8,0
8000a0a0:	40 4b       	lddsp	r11,sp[0x10]
8000a0a2:	12 0b       	add	r11,r9
8000a0a4:	50 08       	stdsp	sp[0x0],r8
8000a0a6:	50 4b       	stdsp	sp[0x10],r11
8000a0a8:	12 00       	add	r0,r9
8000a0aa:	30 1b       	mov	r11,1
8000a0ac:	0e 9c       	mov	r12,r7
8000a0ae:	e0 a0 08 a7 	rcall	8000b1fc <__i2b>
8000a0b2:	40 08       	lddsp	r8,sp[0x0]
8000a0b4:	18 94       	mov	r4,r12
8000a0b6:	40 4a       	lddsp	r10,sp[0x10]
8000a0b8:	58 05       	cp.w	r5,0
8000a0ba:	5f 99       	srgt	r9
8000a0bc:	58 0a       	cp.w	r10,0
8000a0be:	5f 9a       	srgt	r10
8000a0c0:	f5 e9 00 09 	and	r9,r10,r9
8000a0c4:	c0 80       	breq	8000a0d4 <_dtoa_r+0x7e4>
8000a0c6:	40 4c       	lddsp	r12,sp[0x10]
8000a0c8:	f8 05 0d 49 	min	r9,r12,r5
8000a0cc:	12 1c       	sub	r12,r9
8000a0ce:	12 10       	sub	r0,r9
8000a0d0:	50 4c       	stdsp	sp[0x10],r12
8000a0d2:	12 15       	sub	r5,r9
8000a0d4:	58 02       	cp.w	r2,0
8000a0d6:	e0 8a 00 27 	brle	8000a124 <_dtoa_r+0x834>
8000a0da:	40 db       	lddsp	r11,sp[0x34]
8000a0dc:	58 0b       	cp.w	r11,0
8000a0de:	c1 d0       	breq	8000a118 <_dtoa_r+0x828>
8000a0e0:	58 08       	cp.w	r8,0
8000a0e2:	e0 8a 00 17 	brle	8000a110 <_dtoa_r+0x820>
8000a0e6:	10 9a       	mov	r10,r8
8000a0e8:	50 08       	stdsp	sp[0x0],r8
8000a0ea:	08 9b       	mov	r11,r4
8000a0ec:	0e 9c       	mov	r12,r7
8000a0ee:	e0 a0 08 cd 	rcall	8000b288 <__pow5mult>
8000a0f2:	06 9a       	mov	r10,r3
8000a0f4:	18 9b       	mov	r11,r12
8000a0f6:	18 94       	mov	r4,r12
8000a0f8:	0e 9c       	mov	r12,r7
8000a0fa:	e0 a0 08 01 	rcall	8000b0fc <__multiply>
8000a0fe:	18 99       	mov	r9,r12
8000a100:	06 9b       	mov	r11,r3
8000a102:	50 19       	stdsp	sp[0x4],r9
8000a104:	0e 9c       	mov	r12,r7
8000a106:	e0 a0 06 ad 	rcall	8000ae60 <_Bfree>
8000a10a:	40 19       	lddsp	r9,sp[0x4]
8000a10c:	40 08       	lddsp	r8,sp[0x0]
8000a10e:	12 93       	mov	r3,r9
8000a110:	e4 08 01 0a 	sub	r10,r2,r8
8000a114:	c0 80       	breq	8000a124 <_dtoa_r+0x834>
8000a116:	c0 28       	rjmp	8000a11a <_dtoa_r+0x82a>
8000a118:	04 9a       	mov	r10,r2
8000a11a:	06 9b       	mov	r11,r3
8000a11c:	0e 9c       	mov	r12,r7
8000a11e:	e0 a0 08 b5 	rcall	8000b288 <__pow5mult>
8000a122:	18 93       	mov	r3,r12
8000a124:	30 1b       	mov	r11,1
8000a126:	0e 9c       	mov	r12,r7
8000a128:	e0 a0 08 6a 	rcall	8000b1fc <__i2b>
8000a12c:	41 1a       	lddsp	r10,sp[0x44]
8000a12e:	18 92       	mov	r2,r12
8000a130:	58 0a       	cp.w	r10,0
8000a132:	e0 8a 00 07 	brle	8000a140 <_dtoa_r+0x850>
8000a136:	18 9b       	mov	r11,r12
8000a138:	0e 9c       	mov	r12,r7
8000a13a:	e0 a0 08 a7 	rcall	8000b288 <__pow5mult>
8000a13e:	18 92       	mov	r2,r12
8000a140:	40 c9       	lddsp	r9,sp[0x30]
8000a142:	58 19       	cp.w	r9,1
8000a144:	e0 89 00 14 	brgt	8000a16c <_dtoa_r+0x87c>
8000a148:	40 38       	lddsp	r8,sp[0xc]
8000a14a:	58 08       	cp.w	r8,0
8000a14c:	c1 01       	brne	8000a16c <_dtoa_r+0x87c>
8000a14e:	40 29       	lddsp	r9,sp[0x8]
8000a150:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a154:	c0 c1       	brne	8000a16c <_dtoa_r+0x87c>
8000a156:	12 98       	mov	r8,r9
8000a158:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a15c:	c0 80       	breq	8000a16c <_dtoa_r+0x87c>
8000a15e:	40 4c       	lddsp	r12,sp[0x10]
8000a160:	30 1b       	mov	r11,1
8000a162:	2f fc       	sub	r12,-1
8000a164:	2f f0       	sub	r0,-1
8000a166:	50 4c       	stdsp	sp[0x10],r12
8000a168:	50 6b       	stdsp	sp[0x18],r11
8000a16a:	c0 38       	rjmp	8000a170 <_dtoa_r+0x880>
8000a16c:	30 0a       	mov	r10,0
8000a16e:	50 6a       	stdsp	sp[0x18],r10
8000a170:	41 19       	lddsp	r9,sp[0x44]
8000a172:	58 09       	cp.w	r9,0
8000a174:	c0 31       	brne	8000a17a <_dtoa_r+0x88a>
8000a176:	30 1c       	mov	r12,1
8000a178:	c0 98       	rjmp	8000a18a <_dtoa_r+0x89a>
8000a17a:	64 48       	ld.w	r8,r2[0x10]
8000a17c:	2f c8       	sub	r8,-4
8000a17e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a182:	e0 a0 05 df 	rcall	8000ad40 <__hi0bits>
8000a186:	f8 0c 11 20 	rsub	r12,r12,32
8000a18a:	40 4b       	lddsp	r11,sp[0x10]
8000a18c:	f8 0b 00 08 	add	r8,r12,r11
8000a190:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a194:	c0 c0       	breq	8000a1ac <_dtoa_r+0x8bc>
8000a196:	f0 08 11 20 	rsub	r8,r8,32
8000a19a:	58 48       	cp.w	r8,4
8000a19c:	e0 8a 00 06 	brle	8000a1a8 <_dtoa_r+0x8b8>
8000a1a0:	20 48       	sub	r8,4
8000a1a2:	10 0b       	add	r11,r8
8000a1a4:	50 4b       	stdsp	sp[0x10],r11
8000a1a6:	c0 78       	rjmp	8000a1b4 <_dtoa_r+0x8c4>
8000a1a8:	58 48       	cp.w	r8,4
8000a1aa:	c0 70       	breq	8000a1b8 <_dtoa_r+0x8c8>
8000a1ac:	40 4a       	lddsp	r10,sp[0x10]
8000a1ae:	2e 48       	sub	r8,-28
8000a1b0:	10 0a       	add	r10,r8
8000a1b2:	50 4a       	stdsp	sp[0x10],r10
8000a1b4:	10 00       	add	r0,r8
8000a1b6:	10 05       	add	r5,r8
8000a1b8:	58 00       	cp.w	r0,0
8000a1ba:	e0 8a 00 08 	brle	8000a1ca <_dtoa_r+0x8da>
8000a1be:	06 9b       	mov	r11,r3
8000a1c0:	00 9a       	mov	r10,r0
8000a1c2:	0e 9c       	mov	r12,r7
8000a1c4:	e0 a0 07 58 	rcall	8000b074 <__lshift>
8000a1c8:	18 93       	mov	r3,r12
8000a1ca:	40 49       	lddsp	r9,sp[0x10]
8000a1cc:	58 09       	cp.w	r9,0
8000a1ce:	e0 8a 00 08 	brle	8000a1de <_dtoa_r+0x8ee>
8000a1d2:	04 9b       	mov	r11,r2
8000a1d4:	12 9a       	mov	r10,r9
8000a1d6:	0e 9c       	mov	r12,r7
8000a1d8:	e0 a0 07 4e 	rcall	8000b074 <__lshift>
8000a1dc:	18 92       	mov	r2,r12
8000a1de:	41 48       	lddsp	r8,sp[0x50]
8000a1e0:	58 08       	cp.w	r8,0
8000a1e2:	c1 b0       	breq	8000a218 <_dtoa_r+0x928>
8000a1e4:	04 9b       	mov	r11,r2
8000a1e6:	06 9c       	mov	r12,r3
8000a1e8:	e0 a0 06 23 	rcall	8000ae2e <__mcmp>
8000a1ec:	c1 64       	brge	8000a218 <_dtoa_r+0x928>
8000a1ee:	06 9b       	mov	r11,r3
8000a1f0:	30 09       	mov	r9,0
8000a1f2:	30 aa       	mov	r10,10
8000a1f4:	0e 9c       	mov	r12,r7
8000a1f6:	e0 a0 08 0b 	rcall	8000b20c <__multadd>
8000a1fa:	20 16       	sub	r6,1
8000a1fc:	18 93       	mov	r3,r12
8000a1fe:	40 dc       	lddsp	r12,sp[0x34]
8000a200:	58 0c       	cp.w	r12,0
8000a202:	c0 31       	brne	8000a208 <_dtoa_r+0x918>
8000a204:	40 91       	lddsp	r1,sp[0x24]
8000a206:	c0 98       	rjmp	8000a218 <_dtoa_r+0x928>
8000a208:	08 9b       	mov	r11,r4
8000a20a:	40 91       	lddsp	r1,sp[0x24]
8000a20c:	30 09       	mov	r9,0
8000a20e:	30 aa       	mov	r10,10
8000a210:	0e 9c       	mov	r12,r7
8000a212:	e0 a0 07 fd 	rcall	8000b20c <__multadd>
8000a216:	18 94       	mov	r4,r12
8000a218:	58 01       	cp.w	r1,0
8000a21a:	5f a9       	srle	r9
8000a21c:	40 cb       	lddsp	r11,sp[0x30]
8000a21e:	58 2b       	cp.w	r11,2
8000a220:	5f 98       	srgt	r8
8000a222:	f3 e8 00 08 	and	r8,r9,r8
8000a226:	c2 50       	breq	8000a270 <_dtoa_r+0x980>
8000a228:	58 01       	cp.w	r1,0
8000a22a:	c1 11       	brne	8000a24c <_dtoa_r+0x95c>
8000a22c:	04 9b       	mov	r11,r2
8000a22e:	02 99       	mov	r9,r1
8000a230:	30 5a       	mov	r10,5
8000a232:	0e 9c       	mov	r12,r7
8000a234:	e0 a0 07 ec 	rcall	8000b20c <__multadd>
8000a238:	18 92       	mov	r2,r12
8000a23a:	18 9b       	mov	r11,r12
8000a23c:	06 9c       	mov	r12,r3
8000a23e:	e0 a0 05 f8 	rcall	8000ae2e <__mcmp>
8000a242:	e0 89 00 0f 	brgt	8000a260 <_dtoa_r+0x970>
8000a246:	c0 38       	rjmp	8000a24c <_dtoa_r+0x95c>
8000a248:	30 02       	mov	r2,0
8000a24a:	04 94       	mov	r4,r2
8000a24c:	40 ea       	lddsp	r10,sp[0x38]
8000a24e:	30 09       	mov	r9,0
8000a250:	5c da       	com	r10
8000a252:	40 85       	lddsp	r5,sp[0x20]
8000a254:	50 6a       	stdsp	sp[0x18],r10
8000a256:	50 49       	stdsp	sp[0x10],r9
8000a258:	c0 f9       	rjmp	8000a476 <_dtoa_r+0xb86>
8000a25a:	08 92       	mov	r2,r4
8000a25c:	40 66       	lddsp	r6,sp[0x18]
8000a25e:	04 94       	mov	r4,r2
8000a260:	2f f6       	sub	r6,-1
8000a262:	50 66       	stdsp	sp[0x18],r6
8000a264:	33 18       	mov	r8,49
8000a266:	40 85       	lddsp	r5,sp[0x20]
8000a268:	0a c8       	st.b	r5++,r8
8000a26a:	30 08       	mov	r8,0
8000a26c:	50 48       	stdsp	sp[0x10],r8
8000a26e:	c0 49       	rjmp	8000a476 <_dtoa_r+0xb86>
8000a270:	40 dc       	lddsp	r12,sp[0x34]
8000a272:	58 0c       	cp.w	r12,0
8000a274:	e0 80 00 b5 	breq	8000a3de <_dtoa_r+0xaee>
8000a278:	58 05       	cp.w	r5,0
8000a27a:	e0 8a 00 08 	brle	8000a28a <_dtoa_r+0x99a>
8000a27e:	08 9b       	mov	r11,r4
8000a280:	0a 9a       	mov	r10,r5
8000a282:	0e 9c       	mov	r12,r7
8000a284:	e0 a0 06 f8 	rcall	8000b074 <__lshift>
8000a288:	18 94       	mov	r4,r12
8000a28a:	40 6b       	lddsp	r11,sp[0x18]
8000a28c:	58 0b       	cp.w	r11,0
8000a28e:	c0 31       	brne	8000a294 <_dtoa_r+0x9a4>
8000a290:	08 9c       	mov	r12,r4
8000a292:	c1 38       	rjmp	8000a2b8 <_dtoa_r+0x9c8>
8000a294:	68 1b       	ld.w	r11,r4[0x4]
8000a296:	0e 9c       	mov	r12,r7
8000a298:	e0 a0 05 fe 	rcall	8000ae94 <_Balloc>
8000a29c:	68 4a       	ld.w	r10,r4[0x10]
8000a29e:	18 95       	mov	r5,r12
8000a2a0:	e8 cb ff f4 	sub	r11,r4,-12
8000a2a4:	2f ea       	sub	r10,-2
8000a2a6:	2f 4c       	sub	r12,-12
8000a2a8:	a3 6a       	lsl	r10,0x2
8000a2aa:	fe b0 e5 6b 	rcall	80006d80 <memcpy>
8000a2ae:	0a 9b       	mov	r11,r5
8000a2b0:	30 1a       	mov	r10,1
8000a2b2:	0e 9c       	mov	r12,r7
8000a2b4:	e0 a0 06 e0 	rcall	8000b074 <__lshift>
8000a2b8:	50 44       	stdsp	sp[0x10],r4
8000a2ba:	40 3a       	lddsp	r10,sp[0xc]
8000a2bc:	30 19       	mov	r9,1
8000a2be:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a2c2:	18 94       	mov	r4,r12
8000a2c4:	50 da       	stdsp	sp[0x34],r10
8000a2c6:	40 85       	lddsp	r5,sp[0x20]
8000a2c8:	50 99       	stdsp	sp[0x24],r9
8000a2ca:	50 26       	stdsp	sp[0x8],r6
8000a2cc:	50 e1       	stdsp	sp[0x38],r1
8000a2ce:	04 9b       	mov	r11,r2
8000a2d0:	06 9c       	mov	r12,r3
8000a2d2:	fe b0 fa 7f 	rcall	800097d0 <quorem>
8000a2d6:	40 4b       	lddsp	r11,sp[0x10]
8000a2d8:	f8 c0 ff d0 	sub	r0,r12,-48
8000a2dc:	06 9c       	mov	r12,r3
8000a2de:	e0 a0 05 a8 	rcall	8000ae2e <__mcmp>
8000a2e2:	08 9a       	mov	r10,r4
8000a2e4:	50 6c       	stdsp	sp[0x18],r12
8000a2e6:	04 9b       	mov	r11,r2
8000a2e8:	0e 9c       	mov	r12,r7
8000a2ea:	e0 a0 06 5d 	rcall	8000afa4 <__mdiff>
8000a2ee:	18 91       	mov	r1,r12
8000a2f0:	78 38       	ld.w	r8,r12[0xc]
8000a2f2:	58 08       	cp.w	r8,0
8000a2f4:	c0 30       	breq	8000a2fa <_dtoa_r+0xa0a>
8000a2f6:	30 16       	mov	r6,1
8000a2f8:	c0 68       	rjmp	8000a304 <_dtoa_r+0xa14>
8000a2fa:	18 9b       	mov	r11,r12
8000a2fc:	06 9c       	mov	r12,r3
8000a2fe:	e0 a0 05 98 	rcall	8000ae2e <__mcmp>
8000a302:	18 96       	mov	r6,r12
8000a304:	0e 9c       	mov	r12,r7
8000a306:	02 9b       	mov	r11,r1
8000a308:	e0 a0 05 ac 	rcall	8000ae60 <_Bfree>
8000a30c:	40 cc       	lddsp	r12,sp[0x30]
8000a30e:	ed ec 10 08 	or	r8,r6,r12
8000a312:	c0 d1       	brne	8000a32c <_dtoa_r+0xa3c>
8000a314:	40 db       	lddsp	r11,sp[0x34]
8000a316:	58 0b       	cp.w	r11,0
8000a318:	c0 a1       	brne	8000a32c <_dtoa_r+0xa3c>
8000a31a:	40 26       	lddsp	r6,sp[0x8]
8000a31c:	e0 40 00 39 	cp.w	r0,57
8000a320:	c3 00       	breq	8000a380 <_dtoa_r+0xa90>
8000a322:	40 6a       	lddsp	r10,sp[0x18]
8000a324:	58 0a       	cp.w	r10,0
8000a326:	e0 89 00 24 	brgt	8000a36e <_dtoa_r+0xa7e>
8000a32a:	c2 f8       	rjmp	8000a388 <_dtoa_r+0xa98>
8000a32c:	40 69       	lddsp	r9,sp[0x18]
8000a32e:	58 09       	cp.w	r9,0
8000a330:	c0 85       	brlt	8000a340 <_dtoa_r+0xa50>
8000a332:	12 98       	mov	r8,r9
8000a334:	40 cc       	lddsp	r12,sp[0x30]
8000a336:	18 48       	or	r8,r12
8000a338:	c1 d1       	brne	8000a372 <_dtoa_r+0xa82>
8000a33a:	40 db       	lddsp	r11,sp[0x34]
8000a33c:	58 0b       	cp.w	r11,0
8000a33e:	c1 a1       	brne	8000a372 <_dtoa_r+0xa82>
8000a340:	0c 99       	mov	r9,r6
8000a342:	40 26       	lddsp	r6,sp[0x8]
8000a344:	58 09       	cp.w	r9,0
8000a346:	e0 8a 00 21 	brle	8000a388 <_dtoa_r+0xa98>
8000a34a:	06 9b       	mov	r11,r3
8000a34c:	30 1a       	mov	r10,1
8000a34e:	0e 9c       	mov	r12,r7
8000a350:	e0 a0 06 92 	rcall	8000b074 <__lshift>
8000a354:	04 9b       	mov	r11,r2
8000a356:	18 93       	mov	r3,r12
8000a358:	e0 a0 05 6b 	rcall	8000ae2e <__mcmp>
8000a35c:	e0 89 00 06 	brgt	8000a368 <_dtoa_r+0xa78>
8000a360:	c1 41       	brne	8000a388 <_dtoa_r+0xa98>
8000a362:	ed b0 00 00 	bld	r0,0x0
8000a366:	c1 11       	brne	8000a388 <_dtoa_r+0xa98>
8000a368:	e0 40 00 39 	cp.w	r0,57
8000a36c:	c0 a0       	breq	8000a380 <_dtoa_r+0xa90>
8000a36e:	2f f0       	sub	r0,-1
8000a370:	c0 c8       	rjmp	8000a388 <_dtoa_r+0xa98>
8000a372:	58 06       	cp.w	r6,0
8000a374:	e0 8a 00 0c 	brle	8000a38c <_dtoa_r+0xa9c>
8000a378:	40 26       	lddsp	r6,sp[0x8]
8000a37a:	e0 40 00 39 	cp.w	r0,57
8000a37e:	c0 41       	brne	8000a386 <_dtoa_r+0xa96>
8000a380:	33 98       	mov	r8,57
8000a382:	0a c8       	st.b	r5++,r8
8000a384:	c6 78       	rjmp	8000a452 <_dtoa_r+0xb62>
8000a386:	2f f0       	sub	r0,-1
8000a388:	0a c0       	st.b	r5++,r0
8000a38a:	c7 58       	rjmp	8000a474 <_dtoa_r+0xb84>
8000a38c:	0a c0       	st.b	r5++,r0
8000a38e:	40 9a       	lddsp	r10,sp[0x24]
8000a390:	40 e9       	lddsp	r9,sp[0x38]
8000a392:	12 3a       	cp.w	r10,r9
8000a394:	c4 30       	breq	8000a41a <_dtoa_r+0xb2a>
8000a396:	06 9b       	mov	r11,r3
8000a398:	30 09       	mov	r9,0
8000a39a:	30 aa       	mov	r10,10
8000a39c:	0e 9c       	mov	r12,r7
8000a39e:	e0 a0 07 37 	rcall	8000b20c <__multadd>
8000a3a2:	40 48       	lddsp	r8,sp[0x10]
8000a3a4:	18 93       	mov	r3,r12
8000a3a6:	08 38       	cp.w	r8,r4
8000a3a8:	c0 91       	brne	8000a3ba <_dtoa_r+0xaca>
8000a3aa:	10 9b       	mov	r11,r8
8000a3ac:	30 09       	mov	r9,0
8000a3ae:	30 aa       	mov	r10,10
8000a3b0:	0e 9c       	mov	r12,r7
8000a3b2:	e0 a0 07 2d 	rcall	8000b20c <__multadd>
8000a3b6:	50 4c       	stdsp	sp[0x10],r12
8000a3b8:	c0 e8       	rjmp	8000a3d4 <_dtoa_r+0xae4>
8000a3ba:	40 4b       	lddsp	r11,sp[0x10]
8000a3bc:	30 09       	mov	r9,0
8000a3be:	30 aa       	mov	r10,10
8000a3c0:	0e 9c       	mov	r12,r7
8000a3c2:	e0 a0 07 25 	rcall	8000b20c <__multadd>
8000a3c6:	08 9b       	mov	r11,r4
8000a3c8:	50 4c       	stdsp	sp[0x10],r12
8000a3ca:	30 09       	mov	r9,0
8000a3cc:	30 aa       	mov	r10,10
8000a3ce:	0e 9c       	mov	r12,r7
8000a3d0:	e0 a0 07 1e 	rcall	8000b20c <__multadd>
8000a3d4:	18 94       	mov	r4,r12
8000a3d6:	40 9c       	lddsp	r12,sp[0x24]
8000a3d8:	2f fc       	sub	r12,-1
8000a3da:	50 9c       	stdsp	sp[0x24],r12
8000a3dc:	c7 9b       	rjmp	8000a2ce <_dtoa_r+0x9de>
8000a3de:	30 18       	mov	r8,1
8000a3e0:	06 90       	mov	r0,r3
8000a3e2:	40 85       	lddsp	r5,sp[0x20]
8000a3e4:	08 93       	mov	r3,r4
8000a3e6:	0c 94       	mov	r4,r6
8000a3e8:	10 96       	mov	r6,r8
8000a3ea:	04 9b       	mov	r11,r2
8000a3ec:	00 9c       	mov	r12,r0
8000a3ee:	fe b0 f9 f1 	rcall	800097d0 <quorem>
8000a3f2:	2d 0c       	sub	r12,-48
8000a3f4:	0a cc       	st.b	r5++,r12
8000a3f6:	02 36       	cp.w	r6,r1
8000a3f8:	c0 a4       	brge	8000a40c <_dtoa_r+0xb1c>
8000a3fa:	00 9b       	mov	r11,r0
8000a3fc:	30 09       	mov	r9,0
8000a3fe:	30 aa       	mov	r10,10
8000a400:	0e 9c       	mov	r12,r7
8000a402:	2f f6       	sub	r6,-1
8000a404:	e0 a0 07 04 	rcall	8000b20c <__multadd>
8000a408:	18 90       	mov	r0,r12
8000a40a:	cf 0b       	rjmp	8000a3ea <_dtoa_r+0xafa>
8000a40c:	08 96       	mov	r6,r4
8000a40e:	30 0b       	mov	r11,0
8000a410:	06 94       	mov	r4,r3
8000a412:	50 4b       	stdsp	sp[0x10],r11
8000a414:	00 93       	mov	r3,r0
8000a416:	18 90       	mov	r0,r12
8000a418:	c0 28       	rjmp	8000a41c <_dtoa_r+0xb2c>
8000a41a:	40 26       	lddsp	r6,sp[0x8]
8000a41c:	06 9b       	mov	r11,r3
8000a41e:	30 1a       	mov	r10,1
8000a420:	0e 9c       	mov	r12,r7
8000a422:	e0 a0 06 29 	rcall	8000b074 <__lshift>
8000a426:	04 9b       	mov	r11,r2
8000a428:	18 93       	mov	r3,r12
8000a42a:	e0 a0 05 02 	rcall	8000ae2e <__mcmp>
8000a42e:	e0 89 00 12 	brgt	8000a452 <_dtoa_r+0xb62>
8000a432:	c1 b1       	brne	8000a468 <_dtoa_r+0xb78>
8000a434:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a438:	c0 d1       	brne	8000a452 <_dtoa_r+0xb62>
8000a43a:	c1 78       	rjmp	8000a468 <_dtoa_r+0xb78>
8000a43c:	40 89       	lddsp	r9,sp[0x20]
8000a43e:	12 38       	cp.w	r8,r9
8000a440:	c0 30       	breq	8000a446 <_dtoa_r+0xb56>
8000a442:	10 95       	mov	r5,r8
8000a444:	c0 88       	rjmp	8000a454 <_dtoa_r+0xb64>
8000a446:	2f f6       	sub	r6,-1
8000a448:	50 66       	stdsp	sp[0x18],r6
8000a44a:	33 18       	mov	r8,49
8000a44c:	40 8c       	lddsp	r12,sp[0x20]
8000a44e:	b8 88       	st.b	r12[0x0],r8
8000a450:	c1 38       	rjmp	8000a476 <_dtoa_r+0xb86>
8000a452:	33 9a       	mov	r10,57
8000a454:	0a 98       	mov	r8,r5
8000a456:	11 79       	ld.ub	r9,--r8
8000a458:	f4 09 18 00 	cp.b	r9,r10
8000a45c:	cf 00       	breq	8000a43c <_dtoa_r+0xb4c>
8000a45e:	2f f9       	sub	r9,-1
8000a460:	b0 89       	st.b	r8[0x0],r9
8000a462:	c0 98       	rjmp	8000a474 <_dtoa_r+0xb84>
8000a464:	10 95       	mov	r5,r8
8000a466:	c0 28       	rjmp	8000a46a <_dtoa_r+0xb7a>
8000a468:	33 09       	mov	r9,48
8000a46a:	0a 98       	mov	r8,r5
8000a46c:	11 7a       	ld.ub	r10,--r8
8000a46e:	f2 0a 18 00 	cp.b	r10,r9
8000a472:	cf 90       	breq	8000a464 <_dtoa_r+0xb74>
8000a474:	50 66       	stdsp	sp[0x18],r6
8000a476:	04 9b       	mov	r11,r2
8000a478:	0e 9c       	mov	r12,r7
8000a47a:	e0 a0 04 f3 	rcall	8000ae60 <_Bfree>
8000a47e:	58 04       	cp.w	r4,0
8000a480:	c1 20       	breq	8000a4a4 <_dtoa_r+0xbb4>
8000a482:	40 4b       	lddsp	r11,sp[0x10]
8000a484:	08 3b       	cp.w	r11,r4
8000a486:	5f 19       	srne	r9
8000a488:	58 0b       	cp.w	r11,0
8000a48a:	5f 18       	srne	r8
8000a48c:	f3 e8 00 08 	and	r8,r9,r8
8000a490:	c0 40       	breq	8000a498 <_dtoa_r+0xba8>
8000a492:	0e 9c       	mov	r12,r7
8000a494:	e0 a0 04 e6 	rcall	8000ae60 <_Bfree>
8000a498:	08 9b       	mov	r11,r4
8000a49a:	0e 9c       	mov	r12,r7
8000a49c:	e0 a0 04 e2 	rcall	8000ae60 <_Bfree>
8000a4a0:	c0 28       	rjmp	8000a4a4 <_dtoa_r+0xbb4>
8000a4a2:	50 66       	stdsp	sp[0x18],r6
8000a4a4:	0e 9c       	mov	r12,r7
8000a4a6:	06 9b       	mov	r11,r3
8000a4a8:	e0 a0 04 dc 	rcall	8000ae60 <_Bfree>
8000a4ac:	30 08       	mov	r8,0
8000a4ae:	aa 88       	st.b	r5[0x0],r8
8000a4b0:	40 68       	lddsp	r8,sp[0x18]
8000a4b2:	41 5a       	lddsp	r10,sp[0x54]
8000a4b4:	2f f8       	sub	r8,-1
8000a4b6:	41 29       	lddsp	r9,sp[0x48]
8000a4b8:	95 08       	st.w	r10[0x0],r8
8000a4ba:	40 8c       	lddsp	r12,sp[0x20]
8000a4bc:	58 09       	cp.w	r9,0
8000a4be:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a4c2:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a4c6:	2e 6d       	sub	sp,-104
8000a4c8:	d8 32       	popm	r0-r7,pc
8000a4ca:	d7 03       	nop

8000a4cc <__errno>:
8000a4cc:	e0 68 01 18 	mov	r8,280
8000a4d0:	70 0c       	ld.w	r12,r8[0x0]
8000a4d2:	2f 4c       	sub	r12,-12
8000a4d4:	5e fc       	retal	r12
8000a4d6:	d7 03       	nop

8000a4d8 <_fflush_r>:
8000a4d8:	d4 21       	pushm	r4-r7,lr
8000a4da:	16 97       	mov	r7,r11
8000a4dc:	18 96       	mov	r6,r12
8000a4de:	76 48       	ld.w	r8,r11[0x10]
8000a4e0:	58 08       	cp.w	r8,0
8000a4e2:	c7 f0       	breq	8000a5e0 <_fflush_r+0x108>
8000a4e4:	58 0c       	cp.w	r12,0
8000a4e6:	c0 50       	breq	8000a4f0 <_fflush_r+0x18>
8000a4e8:	78 68       	ld.w	r8,r12[0x18]
8000a4ea:	58 08       	cp.w	r8,0
8000a4ec:	c0 21       	brne	8000a4f0 <_fflush_r+0x18>
8000a4ee:	cc dc       	rcall	8000a688 <__sinit>
8000a4f0:	fe c8 db d4 	sub	r8,pc,-9260
8000a4f4:	10 37       	cp.w	r7,r8
8000a4f6:	c0 31       	brne	8000a4fc <_fflush_r+0x24>
8000a4f8:	6c 07       	ld.w	r7,r6[0x0]
8000a4fa:	c0 c8       	rjmp	8000a512 <_fflush_r+0x3a>
8000a4fc:	fe c8 db c0 	sub	r8,pc,-9280
8000a500:	10 37       	cp.w	r7,r8
8000a502:	c0 31       	brne	8000a508 <_fflush_r+0x30>
8000a504:	6c 17       	ld.w	r7,r6[0x4]
8000a506:	c0 68       	rjmp	8000a512 <_fflush_r+0x3a>
8000a508:	fe c8 db ac 	sub	r8,pc,-9300
8000a50c:	10 37       	cp.w	r7,r8
8000a50e:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a512:	8e 6a       	ld.sh	r10,r7[0xc]
8000a514:	14 98       	mov	r8,r10
8000a516:	ed ba 00 03 	bld	r10,0x3
8000a51a:	c4 20       	breq	8000a59e <_fflush_r+0xc6>
8000a51c:	ab ba       	sbr	r10,0xb
8000a51e:	ae 6a       	st.h	r7[0xc],r10
8000a520:	6e 18       	ld.w	r8,r7[0x4]
8000a522:	58 08       	cp.w	r8,0
8000a524:	e0 89 00 06 	brgt	8000a530 <_fflush_r+0x58>
8000a528:	6f 08       	ld.w	r8,r7[0x40]
8000a52a:	58 08       	cp.w	r8,0
8000a52c:	e0 8a 00 5a 	brle	8000a5e0 <_fflush_r+0x108>
8000a530:	6e b8       	ld.w	r8,r7[0x2c]
8000a532:	58 08       	cp.w	r8,0
8000a534:	c5 60       	breq	8000a5e0 <_fflush_r+0x108>
8000a536:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a53a:	c0 30       	breq	8000a540 <_fflush_r+0x68>
8000a53c:	6f 55       	ld.w	r5,r7[0x54]
8000a53e:	c0 f8       	rjmp	8000a55c <_fflush_r+0x84>
8000a540:	30 19       	mov	r9,1
8000a542:	6e 8b       	ld.w	r11,r7[0x20]
8000a544:	0c 9c       	mov	r12,r6
8000a546:	5d 18       	icall	r8
8000a548:	18 95       	mov	r5,r12
8000a54a:	5b fc       	cp.w	r12,-1
8000a54c:	c0 81       	brne	8000a55c <_fflush_r+0x84>
8000a54e:	6c 38       	ld.w	r8,r6[0xc]
8000a550:	59 d8       	cp.w	r8,29
8000a552:	c4 70       	breq	8000a5e0 <_fflush_r+0x108>
8000a554:	8e 68       	ld.sh	r8,r7[0xc]
8000a556:	a7 a8       	sbr	r8,0x6
8000a558:	ae 68       	st.h	r7[0xc],r8
8000a55a:	d8 22       	popm	r4-r7,pc
8000a55c:	8e 68       	ld.sh	r8,r7[0xc]
8000a55e:	ed b8 00 02 	bld	r8,0x2
8000a562:	c0 91       	brne	8000a574 <_fflush_r+0x9c>
8000a564:	6e 18       	ld.w	r8,r7[0x4]
8000a566:	10 15       	sub	r5,r8
8000a568:	6e d8       	ld.w	r8,r7[0x34]
8000a56a:	58 08       	cp.w	r8,0
8000a56c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a570:	eb d8 e1 15 	subne	r5,r5,r8
8000a574:	6e b8       	ld.w	r8,r7[0x2c]
8000a576:	0c 9c       	mov	r12,r6
8000a578:	30 09       	mov	r9,0
8000a57a:	0a 9a       	mov	r10,r5
8000a57c:	6e 8b       	ld.w	r11,r7[0x20]
8000a57e:	5d 18       	icall	r8
8000a580:	8e 68       	ld.sh	r8,r7[0xc]
8000a582:	0a 3c       	cp.w	r12,r5
8000a584:	c2 61       	brne	8000a5d0 <_fflush_r+0xf8>
8000a586:	ab d8       	cbr	r8,0xb
8000a588:	30 0c       	mov	r12,0
8000a58a:	6e 49       	ld.w	r9,r7[0x10]
8000a58c:	ae 68       	st.h	r7[0xc],r8
8000a58e:	8f 1c       	st.w	r7[0x4],r12
8000a590:	8f 09       	st.w	r7[0x0],r9
8000a592:	ed b8 00 0c 	bld	r8,0xc
8000a596:	c2 51       	brne	8000a5e0 <_fflush_r+0x108>
8000a598:	ef 45 00 54 	st.w	r7[84],r5
8000a59c:	d8 22       	popm	r4-r7,pc
8000a59e:	6e 45       	ld.w	r5,r7[0x10]
8000a5a0:	58 05       	cp.w	r5,0
8000a5a2:	c1 f0       	breq	8000a5e0 <_fflush_r+0x108>
8000a5a4:	6e 04       	ld.w	r4,r7[0x0]
8000a5a6:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a5aa:	8f 05       	st.w	r7[0x0],r5
8000a5ac:	f9 b8 01 00 	movne	r8,0
8000a5b0:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a5b4:	0a 14       	sub	r4,r5
8000a5b6:	8f 28       	st.w	r7[0x8],r8
8000a5b8:	c1 18       	rjmp	8000a5da <_fflush_r+0x102>
8000a5ba:	08 99       	mov	r9,r4
8000a5bc:	0a 9a       	mov	r10,r5
8000a5be:	6e a8       	ld.w	r8,r7[0x28]
8000a5c0:	6e 8b       	ld.w	r11,r7[0x20]
8000a5c2:	0c 9c       	mov	r12,r6
8000a5c4:	5d 18       	icall	r8
8000a5c6:	18 14       	sub	r4,r12
8000a5c8:	58 0c       	cp.w	r12,0
8000a5ca:	e0 89 00 07 	brgt	8000a5d8 <_fflush_r+0x100>
8000a5ce:	8e 68       	ld.sh	r8,r7[0xc]
8000a5d0:	a7 a8       	sbr	r8,0x6
8000a5d2:	3f fc       	mov	r12,-1
8000a5d4:	ae 68       	st.h	r7[0xc],r8
8000a5d6:	d8 22       	popm	r4-r7,pc
8000a5d8:	18 05       	add	r5,r12
8000a5da:	58 04       	cp.w	r4,0
8000a5dc:	fe 99 ff ef 	brgt	8000a5ba <_fflush_r+0xe2>
8000a5e0:	d8 2a       	popm	r4-r7,pc,r12=0
8000a5e2:	d7 03       	nop

8000a5e4 <__sfp_lock_acquire>:
8000a5e4:	5e fc       	retal	r12

8000a5e6 <__sfp_lock_release>:
8000a5e6:	5e fc       	retal	r12

8000a5e8 <_cleanup_r>:
8000a5e8:	d4 01       	pushm	lr
8000a5ea:	fe cb f0 ae 	sub	r11,pc,-3922
8000a5ee:	e0 a0 02 f7 	rcall	8000abdc <_fwalk>
8000a5f2:	d8 02       	popm	pc

8000a5f4 <__sfmoreglue>:
8000a5f4:	d4 21       	pushm	r4-r7,lr
8000a5f6:	16 95       	mov	r5,r11
8000a5f8:	f6 06 10 5c 	mul	r6,r11,92
8000a5fc:	ec cb ff f4 	sub	r11,r6,-12
8000a600:	fe b0 e1 a4 	rcall	80006948 <_malloc_r>
8000a604:	18 97       	mov	r7,r12
8000a606:	c0 90       	breq	8000a618 <__sfmoreglue+0x24>
8000a608:	99 15       	st.w	r12[0x4],r5
8000a60a:	30 0b       	mov	r11,0
8000a60c:	2f 4c       	sub	r12,-12
8000a60e:	0c 9a       	mov	r10,r6
8000a610:	8f 2c       	st.w	r7[0x8],r12
8000a612:	8f 0b       	st.w	r7[0x0],r11
8000a614:	fe b0 e4 5a 	rcall	80006ec8 <memset>
8000a618:	0e 9c       	mov	r12,r7
8000a61a:	d8 22       	popm	r4-r7,pc

8000a61c <__sfp>:
8000a61c:	d4 21       	pushm	r4-r7,lr
8000a61e:	fe c8 e0 ea 	sub	r8,pc,-7958
8000a622:	18 96       	mov	r6,r12
8000a624:	70 07       	ld.w	r7,r8[0x0]
8000a626:	6e 68       	ld.w	r8,r7[0x18]
8000a628:	58 08       	cp.w	r8,0
8000a62a:	c0 31       	brne	8000a630 <__sfp+0x14>
8000a62c:	0e 9c       	mov	r12,r7
8000a62e:	c2 dc       	rcall	8000a688 <__sinit>
8000a630:	ee c7 ff 28 	sub	r7,r7,-216
8000a634:	30 05       	mov	r5,0
8000a636:	6e 2c       	ld.w	r12,r7[0x8]
8000a638:	6e 18       	ld.w	r8,r7[0x4]
8000a63a:	c0 68       	rjmp	8000a646 <__sfp+0x2a>
8000a63c:	98 69       	ld.sh	r9,r12[0xc]
8000a63e:	ea 09 19 00 	cp.h	r9,r5
8000a642:	c1 10       	breq	8000a664 <__sfp+0x48>
8000a644:	2a 4c       	sub	r12,-92
8000a646:	20 18       	sub	r8,1
8000a648:	cf a7       	brpl	8000a63c <__sfp+0x20>
8000a64a:	6e 08       	ld.w	r8,r7[0x0]
8000a64c:	58 08       	cp.w	r8,0
8000a64e:	c0 61       	brne	8000a65a <__sfp+0x3e>
8000a650:	30 4b       	mov	r11,4
8000a652:	0c 9c       	mov	r12,r6
8000a654:	cd 0f       	rcall	8000a5f4 <__sfmoreglue>
8000a656:	8f 0c       	st.w	r7[0x0],r12
8000a658:	c0 30       	breq	8000a65e <__sfp+0x42>
8000a65a:	6e 07       	ld.w	r7,r7[0x0]
8000a65c:	ce db       	rjmp	8000a636 <__sfp+0x1a>
8000a65e:	30 c8       	mov	r8,12
8000a660:	8d 38       	st.w	r6[0xc],r8
8000a662:	d8 22       	popm	r4-r7,pc
8000a664:	30 08       	mov	r8,0
8000a666:	f9 48 00 4c 	st.w	r12[76],r8
8000a66a:	99 08       	st.w	r12[0x0],r8
8000a66c:	99 28       	st.w	r12[0x8],r8
8000a66e:	99 18       	st.w	r12[0x4],r8
8000a670:	99 48       	st.w	r12[0x10],r8
8000a672:	99 58       	st.w	r12[0x14],r8
8000a674:	99 68       	st.w	r12[0x18],r8
8000a676:	99 d8       	st.w	r12[0x34],r8
8000a678:	99 e8       	st.w	r12[0x38],r8
8000a67a:	f9 48 00 48 	st.w	r12[72],r8
8000a67e:	3f f8       	mov	r8,-1
8000a680:	b8 78       	st.h	r12[0xe],r8
8000a682:	30 18       	mov	r8,1
8000a684:	b8 68       	st.h	r12[0xc],r8
8000a686:	d8 22       	popm	r4-r7,pc

8000a688 <__sinit>:
8000a688:	d4 21       	pushm	r4-r7,lr
8000a68a:	18 96       	mov	r6,r12
8000a68c:	78 67       	ld.w	r7,r12[0x18]
8000a68e:	58 07       	cp.w	r7,0
8000a690:	c4 91       	brne	8000a722 <__sinit+0x9a>
8000a692:	fe c8 00 aa 	sub	r8,pc,170
8000a696:	30 15       	mov	r5,1
8000a698:	99 a8       	st.w	r12[0x28],r8
8000a69a:	f9 47 00 d8 	st.w	r12[216],r7
8000a69e:	f9 47 00 dc 	st.w	r12[220],r7
8000a6a2:	f9 47 00 e0 	st.w	r12[224],r7
8000a6a6:	99 65       	st.w	r12[0x18],r5
8000a6a8:	cb af       	rcall	8000a61c <__sfp>
8000a6aa:	8d 0c       	st.w	r6[0x0],r12
8000a6ac:	0c 9c       	mov	r12,r6
8000a6ae:	cb 7f       	rcall	8000a61c <__sfp>
8000a6b0:	8d 1c       	st.w	r6[0x4],r12
8000a6b2:	0c 9c       	mov	r12,r6
8000a6b4:	cb 4f       	rcall	8000a61c <__sfp>
8000a6b6:	6c 09       	ld.w	r9,r6[0x0]
8000a6b8:	30 48       	mov	r8,4
8000a6ba:	93 07       	st.w	r9[0x0],r7
8000a6bc:	b2 68       	st.h	r9[0xc],r8
8000a6be:	93 17       	st.w	r9[0x4],r7
8000a6c0:	93 27       	st.w	r9[0x8],r7
8000a6c2:	6c 18       	ld.w	r8,r6[0x4]
8000a6c4:	b2 77       	st.h	r9[0xe],r7
8000a6c6:	93 47       	st.w	r9[0x10],r7
8000a6c8:	93 57       	st.w	r9[0x14],r7
8000a6ca:	93 67       	st.w	r9[0x18],r7
8000a6cc:	93 89       	st.w	r9[0x20],r9
8000a6ce:	91 07       	st.w	r8[0x0],r7
8000a6d0:	91 17       	st.w	r8[0x4],r7
8000a6d2:	91 27       	st.w	r8[0x8],r7
8000a6d4:	fe ce f3 24 	sub	lr,pc,-3292
8000a6d8:	fe cb f3 54 	sub	r11,pc,-3244
8000a6dc:	93 9e       	st.w	r9[0x24],lr
8000a6de:	93 ab       	st.w	r9[0x28],r11
8000a6e0:	fe ca f3 7c 	sub	r10,pc,-3204
8000a6e4:	fe c4 f3 88 	sub	r4,pc,-3192
8000a6e8:	93 ba       	st.w	r9[0x2c],r10
8000a6ea:	93 c4       	st.w	r9[0x30],r4
8000a6ec:	30 99       	mov	r9,9
8000a6ee:	b0 69       	st.h	r8[0xc],r9
8000a6f0:	b0 75       	st.h	r8[0xe],r5
8000a6f2:	91 c4       	st.w	r8[0x30],r4
8000a6f4:	91 47       	st.w	r8[0x10],r7
8000a6f6:	91 57       	st.w	r8[0x14],r7
8000a6f8:	91 67       	st.w	r8[0x18],r7
8000a6fa:	91 88       	st.w	r8[0x20],r8
8000a6fc:	91 9e       	st.w	r8[0x24],lr
8000a6fe:	91 ab       	st.w	r8[0x28],r11
8000a700:	91 ba       	st.w	r8[0x2c],r10
8000a702:	8d 2c       	st.w	r6[0x8],r12
8000a704:	31 28       	mov	r8,18
8000a706:	99 07       	st.w	r12[0x0],r7
8000a708:	b8 68       	st.h	r12[0xc],r8
8000a70a:	99 17       	st.w	r12[0x4],r7
8000a70c:	99 27       	st.w	r12[0x8],r7
8000a70e:	30 28       	mov	r8,2
8000a710:	b8 78       	st.h	r12[0xe],r8
8000a712:	99 c4       	st.w	r12[0x30],r4
8000a714:	99 67       	st.w	r12[0x18],r7
8000a716:	99 9e       	st.w	r12[0x24],lr
8000a718:	99 ab       	st.w	r12[0x28],r11
8000a71a:	99 ba       	st.w	r12[0x2c],r10
8000a71c:	99 47       	st.w	r12[0x10],r7
8000a71e:	99 57       	st.w	r12[0x14],r7
8000a720:	99 8c       	st.w	r12[0x20],r12
8000a722:	d8 22       	popm	r4-r7,pc

8000a724 <_malloc_trim_r>:
8000a724:	d4 21       	pushm	r4-r7,lr
8000a726:	16 95       	mov	r5,r11
8000a728:	18 97       	mov	r7,r12
8000a72a:	fe b0 d3 71 	rcall	80004e0c <__malloc_lock>
8000a72e:	e0 64 01 1c 	mov	r4,284
8000a732:	68 28       	ld.w	r8,r4[0x8]
8000a734:	70 16       	ld.w	r6,r8[0x4]
8000a736:	e0 16 ff fc 	andl	r6,0xfffc
8000a73a:	ec c8 ff 91 	sub	r8,r6,-111
8000a73e:	f0 05 01 05 	sub	r5,r8,r5
8000a742:	e0 15 ff 80 	andl	r5,0xff80
8000a746:	ea c5 00 80 	sub	r5,r5,128
8000a74a:	e0 45 00 7f 	cp.w	r5,127
8000a74e:	e0 8a 00 25 	brle	8000a798 <_malloc_trim_r+0x74>
8000a752:	30 0b       	mov	r11,0
8000a754:	0e 9c       	mov	r12,r7
8000a756:	fe b0 e5 21 	rcall	80007198 <_sbrk_r>
8000a75a:	68 28       	ld.w	r8,r4[0x8]
8000a75c:	0c 08       	add	r8,r6
8000a75e:	10 3c       	cp.w	r12,r8
8000a760:	c1 c1       	brne	8000a798 <_malloc_trim_r+0x74>
8000a762:	ea 0b 11 00 	rsub	r11,r5,0
8000a766:	0e 9c       	mov	r12,r7
8000a768:	fe b0 e5 18 	rcall	80007198 <_sbrk_r>
8000a76c:	5b fc       	cp.w	r12,-1
8000a76e:	c1 91       	brne	8000a7a0 <_malloc_trim_r+0x7c>
8000a770:	30 0b       	mov	r11,0
8000a772:	0e 9c       	mov	r12,r7
8000a774:	fe b0 e5 12 	rcall	80007198 <_sbrk_r>
8000a778:	68 28       	ld.w	r8,r4[0x8]
8000a77a:	f8 08 01 09 	sub	r9,r12,r8
8000a77e:	58 f9       	cp.w	r9,15
8000a780:	e0 8a 00 0c 	brle	8000a798 <_malloc_trim_r+0x74>
8000a784:	a1 a9       	sbr	r9,0x0
8000a786:	91 19       	st.w	r8[0x4],r9
8000a788:	e0 68 05 28 	mov	r8,1320
8000a78c:	70 09       	ld.w	r9,r8[0x0]
8000a78e:	e0 68 07 a8 	mov	r8,1960
8000a792:	f8 09 01 09 	sub	r9,r12,r9
8000a796:	91 09       	st.w	r8[0x0],r9
8000a798:	0e 9c       	mov	r12,r7
8000a79a:	fe b0 d3 47 	rcall	80004e28 <__malloc_unlock>
8000a79e:	d8 2a       	popm	r4-r7,pc,r12=0
8000a7a0:	68 28       	ld.w	r8,r4[0x8]
8000a7a2:	0a 16       	sub	r6,r5
8000a7a4:	a1 a6       	sbr	r6,0x0
8000a7a6:	91 16       	st.w	r8[0x4],r6
8000a7a8:	e0 68 07 a8 	mov	r8,1960
8000a7ac:	70 09       	ld.w	r9,r8[0x0]
8000a7ae:	0a 19       	sub	r9,r5
8000a7b0:	0e 9c       	mov	r12,r7
8000a7b2:	91 09       	st.w	r8[0x0],r9
8000a7b4:	fe b0 d3 3a 	rcall	80004e28 <__malloc_unlock>
8000a7b8:	da 2a       	popm	r4-r7,pc,r12=1
8000a7ba:	d7 03       	nop

8000a7bc <_free_r>:
8000a7bc:	d4 21       	pushm	r4-r7,lr
8000a7be:	16 96       	mov	r6,r11
8000a7c0:	18 97       	mov	r7,r12
8000a7c2:	58 0b       	cp.w	r11,0
8000a7c4:	e0 80 00 c0 	breq	8000a944 <_free_r+0x188>
8000a7c8:	fe b0 d3 22 	rcall	80004e0c <__malloc_lock>
8000a7cc:	20 86       	sub	r6,8
8000a7ce:	e0 6a 01 1c 	mov	r10,284
8000a7d2:	6c 18       	ld.w	r8,r6[0x4]
8000a7d4:	74 2e       	ld.w	lr,r10[0x8]
8000a7d6:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a7da:	a1 c8       	cbr	r8,0x0
8000a7dc:	ec 08 00 09 	add	r9,r6,r8
8000a7e0:	72 1b       	ld.w	r11,r9[0x4]
8000a7e2:	e0 1b ff fc 	andl	r11,0xfffc
8000a7e6:	1c 39       	cp.w	r9,lr
8000a7e8:	c1 e1       	brne	8000a824 <_free_r+0x68>
8000a7ea:	f6 08 00 08 	add	r8,r11,r8
8000a7ee:	58 0c       	cp.w	r12,0
8000a7f0:	c0 81       	brne	8000a800 <_free_r+0x44>
8000a7f2:	6c 09       	ld.w	r9,r6[0x0]
8000a7f4:	12 16       	sub	r6,r9
8000a7f6:	12 08       	add	r8,r9
8000a7f8:	6c 3b       	ld.w	r11,r6[0xc]
8000a7fa:	6c 29       	ld.w	r9,r6[0x8]
8000a7fc:	97 29       	st.w	r11[0x8],r9
8000a7fe:	93 3b       	st.w	r9[0xc],r11
8000a800:	10 99       	mov	r9,r8
8000a802:	95 26       	st.w	r10[0x8],r6
8000a804:	a1 a9       	sbr	r9,0x0
8000a806:	8d 19       	st.w	r6[0x4],r9
8000a808:	e0 69 05 24 	mov	r9,1316
8000a80c:	72 09       	ld.w	r9,r9[0x0]
8000a80e:	12 38       	cp.w	r8,r9
8000a810:	c0 63       	brcs	8000a81c <_free_r+0x60>
8000a812:	e0 68 07 a4 	mov	r8,1956
8000a816:	0e 9c       	mov	r12,r7
8000a818:	70 0b       	ld.w	r11,r8[0x0]
8000a81a:	c8 5f       	rcall	8000a724 <_malloc_trim_r>
8000a81c:	0e 9c       	mov	r12,r7
8000a81e:	fe b0 d3 05 	rcall	80004e28 <__malloc_unlock>
8000a822:	d8 22       	popm	r4-r7,pc
8000a824:	93 1b       	st.w	r9[0x4],r11
8000a826:	58 0c       	cp.w	r12,0
8000a828:	c0 30       	breq	8000a82e <_free_r+0x72>
8000a82a:	30 0c       	mov	r12,0
8000a82c:	c1 08       	rjmp	8000a84c <_free_r+0x90>
8000a82e:	6c 0e       	ld.w	lr,r6[0x0]
8000a830:	f4 c5 ff f8 	sub	r5,r10,-8
8000a834:	1c 16       	sub	r6,lr
8000a836:	1c 08       	add	r8,lr
8000a838:	6c 2e       	ld.w	lr,r6[0x8]
8000a83a:	0a 3e       	cp.w	lr,r5
8000a83c:	f9 bc 00 01 	moveq	r12,1
8000a840:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a844:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a848:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a84c:	f2 0b 00 0e 	add	lr,r9,r11
8000a850:	7c 1e       	ld.w	lr,lr[0x4]
8000a852:	ed be 00 00 	bld	lr,0x0
8000a856:	c1 40       	breq	8000a87e <_free_r+0xc2>
8000a858:	16 08       	add	r8,r11
8000a85a:	58 0c       	cp.w	r12,0
8000a85c:	c0 d1       	brne	8000a876 <_free_r+0xba>
8000a85e:	e0 6e 01 1c 	mov	lr,284
8000a862:	72 2b       	ld.w	r11,r9[0x8]
8000a864:	2f 8e       	sub	lr,-8
8000a866:	1c 3b       	cp.w	r11,lr
8000a868:	c0 71       	brne	8000a876 <_free_r+0xba>
8000a86a:	97 36       	st.w	r11[0xc],r6
8000a86c:	97 26       	st.w	r11[0x8],r6
8000a86e:	8d 2b       	st.w	r6[0x8],r11
8000a870:	8d 3b       	st.w	r6[0xc],r11
8000a872:	30 1c       	mov	r12,1
8000a874:	c0 58       	rjmp	8000a87e <_free_r+0xc2>
8000a876:	72 2b       	ld.w	r11,r9[0x8]
8000a878:	72 39       	ld.w	r9,r9[0xc]
8000a87a:	93 2b       	st.w	r9[0x8],r11
8000a87c:	97 39       	st.w	r11[0xc],r9
8000a87e:	10 99       	mov	r9,r8
8000a880:	ec 08 09 08 	st.w	r6[r8],r8
8000a884:	a1 a9       	sbr	r9,0x0
8000a886:	8d 19       	st.w	r6[0x4],r9
8000a888:	58 0c       	cp.w	r12,0
8000a88a:	c5 a1       	brne	8000a93e <_free_r+0x182>
8000a88c:	e0 48 01 ff 	cp.w	r8,511
8000a890:	e0 8b 00 13 	brhi	8000a8b6 <_free_r+0xfa>
8000a894:	a3 98       	lsr	r8,0x3
8000a896:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a89a:	72 2b       	ld.w	r11,r9[0x8]
8000a89c:	8d 39       	st.w	r6[0xc],r9
8000a89e:	8d 2b       	st.w	r6[0x8],r11
8000a8a0:	97 36       	st.w	r11[0xc],r6
8000a8a2:	93 26       	st.w	r9[0x8],r6
8000a8a4:	a3 48       	asr	r8,0x2
8000a8a6:	74 19       	ld.w	r9,r10[0x4]
8000a8a8:	30 1b       	mov	r11,1
8000a8aa:	f6 08 09 48 	lsl	r8,r11,r8
8000a8ae:	f3 e8 10 08 	or	r8,r9,r8
8000a8b2:	95 18       	st.w	r10[0x4],r8
8000a8b4:	c4 58       	rjmp	8000a93e <_free_r+0x182>
8000a8b6:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a8ba:	58 4b       	cp.w	r11,4
8000a8bc:	e0 8b 00 06 	brhi	8000a8c8 <_free_r+0x10c>
8000a8c0:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a8c4:	2c 8b       	sub	r11,-56
8000a8c6:	c2 08       	rjmp	8000a906 <_free_r+0x14a>
8000a8c8:	59 4b       	cp.w	r11,20
8000a8ca:	e0 8b 00 04 	brhi	8000a8d2 <_free_r+0x116>
8000a8ce:	2a 5b       	sub	r11,-91
8000a8d0:	c1 b8       	rjmp	8000a906 <_free_r+0x14a>
8000a8d2:	e0 4b 00 54 	cp.w	r11,84
8000a8d6:	e0 8b 00 06 	brhi	8000a8e2 <_free_r+0x126>
8000a8da:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a8de:	29 2b       	sub	r11,-110
8000a8e0:	c1 38       	rjmp	8000a906 <_free_r+0x14a>
8000a8e2:	e0 4b 01 54 	cp.w	r11,340
8000a8e6:	e0 8b 00 06 	brhi	8000a8f2 <_free_r+0x136>
8000a8ea:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a8ee:	28 9b       	sub	r11,-119
8000a8f0:	c0 b8       	rjmp	8000a906 <_free_r+0x14a>
8000a8f2:	e0 4b 05 54 	cp.w	r11,1364
8000a8f6:	e0 88 00 05 	brls	8000a900 <_free_r+0x144>
8000a8fa:	37 eb       	mov	r11,126
8000a8fc:	c0 58       	rjmp	8000a906 <_free_r+0x14a>
8000a8fe:	d7 03       	nop
8000a900:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a904:	28 4b       	sub	r11,-124
8000a906:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a90a:	78 29       	ld.w	r9,r12[0x8]
8000a90c:	18 39       	cp.w	r9,r12
8000a90e:	c0 e1       	brne	8000a92a <_free_r+0x16e>
8000a910:	74 18       	ld.w	r8,r10[0x4]
8000a912:	a3 4b       	asr	r11,0x2
8000a914:	30 1c       	mov	r12,1
8000a916:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a91a:	f1 eb 10 0b 	or	r11,r8,r11
8000a91e:	12 98       	mov	r8,r9
8000a920:	95 1b       	st.w	r10[0x4],r11
8000a922:	c0 a8       	rjmp	8000a936 <_free_r+0x17a>
8000a924:	72 29       	ld.w	r9,r9[0x8]
8000a926:	18 39       	cp.w	r9,r12
8000a928:	c0 60       	breq	8000a934 <_free_r+0x178>
8000a92a:	72 1a       	ld.w	r10,r9[0x4]
8000a92c:	e0 1a ff fc 	andl	r10,0xfffc
8000a930:	14 38       	cp.w	r8,r10
8000a932:	cf 93       	brcs	8000a924 <_free_r+0x168>
8000a934:	72 38       	ld.w	r8,r9[0xc]
8000a936:	8d 38       	st.w	r6[0xc],r8
8000a938:	8d 29       	st.w	r6[0x8],r9
8000a93a:	93 36       	st.w	r9[0xc],r6
8000a93c:	91 26       	st.w	r8[0x8],r6
8000a93e:	0e 9c       	mov	r12,r7
8000a940:	fe b0 d2 74 	rcall	80004e28 <__malloc_unlock>
8000a944:	d8 22       	popm	r4-r7,pc
8000a946:	d7 03       	nop

8000a948 <__sfvwrite_r>:
8000a948:	d4 31       	pushm	r0-r7,lr
8000a94a:	20 3d       	sub	sp,12
8000a94c:	14 94       	mov	r4,r10
8000a94e:	18 95       	mov	r5,r12
8000a950:	16 97       	mov	r7,r11
8000a952:	74 28       	ld.w	r8,r10[0x8]
8000a954:	58 08       	cp.w	r8,0
8000a956:	e0 80 01 40 	breq	8000abd6 <__sfvwrite_r+0x28e>
8000a95a:	96 68       	ld.sh	r8,r11[0xc]
8000a95c:	ed b8 00 03 	bld	r8,0x3
8000a960:	c0 41       	brne	8000a968 <__sfvwrite_r+0x20>
8000a962:	76 48       	ld.w	r8,r11[0x10]
8000a964:	58 08       	cp.w	r8,0
8000a966:	c0 c1       	brne	8000a97e <__sfvwrite_r+0x36>
8000a968:	0e 9b       	mov	r11,r7
8000a96a:	0a 9c       	mov	r12,r5
8000a96c:	fe b0 f6 0c 	rcall	80009584 <__swsetup_r>
8000a970:	c0 70       	breq	8000a97e <__sfvwrite_r+0x36>
8000a972:	8e 68       	ld.sh	r8,r7[0xc]
8000a974:	a7 a8       	sbr	r8,0x6
8000a976:	ae 68       	st.h	r7[0xc],r8
8000a978:	30 98       	mov	r8,9
8000a97a:	8b 38       	st.w	r5[0xc],r8
8000a97c:	c2 b9       	rjmp	8000abd2 <__sfvwrite_r+0x28a>
8000a97e:	8e 63       	ld.sh	r3,r7[0xc]
8000a980:	68 00       	ld.w	r0,r4[0x0]
8000a982:	06 96       	mov	r6,r3
8000a984:	e2 16 00 02 	andl	r6,0x2,COH
8000a988:	c2 10       	breq	8000a9ca <__sfvwrite_r+0x82>
8000a98a:	30 03       	mov	r3,0
8000a98c:	e0 62 04 00 	mov	r2,1024
8000a990:	06 96       	mov	r6,r3
8000a992:	c0 48       	rjmp	8000a99a <__sfvwrite_r+0x52>
8000a994:	60 03       	ld.w	r3,r0[0x0]
8000a996:	60 16       	ld.w	r6,r0[0x4]
8000a998:	2f 80       	sub	r0,-8
8000a99a:	58 06       	cp.w	r6,0
8000a99c:	cf c0       	breq	8000a994 <__sfvwrite_r+0x4c>
8000a99e:	e0 46 04 00 	cp.w	r6,1024
8000a9a2:	ec 09 17 80 	movls	r9,r6
8000a9a6:	e4 09 17 b0 	movhi	r9,r2
8000a9aa:	06 9a       	mov	r10,r3
8000a9ac:	6e a8       	ld.w	r8,r7[0x28]
8000a9ae:	6e 8b       	ld.w	r11,r7[0x20]
8000a9b0:	0a 9c       	mov	r12,r5
8000a9b2:	5d 18       	icall	r8
8000a9b4:	18 16       	sub	r6,r12
8000a9b6:	58 0c       	cp.w	r12,0
8000a9b8:	e0 8a 01 0a 	brle	8000abcc <__sfvwrite_r+0x284>
8000a9bc:	68 28       	ld.w	r8,r4[0x8]
8000a9be:	18 18       	sub	r8,r12
8000a9c0:	89 28       	st.w	r4[0x8],r8
8000a9c2:	e0 80 01 0a 	breq	8000abd6 <__sfvwrite_r+0x28e>
8000a9c6:	18 03       	add	r3,r12
8000a9c8:	ce 9b       	rjmp	8000a99a <__sfvwrite_r+0x52>
8000a9ca:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a9ce:	c0 70       	breq	8000a9dc <__sfvwrite_r+0x94>
8000a9d0:	50 06       	stdsp	sp[0x0],r6
8000a9d2:	0c 93       	mov	r3,r6
8000a9d4:	0c 91       	mov	r1,r6
8000a9d6:	50 15       	stdsp	sp[0x4],r5
8000a9d8:	08 92       	mov	r2,r4
8000a9da:	c9 c8       	rjmp	8000ab12 <__sfvwrite_r+0x1ca>
8000a9dc:	06 96       	mov	r6,r3
8000a9de:	08 91       	mov	r1,r4
8000a9e0:	c0 48       	rjmp	8000a9e8 <__sfvwrite_r+0xa0>
8000a9e2:	60 03       	ld.w	r3,r0[0x0]
8000a9e4:	60 16       	ld.w	r6,r0[0x4]
8000a9e6:	2f 80       	sub	r0,-8
8000a9e8:	58 06       	cp.w	r6,0
8000a9ea:	cf c0       	breq	8000a9e2 <__sfvwrite_r+0x9a>
8000a9ec:	8e 68       	ld.sh	r8,r7[0xc]
8000a9ee:	6e 24       	ld.w	r4,r7[0x8]
8000a9f0:	10 99       	mov	r9,r8
8000a9f2:	e2 19 02 00 	andl	r9,0x200,COH
8000a9f6:	c5 50       	breq	8000aaa0 <__sfvwrite_r+0x158>
8000a9f8:	08 36       	cp.w	r6,r4
8000a9fa:	c4 43       	brcs	8000aa82 <__sfvwrite_r+0x13a>
8000a9fc:	10 99       	mov	r9,r8
8000a9fe:	e2 19 04 80 	andl	r9,0x480,COH
8000aa02:	c4 00       	breq	8000aa82 <__sfvwrite_r+0x13a>
8000aa04:	6e 4b       	ld.w	r11,r7[0x10]
8000aa06:	6e 09       	ld.w	r9,r7[0x0]
8000aa08:	16 19       	sub	r9,r11
8000aa0a:	50 09       	stdsp	sp[0x0],r9
8000aa0c:	6e 59       	ld.w	r9,r7[0x14]
8000aa0e:	10 9c       	mov	r12,r8
8000aa10:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000aa14:	30 28       	mov	r8,2
8000aa16:	f4 08 0c 08 	divs	r8,r10,r8
8000aa1a:	fa e9 00 04 	st.d	sp[4],r8
8000aa1e:	10 94       	mov	r4,r8
8000aa20:	40 09       	lddsp	r9,sp[0x0]
8000aa22:	e2 1c 04 00 	andl	r12,0x400,COH
8000aa26:	2f f9       	sub	r9,-1
8000aa28:	0c 09       	add	r9,r6
8000aa2a:	12 38       	cp.w	r8,r9
8000aa2c:	f2 04 17 30 	movlo	r4,r9
8000aa30:	58 0c       	cp.w	r12,0
8000aa32:	c1 10       	breq	8000aa54 <__sfvwrite_r+0x10c>
8000aa34:	08 9b       	mov	r11,r4
8000aa36:	0a 9c       	mov	r12,r5
8000aa38:	fe b0 df 88 	rcall	80006948 <_malloc_r>
8000aa3c:	18 92       	mov	r2,r12
8000aa3e:	c1 40       	breq	8000aa66 <__sfvwrite_r+0x11e>
8000aa40:	40 0a       	lddsp	r10,sp[0x0]
8000aa42:	6e 4b       	ld.w	r11,r7[0x10]
8000aa44:	fe b0 e1 9e 	rcall	80006d80 <memcpy>
8000aa48:	8e 68       	ld.sh	r8,r7[0xc]
8000aa4a:	e0 18 fb 7f 	andl	r8,0xfb7f
8000aa4e:	a7 b8       	sbr	r8,0x7
8000aa50:	ae 68       	st.h	r7[0xc],r8
8000aa52:	c0 d8       	rjmp	8000aa6c <__sfvwrite_r+0x124>
8000aa54:	08 9a       	mov	r10,r4
8000aa56:	0a 9c       	mov	r12,r5
8000aa58:	fe b0 e2 40 	rcall	80006ed8 <_realloc_r>
8000aa5c:	18 92       	mov	r2,r12
8000aa5e:	c0 71       	brne	8000aa6c <__sfvwrite_r+0x124>
8000aa60:	6e 4b       	ld.w	r11,r7[0x10]
8000aa62:	0a 9c       	mov	r12,r5
8000aa64:	ca ce       	rcall	8000a7bc <_free_r>
8000aa66:	30 c8       	mov	r8,12
8000aa68:	8b 38       	st.w	r5[0xc],r8
8000aa6a:	cb 18       	rjmp	8000abcc <__sfvwrite_r+0x284>
8000aa6c:	40 0a       	lddsp	r10,sp[0x0]
8000aa6e:	40 09       	lddsp	r9,sp[0x0]
8000aa70:	e8 0a 01 0a 	sub	r10,r4,r10
8000aa74:	e4 09 00 08 	add	r8,r2,r9
8000aa78:	8f 54       	st.w	r7[0x14],r4
8000aa7a:	8f 2a       	st.w	r7[0x8],r10
8000aa7c:	8f 08       	st.w	r7[0x0],r8
8000aa7e:	8f 42       	st.w	r7[0x10],r2
8000aa80:	0c 94       	mov	r4,r6
8000aa82:	08 36       	cp.w	r6,r4
8000aa84:	ec 04 17 30 	movlo	r4,r6
8000aa88:	06 9b       	mov	r11,r3
8000aa8a:	08 9a       	mov	r10,r4
8000aa8c:	6e 0c       	ld.w	r12,r7[0x0]
8000aa8e:	c3 ad       	rcall	8000ad02 <memmove>
8000aa90:	6e 08       	ld.w	r8,r7[0x0]
8000aa92:	08 08       	add	r8,r4
8000aa94:	8f 08       	st.w	r7[0x0],r8
8000aa96:	6e 28       	ld.w	r8,r7[0x8]
8000aa98:	08 18       	sub	r8,r4
8000aa9a:	0c 94       	mov	r4,r6
8000aa9c:	8f 28       	st.w	r7[0x8],r8
8000aa9e:	c2 e8       	rjmp	8000aafa <__sfvwrite_r+0x1b2>
8000aaa0:	08 36       	cp.w	r6,r4
8000aaa2:	5f ba       	srhi	r10
8000aaa4:	6e 0c       	ld.w	r12,r7[0x0]
8000aaa6:	6e 48       	ld.w	r8,r7[0x10]
8000aaa8:	10 3c       	cp.w	r12,r8
8000aaaa:	5f b8       	srhi	r8
8000aaac:	f5 e8 00 08 	and	r8,r10,r8
8000aab0:	f2 08 18 00 	cp.b	r8,r9
8000aab4:	c0 d0       	breq	8000aace <__sfvwrite_r+0x186>
8000aab6:	06 9b       	mov	r11,r3
8000aab8:	08 9a       	mov	r10,r4
8000aaba:	c2 4d       	rcall	8000ad02 <memmove>
8000aabc:	6e 08       	ld.w	r8,r7[0x0]
8000aabe:	08 08       	add	r8,r4
8000aac0:	0e 9b       	mov	r11,r7
8000aac2:	8f 08       	st.w	r7[0x0],r8
8000aac4:	0a 9c       	mov	r12,r5
8000aac6:	fe b0 fd 09 	rcall	8000a4d8 <_fflush_r>
8000aaca:	c1 80       	breq	8000aafa <__sfvwrite_r+0x1b2>
8000aacc:	c8 08       	rjmp	8000abcc <__sfvwrite_r+0x284>
8000aace:	6e 59       	ld.w	r9,r7[0x14]
8000aad0:	12 36       	cp.w	r6,r9
8000aad2:	c0 a3       	brcs	8000aae6 <__sfvwrite_r+0x19e>
8000aad4:	6e a8       	ld.w	r8,r7[0x28]
8000aad6:	06 9a       	mov	r10,r3
8000aad8:	6e 8b       	ld.w	r11,r7[0x20]
8000aada:	0a 9c       	mov	r12,r5
8000aadc:	5d 18       	icall	r8
8000aade:	18 94       	mov	r4,r12
8000aae0:	e0 89 00 0d 	brgt	8000aafa <__sfvwrite_r+0x1b2>
8000aae4:	c7 48       	rjmp	8000abcc <__sfvwrite_r+0x284>
8000aae6:	0c 9a       	mov	r10,r6
8000aae8:	06 9b       	mov	r11,r3
8000aaea:	c0 cd       	rcall	8000ad02 <memmove>
8000aaec:	6e 08       	ld.w	r8,r7[0x0]
8000aaee:	0c 08       	add	r8,r6
8000aaf0:	0c 94       	mov	r4,r6
8000aaf2:	8f 08       	st.w	r7[0x0],r8
8000aaf4:	6e 28       	ld.w	r8,r7[0x8]
8000aaf6:	0c 18       	sub	r8,r6
8000aaf8:	8f 28       	st.w	r7[0x8],r8
8000aafa:	62 28       	ld.w	r8,r1[0x8]
8000aafc:	08 18       	sub	r8,r4
8000aafe:	83 28       	st.w	r1[0x8],r8
8000ab00:	c6 b0       	breq	8000abd6 <__sfvwrite_r+0x28e>
8000ab02:	08 16       	sub	r6,r4
8000ab04:	08 03       	add	r3,r4
8000ab06:	c7 1b       	rjmp	8000a9e8 <__sfvwrite_r+0xa0>
8000ab08:	60 03       	ld.w	r3,r0[0x0]
8000ab0a:	60 11       	ld.w	r1,r0[0x4]
8000ab0c:	30 08       	mov	r8,0
8000ab0e:	2f 80       	sub	r0,-8
8000ab10:	50 08       	stdsp	sp[0x0],r8
8000ab12:	58 01       	cp.w	r1,0
8000ab14:	cf a0       	breq	8000ab08 <__sfvwrite_r+0x1c0>
8000ab16:	40 0a       	lddsp	r10,sp[0x0]
8000ab18:	58 0a       	cp.w	r10,0
8000ab1a:	c1 41       	brne	8000ab42 <__sfvwrite_r+0x1fa>
8000ab1c:	e2 c6 ff ff 	sub	r6,r1,-1
8000ab20:	02 9a       	mov	r10,r1
8000ab22:	30 ab       	mov	r11,10
8000ab24:	06 9c       	mov	r12,r3
8000ab26:	ce 3c       	rcall	8000acec <memchr>
8000ab28:	f8 c8 ff ff 	sub	r8,r12,-1
8000ab2c:	58 0c       	cp.w	r12,0
8000ab2e:	f1 d3 e1 16 	subne	r6,r8,r3
8000ab32:	f9 b9 01 01 	movne	r9,1
8000ab36:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ab3a:	f9 b8 00 01 	moveq	r8,1
8000ab3e:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000ab42:	02 36       	cp.w	r6,r1
8000ab44:	ec 04 17 80 	movls	r4,r6
8000ab48:	e2 04 17 b0 	movhi	r4,r1
8000ab4c:	6e 59       	ld.w	r9,r7[0x14]
8000ab4e:	6e 25       	ld.w	r5,r7[0x8]
8000ab50:	f2 05 00 05 	add	r5,r9,r5
8000ab54:	0a 34       	cp.w	r4,r5
8000ab56:	5f 9a       	srgt	r10
8000ab58:	6e 0c       	ld.w	r12,r7[0x0]
8000ab5a:	6e 48       	ld.w	r8,r7[0x10]
8000ab5c:	10 3c       	cp.w	r12,r8
8000ab5e:	5f b8       	srhi	r8
8000ab60:	f5 e8 00 08 	and	r8,r10,r8
8000ab64:	30 0a       	mov	r10,0
8000ab66:	f4 08 18 00 	cp.b	r8,r10
8000ab6a:	c0 d0       	breq	8000ab84 <__sfvwrite_r+0x23c>
8000ab6c:	06 9b       	mov	r11,r3
8000ab6e:	0a 9a       	mov	r10,r5
8000ab70:	cc 9c       	rcall	8000ad02 <memmove>
8000ab72:	6e 08       	ld.w	r8,r7[0x0]
8000ab74:	0a 08       	add	r8,r5
8000ab76:	0e 9b       	mov	r11,r7
8000ab78:	8f 08       	st.w	r7[0x0],r8
8000ab7a:	40 1c       	lddsp	r12,sp[0x4]
8000ab7c:	fe b0 fc ae 	rcall	8000a4d8 <_fflush_r>
8000ab80:	c1 70       	breq	8000abae <__sfvwrite_r+0x266>
8000ab82:	c2 58       	rjmp	8000abcc <__sfvwrite_r+0x284>
8000ab84:	12 34       	cp.w	r4,r9
8000ab86:	c0 a5       	brlt	8000ab9a <__sfvwrite_r+0x252>
8000ab88:	6e a8       	ld.w	r8,r7[0x28]
8000ab8a:	06 9a       	mov	r10,r3
8000ab8c:	6e 8b       	ld.w	r11,r7[0x20]
8000ab8e:	40 1c       	lddsp	r12,sp[0x4]
8000ab90:	5d 18       	icall	r8
8000ab92:	18 95       	mov	r5,r12
8000ab94:	e0 89 00 0d 	brgt	8000abae <__sfvwrite_r+0x266>
8000ab98:	c1 a8       	rjmp	8000abcc <__sfvwrite_r+0x284>
8000ab9a:	08 9a       	mov	r10,r4
8000ab9c:	06 9b       	mov	r11,r3
8000ab9e:	cb 2c       	rcall	8000ad02 <memmove>
8000aba0:	6e 08       	ld.w	r8,r7[0x0]
8000aba2:	08 08       	add	r8,r4
8000aba4:	08 95       	mov	r5,r4
8000aba6:	8f 08       	st.w	r7[0x0],r8
8000aba8:	6e 28       	ld.w	r8,r7[0x8]
8000abaa:	08 18       	sub	r8,r4
8000abac:	8f 28       	st.w	r7[0x8],r8
8000abae:	0a 16       	sub	r6,r5
8000abb0:	c0 71       	brne	8000abbe <__sfvwrite_r+0x276>
8000abb2:	0e 9b       	mov	r11,r7
8000abb4:	40 1c       	lddsp	r12,sp[0x4]
8000abb6:	fe b0 fc 91 	rcall	8000a4d8 <_fflush_r>
8000abba:	c0 91       	brne	8000abcc <__sfvwrite_r+0x284>
8000abbc:	50 06       	stdsp	sp[0x0],r6
8000abbe:	64 28       	ld.w	r8,r2[0x8]
8000abc0:	0a 18       	sub	r8,r5
8000abc2:	85 28       	st.w	r2[0x8],r8
8000abc4:	c0 90       	breq	8000abd6 <__sfvwrite_r+0x28e>
8000abc6:	0a 11       	sub	r1,r5
8000abc8:	0a 03       	add	r3,r5
8000abca:	ca 4b       	rjmp	8000ab12 <__sfvwrite_r+0x1ca>
8000abcc:	8e 68       	ld.sh	r8,r7[0xc]
8000abce:	a7 a8       	sbr	r8,0x6
8000abd0:	ae 68       	st.h	r7[0xc],r8
8000abd2:	3f fc       	mov	r12,-1
8000abd4:	c0 28       	rjmp	8000abd8 <__sfvwrite_r+0x290>
8000abd6:	30 0c       	mov	r12,0
8000abd8:	2f dd       	sub	sp,-12
8000abda:	d8 32       	popm	r0-r7,pc

8000abdc <_fwalk>:
8000abdc:	d4 31       	pushm	r0-r7,lr
8000abde:	30 05       	mov	r5,0
8000abe0:	16 91       	mov	r1,r11
8000abe2:	f8 c7 ff 28 	sub	r7,r12,-216
8000abe6:	0a 92       	mov	r2,r5
8000abe8:	fe b0 fc fe 	rcall	8000a5e4 <__sfp_lock_acquire>
8000abec:	3f f3       	mov	r3,-1
8000abee:	c1 68       	rjmp	8000ac1a <_fwalk+0x3e>
8000abf0:	6e 26       	ld.w	r6,r7[0x8]
8000abf2:	6e 14       	ld.w	r4,r7[0x4]
8000abf4:	2f 46       	sub	r6,-12
8000abf6:	c0 c8       	rjmp	8000ac0e <_fwalk+0x32>
8000abf8:	8c 08       	ld.sh	r8,r6[0x0]
8000abfa:	e4 08 19 00 	cp.h	r8,r2
8000abfe:	c0 70       	breq	8000ac0c <_fwalk+0x30>
8000ac00:	8c 18       	ld.sh	r8,r6[0x2]
8000ac02:	e6 08 19 00 	cp.h	r8,r3
8000ac06:	c0 30       	breq	8000ac0c <_fwalk+0x30>
8000ac08:	5d 11       	icall	r1
8000ac0a:	18 45       	or	r5,r12
8000ac0c:	2a 46       	sub	r6,-92
8000ac0e:	20 14       	sub	r4,1
8000ac10:	ec cc 00 0c 	sub	r12,r6,12
8000ac14:	58 04       	cp.w	r4,0
8000ac16:	cf 14       	brge	8000abf8 <_fwalk+0x1c>
8000ac18:	6e 07       	ld.w	r7,r7[0x0]
8000ac1a:	58 07       	cp.w	r7,0
8000ac1c:	ce a1       	brne	8000abf0 <_fwalk+0x14>
8000ac1e:	fe b0 fc e4 	rcall	8000a5e6 <__sfp_lock_release>
8000ac22:	0a 9c       	mov	r12,r5
8000ac24:	d8 32       	popm	r0-r7,pc
8000ac26:	d7 03       	nop

8000ac28 <_localeconv_r>:
8000ac28:	fe cc e2 ac 	sub	r12,pc,-7508
8000ac2c:	5e fc       	retal	r12
8000ac2e:	d7 03       	nop

8000ac30 <__smakebuf_r>:
8000ac30:	d4 21       	pushm	r4-r7,lr
8000ac32:	20 fd       	sub	sp,60
8000ac34:	96 68       	ld.sh	r8,r11[0xc]
8000ac36:	16 97       	mov	r7,r11
8000ac38:	18 96       	mov	r6,r12
8000ac3a:	e2 18 00 02 	andl	r8,0x2,COH
8000ac3e:	c3 d1       	brne	8000acb8 <__smakebuf_r+0x88>
8000ac40:	96 7b       	ld.sh	r11,r11[0xe]
8000ac42:	f0 0b 19 00 	cp.h	r11,r8
8000ac46:	c0 55       	brlt	8000ac50 <__smakebuf_r+0x20>
8000ac48:	1a 9a       	mov	r10,sp
8000ac4a:	e0 a0 04 81 	rcall	8000b54c <_fstat_r>
8000ac4e:	c0 f4       	brge	8000ac6c <__smakebuf_r+0x3c>
8000ac50:	8e 65       	ld.sh	r5,r7[0xc]
8000ac52:	0a 98       	mov	r8,r5
8000ac54:	ab b8       	sbr	r8,0xb
8000ac56:	e2 15 00 80 	andl	r5,0x80,COH
8000ac5a:	ae 68       	st.h	r7[0xc],r8
8000ac5c:	30 04       	mov	r4,0
8000ac5e:	e0 68 04 00 	mov	r8,1024
8000ac62:	f9 b5 01 40 	movne	r5,64
8000ac66:	f0 05 17 00 	moveq	r5,r8
8000ac6a:	c1 c8       	rjmp	8000aca2 <__smakebuf_r+0x72>
8000ac6c:	40 18       	lddsp	r8,sp[0x4]
8000ac6e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000ac72:	e0 48 20 00 	cp.w	r8,8192
8000ac76:	5f 04       	sreq	r4
8000ac78:	e0 48 80 00 	cp.w	r8,32768
8000ac7c:	c0 e1       	brne	8000ac98 <__smakebuf_r+0x68>
8000ac7e:	6e b9       	ld.w	r9,r7[0x2c]
8000ac80:	fe c8 f9 1c 	sub	r8,pc,-1764
8000ac84:	10 39       	cp.w	r9,r8
8000ac86:	c0 91       	brne	8000ac98 <__smakebuf_r+0x68>
8000ac88:	8e 68       	ld.sh	r8,r7[0xc]
8000ac8a:	e0 65 04 00 	mov	r5,1024
8000ac8e:	ab a8       	sbr	r8,0xa
8000ac90:	ef 45 00 50 	st.w	r7[80],r5
8000ac94:	ae 68       	st.h	r7[0xc],r8
8000ac96:	c0 68       	rjmp	8000aca2 <__smakebuf_r+0x72>
8000ac98:	8e 68       	ld.sh	r8,r7[0xc]
8000ac9a:	e0 65 04 00 	mov	r5,1024
8000ac9e:	ab b8       	sbr	r8,0xb
8000aca0:	ae 68       	st.h	r7[0xc],r8
8000aca2:	0a 9b       	mov	r11,r5
8000aca4:	0c 9c       	mov	r12,r6
8000aca6:	fe b0 de 51 	rcall	80006948 <_malloc_r>
8000acaa:	8e 68       	ld.sh	r8,r7[0xc]
8000acac:	c0 d1       	brne	8000acc6 <__smakebuf_r+0x96>
8000acae:	ed b8 00 09 	bld	r8,0x9
8000acb2:	c1 b0       	breq	8000ace8 <__smakebuf_r+0xb8>
8000acb4:	a1 b8       	sbr	r8,0x1
8000acb6:	ae 68       	st.h	r7[0xc],r8
8000acb8:	ee c8 ff b9 	sub	r8,r7,-71
8000acbc:	8f 48       	st.w	r7[0x10],r8
8000acbe:	8f 08       	st.w	r7[0x0],r8
8000acc0:	30 18       	mov	r8,1
8000acc2:	8f 58       	st.w	r7[0x14],r8
8000acc4:	c1 28       	rjmp	8000ace8 <__smakebuf_r+0xb8>
8000acc6:	a7 b8       	sbr	r8,0x7
8000acc8:	8f 4c       	st.w	r7[0x10],r12
8000acca:	ae 68       	st.h	r7[0xc],r8
8000accc:	8f 55       	st.w	r7[0x14],r5
8000acce:	fe c8 06 e6 	sub	r8,pc,1766
8000acd2:	8f 0c       	st.w	r7[0x0],r12
8000acd4:	8d a8       	st.w	r6[0x28],r8
8000acd6:	58 04       	cp.w	r4,0
8000acd8:	c0 80       	breq	8000ace8 <__smakebuf_r+0xb8>
8000acda:	8e 7c       	ld.sh	r12,r7[0xe]
8000acdc:	fe b0 e2 ba 	rcall	80007250 <isatty>
8000ace0:	c0 40       	breq	8000ace8 <__smakebuf_r+0xb8>
8000ace2:	8e 68       	ld.sh	r8,r7[0xc]
8000ace4:	a1 a8       	sbr	r8,0x0
8000ace6:	ae 68       	st.h	r7[0xc],r8
8000ace8:	2f 1d       	sub	sp,-60
8000acea:	d8 22       	popm	r4-r7,pc

8000acec <memchr>:
8000acec:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000acf0:	c0 68       	rjmp	8000acfc <memchr+0x10>
8000acf2:	20 1a       	sub	r10,1
8000acf4:	19 88       	ld.ub	r8,r12[0x0]
8000acf6:	16 38       	cp.w	r8,r11
8000acf8:	5e 0c       	reteq	r12
8000acfa:	2f fc       	sub	r12,-1
8000acfc:	58 0a       	cp.w	r10,0
8000acfe:	cf a1       	brne	8000acf2 <memchr+0x6>
8000ad00:	5e fa       	retal	r10

8000ad02 <memmove>:
8000ad02:	d4 01       	pushm	lr
8000ad04:	18 3b       	cp.w	r11,r12
8000ad06:	c1 92       	brcc	8000ad38 <memmove+0x36>
8000ad08:	f6 0a 00 09 	add	r9,r11,r10
8000ad0c:	12 3c       	cp.w	r12,r9
8000ad0e:	c1 52       	brcc	8000ad38 <memmove+0x36>
8000ad10:	f8 0a 00 0b 	add	r11,r12,r10
8000ad14:	30 08       	mov	r8,0
8000ad16:	c0 68       	rjmp	8000ad22 <memmove+0x20>
8000ad18:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000ad1c:	20 1a       	sub	r10,1
8000ad1e:	f6 08 0b 0e 	st.b	r11[r8],lr
8000ad22:	20 18       	sub	r8,1
8000ad24:	58 0a       	cp.w	r10,0
8000ad26:	cf 91       	brne	8000ad18 <memmove+0x16>
8000ad28:	d8 02       	popm	pc
8000ad2a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000ad2e:	20 1a       	sub	r10,1
8000ad30:	f8 08 0b 09 	st.b	r12[r8],r9
8000ad34:	2f f8       	sub	r8,-1
8000ad36:	c0 28       	rjmp	8000ad3a <memmove+0x38>
8000ad38:	30 08       	mov	r8,0
8000ad3a:	58 0a       	cp.w	r10,0
8000ad3c:	cf 71       	brne	8000ad2a <memmove+0x28>
8000ad3e:	d8 02       	popm	pc

8000ad40 <__hi0bits>:
8000ad40:	18 98       	mov	r8,r12
8000ad42:	e0 1c 00 00 	andl	r12,0x0
8000ad46:	f0 09 15 10 	lsl	r9,r8,0x10
8000ad4a:	58 0c       	cp.w	r12,0
8000ad4c:	f2 08 17 00 	moveq	r8,r9
8000ad50:	f9 bc 00 10 	moveq	r12,16
8000ad54:	f9 bc 01 00 	movne	r12,0
8000ad58:	10 9a       	mov	r10,r8
8000ad5a:	f0 09 15 08 	lsl	r9,r8,0x8
8000ad5e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000ad62:	f7 bc 00 f8 	subeq	r12,-8
8000ad66:	f2 08 17 00 	moveq	r8,r9
8000ad6a:	10 9a       	mov	r10,r8
8000ad6c:	f0 09 15 04 	lsl	r9,r8,0x4
8000ad70:	e6 1a f0 00 	andh	r10,0xf000,COH
8000ad74:	f7 bc 00 fc 	subeq	r12,-4
8000ad78:	f2 08 17 00 	moveq	r8,r9
8000ad7c:	10 9a       	mov	r10,r8
8000ad7e:	f0 09 15 02 	lsl	r9,r8,0x2
8000ad82:	e6 1a c0 00 	andh	r10,0xc000,COH
8000ad86:	f7 bc 00 fe 	subeq	r12,-2
8000ad8a:	f2 08 17 00 	moveq	r8,r9
8000ad8e:	58 08       	cp.w	r8,0
8000ad90:	5e 5c       	retlt	r12
8000ad92:	ed b8 00 1e 	bld	r8,0x1e
8000ad96:	f9 bc 01 20 	movne	r12,32
8000ad9a:	f7 bc 00 ff 	subeq	r12,-1
8000ad9e:	5e fc       	retal	r12

8000ada0 <__lo0bits>:
8000ada0:	18 99       	mov	r9,r12
8000ada2:	78 08       	ld.w	r8,r12[0x0]
8000ada4:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000ada8:	c1 50       	breq	8000add2 <__lo0bits+0x32>
8000adaa:	ed b8 00 00 	bld	r8,0x0
8000adae:	c0 21       	brne	8000adb2 <__lo0bits+0x12>
8000adb0:	5e fd       	retal	0
8000adb2:	10 9b       	mov	r11,r8
8000adb4:	f0 0a 16 01 	lsr	r10,r8,0x1
8000adb8:	e2 1b 00 02 	andl	r11,0x2,COH
8000adbc:	a3 88       	lsr	r8,0x2
8000adbe:	58 0b       	cp.w	r11,0
8000adc0:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000adc4:	f9 bc 01 01 	movne	r12,1
8000adc8:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000adcc:	f9 bc 00 02 	moveq	r12,2
8000add0:	5e fc       	retal	r12
8000add2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000add6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000adda:	58 0a       	cp.w	r10,0
8000addc:	f6 08 17 00 	moveq	r8,r11
8000ade0:	f9 bc 00 10 	moveq	r12,16
8000ade4:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000ade8:	f0 0a 16 08 	lsr	r10,r8,0x8
8000adec:	58 0b       	cp.w	r11,0
8000adee:	f7 bc 00 f8 	subeq	r12,-8
8000adf2:	f4 08 17 00 	moveq	r8,r10
8000adf6:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000adfa:	f0 0a 16 04 	lsr	r10,r8,0x4
8000adfe:	58 0b       	cp.w	r11,0
8000ae00:	f7 bc 00 fc 	subeq	r12,-4
8000ae04:	f4 08 17 00 	moveq	r8,r10
8000ae08:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000ae0c:	f0 0a 16 02 	lsr	r10,r8,0x2
8000ae10:	58 0b       	cp.w	r11,0
8000ae12:	f7 bc 00 fe 	subeq	r12,-2
8000ae16:	f4 08 17 00 	moveq	r8,r10
8000ae1a:	ed b8 00 00 	bld	r8,0x0
8000ae1e:	c0 60       	breq	8000ae2a <__lo0bits+0x8a>
8000ae20:	a1 98       	lsr	r8,0x1
8000ae22:	c0 31       	brne	8000ae28 <__lo0bits+0x88>
8000ae24:	32 0c       	mov	r12,32
8000ae26:	5e fc       	retal	r12
8000ae28:	2f fc       	sub	r12,-1
8000ae2a:	93 08       	st.w	r9[0x0],r8
8000ae2c:	5e fc       	retal	r12

8000ae2e <__mcmp>:
8000ae2e:	d4 01       	pushm	lr
8000ae30:	18 98       	mov	r8,r12
8000ae32:	76 49       	ld.w	r9,r11[0x10]
8000ae34:	78 4c       	ld.w	r12,r12[0x10]
8000ae36:	12 1c       	sub	r12,r9
8000ae38:	c1 31       	brne	8000ae5e <__mcmp+0x30>
8000ae3a:	2f b9       	sub	r9,-5
8000ae3c:	a3 69       	lsl	r9,0x2
8000ae3e:	12 0b       	add	r11,r9
8000ae40:	f0 09 00 09 	add	r9,r8,r9
8000ae44:	2e c8       	sub	r8,-20
8000ae46:	13 4e       	ld.w	lr,--r9
8000ae48:	17 4a       	ld.w	r10,--r11
8000ae4a:	14 3e       	cp.w	lr,r10
8000ae4c:	c0 60       	breq	8000ae58 <__mcmp+0x2a>
8000ae4e:	f9 bc 03 ff 	movlo	r12,-1
8000ae52:	f9 bc 02 01 	movhs	r12,1
8000ae56:	d8 02       	popm	pc
8000ae58:	10 39       	cp.w	r9,r8
8000ae5a:	fe 9b ff f6 	brhi	8000ae46 <__mcmp+0x18>
8000ae5e:	d8 02       	popm	pc

8000ae60 <_Bfree>:
8000ae60:	d4 21       	pushm	r4-r7,lr
8000ae62:	18 97       	mov	r7,r12
8000ae64:	16 95       	mov	r5,r11
8000ae66:	78 96       	ld.w	r6,r12[0x24]
8000ae68:	58 06       	cp.w	r6,0
8000ae6a:	c0 91       	brne	8000ae7c <_Bfree+0x1c>
8000ae6c:	31 0c       	mov	r12,16
8000ae6e:	fe b0 dd 65 	rcall	80006938 <malloc>
8000ae72:	99 36       	st.w	r12[0xc],r6
8000ae74:	8f 9c       	st.w	r7[0x24],r12
8000ae76:	99 16       	st.w	r12[0x4],r6
8000ae78:	99 26       	st.w	r12[0x8],r6
8000ae7a:	99 06       	st.w	r12[0x0],r6
8000ae7c:	58 05       	cp.w	r5,0
8000ae7e:	c0 90       	breq	8000ae90 <_Bfree+0x30>
8000ae80:	6a 19       	ld.w	r9,r5[0x4]
8000ae82:	6e 98       	ld.w	r8,r7[0x24]
8000ae84:	70 38       	ld.w	r8,r8[0xc]
8000ae86:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000ae8a:	8b 0a       	st.w	r5[0x0],r10
8000ae8c:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000ae90:	d8 22       	popm	r4-r7,pc
8000ae92:	d7 03       	nop

8000ae94 <_Balloc>:
8000ae94:	d4 21       	pushm	r4-r7,lr
8000ae96:	18 97       	mov	r7,r12
8000ae98:	16 96       	mov	r6,r11
8000ae9a:	78 95       	ld.w	r5,r12[0x24]
8000ae9c:	58 05       	cp.w	r5,0
8000ae9e:	c0 91       	brne	8000aeb0 <_Balloc+0x1c>
8000aea0:	31 0c       	mov	r12,16
8000aea2:	fe b0 dd 4b 	rcall	80006938 <malloc>
8000aea6:	99 35       	st.w	r12[0xc],r5
8000aea8:	8f 9c       	st.w	r7[0x24],r12
8000aeaa:	99 15       	st.w	r12[0x4],r5
8000aeac:	99 25       	st.w	r12[0x8],r5
8000aeae:	99 05       	st.w	r12[0x0],r5
8000aeb0:	6e 95       	ld.w	r5,r7[0x24]
8000aeb2:	6a 38       	ld.w	r8,r5[0xc]
8000aeb4:	58 08       	cp.w	r8,0
8000aeb6:	c0 b1       	brne	8000aecc <_Balloc+0x38>
8000aeb8:	31 0a       	mov	r10,16
8000aeba:	30 4b       	mov	r11,4
8000aebc:	0e 9c       	mov	r12,r7
8000aebe:	e0 a0 02 a7 	rcall	8000b40c <_calloc_r>
8000aec2:	8b 3c       	st.w	r5[0xc],r12
8000aec4:	6e 98       	ld.w	r8,r7[0x24]
8000aec6:	70 3c       	ld.w	r12,r8[0xc]
8000aec8:	58 0c       	cp.w	r12,0
8000aeca:	c1 b0       	breq	8000af00 <_Balloc+0x6c>
8000aecc:	6e 98       	ld.w	r8,r7[0x24]
8000aece:	70 38       	ld.w	r8,r8[0xc]
8000aed0:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000aed4:	70 0c       	ld.w	r12,r8[0x0]
8000aed6:	58 0c       	cp.w	r12,0
8000aed8:	c0 40       	breq	8000aee0 <_Balloc+0x4c>
8000aeda:	78 09       	ld.w	r9,r12[0x0]
8000aedc:	91 09       	st.w	r8[0x0],r9
8000aede:	c0 e8       	rjmp	8000aefa <_Balloc+0x66>
8000aee0:	0e 9c       	mov	r12,r7
8000aee2:	30 17       	mov	r7,1
8000aee4:	0e 9b       	mov	r11,r7
8000aee6:	ee 06 09 47 	lsl	r7,r7,r6
8000aeea:	ee ca ff fb 	sub	r10,r7,-5
8000aeee:	a3 6a       	lsl	r10,0x2
8000aef0:	e0 a0 02 8e 	rcall	8000b40c <_calloc_r>
8000aef4:	c0 60       	breq	8000af00 <_Balloc+0x6c>
8000aef6:	99 16       	st.w	r12[0x4],r6
8000aef8:	99 27       	st.w	r12[0x8],r7
8000aefa:	30 08       	mov	r8,0
8000aefc:	99 38       	st.w	r12[0xc],r8
8000aefe:	99 48       	st.w	r12[0x10],r8
8000af00:	d8 22       	popm	r4-r7,pc
8000af02:	d7 03       	nop

8000af04 <__d2b>:
8000af04:	d4 31       	pushm	r0-r7,lr
8000af06:	20 2d       	sub	sp,8
8000af08:	16 93       	mov	r3,r11
8000af0a:	12 96       	mov	r6,r9
8000af0c:	10 95       	mov	r5,r8
8000af0e:	14 92       	mov	r2,r10
8000af10:	30 1b       	mov	r11,1
8000af12:	cc 1f       	rcall	8000ae94 <_Balloc>
8000af14:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000af18:	50 09       	stdsp	sp[0x0],r9
8000af1a:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000af1e:	b5 a9       	sbr	r9,0x14
8000af20:	f0 01 16 14 	lsr	r1,r8,0x14
8000af24:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000af28:	18 94       	mov	r4,r12
8000af2a:	58 02       	cp.w	r2,0
8000af2c:	c1 d0       	breq	8000af66 <__d2b+0x62>
8000af2e:	fa cc ff f8 	sub	r12,sp,-8
8000af32:	18 d2       	st.w	--r12,r2
8000af34:	c3 6f       	rcall	8000ada0 <__lo0bits>
8000af36:	40 18       	lddsp	r8,sp[0x4]
8000af38:	c0 d0       	breq	8000af52 <__d2b+0x4e>
8000af3a:	40 09       	lddsp	r9,sp[0x0]
8000af3c:	f8 0a 11 20 	rsub	r10,r12,32
8000af40:	f2 0a 09 4a 	lsl	r10,r9,r10
8000af44:	f5 e8 10 08 	or	r8,r10,r8
8000af48:	89 58       	st.w	r4[0x14],r8
8000af4a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000af4e:	50 09       	stdsp	sp[0x0],r9
8000af50:	c0 28       	rjmp	8000af54 <__d2b+0x50>
8000af52:	89 58       	st.w	r4[0x14],r8
8000af54:	40 08       	lddsp	r8,sp[0x0]
8000af56:	58 08       	cp.w	r8,0
8000af58:	f9 b3 01 02 	movne	r3,2
8000af5c:	f9 b3 00 01 	moveq	r3,1
8000af60:	89 68       	st.w	r4[0x18],r8
8000af62:	89 43       	st.w	r4[0x10],r3
8000af64:	c0 88       	rjmp	8000af74 <__d2b+0x70>
8000af66:	1a 9c       	mov	r12,sp
8000af68:	c1 cf       	rcall	8000ada0 <__lo0bits>
8000af6a:	30 13       	mov	r3,1
8000af6c:	40 08       	lddsp	r8,sp[0x0]
8000af6e:	2e 0c       	sub	r12,-32
8000af70:	89 43       	st.w	r4[0x10],r3
8000af72:	89 58       	st.w	r4[0x14],r8
8000af74:	58 01       	cp.w	r1,0
8000af76:	c0 90       	breq	8000af88 <__d2b+0x84>
8000af78:	e2 c1 04 33 	sub	r1,r1,1075
8000af7c:	18 01       	add	r1,r12
8000af7e:	8d 01       	st.w	r6[0x0],r1
8000af80:	f8 0c 11 35 	rsub	r12,r12,53
8000af84:	8b 0c       	st.w	r5[0x0],r12
8000af86:	c0 c8       	rjmp	8000af9e <__d2b+0x9a>
8000af88:	e6 c8 ff fc 	sub	r8,r3,-4
8000af8c:	f8 cc 04 32 	sub	r12,r12,1074
8000af90:	a5 73       	lsl	r3,0x5
8000af92:	8d 0c       	st.w	r6[0x0],r12
8000af94:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000af98:	cd 4e       	rcall	8000ad40 <__hi0bits>
8000af9a:	18 13       	sub	r3,r12
8000af9c:	8b 03       	st.w	r5[0x0],r3
8000af9e:	08 9c       	mov	r12,r4
8000afa0:	2f ed       	sub	sp,-8
8000afa2:	d8 32       	popm	r0-r7,pc

8000afa4 <__mdiff>:
8000afa4:	d4 31       	pushm	r0-r7,lr
8000afa6:	74 48       	ld.w	r8,r10[0x10]
8000afa8:	76 45       	ld.w	r5,r11[0x10]
8000afaa:	16 97       	mov	r7,r11
8000afac:	14 96       	mov	r6,r10
8000afae:	10 15       	sub	r5,r8
8000afb0:	c1 31       	brne	8000afd6 <__mdiff+0x32>
8000afb2:	2f b8       	sub	r8,-5
8000afb4:	ee ce ff ec 	sub	lr,r7,-20
8000afb8:	a3 68       	lsl	r8,0x2
8000afba:	f4 08 00 0b 	add	r11,r10,r8
8000afbe:	ee 08 00 08 	add	r8,r7,r8
8000afc2:	11 4a       	ld.w	r10,--r8
8000afc4:	17 49       	ld.w	r9,--r11
8000afc6:	12 3a       	cp.w	r10,r9
8000afc8:	c0 30       	breq	8000afce <__mdiff+0x2a>
8000afca:	c0 e2       	brcc	8000afe6 <__mdiff+0x42>
8000afcc:	c0 78       	rjmp	8000afda <__mdiff+0x36>
8000afce:	1c 38       	cp.w	r8,lr
8000afd0:	fe 9b ff f9 	brhi	8000afc2 <__mdiff+0x1e>
8000afd4:	c4 98       	rjmp	8000b066 <__mdiff+0xc2>
8000afd6:	58 05       	cp.w	r5,0
8000afd8:	c0 64       	brge	8000afe4 <__mdiff+0x40>
8000afda:	0e 98       	mov	r8,r7
8000afdc:	30 15       	mov	r5,1
8000afde:	0c 97       	mov	r7,r6
8000afe0:	10 96       	mov	r6,r8
8000afe2:	c0 28       	rjmp	8000afe6 <__mdiff+0x42>
8000afe4:	30 05       	mov	r5,0
8000afe6:	6e 1b       	ld.w	r11,r7[0x4]
8000afe8:	c5 6f       	rcall	8000ae94 <_Balloc>
8000afea:	6e 49       	ld.w	r9,r7[0x10]
8000afec:	6c 44       	ld.w	r4,r6[0x10]
8000afee:	99 35       	st.w	r12[0xc],r5
8000aff0:	2f b4       	sub	r4,-5
8000aff2:	f2 c5 ff fb 	sub	r5,r9,-5
8000aff6:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000affa:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000affe:	2e c6       	sub	r6,-20
8000b000:	2e c7       	sub	r7,-20
8000b002:	f8 c8 ff ec 	sub	r8,r12,-20
8000b006:	30 0a       	mov	r10,0
8000b008:	0f 0e       	ld.w	lr,r7++
8000b00a:	0d 0b       	ld.w	r11,r6++
8000b00c:	fc 02 16 10 	lsr	r2,lr,0x10
8000b010:	f6 03 16 10 	lsr	r3,r11,0x10
8000b014:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b018:	e4 03 01 03 	sub	r3,r2,r3
8000b01c:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b020:	fc 0b 01 0b 	sub	r11,lr,r11
8000b024:	f6 0a 00 0a 	add	r10,r11,r10
8000b028:	b0 1a       	st.h	r8[0x2],r10
8000b02a:	b1 4a       	asr	r10,0x10
8000b02c:	e6 0a 00 0a 	add	r10,r3,r10
8000b030:	b0 0a       	st.h	r8[0x0],r10
8000b032:	2f c8       	sub	r8,-4
8000b034:	b1 4a       	asr	r10,0x10
8000b036:	08 36       	cp.w	r6,r4
8000b038:	ce 83       	brcs	8000b008 <__mdiff+0x64>
8000b03a:	c0 d8       	rjmp	8000b054 <__mdiff+0xb0>
8000b03c:	0f 0b       	ld.w	r11,r7++
8000b03e:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b042:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b046:	16 0a       	add	r10,r11
8000b048:	b0 1a       	st.h	r8[0x2],r10
8000b04a:	b1 4a       	asr	r10,0x10
8000b04c:	1c 0a       	add	r10,lr
8000b04e:	b0 0a       	st.h	r8[0x0],r10
8000b050:	2f c8       	sub	r8,-4
8000b052:	b1 4a       	asr	r10,0x10
8000b054:	0a 37       	cp.w	r7,r5
8000b056:	cf 33       	brcs	8000b03c <__mdiff+0x98>
8000b058:	c0 28       	rjmp	8000b05c <__mdiff+0xb8>
8000b05a:	20 19       	sub	r9,1
8000b05c:	11 4a       	ld.w	r10,--r8
8000b05e:	58 0a       	cp.w	r10,0
8000b060:	cf d0       	breq	8000b05a <__mdiff+0xb6>
8000b062:	99 49       	st.w	r12[0x10],r9
8000b064:	d8 32       	popm	r0-r7,pc
8000b066:	30 0b       	mov	r11,0
8000b068:	c1 6f       	rcall	8000ae94 <_Balloc>
8000b06a:	30 18       	mov	r8,1
8000b06c:	99 48       	st.w	r12[0x10],r8
8000b06e:	30 08       	mov	r8,0
8000b070:	99 58       	st.w	r12[0x14],r8
8000b072:	d8 32       	popm	r0-r7,pc

8000b074 <__lshift>:
8000b074:	d4 31       	pushm	r0-r7,lr
8000b076:	16 97       	mov	r7,r11
8000b078:	76 46       	ld.w	r6,r11[0x10]
8000b07a:	f4 02 14 05 	asr	r2,r10,0x5
8000b07e:	2f f6       	sub	r6,-1
8000b080:	14 93       	mov	r3,r10
8000b082:	18 94       	mov	r4,r12
8000b084:	04 06       	add	r6,r2
8000b086:	76 1b       	ld.w	r11,r11[0x4]
8000b088:	6e 28       	ld.w	r8,r7[0x8]
8000b08a:	c0 38       	rjmp	8000b090 <__lshift+0x1c>
8000b08c:	2f fb       	sub	r11,-1
8000b08e:	a1 78       	lsl	r8,0x1
8000b090:	10 36       	cp.w	r6,r8
8000b092:	fe 99 ff fd 	brgt	8000b08c <__lshift+0x18>
8000b096:	08 9c       	mov	r12,r4
8000b098:	cf ee       	rcall	8000ae94 <_Balloc>
8000b09a:	30 09       	mov	r9,0
8000b09c:	18 95       	mov	r5,r12
8000b09e:	f8 c8 ff ec 	sub	r8,r12,-20
8000b0a2:	12 9a       	mov	r10,r9
8000b0a4:	c0 38       	rjmp	8000b0aa <__lshift+0x36>
8000b0a6:	10 aa       	st.w	r8++,r10
8000b0a8:	2f f9       	sub	r9,-1
8000b0aa:	04 39       	cp.w	r9,r2
8000b0ac:	cf d5       	brlt	8000b0a6 <__lshift+0x32>
8000b0ae:	6e 4b       	ld.w	r11,r7[0x10]
8000b0b0:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b0b4:	2f bb       	sub	r11,-5
8000b0b6:	ee c9 ff ec 	sub	r9,r7,-20
8000b0ba:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b0be:	58 03       	cp.w	r3,0
8000b0c0:	c1 30       	breq	8000b0e6 <__lshift+0x72>
8000b0c2:	e6 0c 11 20 	rsub	r12,r3,32
8000b0c6:	30 0a       	mov	r10,0
8000b0c8:	72 02       	ld.w	r2,r9[0x0]
8000b0ca:	e4 03 09 42 	lsl	r2,r2,r3
8000b0ce:	04 4a       	or	r10,r2
8000b0d0:	10 aa       	st.w	r8++,r10
8000b0d2:	13 0a       	ld.w	r10,r9++
8000b0d4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b0d8:	16 39       	cp.w	r9,r11
8000b0da:	cf 73       	brcs	8000b0c8 <__lshift+0x54>
8000b0dc:	91 0a       	st.w	r8[0x0],r10
8000b0de:	58 0a       	cp.w	r10,0
8000b0e0:	c0 70       	breq	8000b0ee <__lshift+0x7a>
8000b0e2:	2f f6       	sub	r6,-1
8000b0e4:	c0 58       	rjmp	8000b0ee <__lshift+0x7a>
8000b0e6:	13 0a       	ld.w	r10,r9++
8000b0e8:	10 aa       	st.w	r8++,r10
8000b0ea:	16 39       	cp.w	r9,r11
8000b0ec:	cf d3       	brcs	8000b0e6 <__lshift+0x72>
8000b0ee:	08 9c       	mov	r12,r4
8000b0f0:	20 16       	sub	r6,1
8000b0f2:	0e 9b       	mov	r11,r7
8000b0f4:	8b 46       	st.w	r5[0x10],r6
8000b0f6:	cb 5e       	rcall	8000ae60 <_Bfree>
8000b0f8:	0a 9c       	mov	r12,r5
8000b0fa:	d8 32       	popm	r0-r7,pc

8000b0fc <__multiply>:
8000b0fc:	d4 31       	pushm	r0-r7,lr
8000b0fe:	20 2d       	sub	sp,8
8000b100:	76 49       	ld.w	r9,r11[0x10]
8000b102:	74 48       	ld.w	r8,r10[0x10]
8000b104:	16 96       	mov	r6,r11
8000b106:	14 95       	mov	r5,r10
8000b108:	10 39       	cp.w	r9,r8
8000b10a:	ec 08 17 50 	movlt	r8,r6
8000b10e:	ea 06 17 50 	movlt	r6,r5
8000b112:	f0 05 17 50 	movlt	r5,r8
8000b116:	6c 28       	ld.w	r8,r6[0x8]
8000b118:	76 43       	ld.w	r3,r11[0x10]
8000b11a:	74 42       	ld.w	r2,r10[0x10]
8000b11c:	76 1b       	ld.w	r11,r11[0x4]
8000b11e:	e4 03 00 07 	add	r7,r2,r3
8000b122:	10 37       	cp.w	r7,r8
8000b124:	f7 bb 09 ff 	subgt	r11,-1
8000b128:	cb 6e       	rcall	8000ae94 <_Balloc>
8000b12a:	ee c4 ff fb 	sub	r4,r7,-5
8000b12e:	f8 c9 ff ec 	sub	r9,r12,-20
8000b132:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b136:	30 0a       	mov	r10,0
8000b138:	12 98       	mov	r8,r9
8000b13a:	c0 28       	rjmp	8000b13e <__multiply+0x42>
8000b13c:	10 aa       	st.w	r8++,r10
8000b13e:	08 38       	cp.w	r8,r4
8000b140:	cf e3       	brcs	8000b13c <__multiply+0x40>
8000b142:	2f b3       	sub	r3,-5
8000b144:	2f b2       	sub	r2,-5
8000b146:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b14a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b14e:	ec cb ff ec 	sub	r11,r6,-20
8000b152:	50 12       	stdsp	sp[0x4],r2
8000b154:	ea ca ff ec 	sub	r10,r5,-20
8000b158:	c4 48       	rjmp	8000b1e0 <__multiply+0xe4>
8000b15a:	94 95       	ld.uh	r5,r10[0x2]
8000b15c:	58 05       	cp.w	r5,0
8000b15e:	c2 00       	breq	8000b19e <__multiply+0xa2>
8000b160:	12 98       	mov	r8,r9
8000b162:	16 96       	mov	r6,r11
8000b164:	30 0e       	mov	lr,0
8000b166:	50 09       	stdsp	sp[0x0],r9
8000b168:	0d 02       	ld.w	r2,r6++
8000b16a:	e4 00 16 10 	lsr	r0,r2,0x10
8000b16e:	70 01       	ld.w	r1,r8[0x0]
8000b170:	70 09       	ld.w	r9,r8[0x0]
8000b172:	b1 81       	lsr	r1,0x10
8000b174:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b178:	e0 05 03 41 	mac	r1,r0,r5
8000b17c:	ab 32       	mul	r2,r5
8000b17e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b182:	00 02       	add	r2,r0
8000b184:	e4 0e 00 0e 	add	lr,r2,lr
8000b188:	b0 1e       	st.h	r8[0x2],lr
8000b18a:	b1 8e       	lsr	lr,0x10
8000b18c:	1c 01       	add	r1,lr
8000b18e:	b0 01       	st.h	r8[0x0],r1
8000b190:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b194:	2f c8       	sub	r8,-4
8000b196:	06 36       	cp.w	r6,r3
8000b198:	ce 83       	brcs	8000b168 <__multiply+0x6c>
8000b19a:	40 09       	lddsp	r9,sp[0x0]
8000b19c:	91 0e       	st.w	r8[0x0],lr
8000b19e:	94 86       	ld.uh	r6,r10[0x0]
8000b1a0:	58 06       	cp.w	r6,0
8000b1a2:	c1 d0       	breq	8000b1dc <__multiply+0xe0>
8000b1a4:	72 02       	ld.w	r2,r9[0x0]
8000b1a6:	12 98       	mov	r8,r9
8000b1a8:	16 9e       	mov	lr,r11
8000b1aa:	30 05       	mov	r5,0
8000b1ac:	b0 12       	st.h	r8[0x2],r2
8000b1ae:	1d 01       	ld.w	r1,lr++
8000b1b0:	90 82       	ld.uh	r2,r8[0x0]
8000b1b2:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b1b6:	ad 30       	mul	r0,r6
8000b1b8:	e0 02 00 02 	add	r2,r0,r2
8000b1bc:	e4 05 00 05 	add	r5,r2,r5
8000b1c0:	b0 05       	st.h	r8[0x0],r5
8000b1c2:	b1 85       	lsr	r5,0x10
8000b1c4:	b1 81       	lsr	r1,0x10
8000b1c6:	2f c8       	sub	r8,-4
8000b1c8:	ad 31       	mul	r1,r6
8000b1ca:	90 92       	ld.uh	r2,r8[0x2]
8000b1cc:	e2 02 00 02 	add	r2,r1,r2
8000b1d0:	0a 02       	add	r2,r5
8000b1d2:	e4 05 16 10 	lsr	r5,r2,0x10
8000b1d6:	06 3e       	cp.w	lr,r3
8000b1d8:	ce a3       	brcs	8000b1ac <__multiply+0xb0>
8000b1da:	91 02       	st.w	r8[0x0],r2
8000b1dc:	2f ca       	sub	r10,-4
8000b1de:	2f c9       	sub	r9,-4
8000b1e0:	40 18       	lddsp	r8,sp[0x4]
8000b1e2:	10 3a       	cp.w	r10,r8
8000b1e4:	cb b3       	brcs	8000b15a <__multiply+0x5e>
8000b1e6:	c0 28       	rjmp	8000b1ea <__multiply+0xee>
8000b1e8:	20 17       	sub	r7,1
8000b1ea:	58 07       	cp.w	r7,0
8000b1ec:	e0 8a 00 05 	brle	8000b1f6 <__multiply+0xfa>
8000b1f0:	09 48       	ld.w	r8,--r4
8000b1f2:	58 08       	cp.w	r8,0
8000b1f4:	cf a0       	breq	8000b1e8 <__multiply+0xec>
8000b1f6:	99 47       	st.w	r12[0x10],r7
8000b1f8:	2f ed       	sub	sp,-8
8000b1fa:	d8 32       	popm	r0-r7,pc

8000b1fc <__i2b>:
8000b1fc:	d4 21       	pushm	r4-r7,lr
8000b1fe:	16 97       	mov	r7,r11
8000b200:	30 1b       	mov	r11,1
8000b202:	c4 9e       	rcall	8000ae94 <_Balloc>
8000b204:	30 19       	mov	r9,1
8000b206:	99 57       	st.w	r12[0x14],r7
8000b208:	99 49       	st.w	r12[0x10],r9
8000b20a:	d8 22       	popm	r4-r7,pc

8000b20c <__multadd>:
8000b20c:	d4 31       	pushm	r0-r7,lr
8000b20e:	30 08       	mov	r8,0
8000b210:	12 95       	mov	r5,r9
8000b212:	16 97       	mov	r7,r11
8000b214:	18 96       	mov	r6,r12
8000b216:	76 44       	ld.w	r4,r11[0x10]
8000b218:	f6 c9 ff ec 	sub	r9,r11,-20
8000b21c:	72 0b       	ld.w	r11,r9[0x0]
8000b21e:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b222:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b226:	f4 0c 02 4c 	mul	r12,r10,r12
8000b22a:	f4 0b 03 45 	mac	r5,r10,r11
8000b22e:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b232:	b1 85       	lsr	r5,0x10
8000b234:	18 05       	add	r5,r12
8000b236:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b23a:	f8 0b 00 0b 	add	r11,r12,r11
8000b23e:	12 ab       	st.w	r9++,r11
8000b240:	2f f8       	sub	r8,-1
8000b242:	b1 85       	lsr	r5,0x10
8000b244:	08 38       	cp.w	r8,r4
8000b246:	ce b5       	brlt	8000b21c <__multadd+0x10>
8000b248:	58 05       	cp.w	r5,0
8000b24a:	c1 c0       	breq	8000b282 <__multadd+0x76>
8000b24c:	6e 28       	ld.w	r8,r7[0x8]
8000b24e:	10 34       	cp.w	r4,r8
8000b250:	c1 35       	brlt	8000b276 <__multadd+0x6a>
8000b252:	6e 1b       	ld.w	r11,r7[0x4]
8000b254:	0c 9c       	mov	r12,r6
8000b256:	2f fb       	sub	r11,-1
8000b258:	c1 ee       	rcall	8000ae94 <_Balloc>
8000b25a:	6e 4a       	ld.w	r10,r7[0x10]
8000b25c:	ee cb ff f4 	sub	r11,r7,-12
8000b260:	18 93       	mov	r3,r12
8000b262:	2f ea       	sub	r10,-2
8000b264:	2f 4c       	sub	r12,-12
8000b266:	a3 6a       	lsl	r10,0x2
8000b268:	fe b0 dd 8c 	rcall	80006d80 <memcpy>
8000b26c:	0e 9b       	mov	r11,r7
8000b26e:	0c 9c       	mov	r12,r6
8000b270:	fe b0 fd f8 	rcall	8000ae60 <_Bfree>
8000b274:	06 97       	mov	r7,r3
8000b276:	e8 c8 ff ff 	sub	r8,r4,-1
8000b27a:	2f b4       	sub	r4,-5
8000b27c:	8f 48       	st.w	r7[0x10],r8
8000b27e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b282:	0e 9c       	mov	r12,r7
8000b284:	d8 32       	popm	r0-r7,pc
8000b286:	d7 03       	nop

8000b288 <__pow5mult>:
8000b288:	d4 31       	pushm	r0-r7,lr
8000b28a:	14 96       	mov	r6,r10
8000b28c:	18 97       	mov	r7,r12
8000b28e:	16 94       	mov	r4,r11
8000b290:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b294:	c0 90       	breq	8000b2a6 <__pow5mult+0x1e>
8000b296:	20 18       	sub	r8,1
8000b298:	fe c9 e8 dc 	sub	r9,pc,-5924
8000b29c:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b2a0:	30 09       	mov	r9,0
8000b2a2:	cb 5f       	rcall	8000b20c <__multadd>
8000b2a4:	18 94       	mov	r4,r12
8000b2a6:	a3 46       	asr	r6,0x2
8000b2a8:	c3 40       	breq	8000b310 <__pow5mult+0x88>
8000b2aa:	6e 95       	ld.w	r5,r7[0x24]
8000b2ac:	58 05       	cp.w	r5,0
8000b2ae:	c0 91       	brne	8000b2c0 <__pow5mult+0x38>
8000b2b0:	31 0c       	mov	r12,16
8000b2b2:	fe b0 db 43 	rcall	80006938 <malloc>
8000b2b6:	99 35       	st.w	r12[0xc],r5
8000b2b8:	8f 9c       	st.w	r7[0x24],r12
8000b2ba:	99 15       	st.w	r12[0x4],r5
8000b2bc:	99 25       	st.w	r12[0x8],r5
8000b2be:	99 05       	st.w	r12[0x0],r5
8000b2c0:	6e 93       	ld.w	r3,r7[0x24]
8000b2c2:	66 25       	ld.w	r5,r3[0x8]
8000b2c4:	58 05       	cp.w	r5,0
8000b2c6:	c0 c1       	brne	8000b2de <__pow5mult+0x56>
8000b2c8:	e0 6b 02 71 	mov	r11,625
8000b2cc:	0e 9c       	mov	r12,r7
8000b2ce:	c9 7f       	rcall	8000b1fc <__i2b>
8000b2d0:	87 2c       	st.w	r3[0x8],r12
8000b2d2:	30 08       	mov	r8,0
8000b2d4:	18 95       	mov	r5,r12
8000b2d6:	99 08       	st.w	r12[0x0],r8
8000b2d8:	c0 38       	rjmp	8000b2de <__pow5mult+0x56>
8000b2da:	06 9c       	mov	r12,r3
8000b2dc:	18 95       	mov	r5,r12
8000b2de:	ed b6 00 00 	bld	r6,0x0
8000b2e2:	c0 b1       	brne	8000b2f8 <__pow5mult+0x70>
8000b2e4:	08 9b       	mov	r11,r4
8000b2e6:	0a 9a       	mov	r10,r5
8000b2e8:	0e 9c       	mov	r12,r7
8000b2ea:	c0 9f       	rcall	8000b0fc <__multiply>
8000b2ec:	08 9b       	mov	r11,r4
8000b2ee:	18 93       	mov	r3,r12
8000b2f0:	0e 9c       	mov	r12,r7
8000b2f2:	06 94       	mov	r4,r3
8000b2f4:	fe b0 fd b6 	rcall	8000ae60 <_Bfree>
8000b2f8:	a1 56       	asr	r6,0x1
8000b2fa:	c0 b0       	breq	8000b310 <__pow5mult+0x88>
8000b2fc:	6a 03       	ld.w	r3,r5[0x0]
8000b2fe:	58 03       	cp.w	r3,0
8000b300:	ce d1       	brne	8000b2da <__pow5mult+0x52>
8000b302:	0a 9a       	mov	r10,r5
8000b304:	0a 9b       	mov	r11,r5
8000b306:	0e 9c       	mov	r12,r7
8000b308:	cf ae       	rcall	8000b0fc <__multiply>
8000b30a:	8b 0c       	st.w	r5[0x0],r12
8000b30c:	99 03       	st.w	r12[0x0],r3
8000b30e:	ce 7b       	rjmp	8000b2dc <__pow5mult+0x54>
8000b310:	08 9c       	mov	r12,r4
8000b312:	d8 32       	popm	r0-r7,pc

8000b314 <__isinfd>:
8000b314:	14 98       	mov	r8,r10
8000b316:	fc 19 7f f0 	movh	r9,0x7ff0
8000b31a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b31e:	f0 0b 11 00 	rsub	r11,r8,0
8000b322:	f7 e8 10 08 	or	r8,r11,r8
8000b326:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b32a:	f2 08 01 08 	sub	r8,r9,r8
8000b32e:	f0 0c 11 00 	rsub	r12,r8,0
8000b332:	f9 e8 10 08 	or	r8,r12,r8
8000b336:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b33a:	2f fc       	sub	r12,-1
8000b33c:	5e fc       	retal	r12

8000b33e <__isnand>:
8000b33e:	14 98       	mov	r8,r10
8000b340:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b344:	f0 0c 11 00 	rsub	r12,r8,0
8000b348:	10 4c       	or	r12,r8
8000b34a:	fc 18 7f f0 	movh	r8,0x7ff0
8000b34e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b352:	f0 0c 01 0c 	sub	r12,r8,r12
8000b356:	bf 9c       	lsr	r12,0x1f
8000b358:	5e fc       	retal	r12
8000b35a:	d7 03       	nop

8000b35c <__sclose>:
8000b35c:	d4 01       	pushm	lr
8000b35e:	96 7b       	ld.sh	r11,r11[0xe]
8000b360:	c8 2c       	rcall	8000b464 <_close_r>
8000b362:	d8 02       	popm	pc

8000b364 <__sseek>:
8000b364:	d4 21       	pushm	r4-r7,lr
8000b366:	16 97       	mov	r7,r11
8000b368:	96 7b       	ld.sh	r11,r11[0xe]
8000b36a:	c0 3d       	rcall	8000b570 <_lseek_r>
8000b36c:	8e 68       	ld.sh	r8,r7[0xc]
8000b36e:	10 99       	mov	r9,r8
8000b370:	ad c8       	cbr	r8,0xc
8000b372:	ad a9       	sbr	r9,0xc
8000b374:	5b fc       	cp.w	r12,-1
8000b376:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b37a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b37e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b382:	d8 22       	popm	r4-r7,pc

8000b384 <__swrite>:
8000b384:	d4 21       	pushm	r4-r7,lr
8000b386:	96 68       	ld.sh	r8,r11[0xc]
8000b388:	16 97       	mov	r7,r11
8000b38a:	14 95       	mov	r5,r10
8000b38c:	12 94       	mov	r4,r9
8000b38e:	e2 18 01 00 	andl	r8,0x100,COH
8000b392:	18 96       	mov	r6,r12
8000b394:	c0 50       	breq	8000b39e <__swrite+0x1a>
8000b396:	30 29       	mov	r9,2
8000b398:	30 0a       	mov	r10,0
8000b39a:	96 7b       	ld.sh	r11,r11[0xe]
8000b39c:	ce ac       	rcall	8000b570 <_lseek_r>
8000b39e:	8e 68       	ld.sh	r8,r7[0xc]
8000b3a0:	ad c8       	cbr	r8,0xc
8000b3a2:	08 99       	mov	r9,r4
8000b3a4:	0a 9a       	mov	r10,r5
8000b3a6:	8e 7b       	ld.sh	r11,r7[0xe]
8000b3a8:	0c 9c       	mov	r12,r6
8000b3aa:	ae 68       	st.h	r7[0xc],r8
8000b3ac:	c1 cc       	rcall	8000b3e4 <_write_r>
8000b3ae:	d8 22       	popm	r4-r7,pc

8000b3b0 <__sread>:
8000b3b0:	d4 21       	pushm	r4-r7,lr
8000b3b2:	16 97       	mov	r7,r11
8000b3b4:	96 7b       	ld.sh	r11,r11[0xe]
8000b3b6:	cf 1c       	rcall	8000b598 <_read_r>
8000b3b8:	c0 65       	brlt	8000b3c4 <__sread+0x14>
8000b3ba:	6f 58       	ld.w	r8,r7[0x54]
8000b3bc:	18 08       	add	r8,r12
8000b3be:	ef 48 00 54 	st.w	r7[84],r8
8000b3c2:	d8 22       	popm	r4-r7,pc
8000b3c4:	8e 68       	ld.sh	r8,r7[0xc]
8000b3c6:	ad c8       	cbr	r8,0xc
8000b3c8:	ae 68       	st.h	r7[0xc],r8
8000b3ca:	d8 22       	popm	r4-r7,pc

8000b3cc <strlen>:
8000b3cc:	30 09       	mov	r9,0
8000b3ce:	18 98       	mov	r8,r12
8000b3d0:	c0 28       	rjmp	8000b3d4 <strlen+0x8>
8000b3d2:	2f f8       	sub	r8,-1
8000b3d4:	11 8a       	ld.ub	r10,r8[0x0]
8000b3d6:	f2 0a 18 00 	cp.b	r10,r9
8000b3da:	cf c1       	brne	8000b3d2 <strlen+0x6>
8000b3dc:	f0 0c 01 0c 	sub	r12,r8,r12
8000b3e0:	5e fc       	retal	r12
8000b3e2:	d7 03       	nop

8000b3e4 <_write_r>:
8000b3e4:	d4 21       	pushm	r4-r7,lr
8000b3e6:	16 98       	mov	r8,r11
8000b3e8:	18 97       	mov	r7,r12
8000b3ea:	10 9c       	mov	r12,r8
8000b3ec:	30 08       	mov	r8,0
8000b3ee:	14 9b       	mov	r11,r10
8000b3f0:	e0 66 08 0c 	mov	r6,2060
8000b3f4:	12 9a       	mov	r10,r9
8000b3f6:	8d 08       	st.w	r6[0x0],r8
8000b3f8:	fe b0 cf 40 	rcall	80005278 <_write>
8000b3fc:	5b fc       	cp.w	r12,-1
8000b3fe:	c0 51       	brne	8000b408 <_write_r+0x24>
8000b400:	6c 08       	ld.w	r8,r6[0x0]
8000b402:	58 08       	cp.w	r8,0
8000b404:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b408:	d8 22       	popm	r4-r7,pc
8000b40a:	d7 03       	nop

8000b40c <_calloc_r>:
8000b40c:	d4 21       	pushm	r4-r7,lr
8000b40e:	f4 0b 02 4b 	mul	r11,r10,r11
8000b412:	fe b0 da 9b 	rcall	80006948 <_malloc_r>
8000b416:	18 97       	mov	r7,r12
8000b418:	c2 30       	breq	8000b45e <_calloc_r+0x52>
8000b41a:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b41e:	e0 1a ff fc 	andl	r10,0xfffc
8000b422:	20 4a       	sub	r10,4
8000b424:	e0 4a 00 24 	cp.w	r10,36
8000b428:	e0 8b 00 18 	brhi	8000b458 <_calloc_r+0x4c>
8000b42c:	18 98       	mov	r8,r12
8000b42e:	59 3a       	cp.w	r10,19
8000b430:	e0 88 00 0f 	brls	8000b44e <_calloc_r+0x42>
8000b434:	30 09       	mov	r9,0
8000b436:	10 a9       	st.w	r8++,r9
8000b438:	10 a9       	st.w	r8++,r9
8000b43a:	59 ba       	cp.w	r10,27
8000b43c:	e0 88 00 09 	brls	8000b44e <_calloc_r+0x42>
8000b440:	10 a9       	st.w	r8++,r9
8000b442:	10 a9       	st.w	r8++,r9
8000b444:	e0 4a 00 24 	cp.w	r10,36
8000b448:	c0 31       	brne	8000b44e <_calloc_r+0x42>
8000b44a:	10 a9       	st.w	r8++,r9
8000b44c:	10 a9       	st.w	r8++,r9
8000b44e:	30 09       	mov	r9,0
8000b450:	10 a9       	st.w	r8++,r9
8000b452:	91 19       	st.w	r8[0x4],r9
8000b454:	91 09       	st.w	r8[0x0],r9
8000b456:	c0 48       	rjmp	8000b45e <_calloc_r+0x52>
8000b458:	30 0b       	mov	r11,0
8000b45a:	fe b0 dd 37 	rcall	80006ec8 <memset>
8000b45e:	0e 9c       	mov	r12,r7
8000b460:	d8 22       	popm	r4-r7,pc
8000b462:	d7 03       	nop

8000b464 <_close_r>:
8000b464:	d4 21       	pushm	r4-r7,lr
8000b466:	30 08       	mov	r8,0
8000b468:	18 97       	mov	r7,r12
8000b46a:	e0 66 08 0c 	mov	r6,2060
8000b46e:	16 9c       	mov	r12,r11
8000b470:	8d 08       	st.w	r6[0x0],r8
8000b472:	fe b0 de db 	rcall	80007228 <_close>
8000b476:	5b fc       	cp.w	r12,-1
8000b478:	c0 51       	brne	8000b482 <_close_r+0x1e>
8000b47a:	6c 08       	ld.w	r8,r6[0x0]
8000b47c:	58 08       	cp.w	r8,0
8000b47e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b482:	d8 22       	popm	r4-r7,pc

8000b484 <_fclose_r>:
8000b484:	d4 21       	pushm	r4-r7,lr
8000b486:	18 96       	mov	r6,r12
8000b488:	16 97       	mov	r7,r11
8000b48a:	58 0b       	cp.w	r11,0
8000b48c:	c0 31       	brne	8000b492 <_fclose_r+0xe>
8000b48e:	16 95       	mov	r5,r11
8000b490:	c5 38       	rjmp	8000b536 <_fclose_r+0xb2>
8000b492:	fe b0 f8 a9 	rcall	8000a5e4 <__sfp_lock_acquire>
8000b496:	58 06       	cp.w	r6,0
8000b498:	c0 70       	breq	8000b4a6 <_fclose_r+0x22>
8000b49a:	6c 68       	ld.w	r8,r6[0x18]
8000b49c:	58 08       	cp.w	r8,0
8000b49e:	c0 41       	brne	8000b4a6 <_fclose_r+0x22>
8000b4a0:	0c 9c       	mov	r12,r6
8000b4a2:	fe b0 f8 f3 	rcall	8000a688 <__sinit>
8000b4a6:	fe c8 eb 8a 	sub	r8,pc,-5238
8000b4aa:	10 37       	cp.w	r7,r8
8000b4ac:	c0 31       	brne	8000b4b2 <_fclose_r+0x2e>
8000b4ae:	6c 07       	ld.w	r7,r6[0x0]
8000b4b0:	c0 c8       	rjmp	8000b4c8 <_fclose_r+0x44>
8000b4b2:	fe c8 eb 76 	sub	r8,pc,-5258
8000b4b6:	10 37       	cp.w	r7,r8
8000b4b8:	c0 31       	brne	8000b4be <_fclose_r+0x3a>
8000b4ba:	6c 17       	ld.w	r7,r6[0x4]
8000b4bc:	c0 68       	rjmp	8000b4c8 <_fclose_r+0x44>
8000b4be:	fe c8 eb 62 	sub	r8,pc,-5278
8000b4c2:	10 37       	cp.w	r7,r8
8000b4c4:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b4c8:	8e 69       	ld.sh	r9,r7[0xc]
8000b4ca:	30 08       	mov	r8,0
8000b4cc:	f0 09 19 00 	cp.h	r9,r8
8000b4d0:	c0 51       	brne	8000b4da <_fclose_r+0x56>
8000b4d2:	fe b0 f8 8a 	rcall	8000a5e6 <__sfp_lock_release>
8000b4d6:	30 05       	mov	r5,0
8000b4d8:	c2 f8       	rjmp	8000b536 <_fclose_r+0xb2>
8000b4da:	0e 9b       	mov	r11,r7
8000b4dc:	0c 9c       	mov	r12,r6
8000b4de:	fe b0 f7 fd 	rcall	8000a4d8 <_fflush_r>
8000b4e2:	6e c8       	ld.w	r8,r7[0x30]
8000b4e4:	18 95       	mov	r5,r12
8000b4e6:	58 08       	cp.w	r8,0
8000b4e8:	c0 60       	breq	8000b4f4 <_fclose_r+0x70>
8000b4ea:	6e 8b       	ld.w	r11,r7[0x20]
8000b4ec:	0c 9c       	mov	r12,r6
8000b4ee:	5d 18       	icall	r8
8000b4f0:	f9 b5 05 ff 	movlt	r5,-1
8000b4f4:	8e 68       	ld.sh	r8,r7[0xc]
8000b4f6:	ed b8 00 07 	bld	r8,0x7
8000b4fa:	c0 51       	brne	8000b504 <_fclose_r+0x80>
8000b4fc:	6e 4b       	ld.w	r11,r7[0x10]
8000b4fe:	0c 9c       	mov	r12,r6
8000b500:	fe b0 f9 5e 	rcall	8000a7bc <_free_r>
8000b504:	6e db       	ld.w	r11,r7[0x34]
8000b506:	58 0b       	cp.w	r11,0
8000b508:	c0 a0       	breq	8000b51c <_fclose_r+0x98>
8000b50a:	ee c8 ff bc 	sub	r8,r7,-68
8000b50e:	10 3b       	cp.w	r11,r8
8000b510:	c0 40       	breq	8000b518 <_fclose_r+0x94>
8000b512:	0c 9c       	mov	r12,r6
8000b514:	fe b0 f9 54 	rcall	8000a7bc <_free_r>
8000b518:	30 08       	mov	r8,0
8000b51a:	8f d8       	st.w	r7[0x34],r8
8000b51c:	6f 2b       	ld.w	r11,r7[0x48]
8000b51e:	58 0b       	cp.w	r11,0
8000b520:	c0 70       	breq	8000b52e <_fclose_r+0xaa>
8000b522:	0c 9c       	mov	r12,r6
8000b524:	fe b0 f9 4c 	rcall	8000a7bc <_free_r>
8000b528:	30 08       	mov	r8,0
8000b52a:	ef 48 00 48 	st.w	r7[72],r8
8000b52e:	30 08       	mov	r8,0
8000b530:	ae 68       	st.h	r7[0xc],r8
8000b532:	fe b0 f8 5a 	rcall	8000a5e6 <__sfp_lock_release>
8000b536:	0a 9c       	mov	r12,r5
8000b538:	d8 22       	popm	r4-r7,pc
8000b53a:	d7 03       	nop

8000b53c <fclose>:
8000b53c:	d4 01       	pushm	lr
8000b53e:	e0 68 01 18 	mov	r8,280
8000b542:	18 9b       	mov	r11,r12
8000b544:	70 0c       	ld.w	r12,r8[0x0]
8000b546:	c9 ff       	rcall	8000b484 <_fclose_r>
8000b548:	d8 02       	popm	pc
8000b54a:	d7 03       	nop

8000b54c <_fstat_r>:
8000b54c:	d4 21       	pushm	r4-r7,lr
8000b54e:	16 98       	mov	r8,r11
8000b550:	18 97       	mov	r7,r12
8000b552:	10 9c       	mov	r12,r8
8000b554:	30 08       	mov	r8,0
8000b556:	e0 66 08 0c 	mov	r6,2060
8000b55a:	14 9b       	mov	r11,r10
8000b55c:	8d 08       	st.w	r6[0x0],r8
8000b55e:	fe b0 de 8d 	rcall	80007278 <_fstat>
8000b562:	5b fc       	cp.w	r12,-1
8000b564:	c0 51       	brne	8000b56e <_fstat_r+0x22>
8000b566:	6c 08       	ld.w	r8,r6[0x0]
8000b568:	58 08       	cp.w	r8,0
8000b56a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b56e:	d8 22       	popm	r4-r7,pc

8000b570 <_lseek_r>:
8000b570:	d4 21       	pushm	r4-r7,lr
8000b572:	16 98       	mov	r8,r11
8000b574:	18 97       	mov	r7,r12
8000b576:	10 9c       	mov	r12,r8
8000b578:	30 08       	mov	r8,0
8000b57a:	14 9b       	mov	r11,r10
8000b57c:	e0 66 08 0c 	mov	r6,2060
8000b580:	12 9a       	mov	r10,r9
8000b582:	8d 08       	st.w	r6[0x0],r8
8000b584:	fe b0 de 5c 	rcall	8000723c <_lseek>
8000b588:	5b fc       	cp.w	r12,-1
8000b58a:	c0 51       	brne	8000b594 <_lseek_r+0x24>
8000b58c:	6c 08       	ld.w	r8,r6[0x0]
8000b58e:	58 08       	cp.w	r8,0
8000b590:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b594:	d8 22       	popm	r4-r7,pc
8000b596:	d7 03       	nop

8000b598 <_read_r>:
8000b598:	d4 21       	pushm	r4-r7,lr
8000b59a:	16 98       	mov	r8,r11
8000b59c:	18 97       	mov	r7,r12
8000b59e:	10 9c       	mov	r12,r8
8000b5a0:	30 08       	mov	r8,0
8000b5a2:	14 9b       	mov	r11,r10
8000b5a4:	e0 66 08 0c 	mov	r6,2060
8000b5a8:	12 9a       	mov	r10,r9
8000b5aa:	8d 08       	st.w	r6[0x0],r8
8000b5ac:	fe b0 ce 20 	rcall	800051ec <_read>
8000b5b0:	5b fc       	cp.w	r12,-1
8000b5b2:	c0 51       	brne	8000b5bc <_read_r+0x24>
8000b5b4:	6c 08       	ld.w	r8,r6[0x0]
8000b5b6:	58 08       	cp.w	r8,0
8000b5b8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b5bc:	d8 22       	popm	r4-r7,pc
8000b5be:	d7 03       	nop

8000b5c0 <__avr32_f64_mul>:
8000b5c0:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b5c4:	e0 80 00 dc 	breq	8000b77c <__avr32_f64_mul_op1_zero>
8000b5c8:	d4 21       	pushm	r4-r7,lr
8000b5ca:	f7 e9 20 0e 	eor	lr,r11,r9
8000b5ce:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b5d2:	30 15       	mov	r5,1
8000b5d4:	c4 30       	breq	8000b65a <__avr32_f64_mul_op1_subnormal>
8000b5d6:	ab 6b       	lsl	r11,0xa
8000b5d8:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b5dc:	ab 6a       	lsl	r10,0xa
8000b5de:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b5e2:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b5e6:	c5 c0       	breq	8000b69e <__avr32_f64_mul_op2_subnormal>
8000b5e8:	a1 78       	lsl	r8,0x1
8000b5ea:	5c f9       	rol	r9
8000b5ec:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b5f0:	e0 47 07 ff 	cp.w	r7,2047
8000b5f4:	c7 70       	breq	8000b6e2 <__avr32_f64_mul_op_nan_or_inf>
8000b5f6:	e0 46 07 ff 	cp.w	r6,2047
8000b5fa:	c7 40       	breq	8000b6e2 <__avr32_f64_mul_op_nan_or_inf>
8000b5fc:	ee 06 00 0c 	add	r12,r7,r6
8000b600:	e0 2c 03 fe 	sub	r12,1022
8000b604:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b608:	f4 09 07 44 	macu.d	r4,r10,r9
8000b60c:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b610:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b614:	08 07       	add	r7,r4
8000b616:	f4 05 00 4a 	adc	r10,r10,r5
8000b61a:	5c 0b       	acr	r11
8000b61c:	ed bb 00 14 	bld	r11,0x14
8000b620:	c0 50       	breq	8000b62a <__avr32_f64_mul+0x6a>
8000b622:	a1 77       	lsl	r7,0x1
8000b624:	5c fa       	rol	r10
8000b626:	5c fb       	rol	r11
8000b628:	20 1c       	sub	r12,1
8000b62a:	58 0c       	cp.w	r12,0
8000b62c:	e0 8a 00 6f 	brle	8000b70a <__avr32_f64_mul_res_subnormal>
8000b630:	e0 4c 07 ff 	cp.w	r12,2047
8000b634:	e0 84 00 9c 	brge	8000b76c <__avr32_f64_mul_res_inf>
8000b638:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b63c:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b640:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b644:	ee 17 80 00 	eorh	r7,0x8000
8000b648:	f1 b7 04 20 	satu	r7,0x1
8000b64c:	0e 0a       	add	r10,r7
8000b64e:	5c 0b       	acr	r11
8000b650:	ed be 00 1f 	bld	lr,0x1f
8000b654:	ef bb 00 1f 	bst	r11,0x1f
8000b658:	d8 22       	popm	r4-r7,pc

8000b65a <__avr32_f64_mul_op1_subnormal>:
8000b65a:	e4 1b 00 0f 	andh	r11,0xf
8000b65e:	f4 0c 12 00 	clz	r12,r10
8000b662:	f6 06 12 00 	clz	r6,r11
8000b666:	f7 bc 03 e1 	sublo	r12,-31
8000b66a:	f8 06 17 30 	movlo	r6,r12
8000b66e:	f7 b6 02 01 	subhs	r6,1
8000b672:	e0 46 00 20 	cp.w	r6,32
8000b676:	c0 d4       	brge	8000b690 <__avr32_f64_mul_op1_subnormal+0x36>
8000b678:	ec 0c 11 20 	rsub	r12,r6,32
8000b67c:	f6 06 09 4b 	lsl	r11,r11,r6
8000b680:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b684:	18 4b       	or	r11,r12
8000b686:	f4 06 09 4a 	lsl	r10,r10,r6
8000b68a:	20 b6       	sub	r6,11
8000b68c:	0c 17       	sub	r7,r6
8000b68e:	ca ab       	rjmp	8000b5e2 <__avr32_f64_mul+0x22>
8000b690:	f4 06 09 4b 	lsl	r11,r10,r6
8000b694:	c6 40       	breq	8000b75c <__avr32_f64_mul_res_zero>
8000b696:	30 0a       	mov	r10,0
8000b698:	20 b6       	sub	r6,11
8000b69a:	0c 17       	sub	r7,r6
8000b69c:	ca 3b       	rjmp	8000b5e2 <__avr32_f64_mul+0x22>

8000b69e <__avr32_f64_mul_op2_subnormal>:
8000b69e:	e4 19 00 0f 	andh	r9,0xf
8000b6a2:	f0 0c 12 00 	clz	r12,r8
8000b6a6:	f2 05 12 00 	clz	r5,r9
8000b6aa:	f7 bc 03 ea 	sublo	r12,-22
8000b6ae:	f8 05 17 30 	movlo	r5,r12
8000b6b2:	f7 b5 02 0a 	subhs	r5,10
8000b6b6:	e0 45 00 20 	cp.w	r5,32
8000b6ba:	c0 d4       	brge	8000b6d4 <__avr32_f64_mul_op2_subnormal+0x36>
8000b6bc:	ea 0c 11 20 	rsub	r12,r5,32
8000b6c0:	f2 05 09 49 	lsl	r9,r9,r5
8000b6c4:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b6c8:	18 49       	or	r9,r12
8000b6ca:	f0 05 09 48 	lsl	r8,r8,r5
8000b6ce:	20 25       	sub	r5,2
8000b6d0:	0a 16       	sub	r6,r5
8000b6d2:	c8 fb       	rjmp	8000b5f0 <__avr32_f64_mul+0x30>
8000b6d4:	f0 05 09 49 	lsl	r9,r8,r5
8000b6d8:	c4 20       	breq	8000b75c <__avr32_f64_mul_res_zero>
8000b6da:	30 08       	mov	r8,0
8000b6dc:	20 25       	sub	r5,2
8000b6de:	0a 16       	sub	r6,r5
8000b6e0:	c8 8b       	rjmp	8000b5f0 <__avr32_f64_mul+0x30>

8000b6e2 <__avr32_f64_mul_op_nan_or_inf>:
8000b6e2:	e4 19 00 0f 	andh	r9,0xf
8000b6e6:	e4 1b 00 0f 	andh	r11,0xf
8000b6ea:	14 4b       	or	r11,r10
8000b6ec:	10 49       	or	r9,r8
8000b6ee:	e0 47 07 ff 	cp.w	r7,2047
8000b6f2:	c0 91       	brne	8000b704 <__avr32_f64_mul_op1_not_naninf>
8000b6f4:	58 0b       	cp.w	r11,0
8000b6f6:	c3 81       	brne	8000b766 <__avr32_f64_mul_res_nan>
8000b6f8:	e0 46 07 ff 	cp.w	r6,2047
8000b6fc:	c3 81       	brne	8000b76c <__avr32_f64_mul_res_inf>
8000b6fe:	58 09       	cp.w	r9,0
8000b700:	c3 60       	breq	8000b76c <__avr32_f64_mul_res_inf>
8000b702:	c3 28       	rjmp	8000b766 <__avr32_f64_mul_res_nan>

8000b704 <__avr32_f64_mul_op1_not_naninf>:
8000b704:	58 09       	cp.w	r9,0
8000b706:	c3 30       	breq	8000b76c <__avr32_f64_mul_res_inf>
8000b708:	c2 f8       	rjmp	8000b766 <__avr32_f64_mul_res_nan>

8000b70a <__avr32_f64_mul_res_subnormal>:
8000b70a:	5c 3c       	neg	r12
8000b70c:	2f fc       	sub	r12,-1
8000b70e:	f1 bc 04 c0 	satu	r12,0x6
8000b712:	e0 4c 00 20 	cp.w	r12,32
8000b716:	c1 14       	brge	8000b738 <__avr32_f64_mul_res_subnormal+0x2e>
8000b718:	f8 08 11 20 	rsub	r8,r12,32
8000b71c:	0e 46       	or	r6,r7
8000b71e:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b722:	f4 08 09 49 	lsl	r9,r10,r8
8000b726:	12 47       	or	r7,r9
8000b728:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b72c:	f6 08 09 49 	lsl	r9,r11,r8
8000b730:	12 4a       	or	r10,r9
8000b732:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b736:	c8 3b       	rjmp	8000b63c <__avr32_f64_mul+0x7c>
8000b738:	f8 08 11 20 	rsub	r8,r12,32
8000b73c:	f9 b9 00 00 	moveq	r9,0
8000b740:	c0 30       	breq	8000b746 <__avr32_f64_mul_res_subnormal+0x3c>
8000b742:	f6 08 09 49 	lsl	r9,r11,r8
8000b746:	0e 46       	or	r6,r7
8000b748:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b74c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b750:	f3 ea 10 07 	or	r7,r9,r10
8000b754:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b758:	30 0b       	mov	r11,0
8000b75a:	c7 1b       	rjmp	8000b63c <__avr32_f64_mul+0x7c>

8000b75c <__avr32_f64_mul_res_zero>:
8000b75c:	1c 9b       	mov	r11,lr
8000b75e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b762:	30 0a       	mov	r10,0
8000b764:	d8 22       	popm	r4-r7,pc

8000b766 <__avr32_f64_mul_res_nan>:
8000b766:	3f fb       	mov	r11,-1
8000b768:	3f fa       	mov	r10,-1
8000b76a:	d8 22       	popm	r4-r7,pc

8000b76c <__avr32_f64_mul_res_inf>:
8000b76c:	f0 6b 00 00 	mov	r11,-1048576
8000b770:	ed be 00 1f 	bld	lr,0x1f
8000b774:	ef bb 00 1f 	bst	r11,0x1f
8000b778:	30 0a       	mov	r10,0
8000b77a:	d8 22       	popm	r4-r7,pc

8000b77c <__avr32_f64_mul_op1_zero>:
8000b77c:	f7 e9 20 0b 	eor	r11,r11,r9
8000b780:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b784:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b788:	e0 4c 07 ff 	cp.w	r12,2047
8000b78c:	5e 1c       	retne	r12
8000b78e:	3f fa       	mov	r10,-1
8000b790:	3f fb       	mov	r11,-1
8000b792:	5e fc       	retal	r12

8000b794 <__avr32_f64_sub_from_add>:
8000b794:	ee 19 80 00 	eorh	r9,0x8000

8000b798 <__avr32_f64_sub>:
8000b798:	f7 e9 20 0c 	eor	r12,r11,r9
8000b79c:	e0 86 00 ca 	brmi	8000b930 <__avr32_f64_add_from_sub>
8000b7a0:	eb cd 40 e0 	pushm	r5-r7,lr
8000b7a4:	16 9c       	mov	r12,r11
8000b7a6:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b7aa:	bf db       	cbr	r11,0x1f
8000b7ac:	bf d9       	cbr	r9,0x1f
8000b7ae:	10 3a       	cp.w	r10,r8
8000b7b0:	f2 0b 13 00 	cpc	r11,r9
8000b7b4:	c0 92       	brcc	8000b7c6 <__avr32_f64_sub+0x2e>
8000b7b6:	16 97       	mov	r7,r11
8000b7b8:	12 9b       	mov	r11,r9
8000b7ba:	0e 99       	mov	r9,r7
8000b7bc:	14 97       	mov	r7,r10
8000b7be:	10 9a       	mov	r10,r8
8000b7c0:	0e 98       	mov	r8,r7
8000b7c2:	ee 1c 80 00 	eorh	r12,0x8000
8000b7c6:	f6 07 16 14 	lsr	r7,r11,0x14
8000b7ca:	ab 7b       	lsl	r11,0xb
8000b7cc:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b7d0:	ab 7a       	lsl	r10,0xb
8000b7d2:	bf bb       	sbr	r11,0x1f
8000b7d4:	f2 06 16 14 	lsr	r6,r9,0x14
8000b7d8:	c4 40       	breq	8000b860 <__avr32_f64_sub_opL_subnormal>
8000b7da:	ab 79       	lsl	r9,0xb
8000b7dc:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b7e0:	ab 78       	lsl	r8,0xb
8000b7e2:	bf b9       	sbr	r9,0x1f

8000b7e4 <__avr32_f64_sub_opL_subnormal_done>:
8000b7e4:	e0 47 07 ff 	cp.w	r7,2047
8000b7e8:	c4 f0       	breq	8000b886 <__avr32_f64_sub_opH_nan_or_inf>
8000b7ea:	0e 26       	rsub	r6,r7
8000b7ec:	c1 20       	breq	8000b810 <__avr32_f64_sub_shift_done>
8000b7ee:	ec 05 11 20 	rsub	r5,r6,32
8000b7f2:	e0 46 00 20 	cp.w	r6,32
8000b7f6:	c7 c2       	brcc	8000b8ee <__avr32_f64_sub_longshift>
8000b7f8:	f0 05 09 4e 	lsl	lr,r8,r5
8000b7fc:	f2 05 09 45 	lsl	r5,r9,r5
8000b800:	f0 06 0a 48 	lsr	r8,r8,r6
8000b804:	f2 06 0a 49 	lsr	r9,r9,r6
8000b808:	0a 48       	or	r8,r5
8000b80a:	58 0e       	cp.w	lr,0
8000b80c:	5f 1e       	srne	lr
8000b80e:	1c 48       	or	r8,lr

8000b810 <__avr32_f64_sub_shift_done>:
8000b810:	10 1a       	sub	r10,r8
8000b812:	f6 09 01 4b 	sbc	r11,r11,r9
8000b816:	f6 06 12 00 	clz	r6,r11
8000b81a:	c0 e0       	breq	8000b836 <__avr32_f64_sub_longnormalize_done>
8000b81c:	c7 83       	brcs	8000b90c <__avr32_f64_sub_longnormalize>
8000b81e:	ec 0e 11 20 	rsub	lr,r6,32
8000b822:	f6 06 09 4b 	lsl	r11,r11,r6
8000b826:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b82a:	1c 4b       	or	r11,lr
8000b82c:	f4 06 09 4a 	lsl	r10,r10,r6
8000b830:	0c 17       	sub	r7,r6
8000b832:	e0 8a 00 39 	brle	8000b8a4 <__avr32_f64_sub_subnormal_result>

8000b836 <__avr32_f64_sub_longnormalize_done>:
8000b836:	f4 09 15 15 	lsl	r9,r10,0x15
8000b83a:	ab 9a       	lsr	r10,0xb
8000b83c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b840:	ab 9b       	lsr	r11,0xb
8000b842:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b846:	18 4b       	or	r11,r12

8000b848 <__avr32_f64_sub_round>:
8000b848:	fc 17 80 00 	movh	r7,0x8000
8000b84c:	ed ba 00 00 	bld	r10,0x0
8000b850:	f7 b7 01 ff 	subne	r7,-1
8000b854:	0e 39       	cp.w	r9,r7
8000b856:	5f 29       	srhs	r9
8000b858:	12 0a       	add	r10,r9
8000b85a:	5c 0b       	acr	r11
8000b85c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b860 <__avr32_f64_sub_opL_subnormal>:
8000b860:	ab 79       	lsl	r9,0xb
8000b862:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b866:	ab 78       	lsl	r8,0xb
8000b868:	f3 e8 10 0e 	or	lr,r9,r8
8000b86c:	f9 b6 01 01 	movne	r6,1
8000b870:	ee 0e 11 00 	rsub	lr,r7,0
8000b874:	f9 b7 00 01 	moveq	r7,1
8000b878:	ef bb 00 1f 	bst	r11,0x1f
8000b87c:	f7 ea 10 0e 	or	lr,r11,r10
8000b880:	f9 b7 00 00 	moveq	r7,0
8000b884:	cb 0b       	rjmp	8000b7e4 <__avr32_f64_sub_opL_subnormal_done>

8000b886 <__avr32_f64_sub_opH_nan_or_inf>:
8000b886:	bf db       	cbr	r11,0x1f
8000b888:	f7 ea 10 0e 	or	lr,r11,r10
8000b88c:	c0 81       	brne	8000b89c <__avr32_f64_sub_return_nan>
8000b88e:	e0 46 07 ff 	cp.w	r6,2047
8000b892:	c0 50       	breq	8000b89c <__avr32_f64_sub_return_nan>
8000b894:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b898:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b89c <__avr32_f64_sub_return_nan>:
8000b89c:	3f fa       	mov	r10,-1
8000b89e:	3f fb       	mov	r11,-1
8000b8a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b8a4 <__avr32_f64_sub_subnormal_result>:
8000b8a4:	5c 37       	neg	r7
8000b8a6:	2f f7       	sub	r7,-1
8000b8a8:	f1 b7 04 c0 	satu	r7,0x6
8000b8ac:	e0 47 00 20 	cp.w	r7,32
8000b8b0:	c1 14       	brge	8000b8d2 <__avr32_f64_sub_subnormal_result+0x2e>
8000b8b2:	ee 08 11 20 	rsub	r8,r7,32
8000b8b6:	f4 08 09 49 	lsl	r9,r10,r8
8000b8ba:	5f 16       	srne	r6
8000b8bc:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b8c0:	0c 4a       	or	r10,r6
8000b8c2:	f6 08 09 49 	lsl	r9,r11,r8
8000b8c6:	f5 e9 10 0a 	or	r10,r10,r9
8000b8ca:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b8ce:	30 07       	mov	r7,0
8000b8d0:	cb 3b       	rjmp	8000b836 <__avr32_f64_sub_longnormalize_done>
8000b8d2:	ee 08 11 40 	rsub	r8,r7,64
8000b8d6:	f6 08 09 49 	lsl	r9,r11,r8
8000b8da:	14 49       	or	r9,r10
8000b8dc:	5f 16       	srne	r6
8000b8de:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b8e2:	0c 4a       	or	r10,r6
8000b8e4:	30 0b       	mov	r11,0
8000b8e6:	30 07       	mov	r7,0
8000b8e8:	ca 7b       	rjmp	8000b836 <__avr32_f64_sub_longnormalize_done>
8000b8ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b8ee <__avr32_f64_sub_longshift>:
8000b8ee:	f1 b6 04 c0 	satu	r6,0x6
8000b8f2:	f0 0e 17 00 	moveq	lr,r8
8000b8f6:	c0 40       	breq	8000b8fe <__avr32_f64_sub_longshift+0x10>
8000b8f8:	f2 05 09 4e 	lsl	lr,r9,r5
8000b8fc:	10 4e       	or	lr,r8
8000b8fe:	f2 06 0a 48 	lsr	r8,r9,r6
8000b902:	30 09       	mov	r9,0
8000b904:	58 0e       	cp.w	lr,0
8000b906:	5f 1e       	srne	lr
8000b908:	1c 48       	or	r8,lr
8000b90a:	c8 3b       	rjmp	8000b810 <__avr32_f64_sub_shift_done>

8000b90c <__avr32_f64_sub_longnormalize>:
8000b90c:	f4 06 12 00 	clz	r6,r10
8000b910:	f9 b7 03 00 	movlo	r7,0
8000b914:	f9 b6 03 00 	movlo	r6,0
8000b918:	f9 bc 03 00 	movlo	r12,0
8000b91c:	f7 b6 02 e0 	subhs	r6,-32
8000b920:	f4 06 09 4b 	lsl	r11,r10,r6
8000b924:	30 0a       	mov	r10,0
8000b926:	0c 17       	sub	r7,r6
8000b928:	fe 9a ff be 	brle	8000b8a4 <__avr32_f64_sub_subnormal_result>
8000b92c:	c8 5b       	rjmp	8000b836 <__avr32_f64_sub_longnormalize_done>
8000b92e:	d7 03       	nop

8000b930 <__avr32_f64_add_from_sub>:
8000b930:	ee 19 80 00 	eorh	r9,0x8000

8000b934 <__avr32_f64_add>:
8000b934:	f7 e9 20 0c 	eor	r12,r11,r9
8000b938:	fe 96 ff 2e 	brmi	8000b794 <__avr32_f64_sub_from_add>
8000b93c:	eb cd 40 e0 	pushm	r5-r7,lr
8000b940:	16 9c       	mov	r12,r11
8000b942:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b946:	bf db       	cbr	r11,0x1f
8000b948:	bf d9       	cbr	r9,0x1f
8000b94a:	12 3b       	cp.w	r11,r9
8000b94c:	c0 72       	brcc	8000b95a <__avr32_f64_add+0x26>
8000b94e:	16 97       	mov	r7,r11
8000b950:	12 9b       	mov	r11,r9
8000b952:	0e 99       	mov	r9,r7
8000b954:	14 97       	mov	r7,r10
8000b956:	10 9a       	mov	r10,r8
8000b958:	0e 98       	mov	r8,r7
8000b95a:	30 0e       	mov	lr,0
8000b95c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b960:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b964:	b5 ab       	sbr	r11,0x14
8000b966:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b96a:	c6 20       	breq	8000ba2e <__avr32_f64_add_op2_subnormal>
8000b96c:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b970:	b5 a9       	sbr	r9,0x14
8000b972:	e0 47 07 ff 	cp.w	r7,2047
8000b976:	c2 80       	breq	8000b9c6 <__avr32_f64_add_opH_nan_or_inf>
8000b978:	0e 26       	rsub	r6,r7
8000b97a:	c1 20       	breq	8000b99e <__avr32_f64_add_shift_done>
8000b97c:	e0 46 00 36 	cp.w	r6,54
8000b980:	c1 52       	brcc	8000b9aa <__avr32_f64_add_res_of_done>
8000b982:	ec 05 11 20 	rsub	r5,r6,32
8000b986:	e0 46 00 20 	cp.w	r6,32
8000b98a:	c3 52       	brcc	8000b9f4 <__avr32_f64_add_longshift>
8000b98c:	f0 05 09 4e 	lsl	lr,r8,r5
8000b990:	f2 05 09 45 	lsl	r5,r9,r5
8000b994:	f0 06 0a 48 	lsr	r8,r8,r6
8000b998:	f2 06 0a 49 	lsr	r9,r9,r6
8000b99c:	0a 48       	or	r8,r5

8000b99e <__avr32_f64_add_shift_done>:
8000b99e:	10 0a       	add	r10,r8
8000b9a0:	f6 09 00 4b 	adc	r11,r11,r9
8000b9a4:	ed bb 00 15 	bld	r11,0x15
8000b9a8:	c3 40       	breq	8000ba10 <__avr32_f64_add_res_of>

8000b9aa <__avr32_f64_add_res_of_done>:
8000b9aa:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b9ae:	18 4b       	or	r11,r12

8000b9b0 <__avr32_f64_add_round>:
8000b9b0:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b9b4:	18 4e       	or	lr,r12
8000b9b6:	ee 1e 80 00 	eorh	lr,0x8000
8000b9ba:	f1 be 04 20 	satu	lr,0x1
8000b9be:	1c 0a       	add	r10,lr
8000b9c0:	5c 0b       	acr	r11
8000b9c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b9c6 <__avr32_f64_add_opH_nan_or_inf>:
8000b9c6:	b5 cb       	cbr	r11,0x14
8000b9c8:	f7 ea 10 0e 	or	lr,r11,r10
8000b9cc:	c1 01       	brne	8000b9ec <__avr32_f64_add_return_nan>
8000b9ce:	e0 46 07 ff 	cp.w	r6,2047
8000b9d2:	c0 30       	breq	8000b9d8 <__avr32_f64_add_opL_nan_or_inf>
8000b9d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b9d8 <__avr32_f64_add_opL_nan_or_inf>:
8000b9d8:	b5 c9       	cbr	r9,0x14
8000b9da:	f3 e8 10 0e 	or	lr,r9,r8
8000b9de:	c0 71       	brne	8000b9ec <__avr32_f64_add_return_nan>
8000b9e0:	30 0a       	mov	r10,0
8000b9e2:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b9e6:	18 4b       	or	r11,r12
8000b9e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b9ec <__avr32_f64_add_return_nan>:
8000b9ec:	3f fa       	mov	r10,-1
8000b9ee:	3f fb       	mov	r11,-1
8000b9f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b9f4 <__avr32_f64_add_longshift>:
8000b9f4:	f1 b6 04 c0 	satu	r6,0x6
8000b9f8:	f0 0e 17 00 	moveq	lr,r8
8000b9fc:	c0 60       	breq	8000ba08 <__avr32_f64_add_longshift+0x14>
8000b9fe:	f2 05 09 4e 	lsl	lr,r9,r5
8000ba02:	58 08       	cp.w	r8,0
8000ba04:	5f 18       	srne	r8
8000ba06:	10 4e       	or	lr,r8
8000ba08:	f2 06 0a 48 	lsr	r8,r9,r6
8000ba0c:	30 09       	mov	r9,0
8000ba0e:	cc 8b       	rjmp	8000b99e <__avr32_f64_add_shift_done>

8000ba10 <__avr32_f64_add_res_of>:
8000ba10:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000ba14:	a1 9b       	lsr	r11,0x1
8000ba16:	5d 0a       	ror	r10
8000ba18:	5d 0e       	ror	lr
8000ba1a:	2f f7       	sub	r7,-1
8000ba1c:	e0 47 07 ff 	cp.w	r7,2047
8000ba20:	f9 ba 00 00 	moveq	r10,0
8000ba24:	f9 bb 00 00 	moveq	r11,0
8000ba28:	f9 be 00 00 	moveq	lr,0
8000ba2c:	cb fb       	rjmp	8000b9aa <__avr32_f64_add_res_of_done>

8000ba2e <__avr32_f64_add_op2_subnormal>:
8000ba2e:	30 16       	mov	r6,1
8000ba30:	58 07       	cp.w	r7,0
8000ba32:	ca 01       	brne	8000b972 <__avr32_f64_add+0x3e>
8000ba34:	b5 cb       	cbr	r11,0x14
8000ba36:	10 0a       	add	r10,r8
8000ba38:	f6 09 00 4b 	adc	r11,r11,r9
8000ba3c:	18 4b       	or	r11,r12
8000ba3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000ba42:	d7 03       	nop

8000ba44 <__avr32_f64_to_u32>:
8000ba44:	58 0b       	cp.w	r11,0
8000ba46:	5e 6d       	retmi	0

8000ba48 <__avr32_f64_to_s32>:
8000ba48:	f6 0c 15 01 	lsl	r12,r11,0x1
8000ba4c:	b5 9c       	lsr	r12,0x15
8000ba4e:	e0 2c 03 ff 	sub	r12,1023
8000ba52:	5e 3d       	retlo	0
8000ba54:	f8 0c 11 1f 	rsub	r12,r12,31
8000ba58:	16 99       	mov	r9,r11
8000ba5a:	ab 7b       	lsl	r11,0xb
8000ba5c:	bf bb       	sbr	r11,0x1f
8000ba5e:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000ba62:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ba66:	a1 79       	lsl	r9,0x1
8000ba68:	5e 2b       	reths	r11
8000ba6a:	5c 3b       	neg	r11
8000ba6c:	5e fb       	retal	r11

8000ba6e <__avr32_u32_to_f64>:
8000ba6e:	f8 cb 00 00 	sub	r11,r12,0
8000ba72:	30 0c       	mov	r12,0
8000ba74:	c0 38       	rjmp	8000ba7a <__avr32_s32_to_f64+0x4>

8000ba76 <__avr32_s32_to_f64>:
8000ba76:	18 9b       	mov	r11,r12
8000ba78:	5c 4b       	abs	r11
8000ba7a:	30 0a       	mov	r10,0
8000ba7c:	5e 0b       	reteq	r11
8000ba7e:	d4 01       	pushm	lr
8000ba80:	e0 69 04 1e 	mov	r9,1054
8000ba84:	f6 08 12 00 	clz	r8,r11
8000ba88:	c1 70       	breq	8000bab6 <__avr32_s32_to_f64+0x40>
8000ba8a:	c0 c3       	brcs	8000baa2 <__avr32_s32_to_f64+0x2c>
8000ba8c:	f0 0e 11 20 	rsub	lr,r8,32
8000ba90:	f6 08 09 4b 	lsl	r11,r11,r8
8000ba94:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000ba98:	1c 4b       	or	r11,lr
8000ba9a:	f4 08 09 4a 	lsl	r10,r10,r8
8000ba9e:	10 19       	sub	r9,r8
8000baa0:	c0 b8       	rjmp	8000bab6 <__avr32_s32_to_f64+0x40>
8000baa2:	f4 08 12 00 	clz	r8,r10
8000baa6:	f9 b8 03 00 	movlo	r8,0
8000baaa:	f7 b8 02 e0 	subhs	r8,-32
8000baae:	f4 08 09 4b 	lsl	r11,r10,r8
8000bab2:	30 0a       	mov	r10,0
8000bab4:	10 19       	sub	r9,r8
8000bab6:	58 09       	cp.w	r9,0
8000bab8:	e0 89 00 30 	brgt	8000bb18 <__avr32_s32_to_f64+0xa2>
8000babc:	5c 39       	neg	r9
8000babe:	2f f9       	sub	r9,-1
8000bac0:	e0 49 00 36 	cp.w	r9,54
8000bac4:	c0 43       	brcs	8000bacc <__avr32_s32_to_f64+0x56>
8000bac6:	30 0b       	mov	r11,0
8000bac8:	30 0a       	mov	r10,0
8000baca:	c2 68       	rjmp	8000bb16 <__avr32_s32_to_f64+0xa0>
8000bacc:	2f 69       	sub	r9,-10
8000bace:	f2 08 11 20 	rsub	r8,r9,32
8000bad2:	e0 49 00 20 	cp.w	r9,32
8000bad6:	c0 b2       	brcc	8000baec <__avr32_s32_to_f64+0x76>
8000bad8:	f4 08 09 4e 	lsl	lr,r10,r8
8000badc:	f6 08 09 48 	lsl	r8,r11,r8
8000bae0:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bae4:	f6 09 0a 4b 	lsr	r11,r11,r9
8000bae8:	10 4b       	or	r11,r8
8000baea:	c0 88       	rjmp	8000bafa <__avr32_s32_to_f64+0x84>
8000baec:	f6 08 09 4e 	lsl	lr,r11,r8
8000baf0:	14 4e       	or	lr,r10
8000baf2:	16 9a       	mov	r10,r11
8000baf4:	30 0b       	mov	r11,0
8000baf6:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bafa:	ed ba 00 00 	bld	r10,0x0
8000bafe:	c0 92       	brcc	8000bb10 <__avr32_s32_to_f64+0x9a>
8000bb00:	1c 7e       	tst	lr,lr
8000bb02:	c0 41       	brne	8000bb0a <__avr32_s32_to_f64+0x94>
8000bb04:	ed ba 00 01 	bld	r10,0x1
8000bb08:	c0 42       	brcc	8000bb10 <__avr32_s32_to_f64+0x9a>
8000bb0a:	2f fa       	sub	r10,-1
8000bb0c:	f7 bb 02 ff 	subhs	r11,-1
8000bb10:	5c fc       	rol	r12
8000bb12:	5d 0b       	ror	r11
8000bb14:	5d 0a       	ror	r10
8000bb16:	d8 02       	popm	pc
8000bb18:	e0 68 03 ff 	mov	r8,1023
8000bb1c:	ed ba 00 0b 	bld	r10,0xb
8000bb20:	f7 b8 00 ff 	subeq	r8,-1
8000bb24:	10 0a       	add	r10,r8
8000bb26:	5c 0b       	acr	r11
8000bb28:	f7 b9 03 fe 	sublo	r9,-2
8000bb2c:	e0 49 07 ff 	cp.w	r9,2047
8000bb30:	c0 55       	brlt	8000bb3a <__avr32_s32_to_f64+0xc4>
8000bb32:	30 0a       	mov	r10,0
8000bb34:	fc 1b ff e0 	movh	r11,0xffe0
8000bb38:	c0 c8       	rjmp	8000bb50 <__floatsidf_return_op1>
8000bb3a:	ed bb 00 1f 	bld	r11,0x1f
8000bb3e:	f7 b9 01 01 	subne	r9,1
8000bb42:	ab 9a       	lsr	r10,0xb
8000bb44:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bb48:	a1 7b       	lsl	r11,0x1
8000bb4a:	ab 9b       	lsr	r11,0xb
8000bb4c:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000bb50 <__floatsidf_return_op1>:
8000bb50:	a1 7c       	lsl	r12,0x1
8000bb52:	5d 0b       	ror	r11
8000bb54:	d8 02       	popm	pc

8000bb56 <__avr32_f64_cmp_eq>:
8000bb56:	10 3a       	cp.w	r10,r8
8000bb58:	f2 0b 13 00 	cpc	r11,r9
8000bb5c:	c0 80       	breq	8000bb6c <__avr32_f64_cmp_eq+0x16>
8000bb5e:	a1 7b       	lsl	r11,0x1
8000bb60:	a1 79       	lsl	r9,0x1
8000bb62:	14 4b       	or	r11,r10
8000bb64:	12 4b       	or	r11,r9
8000bb66:	10 4b       	or	r11,r8
8000bb68:	5e 0f       	reteq	1
8000bb6a:	5e fd       	retal	0
8000bb6c:	a1 7b       	lsl	r11,0x1
8000bb6e:	fc 1c ff e0 	movh	r12,0xffe0
8000bb72:	58 0a       	cp.w	r10,0
8000bb74:	f8 0b 13 00 	cpc	r11,r12
8000bb78:	5e 8f       	retls	1
8000bb7a:	5e fd       	retal	0

8000bb7c <__avr32_f64_cmp_ge>:
8000bb7c:	1a de       	st.w	--sp,lr
8000bb7e:	1a d7       	st.w	--sp,r7
8000bb80:	a1 7b       	lsl	r11,0x1
8000bb82:	5f 3c       	srlo	r12
8000bb84:	a1 79       	lsl	r9,0x1
8000bb86:	5f 37       	srlo	r7
8000bb88:	5c fc       	rol	r12
8000bb8a:	fc 1e ff e0 	movh	lr,0xffe0
8000bb8e:	58 0a       	cp.w	r10,0
8000bb90:	fc 0b 13 00 	cpc	r11,lr
8000bb94:	e0 8b 00 1d 	brhi	8000bbce <__avr32_f64_cmp_ge+0x52>
8000bb98:	58 08       	cp.w	r8,0
8000bb9a:	fc 09 13 00 	cpc	r9,lr
8000bb9e:	e0 8b 00 18 	brhi	8000bbce <__avr32_f64_cmp_ge+0x52>
8000bba2:	58 0b       	cp.w	r11,0
8000bba4:	f5 ba 00 00 	subfeq	r10,0
8000bba8:	c1 50       	breq	8000bbd2 <__avr32_f64_cmp_ge+0x56>
8000bbaa:	1b 07       	ld.w	r7,sp++
8000bbac:	1b 0e       	ld.w	lr,sp++
8000bbae:	58 3c       	cp.w	r12,3
8000bbb0:	c0 a0       	breq	8000bbc4 <__avr32_f64_cmp_ge+0x48>
8000bbb2:	58 1c       	cp.w	r12,1
8000bbb4:	c0 33       	brcs	8000bbba <__avr32_f64_cmp_ge+0x3e>
8000bbb6:	5e 0f       	reteq	1
8000bbb8:	5e 1d       	retne	0
8000bbba:	10 3a       	cp.w	r10,r8
8000bbbc:	f2 0b 13 00 	cpc	r11,r9
8000bbc0:	5e 2f       	reths	1
8000bbc2:	5e 3d       	retlo	0
8000bbc4:	14 38       	cp.w	r8,r10
8000bbc6:	f6 09 13 00 	cpc	r9,r11
8000bbca:	5e 2f       	reths	1
8000bbcc:	5e 3d       	retlo	0
8000bbce:	1b 07       	ld.w	r7,sp++
8000bbd0:	d8 0a       	popm	pc,r12=0
8000bbd2:	58 17       	cp.w	r7,1
8000bbd4:	5f 0c       	sreq	r12
8000bbd6:	58 09       	cp.w	r9,0
8000bbd8:	f5 b8 00 00 	subfeq	r8,0
8000bbdc:	1b 07       	ld.w	r7,sp++
8000bbde:	1b 0e       	ld.w	lr,sp++
8000bbe0:	5e 0f       	reteq	1
8000bbe2:	5e fc       	retal	r12

8000bbe4 <__avr32_f64_cmp_lt>:
8000bbe4:	1a de       	st.w	--sp,lr
8000bbe6:	1a d7       	st.w	--sp,r7
8000bbe8:	a1 7b       	lsl	r11,0x1
8000bbea:	5f 3c       	srlo	r12
8000bbec:	a1 79       	lsl	r9,0x1
8000bbee:	5f 37       	srlo	r7
8000bbf0:	5c fc       	rol	r12
8000bbf2:	fc 1e ff e0 	movh	lr,0xffe0
8000bbf6:	58 0a       	cp.w	r10,0
8000bbf8:	fc 0b 13 00 	cpc	r11,lr
8000bbfc:	e0 8b 00 1d 	brhi	8000bc36 <__avr32_f64_cmp_lt+0x52>
8000bc00:	58 08       	cp.w	r8,0
8000bc02:	fc 09 13 00 	cpc	r9,lr
8000bc06:	e0 8b 00 18 	brhi	8000bc36 <__avr32_f64_cmp_lt+0x52>
8000bc0a:	58 0b       	cp.w	r11,0
8000bc0c:	f5 ba 00 00 	subfeq	r10,0
8000bc10:	c1 50       	breq	8000bc3a <__avr32_f64_cmp_lt+0x56>
8000bc12:	1b 07       	ld.w	r7,sp++
8000bc14:	1b 0e       	ld.w	lr,sp++
8000bc16:	58 3c       	cp.w	r12,3
8000bc18:	c0 a0       	breq	8000bc2c <__avr32_f64_cmp_lt+0x48>
8000bc1a:	58 1c       	cp.w	r12,1
8000bc1c:	c0 33       	brcs	8000bc22 <__avr32_f64_cmp_lt+0x3e>
8000bc1e:	5e 0d       	reteq	0
8000bc20:	5e 1f       	retne	1
8000bc22:	10 3a       	cp.w	r10,r8
8000bc24:	f2 0b 13 00 	cpc	r11,r9
8000bc28:	5e 2d       	reths	0
8000bc2a:	5e 3f       	retlo	1
8000bc2c:	14 38       	cp.w	r8,r10
8000bc2e:	f6 09 13 00 	cpc	r9,r11
8000bc32:	5e 2d       	reths	0
8000bc34:	5e 3f       	retlo	1
8000bc36:	1b 07       	ld.w	r7,sp++
8000bc38:	d8 0a       	popm	pc,r12=0
8000bc3a:	58 17       	cp.w	r7,1
8000bc3c:	5f 1c       	srne	r12
8000bc3e:	58 09       	cp.w	r9,0
8000bc40:	f5 b8 00 00 	subfeq	r8,0
8000bc44:	1b 07       	ld.w	r7,sp++
8000bc46:	1b 0e       	ld.w	lr,sp++
8000bc48:	5e 0d       	reteq	0
8000bc4a:	5e fc       	retal	r12

8000bc4c <__avr32_f64_div>:
8000bc4c:	eb cd 40 ff 	pushm	r0-r7,lr
8000bc50:	f7 e9 20 0e 	eor	lr,r11,r9
8000bc54:	f6 07 16 14 	lsr	r7,r11,0x14
8000bc58:	a9 7b       	lsl	r11,0x9
8000bc5a:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000bc5e:	a9 7a       	lsl	r10,0x9
8000bc60:	bd bb       	sbr	r11,0x1d
8000bc62:	e4 1b 3f ff 	andh	r11,0x3fff
8000bc66:	ab d7       	cbr	r7,0xb
8000bc68:	e0 80 00 cc 	breq	8000be00 <__avr32_f64_div_round_subnormal+0x54>
8000bc6c:	e0 47 07 ff 	cp.w	r7,2047
8000bc70:	e0 84 00 b5 	brge	8000bdda <__avr32_f64_div_round_subnormal+0x2e>
8000bc74:	f2 06 16 14 	lsr	r6,r9,0x14
8000bc78:	a9 79       	lsl	r9,0x9
8000bc7a:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000bc7e:	a9 78       	lsl	r8,0x9
8000bc80:	bd b9       	sbr	r9,0x1d
8000bc82:	e4 19 3f ff 	andh	r9,0x3fff
8000bc86:	ab d6       	cbr	r6,0xb
8000bc88:	e0 80 00 e2 	breq	8000be4c <__avr32_f64_div_round_subnormal+0xa0>
8000bc8c:	e0 46 07 ff 	cp.w	r6,2047
8000bc90:	e0 84 00 b2 	brge	8000bdf4 <__avr32_f64_div_round_subnormal+0x48>
8000bc94:	0c 17       	sub	r7,r6
8000bc96:	fe 37 fc 01 	sub	r7,-1023
8000bc9a:	fc 1c 80 00 	movh	r12,0x8000
8000bc9e:	f8 03 16 01 	lsr	r3,r12,0x1
8000bca2:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000bca6:	5c d4       	com	r4
8000bca8:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000bcac:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bcb0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bcb4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bcb8:	ea 03 15 02 	lsl	r3,r5,0x2
8000bcbc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bcc0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bcc4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bcc8:	ea 03 15 02 	lsl	r3,r5,0x2
8000bccc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bcd0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bcd4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bcd8:	ea 03 15 02 	lsl	r3,r5,0x2
8000bcdc:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bce0:	e4 09 07 40 	macu.d	r0,r2,r9
8000bce4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bce8:	02 04       	add	r4,r1
8000bcea:	5c 05       	acr	r5
8000bcec:	a3 65       	lsl	r5,0x2
8000bcee:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bcf2:	a3 64       	lsl	r4,0x2
8000bcf4:	5c 34       	neg	r4
8000bcf6:	f8 05 01 45 	sbc	r5,r12,r5
8000bcfa:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bcfe:	e4 05 07 40 	macu.d	r0,r2,r5
8000bd02:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bd06:	02 04       	add	r4,r1
8000bd08:	5c 05       	acr	r5
8000bd0a:	ea 03 15 02 	lsl	r3,r5,0x2
8000bd0e:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bd12:	e8 02 15 02 	lsl	r2,r4,0x2
8000bd16:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bd1a:	e4 09 07 40 	macu.d	r0,r2,r9
8000bd1e:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bd22:	02 04       	add	r4,r1
8000bd24:	5c 05       	acr	r5
8000bd26:	a3 65       	lsl	r5,0x2
8000bd28:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bd2c:	a3 64       	lsl	r4,0x2
8000bd2e:	5c 34       	neg	r4
8000bd30:	f8 05 01 45 	sbc	r5,r12,r5
8000bd34:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bd38:	e4 05 07 40 	macu.d	r0,r2,r5
8000bd3c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bd40:	02 04       	add	r4,r1
8000bd42:	5c 05       	acr	r5
8000bd44:	ea 03 15 02 	lsl	r3,r5,0x2
8000bd48:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bd4c:	e8 02 15 02 	lsl	r2,r4,0x2
8000bd50:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000bd54:	e4 0b 07 40 	macu.d	r0,r2,r11
8000bd58:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000bd5c:	02 02       	add	r2,r1
8000bd5e:	5c 03       	acr	r3
8000bd60:	ed b3 00 1c 	bld	r3,0x1c
8000bd64:	c0 90       	breq	8000bd76 <__avr32_f64_div+0x12a>
8000bd66:	a1 72       	lsl	r2,0x1
8000bd68:	5c f3       	rol	r3
8000bd6a:	20 17       	sub	r7,1
8000bd6c:	a3 9a       	lsr	r10,0x3
8000bd6e:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000bd72:	a3 9b       	lsr	r11,0x3
8000bd74:	c0 58       	rjmp	8000bd7e <__avr32_f64_div+0x132>
8000bd76:	a5 8a       	lsr	r10,0x4
8000bd78:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000bd7c:	a5 8b       	lsr	r11,0x4
8000bd7e:	58 07       	cp.w	r7,0
8000bd80:	e0 8a 00 8b 	brle	8000be96 <__avr32_f64_div_res_subnormal>
8000bd84:	e0 12 ff 00 	andl	r2,0xff00
8000bd88:	e8 12 00 80 	orl	r2,0x80
8000bd8c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bd90:	e4 09 07 40 	macu.d	r0,r2,r9
8000bd94:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bd98:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bd9c:	00 05       	add	r5,r0
8000bd9e:	f0 01 00 48 	adc	r8,r8,r1
8000bda2:	5c 09       	acr	r9
8000bda4:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bda8:	58 04       	cp.w	r4,0
8000bdaa:	5c 25       	cpc	r5

8000bdac <__avr32_f64_div_round_subnormal>:
8000bdac:	f4 08 13 00 	cpc	r8,r10
8000bdb0:	f6 09 13 00 	cpc	r9,r11
8000bdb4:	5f 36       	srlo	r6
8000bdb6:	f8 06 17 00 	moveq	r6,r12
8000bdba:	e4 0a 16 08 	lsr	r10,r2,0x8
8000bdbe:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000bdc2:	e6 0b 16 08 	lsr	r11,r3,0x8
8000bdc6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bdca:	ed be 00 1f 	bld	lr,0x1f
8000bdce:	ef bb 00 1f 	bst	r11,0x1f
8000bdd2:	0c 0a       	add	r10,r6
8000bdd4:	5c 0b       	acr	r11
8000bdd6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bdda:	e4 1b 00 0f 	andh	r11,0xf
8000bdde:	14 4b       	or	r11,r10
8000bde0:	e0 81 00 a7 	brne	8000bf2e <__avr32_f64_div_res_subnormal+0x98>
8000bde4:	f2 06 16 14 	lsr	r6,r9,0x14
8000bde8:	ab d6       	cbr	r6,0xb
8000bdea:	e0 46 07 ff 	cp.w	r6,2047
8000bdee:	e0 81 00 a4 	brne	8000bf36 <__avr32_f64_div_res_subnormal+0xa0>
8000bdf2:	c9 e8       	rjmp	8000bf2e <__avr32_f64_div_res_subnormal+0x98>
8000bdf4:	e4 19 00 0f 	andh	r9,0xf
8000bdf8:	10 49       	or	r9,r8
8000bdfa:	e0 81 00 9a 	brne	8000bf2e <__avr32_f64_div_res_subnormal+0x98>
8000bdfe:	c9 28       	rjmp	8000bf22 <__avr32_f64_div_res_subnormal+0x8c>
8000be00:	a3 7b       	lsl	r11,0x3
8000be02:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000be06:	a3 7a       	lsl	r10,0x3
8000be08:	f5 eb 10 04 	or	r4,r10,r11
8000be0c:	e0 80 00 a0 	breq	8000bf4c <__avr32_f64_div_op1_zero>
8000be10:	f6 04 12 00 	clz	r4,r11
8000be14:	c1 70       	breq	8000be42 <__avr32_f64_div_round_subnormal+0x96>
8000be16:	c0 c3       	brcs	8000be2e <__avr32_f64_div_round_subnormal+0x82>
8000be18:	e8 05 11 20 	rsub	r5,r4,32
8000be1c:	f6 04 09 4b 	lsl	r11,r11,r4
8000be20:	f4 05 0a 45 	lsr	r5,r10,r5
8000be24:	0a 4b       	or	r11,r5
8000be26:	f4 04 09 4a 	lsl	r10,r10,r4
8000be2a:	08 17       	sub	r7,r4
8000be2c:	c0 b8       	rjmp	8000be42 <__avr32_f64_div_round_subnormal+0x96>
8000be2e:	f4 04 12 00 	clz	r4,r10
8000be32:	f9 b4 03 00 	movlo	r4,0
8000be36:	f7 b4 02 e0 	subhs	r4,-32
8000be3a:	f4 04 09 4b 	lsl	r11,r10,r4
8000be3e:	30 0a       	mov	r10,0
8000be40:	08 17       	sub	r7,r4
8000be42:	a3 8a       	lsr	r10,0x2
8000be44:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000be48:	a3 8b       	lsr	r11,0x2
8000be4a:	c1 1b       	rjmp	8000bc6c <__avr32_f64_div+0x20>
8000be4c:	a3 79       	lsl	r9,0x3
8000be4e:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000be52:	a3 78       	lsl	r8,0x3
8000be54:	f3 e8 10 04 	or	r4,r9,r8
8000be58:	c6 f0       	breq	8000bf36 <__avr32_f64_div_res_subnormal+0xa0>
8000be5a:	f2 04 12 00 	clz	r4,r9
8000be5e:	c1 70       	breq	8000be8c <__avr32_f64_div_round_subnormal+0xe0>
8000be60:	c0 c3       	brcs	8000be78 <__avr32_f64_div_round_subnormal+0xcc>
8000be62:	e8 05 11 20 	rsub	r5,r4,32
8000be66:	f2 04 09 49 	lsl	r9,r9,r4
8000be6a:	f0 05 0a 45 	lsr	r5,r8,r5
8000be6e:	0a 49       	or	r9,r5
8000be70:	f0 04 09 48 	lsl	r8,r8,r4
8000be74:	08 16       	sub	r6,r4
8000be76:	c0 b8       	rjmp	8000be8c <__avr32_f64_div_round_subnormal+0xe0>
8000be78:	f0 04 12 00 	clz	r4,r8
8000be7c:	f9 b4 03 00 	movlo	r4,0
8000be80:	f7 b4 02 e0 	subhs	r4,-32
8000be84:	f0 04 09 49 	lsl	r9,r8,r4
8000be88:	30 08       	mov	r8,0
8000be8a:	08 16       	sub	r6,r4
8000be8c:	a3 88       	lsr	r8,0x2
8000be8e:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000be92:	a3 89       	lsr	r9,0x2
8000be94:	cf ca       	rjmp	8000bc8c <__avr32_f64_div+0x40>

8000be96 <__avr32_f64_div_res_subnormal>:
8000be96:	5c 37       	neg	r7
8000be98:	2f f7       	sub	r7,-1
8000be9a:	f1 b7 04 c0 	satu	r7,0x6
8000be9e:	e0 47 00 20 	cp.w	r7,32
8000bea2:	c1 54       	brge	8000becc <__avr32_f64_div_res_subnormal+0x36>
8000bea4:	ee 06 11 20 	rsub	r6,r7,32
8000bea8:	e4 07 0a 42 	lsr	r2,r2,r7
8000beac:	e6 06 09 4c 	lsl	r12,r3,r6
8000beb0:	18 42       	or	r2,r12
8000beb2:	e6 07 0a 43 	lsr	r3,r3,r7
8000beb6:	f4 06 09 41 	lsl	r1,r10,r6
8000beba:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bebe:	f6 06 09 4c 	lsl	r12,r11,r6
8000bec2:	18 4a       	or	r10,r12
8000bec4:	f6 07 0a 4b 	lsr	r11,r11,r7
8000bec8:	30 00       	mov	r0,0
8000beca:	c1 58       	rjmp	8000bef4 <__avr32_f64_div_res_subnormal+0x5e>
8000becc:	ee 06 11 20 	rsub	r6,r7,32
8000bed0:	f9 b0 00 00 	moveq	r0,0
8000bed4:	f9 bc 00 00 	moveq	r12,0
8000bed8:	c0 50       	breq	8000bee2 <__avr32_f64_div_res_subnormal+0x4c>
8000beda:	f4 06 09 40 	lsl	r0,r10,r6
8000bede:	f6 06 09 4c 	lsl	r12,r11,r6
8000bee2:	e6 07 0a 42 	lsr	r2,r3,r7
8000bee6:	30 03       	mov	r3,0
8000bee8:	f4 07 0a 41 	lsr	r1,r10,r7
8000beec:	18 41       	or	r1,r12
8000beee:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bef2:	30 0b       	mov	r11,0
8000bef4:	e0 12 ff 00 	andl	r2,0xff00
8000bef8:	e8 12 00 80 	orl	r2,0x80
8000befc:	e6 08 06 46 	mulu.d	r6,r3,r8
8000bf00:	e4 09 07 46 	macu.d	r6,r2,r9
8000bf04:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bf08:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bf0c:	0c 05       	add	r5,r6
8000bf0e:	f0 07 00 48 	adc	r8,r8,r7
8000bf12:	5c 09       	acr	r9
8000bf14:	30 07       	mov	r7,0
8000bf16:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bf1a:	00 34       	cp.w	r4,r0
8000bf1c:	e2 05 13 00 	cpc	r5,r1
8000bf20:	c4 6b       	rjmp	8000bdac <__avr32_f64_div_round_subnormal>
8000bf22:	1c 9b       	mov	r11,lr
8000bf24:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bf28:	30 0a       	mov	r10,0
8000bf2a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bf2e:	3f fb       	mov	r11,-1
8000bf30:	30 0a       	mov	r10,0
8000bf32:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bf36:	f5 eb 10 04 	or	r4,r10,r11
8000bf3a:	c0 90       	breq	8000bf4c <__avr32_f64_div_op1_zero>
8000bf3c:	1c 9b       	mov	r11,lr
8000bf3e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bf42:	ea 1b 7f f0 	orh	r11,0x7ff0
8000bf46:	30 0a       	mov	r10,0
8000bf48:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000bf4c <__avr32_f64_div_op1_zero>:
8000bf4c:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000bf50:	ce f0       	breq	8000bf2e <__avr32_f64_div_res_subnormal+0x98>
8000bf52:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000bf56:	e0 44 07 ff 	cp.w	r4,2047
8000bf5a:	ce 41       	brne	8000bf22 <__avr32_f64_div_res_subnormal+0x8c>
8000bf5c:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000bf60:	ce 10       	breq	8000bf22 <__avr32_f64_div_res_subnormal+0x8c>
8000bf62:	ce 6b       	rjmp	8000bf2e <__avr32_f64_div_res_subnormal+0x98>

8000bf64 <__avr32_umod64>:
8000bf64:	d4 31       	pushm	r0-r7,lr
8000bf66:	1a 97       	mov	r7,sp
8000bf68:	20 3d       	sub	sp,12
8000bf6a:	10 9c       	mov	r12,r8
8000bf6c:	12 95       	mov	r5,r9
8000bf6e:	14 9e       	mov	lr,r10
8000bf70:	16 91       	mov	r1,r11
8000bf72:	16 96       	mov	r6,r11
8000bf74:	58 09       	cp.w	r9,0
8000bf76:	e0 81 00 81 	brne	8000c078 <__avr32_umod64+0x114>
8000bf7a:	16 38       	cp.w	r8,r11
8000bf7c:	e0 88 00 12 	brls	8000bfa0 <__avr32_umod64+0x3c>
8000bf80:	f0 08 12 00 	clz	r8,r8
8000bf84:	c4 e0       	breq	8000c020 <__avr32_umod64+0xbc>
8000bf86:	f6 08 09 46 	lsl	r6,r11,r8
8000bf8a:	f8 08 09 4c 	lsl	r12,r12,r8
8000bf8e:	f0 0b 11 20 	rsub	r11,r8,32
8000bf92:	f4 08 09 4e 	lsl	lr,r10,r8
8000bf96:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000bf9a:	f7 e6 10 06 	or	r6,r11,r6
8000bf9e:	c4 18       	rjmp	8000c020 <__avr32_umod64+0xbc>
8000bfa0:	58 08       	cp.w	r8,0
8000bfa2:	c0 51       	brne	8000bfac <__avr32_umod64+0x48>
8000bfa4:	30 19       	mov	r9,1
8000bfa6:	f2 08 0d 08 	divu	r8,r9,r8
8000bfaa:	10 9c       	mov	r12,r8
8000bfac:	f8 08 12 00 	clz	r8,r12
8000bfb0:	c0 31       	brne	8000bfb6 <__avr32_umod64+0x52>
8000bfb2:	18 16       	sub	r6,r12
8000bfb4:	c3 68       	rjmp	8000c020 <__avr32_umod64+0xbc>
8000bfb6:	f0 03 11 20 	rsub	r3,r8,32
8000bfba:	f4 03 0a 4b 	lsr	r11,r10,r3
8000bfbe:	f8 08 09 4c 	lsl	r12,r12,r8
8000bfc2:	ec 08 09 49 	lsl	r9,r6,r8
8000bfc6:	ec 03 0a 43 	lsr	r3,r6,r3
8000bfca:	f7 e9 10 09 	or	r9,r11,r9
8000bfce:	f8 05 16 10 	lsr	r5,r12,0x10
8000bfd2:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bfd6:	e6 05 0d 02 	divu	r2,r3,r5
8000bfda:	f2 0e 16 10 	lsr	lr,r9,0x10
8000bfde:	ec 02 02 4b 	mul	r11,r6,r2
8000bfe2:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000bfe6:	16 3e       	cp.w	lr,r11
8000bfe8:	c0 72       	brcc	8000bff6 <__avr32_umod64+0x92>
8000bfea:	18 0e       	add	lr,r12
8000bfec:	18 3e       	cp.w	lr,r12
8000bfee:	c0 43       	brcs	8000bff6 <__avr32_umod64+0x92>
8000bff0:	16 3e       	cp.w	lr,r11
8000bff2:	fd dc e3 0e 	addcs	lr,lr,r12
8000bff6:	fc 0b 01 03 	sub	r3,lr,r11
8000bffa:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000bffe:	e6 05 0d 02 	divu	r2,r3,r5
8000c002:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c006:	a5 36       	mul	r6,r2
8000c008:	0c 39       	cp.w	r9,r6
8000c00a:	c0 72       	brcc	8000c018 <__avr32_umod64+0xb4>
8000c00c:	18 09       	add	r9,r12
8000c00e:	18 39       	cp.w	r9,r12
8000c010:	c0 43       	brcs	8000c018 <__avr32_umod64+0xb4>
8000c012:	0c 39       	cp.w	r9,r6
8000c014:	f3 dc e3 09 	addcs	r9,r9,r12
8000c018:	f2 06 01 06 	sub	r6,r9,r6
8000c01c:	f4 08 09 4e 	lsl	lr,r10,r8
8000c020:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c024:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c028:	ec 0a 0d 02 	divu	r2,r6,r10
8000c02c:	fc 09 16 10 	lsr	r9,lr,0x10
8000c030:	ea 02 02 4b 	mul	r11,r5,r2
8000c034:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c038:	16 39       	cp.w	r9,r11
8000c03a:	c0 72       	brcc	8000c048 <__avr32_umod64+0xe4>
8000c03c:	18 09       	add	r9,r12
8000c03e:	18 39       	cp.w	r9,r12
8000c040:	c0 43       	brcs	8000c048 <__avr32_umod64+0xe4>
8000c042:	16 39       	cp.w	r9,r11
8000c044:	f3 dc e3 09 	addcs	r9,r9,r12
8000c048:	f2 0b 01 0b 	sub	r11,r9,r11
8000c04c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c050:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c054:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c058:	ea 0a 02 4a 	mul	r10,r5,r10
8000c05c:	14 3e       	cp.w	lr,r10
8000c05e:	c0 72       	brcc	8000c06c <__avr32_umod64+0x108>
8000c060:	18 0e       	add	lr,r12
8000c062:	18 3e       	cp.w	lr,r12
8000c064:	c0 43       	brcs	8000c06c <__avr32_umod64+0x108>
8000c066:	14 3e       	cp.w	lr,r10
8000c068:	fd dc e3 0e 	addcs	lr,lr,r12
8000c06c:	fc 0a 01 0a 	sub	r10,lr,r10
8000c070:	30 0b       	mov	r11,0
8000c072:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c076:	c7 b8       	rjmp	8000c16c <__avr32_umod64+0x208>
8000c078:	16 39       	cp.w	r9,r11
8000c07a:	e0 8b 00 79 	brhi	8000c16c <__avr32_umod64+0x208>
8000c07e:	f2 09 12 00 	clz	r9,r9
8000c082:	c1 21       	brne	8000c0a6 <__avr32_umod64+0x142>
8000c084:	10 3a       	cp.w	r10,r8
8000c086:	5f 2b       	srhs	r11
8000c088:	0a 31       	cp.w	r1,r5
8000c08a:	5f ba       	srhi	r10
8000c08c:	f7 ea 10 0a 	or	r10,r11,r10
8000c090:	f2 0a 18 00 	cp.b	r10,r9
8000c094:	c0 60       	breq	8000c0a0 <__avr32_umod64+0x13c>
8000c096:	fc 08 01 0c 	sub	r12,lr,r8
8000c09a:	e2 05 01 46 	sbc	r6,r1,r5
8000c09e:	18 9e       	mov	lr,r12
8000c0a0:	0c 9b       	mov	r11,r6
8000c0a2:	1c 9a       	mov	r10,lr
8000c0a4:	c6 48       	rjmp	8000c16c <__avr32_umod64+0x208>
8000c0a6:	ea 09 09 4c 	lsl	r12,r5,r9
8000c0aa:	f2 06 11 20 	rsub	r6,r9,32
8000c0ae:	f6 09 09 4b 	lsl	r11,r11,r9
8000c0b2:	f0 09 09 42 	lsl	r2,r8,r9
8000c0b6:	ef 46 ff f4 	st.w	r7[-12],r6
8000c0ba:	f0 06 0a 48 	lsr	r8,r8,r6
8000c0be:	18 48       	or	r8,r12
8000c0c0:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c0c4:	f4 09 09 43 	lsl	r3,r10,r9
8000c0c8:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c0cc:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c0d0:	16 4a       	or	r10,r11
8000c0d2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c0d6:	f8 0b 0d 04 	divu	r4,r12,r11
8000c0da:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c0de:	08 91       	mov	r1,r4
8000c0e0:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c0e4:	e8 0e 02 46 	mul	r6,r4,lr
8000c0e8:	0c 3c       	cp.w	r12,r6
8000c0ea:	c0 a2       	brcc	8000c0fe <__avr32_umod64+0x19a>
8000c0ec:	20 11       	sub	r1,1
8000c0ee:	10 0c       	add	r12,r8
8000c0f0:	10 3c       	cp.w	r12,r8
8000c0f2:	c0 63       	brcs	8000c0fe <__avr32_umod64+0x19a>
8000c0f4:	0c 3c       	cp.w	r12,r6
8000c0f6:	f7 b1 03 01 	sublo	r1,1
8000c0fa:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c0fe:	0c 1c       	sub	r12,r6
8000c100:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c104:	f8 0b 0d 04 	divu	r4,r12,r11
8000c108:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c10c:	08 96       	mov	r6,r4
8000c10e:	e8 0e 02 4e 	mul	lr,r4,lr
8000c112:	1c 3b       	cp.w	r11,lr
8000c114:	c0 a2       	brcc	8000c128 <__avr32_umod64+0x1c4>
8000c116:	20 16       	sub	r6,1
8000c118:	10 0b       	add	r11,r8
8000c11a:	10 3b       	cp.w	r11,r8
8000c11c:	c0 63       	brcs	8000c128 <__avr32_umod64+0x1c4>
8000c11e:	1c 3b       	cp.w	r11,lr
8000c120:	f7 b6 03 01 	sublo	r6,1
8000c124:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c128:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c12c:	1c 1b       	sub	r11,lr
8000c12e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c132:	00 9e       	mov	lr,r0
8000c134:	02 9c       	mov	r12,r1
8000c136:	16 3c       	cp.w	r12,r11
8000c138:	e0 8b 00 08 	brhi	8000c148 <__avr32_umod64+0x1e4>
8000c13c:	5f 06       	sreq	r6
8000c13e:	06 30       	cp.w	r0,r3
8000c140:	5f ba       	srhi	r10
8000c142:	ed ea 00 0a 	and	r10,r6,r10
8000c146:	c0 60       	breq	8000c152 <__avr32_umod64+0x1ee>
8000c148:	fc 02 01 04 	sub	r4,lr,r2
8000c14c:	f8 08 01 4c 	sbc	r12,r12,r8
8000c150:	08 9e       	mov	lr,r4
8000c152:	e6 0e 01 0a 	sub	r10,r3,lr
8000c156:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c15a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c15e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c162:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c166:	f8 01 09 4c 	lsl	r12,r12,r1
8000c16a:	18 4a       	or	r10,r12
8000c16c:	2f dd       	sub	sp,-12
8000c16e:	d8 32       	popm	r0-r7,pc

8000c170 <__do_global_ctors_aux>:
8000c170:	d4 21       	pushm	r4-r7,lr
8000c172:	30 c7       	mov	r7,12
8000c174:	c0 28       	rjmp	8000c178 <__do_global_ctors_aux+0x8>
8000c176:	5d 18       	icall	r8
8000c178:	20 47       	sub	r7,4
8000c17a:	6e 08       	ld.w	r8,r7[0x0]
8000c17c:	5b f8       	cp.w	r8,-1
8000c17e:	cf c1       	brne	8000c176 <__do_global_ctors_aux+0x6>
8000c180:	d8 22       	popm	r4-r7,pc
8000c182:	d7 03       	nop

Disassembly of section .exception:

8000c200 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
8000c200:	c0 08       	rjmp	8000c200 <_evba>
	...

8000c204 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
8000c204:	c0 08       	rjmp	8000c204 <_handle_TLB_Multiple_Hit>
	...

8000c208 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
8000c208:	c0 08       	rjmp	8000c208 <_handle_Bus_Error_Data_Fetch>
	...

8000c20c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000c20c:	c0 08       	rjmp	8000c20c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c210 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
8000c210:	c0 08       	rjmp	8000c210 <_handle_NMI>
	...

8000c214 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
8000c214:	c0 08       	rjmp	8000c214 <_handle_Instruction_Address>
	...

8000c218 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
8000c218:	c0 08       	rjmp	8000c218 <_handle_ITLB_Protection>
	...

8000c21c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000c21c:	c0 08       	rjmp	8000c21c <_handle_Breakpoint>
	...

8000c220 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
8000c220:	c0 08       	rjmp	8000c220 <_handle_Illegal_Opcode>
	...

8000c224 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
8000c224:	c0 08       	rjmp	8000c224 <_handle_Unimplemented_Instruction>
	...

8000c228 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
8000c228:	c0 08       	rjmp	8000c228 <_handle_Privilege_Violation>
	...

8000c22c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000c22c:	c0 08       	rjmp	8000c22c <_handle_Floating_Point>
	...

8000c230 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
8000c230:	c0 08       	rjmp	8000c230 <_handle_Coprocessor_Absent>
	...

8000c234 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
8000c234:	c0 08       	rjmp	8000c234 <_handle_Data_Address_Read>
	...

8000c238 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
8000c238:	c0 08       	rjmp	8000c238 <_handle_Data_Address_Write>
	...

8000c23c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000c23c:	c0 08       	rjmp	8000c23c <_handle_DTLB_Protection_Read>
	...

8000c240 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
8000c240:	c0 08       	rjmp	8000c240 <_handle_DTLB_Protection_Write>
	...

8000c244 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
8000c244:	c0 08       	rjmp	8000c244 <_handle_DTLB_Modified>
	...

8000c250 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
8000c250:	c0 08       	rjmp	8000c250 <_handle_ITLB_Miss>
	...

8000c260 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
8000c260:	c0 08       	rjmp	8000c260 <_handle_DTLB_Miss_Read>
	...

8000c270 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
8000c270:	c0 08       	rjmp	8000c270 <_handle_DTLB_Miss_Write>
	...

8000c300 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c300:	fe cf 74 38 	sub	pc,pc,29752

8000c304 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c304:	30 0c       	mov	r12,0
8000c306:	fe b0 c0 51 	rcall	800043a8 <_get_interrupt_handler>
8000c30a:	58 0c       	cp.w	r12,0
8000c30c:	f8 0f 17 10 	movne	pc,r12
8000c310:	d6 03       	rete

8000c312 <_int1>:
8000c312:	30 1c       	mov	r12,1
8000c314:	fe b0 c0 4a 	rcall	800043a8 <_get_interrupt_handler>
8000c318:	58 0c       	cp.w	r12,0
8000c31a:	f8 0f 17 10 	movne	pc,r12
8000c31e:	d6 03       	rete

8000c320 <_int2>:
8000c320:	30 2c       	mov	r12,2
8000c322:	fe b0 c0 43 	rcall	800043a8 <_get_interrupt_handler>
8000c326:	58 0c       	cp.w	r12,0
8000c328:	f8 0f 17 10 	movne	pc,r12
8000c32c:	d6 03       	rete

8000c32e <_int3>:
8000c32e:	30 3c       	mov	r12,3
8000c330:	fe b0 c0 3c 	rcall	800043a8 <_get_interrupt_handler>
8000c334:	58 0c       	cp.w	r12,0
8000c336:	f8 0f 17 10 	movne	pc,r12
8000c33a:	d6 03       	rete
8000c33c:	d7 03       	nop
8000c33e:	d7 03       	nop
8000c340:	d7 03       	nop
8000c342:	d7 03       	nop
8000c344:	d7 03       	nop
8000c346:	d7 03       	nop
8000c348:	d7 03       	nop
8000c34a:	d7 03       	nop
8000c34c:	d7 03       	nop
8000c34e:	d7 03       	nop
8000c350:	d7 03       	nop
8000c352:	d7 03       	nop
8000c354:	d7 03       	nop
8000c356:	d7 03       	nop
8000c358:	d7 03       	nop
8000c35a:	d7 03       	nop
8000c35c:	d7 03       	nop
8000c35e:	d7 03       	nop
8000c360:	d7 03       	nop
8000c362:	d7 03       	nop
8000c364:	d7 03       	nop
8000c366:	d7 03       	nop
8000c368:	d7 03       	nop
8000c36a:	d7 03       	nop
8000c36c:	d7 03       	nop
8000c36e:	d7 03       	nop
8000c370:	d7 03       	nop
8000c372:	d7 03       	nop
8000c374:	d7 03       	nop
8000c376:	d7 03       	nop
8000c378:	d7 03       	nop
8000c37a:	d7 03       	nop
8000c37c:	d7 03       	nop
8000c37e:	d7 03       	nop
8000c380:	d7 03       	nop
8000c382:	d7 03       	nop
8000c384:	d7 03       	nop
8000c386:	d7 03       	nop
8000c388:	d7 03       	nop
8000c38a:	d7 03       	nop
8000c38c:	d7 03       	nop
8000c38e:	d7 03       	nop
8000c390:	d7 03       	nop
8000c392:	d7 03       	nop
8000c394:	d7 03       	nop
8000c396:	d7 03       	nop
8000c398:	d7 03       	nop
8000c39a:	d7 03       	nop
8000c39c:	d7 03       	nop
8000c39e:	d7 03       	nop
8000c3a0:	d7 03       	nop
8000c3a2:	d7 03       	nop
8000c3a4:	d7 03       	nop
8000c3a6:	d7 03       	nop
8000c3a8:	d7 03       	nop
8000c3aa:	d7 03       	nop
8000c3ac:	d7 03       	nop
8000c3ae:	d7 03       	nop
8000c3b0:	d7 03       	nop
8000c3b2:	d7 03       	nop
8000c3b4:	d7 03       	nop
8000c3b6:	d7 03       	nop
8000c3b8:	d7 03       	nop
8000c3ba:	d7 03       	nop
8000c3bc:	d7 03       	nop
8000c3be:	d7 03       	nop
8000c3c0:	d7 03       	nop
8000c3c2:	d7 03       	nop
8000c3c4:	d7 03       	nop
8000c3c6:	d7 03       	nop
8000c3c8:	d7 03       	nop
8000c3ca:	d7 03       	nop
8000c3cc:	d7 03       	nop
8000c3ce:	d7 03       	nop
8000c3d0:	d7 03       	nop
8000c3d2:	d7 03       	nop
8000c3d4:	d7 03       	nop
8000c3d6:	d7 03       	nop
8000c3d8:	d7 03       	nop
8000c3da:	d7 03       	nop
8000c3dc:	d7 03       	nop
8000c3de:	d7 03       	nop
8000c3e0:	d7 03       	nop
8000c3e2:	d7 03       	nop
8000c3e4:	d7 03       	nop
8000c3e6:	d7 03       	nop
8000c3e8:	d7 03       	nop
8000c3ea:	d7 03       	nop
8000c3ec:	d7 03       	nop
8000c3ee:	d7 03       	nop
8000c3f0:	d7 03       	nop
8000c3f2:	d7 03       	nop
8000c3f4:	d7 03       	nop
8000c3f6:	d7 03       	nop
8000c3f8:	d7 03       	nop
8000c3fa:	d7 03       	nop
8000c3fc:	d7 03       	nop
8000c3fe:	d7 03       	nop

Disassembly of section .fini:

8000c400 <_fini>:
8000c400:	eb cd 40 40 	pushm	r6,lr
8000c404:	48 26       	lddpc	r6,8000c40c <_fini+0xc>
8000c406:	1e 26       	rsub	r6,pc
8000c408:	c0 48       	rjmp	8000c410 <_fini+0x10>
8000c40a:	d7 03       	nop
8000c40c:	80 00       	ld.sh	r0,r0[0x0]
8000c40e:	c3 ea       	rjmp	8000c08a <__avr32_umod64+0x126>
8000c410:	fe b0 ae 3e 	rcall	8000208c <__do_global_dtors_aux>
8000c414:	e3 cd 80 40 	ldm	sp++,r6,pc
