
Lab63_peter.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         0000a130  80002028  80002028  00002428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  8000c200  8000c200  0000c600  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  8000c400  8000c400  0000c800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       000006a0  8000c418  8000c418  0000c818  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  8 .ctors        00000008  00000008  8000cab8  0000d008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .dtors        00000008  00000010  8000cac0  0000d010  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .jcr          00000004  00000018  8000cac8  0000d018  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got          00000000  0000001c  8000cacc  0000d01c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         00000510  0000001c  8000cacc  0000d01c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .bss          000002d0  00000548  00000548  00000000  2**2
                  ALLOC
 14 .heap         0000e7e8  00000818  00000818  00000000  2**0
                  ALLOC
 15 .comment      00000030  00000000  00000000  0000d52c  2**0
                  CONTENTS, READONLY
 16 .debug_aranges 00001120  00000000  00000000  0000d560  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_pubnames 00001f9c  00000000  00000000  0000e680  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_info   00029ea6  00000000  00000000  0001061c  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_abbrev 00005e9f  00000000  00000000  0003a4c2  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_line   00012b34  00000000  00000000  00040361  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_frame  00002eb4  00000000  00000000  00052e98  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_str    000056ed  00000000  00000000  00055d4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_loc    0000a917  00000000  00000000  0005b439  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_macinfo 010d0c0a  00000000  00000000  00065d50  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 26 .debug_ranges 00001178  00000000  00000000  0113695a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	20 28       	sub	r8,2

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

8000200c <_init>:
8000200c:	eb cd 40 40 	pushm	r6,lr
80002010:	48 26       	lddpc	r6,80002018 <_init+0xc>
80002012:	1e 26       	rsub	r6,pc
80002014:	c0 48       	rjmp	8000201c <_init+0x10>
80002016:	d7 03       	nop
80002018:	80 00       	ld.sh	r0,r0[0x0]
8000201a:	1f f6       	ld.ub	r6,pc[0x7]
8000201c:	c5 6c       	rcall	800020c8 <frame_dummy>
8000201e:	e0 a0 50 93 	rcall	8000c144 <__do_global_ctors_aux>
80002022:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002028 <_stext>:
80002028:	30 07       	mov	r7,0
8000202a:	e0 7a 00 00 	mov	r10,65536
8000202e:	5b fa       	cp.w	r10,-1
80002030:	f4 0d 17 10 	movne	sp,r10
80002034:	49 4b       	lddpc	r11,80002084 <_stext+0x5c>
80002036:	30 8c       	mov	r12,8
80002038:	18 3b       	cp.w	r11,r12
8000203a:	c0 70       	breq	80002048 <_stext+0x20>
8000203c:	e0 6a 05 30 	mov	r10,1328
80002040:	b7 09       	ld.d	r8,r11++
80002042:	b9 28       	st.d	r12++,r8
80002044:	14 3c       	cp.w	r12,r10
80002046:	cf d5       	brlt	80002040 <_stext+0x18>
80002048:	e0 6a 08 18 	mov	r10,2072
8000204c:	e0 6c 05 30 	mov	r12,1328
80002050:	30 08       	mov	r8,0
80002052:	30 09       	mov	r9,0
80002054:	b9 28       	st.d	r12++,r8
80002056:	14 3c       	cp.w	r12,r10
80002058:	cf e5       	brlt	80002054 <_stext+0x2c>
8000205a:	e0 a0 16 cd 	rcall	80004df4 <_init_startup>
8000205e:	48 bc       	lddpc	r12,80002088 <_stext+0x60>
80002060:	e0 a0 24 36 	rcall	800068cc <atexit>
80002064:	cd 4f       	rcall	8000200c <_init>
80002066:	1a 9c       	mov	r12,sp
80002068:	30 0b       	mov	r11,0
8000206a:	e0 a0 28 bf 	rcall	800071e8 <_init_argv>
8000206e:	5b fc       	cp.w	r12,-1
80002070:	f9 bc 00 00 	moveq	r12,0
80002074:	f9 ba 00 00 	moveq	r10,0
80002078:	14 1d       	sub	sp,r10
8000207a:	e0 a0 0f a1 	rcall	80003fbc <main>
8000207e:	e0 a0 24 2f 	rcall	800068dc <exit>
80002082:	d7 03       	nop
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	ca b8       	rjmp	800021dc <dip204_init+0xd4>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	c4 00       	breq	8000210a <dip204_init+0x2>

8000208c <__do_global_dtors_aux>:
8000208c:	d4 21       	pushm	r4-r7,lr
8000208e:	e0 68 05 48 	mov	r8,1352
80002092:	11 89       	ld.ub	r9,r8[0x0]
80002094:	30 08       	mov	r8,0
80002096:	f0 09 18 00 	cp.b	r9,r8
8000209a:	c1 61       	brne	800020c6 <__do_global_dtors_aux+0x3a>
8000209c:	31 08       	mov	r8,16
8000209e:	31 46       	mov	r6,20
800020a0:	10 95       	mov	r5,r8
800020a2:	10 16       	sub	r6,r8
800020a4:	e0 67 05 4c 	mov	r7,1356
800020a8:	a3 46       	asr	r6,0x2
800020aa:	20 16       	sub	r6,1
800020ac:	c0 68       	rjmp	800020b8 <__do_global_dtors_aux+0x2c>
800020ae:	2f f8       	sub	r8,-1
800020b0:	8f 08       	st.w	r7[0x0],r8
800020b2:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020b6:	5d 18       	icall	r8
800020b8:	6e 08       	ld.w	r8,r7[0x0]
800020ba:	0c 38       	cp.w	r8,r6
800020bc:	cf 93       	brcs	800020ae <__do_global_dtors_aux+0x22>
800020be:	30 19       	mov	r9,1
800020c0:	e0 68 05 48 	mov	r8,1352
800020c4:	b0 89       	st.b	r8[0x0],r9
800020c6:	d8 22       	popm	r4-r7,pc

800020c8 <frame_dummy>:
800020c8:	d4 01       	pushm	lr
800020ca:	31 8c       	mov	r12,24
800020cc:	78 08       	ld.w	r8,r12[0x0]
800020ce:	58 08       	cp.w	r8,0
800020d0:	c0 50       	breq	800020da <frame_dummy+0x12>
800020d2:	48 38       	lddpc	r8,800020dc <frame_dummy+0x14>
800020d4:	58 08       	cp.w	r8,0
800020d6:	c0 20       	breq	800020da <frame_dummy+0x12>
800020d8:	5d 18       	icall	r8
800020da:	d8 02       	popm	pc
800020dc:	00 00       	add	r0,r0
	...

800020e0 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern bool sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
800020e0:	eb cd 40 80 	pushm	r7,lr
800020e4:	1a 97       	mov	r7,sp
	}
#endif

	switch (CONFIG_SYSCLK_SOURCE) {
	case SYSCLK_SRC_RCSYS:
		return OSC_SLOW_NOMINAL_HZ;
800020e6:	e0 78 c2 00 	mov	r8,115200

	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
800020ea:	10 9c       	mov	r12,r8
800020ec:	e3 cd 80 80 	ldm	sp++,r7,pc

800020f0 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
800020f0:	eb cd 40 80 	pushm	r7,lr
800020f4:	1a 97       	mov	r7,sp
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_CPU_DIV;
800020f6:	f0 1f 00 04 	mcall	80002104 <sysclk_get_cpu_hz+0x14>
800020fa:	18 98       	mov	r8,r12
}
800020fc:	10 9c       	mov	r12,r8
800020fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002102:	00 00       	add	r0,r0
80002104:	80 00       	ld.sh	r0,r0[0x0]
80002106:	20 e0       	sub	r0,14

80002108 <dip204_init>:


/****************************** global functions *****************************/

void dip204_init(backlight_options option, bool backlight_on)
{
80002108:	eb cd 40 8f 	pushm	r0-r3,r7,lr
8000210c:	1a 97       	mov	r7,sp
8000210e:	fa cd 01 ac 	sub	sp,sp,428
80002112:	ef 4c fe b8 	st.w	r7[-328],r12
80002116:	16 98       	mov	r8,r11
80002118:	ef 68 fe b4 	st.b	r7[-332],r8
  pwm_opt_t pwm_opt;  // pwm option config

  if (option == backlight_PWM)
8000211c:	ee f8 fe b8 	ld.w	r8,r7[-328]
80002120:	58 18       	cp.w	r8,1
80002122:	c6 41       	brne	800021ea <dip204_init+0xe2>
  {
    channel_id = DIP204_PWM_CHANNEL;
80002124:	fe f9 0a 84 	ld.w	r9,pc[2692]
80002128:	30 68       	mov	r8,6
8000212a:	93 08       	st.w	r9[0x0],r8
    gpio_enable_module_pin(DIP204_PWM_PIN, DIP204_PWM_FUNCTION);
8000212c:	30 2b       	mov	r11,2
8000212e:	33 2c       	mov	r12,50
80002130:	f0 1f 02 9f 	mcall	80002bac <dip204_init+0xaa4>

    // PWM controller configuration
    pwm_opt.diva=0;
80002134:	30 08       	mov	r8,0
80002136:	ef 48 ff 14 	st.w	r7[-236],r8
    pwm_opt.divb=0;
8000213a:	30 08       	mov	r8,0
8000213c:	ef 48 ff 10 	st.w	r7[-240],r8
    pwm_opt.prea=0;
80002140:	30 08       	mov	r8,0
80002142:	ef 48 ff 1c 	st.w	r7[-228],r8
    pwm_opt.preb=0;
80002146:	30 08       	mov	r8,0
80002148:	ef 48 ff 18 	st.w	r7[-232],r8

    pwm_init(&pwm_opt);
8000214c:	ee c8 00 f0 	sub	r8,r7,240
80002150:	10 9c       	mov	r12,r8
80002152:	f0 1f 02 98 	mcall	80002bb0 <dip204_init+0xaa8>
    pwm_duty = (backlight_on) ? DIP204_PERIOD_MAX - 1 : 1;
80002156:	ef 39 fe b4 	ld.ub	r9,r7[-332]
8000215a:	30 08       	mov	r8,0
8000215c:	f0 09 18 00 	cp.b	r9,r8
80002160:	c0 30       	breq	80002166 <dip204_init+0x5e>
80002162:	33 18       	mov	r8,49
80002164:	c0 28       	rjmp	80002168 <dip204_init+0x60>
80002166:	30 18       	mov	r8,1
80002168:	fe f9 0a 4c 	ld.w	r9,pc[2636]
8000216c:	b2 08       	st.h	r9[0x0],r8
    pwm_channel.CMR.calg = PWM_MODE_LEFT_ALIGNED;   // channel mode
8000216e:	fe fa 0a 4a 	ld.w	r10,pc[2634]
80002172:	74 08       	ld.w	r8,r10[0x0]
80002174:	30 09       	mov	r9,0
80002176:	f1 d9 d1 01 	bfins	r8,r9,0x8,0x1
8000217a:	95 08       	st.w	r10[0x0],r8
    pwm_channel.CMR.cpol = PWM_POLARITY_LOW;   // channel polarity
8000217c:	fe fa 0a 3c 	ld.w	r10,pc[2620]
80002180:	74 08       	ld.w	r8,r10[0x0]
80002182:	30 09       	mov	r9,0
80002184:	f1 d9 d1 21 	bfins	r8,r9,0x9,0x1
80002188:	95 08       	st.w	r10[0x0],r8
    pwm_channel.CMR.cpd = PWM_UPDATE_PERIOD;   // not used the first time
8000218a:	fe fa 0a 2e 	ld.w	r10,pc[2606]
8000218e:	74 08       	ld.w	r8,r10[0x0]
80002190:	30 19       	mov	r9,1
80002192:	f1 d9 d1 41 	bfins	r8,r9,0xa,0x1
80002196:	95 08       	st.w	r10[0x0],r8
    pwm_channel.CMR.cpre = AVR32_PWM_CPRE_MCK_DIV_256;   // channel prescaler
80002198:	fe fa 0a 20 	ld.w	r10,pc[2592]
8000219c:	74 08       	ld.w	r8,r10[0x0]
8000219e:	30 89       	mov	r9,8
800021a0:	f1 d9 d0 04 	bfins	r8,r9,0x0,0x4
800021a4:	95 08       	st.w	r10[0x0],r8
    pwm_channel.cdty = pwm_duty;  // channel duty cycle, should be < CPRD
800021a6:	fe f8 0a 0e 	ld.w	r8,pc[2574]
800021aa:	90 08       	ld.sh	r8,r8[0x0]
800021ac:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800021b0:	fe f8 0a 08 	ld.w	r8,pc[2568]
800021b4:	91 19       	st.w	r8[0x4],r9
    pwm_channel.cprd = DIP204_PERIOD_MAX;  // channel period
800021b6:	fe f9 0a 02 	ld.w	r9,pc[2562]
800021ba:	33 28       	mov	r8,50
800021bc:	93 28       	st.w	r9[0x8],r8
    pwm_channel.cupd = 0;  // channel update is not used here.
800021be:	fe f9 09 fa 	ld.w	r9,pc[2554]
800021c2:	30 08       	mov	r8,0
800021c4:	93 48       	st.w	r9[0x10],r8

    pwm_channel_init(channel_id, &pwm_channel);
800021c6:	fe f8 09 e2 	ld.w	r8,pc[2530]
800021ca:	70 08       	ld.w	r8,r8[0x0]
800021cc:	fe fb 09 ec 	ld.w	r11,pc[2540]
800021d0:	10 9c       	mov	r12,r8
800021d2:	f0 1f 02 7b 	mcall	80002bbc <dip204_init+0xab4>
    // start PWM
    pwm_start_channels(1 << channel_id);
800021d6:	fe f8 09 d2 	ld.w	r8,pc[2514]
800021da:	70 09       	ld.w	r9,r8[0x0]
800021dc:	30 18       	mov	r8,1
800021de:	f0 09 09 48 	lsl	r8,r8,r9
800021e2:	10 9c       	mov	r12,r8
800021e4:	f0 1f 02 77 	mcall	80002bc0 <dip204_init+0xab8>
800021e8:	c0 e8       	rjmp	80002204 <dip204_init+0xfc>
  }
  else
  {
    if (backlight_on)
800021ea:	ef 39 fe b4 	ld.ub	r9,r7[-332]
800021ee:	30 08       	mov	r8,0
800021f0:	f0 09 18 00 	cp.b	r9,r8
800021f4:	c0 50       	breq	800021fe <dip204_init+0xf6>
    {
      gpio_clr_gpio_pin(DIP204_BACKLIGHT_PIN);
800021f6:	33 2c       	mov	r12,50
800021f8:	f0 1f 02 73 	mcall	80002bc4 <dip204_init+0xabc>
800021fc:	c0 48       	rjmp	80002204 <dip204_init+0xfc>
    }
    else
    {
      gpio_set_gpio_pin(DIP204_BACKLIGHT_PIN);
800021fe:	33 2c       	mov	r12,50
80002200:	f0 1f 02 72 	mcall	80002bc8 <dip204_init+0xac0>
    }
  }
  // delay for power on
  delay_ms(20);
80002204:	f0 1f 02 72 	mcall	80002bcc <dip204_init+0xac4>
80002208:	18 99       	mov	r9,r12
8000220a:	31 48       	mov	r8,20
8000220c:	ef 48 ff 24 	st.w	r7[-220],r8
80002210:	ef 49 ff 20 	st.w	r7[-224],r9
80002214:	ee f8 ff 24 	ld.w	r8,r7[-220]
80002218:	ef 48 ff 2c 	st.w	r7[-212],r8
8000221c:	ee f8 ff 20 	ld.w	r8,r7[-224]
80002220:	ef 48 ff 28 	st.w	r7[-216],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002224:	ee f0 ff 2c 	ld.w	r0,r7[-212]
80002228:	30 01       	mov	r1,0
8000222a:	ee f2 ff 28 	ld.w	r2,r7[-216]
8000222e:	30 03       	mov	r3,0
80002230:	e2 02 02 49 	mul	r9,r1,r2
80002234:	e6 00 02 48 	mul	r8,r3,r0
80002238:	10 09       	add	r9,r8
8000223a:	e0 02 06 4a 	mulu.d	r10,r0,r2
8000223e:	16 09       	add	r9,r11
80002240:	12 9b       	mov	r11,r9
80002242:	e0 68 03 e7 	mov	r8,999
80002246:	30 09       	mov	r9,0
80002248:	10 0a       	add	r10,r8
8000224a:	f6 09 00 4b 	adc	r11,r11,r9
8000224e:	e0 68 03 e8 	mov	r8,1000
80002252:	30 09       	mov	r9,0
80002254:	f0 1f 02 5f 	mcall	80002bd0 <dip204_init+0xac8>
80002258:	14 98       	mov	r8,r10
8000225a:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000225c:	ef 48 ff 34 	st.w	r7[-204],r8
80002260:	ee c8 01 44 	sub	r8,r7,324
80002264:	ef 48 ff 30 	st.w	r7[-208],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002268:	e1 b8 00 42 	mfsr	r8,0x108
8000226c:	10 99       	mov	r9,r8
8000226e:	ee f8 ff 30 	ld.w	r8,r7[-208]
80002272:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002274:	ee f8 ff 30 	ld.w	r8,r7[-208]
80002278:	70 09       	ld.w	r9,r8[0x0]
8000227a:	ee f8 ff 34 	ld.w	r8,r7[-204]
8000227e:	10 09       	add	r9,r8
80002280:	ee f8 ff 30 	ld.w	r8,r7[-208]
80002284:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002286:	ee f9 ff 30 	ld.w	r9,r7[-208]
8000228a:	30 08       	mov	r8,0
8000228c:	f3 68 00 08 	st.b	r9[8],r8
80002290:	ee c8 01 44 	sub	r8,r7,324
80002294:	ef 48 ff 38 	st.w	r7[-200],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002298:	e1 b8 00 42 	mfsr	r8,0x108
8000229c:	ef 48 ff 3c 	st.w	r7[-196],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800022a0:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022a4:	f1 39 00 08 	ld.ub	r9,r8[8]
800022a8:	30 28       	mov	r8,2
800022aa:	f0 09 18 00 	cp.b	r9,r8
800022ae:	c0 31       	brne	800022b4 <dip204_init+0x1ac>
    return false;
800022b0:	30 08       	mov	r8,0
800022b2:	c4 38       	rjmp	80002338 <dip204_init+0x230>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800022b4:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022b8:	f1 39 00 08 	ld.ub	r9,r8[8]
800022bc:	30 18       	mov	r8,1
800022be:	f0 09 18 00 	cp.b	r9,r8
800022c2:	c0 31       	brne	800022c8 <dip204_init+0x1c0>
    return true;
800022c4:	30 18       	mov	r8,1
800022c6:	c3 98       	rjmp	80002338 <dip204_init+0x230>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800022c8:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022cc:	70 09       	ld.w	r9,r8[0x0]
800022ce:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022d2:	70 18       	ld.w	r8,r8[0x4]
800022d4:	10 39       	cp.w	r9,r8
800022d6:	e0 88 00 1a 	brls	8000230a <dip204_init+0x202>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800022da:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022de:	70 09       	ld.w	r9,r8[0x0]
800022e0:	ee f8 ff 3c 	ld.w	r8,r7[-196]
800022e4:	12 38       	cp.w	r8,r9
800022e6:	c1 02       	brcc	80002306 <dip204_init+0x1fe>
800022e8:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022ec:	70 19       	ld.w	r9,r8[0x4]
800022ee:	ee f8 ff 3c 	ld.w	r8,r7[-196]
800022f2:	12 38       	cp.w	r8,r9
800022f4:	e0 88 00 09 	brls	80002306 <dip204_init+0x1fe>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800022f8:	ee f9 ff 38 	ld.w	r9,r7[-200]
800022fc:	30 18       	mov	r8,1
800022fe:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002302:	30 18       	mov	r8,1
80002304:	c1 a8       	rjmp	80002338 <dip204_init+0x230>
    }
    return false;
80002306:	30 08       	mov	r8,0
80002308:	c1 88       	rjmp	80002338 <dip204_init+0x230>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000230a:	ee f8 ff 38 	ld.w	r8,r7[-200]
8000230e:	70 09       	ld.w	r9,r8[0x0]
80002310:	ee f8 ff 3c 	ld.w	r8,r7[-196]
80002314:	12 38       	cp.w	r8,r9
80002316:	c0 93       	brcs	80002328 <dip204_init+0x220>
80002318:	ee f8 ff 38 	ld.w	r8,r7[-200]
8000231c:	70 19       	ld.w	r9,r8[0x4]
8000231e:	ee f8 ff 3c 	ld.w	r8,r7[-196]
80002322:	12 38       	cp.w	r8,r9
80002324:	e0 88 00 09 	brls	80002336 <dip204_init+0x22e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002328:	ee f9 ff 38 	ld.w	r9,r7[-200]
8000232c:	30 18       	mov	r8,1
8000232e:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002332:	30 18       	mov	r8,1
80002334:	c0 28       	rjmp	80002338 <dip204_init+0x230>
    }
    return false;
80002336:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002338:	58 08       	cp.w	r8,0
8000233a:	ca b0       	breq	80002290 <dip204_init+0x188>
  // select the LCD chip
  dip204_select();
8000233c:	f0 1f 02 26 	mcall	80002bd4 <dip204_init+0xacc>
  // Send Command Start Byte
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002340:	e0 6c 00 f8 	mov	r12,248
80002344:	f0 1f 02 25 	mcall	80002bd8 <dip204_init+0xad0>
  // Send "extended Function Set" Command  (RE=1)
  dip204_write_byte(0x34);
80002348:	33 4c       	mov	r12,52
8000234a:	f0 1f 02 24 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
8000234e:	f0 1f 02 20 	mcall	80002bcc <dip204_init+0xac4>
80002352:	18 99       	mov	r9,r12
80002354:	30 18       	mov	r8,1
80002356:	ef 48 ff 44 	st.w	r7[-188],r8
8000235a:	ef 49 ff 40 	st.w	r7[-192],r9
8000235e:	ee f8 ff 44 	ld.w	r8,r7[-188]
80002362:	ef 48 ff 4c 	st.w	r7[-180],r8
80002366:	ee f8 ff 40 	ld.w	r8,r7[-192]
8000236a:	ef 48 ff 48 	st.w	r7[-184],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000236e:	ee fc ff 4c 	ld.w	r12,r7[-180]
80002372:	ef 4c fe 60 	st.w	r7[-416],r12
80002376:	30 0b       	mov	r11,0
80002378:	ef 4b fe 5c 	st.w	r7[-420],r11
8000237c:	ee fa ff 48 	ld.w	r10,r7[-184]
80002380:	ef 4a fe 58 	st.w	r7[-424],r10
80002384:	30 09       	mov	r9,0
80002386:	ef 49 fe 54 	st.w	r7[-428],r9
8000238a:	ee f9 fe 5c 	ld.w	r9,r7[-420]
8000238e:	ee f8 fe 58 	ld.w	r8,r7[-424]
80002392:	b1 39       	mul	r9,r8
80002394:	ee f8 fe 54 	ld.w	r8,r7[-428]
80002398:	ee fc fe 60 	ld.w	r12,r7[-416]
8000239c:	b9 38       	mul	r8,r12
8000239e:	10 09       	add	r9,r8
800023a0:	ee f8 fe 60 	ld.w	r8,r7[-416]
800023a4:	ee fc fe 58 	ld.w	r12,r7[-424]
800023a8:	f0 0c 06 4a 	mulu.d	r10,r8,r12
800023ac:	16 09       	add	r9,r11
800023ae:	12 9b       	mov	r11,r9
800023b0:	e0 68 03 e7 	mov	r8,999
800023b4:	30 09       	mov	r9,0
800023b6:	10 0a       	add	r10,r8
800023b8:	f6 09 00 4b 	adc	r11,r11,r9
800023bc:	e0 68 03 e8 	mov	r8,1000
800023c0:	30 09       	mov	r9,0
800023c2:	f0 1f 02 04 	mcall	80002bd0 <dip204_init+0xac8>
800023c6:	14 98       	mov	r8,r10
800023c8:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
800023ca:	ef 48 ff 54 	st.w	r7[-172],r8
800023ce:	ee c8 01 38 	sub	r8,r7,312
800023d2:	ef 48 ff 50 	st.w	r7[-176],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800023d6:	e1 b8 00 42 	mfsr	r8,0x108
800023da:	10 99       	mov	r9,r8
800023dc:	ee f8 ff 50 	ld.w	r8,r7[-176]
800023e0:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800023e2:	ee f8 ff 50 	ld.w	r8,r7[-176]
800023e6:	70 09       	ld.w	r9,r8[0x0]
800023e8:	ee f8 ff 54 	ld.w	r8,r7[-172]
800023ec:	10 09       	add	r9,r8
800023ee:	ee f8 ff 50 	ld.w	r8,r7[-176]
800023f2:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800023f4:	ee f9 ff 50 	ld.w	r9,r7[-176]
800023f8:	30 08       	mov	r8,0
800023fa:	f3 68 00 08 	st.b	r9[8],r8
800023fe:	ee c8 01 38 	sub	r8,r7,312
80002402:	ef 48 ff 58 	st.w	r7[-168],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002406:	e1 b8 00 42 	mfsr	r8,0x108
8000240a:	ef 48 ff 5c 	st.w	r7[-164],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000240e:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002412:	f1 39 00 08 	ld.ub	r9,r8[8]
80002416:	30 28       	mov	r8,2
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c0 31       	brne	80002422 <dip204_init+0x31a>
    return false;
8000241e:	30 08       	mov	r8,0
80002420:	c4 38       	rjmp	800024a6 <dip204_init+0x39e>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002422:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002426:	f1 39 00 08 	ld.ub	r9,r8[8]
8000242a:	30 18       	mov	r8,1
8000242c:	f0 09 18 00 	cp.b	r9,r8
80002430:	c0 31       	brne	80002436 <dip204_init+0x32e>
    return true;
80002432:	30 18       	mov	r8,1
80002434:	c3 98       	rjmp	800024a6 <dip204_init+0x39e>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002436:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000243a:	70 09       	ld.w	r9,r8[0x0]
8000243c:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002440:	70 18       	ld.w	r8,r8[0x4]
80002442:	10 39       	cp.w	r9,r8
80002444:	e0 88 00 1a 	brls	80002478 <dip204_init+0x370>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002448:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000244c:	70 09       	ld.w	r9,r8[0x0]
8000244e:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002452:	12 38       	cp.w	r8,r9
80002454:	c1 02       	brcc	80002474 <dip204_init+0x36c>
80002456:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000245a:	70 19       	ld.w	r9,r8[0x4]
8000245c:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002460:	12 38       	cp.w	r8,r9
80002462:	e0 88 00 09 	brls	80002474 <dip204_init+0x36c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002466:	ee f9 ff 58 	ld.w	r9,r7[-168]
8000246a:	30 18       	mov	r8,1
8000246c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002470:	30 18       	mov	r8,1
80002472:	c1 a8       	rjmp	800024a6 <dip204_init+0x39e>
    }
    return false;
80002474:	30 08       	mov	r8,0
80002476:	c1 88       	rjmp	800024a6 <dip204_init+0x39e>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002478:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000247c:	70 09       	ld.w	r9,r8[0x0]
8000247e:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002482:	12 38       	cp.w	r8,r9
80002484:	c0 93       	brcs	80002496 <dip204_init+0x38e>
80002486:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000248a:	70 19       	ld.w	r9,r8[0x4]
8000248c:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002490:	12 38       	cp.w	r8,r9
80002492:	e0 88 00 09 	brls	800024a4 <dip204_init+0x39c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002496:	ee f9 ff 58 	ld.w	r9,r7[-168]
8000249a:	30 18       	mov	r8,1
8000249c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800024a0:	30 18       	mov	r8,1
800024a2:	c0 28       	rjmp	800024a6 <dip204_init+0x39e>
    }
    return false;
800024a4:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800024a6:	58 08       	cp.w	r8,0
800024a8:	ca b0       	breq	800023fe <dip204_init+0x2f6>
  // Send "Enter 4-Line Mode" Command
  dip204_write_byte(0x09);
800024aa:	30 9c       	mov	r12,9
800024ac:	f0 1f 01 cb 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
800024b0:	f0 1f 01 c7 	mcall	80002bcc <dip204_init+0xac4>
800024b4:	18 99       	mov	r9,r12
800024b6:	30 18       	mov	r8,1
800024b8:	ef 48 ff 64 	st.w	r7[-156],r8
800024bc:	ef 49 ff 60 	st.w	r7[-160],r9
800024c0:	ee f8 ff 64 	ld.w	r8,r7[-156]
800024c4:	ef 48 ff 6c 	st.w	r7[-148],r8
800024c8:	ee f8 ff 60 	ld.w	r8,r7[-160]
800024cc:	ef 48 ff 68 	st.w	r7[-152],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800024d0:	ee fb ff 6c 	ld.w	r11,r7[-148]
800024d4:	ef 4b fe 70 	st.w	r7[-400],r11
800024d8:	30 0a       	mov	r10,0
800024da:	ef 4a fe 6c 	st.w	r7[-404],r10
800024de:	ee f9 ff 68 	ld.w	r9,r7[-152]
800024e2:	ef 49 fe 68 	st.w	r7[-408],r9
800024e6:	30 08       	mov	r8,0
800024e8:	ef 48 fe 64 	st.w	r7[-412],r8
800024ec:	ee f9 fe 6c 	ld.w	r9,r7[-404]
800024f0:	ee fc fe 68 	ld.w	r12,r7[-408]
800024f4:	b9 39       	mul	r9,r12
800024f6:	ee f8 fe 64 	ld.w	r8,r7[-412]
800024fa:	ee fb fe 70 	ld.w	r11,r7[-400]
800024fe:	b7 38       	mul	r8,r11
80002500:	10 09       	add	r9,r8
80002502:	ee f8 fe 70 	ld.w	r8,r7[-400]
80002506:	ee fc fe 68 	ld.w	r12,r7[-408]
8000250a:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000250e:	16 09       	add	r9,r11
80002510:	12 9b       	mov	r11,r9
80002512:	e0 68 03 e7 	mov	r8,999
80002516:	30 09       	mov	r9,0
80002518:	10 0a       	add	r10,r8
8000251a:	f6 09 00 4b 	adc	r11,r11,r9
8000251e:	e0 68 03 e8 	mov	r8,1000
80002522:	30 09       	mov	r9,0
80002524:	f0 1f 01 ab 	mcall	80002bd0 <dip204_init+0xac8>
80002528:	14 98       	mov	r8,r10
8000252a:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000252c:	ef 48 ff 74 	st.w	r7[-140],r8
80002530:	ee c8 01 2c 	sub	r8,r7,300
80002534:	ef 48 ff 70 	st.w	r7[-144],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002538:	e1 b8 00 42 	mfsr	r8,0x108
8000253c:	10 99       	mov	r9,r8
8000253e:	ee f8 ff 70 	ld.w	r8,r7[-144]
80002542:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002544:	ee f8 ff 70 	ld.w	r8,r7[-144]
80002548:	70 09       	ld.w	r9,r8[0x0]
8000254a:	ee f8 ff 74 	ld.w	r8,r7[-140]
8000254e:	10 09       	add	r9,r8
80002550:	ee f8 ff 70 	ld.w	r8,r7[-144]
80002554:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002556:	ee f9 ff 70 	ld.w	r9,r7[-144]
8000255a:	30 08       	mov	r8,0
8000255c:	f3 68 00 08 	st.b	r9[8],r8
80002560:	ee c8 01 2c 	sub	r8,r7,300
80002564:	ef 48 ff 78 	st.w	r7[-136],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002568:	e1 b8 00 42 	mfsr	r8,0x108
8000256c:	ef 48 ff 7c 	st.w	r7[-132],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002570:	ee f8 ff 78 	ld.w	r8,r7[-136]
80002574:	f1 39 00 08 	ld.ub	r9,r8[8]
80002578:	30 28       	mov	r8,2
8000257a:	f0 09 18 00 	cp.b	r9,r8
8000257e:	c0 31       	brne	80002584 <dip204_init+0x47c>
    return false;
80002580:	30 08       	mov	r8,0
80002582:	c4 38       	rjmp	80002608 <dip204_init+0x500>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002584:	ee f8 ff 78 	ld.w	r8,r7[-136]
80002588:	f1 39 00 08 	ld.ub	r9,r8[8]
8000258c:	30 18       	mov	r8,1
8000258e:	f0 09 18 00 	cp.b	r9,r8
80002592:	c0 31       	brne	80002598 <dip204_init+0x490>
    return true;
80002594:	30 18       	mov	r8,1
80002596:	c3 98       	rjmp	80002608 <dip204_init+0x500>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002598:	ee f8 ff 78 	ld.w	r8,r7[-136]
8000259c:	70 09       	ld.w	r9,r8[0x0]
8000259e:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025a2:	70 18       	ld.w	r8,r8[0x4]
800025a4:	10 39       	cp.w	r9,r8
800025a6:	e0 88 00 1a 	brls	800025da <dip204_init+0x4d2>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800025aa:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025ae:	70 09       	ld.w	r9,r8[0x0]
800025b0:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025b4:	12 38       	cp.w	r8,r9
800025b6:	c1 02       	brcc	800025d6 <dip204_init+0x4ce>
800025b8:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025bc:	70 19       	ld.w	r9,r8[0x4]
800025be:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025c2:	12 38       	cp.w	r8,r9
800025c4:	e0 88 00 09 	brls	800025d6 <dip204_init+0x4ce>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800025c8:	ee f9 ff 78 	ld.w	r9,r7[-136]
800025cc:	30 18       	mov	r8,1
800025ce:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800025d2:	30 18       	mov	r8,1
800025d4:	c1 a8       	rjmp	80002608 <dip204_init+0x500>
    }
    return false;
800025d6:	30 08       	mov	r8,0
800025d8:	c1 88       	rjmp	80002608 <dip204_init+0x500>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800025da:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025de:	70 09       	ld.w	r9,r8[0x0]
800025e0:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025e4:	12 38       	cp.w	r8,r9
800025e6:	c0 93       	brcs	800025f8 <dip204_init+0x4f0>
800025e8:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025ec:	70 19       	ld.w	r9,r8[0x4]
800025ee:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025f2:	12 38       	cp.w	r8,r9
800025f4:	e0 88 00 09 	brls	80002606 <dip204_init+0x4fe>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800025f8:	ee f9 ff 78 	ld.w	r9,r7[-136]
800025fc:	30 18       	mov	r8,1
800025fe:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002602:	30 18       	mov	r8,1
80002604:	c0 28       	rjmp	80002608 <dip204_init+0x500>
    }
    return false;
80002606:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002608:	58 08       	cp.w	r8,0
8000260a:	ca b0       	breq	80002560 <dip204_init+0x458>
  // Send "Function Set" Command (RE=0)
  dip204_write_byte(0x30);
8000260c:	33 0c       	mov	r12,48
8000260e:	f0 1f 01 73 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
80002612:	f0 1f 01 6f 	mcall	80002bcc <dip204_init+0xac4>
80002616:	18 99       	mov	r9,r12
80002618:	30 18       	mov	r8,1
8000261a:	ef 48 ff 84 	st.w	r7[-124],r8
8000261e:	ef 49 ff 80 	st.w	r7[-128],r9
80002622:	ee f8 ff 84 	ld.w	r8,r7[-124]
80002626:	ef 48 ff 8c 	st.w	r7[-116],r8
8000262a:	ee f8 ff 80 	ld.w	r8,r7[-128]
8000262e:	ef 48 ff 88 	st.w	r7[-120],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002632:	ee fb ff 8c 	ld.w	r11,r7[-116]
80002636:	ef 4b fe 80 	st.w	r7[-384],r11
8000263a:	30 0a       	mov	r10,0
8000263c:	ef 4a fe 7c 	st.w	r7[-388],r10
80002640:	ee f9 ff 88 	ld.w	r9,r7[-120]
80002644:	ef 49 fe 78 	st.w	r7[-392],r9
80002648:	30 08       	mov	r8,0
8000264a:	ef 48 fe 74 	st.w	r7[-396],r8
8000264e:	ee f9 fe 7c 	ld.w	r9,r7[-388]
80002652:	ee fc fe 78 	ld.w	r12,r7[-392]
80002656:	b9 39       	mul	r9,r12
80002658:	ee f8 fe 74 	ld.w	r8,r7[-396]
8000265c:	ee fb fe 80 	ld.w	r11,r7[-384]
80002660:	b7 38       	mul	r8,r11
80002662:	10 09       	add	r9,r8
80002664:	ee f8 fe 80 	ld.w	r8,r7[-384]
80002668:	ee fc fe 78 	ld.w	r12,r7[-392]
8000266c:	f0 0c 06 4a 	mulu.d	r10,r8,r12
80002670:	16 09       	add	r9,r11
80002672:	12 9b       	mov	r11,r9
80002674:	e0 68 03 e7 	mov	r8,999
80002678:	30 09       	mov	r9,0
8000267a:	10 0a       	add	r10,r8
8000267c:	f6 09 00 4b 	adc	r11,r11,r9
80002680:	e0 68 03 e8 	mov	r8,1000
80002684:	30 09       	mov	r9,0
80002686:	f0 1f 01 53 	mcall	80002bd0 <dip204_init+0xac8>
8000268a:	14 98       	mov	r8,r10
8000268c:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000268e:	ef 48 ff 94 	st.w	r7[-108],r8
80002692:	ee c8 01 20 	sub	r8,r7,288
80002696:	ef 48 ff 90 	st.w	r7[-112],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000269a:	e1 b8 00 42 	mfsr	r8,0x108
8000269e:	10 99       	mov	r9,r8
800026a0:	ee f8 ff 90 	ld.w	r8,r7[-112]
800026a4:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800026a6:	ee f8 ff 90 	ld.w	r8,r7[-112]
800026aa:	70 09       	ld.w	r9,r8[0x0]
800026ac:	ee f8 ff 94 	ld.w	r8,r7[-108]
800026b0:	10 09       	add	r9,r8
800026b2:	ee f8 ff 90 	ld.w	r8,r7[-112]
800026b6:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800026b8:	ee f9 ff 90 	ld.w	r9,r7[-112]
800026bc:	30 08       	mov	r8,0
800026be:	f3 68 00 08 	st.b	r9[8],r8
800026c2:	ee c8 01 20 	sub	r8,r7,288
800026c6:	ef 48 ff 98 	st.w	r7[-104],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800026ca:	e1 b8 00 42 	mfsr	r8,0x108
800026ce:	ef 48 ff 9c 	st.w	r7[-100],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800026d2:	ee f8 ff 98 	ld.w	r8,r7[-104]
800026d6:	f1 39 00 08 	ld.ub	r9,r8[8]
800026da:	30 28       	mov	r8,2
800026dc:	f0 09 18 00 	cp.b	r9,r8
800026e0:	c0 31       	brne	800026e6 <dip204_init+0x5de>
    return false;
800026e2:	30 08       	mov	r8,0
800026e4:	c4 38       	rjmp	8000276a <dip204_init+0x662>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800026e6:	ee f8 ff 98 	ld.w	r8,r7[-104]
800026ea:	f1 39 00 08 	ld.ub	r9,r8[8]
800026ee:	30 18       	mov	r8,1
800026f0:	f0 09 18 00 	cp.b	r9,r8
800026f4:	c0 31       	brne	800026fa <dip204_init+0x5f2>
    return true;
800026f6:	30 18       	mov	r8,1
800026f8:	c3 98       	rjmp	8000276a <dip204_init+0x662>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800026fa:	ee f8 ff 98 	ld.w	r8,r7[-104]
800026fe:	70 09       	ld.w	r9,r8[0x0]
80002700:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002704:	70 18       	ld.w	r8,r8[0x4]
80002706:	10 39       	cp.w	r9,r8
80002708:	e0 88 00 1a 	brls	8000273c <dip204_init+0x634>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000270c:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002710:	70 08       	ld.w	r8,r8[0x0]
80002712:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002716:	10 39       	cp.w	r9,r8
80002718:	c1 02       	brcc	80002738 <dip204_init+0x630>
8000271a:	ee f8 ff 98 	ld.w	r8,r7[-104]
8000271e:	70 18       	ld.w	r8,r8[0x4]
80002720:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002724:	10 39       	cp.w	r9,r8
80002726:	e0 88 00 09 	brls	80002738 <dip204_init+0x630>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000272a:	ee f9 ff 98 	ld.w	r9,r7[-104]
8000272e:	30 18       	mov	r8,1
80002730:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002734:	30 18       	mov	r8,1
80002736:	c1 a8       	rjmp	8000276a <dip204_init+0x662>
    }
    return false;
80002738:	30 08       	mov	r8,0
8000273a:	c1 88       	rjmp	8000276a <dip204_init+0x662>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000273c:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002740:	70 08       	ld.w	r8,r8[0x0]
80002742:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002746:	10 39       	cp.w	r9,r8
80002748:	c0 93       	brcs	8000275a <dip204_init+0x652>
8000274a:	ee f8 ff 98 	ld.w	r8,r7[-104]
8000274e:	70 18       	ld.w	r8,r8[0x4]
80002750:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002754:	10 39       	cp.w	r9,r8
80002756:	e0 88 00 09 	brls	80002768 <dip204_init+0x660>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000275a:	ee f9 ff 98 	ld.w	r9,r7[-104]
8000275e:	30 18       	mov	r8,1
80002760:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002764:	30 18       	mov	r8,1
80002766:	c0 28       	rjmp	8000276a <dip204_init+0x662>
    }
    return false;
80002768:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
8000276a:	58 08       	cp.w	r8,0
8000276c:	ca b0       	breq	800026c2 <dip204_init+0x5ba>
  // Send "Display On Command: Display On, Cursor On, Blink On"
  dip204_write_byte(0x0F);
8000276e:	30 fc       	mov	r12,15
80002770:	f0 1f 01 1a 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
80002774:	f0 1f 01 16 	mcall	80002bcc <dip204_init+0xac4>
80002778:	18 98       	mov	r8,r12
8000277a:	30 19       	mov	r9,1
8000277c:	ef 49 ff a4 	st.w	r7[-92],r9
80002780:	ef 48 ff a0 	st.w	r7[-96],r8
80002784:	ee f8 ff a4 	ld.w	r8,r7[-92]
80002788:	ef 48 ff ac 	st.w	r7[-84],r8
8000278c:	ee f8 ff a0 	ld.w	r8,r7[-96]
80002790:	ef 48 ff a8 	st.w	r7[-88],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002794:	ee fb ff ac 	ld.w	r11,r7[-84]
80002798:	ef 4b fe 90 	st.w	r7[-368],r11
8000279c:	30 0a       	mov	r10,0
8000279e:	ef 4a fe 8c 	st.w	r7[-372],r10
800027a2:	ee f9 ff a8 	ld.w	r9,r7[-88]
800027a6:	ef 49 fe 88 	st.w	r7[-376],r9
800027aa:	30 08       	mov	r8,0
800027ac:	ef 48 fe 84 	st.w	r7[-380],r8
800027b0:	ee fa fe 8c 	ld.w	r10,r7[-372]
800027b4:	ee fc fe 88 	ld.w	r12,r7[-376]
800027b8:	b9 3a       	mul	r10,r12
800027ba:	ee f8 fe 84 	ld.w	r8,r7[-380]
800027be:	ee fb fe 90 	ld.w	r11,r7[-368]
800027c2:	b7 38       	mul	r8,r11
800027c4:	10 0a       	add	r10,r8
800027c6:	ee fc fe 90 	ld.w	r12,r7[-368]
800027ca:	ee fb fe 88 	ld.w	r11,r7[-376]
800027ce:	f8 0b 06 48 	mulu.d	r8,r12,r11
800027d2:	12 0a       	add	r10,r9
800027d4:	14 99       	mov	r9,r10
800027d6:	e0 6a 03 e7 	mov	r10,999
800027da:	30 0b       	mov	r11,0
800027dc:	f0 0a 00 0a 	add	r10,r8,r10
800027e0:	f2 0b 00 4b 	adc	r11,r9,r11
800027e4:	e0 68 03 e8 	mov	r8,1000
800027e8:	30 09       	mov	r9,0
800027ea:	f0 1f 00 fa 	mcall	80002bd0 <dip204_init+0xac8>
800027ee:	14 98       	mov	r8,r10
800027f0:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
800027f2:	ef 48 ff b4 	st.w	r7[-76],r8
800027f6:	ee c8 01 14 	sub	r8,r7,276
800027fa:	ef 48 ff b0 	st.w	r7[-80],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800027fe:	e1 b8 00 42 	mfsr	r8,0x108
80002802:	10 99       	mov	r9,r8
80002804:	ee f8 ff b0 	ld.w	r8,r7[-80]
80002808:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000280a:	ee f8 ff b0 	ld.w	r8,r7[-80]
8000280e:	70 09       	ld.w	r9,r8[0x0]
80002810:	ee f8 ff b4 	ld.w	r8,r7[-76]
80002814:	10 09       	add	r9,r8
80002816:	ee f8 ff b0 	ld.w	r8,r7[-80]
8000281a:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000281c:	ee f9 ff b0 	ld.w	r9,r7[-80]
80002820:	30 08       	mov	r8,0
80002822:	f3 68 00 08 	st.b	r9[8],r8
80002826:	ee c8 01 14 	sub	r8,r7,276
8000282a:	ef 48 ff b8 	st.w	r7[-72],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000282e:	e1 b8 00 42 	mfsr	r8,0x108
80002832:	ef 48 ff bc 	st.w	r7[-68],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002836:	ee f8 ff b8 	ld.w	r8,r7[-72]
8000283a:	f1 39 00 08 	ld.ub	r9,r8[8]
8000283e:	30 28       	mov	r8,2
80002840:	f0 09 18 00 	cp.b	r9,r8
80002844:	c0 31       	brne	8000284a <dip204_init+0x742>
    return false;
80002846:	30 08       	mov	r8,0
80002848:	c4 38       	rjmp	800028ce <dip204_init+0x7c6>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
8000284a:	ee f8 ff b8 	ld.w	r8,r7[-72]
8000284e:	f1 39 00 08 	ld.ub	r9,r8[8]
80002852:	30 18       	mov	r8,1
80002854:	f0 09 18 00 	cp.b	r9,r8
80002858:	c0 31       	brne	8000285e <dip204_init+0x756>
    return true;
8000285a:	30 18       	mov	r8,1
8000285c:	c3 98       	rjmp	800028ce <dip204_init+0x7c6>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000285e:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002862:	70 09       	ld.w	r9,r8[0x0]
80002864:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002868:	70 18       	ld.w	r8,r8[0x4]
8000286a:	10 39       	cp.w	r9,r8
8000286c:	e0 88 00 1a 	brls	800028a0 <dip204_init+0x798>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002870:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002874:	70 08       	ld.w	r8,r8[0x0]
80002876:	ee f9 ff bc 	ld.w	r9,r7[-68]
8000287a:	10 39       	cp.w	r9,r8
8000287c:	c1 02       	brcc	8000289c <dip204_init+0x794>
8000287e:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002882:	70 18       	ld.w	r8,r8[0x4]
80002884:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002888:	10 39       	cp.w	r9,r8
8000288a:	e0 88 00 09 	brls	8000289c <dip204_init+0x794>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000288e:	ee f9 ff b8 	ld.w	r9,r7[-72]
80002892:	30 18       	mov	r8,1
80002894:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002898:	30 18       	mov	r8,1
8000289a:	c1 a8       	rjmp	800028ce <dip204_init+0x7c6>
    }
    return false;
8000289c:	30 08       	mov	r8,0
8000289e:	c1 88       	rjmp	800028ce <dip204_init+0x7c6>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800028a0:	ee f8 ff b8 	ld.w	r8,r7[-72]
800028a4:	70 08       	ld.w	r8,r8[0x0]
800028a6:	ee f9 ff bc 	ld.w	r9,r7[-68]
800028aa:	10 39       	cp.w	r9,r8
800028ac:	c0 93       	brcs	800028be <dip204_init+0x7b6>
800028ae:	ee f8 ff b8 	ld.w	r8,r7[-72]
800028b2:	70 18       	ld.w	r8,r8[0x4]
800028b4:	ee f9 ff bc 	ld.w	r9,r7[-68]
800028b8:	10 39       	cp.w	r9,r8
800028ba:	e0 88 00 09 	brls	800028cc <dip204_init+0x7c4>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800028be:	ee f9 ff b8 	ld.w	r9,r7[-72]
800028c2:	30 18       	mov	r8,1
800028c4:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800028c8:	30 18       	mov	r8,1
800028ca:	c0 28       	rjmp	800028ce <dip204_init+0x7c6>
    }
    return false;
800028cc:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800028ce:	58 08       	cp.w	r8,0
800028d0:	ca b0       	breq	80002826 <dip204_init+0x71e>
  // Send "Display Clear" Command
  dip204_write_byte(0x01);
800028d2:	30 1c       	mov	r12,1
800028d4:	f0 1f 00 c1 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(5);
800028d8:	f0 1f 00 bd 	mcall	80002bcc <dip204_init+0xac4>
800028dc:	18 98       	mov	r8,r12
800028de:	30 59       	mov	r9,5
800028e0:	ef 49 ff c4 	st.w	r7[-60],r9
800028e4:	ef 48 ff c0 	st.w	r7[-64],r8
800028e8:	ee f8 ff c4 	ld.w	r8,r7[-60]
800028ec:	ef 48 ff cc 	st.w	r7[-52],r8
800028f0:	ee f8 ff c0 	ld.w	r8,r7[-64]
800028f4:	ef 48 ff c8 	st.w	r7[-56],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800028f8:	ee fa ff cc 	ld.w	r10,r7[-52]
800028fc:	ef 4a fe a0 	st.w	r7[-352],r10
80002900:	30 09       	mov	r9,0
80002902:	ef 49 fe 9c 	st.w	r7[-356],r9
80002906:	ee f8 ff c8 	ld.w	r8,r7[-56]
8000290a:	ef 48 fe 98 	st.w	r7[-360],r8
8000290e:	30 0c       	mov	r12,0
80002910:	ef 4c fe 94 	st.w	r7[-364],r12
80002914:	ee fa fe 9c 	ld.w	r10,r7[-356]
80002918:	ee fb fe 98 	ld.w	r11,r7[-360]
8000291c:	b7 3a       	mul	r10,r11
8000291e:	ee f8 fe 94 	ld.w	r8,r7[-364]
80002922:	ee f9 fe a0 	ld.w	r9,r7[-352]
80002926:	b3 38       	mul	r8,r9
80002928:	10 0a       	add	r10,r8
8000292a:	ee fc fe a0 	ld.w	r12,r7[-352]
8000292e:	ee fb fe 98 	ld.w	r11,r7[-360]
80002932:	f8 0b 06 48 	mulu.d	r8,r12,r11
80002936:	12 0a       	add	r10,r9
80002938:	14 99       	mov	r9,r10
8000293a:	e0 6a 03 e7 	mov	r10,999
8000293e:	30 0b       	mov	r11,0
80002940:	f0 0a 00 0a 	add	r10,r8,r10
80002944:	f2 0b 00 4b 	adc	r11,r9,r11
80002948:	e0 68 03 e8 	mov	r8,1000
8000294c:	30 09       	mov	r9,0
8000294e:	f0 1f 00 a1 	mcall	80002bd0 <dip204_init+0xac8>
80002952:	14 98       	mov	r8,r10
80002954:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002956:	ef 48 ff d4 	st.w	r7[-44],r8
8000295a:	ee c8 01 08 	sub	r8,r7,264
8000295e:	ef 48 ff d0 	st.w	r7[-48],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002962:	e1 b8 00 42 	mfsr	r8,0x108
80002966:	10 99       	mov	r9,r8
80002968:	ee f8 ff d0 	ld.w	r8,r7[-48]
8000296c:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000296e:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002972:	70 09       	ld.w	r9,r8[0x0]
80002974:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002978:	10 09       	add	r9,r8
8000297a:	ee f8 ff d0 	ld.w	r8,r7[-48]
8000297e:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002980:	ee f9 ff d0 	ld.w	r9,r7[-48]
80002984:	30 08       	mov	r8,0
80002986:	f3 68 00 08 	st.b	r9[8],r8
8000298a:	ee c8 01 08 	sub	r8,r7,264
8000298e:	ef 48 ff d8 	st.w	r7[-40],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002992:	e1 b8 00 42 	mfsr	r8,0x108
80002996:	ef 48 ff dc 	st.w	r7[-36],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000299a:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000299e:	f1 39 00 08 	ld.ub	r9,r8[8]
800029a2:	30 28       	mov	r8,2
800029a4:	f0 09 18 00 	cp.b	r9,r8
800029a8:	c0 31       	brne	800029ae <dip204_init+0x8a6>
    return false;
800029aa:	30 08       	mov	r8,0
800029ac:	c4 38       	rjmp	80002a32 <dip204_init+0x92a>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800029ae:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029b2:	f1 39 00 08 	ld.ub	r9,r8[8]
800029b6:	30 18       	mov	r8,1
800029b8:	f0 09 18 00 	cp.b	r9,r8
800029bc:	c0 31       	brne	800029c2 <dip204_init+0x8ba>
    return true;
800029be:	30 18       	mov	r8,1
800029c0:	c3 98       	rjmp	80002a32 <dip204_init+0x92a>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800029c2:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029c6:	70 09       	ld.w	r9,r8[0x0]
800029c8:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029cc:	70 18       	ld.w	r8,r8[0x4]
800029ce:	10 39       	cp.w	r9,r8
800029d0:	e0 88 00 1a 	brls	80002a04 <dip204_init+0x8fc>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800029d4:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029d8:	70 08       	ld.w	r8,r8[0x0]
800029da:	ee f9 ff dc 	ld.w	r9,r7[-36]
800029de:	10 39       	cp.w	r9,r8
800029e0:	c1 02       	brcc	80002a00 <dip204_init+0x8f8>
800029e2:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029e6:	70 18       	ld.w	r8,r8[0x4]
800029e8:	ee f9 ff dc 	ld.w	r9,r7[-36]
800029ec:	10 39       	cp.w	r9,r8
800029ee:	e0 88 00 09 	brls	80002a00 <dip204_init+0x8f8>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800029f2:	ee f9 ff d8 	ld.w	r9,r7[-40]
800029f6:	30 18       	mov	r8,1
800029f8:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800029fc:	30 18       	mov	r8,1
800029fe:	c1 a8       	rjmp	80002a32 <dip204_init+0x92a>
    }
    return false;
80002a00:	30 08       	mov	r8,0
80002a02:	c1 88       	rjmp	80002a32 <dip204_init+0x92a>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002a04:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002a08:	70 08       	ld.w	r8,r8[0x0]
80002a0a:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002a0e:	10 39       	cp.w	r9,r8
80002a10:	c0 93       	brcs	80002a22 <dip204_init+0x91a>
80002a12:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002a16:	70 18       	ld.w	r8,r8[0x4]
80002a18:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002a1c:	10 39       	cp.w	r9,r8
80002a1e:	e0 88 00 09 	brls	80002a30 <dip204_init+0x928>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002a22:	ee f9 ff d8 	ld.w	r9,r7[-40]
80002a26:	30 18       	mov	r8,1
80002a28:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002a2c:	30 18       	mov	r8,1
80002a2e:	c0 28       	rjmp	80002a32 <dip204_init+0x92a>
    }
    return false;
80002a30:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002a32:	58 08       	cp.w	r8,0
80002a34:	ca b0       	breq	8000298a <dip204_init+0x882>
  // Send "Entry Mode Set Command: Increment Mode, Entire Shift off"
  dip204_write_byte(0x06);
80002a36:	30 6c       	mov	r12,6
80002a38:	f0 1f 00 68 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
80002a3c:	f0 1f 00 64 	mcall	80002bcc <dip204_init+0xac4>
80002a40:	18 98       	mov	r8,r12
80002a42:	30 19       	mov	r9,1
80002a44:	ef 49 ff e4 	st.w	r7[-28],r9
80002a48:	ef 48 ff e0 	st.w	r7[-32],r8
80002a4c:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002a50:	ef 48 ff ec 	st.w	r7[-20],r8
80002a54:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002a58:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002a5c:	ee fa ff ec 	ld.w	r10,r7[-20]
80002a60:	ef 4a fe b0 	st.w	r7[-336],r10
80002a64:	30 09       	mov	r9,0
80002a66:	ef 49 fe ac 	st.w	r7[-340],r9
80002a6a:	ee f8 ff e8 	ld.w	r8,r7[-24]
80002a6e:	ef 48 fe a8 	st.w	r7[-344],r8
80002a72:	30 0c       	mov	r12,0
80002a74:	ef 4c fe a4 	st.w	r7[-348],r12
80002a78:	ee fa fe ac 	ld.w	r10,r7[-340]
80002a7c:	ee fb fe a8 	ld.w	r11,r7[-344]
80002a80:	b7 3a       	mul	r10,r11
80002a82:	ee f8 fe a4 	ld.w	r8,r7[-348]
80002a86:	ee f9 fe b0 	ld.w	r9,r7[-336]
80002a8a:	b3 38       	mul	r8,r9
80002a8c:	10 0a       	add	r10,r8
80002a8e:	ee fc fe b0 	ld.w	r12,r7[-336]
80002a92:	ee fb fe a8 	ld.w	r11,r7[-344]
80002a96:	f8 0b 06 48 	mulu.d	r8,r12,r11
80002a9a:	12 0a       	add	r10,r9
80002a9c:	14 99       	mov	r9,r10
80002a9e:	e0 6a 03 e7 	mov	r10,999
80002aa2:	30 0b       	mov	r11,0
80002aa4:	f0 0a 00 0a 	add	r10,r8,r10
80002aa8:	f2 0b 00 4b 	adc	r11,r9,r11
80002aac:	e0 68 03 e8 	mov	r8,1000
80002ab0:	30 09       	mov	r9,0
80002ab2:	f0 1f 00 48 	mcall	80002bd0 <dip204_init+0xac8>
80002ab6:	14 98       	mov	r8,r10
80002ab8:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002aba:	ef 48 ff f4 	st.w	r7[-12],r8
80002abe:	ee c8 00 fc 	sub	r8,r7,252
80002ac2:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002ac6:	e1 b8 00 42 	mfsr	r8,0x108
80002aca:	10 99       	mov	r9,r8
80002acc:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ad0:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002ad2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ad6:	70 09       	ld.w	r9,r8[0x0]
80002ad8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002adc:	10 09       	add	r9,r8
80002ade:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ae2:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002ae4:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002ae8:	30 08       	mov	r8,0
80002aea:	f3 68 00 08 	st.b	r9[8],r8
80002aee:	ee c8 00 fc 	sub	r8,r7,252
80002af2:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002af6:	e1 b8 00 42 	mfsr	r8,0x108
80002afa:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002afe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b02:	f1 39 00 08 	ld.ub	r9,r8[8]
80002b06:	30 28       	mov	r8,2
80002b08:	f0 09 18 00 	cp.b	r9,r8
80002b0c:	c0 31       	brne	80002b12 <dip204_init+0xa0a>
    return false;
80002b0e:	30 08       	mov	r8,0
80002b10:	c4 38       	rjmp	80002b96 <dip204_init+0xa8e>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002b12:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b16:	f1 39 00 08 	ld.ub	r9,r8[8]
80002b1a:	30 18       	mov	r8,1
80002b1c:	f0 09 18 00 	cp.b	r9,r8
80002b20:	c0 31       	brne	80002b26 <dip204_init+0xa1e>
    return true;
80002b22:	30 18       	mov	r8,1
80002b24:	c3 98       	rjmp	80002b96 <dip204_init+0xa8e>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002b26:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b2a:	70 09       	ld.w	r9,r8[0x0]
80002b2c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b30:	70 18       	ld.w	r8,r8[0x4]
80002b32:	10 39       	cp.w	r9,r8
80002b34:	e0 88 00 1a 	brls	80002b68 <dip204_init+0xa60>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002b38:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b3c:	70 08       	ld.w	r8,r8[0x0]
80002b3e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b42:	10 39       	cp.w	r9,r8
80002b44:	c1 02       	brcc	80002b64 <dip204_init+0xa5c>
80002b46:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b4a:	70 18       	ld.w	r8,r8[0x4]
80002b4c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b50:	10 39       	cp.w	r9,r8
80002b52:	e0 88 00 09 	brls	80002b64 <dip204_init+0xa5c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002b56:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002b5a:	30 18       	mov	r8,1
80002b5c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002b60:	30 18       	mov	r8,1
80002b62:	c1 a8       	rjmp	80002b96 <dip204_init+0xa8e>
    }
    return false;
80002b64:	30 08       	mov	r8,0
80002b66:	c1 88       	rjmp	80002b96 <dip204_init+0xa8e>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002b68:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b6c:	70 08       	ld.w	r8,r8[0x0]
80002b6e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b72:	10 39       	cp.w	r9,r8
80002b74:	c0 93       	brcs	80002b86 <dip204_init+0xa7e>
80002b76:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b7a:	70 18       	ld.w	r8,r8[0x4]
80002b7c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b80:	10 39       	cp.w	r9,r8
80002b82:	e0 88 00 09 	brls	80002b94 <dip204_init+0xa8c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002b86:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002b8a:	30 18       	mov	r8,1
80002b8c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002b90:	30 18       	mov	r8,1
80002b92:	c0 28       	rjmp	80002b96 <dip204_init+0xa8e>
    }
    return false;
80002b94:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002b96:	58 08       	cp.w	r8,0
80002b98:	ca b0       	breq	80002aee <dip204_init+0x9e6>
  dip204_wait_busy();
80002b9a:	f0 1f 00 11 	mcall	80002bdc <dip204_init+0xad4>
  // unselect chip
  dip204_unselect();
80002b9e:	f0 1f 00 11 	mcall	80002be0 <dip204_init+0xad8>
}
80002ba2:	29 5d       	sub	sp,-428
80002ba4:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
80002ba8:	00 00       	add	r0,r0
80002baa:	00 1c       	sub	r12,r0
80002bac:	80 00       	ld.sh	r0,r0[0x0]
80002bae:	42 00       	lddsp	r0,sp[0x80]
80002bb0:	80 00       	ld.sh	r0,r0[0x0]
80002bb2:	31 b8       	mov	r8,27
80002bb4:	00 00       	add	r0,r0
80002bb6:	05 50       	ld.sh	r0,--r2
80002bb8:	00 00       	add	r0,r0
80002bba:	05 54       	ld.sh	r4,--r2
80002bbc:	80 00       	ld.sh	r0,r0[0x0]
80002bbe:	32 4c       	mov	r12,36
80002bc0:	80 00       	ld.sh	r0,r0[0x0]
80002bc2:	32 d4       	mov	r4,45
80002bc4:	80 00       	ld.sh	r0,r0[0x0]
80002bc6:	43 78       	lddsp	r8,sp[0xdc]
80002bc8:	80 00       	ld.sh	r0,r0[0x0]
80002bca:	43 10       	lddsp	r0,sp[0xc4]
80002bcc:	80 00       	ld.sh	r0,r0[0x0]
80002bce:	20 f0       	sub	r0,15
80002bd0:	80 00       	ld.sh	r0,r0[0x0]
80002bd2:	66 68       	ld.w	r8,r3[0x18]
80002bd4:	80 00       	ld.sh	r0,r0[0x0]
80002bd6:	2f 50       	sub	r0,-11
80002bd8:	80 00       	ld.sh	r0,r0[0x0]
80002bda:	2f 80       	sub	r0,-8
80002bdc:	80 00       	ld.sh	r0,r0[0x0]
80002bde:	30 64       	mov	r4,6
80002be0:	80 00       	ld.sh	r0,r0[0x0]
80002be2:	2f 68       	sub	r8,-10

80002be4 <dip204_hide_cursor>:
  dip204_unselect();
}


void dip204_hide_cursor(void)
{
80002be4:	eb cd 40 80 	pushm	r7,lr
80002be8:	1a 97       	mov	r7,sp
  /* select the LCD chip */
  dip204_select();
80002bea:	f0 1f 00 08 	mcall	80002c08 <dip204_hide_cursor+0x24>
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002bee:	e0 6c 00 f8 	mov	r12,248
80002bf2:	f0 1f 00 07 	mcall	80002c0c <dip204_hide_cursor+0x28>
  /* Send "Display On Command: Display On, Cursor On, Blink On" */
  dip204_write_byte(0x0C);
80002bf6:	30 cc       	mov	r12,12
80002bf8:	f0 1f 00 05 	mcall	80002c0c <dip204_hide_cursor+0x28>
  dip204_wait_busy();
80002bfc:	f0 1f 00 05 	mcall	80002c10 <dip204_hide_cursor+0x2c>
  /* unselect chip */
  dip204_unselect();
80002c00:	f0 1f 00 05 	mcall	80002c14 <dip204_hide_cursor+0x30>
}
80002c04:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c08:	80 00       	ld.sh	r0,r0[0x0]
80002c0a:	2f 50       	sub	r0,-11
80002c0c:	80 00       	ld.sh	r0,r0[0x0]
80002c0e:	2f 80       	sub	r0,-8
80002c10:	80 00       	ld.sh	r0,r0[0x0]
80002c12:	30 64       	mov	r4,6
80002c14:	80 00       	ld.sh	r0,r0[0x0]
80002c16:	2f 68       	sub	r8,-10

80002c18 <dip204_set_cursor_position>:
  dip204_set_cursor_position(column, line);
}


void dip204_set_cursor_position(unsigned char column, unsigned char line)
{
80002c18:	eb cd 40 80 	pushm	r7,lr
80002c1c:	1a 97       	mov	r7,sp
80002c1e:	20 3d       	sub	sp,12
80002c20:	18 99       	mov	r9,r12
80002c22:	16 98       	mov	r8,r11
80002c24:	ef 69 ff f8 	st.b	r7[-8],r9
80002c28:	ef 68 ff f4 	st.b	r7[-12],r8
  unsigned char address = 0;
80002c2c:	30 08       	mov	r8,0
80002c2e:	ef 68 ff ff 	st.b	r7[-1],r8

  dip204_select();
80002c32:	f0 1f 00 18 	mcall	80002c90 <dip204_set_cursor_position+0x78>
  if ((column <= 20) && (line <= 4))
80002c36:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80002c3a:	31 48       	mov	r8,20
80002c3c:	f0 09 18 00 	cp.b	r9,r8
80002c40:	e0 8b 00 17 	brhi	80002c6e <dip204_set_cursor_position+0x56>
80002c44:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80002c48:	30 48       	mov	r8,4
80002c4a:	f0 09 18 00 	cp.b	r9,r8
80002c4e:	e0 8b 00 10 	brhi	80002c6e <dip204_set_cursor_position+0x56>
  {
    /* Calculate DDRAM address from line and row values */
    address = ( (line-1) * 32 ) + ( column-1 ) + 128;
80002c52:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002c56:	20 18       	sub	r8,1
80002c58:	5c 58       	castu.b	r8
80002c5a:	a5 78       	lsl	r8,0x5
80002c5c:	5c 58       	castu.b	r8
80002c5e:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80002c62:	f2 08 00 08 	add	r8,r9,r8
80002c66:	5c 58       	castu.b	r8
80002c68:	28 18       	sub	r8,-127
80002c6a:	ef 68 ff ff 	st.b	r7[-1],r8
  }
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002c6e:	e0 6c 00 f8 	mov	r12,248
80002c72:	f0 1f 00 09 	mcall	80002c94 <dip204_set_cursor_position+0x7c>
  /* Send Address lower Nibble */
  dip204_write_byte(address);
80002c76:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002c7a:	10 9c       	mov	r12,r8
80002c7c:	f0 1f 00 06 	mcall	80002c94 <dip204_set_cursor_position+0x7c>
  dip204_wait_busy();
80002c80:	f0 1f 00 06 	mcall	80002c98 <dip204_set_cursor_position+0x80>
  dip204_unselect();
80002c84:	f0 1f 00 06 	mcall	80002c9c <dip204_set_cursor_position+0x84>
}
80002c88:	2f dd       	sub	sp,-12
80002c8a:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c8e:	00 00       	add	r0,r0
80002c90:	80 00       	ld.sh	r0,r0[0x0]
80002c92:	2f 50       	sub	r0,-11
80002c94:	80 00       	ld.sh	r0,r0[0x0]
80002c96:	2f 80       	sub	r0,-8
80002c98:	80 00       	ld.sh	r0,r0[0x0]
80002c9a:	30 64       	mov	r4,6
80002c9c:	80 00       	ld.sh	r0,r0[0x0]
80002c9e:	2f 68       	sub	r8,-10

80002ca0 <dip204_clear_display>:


void dip204_clear_display(void)
{
80002ca0:	eb cd 40 8f 	pushm	r0-r3,r7,lr
80002ca4:	1a 97       	mov	r7,sp
80002ca6:	20 bd       	sub	sp,44
  dip204_select();
80002ca8:	f0 1f 00 57 	mcall	80002e04 <dip204_clear_display+0x164>
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002cac:	e0 6c 00 f8 	mov	r12,248
80002cb0:	f0 1f 00 56 	mcall	80002e08 <dip204_clear_display+0x168>
  /* Send Display Clear Command */
  dip204_write_byte(0x01);
80002cb4:	30 1c       	mov	r12,1
80002cb6:	f0 1f 00 55 	mcall	80002e08 <dip204_clear_display+0x168>
  /* Wait for command execution */
  delay_ms(4);
80002cba:	f0 1f 00 55 	mcall	80002e0c <dip204_clear_display+0x16c>
80002cbe:	18 98       	mov	r8,r12
80002cc0:	30 49       	mov	r9,4
80002cc2:	ef 49 ff e4 	st.w	r7[-28],r9
80002cc6:	ef 48 ff e0 	st.w	r7[-32],r8
80002cca:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002cce:	ef 48 ff ec 	st.w	r7[-20],r8
80002cd2:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002cd6:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002cda:	ee f0 ff ec 	ld.w	r0,r7[-20]
80002cde:	30 01       	mov	r1,0
80002ce0:	ee f2 ff e8 	ld.w	r2,r7[-24]
80002ce4:	30 03       	mov	r3,0
80002ce6:	e2 02 02 4a 	mul	r10,r1,r2
80002cea:	e6 00 02 48 	mul	r8,r3,r0
80002cee:	10 0a       	add	r10,r8
80002cf0:	e0 02 06 48 	mulu.d	r8,r0,r2
80002cf4:	12 0a       	add	r10,r9
80002cf6:	14 99       	mov	r9,r10
80002cf8:	e0 6a 03 e7 	mov	r10,999
80002cfc:	30 0b       	mov	r11,0
80002cfe:	f0 0a 00 0a 	add	r10,r8,r10
80002d02:	f2 0b 00 4b 	adc	r11,r9,r11
80002d06:	e0 68 03 e8 	mov	r8,1000
80002d0a:	30 09       	mov	r9,0
80002d0c:	f0 1f 00 41 	mcall	80002e10 <dip204_clear_display+0x170>
80002d10:	14 98       	mov	r8,r10
80002d12:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002d14:	ef 48 ff f4 	st.w	r7[-12],r8
80002d18:	ee c8 00 2c 	sub	r8,r7,44
80002d1c:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002d20:	e1 b8 00 42 	mfsr	r8,0x108
80002d24:	10 99       	mov	r9,r8
80002d26:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d2a:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002d2c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d30:	70 09       	ld.w	r9,r8[0x0]
80002d32:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002d36:	10 09       	add	r9,r8
80002d38:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d3c:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002d3e:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002d42:	30 08       	mov	r8,0
80002d44:	f3 68 00 08 	st.b	r9[8],r8
80002d48:	ee c8 00 2c 	sub	r8,r7,44
80002d4c:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002d50:	e1 b8 00 42 	mfsr	r8,0x108
80002d54:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002d58:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d5c:	f1 39 00 08 	ld.ub	r9,r8[8]
80002d60:	30 28       	mov	r8,2
80002d62:	f0 09 18 00 	cp.b	r9,r8
80002d66:	c0 31       	brne	80002d6c <dip204_clear_display+0xcc>
    return false;
80002d68:	30 08       	mov	r8,0
80002d6a:	c4 38       	rjmp	80002df0 <dip204_clear_display+0x150>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002d6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d70:	f1 39 00 08 	ld.ub	r9,r8[8]
80002d74:	30 18       	mov	r8,1
80002d76:	f0 09 18 00 	cp.b	r9,r8
80002d7a:	c0 31       	brne	80002d80 <dip204_clear_display+0xe0>
    return true;
80002d7c:	30 18       	mov	r8,1
80002d7e:	c3 98       	rjmp	80002df0 <dip204_clear_display+0x150>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002d80:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d84:	70 09       	ld.w	r9,r8[0x0]
80002d86:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d8a:	70 18       	ld.w	r8,r8[0x4]
80002d8c:	10 39       	cp.w	r9,r8
80002d8e:	e0 88 00 1a 	brls	80002dc2 <dip204_clear_display+0x122>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002d92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d96:	70 08       	ld.w	r8,r8[0x0]
80002d98:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002d9c:	10 39       	cp.w	r9,r8
80002d9e:	c1 02       	brcc	80002dbe <dip204_clear_display+0x11e>
80002da0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002da4:	70 18       	ld.w	r8,r8[0x4]
80002da6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002daa:	10 39       	cp.w	r9,r8
80002dac:	e0 88 00 09 	brls	80002dbe <dip204_clear_display+0x11e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002db0:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002db4:	30 18       	mov	r8,1
80002db6:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002dba:	30 18       	mov	r8,1
80002dbc:	c1 a8       	rjmp	80002df0 <dip204_clear_display+0x150>
    }
    return false;
80002dbe:	30 08       	mov	r8,0
80002dc0:	c1 88       	rjmp	80002df0 <dip204_clear_display+0x150>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002dc2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dc6:	70 08       	ld.w	r8,r8[0x0]
80002dc8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002dcc:	10 39       	cp.w	r9,r8
80002dce:	c0 93       	brcs	80002de0 <dip204_clear_display+0x140>
80002dd0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dd4:	70 18       	ld.w	r8,r8[0x4]
80002dd6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002dda:	10 39       	cp.w	r9,r8
80002ddc:	e0 88 00 09 	brls	80002dee <dip204_clear_display+0x14e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002de0:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002de4:	30 18       	mov	r8,1
80002de6:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002dea:	30 18       	mov	r8,1
80002dec:	c0 28       	rjmp	80002df0 <dip204_clear_display+0x150>
    }
    return false;
80002dee:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002df0:	58 08       	cp.w	r8,0
80002df2:	ca b0       	breq	80002d48 <dip204_clear_display+0xa8>
  dip204_wait_busy();
80002df4:	f0 1f 00 08 	mcall	80002e14 <dip204_clear_display+0x174>
  dip204_unselect();
80002df8:	f0 1f 00 08 	mcall	80002e18 <dip204_clear_display+0x178>
}
80002dfc:	2f 5d       	sub	sp,-44
80002dfe:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
80002e02:	00 00       	add	r0,r0
80002e04:	80 00       	ld.sh	r0,r0[0x0]
80002e06:	2f 50       	sub	r0,-11
80002e08:	80 00       	ld.sh	r0,r0[0x0]
80002e0a:	2f 80       	sub	r0,-8
80002e0c:	80 00       	ld.sh	r0,r0[0x0]
80002e0e:	20 f0       	sub	r0,15
80002e10:	80 00       	ld.sh	r0,r0[0x0]
80002e12:	66 68       	ld.w	r8,r3[0x18]
80002e14:	80 00       	ld.sh	r0,r0[0x0]
80002e16:	30 64       	mov	r4,6
80002e18:	80 00       	ld.sh	r0,r0[0x0]
80002e1a:	2f 68       	sub	r8,-10

80002e1c <dip204_write_string>:


void dip204_write_string(const char *string)
{
80002e1c:	eb cd 40 80 	pushm	r7,lr
80002e20:	1a 97       	mov	r7,sp
80002e22:	20 2d       	sub	sp,8
80002e24:	ef 4c ff f8 	st.w	r7[-8],r12
  unsigned char i=0;
80002e28:	30 08       	mov	r8,0
80002e2a:	ef 68 ff ff 	st.b	r7[-1],r8

  dip204_select();
80002e2e:	f0 1f 00 14 	mcall	80002e7c <dip204_write_string+0x60>
  /* for all chars in string */
  while(string[i]!=0)
80002e32:	c1 68       	rjmp	80002e5e <dip204_write_string+0x42>
  {
    /* Send Write Data Start Byte */
    dip204_write_byte(DIP204_WRITE_DATA);
80002e34:	e0 6c 00 fa 	mov	r12,250
80002e38:	f0 1f 00 12 	mcall	80002e80 <dip204_write_string+0x64>
    /* Send byte */
    dip204_write_byte(string[i]);
80002e3c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002e40:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002e44:	f2 08 00 08 	add	r8,r9,r8
80002e48:	11 88       	ld.ub	r8,r8[0x0]
80002e4a:	10 9c       	mov	r12,r8
80002e4c:	f0 1f 00 0d 	mcall	80002e80 <dip204_write_string+0x64>
    /* go to next char */
    i++;
80002e50:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002e54:	2f f8       	sub	r8,-1
80002e56:	ef 68 ff ff 	st.b	r7[-1],r8
    dip204_wait_busy();
80002e5a:	f0 1f 00 0b 	mcall	80002e84 <dip204_write_string+0x68>
{
  unsigned char i=0;

  dip204_select();
  /* for all chars in string */
  while(string[i]!=0)
80002e5e:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002e62:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002e66:	f2 08 00 08 	add	r8,r9,r8
80002e6a:	11 88       	ld.ub	r8,r8[0x0]
80002e6c:	58 08       	cp.w	r8,0
80002e6e:	ce 31       	brne	80002e34 <dip204_write_string+0x18>
    dip204_write_byte(string[i]);
    /* go to next char */
    i++;
    dip204_wait_busy();
  }
  dip204_unselect();
80002e70:	f0 1f 00 06 	mcall	80002e88 <dip204_write_string+0x6c>
}
80002e74:	2f ed       	sub	sp,-8
80002e76:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e7a:	00 00       	add	r0,r0
80002e7c:	80 00       	ld.sh	r0,r0[0x0]
80002e7e:	2f 50       	sub	r0,-11
80002e80:	80 00       	ld.sh	r0,r0[0x0]
80002e82:	2f 80       	sub	r0,-8
80002e84:	80 00       	ld.sh	r0,r0[0x0]
80002e86:	30 64       	mov	r4,6
80002e88:	80 00       	ld.sh	r0,r0[0x0]
80002e8a:	2f 68       	sub	r8,-10

80002e8c <dip204_printf_string>:


void dip204_printf_string(const char *format, ...)
{
80002e8c:	eb cd 40 80 	pushm	r7,lr
80002e90:	1a 97       	mov	r7,sp
80002e92:	20 9d       	sub	sp,36
80002e94:	ee c9 ff f8 	sub	r9,r7,-8
80002e98:	ef 4c ff dc 	st.w	r7[-36],r12
  va_list arg;
  char string[21];
  unsigned char i=0;
80002e9c:	30 08       	mov	r8,0
80002e9e:	ef 68 ff ff 	st.b	r7[-1],r8

  va_start(arg, format);
80002ea2:	f2 c8 00 00 	sub	r8,r9,0
80002ea6:	ef 48 ff f8 	st.w	r7[-8],r8
  i = vsprintf(string, format, arg);
80002eaa:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002eae:	ee c8 00 20 	sub	r8,r7,32
80002eb2:	12 9a       	mov	r10,r9
80002eb4:	ee fb ff dc 	ld.w	r11,r7[-36]
80002eb8:	10 9c       	mov	r12,r8
80002eba:	f0 1f 00 21 	mcall	80002f3c <dip204_printf_string+0xb0>
80002ebe:	18 98       	mov	r8,r12
80002ec0:	ef 68 ff ff 	st.b	r7[-1],r8
  while (i < sizeof(string) - 1) string[i++] = '\0';
80002ec4:	c0 d8       	rjmp	80002ede <dip204_printf_string+0x52>
80002ec6:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002eca:	ee 08 00 09 	add	r9,r7,r8
80002ece:	30 08       	mov	r8,0
80002ed0:	f3 68 ff e0 	st.b	r9[-32],r8
80002ed4:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002ed8:	2f f8       	sub	r8,-1
80002eda:	ef 68 ff ff 	st.b	r7[-1],r8
80002ede:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80002ee2:	31 38       	mov	r8,19
80002ee4:	f0 09 18 00 	cp.b	r9,r8
80002ee8:	fe 98 ff ef 	brls	80002ec6 <dip204_printf_string+0x3a>
  va_end(arg);
  dip204_select();
80002eec:	f0 1f 00 15 	mcall	80002f40 <dip204_printf_string+0xb4>
  /* for all chars in string */
  i = 0;
80002ef0:	30 08       	mov	r8,0
80002ef2:	ef 68 ff ff 	st.b	r7[-1],r8
  while(string[i]!='\0')
80002ef6:	c1 58       	rjmp	80002f20 <dip204_printf_string+0x94>
  {
    /* Send Write Data Start Byte */
    dip204_write_byte(DIP204_WRITE_DATA);
80002ef8:	e0 6c 00 fa 	mov	r12,250
80002efc:	f0 1f 00 12 	mcall	80002f44 <dip204_printf_string+0xb8>
    /* Send byte */
    dip204_write_byte(string[i]);
80002f00:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002f04:	ee 08 00 08 	add	r8,r7,r8
80002f08:	f1 38 ff e0 	ld.ub	r8,r8[-32]
80002f0c:	10 9c       	mov	r12,r8
80002f0e:	f0 1f 00 0e 	mcall	80002f44 <dip204_printf_string+0xb8>
    /* go to next char */
    i++;
80002f12:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002f16:	2f f8       	sub	r8,-1
80002f18:	ef 68 ff ff 	st.b	r7[-1],r8
    dip204_wait_busy();
80002f1c:	f0 1f 00 0b 	mcall	80002f48 <dip204_printf_string+0xbc>
  while (i < sizeof(string) - 1) string[i++] = '\0';
  va_end(arg);
  dip204_select();
  /* for all chars in string */
  i = 0;
  while(string[i]!='\0')
80002f20:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002f24:	ee 08 00 08 	add	r8,r7,r8
80002f28:	f1 38 ff e0 	ld.ub	r8,r8[-32]
80002f2c:	58 08       	cp.w	r8,0
80002f2e:	ce 51       	brne	80002ef8 <dip204_printf_string+0x6c>
    dip204_write_byte(string[i]);
    /* go to next char */
    i++;
    dip204_wait_busy();
  }
  dip204_unselect();
80002f30:	f0 1f 00 07 	mcall	80002f4c <dip204_printf_string+0xc0>
}
80002f34:	2f 7d       	sub	sp,-36
80002f36:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f3a:	00 00       	add	r0,r0
80002f3c:	80 00       	ld.sh	r0,r0[0x0]
80002f3e:	95 44       	st.w	r10[0x10],r4
80002f40:	80 00       	ld.sh	r0,r0[0x0]
80002f42:	2f 50       	sub	r0,-11
80002f44:	80 00       	ld.sh	r0,r0[0x0]
80002f46:	2f 80       	sub	r0,-8
80002f48:	80 00       	ld.sh	r0,r0[0x0]
80002f4a:	30 64       	mov	r4,6
80002f4c:	80 00       	ld.sh	r0,r0[0x0]
80002f4e:	2f 68       	sub	r8,-10

80002f50 <dip204_select>:

/*! \brief function to select the LCD
 *
 */
static void dip204_select(void)
{
80002f50:	eb cd 40 80 	pushm	r7,lr
80002f54:	1a 97       	mov	r7,sp
  spi_selectChip(DIP204_SPI, DIP204_SPI_NPCS);
80002f56:	30 2b       	mov	r11,2
80002f58:	fe 7c 28 00 	mov	r12,-55296
80002f5c:	f0 1f 00 02 	mcall	80002f64 <dip204_select+0x14>
}
80002f60:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f64:	80 00       	ld.sh	r0,r0[0x0]
80002f66:	34 7a       	mov	r10,71

80002f68 <dip204_unselect>:

/*! \brief function to unselect the LCD
 *
 */
static void dip204_unselect(void)
{
80002f68:	eb cd 40 80 	pushm	r7,lr
80002f6c:	1a 97       	mov	r7,sp
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_unselectChip(DIP204_SPI, DIP204_SPI_NPCS);
80002f6e:	30 2b       	mov	r11,2
80002f70:	fe 7c 28 00 	mov	r12,-55296
80002f74:	f0 1f 00 02 	mcall	80002f7c <dip204_unselect+0x14>
  Assert( SPI_OK==spi_status );
}
80002f78:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f7c:	80 00       	ld.sh	r0,r0[0x0]
80002f7e:	35 12       	mov	r2,81

80002f80 <dip204_write_byte>:
 *
 *  \param  byte  Input. byte to write to the LCD (D7 .. D0)
 *
 */
static void dip204_write_byte(unsigned char byte)
{
80002f80:	eb cd 40 80 	pushm	r7,lr
80002f84:	1a 97       	mov	r7,sp
80002f86:	20 3d       	sub	sp,12
80002f88:	18 98       	mov	r8,r12
80002f8a:	ef 68 ff f4 	st.b	r7[-12],r8
  unsigned char reverse;

  switch (byte)
80002f8e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002f92:	f0 c8 00 f8 	sub	r8,r8,248
80002f96:	58 68       	cp.w	r8,6
80002f98:	e0 8b 00 10 	brhi	80002fb8 <dip204_write_byte+0x38>
80002f9c:	30 19       	mov	r9,1
80002f9e:	f2 08 09 48 	lsl	r8,r9,r8
80002fa2:	e2 18 00 55 	andl	r8,0x55,COH
80002fa6:	c0 90       	breq	80002fb8 <dip204_write_byte+0x38>
    {
      /* send D7 to D0 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, byte);
80002fa8:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002fac:	10 9b       	mov	r11,r8
80002fae:	fe 7c 28 00 	mov	r12,-55296
80002fb2:	f0 1f 00 15 	mcall	80003004 <dip204_write_byte+0x84>
      Assert( SPI_OK==spi_status );
      break;
80002fb6:	c2 48       	rjmp	80002ffe <dip204_write_byte+0x7e>
    }
    /* LSB first for all other data */
    default:
    {
      /* reverse byte */
      reverse = bit_reverse8(byte);
80002fb8:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002fbc:	ef 48 ff fc 	st.w	r7[-4],r8
80002fc0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fc4:	5c 98       	brev	r8
80002fc6:	ef 48 ff fc 	st.w	r7[-4],r8
80002fca:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fce:	b9 88       	lsr	r8,0x18
80002fd0:	ef 68 ff fb 	st.b	r7[-5],r8
      /* send D0 to D3 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, (reverse & 0xF0));
80002fd4:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002fd8:	e2 18 00 f0 	andl	r8,0xf0,COH
80002fdc:	10 9b       	mov	r11,r8
80002fde:	fe 7c 28 00 	mov	r12,-55296
80002fe2:	f0 1f 00 09 	mcall	80003004 <dip204_write_byte+0x84>
      Assert( SPI_OK==spi_status );
      /* send D4 to D7 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, ((reverse << 4) & 0xF0));
80002fe6:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002fea:	a5 68       	lsl	r8,0x4
80002fec:	5c 88       	casts.h	r8
80002fee:	5c 78       	castu.h	r8
80002ff0:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002ff4:	10 9b       	mov	r11,r8
80002ff6:	fe 7c 28 00 	mov	r12,-55296
80002ffa:	f0 1f 00 03 	mcall	80003004 <dip204_write_byte+0x84>
      Assert( SPI_OK==spi_status );
      break;
    }
  }
}
80002ffe:	2f dd       	sub	sp,-12
80003000:	e3 cd 80 80 	ldm	sp++,r7,pc
80003004:	80 00       	ld.sh	r0,r0[0x0]
80003006:	37 1a       	mov	r10,113

80003008 <dip204_read_byte>:
 *
 *  \param  byte  Input. byte read from the LCD (D7 .. D0)
 *
 */
static void dip204_read_byte(unsigned char *byte)
{
80003008:	eb cd 40 80 	pushm	r7,lr
8000300c:	1a 97       	mov	r7,sp
8000300e:	20 3d       	sub	sp,12
80003010:	ef 4c ff f4 	st.w	r7[-12],r12
  unsigned short reverse = 0x00;
80003014:	30 08       	mov	r8,0
80003016:	ef 58 ff fa 	st.h	r7[-6],r8

  /* dummy write */
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_write(DIP204_SPI, 0x00);
8000301a:	30 0b       	mov	r11,0
8000301c:	fe 7c 28 00 	mov	r12,-55296
80003020:	f0 1f 00 0f 	mcall	8000305c <dip204_read_byte+0x54>
  Assert( SPI_OK==spi_status );
  /* read RSR register */
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_read(DIP204_SPI, &reverse);
80003024:	ee c8 00 06 	sub	r8,r7,6
80003028:	10 9b       	mov	r11,r8
8000302a:	fe 7c 28 00 	mov	r12,-55296
8000302e:	f0 1f 00 0d 	mcall	80003060 <dip204_read_byte+0x58>
  Assert( SPI_OK==spi_status );
  /* Revert received byte (issued LSB first by the LCD) */
  *byte = bit_reverse8(reverse);
80003032:	ef 08 ff fa 	ld.sh	r8,r7[-6]
80003036:	5c 58       	castu.b	r8
80003038:	ef 48 ff fc 	st.w	r7[-4],r8
8000303c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003040:	5c 98       	brev	r8
80003042:	ef 48 ff fc 	st.w	r7[-4],r8
80003046:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000304a:	b9 88       	lsr	r8,0x18
8000304c:	5c 58       	castu.b	r8
8000304e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003052:	b2 88       	st.b	r9[0x0],r8
}
80003054:	2f dd       	sub	sp,-12
80003056:	e3 cd 80 80 	ldm	sp++,r7,pc
8000305a:	00 00       	add	r0,r0
8000305c:	80 00       	ld.sh	r0,r0[0x0]
8000305e:	37 1a       	mov	r10,113
80003060:	80 00       	ld.sh	r0,r0[0x0]
80003062:	37 72       	mov	r2,119

80003064 <dip204_wait_busy>:

/*! \brief function to wait for LCD becomes not busy
 *
 */
static void dip204_wait_busy(void)
{
80003064:	eb cd 40 80 	pushm	r7,lr
80003068:	1a 97       	mov	r7,sp
8000306a:	20 1d       	sub	sp,4
  unsigned char status = 0x00;
8000306c:	30 08       	mov	r8,0
8000306e:	ef 68 ff ff 	st.b	r7[-1],r8

  /* send read command to LCD */
  dip204_write_byte(DIP204_READ_COMMAND);
80003072:	e0 6c 00 fc 	mov	r12,252
80003076:	f0 1f 00 09 	mcall	80003098 <dip204_wait_busy+0x34>
  /* read next byte */
  do {
  dip204_read_byte(&status);
8000307a:	ee c8 00 01 	sub	r8,r7,1
8000307e:	10 9c       	mov	r12,r8
80003080:	f0 1f 00 07 	mcall	8000309c <dip204_wait_busy+0x38>
  /* keep D7 to know status */
  }while (status & 0x80);
80003084:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003088:	10 99       	mov	r9,r8
8000308a:	30 08       	mov	r8,0
8000308c:	f0 09 18 00 	cp.b	r9,r8
80003090:	cf 55       	brlt	8000307a <dip204_wait_busy+0x16>
}
80003092:	2f fd       	sub	sp,-4
80003094:	e3 cd 80 80 	ldm	sp++,r7,pc
80003098:	80 00       	ld.sh	r0,r0[0x0]
8000309a:	2f 80       	sub	r0,-8
8000309c:	80 00       	ld.sh	r0,r0[0x0]
8000309e:	30 08       	mov	r8,0

800030a0 <adc_configure>:
 * If not called, ADC channels will have side effects
 *
 * \param *adc Base address of the ADC
 */
void adc_configure(volatile avr32_adc_t *adc)
{
800030a0:	eb cd 40 80 	pushm	r7,lr
800030a4:	1a 97       	mov	r7,sp
800030a6:	20 1d       	sub	sp,4
800030a8:	ef 4c ff fc 	st.w	r7[-4],r12
	adc->mr |= 1 << AVR32_ADC_LOWRES_OFFSET;
#endif

	/* Set Sample/Hold time to max so that the ADC capacitor should be
	 * loaded entirely */
	adc->mr |= 0xF << AVR32_ADC_SHTIM_OFFSET;
800030ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030b0:	70 18       	ld.w	r8,r8[0x4]
800030b2:	10 99       	mov	r9,r8
800030b4:	ea 19 0f 00 	orh	r9,0xf00
800030b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030bc:	91 19       	st.w	r8[0x4],r9

	/* Set Startup to max so that the ADC capacitor should be loaded
	 * entirely */
	adc->mr |= 0x1F << AVR32_ADC_STARTUP_OFFSET;
800030be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030c2:	70 18       	ld.w	r8,r8[0x4]
800030c4:	10 99       	mov	r9,r8
800030c6:	ea 19 00 1f 	orh	r9,0x1f
800030ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030ce:	91 19       	st.w	r8[0x4],r9
}
800030d0:	2f fd       	sub	sp,-4
800030d2:	e3 cd 80 80 	ldm	sp++,r7,pc

800030d6 <adc_start>:

/** \brief Start analog to digital conversion
 * \param *adc Base address of the ADC
 */
void adc_start(volatile avr32_adc_t *adc)
{
800030d6:	eb cd 40 80 	pushm	r7,lr
800030da:	1a 97       	mov	r7,sp
800030dc:	20 1d       	sub	sp,4
800030de:	ef 4c ff fc 	st.w	r7[-4],r12
	Assert( adc != NULL );

	/* start conversion */
	adc->cr = AVR32_ADC_START_MASK;
800030e2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030e6:	30 29       	mov	r9,2
800030e8:	91 09       	st.w	r8[0x0],r9
}
800030ea:	2f fd       	sub	sp,-4
800030ec:	e3 cd 80 80 	ldm	sp++,r7,pc

800030f0 <adc_enable>:
 *
 * \param *adc Base address of the ADC
 * \param  channel   channel to enable (0 to 7)
 */
void adc_enable(volatile avr32_adc_t *adc, uint16_t channel)
{
800030f0:	eb cd 40 80 	pushm	r7,lr
800030f4:	1a 97       	mov	r7,sp
800030f6:	20 2d       	sub	sp,8
800030f8:	ef 4c ff fc 	st.w	r7[-4],r12
800030fc:	16 98       	mov	r8,r11
800030fe:	ef 58 ff f8 	st.h	r7[-8],r8
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB ); /* check if channel exist
	                                              **/

	/* enable channel */
	adc->cher = (1 << channel);
80003102:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003106:	30 19       	mov	r9,1
80003108:	f2 08 09 48 	lsl	r8,r9,r8
8000310c:	10 99       	mov	r9,r8
8000310e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003112:	91 49       	st.w	r8[0x10],r9
}
80003114:	2f ed       	sub	sp,-8
80003116:	e3 cd 80 80 	ldm	sp++,r7,pc

8000311a <adc_check_eoc>:
 * \param  channel   channel to check (0 to 7)
 * \return bool      true if conversion not running
 *                   false if conversion running
 */
bool adc_check_eoc(volatile avr32_adc_t *adc, uint16_t channel)
{
8000311a:	eb cd 40 80 	pushm	r7,lr
8000311e:	1a 97       	mov	r7,sp
80003120:	20 2d       	sub	sp,8
80003122:	ef 4c ff fc 	st.w	r7[-4],r12
80003126:	16 98       	mov	r8,r11
80003128:	ef 58 ff f8 	st.h	r7[-8],r8
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB ); /* check if channel exist
	                                              **/

	/* get SR register : EOC bit for channel */
	return ((adc->sr & (1 << channel)) ? true : false);
8000312c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003130:	70 79       	ld.w	r9,r8[0x1c]
80003132:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003136:	30 1a       	mov	r10,1
80003138:	f4 08 09 48 	lsl	r8,r10,r8
8000313c:	f3 e8 00 08 	and	r8,r9,r8
80003140:	5f 18       	srne	r8
80003142:	5c 58       	castu.b	r8
}
80003144:	10 9c       	mov	r12,r8
80003146:	2f ed       	sub	sp,-8
80003148:	e3 cd 80 80 	ldm	sp++,r7,pc

8000314c <adc_get_value>:
 * \param *adc Base address of the ADC
 * \param  channel   channel to handle (0 to 7)
 * \return The value acquired (unsigned long)
 */
uint32_t adc_get_value(volatile avr32_adc_t *adc, uint16_t channel)
{
8000314c:	eb cd 40 80 	pushm	r7,lr
80003150:	1a 97       	mov	r7,sp
80003152:	20 2d       	sub	sp,8
80003154:	ef 4c ff fc 	st.w	r7[-4],r12
80003158:	16 98       	mov	r8,r11
8000315a:	ef 58 ff f8 	st.h	r7[-8],r8
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB );

	/* wait for end of conversion */
	while (adc_check_eoc(adc, channel) != true) {
8000315e:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003162:	10 9b       	mov	r11,r8
80003164:	ee fc ff fc 	ld.w	r12,r7[-4]
80003168:	f0 1f 00 0b 	mcall	80003194 <adc_get_value+0x48>
8000316c:	18 98       	mov	r8,r12
8000316e:	ec 18 00 01 	eorl	r8,0x1
80003172:	5c 58       	castu.b	r8
80003174:	cf 51       	brne	8000315e <adc_get_value+0x12>
	}

	return *((uint32_t *)((&(adc->cdr0)) + channel));
80003176:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000317a:	f0 c9 ff d0 	sub	r9,r8,-48
8000317e:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003182:	a3 68       	lsl	r8,0x2
80003184:	f2 08 00 08 	add	r8,r9,r8
80003188:	70 08       	ld.w	r8,r8[0x0]
}
8000318a:	10 9c       	mov	r12,r8
8000318c:	2f ed       	sub	sp,-8
8000318e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003192:	00 00       	add	r0,r0
80003194:	80 00       	ld.sh	r0,r0[0x0]
80003196:	31 1a       	mov	r10,17

80003198 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80003198:	eb cd 40 80 	pushm	r7,lr
8000319c:	1a 97       	mov	r7,sp
8000319e:	20 1d       	sub	sp,4
800031a0:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
800031a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031a8:	e6 18 00 01 	andh	r8,0x1,COH
800031ac:	5f 08       	sreq	r8
800031ae:	5c 58       	castu.b	r8
}
800031b0:	10 9c       	mov	r12,r8
800031b2:	2f fd       	sub	sp,-4
800031b4:	e3 cd 80 80 	ldm	sp++,r7,pc

800031b8 <pwm_init>:
#include "compiler.h"
#include "pwm.h"


int pwm_init(const pwm_opt_t *opt)
{
800031b8:	eb cd 40 80 	pushm	r7,lr
800031bc:	1a 97       	mov	r7,sp
800031be:	20 3d       	sub	sp,12
800031c0:	ef 4c ff f4 	st.w	r7[-12],r12
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
800031c4:	fe 78 30 00 	mov	r8,-53248
800031c8:	ef 48 ff f8 	st.w	r7[-8],r8
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
800031cc:	e1 b8 00 00 	mfsr	r8,0x0
800031d0:	10 9c       	mov	r12,r8
800031d2:	f0 1f 00 1e 	mcall	80003248 <pwm_init+0x90>
800031d6:	18 98       	mov	r8,r12
800031d8:	ef 68 ff ff 	st.b	r7[-1],r8

  if (opt == 0 ) // Null pointer.
800031dc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800031e0:	58 08       	cp.w	r8,0
800031e2:	c0 31       	brne	800031e8 <pwm_init+0x30>
    return PWM_INVALID_INPUT;
800031e4:	30 18       	mov	r8,1
800031e6:	c2 c8       	rjmp	8000323e <pwm_init+0x86>

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
800031e8:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800031ec:	30 08       	mov	r8,0
800031ee:	f0 09 18 00 	cp.b	r9,r8
800031f2:	c0 20       	breq	800031f6 <pwm_init+0x3e>
800031f4:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
800031f6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800031fa:	37 f9       	mov	r9,127
800031fc:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
800031fe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003202:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
80003204:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003208:	30 08       	mov	r8,0
8000320a:	f0 09 18 00 	cp.b	r9,r8
8000320e:	c0 20       	breq	80003212 <pwm_init+0x5a>
80003210:	d5 03       	csrf	0x10

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
80003212:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003216:	70 19       	ld.w	r9,r8[0x4]
    ((opt->divb)<<AVR32_PWM_DIVB_OFFSET) |
80003218:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000321c:	70 08       	ld.w	r8,r8[0x0]
8000321e:	b1 68       	lsl	r8,0x10
80003220:	10 49       	or	r9,r8
    ((opt->prea)<<AVR32_PWM_PREA_OFFSET) |
80003222:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003226:	70 38       	ld.w	r8,r8[0xc]
80003228:	a9 68       	lsl	r8,0x8
8000322a:	10 49       	or	r9,r8
    ((opt->preb)<<AVR32_PWM_PREB_OFFSET)
8000322c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003230:	70 28       	ld.w	r8,r8[0x8]
80003232:	b9 68       	lsl	r8,0x18
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
80003234:	10 49       	or	r9,r8
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
80003236:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000323a:	91 09       	st.w	r8[0x0],r9
    ((opt->divb)<<AVR32_PWM_DIVB_OFFSET) |
    ((opt->prea)<<AVR32_PWM_PREA_OFFSET) |
    ((opt->preb)<<AVR32_PWM_PREB_OFFSET)
    ;

  return PWM_SUCCESS;
8000323c:	30 08       	mov	r8,0
}
8000323e:	10 9c       	mov	r12,r8
80003240:	2f dd       	sub	sp,-12
80003242:	e3 cd 80 80 	ldm	sp++,r7,pc
80003246:	00 00       	add	r0,r0
80003248:	80 00       	ld.sh	r0,r0[0x0]
8000324a:	31 98       	mov	r8,25

8000324c <pwm_channel_init>:


int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
8000324c:	eb cd 40 80 	pushm	r7,lr
80003250:	1a 97       	mov	r7,sp
80003252:	20 3d       	sub	sp,12
80003254:	ef 4c ff f8 	st.w	r7[-8],r12
80003258:	ef 4b ff f4 	st.w	r7[-12],r11
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
8000325c:	fe 78 30 00 	mov	r8,-53248
80003260:	ef 48 ff fc 	st.w	r7[-4],r8

  if (pwm_channel == 0) // Null pointer.
80003264:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003268:	58 08       	cp.w	r8,0
8000326a:	c0 31       	brne	80003270 <pwm_channel_init+0x24>
    return PWM_INVALID_ARGUMENT;
8000326c:	30 18       	mov	r8,1
8000326e:	c2 f8       	rjmp	800032cc <pwm_channel_init+0x80>
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
80003270:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003274:	58 68       	cp.w	r8,6
80003276:	e0 88 00 04 	brls	8000327e <pwm_channel_init+0x32>
    return PWM_INVALID_INPUT;
8000327a:	30 18       	mov	r8,1
8000327c:	c2 88       	rjmp	800032cc <pwm_channel_init+0x80>

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
8000327e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003282:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003286:	72 09       	ld.w	r9,r9[0x0]
80003288:	ee fa ff fc 	ld.w	r10,r7[-4]
8000328c:	2f 08       	sub	r8,-16
8000328e:	a5 78       	lsl	r8,0x5
80003290:	f4 08 00 08 	add	r8,r10,r8
80003294:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
80003296:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000329a:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000329e:	72 19       	ld.w	r9,r9[0x4]
800032a0:	ee fa ff fc 	ld.w	r10,r7[-4]
800032a4:	a5 78       	lsl	r8,0x5
800032a6:	f4 08 00 08 	add	r8,r10,r8
800032aa:	f0 c8 fd fc 	sub	r8,r8,-516
800032ae:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
800032b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800032b4:	ee f9 ff f4 	ld.w	r9,r7[-12]
800032b8:	72 29       	ld.w	r9,r9[0x8]
800032ba:	ee fa ff fc 	ld.w	r10,r7[-4]
800032be:	a5 78       	lsl	r8,0x5
800032c0:	f4 08 00 08 	add	r8,r10,r8
800032c4:	f0 c8 fd f8 	sub	r8,r8,-520
800032c8:	91 09       	st.w	r8[0x0],r9

  return PWM_SUCCESS;
800032ca:	30 08       	mov	r8,0
}
800032cc:	10 9c       	mov	r12,r8
800032ce:	2f dd       	sub	sp,-12
800032d0:	e3 cd 80 80 	ldm	sp++,r7,pc

800032d4 <pwm_start_channels>:


int pwm_start_channels(unsigned long channels_bitmask)
{
800032d4:	eb cd 40 80 	pushm	r7,lr
800032d8:	1a 97       	mov	r7,sp
800032da:	20 1d       	sub	sp,4
800032dc:	ef 4c ff fc 	st.w	r7[-4],r12
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
800032e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032e4:	e0 18 ff 80 	andl	r8,0xff80
800032e8:	c0 30       	breq	800032ee <pwm_start_channels+0x1a>
    return PWM_INVALID_INPUT;
800032ea:	30 18       	mov	r8,1
800032ec:	c0 78       	rjmp	800032fa <pwm_start_channels+0x26>

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
800032ee:	fe 78 30 00 	mov	r8,-53248
800032f2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800032f6:	91 19       	st.w	r8[0x4],r9

  return PWM_SUCCESS;
800032f8:	30 08       	mov	r8,0
}
800032fa:	10 9c       	mov	r12,r8
800032fc:	2f fd       	sub	sp,-4
800032fe:	e3 cd 80 80 	ldm	sp++,r7,pc

80003302 <getBaudDiv>:
/** The SPI mutex. */
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
80003302:	eb cd 40 80 	pushm	r7,lr
80003306:	1a 97       	mov	r7,sp
80003308:	20 3d       	sub	sp,12
8000330a:	ef 4c ff f8 	st.w	r7[-8],r12
8000330e:	ef 4b ff f4 	st.w	r7[-12],r11
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80003312:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003316:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000331a:	f2 08 00 08 	add	r8,r9,r8
8000331e:	20 18       	sub	r8,1
80003320:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003324:	f0 09 0d 08 	divu	r8,r8,r9
80003328:	ef 48 ff fc 	st.w	r7[-4],r8

	if (baudDiv <= 0 || baudDiv > 255) {
8000332c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003330:	58 08       	cp.w	r8,0
80003332:	c0 70       	breq	80003340 <getBaudDiv+0x3e>
80003334:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003338:	e0 48 00 ff 	cp.w	r8,255
8000333c:	e0 88 00 04 	brls	80003344 <getBaudDiv+0x42>
		return -1;
80003340:	3f f8       	mov	r8,-1
80003342:	c0 48       	rjmp	8000334a <getBaudDiv+0x48>
	}

	return baudDiv;
80003344:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003348:	5c 88       	casts.h	r8
}
8000334a:	10 9c       	mov	r12,r8
8000334c:	2f dd       	sub	sp,-12
8000334e:	e3 cd 80 80 	ldm	sp++,r7,pc

80003352 <spi_initMaster>:
	return SPI_OK;
}

spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
80003352:	eb cd 40 80 	pushm	r7,lr
80003356:	1a 97       	mov	r7,sp
80003358:	20 3d       	sub	sp,12
8000335a:	ef 4c ff f8 	st.w	r7[-8],r12
8000335e:	ef 4b ff f4 	st.w	r7[-12],r11
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80003362:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003366:	f1 39 00 0d 	ld.ub	r9,r8[13]
8000336a:	30 18       	mov	r8,1
8000336c:	f0 09 18 00 	cp.b	r9,r8
80003370:	e0 88 00 04 	brls	80003378 <spi_initMaster+0x26>
		return SPI_ERROR_ARGUMENT;
80003374:	30 28       	mov	r8,2
80003376:	c3 48       	rjmp	800033de <spi_initMaster+0x8c>
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80003378:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000337c:	e0 69 00 80 	mov	r9,128
80003380:	91 09       	st.w	r8[0x0],r9

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80003382:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003386:	70 18       	ld.w	r8,r8[0x4]
80003388:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.mstr = 1;
8000338c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003390:	30 19       	mov	r9,1
80003392:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
80003396:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
8000339a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000339e:	f1 38 00 0d 	ld.ub	r8,r8[13]
800033a2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800033a6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800033aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033ae:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
800033b2:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.llb = 0;
800033b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033ba:	30 09       	mov	r9,0
800033bc:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
800033c0:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800033c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033c8:	30 f9       	mov	r9,15
800033ca:	f1 d9 d2 04 	bfins	r8,r9,0x10,0x4
800033ce:	ef 48 ff fc 	st.w	r7[-4],r8
	spi->mr = u_avr32_spi_mr.mr;
800033d2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800033d6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800033da:	91 19       	st.w	r8[0x4],r9

	return SPI_OK;
800033dc:	30 08       	mov	r8,0
}
800033de:	10 9c       	mov	r12,r8
800033e0:	2f dd       	sub	sp,-12
800033e2:	e3 cd 80 80 	ldm	sp++,r7,pc

800033e6 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800033e6:	eb cd 40 80 	pushm	r7,lr
800033ea:	1a 97       	mov	r7,sp
800033ec:	20 5d       	sub	sp,20
800033ee:	ef 4c ff f8 	st.w	r7[-8],r12
800033f2:	12 98       	mov	r8,r9
800033f4:	16 99       	mov	r9,r11
800033f6:	ef 69 ff f4 	st.b	r7[-12],r9
800033fa:	14 99       	mov	r9,r10
800033fc:	ef 69 ff f0 	st.b	r7[-16],r9
80003400:	ef 68 ff ec 	st.b	r7[-20],r8
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80003404:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80003408:	30 18       	mov	r8,1
8000340a:	f0 09 18 00 	cp.b	r9,r8
8000340e:	e0 8b 00 09 	brhi	80003420 <spi_selectionMode+0x3a>
80003412:	ef 39 ff f0 	ld.ub	r9,r7[-16]
80003416:	30 18       	mov	r8,1
80003418:	f0 09 18 00 	cp.b	r9,r8
8000341c:	e0 88 00 04 	brls	80003424 <spi_selectionMode+0x3e>
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
80003420:	30 28       	mov	r8,2
80003422:	c2 88       	rjmp	80003472 <spi_selectionMode+0x8c>
	}

	u_avr32_spi_mr.mr = spi->mr;
80003424:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003428:	70 18       	ld.w	r8,r8[0x4]
8000342a:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.ps = variable_ps;
8000342e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003432:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003436:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000343a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000343e:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
80003442:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80003446:	ef 38 ff f0 	ld.ub	r8,r7[-16]
8000344a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000344e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003452:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003456:	f1 d9 d0 41 	bfins	r8,r9,0x2,0x1
8000345a:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.dlybcs = delay;
8000345e:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80003462:	ef 68 ff fc 	st.b	r7[-4],r8
	spi->mr = u_avr32_spi_mr.mr;
80003466:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000346a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000346e:	91 19       	st.w	r8[0x4],r9

	return SPI_OK;
80003470:	30 08       	mov	r8,0
}
80003472:	10 9c       	mov	r12,r8
80003474:	2f bd       	sub	sp,-20
80003476:	e3 cd 80 80 	ldm	sp++,r7,pc

8000347a <spi_selectChip>:

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000347a:	eb cd 40 80 	pushm	r7,lr
8000347e:	1a 97       	mov	r7,sp
80003480:	20 2d       	sub	sp,8
80003482:	ef 4c ff fc 	st.w	r7[-4],r12
80003486:	16 98       	mov	r8,r11
80003488:	ef 68 ff f8 	st.b	r7[-8],r8
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000348c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003490:	70 18       	ld.w	r8,r8[0x4]
80003492:	10 99       	mov	r9,r8
80003494:	ea 19 00 0f 	orh	r9,0xf
80003498:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000349c:	91 19       	st.w	r8[0x4],r9

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
8000349e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034a2:	70 18       	ld.w	r8,r8[0x4]
800034a4:	e2 18 00 04 	andl	r8,0x4,COH
800034a8:	c1 90       	breq	800034da <spi_selectChip+0x60>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800034aa:	ef 39 ff f8 	ld.ub	r9,r7[-8]
800034ae:	30 e8       	mov	r8,14
800034b0:	f0 09 18 00 	cp.b	r9,r8
800034b4:	e0 88 00 04 	brls	800034bc <spi_selectChip+0x42>
			return SPI_ERROR_ARGUMENT;
800034b8:	30 28       	mov	r8,2
800034ba:	c2 88       	rjmp	8000350a <spi_selectChip+0x90>
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800034bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034c0:	70 19       	ld.w	r9,r8[0x4]
				(chip << AVR32_SPI_MR_PCS_OFFSET);
800034c2:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800034c6:	b1 68       	lsl	r8,0x10
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800034c8:	ea 18 ff f0 	orh	r8,0xfff0
800034cc:	e8 18 ff ff 	orl	r8,0xffff
800034d0:	10 69       	and	r9,r8
800034d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034d6:	91 19       	st.w	r8[0x4],r9
800034d8:	c1 88       	rjmp	80003508 <spi_selectChip+0x8e>
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800034da:	ef 39 ff f8 	ld.ub	r9,r7[-8]
800034de:	30 38       	mov	r8,3
800034e0:	f0 09 18 00 	cp.b	r9,r8
800034e4:	e0 88 00 04 	brls	800034ec <spi_selectChip+0x72>
			return SPI_ERROR_ARGUMENT;
800034e8:	30 28       	mov	r8,2
800034ea:	c1 08       	rjmp	8000350a <spi_selectChip+0x90>
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800034ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034f0:	70 19       	ld.w	r9,r8[0x4]
800034f2:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800034f6:	2f 08       	sub	r8,-16
800034f8:	30 1a       	mov	r10,1
800034fa:	f4 08 09 48 	lsl	r8,r10,r8
800034fe:	5c d8       	com	r8
80003500:	10 69       	and	r9,r8
80003502:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003506:	91 19       	st.w	r8[0x4],r9
	}

	return SPI_OK;
80003508:	30 08       	mov	r8,0
}
8000350a:	10 9c       	mov	r12,r8
8000350c:	2f ed       	sub	sp,-8
8000350e:	e3 cd 80 80 	ldm	sp++,r7,pc

80003512 <spi_unselectChip>:

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80003512:	eb cd 40 80 	pushm	r7,lr
80003516:	1a 97       	mov	r7,sp
80003518:	20 3d       	sub	sp,12
8000351a:	ef 4c ff f8 	st.w	r7[-8],r12
8000351e:	16 98       	mov	r8,r11
80003520:	ef 68 ff f4 	st.b	r7[-12],r8
	uint32_t timeout = SPI_TIMEOUT;
80003524:	e0 68 3a 98 	mov	r8,15000
80003528:	ef 48 ff fc 	st.w	r7[-4],r8

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000352c:	c0 f8       	rjmp	8000354a <spi_unselectChip+0x38>
		if (!timeout--) {
8000352e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003532:	58 08       	cp.w	r8,0
80003534:	5f 08       	sreq	r8
80003536:	5c 58       	castu.b	r8
80003538:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000353c:	20 19       	sub	r9,1
8000353e:	ef 49 ff fc 	st.w	r7[-4],r9
80003542:	58 08       	cp.w	r8,0
80003544:	c0 30       	breq	8000354a <spi_unselectChip+0x38>
			return SPI_ERROR_TIMEOUT;
80003546:	30 18       	mov	r8,1
80003548:	c1 68       	rjmp	80003574 <spi_unselectChip+0x62>

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000354a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000354e:	70 48       	ld.w	r8,r8[0x10]
80003550:	e2 18 02 00 	andl	r8,0x200,COH
80003554:	ce d0       	breq	8000352e <spi_unselectChip+0x1c>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80003556:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000355a:	70 18       	ld.w	r8,r8[0x4]
8000355c:	10 99       	mov	r9,r8
8000355e:	ea 19 00 0f 	orh	r9,0xf
80003562:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003566:	91 19       	st.w	r8[0x4],r9

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80003568:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000356c:	fc 19 01 00 	movh	r9,0x100
80003570:	91 09       	st.w	r8[0x0],r9

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
#endif

	return SPI_OK;
80003572:	30 08       	mov	r8,0
}
80003574:	10 9c       	mov	r12,r8
80003576:	2f dd       	sub	sp,-12
80003578:	e3 cd 80 80 	ldm	sp++,r7,pc

8000357c <spi_setupChipReg>:

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
8000357c:	eb cd 40 80 	pushm	r7,lr
80003580:	1a 97       	mov	r7,sp
80003582:	20 5d       	sub	sp,20
80003584:	ef 4c ff f4 	st.w	r7[-12],r12
80003588:	ef 4b ff f0 	st.w	r7[-16],r11
8000358c:	ef 4a ff ec 	st.w	r7[-20],r10
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80003590:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003594:	f1 39 00 0c 	ld.ub	r9,r8[12]
80003598:	30 38       	mov	r8,3
8000359a:	f0 09 18 00 	cp.b	r9,r8
8000359e:	e0 8b 00 1d 	brhi	800035d8 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
800035a2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035a6:	f1 39 00 0b 	ld.ub	r9,r8[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800035aa:	30 18       	mov	r8,1
800035ac:	f0 09 18 00 	cp.b	r9,r8
800035b0:	e0 8b 00 14 	brhi	800035d8 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800035b4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035b8:	f1 39 00 08 	ld.ub	r9,r8[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800035bc:	30 78       	mov	r8,7
800035be:	f0 09 18 00 	cp.b	r9,r8
800035c2:	e0 88 00 0b 	brls	800035d8 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800035c6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035ca:	f1 39 00 08 	ld.ub	r9,r8[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800035ce:	31 08       	mov	r8,16
800035d0:	f0 09 18 00 	cp.b	r9,r8
800035d4:	e0 88 00 04 	brls	800035dc <spi_setupChipReg+0x60>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
800035d8:	30 28       	mov	r8,2
800035da:	c8 d8       	rjmp	800036f4 <spi_setupChipReg+0x178>
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800035dc:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035e0:	70 18       	ld.w	r8,r8[0x4]
800035e2:	ee fb ff ec 	ld.w	r11,r7[-20]
800035e6:	10 9c       	mov	r12,r8
800035e8:	f0 1f 00 45 	mcall	800036fc <spi_setupChipReg+0x180>
800035ec:	18 98       	mov	r8,r12
800035ee:	ef 48 ff fc 	st.w	r7[-4],r8

	if (baudDiv < 0) {
800035f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800035f6:	58 08       	cp.w	r8,0
800035f8:	c0 34       	brge	800035fe <spi_setupChipReg+0x82>
		return SPI_ERROR_ARGUMENT;
800035fa:	30 28       	mov	r8,2
800035fc:	c7 c8       	rjmp	800036f4 <spi_setupChipReg+0x178>
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800035fe:	30 08       	mov	r8,0
80003600:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80003604:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003608:	f1 38 00 0c 	ld.ub	r8,r8[12]
8000360c:	a1 98       	lsr	r8,0x1
8000360e:	5c 58       	castu.b	r8
80003610:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003614:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003618:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000361c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
80003620:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80003624:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003628:	f1 38 00 0c 	ld.ub	r8,r8[12]
8000362c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003630:	5f 08       	sreq	r8
80003632:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003636:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000363a:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
8000363e:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80003642:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003646:	f1 38 00 0b 	ld.ub	r8,r8[11]
8000364a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000364e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003652:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003656:	f1 d9 d0 61 	bfins	r8,r9,0x3,0x1
8000365a:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
8000365e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003662:	f1 38 00 08 	ld.ub	r8,r8[8]
80003666:	20 88       	sub	r8,8
80003668:	5c 58       	castu.b	r8
8000366a:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000366e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003672:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003676:	f1 d9 d0 84 	bfins	r8,r9,0x4,0x4
8000367a:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
8000367e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003682:	5c 58       	castu.b	r8
80003684:	ef 68 ff fa 	st.b	r7[-6],r8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80003688:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000368c:	f1 38 00 09 	ld.ub	r8,r8[9]
80003690:	ef 68 ff f9 	st.b	r7[-7],r8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80003694:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003698:	f1 38 00 0a 	ld.ub	r8,r8[10]
8000369c:	ef 68 ff f8 	st.b	r7[-8],r8

	switch (options->reg) {
800036a0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800036a4:	11 88       	ld.ub	r8,r8[0x0]
800036a6:	58 18       	cp.w	r8,1
800036a8:	c1 10       	breq	800036ca <spi_setupChipReg+0x14e>
800036aa:	e0 89 00 05 	brgt	800036b4 <spi_setupChipReg+0x138>
800036ae:	58 08       	cp.w	r8,0
800036b0:	c0 70       	breq	800036be <spi_setupChipReg+0x142>
800036b2:	c1 e8       	rjmp	800036ee <spi_setupChipReg+0x172>
800036b4:	58 28       	cp.w	r8,2
800036b6:	c1 00       	breq	800036d6 <spi_setupChipReg+0x15a>
800036b8:	58 38       	cp.w	r8,3
800036ba:	c1 40       	breq	800036e2 <spi_setupChipReg+0x166>
800036bc:	c1 98       	rjmp	800036ee <spi_setupChipReg+0x172>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800036be:	ee f9 ff f8 	ld.w	r9,r7[-8]
800036c2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036c6:	91 c9       	st.w	r8[0x30],r9
		break;
800036c8:	c1 58       	rjmp	800036f2 <spi_setupChipReg+0x176>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800036ca:	ee f9 ff f8 	ld.w	r9,r7[-8]
800036ce:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036d2:	91 d9       	st.w	r8[0x34],r9
		break;
800036d4:	c0 f8       	rjmp	800036f2 <spi_setupChipReg+0x176>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800036d6:	ee f9 ff f8 	ld.w	r9,r7[-8]
800036da:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036de:	91 e9       	st.w	r8[0x38],r9
		break;
800036e0:	c0 98       	rjmp	800036f2 <spi_setupChipReg+0x176>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800036e2:	ee f9 ff f8 	ld.w	r9,r7[-8]
800036e6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800036ea:	91 f9       	st.w	r8[0x3c],r9
		break;
800036ec:	c0 38       	rjmp	800036f2 <spi_setupChipReg+0x176>

	default:
		return SPI_ERROR_ARGUMENT;
800036ee:	30 28       	mov	r8,2
800036f0:	c0 28       	rjmp	800036f4 <spi_setupChipReg+0x178>
			}
		}
	}
#endif

	return SPI_OK;
800036f2:	30 08       	mov	r8,0
}
800036f4:	10 9c       	mov	r12,r8
800036f6:	2f bd       	sub	sp,-20
800036f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800036fc:	80 00       	ld.sh	r0,r0[0x0]
800036fe:	33 02       	mov	r2,48

80003700 <spi_enable>:

void spi_enable(volatile avr32_spi_t *spi)
{
80003700:	eb cd 40 80 	pushm	r7,lr
80003704:	1a 97       	mov	r7,sp
80003706:	20 1d       	sub	sp,4
80003708:	ef 4c ff fc 	st.w	r7[-4],r12
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000370c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003710:	30 19       	mov	r9,1
80003712:	91 09       	st.w	r8[0x0],r9
}
80003714:	2f fd       	sub	sp,-4
80003716:	e3 cd 80 80 	ldm	sp++,r7,pc

8000371a <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000371a:	eb cd 40 80 	pushm	r7,lr
8000371e:	1a 97       	mov	r7,sp
80003720:	20 3d       	sub	sp,12
80003722:	ef 4c ff f8 	st.w	r7[-8],r12
80003726:	16 98       	mov	r8,r11
80003728:	ef 58 ff f4 	st.h	r7[-12],r8
	uint32_t timeout = SPI_TIMEOUT;
8000372c:	e0 68 3a 98 	mov	r8,15000
80003730:	ef 48 ff fc 	st.w	r7[-4],r8

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80003734:	c0 f8       	rjmp	80003752 <spi_write+0x38>
		if (!timeout--) {
80003736:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000373a:	58 08       	cp.w	r8,0
8000373c:	5f 08       	sreq	r8
8000373e:	5c 58       	castu.b	r8
80003740:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003744:	20 19       	sub	r9,1
80003746:	ef 49 ff fc 	st.w	r7[-4],r9
8000374a:	58 08       	cp.w	r8,0
8000374c:	c0 30       	breq	80003752 <spi_write+0x38>
			return SPI_ERROR_TIMEOUT;
8000374e:	30 18       	mov	r8,1
80003750:	c0 d8       	rjmp	8000376a <spi_write+0x50>

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80003752:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003756:	70 48       	ld.w	r8,r8[0x10]
80003758:	e2 18 00 02 	andl	r8,0x2,COH
8000375c:	ce d0       	breq	80003736 <spi_write+0x1c>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000375e:	ef 19 ff f4 	ld.uh	r9,r7[-12]
80003762:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003766:	91 39       	st.w	r8[0xc],r9

	return SPI_OK;
80003768:	30 08       	mov	r8,0
}
8000376a:	10 9c       	mov	r12,r8
8000376c:	2f dd       	sub	sp,-12
8000376e:	e3 cd 80 80 	ldm	sp++,r7,pc

80003772 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80003772:	eb cd 40 80 	pushm	r7,lr
80003776:	1a 97       	mov	r7,sp
80003778:	20 3d       	sub	sp,12
8000377a:	ef 4c ff f8 	st.w	r7[-8],r12
8000377e:	ef 4b ff f4 	st.w	r7[-12],r11
	unsigned int timeout = SPI_TIMEOUT;
80003782:	e0 68 3a 98 	mov	r8,15000
80003786:	ef 48 ff fc 	st.w	r7[-4],r8

	while ((spi->sr &
8000378a:	c0 f8       	rjmp	800037a8 <spi_read+0x36>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
8000378c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003790:	58 08       	cp.w	r8,0
80003792:	5f 08       	sreq	r8
80003794:	5c 58       	castu.b	r8
80003796:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000379a:	20 19       	sub	r9,1
8000379c:	ef 49 ff fc 	st.w	r7[-4],r9
800037a0:	58 08       	cp.w	r8,0
800037a2:	c0 30       	breq	800037a8 <spi_read+0x36>
			return SPI_ERROR_TIMEOUT;
800037a4:	30 18       	mov	r8,1
800037a6:	c1 18       	rjmp	800037c8 <spi_read+0x56>

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800037a8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800037ac:	70 48       	ld.w	r8,r8[0x10]
800037ae:	e2 18 02 01 	andl	r8,0x201,COH
800037b2:	e0 48 02 01 	cp.w	r8,513
800037b6:	ce b1       	brne	8000378c <spi_read+0x1a>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800037b8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800037bc:	70 28       	ld.w	r8,r8[0x8]
800037be:	5c 88       	casts.h	r8
800037c0:	ee f9 ff f4 	ld.w	r9,r7[-12]
800037c4:	b2 08       	st.h	r9[0x0],r8

	return SPI_OK;
800037c6:	30 08       	mov	r8,0
}
800037c8:	10 9c       	mov	r12,r8
800037ca:	2f dd       	sub	sp,-12
800037cc:	e3 cd 80 80 	ldm	sp++,r7,pc

800037d0 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern bool sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
800037d0:	eb cd 40 80 	pushm	r7,lr
800037d4:	1a 97       	mov	r7,sp
	}
#endif

	switch (CONFIG_SYSCLK_SOURCE) {
	case SYSCLK_SRC_RCSYS:
		return OSC_SLOW_NOMINAL_HZ;
800037d6:	e0 78 c2 00 	mov	r8,115200

	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
800037da:	10 9c       	mov	r12,r8
800037dc:	e3 cd 80 80 	ldm	sp++,r7,pc

800037e0 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
800037e0:	eb cd 40 80 	pushm	r7,lr
800037e4:	1a 97       	mov	r7,sp
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_CPU_DIV;
800037e6:	f0 1f 00 04 	mcall	800037f4 <sysclk_get_cpu_hz+0x14>
800037ea:	18 98       	mov	r8,r12
}
800037ec:	10 9c       	mov	r12,r8
800037ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800037f2:	00 00       	add	r0,r0
800037f4:	80 00       	ld.sh	r0,r0[0x0]
800037f6:	37 d0       	mov	r0,125

800037f8 <display_init>:

// Include Files
#include "display_init.h"

void display_init(void)
{
800037f8:	eb cd 40 8f 	pushm	r0-r3,r7,lr
800037fc:	1a 97       	mov	r7,sp
800037fe:	21 0d       	sub	sp,64
	volatile avr32_pm_t* pm = &AVR32_PM;
80003800:	fe 78 0c 00 	mov	r8,-62464
80003804:	ef 48 ff dc 	st.w	r7[-36],r8
	   .spck_delay           = 0,
	   .trans_delay  		 = 8,
	   .stay_act             = 1,
	   .spi_mode             = 0,
	   .modfdis              = 1
	};
80003808:	4f 68       	lddpc	r8,800039e0 <display_init+0x1e8>
8000380a:	ee ca 00 34 	sub	r10,r7,52
8000380e:	10 9b       	mov	r11,r8
80003810:	f6 e8 00 00 	ld.d	r8,r11[0]
80003814:	f4 e9 00 00 	st.d	r10[0],r8
80003818:	f6 e8 00 08 	ld.d	r8,r11[8]
8000381c:	f4 e9 00 08 	st.d	r10[8],r8

	// Switch clock to external 12 MHz crystal
	// 1) Configure OSC0 in crystal mode, external crystal with a FOSC0 Hz frequency.
	pm_enable_osc0_crystal(pm, FOSC0);
80003820:	e0 6b 1b 00 	mov	r11,6912
80003824:	ea 1b 00 b7 	orh	r11,0xb7
80003828:	ee fc ff dc 	ld.w	r12,r7[-36]
8000382c:	f0 1f 00 6e 	mcall	800039e4 <display_init+0x1ec>

	// 2) Enable the OSC0
	pm_enable_clk0(pm, OSC0_STARTUP);
80003830:	30 3b       	mov	r11,3
80003832:	ee fc ff dc 	ld.w	r12,r7[-36]
80003836:	f0 1f 00 6d 	mcall	800039e8 <display_init+0x1f0>

	// 3) Set the main clock source as being OSC0.
	pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
8000383a:	30 1b       	mov	r11,1
8000383c:	ee fc ff dc 	ld.w	r12,r7[-36]
80003840:	f0 1f 00 6b 	mcall	800039ec <display_init+0x1f4>

	// Initialize the delay function
	delay_init(12000000);
	// Delay for a ms, to allow the display to power up properly
	delay_ms(1);
80003844:	f0 1f 00 6b 	mcall	800039f0 <display_init+0x1f8>
80003848:	18 98       	mov	r8,r12
8000384a:	30 19       	mov	r9,1
8000384c:	ef 49 ff e4 	st.w	r7[-28],r9
80003850:	ef 48 ff e0 	st.w	r7[-32],r8
80003854:	ee f8 ff e4 	ld.w	r8,r7[-28]
80003858:	ef 48 ff ec 	st.w	r7[-20],r8
8000385c:	ee f8 ff e0 	ld.w	r8,r7[-32]
80003860:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003864:	ee f0 ff ec 	ld.w	r0,r7[-20]
80003868:	30 01       	mov	r1,0
8000386a:	ee f2 ff e8 	ld.w	r2,r7[-24]
8000386e:	30 03       	mov	r3,0
80003870:	e2 02 02 4a 	mul	r10,r1,r2
80003874:	e6 00 02 48 	mul	r8,r3,r0
80003878:	10 0a       	add	r10,r8
8000387a:	e0 02 06 48 	mulu.d	r8,r0,r2
8000387e:	12 0a       	add	r10,r9
80003880:	14 99       	mov	r9,r10
80003882:	e0 6a 03 e7 	mov	r10,999
80003886:	30 0b       	mov	r11,0
80003888:	f0 0a 00 0a 	add	r10,r8,r10
8000388c:	f2 0b 00 4b 	adc	r11,r9,r11
80003890:	e0 68 03 e8 	mov	r8,1000
80003894:	30 09       	mov	r9,0
80003896:	f0 1f 00 58 	mcall	800039f4 <display_init+0x1fc>
8000389a:	14 98       	mov	r8,r10
8000389c:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000389e:	ef 48 ff f4 	st.w	r7[-12],r8
800038a2:	ee c8 00 40 	sub	r8,r7,64
800038a6:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800038aa:	e1 b8 00 42 	mfsr	r8,0x108
800038ae:	10 99       	mov	r9,r8
800038b0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800038b4:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800038b6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800038ba:	70 09       	ld.w	r9,r8[0x0]
800038bc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800038c0:	10 09       	add	r9,r8
800038c2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800038c6:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800038c8:	ee f9 ff f0 	ld.w	r9,r7[-16]
800038cc:	30 08       	mov	r8,0
800038ce:	f3 68 00 08 	st.b	r9[8],r8
800038d2:	ee c8 00 40 	sub	r8,r7,64
800038d6:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800038da:	e1 b8 00 42 	mfsr	r8,0x108
800038de:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800038e2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800038e6:	f1 39 00 08 	ld.ub	r9,r8[8]
800038ea:	30 28       	mov	r8,2
800038ec:	f0 09 18 00 	cp.b	r9,r8
800038f0:	c0 31       	brne	800038f6 <display_init+0xfe>
    return false;
800038f2:	30 08       	mov	r8,0
800038f4:	c4 38       	rjmp	8000397a <display_init+0x182>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800038f6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800038fa:	f1 39 00 08 	ld.ub	r9,r8[8]
800038fe:	30 18       	mov	r8,1
80003900:	f0 09 18 00 	cp.b	r9,r8
80003904:	c0 31       	brne	8000390a <display_init+0x112>
    return true;
80003906:	30 18       	mov	r8,1
80003908:	c3 98       	rjmp	8000397a <display_init+0x182>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000390a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000390e:	70 09       	ld.w	r9,r8[0x0]
80003910:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003914:	70 18       	ld.w	r8,r8[0x4]
80003916:	10 39       	cp.w	r9,r8
80003918:	e0 88 00 1a 	brls	8000394c <display_init+0x154>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000391c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003920:	70 08       	ld.w	r8,r8[0x0]
80003922:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003926:	10 39       	cp.w	r9,r8
80003928:	c1 02       	brcc	80003948 <display_init+0x150>
8000392a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000392e:	70 18       	ld.w	r8,r8[0x4]
80003930:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003934:	10 39       	cp.w	r9,r8
80003936:	e0 88 00 09 	brls	80003948 <display_init+0x150>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000393a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000393e:	30 18       	mov	r8,1
80003940:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80003944:	30 18       	mov	r8,1
80003946:	c1 a8       	rjmp	8000397a <display_init+0x182>
    }
    return false;
80003948:	30 08       	mov	r8,0
8000394a:	c1 88       	rjmp	8000397a <display_init+0x182>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000394c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003950:	70 08       	ld.w	r8,r8[0x0]
80003952:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003956:	10 39       	cp.w	r9,r8
80003958:	c0 93       	brcs	8000396a <display_init+0x172>
8000395a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000395e:	70 18       	ld.w	r8,r8[0x4]
80003960:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003964:	10 39       	cp.w	r9,r8
80003966:	e0 88 00 09 	brls	80003978 <display_init+0x180>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000396a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000396e:	30 18       	mov	r8,1
80003970:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80003974:	30 18       	mov	r8,1
80003976:	c0 28       	rjmp	8000397a <display_init+0x182>
    }
    return false;
80003978:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
8000397a:	58 08       	cp.w	r8,0
8000397c:	ca b0       	breq	800038d2 <display_init+0xda>

	// Enable the SPI peripheral on GPIO pins
	gpio_enable_module(DIP204_SPI_GPIO_MAP,
8000397e:	30 4b       	mov	r11,4
80003980:	49 ec       	lddpc	r12,800039f8 <display_init+0x200>
80003982:	f0 1f 00 1f 	mcall	800039fc <display_init+0x204>
						sizeof(DIP204_SPI_GPIO_MAP) / 	sizeof(DIP204_SPI_GPIO_MAP[0]));

	// Initialize as SPI master
	spi_initMaster(DIP204_SPI, &spiOptions);
80003986:	ee c8 00 34 	sub	r8,r7,52
8000398a:	10 9b       	mov	r11,r8
8000398c:	fe 7c 28 00 	mov	r12,-55296
80003990:	f0 1f 00 1c 	mcall	80003a00 <display_init+0x208>
	spi_selectionMode(DIP204_SPI, 0, 0, 0);
80003994:	30 09       	mov	r9,0
80003996:	30 0a       	mov	r10,0
80003998:	30 0b       	mov	r11,0
8000399a:	fe 7c 28 00 	mov	r12,-55296
8000399e:	f0 1f 00 1a 	mcall	80003a04 <display_init+0x20c>
	spi_enable(DIP204_SPI);
800039a2:	fe 7c 28 00 	mov	r12,-55296
800039a6:	f0 1f 00 19 	mcall	80003a08 <display_init+0x210>
	spi_setupChipReg(DIP204_SPI, &spiOptions, FOSC0);
800039aa:	ee c8 00 34 	sub	r8,r7,52
800039ae:	e0 6a 1b 00 	mov	r10,6912
800039b2:	ea 1a 00 b7 	orh	r10,0xb7
800039b6:	10 9b       	mov	r11,r8
800039b8:	fe 7c 28 00 	mov	r12,-55296
800039bc:	f0 1f 00 14 	mcall	80003a0c <display_init+0x214>

	dip204_init(backlight_IO, ON);
800039c0:	30 1b       	mov	r11,1
800039c2:	30 0c       	mov	r12,0
800039c4:	f0 1f 00 13 	mcall	80003a10 <display_init+0x218>
	dip204_clear_display();
800039c8:	f0 1f 00 13 	mcall	80003a14 <display_init+0x21c>
	dip204_hide_cursor();
800039cc:	f0 1f 00 13 	mcall	80003a18 <display_init+0x220>
	dip204_set_cursor_position(1,1);
800039d0:	30 1b       	mov	r11,1
800039d2:	30 1c       	mov	r12,1
800039d4:	f0 1f 00 12 	mcall	80003a1c <display_init+0x224>
}
800039d8:	2f 0d       	sub	sp,-64
800039da:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
800039de:	00 00       	add	r0,r0
800039e0:	80 00       	ld.sh	r0,r0[0x0]
800039e2:	c4 18       	rjmp	80003a64 <initLED+0x44>
800039e4:	80 00       	ld.sh	r0,r0[0x0]
800039e6:	46 24       	lddsp	r4,sp[0x188]
800039e8:	80 00       	ld.sh	r0,r0[0x0]
800039ea:	46 88       	lddsp	r8,sp[0x1a0]
800039ec:	80 00       	ld.sh	r0,r0[0x0]
800039ee:	47 34       	lddsp	r4,sp[0x1cc]
800039f0:	80 00       	ld.sh	r0,r0[0x0]
800039f2:	37 e0       	mov	r0,126
800039f4:	80 00       	ld.sh	r0,r0[0x0]
800039f6:	66 68       	ld.w	r8,r3[0x18]
800039f8:	80 00       	ld.sh	r0,r0[0x0]
800039fa:	c4 28       	rjmp	80003a7e <initLED+0x5e>
800039fc:	80 00       	ld.sh	r0,r0[0x0]
800039fe:	41 90       	lddsp	r0,sp[0x64]
80003a00:	80 00       	ld.sh	r0,r0[0x0]
80003a02:	33 52       	mov	r2,53
80003a04:	80 00       	ld.sh	r0,r0[0x0]
80003a06:	33 e6       	mov	r6,62
80003a08:	80 00       	ld.sh	r0,r0[0x0]
80003a0a:	37 00       	mov	r0,112
80003a0c:	80 00       	ld.sh	r0,r0[0x0]
80003a0e:	35 7c       	mov	r12,87
80003a10:	80 00       	ld.sh	r0,r0[0x0]
80003a12:	21 08       	sub	r8,16
80003a14:	80 00       	ld.sh	r0,r0[0x0]
80003a16:	2c a0       	sub	r0,-54
80003a18:	80 00       	ld.sh	r0,r0[0x0]
80003a1a:	2b e4       	sub	r4,-66
80003a1c:	80 00       	ld.sh	r0,r0[0x0]
80003a1e:	2c 18       	sub	r8,-63

80003a20 <initLED>:
#include "LED.h"

void initLED (void)
{
80003a20:	eb cd 40 80 	pushm	r7,lr
80003a24:	1a 97       	mov	r7,sp
80003a26:	20 1d       	sub	sp,4
	/*
	* First make access to the GPIO port registers
	* shorter to type , just for our convenience
	*/
	volatile avr32_gpio_port_t * led0_port;
	led0_port = &AVR32_GPIO.port[LED0_PORT];
80003a28:	fe 78 11 00 	mov	r8,-61184
80003a2c:	ef 48 ff fc 	st.w	r7[-4],r8
	/*
	* Choose GPIO peripheral function ,
	* by writing a 1 to gpers , GPIO Enable Register Set
	*/
	led0_port->gpers = LED0_BIT_VALUE;
80003a30:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a34:	fc 19 08 00 	movh	r9,0x800
80003a38:	91 19       	st.w	r8[0x4],r9
	led0_port->gpers = LED1_BIT_VALUE;
80003a3a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a3e:	fc 19 10 00 	movh	r9,0x1000
80003a42:	91 19       	st.w	r8[0x4],r9
	led0_port->gpers = LED2_BIT_VALUE;
80003a44:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a48:	fc 19 20 00 	movh	r9,0x2000
80003a4c:	91 19       	st.w	r8[0x4],r9
	/*
	* Set the output value register to 1 in order to
	* turn the LED off (1= off , 0= on in this case ) ,
	* by writing a 1 to ovrs , Output Value Register Set
	*/
	led0_port->ovrs = LED0_BIT_VALUE;
80003a4e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a52:	fc 19 08 00 	movh	r9,0x800
80003a56:	f1 49 00 54 	st.w	r8[84],r9
	led0_port->ovrs = LED1_BIT_VALUE;
80003a5a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a5e:	fc 19 10 00 	movh	r9,0x1000
80003a62:	f1 49 00 54 	st.w	r8[84],r9
	led0_port->ovrs = LED2_BIT_VALUE;
80003a66:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a6a:	fc 19 20 00 	movh	r9,0x2000
80003a6e:	f1 49 00 54 	st.w	r8[84],r9
	/*
	* Set the output enable register ,
	* by writing a 1 to oders , Output Drive Enable
	* Register Set
	*/
	led0_port->oders = LED0_BIT_VALUE;
80003a72:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a76:	fc 19 08 00 	movh	r9,0x800
80003a7a:	f1 49 00 44 	st.w	r8[68],r9
	led0_port->oders = LED1_BIT_VALUE;
80003a7e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a82:	fc 19 10 00 	movh	r9,0x1000
80003a86:	f1 49 00 44 	st.w	r8[68],r9
	led0_port->oders = LED2_BIT_VALUE;
80003a8a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a8e:	fc 19 20 00 	movh	r9,0x2000
80003a92:	f1 49 00 44 	st.w	r8[68],r9
}
80003a96:	2f fd       	sub	sp,-4
80003a98:	e3 cd 80 80 	ldm	sp++,r7,pc

80003a9c <onLED>:
{
	AVR32_GPIO.port[LED0_PORT].ovrt = ledNr;
}

void onLED(int ledNr)
{
80003a9c:	eb cd 40 80 	pushm	r7,lr
80003aa0:	1a 97       	mov	r7,sp
80003aa2:	20 1d       	sub	sp,4
80003aa4:	ef 4c ff fc 	st.w	r7[-4],r12
	AVR32_GPIO.port[LED0_PORT].ovrc = ledNr;
80003aa8:	fe 78 10 00 	mov	r8,-61440
80003aac:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003ab0:	f1 49 01 58 	st.w	r8[344],r9
}
80003ab4:	2f fd       	sub	sp,-4
80003ab6:	e3 cd 80 80 	ldm	sp++,r7,pc
80003aba:	d7 03       	nop
80003abc:	54 65       	stdsp	sp[0x118],r5
80003abe:	6d 70       	ld.w	r0,r6[0x5c]
80003ac0:	65 72       	ld.w	r2,r2[0x5c]
80003ac2:	61 74       	ld.w	r4,r0[0x5c]
80003ac4:	75 72       	ld.w	r2,r10[0x5c]
80003ac6:	65 3a       	ld.w	r10,r2[0x4c]
80003ac8:	00 00       	add	r0,r0
80003aca:	00 00       	add	r0,r0
80003acc:	50 6f       	stdsp	sp[0x18],pc
80003ace:	74 65       	ld.w	r5,r10[0x18]
80003ad0:	6e 74       	ld.w	r4,r7[0x1c]
80003ad2:	69 6f       	ld.w	pc,r4[0x58]
80003ad4:	6d 65       	ld.w	r5,r6[0x58]
80003ad6:	74 65       	ld.w	r5,r10[0x18]
80003ad8:	72 3a       	ld.w	r10,r9[0xc]
80003ada:	00 00       	add	r0,r0
80003adc:	4c 69       	lddpc	r9,80003bf4 <vTemperature+0x3c>
80003ade:	67 68       	ld.w	r8,r3[0x58]
80003ae0:	74 3a       	ld.w	r10,r10[0xc]
80003ae2:	00 00       	add	r0,r0
80003ae4:	54 65       	stdsp	sp[0x118],r5
80003ae6:	6d 70       	ld.w	r0,r6[0x5c]
80003ae8:	65 72       	ld.w	r2,r2[0x5c]
80003aea:	61 74       	ld.w	r4,r0[0x5c]
80003aec:	75 72       	ld.w	r2,r10[0x5c]
80003aee:	65 20       	ld.w	r0,r2[0x48]
80003af0:	25 64       	sub	r4,86
80003af2:	0a 00       	add	r0,r5
80003af4:	50 6f       	stdsp	sp[0x18],pc
80003af6:	74 65       	ld.w	r5,r10[0x18]
80003af8:	6e 74       	ld.w	r4,r7[0x1c]
80003afa:	69 6f       	ld.w	pc,r4[0x58]
80003afc:	6d 65       	ld.w	r5,r6[0x58]
80003afe:	74 65       	ld.w	r5,r10[0x18]
80003b00:	72 20       	ld.w	r0,r9[0x8]
80003b02:	25 64       	sub	r4,86
80003b04:	0a 00       	add	r0,r5
80003b06:	00 00       	add	r0,r0
80003b08:	4c 69       	lddpc	r9,80003c20 <vTemperature+0x68>
80003b0a:	67 68       	ld.w	r8,r3[0x58]
80003b0c:	74 20       	ld.w	r0,r10[0x8]
80003b0e:	25 64       	sub	r4,86
80003b10:	0a 00       	add	r0,r5
80003b12:	00 00       	add	r0,r0
80003b14:	25 30       	sub	r0,83
80003b16:	34 64       	mov	r4,70
80003b18:	00 00       	add	r0,r0
80003b1a:	00 00       	add	r0,r0
80003b1c:	76 43       	ld.w	r3,r11[0x10]
80003b1e:	6f 6e       	ld.w	lr,r7[0x58]
80003b20:	73 75       	ld.w	r5,r9[0x5c]
80003b22:	6d 65       	ld.w	r5,r6[0x58]
80003b24:	72 00       	ld.w	r0,r9[0x0]
80003b26:	00 00       	add	r0,r0
80003b28:	76 54       	ld.w	r4,r11[0x14]
80003b2a:	65 6d       	ld.w	sp,r2[0x58]
80003b2c:	70 65       	ld.w	r5,r8[0x18]
80003b2e:	72 61       	ld.w	r1,r9[0x18]
80003b30:	74 75       	ld.w	r5,r10[0x1c]
80003b32:	72 65       	ld.w	r5,r9[0x18]
80003b34:	00 00       	add	r0,r0
80003b36:	00 00       	add	r0,r0
80003b38:	76 50       	ld.w	r0,r11[0x14]
80003b3a:	6f 74       	ld.w	r4,r7[0x5c]
80003b3c:	65 6e       	ld.w	lr,r2[0x58]
80003b3e:	74 69       	ld.w	r9,r10[0x18]
80003b40:	6f 6d       	ld.w	sp,r7[0x58]
80003b42:	65 74       	ld.w	r4,r2[0x5c]
80003b44:	65 72       	ld.w	r2,r2[0x5c]
80003b46:	00 00       	add	r0,r0
80003b48:	76 4c       	ld.w	r12,r11[0x10]
80003b4a:	69 67       	ld.w	r7,r4[0x58]
80003b4c:	68 74       	ld.w	r4,r4[0x1c]
	...

80003b50 <init_usart>:
xTaskHandle xHandleTemperature;		// Task handle - Temperature
xTaskHandle xHandlePotentiometer;	// Task handle - Potentiometer
xTaskHandle xHandleLight;			// Task handle - Light

void init_usart ( void )
{
80003b50:	eb cd 40 80 	pushm	r7,lr
80003b54:	1a 97       	mov	r7,sp
		. charlength = 8,
		. paritytype = USART_NO_PARITY ,
		. stopbits = USART_1_STOPBIT ,
		. channelmode = USART_NORMAL_CHMODE
	};
	pm_switch_to_osc0 (& AVR32_PM , FOSC0 , OSC0_STARTUP );				// Switch to 12 MHz clock
80003b56:	30 3a       	mov	r10,3
80003b58:	e0 6b 1b 00 	mov	r11,6912
80003b5c:	ea 1b 00 b7 	orh	r11,0xb7
80003b60:	fe 7c 0c 00 	mov	r12,-62464
80003b64:	f0 1f 00 0f 	mcall	80003ba0 <init_usart+0x50>
	gpio_enable_module ( USART_SERIAL_GPIO_MAP , 2);					// Enable usart
80003b68:	30 2b       	mov	r11,2
80003b6a:	48 fc       	lddpc	r12,80003ba4 <init_usart+0x54>
80003b6c:	f0 1f 00 0f 	mcall	80003ba8 <init_usart+0x58>
	gpio_enable_module ( USART_DEBUG_GPIO_MAP , 2);
80003b70:	30 2b       	mov	r11,2
80003b72:	48 fc       	lddpc	r12,80003bac <init_usart+0x5c>
80003b74:	f0 1f 00 0d 	mcall	80003ba8 <init_usart+0x58>
	usart_init_rs232 ( serialPORT_USART , & USART_OPTIONS , FOSC0 );	// Usart options
80003b78:	e0 6a 1b 00 	mov	r10,6912
80003b7c:	ea 1a 00 b7 	orh	r10,0xb7
80003b80:	48 cb       	lddpc	r11,80003bb0 <init_usart+0x60>
80003b82:	fe 7c 18 00 	mov	r12,-59392
80003b86:	f0 1f 00 0c 	mcall	80003bb4 <init_usart+0x64>
	usart_init_rs232 ( configDBG_USART , & USART_OPTIONS , FOSC0 );
80003b8a:	e0 6a 1b 00 	mov	r10,6912
80003b8e:	ea 1a 00 b7 	orh	r10,0xb7
80003b92:	48 8b       	lddpc	r11,80003bb0 <init_usart+0x60>
80003b94:	fe 7c 18 00 	mov	r12,-59392
80003b98:	f0 1f 00 07 	mcall	80003bb4 <init_usart+0x64>
}
80003b9c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003ba0:	80 00       	ld.sh	r0,r0[0x0]
80003ba2:	47 80       	lddsp	r0,sp[0x1e0]
80003ba4:	80 00       	ld.sh	r0,r0[0x0]
80003ba6:	c4 48       	rjmp	80003c2e <vTemperature+0x76>
80003ba8:	80 00       	ld.sh	r0,r0[0x0]
80003baa:	41 90       	lddsp	r0,sp[0x64]
80003bac:	80 00       	ld.sh	r0,r0[0x0]
80003bae:	c4 58       	rjmp	80003c38 <vTemperature+0x80>
80003bb0:	80 00       	ld.sh	r0,r0[0x0]
80003bb2:	c4 68       	rjmp	80003c3e <vTemperature+0x86>
80003bb4:	80 00       	ld.sh	r0,r0[0x0]
80003bb6:	49 30       	lddpc	r0,80003c00 <vTemperature+0x48>

80003bb8 <vTemperature>:

void vTemperature(void *pvParameters)
{
80003bb8:	eb cd 40 80 	pushm	r7,lr
80003bbc:	1a 97       	mov	r7,sp
80003bbe:	20 3d       	sub	sp,12
80003bc0:	ef 4c ff f4 	st.w	r7[-12],r12
	volatile portTickType xLastWakeTime; // Holds tick count
	xLastWakeTime = xTaskGetTickCount(); // Sets current tick count
80003bc4:	f0 1f 00 18 	mcall	80003c24 <vTemperature+0x6c>
80003bc8:	18 98       	mov	r8,r12
80003bca:	ef 48 ff fc 	st.w	r7[-4],r8
80003bce:	c0 28       	rjmp	80003bd2 <vTemperature+0x1a>
		// (Sample hold time + Startup time) * 12MHz = 544
		// IF CLK_ADC = 115200Hz => (Sample hold time + Startup time) * 115200 = (0,0002778 + 0,00444) * 115200 = 543.49

		//vTaskDelay(100);
		//vTaskDelayUntil(xLastWakeTime,xFreq);
	}
80003bd0:	d7 03       	nop
	//volatile const portTickType xFreq = 544; // Holds the period	
	volatile uint32_t value_to_send;		// Character to send to Consumer
	
	while(1)
	{
		if(xSemaphoreTake(xEmptyCountTemperature, (portTickType)portMAX_DELAY) == pdTRUE)
80003bd2:	49 68       	lddpc	r8,80003c28 <vTemperature+0x70>
80003bd4:	70 08       	ld.w	r8,r8[0x0]
80003bd6:	30 09       	mov	r9,0
80003bd8:	3f fa       	mov	r10,-1
80003bda:	30 0b       	mov	r11,0
80003bdc:	10 9c       	mov	r12,r8
80003bde:	f0 1f 00 14 	mcall	80003c2c <vTemperature+0x74>
80003be2:	18 98       	mov	r8,r12
80003be4:	58 18       	cp.w	r8,1
80003be6:	cf 51       	brne	80003bd0 <vTemperature+0x18>
		{
			// Semaphore taken
			adc_start(&AVR32_ADC);
80003be8:	fe 7c 3c 00 	mov	r12,-50176
80003bec:	f0 1f 00 11 	mcall	80003c30 <vTemperature+0x78>
			value_to_send = adc_get_value(&AVR32_ADC, ADC_TEMPERATURE_CHANNEL);
80003bf0:	30 0b       	mov	r11,0
80003bf2:	fe 7c 3c 00 	mov	r12,-50176
80003bf6:	f0 1f 00 10 	mcall	80003c34 <vTemperature+0x7c>
80003bfa:	18 98       	mov	r8,r12
80003bfc:	ef 48 ff f8 	st.w	r7[-8],r8
			xQueueSendToBack(xQHandleTemperature, &value_to_send, (portTickType)10);
80003c00:	48 e8       	lddpc	r8,80003c38 <vTemperature+0x80>
80003c02:	70 08       	ld.w	r8,r8[0x0]
80003c04:	ee cb 00 08 	sub	r11,r7,8
80003c08:	30 09       	mov	r9,0
80003c0a:	30 aa       	mov	r10,10
80003c0c:	10 9c       	mov	r12,r8
80003c0e:	f0 1f 00 0c 	mcall	80003c3c <vTemperature+0x84>
		
			if(xSemaphoreGive(xFillCountTemperature) == pdTRUE)
80003c12:	48 c8       	lddpc	r8,80003c40 <vTemperature+0x88>
80003c14:	70 08       	ld.w	r8,r8[0x0]
80003c16:	30 09       	mov	r9,0
80003c18:	30 0a       	mov	r10,0
80003c1a:	30 0b       	mov	r11,0
80003c1c:	10 9c       	mov	r12,r8
80003c1e:	f0 1f 00 08 	mcall	80003c3c <vTemperature+0x84>
		// (Sample hold time + Startup time) * 12MHz = 544
		// IF CLK_ADC = 115200Hz => (Sample hold time + Startup time) * 115200 = (0,0002778 + 0,00444) * 115200 = 543.49

		//vTaskDelay(100);
		//vTaskDelayUntil(xLastWakeTime,xFreq);
	}
80003c22:	cd 8b       	rjmp	80003bd2 <vTemperature+0x1a>
80003c24:	80 00       	ld.sh	r0,r0[0x0]
80003c26:	5e a8       	retle	r8
80003c28:	00 00       	add	r0,r0
80003c2a:	07 e0       	ld.ub	r0,r3[0x6]
80003c2c:	80 00       	ld.sh	r0,r0[0x0]
80003c2e:	56 80       	stdsp	sp[0x1a0],r0
80003c30:	80 00       	ld.sh	r0,r0[0x0]
80003c32:	30 d6       	mov	r6,13
80003c34:	80 00       	ld.sh	r0,r0[0x0]
80003c36:	31 4c       	mov	r12,20
80003c38:	00 00       	add	r0,r0
80003c3a:	08 00       	add	r0,r4
80003c3c:	80 00       	ld.sh	r0,r0[0x0]
80003c3e:	55 18       	stdsp	sp[0x144],r8
80003c40:	00 00       	add	r0,r0
80003c42:	07 d8       	ld.ub	r8,r3[0x5]

80003c44 <vPotentiometer>:
}

void vPotentiometer(void *pvParameters)
{
80003c44:	eb cd 40 80 	pushm	r7,lr
80003c48:	1a 97       	mov	r7,sp
80003c4a:	20 4d       	sub	sp,16
80003c4c:	ef 4c ff f0 	st.w	r7[-16],r12
	volatile portTickType xLastWakeTime; // Holds tick count
	xLastWakeTime = xTaskGetTickCount(); // Sets current tick count
80003c50:	f0 1f 00 1a 	mcall	80003cb8 <vPotentiometer+0x74>
80003c54:	18 98       	mov	r8,r12
80003c56:	ef 48 ff fc 	st.w	r7[-4],r8
	//volatile const portTickType xFreq = TASK_DELAY_MS(1000); // Holds the period		
	volatile const portTickType xFreq = 544; // Holds the period	
80003c5a:	e0 68 02 20 	mov	r8,544
80003c5e:	ef 48 ff f8 	st.w	r7[-8],r8
80003c62:	c0 28       	rjmp	80003c66 <vPotentiometer+0x22>
		{
			usart_write_line(serialPORT_USART, "Deadline miss - Potentiometer");
		}*/
		//vTaskDelayUntil(xLastWakeTime,xFreq);
		//vTaskDelay(100);
	}
80003c64:	d7 03       	nop
	volatile const portTickType xFreq = 544; // Holds the period	
	volatile uint32_t value_to_send;		// Character to send to Consumer
	
	while(1)
	{		
		if(xSemaphoreTake(xEmptyCountPotentiometer, (portTickType)portMAX_DELAY) == pdTRUE)
80003c66:	49 68       	lddpc	r8,80003cbc <vPotentiometer+0x78>
80003c68:	70 08       	ld.w	r8,r8[0x0]
80003c6a:	30 09       	mov	r9,0
80003c6c:	3f fa       	mov	r10,-1
80003c6e:	30 0b       	mov	r11,0
80003c70:	10 9c       	mov	r12,r8
80003c72:	f0 1f 00 14 	mcall	80003cc0 <vPotentiometer+0x7c>
80003c76:	18 98       	mov	r8,r12
80003c78:	58 18       	cp.w	r8,1
80003c7a:	cf 51       	brne	80003c64 <vPotentiometer+0x20>
		{
			// Semaphore taken
			adc_start(&AVR32_ADC);
80003c7c:	fe 7c 3c 00 	mov	r12,-50176
80003c80:	f0 1f 00 11 	mcall	80003cc4 <vPotentiometer+0x80>
			value_to_send = adc_get_value(&AVR32_ADC, ADC_POTENTIOMETER_CHANNEL);
80003c84:	30 1b       	mov	r11,1
80003c86:	fe 7c 3c 00 	mov	r12,-50176
80003c8a:	f0 1f 00 10 	mcall	80003cc8 <vPotentiometer+0x84>
80003c8e:	18 98       	mov	r8,r12
80003c90:	ef 48 ff f4 	st.w	r7[-12],r8
			xQueueSendToBack(xQHandlePotentiometer, &value_to_send, (portTickType)10);	
80003c94:	48 e8       	lddpc	r8,80003ccc <vPotentiometer+0x88>
80003c96:	70 08       	ld.w	r8,r8[0x0]
80003c98:	ee cb 00 0c 	sub	r11,r7,12
80003c9c:	30 09       	mov	r9,0
80003c9e:	30 aa       	mov	r10,10
80003ca0:	10 9c       	mov	r12,r8
80003ca2:	f0 1f 00 0c 	mcall	80003cd0 <vPotentiometer+0x8c>
				
			if(xSemaphoreGive(xFillCountPotentiometer) == pdTRUE)
80003ca6:	48 c8       	lddpc	r8,80003cd4 <vPotentiometer+0x90>
80003ca8:	70 08       	ld.w	r8,r8[0x0]
80003caa:	30 09       	mov	r9,0
80003cac:	30 0a       	mov	r10,0
80003cae:	30 0b       	mov	r11,0
80003cb0:	10 9c       	mov	r12,r8
80003cb2:	f0 1f 00 08 	mcall	80003cd0 <vPotentiometer+0x8c>
		{
			usart_write_line(serialPORT_USART, "Deadline miss - Potentiometer");
		}*/
		//vTaskDelayUntil(xLastWakeTime,xFreq);
		//vTaskDelay(100);
	}
80003cb6:	cd 8b       	rjmp	80003c66 <vPotentiometer+0x22>
80003cb8:	80 00       	ld.sh	r0,r0[0x0]
80003cba:	5e a8       	retle	r8
80003cbc:	00 00       	add	r0,r0
80003cbe:	08 04       	add	r4,r4
80003cc0:	80 00       	ld.sh	r0,r0[0x0]
80003cc2:	56 80       	stdsp	sp[0x1a0],r0
80003cc4:	80 00       	ld.sh	r0,r0[0x0]
80003cc6:	30 d6       	mov	r6,13
80003cc8:	80 00       	ld.sh	r0,r0[0x0]
80003cca:	31 4c       	mov	r12,20
80003ccc:	00 00       	add	r0,r0
80003cce:	07 f8       	ld.ub	r8,r3[0x7]
80003cd0:	80 00       	ld.sh	r0,r0[0x0]
80003cd2:	55 18       	stdsp	sp[0x144],r8
80003cd4:	00 00       	add	r0,r0
80003cd6:	07 e8       	ld.ub	r8,r3[0x6]

80003cd8 <vLight>:
}

void vLight(void *pvParameters)
{
80003cd8:	eb cd 40 80 	pushm	r7,lr
80003cdc:	1a 97       	mov	r7,sp
80003cde:	20 3d       	sub	sp,12
80003ce0:	ef 4c ff f4 	st.w	r7[-12],r12
	volatile portTickType xLastWakeTime; // Holds tick count
	xLastWakeTime = xTaskGetTickCount(); // Sets current tick count
80003ce4:	f0 1f 00 18 	mcall	80003d44 <vLight+0x6c>
80003ce8:	18 98       	mov	r8,r12
80003cea:	ef 48 ff fc 	st.w	r7[-4],r8
80003cee:	c0 28       	rjmp	80003cf2 <vLight+0x1a>
			}
		}
		//vTaskDelay(TASK_DELAY_MS(100));
		//vTaskDelayUntil(xLastWakeTime,xFreq);
		//vTaskDelay(100);
	}
80003cf0:	d7 03       	nop
	//volatile const portTickType xFreq = 544; // Holds the period	
	volatile uint32_t value_to_send;		// Character to send to Consumer
	
	while(1)
	{		
		if(xSemaphoreTake(xEmptyCountLight, (portTickType)portMAX_DELAY) == pdTRUE)
80003cf2:	49 68       	lddpc	r8,80003d48 <vLight+0x70>
80003cf4:	70 08       	ld.w	r8,r8[0x0]
80003cf6:	30 09       	mov	r9,0
80003cf8:	3f fa       	mov	r10,-1
80003cfa:	30 0b       	mov	r11,0
80003cfc:	10 9c       	mov	r12,r8
80003cfe:	f0 1f 00 14 	mcall	80003d4c <vLight+0x74>
80003d02:	18 98       	mov	r8,r12
80003d04:	58 18       	cp.w	r8,1
80003d06:	cf 51       	brne	80003cf0 <vLight+0x18>
		{
			// Semaphore taken
			adc_start(&AVR32_ADC);
80003d08:	fe 7c 3c 00 	mov	r12,-50176
80003d0c:	f0 1f 00 11 	mcall	80003d50 <vLight+0x78>
			value_to_send = adc_get_value(&AVR32_ADC, ADC_LIGHT_CHANNEL);
80003d10:	30 2b       	mov	r11,2
80003d12:	fe 7c 3c 00 	mov	r12,-50176
80003d16:	f0 1f 00 10 	mcall	80003d54 <vLight+0x7c>
80003d1a:	18 98       	mov	r8,r12
80003d1c:	ef 48 ff f8 	st.w	r7[-8],r8
			xQueueSendToBack(xQHandleLight, &value_to_send, (portTickType)10);
80003d20:	48 e8       	lddpc	r8,80003d58 <vLight+0x80>
80003d22:	70 08       	ld.w	r8,r8[0x0]
80003d24:	ee cb 00 08 	sub	r11,r7,8
80003d28:	30 09       	mov	r9,0
80003d2a:	30 aa       	mov	r10,10
80003d2c:	10 9c       	mov	r12,r8
80003d2e:	f0 1f 00 0c 	mcall	80003d5c <vLight+0x84>
		
			if(xSemaphoreGive(xFillCountLight) == pdTRUE)
80003d32:	48 c8       	lddpc	r8,80003d60 <vLight+0x88>
80003d34:	70 08       	ld.w	r8,r8[0x0]
80003d36:	30 09       	mov	r9,0
80003d38:	30 0a       	mov	r10,0
80003d3a:	30 0b       	mov	r11,0
80003d3c:	10 9c       	mov	r12,r8
80003d3e:	f0 1f 00 08 	mcall	80003d5c <vLight+0x84>
			}
		}
		//vTaskDelay(TASK_DELAY_MS(100));
		//vTaskDelayUntil(xLastWakeTime,xFreq);
		//vTaskDelay(100);
	}
80003d42:	cd 8b       	rjmp	80003cf2 <vLight+0x1a>
80003d44:	80 00       	ld.sh	r0,r0[0x0]
80003d46:	5e a8       	retle	r8
80003d48:	00 00       	add	r0,r0
80003d4a:	07 fc       	ld.ub	r12,r3[0x7]
80003d4c:	80 00       	ld.sh	r0,r0[0x0]
80003d4e:	56 80       	stdsp	sp[0x1a0],r0
80003d50:	80 00       	ld.sh	r0,r0[0x0]
80003d52:	30 d6       	mov	r6,13
80003d54:	80 00       	ld.sh	r0,r0[0x0]
80003d56:	31 4c       	mov	r12,20
80003d58:	00 00       	add	r0,r0
80003d5a:	07 ec       	ld.ub	r12,r3[0x6]
80003d5c:	80 00       	ld.sh	r0,r0[0x0]
80003d5e:	55 18       	stdsp	sp[0x144],r8
80003d60:	00 00       	add	r0,r0
80003d62:	08 08       	add	r8,r4

80003d64 <vConsumer>:
}

void vConsumer( void *pvParameters )
{
80003d64:	eb cd 40 80 	pushm	r7,lr
80003d68:	1a 97       	mov	r7,sp
80003d6a:	21 3d       	sub	sp,76
80003d6c:	ef 4c ff b4 	st.w	r7[-76],r12
	volatile uint32_t temperature_received = 0;		// Value received
80003d70:	30 08       	mov	r8,0
80003d72:	ef 48 ff f0 	st.w	r7[-16],r8
	volatile uint32_t potentiometer_received = 0;	// Value received
80003d76:	30 08       	mov	r8,0
80003d78:	ef 48 ff ec 	st.w	r7[-20],r8
	volatile uint32_t light_received = 0;			// Value received
80003d7c:	30 08       	mov	r8,0
80003d7e:	ef 48 ff e8 	st.w	r7[-24],r8
	volatile uint32_t temp_usart_write = 0;			// Value received
80003d82:	30 08       	mov	r8,0
80003d84:	ef 48 ff e4 	st.w	r7[-28],r8
	volatile uint32_t pot_usart_write = 0;			// Value received
80003d88:	30 08       	mov	r8,0
80003d8a:	ef 48 ff e0 	st.w	r7[-32],r8
	volatile uint32_t light_usart_write = 0;			// Value received
80003d8e:	30 08       	mov	r8,0
80003d90:	ef 48 ff dc 	st.w	r7[-36],r8
	volatile const char * string_temp = "Temperature:";
80003d94:	4f 08       	lddpc	r8,80003f54 <vConsumer+0x1f0>
80003d96:	ef 48 ff f4 	st.w	r7[-12],r8
	volatile const char * string_potentiometer = "Potentiometer:";
80003d9a:	4f 08       	lddpc	r8,80003f58 <vConsumer+0x1f4>
80003d9c:	ef 48 ff f8 	st.w	r7[-8],r8
	volatile const char * string_light = "Light:";
80003da0:	4e f8       	lddpc	r8,80003f5c <vConsumer+0x1f8>
80003da2:	ef 48 ff fc 	st.w	r7[-4],r8
	volatile char temperature_usart[10];
	volatile char potentiometer_usart[10];
	volatile char light_usart[10];
	
	dip204_clear_display();
80003da6:	f0 1f 00 6f 	mcall	80003f60 <vConsumer+0x1fc>
	dip204_set_cursor_position(1, 1);
80003daa:	30 1b       	mov	r11,1
80003dac:	30 1c       	mov	r12,1
80003dae:	f0 1f 00 6e 	mcall	80003f64 <vConsumer+0x200>
	dip204_write_string(string_temp);
80003db2:	ee fc ff f4 	ld.w	r12,r7[-12]
80003db6:	f0 1f 00 6d 	mcall	80003f68 <vConsumer+0x204>
	dip204_set_cursor_position(1, 2);
80003dba:	30 2b       	mov	r11,2
80003dbc:	30 1c       	mov	r12,1
80003dbe:	f0 1f 00 6a 	mcall	80003f64 <vConsumer+0x200>
	dip204_write_string(string_potentiometer);
80003dc2:	ee fc ff f8 	ld.w	r12,r7[-8]
80003dc6:	f0 1f 00 69 	mcall	80003f68 <vConsumer+0x204>
	dip204_set_cursor_position(1, 3);
80003dca:	30 3b       	mov	r11,3
80003dcc:	30 1c       	mov	r12,1
80003dce:	f0 1f 00 66 	mcall	80003f64 <vConsumer+0x200>
	dip204_write_string(string_light);
80003dd2:	ee fc ff fc 	ld.w	r12,r7[-4]
80003dd6:	f0 1f 00 65 	mcall	80003f68 <vConsumer+0x204>
	
	onLED(LED3_BIT_VALUE);	// On when Consumer is active
80003dda:	fc 1c 40 00 	movh	r12,0x4000
80003dde:	f0 1f 00 64 	mcall	80003f6c <vConsumer+0x208>
	
	while(1)
	{
		if(xSemaphoreTake(xFillCountTemperature, (portTickType)10) == pdTRUE)
80003de2:	4e 48       	lddpc	r8,80003f70 <vConsumer+0x20c>
80003de4:	70 08       	ld.w	r8,r8[0x0]
80003de6:	30 09       	mov	r9,0
80003de8:	30 aa       	mov	r10,10
80003dea:	30 0b       	mov	r11,0
80003dec:	10 9c       	mov	r12,r8
80003dee:	f0 1f 00 62 	mcall	80003f74 <vConsumer+0x210>
80003df2:	18 98       	mov	r8,r12
80003df4:	58 18       	cp.w	r8,1
80003df6:	c1 61       	brne	80003e22 <vConsumer+0xbe>
		{
			// Semaphore taken
			xQueueReceive(xQHandleTemperature, &temperature_received, (portTickType)10);
80003df8:	4e 08       	lddpc	r8,80003f78 <vConsumer+0x214>
80003dfa:	70 08       	ld.w	r8,r8[0x0]
80003dfc:	ee cb 00 10 	sub	r11,r7,16
80003e00:	30 09       	mov	r9,0
80003e02:	30 aa       	mov	r10,10
80003e04:	10 9c       	mov	r12,r8
80003e06:	f0 1f 00 5c 	mcall	80003f74 <vConsumer+0x210>
			temp_usart_write = temperature_received;
80003e0a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003e0e:	ef 48 ff e4 	st.w	r7[-28],r8
		
			if(xSemaphoreGive(xEmptyCountTemperature) == pdTRUE)
80003e12:	4d b8       	lddpc	r8,80003f7c <vConsumer+0x218>
80003e14:	70 08       	ld.w	r8,r8[0x0]
80003e16:	30 09       	mov	r9,0
80003e18:	30 0a       	mov	r10,0
80003e1a:	30 0b       	mov	r11,0
80003e1c:	10 9c       	mov	r12,r8
80003e1e:	f0 1f 00 59 	mcall	80003f80 <vConsumer+0x21c>
			{
				// Semaphore given
			}
		}
		
		if(xSemaphoreTake(xFillCountPotentiometer, (portTickType)10) == pdTRUE)
80003e22:	4d 98       	lddpc	r8,80003f84 <vConsumer+0x220>
80003e24:	70 08       	ld.w	r8,r8[0x0]
80003e26:	30 09       	mov	r9,0
80003e28:	30 aa       	mov	r10,10
80003e2a:	30 0b       	mov	r11,0
80003e2c:	10 9c       	mov	r12,r8
80003e2e:	f0 1f 00 52 	mcall	80003f74 <vConsumer+0x210>
80003e32:	18 98       	mov	r8,r12
80003e34:	58 18       	cp.w	r8,1
80003e36:	c1 61       	brne	80003e62 <vConsumer+0xfe>
		{
			// Semaphore taken
			xQueueReceive(xQHandlePotentiometer, &potentiometer_received, (portTickType)10);
80003e38:	4d 48       	lddpc	r8,80003f88 <vConsumer+0x224>
80003e3a:	70 08       	ld.w	r8,r8[0x0]
80003e3c:	ee cb 00 14 	sub	r11,r7,20
80003e40:	30 09       	mov	r9,0
80003e42:	30 aa       	mov	r10,10
80003e44:	10 9c       	mov	r12,r8
80003e46:	f0 1f 00 4c 	mcall	80003f74 <vConsumer+0x210>
			pot_usart_write = potentiometer_received;
80003e4a:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003e4e:	ef 48 ff e0 	st.w	r7[-32],r8
		
			if(xSemaphoreGive(xEmptyCountPotentiometer) == pdTRUE)
80003e52:	4c f8       	lddpc	r8,80003f8c <vConsumer+0x228>
80003e54:	70 08       	ld.w	r8,r8[0x0]
80003e56:	30 09       	mov	r9,0
80003e58:	30 0a       	mov	r10,0
80003e5a:	30 0b       	mov	r11,0
80003e5c:	10 9c       	mov	r12,r8
80003e5e:	f0 1f 00 49 	mcall	80003f80 <vConsumer+0x21c>
			{
				// Semaphore given
			}
		}		

		if(xSemaphoreTake(xFillCountLight, (portTickType)10) == pdTRUE)
80003e62:	4c c8       	lddpc	r8,80003f90 <vConsumer+0x22c>
80003e64:	70 08       	ld.w	r8,r8[0x0]
80003e66:	30 09       	mov	r9,0
80003e68:	30 aa       	mov	r10,10
80003e6a:	30 0b       	mov	r11,0
80003e6c:	10 9c       	mov	r12,r8
80003e6e:	f0 1f 00 42 	mcall	80003f74 <vConsumer+0x210>
80003e72:	18 98       	mov	r8,r12
80003e74:	58 18       	cp.w	r8,1
80003e76:	c1 61       	brne	80003ea2 <vConsumer+0x13e>
		{
			// Semaphore taken
			xQueueReceive(xQHandleLight, &light_received, (portTickType)10);
80003e78:	4c 78       	lddpc	r8,80003f94 <vConsumer+0x230>
80003e7a:	70 08       	ld.w	r8,r8[0x0]
80003e7c:	ee cb 00 18 	sub	r11,r7,24
80003e80:	30 09       	mov	r9,0
80003e82:	30 aa       	mov	r10,10
80003e84:	10 9c       	mov	r12,r8
80003e86:	f0 1f 00 3c 	mcall	80003f74 <vConsumer+0x210>
			light_usart_write = light_received;
80003e8a:	ee f8 ff e8 	ld.w	r8,r7[-24]
80003e8e:	ef 48 ff dc 	st.w	r7[-36],r8
		
			if(xSemaphoreGive(xEmptyCountLight) == pdTRUE)
80003e92:	4c 28       	lddpc	r8,80003f98 <vConsumer+0x234>
80003e94:	70 08       	ld.w	r8,r8[0x0]
80003e96:	30 09       	mov	r9,0
80003e98:	30 0a       	mov	r10,0
80003e9a:	30 0b       	mov	r11,0
80003e9c:	10 9c       	mov	r12,r8
80003e9e:	f0 1f 00 39 	mcall	80003f80 <vConsumer+0x21c>
			{
				// Semaphore given
			}
		}

		sprintf(temperature_usart, "Temperature %d\n", temp_usart_write);
80003ea2:	ee f9 ff e4 	ld.w	r9,r7[-28]
80003ea6:	ee c8 00 30 	sub	r8,r7,48
80003eaa:	1a d9       	st.w	--sp,r9
80003eac:	4b cb       	lddpc	r11,80003f9c <vConsumer+0x238>
80003eae:	10 9c       	mov	r12,r8
80003eb0:	f0 1f 00 3c 	mcall	80003fa0 <vConsumer+0x23c>
80003eb4:	2f fd       	sub	sp,-4
		usart_write_line(serialPORT_USART, temperature_usart);
80003eb6:	ee c8 00 30 	sub	r8,r7,48
80003eba:	10 9b       	mov	r11,r8
80003ebc:	fe 7c 18 00 	mov	r12,-59392
80003ec0:	f0 1f 00 39 	mcall	80003fa4 <vConsumer+0x240>
		sprintf(potentiometer_usart, "Potentiometer %d\n", pot_usart_write);
80003ec4:	ee f9 ff e0 	ld.w	r9,r7[-32]
80003ec8:	ee c8 00 3c 	sub	r8,r7,60
80003ecc:	1a d9       	st.w	--sp,r9
80003ece:	4b 7b       	lddpc	r11,80003fa8 <vConsumer+0x244>
80003ed0:	10 9c       	mov	r12,r8
80003ed2:	f0 1f 00 34 	mcall	80003fa0 <vConsumer+0x23c>
80003ed6:	2f fd       	sub	sp,-4
		usart_write_line(serialPORT_USART, potentiometer_usart);
80003ed8:	ee c8 00 3c 	sub	r8,r7,60
80003edc:	10 9b       	mov	r11,r8
80003ede:	fe 7c 18 00 	mov	r12,-59392
80003ee2:	f0 1f 00 31 	mcall	80003fa4 <vConsumer+0x240>
		sprintf(light_usart, "Light %d\n", light_usart_write);
80003ee6:	ee f9 ff dc 	ld.w	r9,r7[-36]
80003eea:	ee c8 00 48 	sub	r8,r7,72
80003eee:	1a d9       	st.w	--sp,r9
80003ef0:	4a fb       	lddpc	r11,80003fac <vConsumer+0x248>
80003ef2:	10 9c       	mov	r12,r8
80003ef4:	f0 1f 00 2b 	mcall	80003fa0 <vConsumer+0x23c>
80003ef8:	2f fd       	sub	sp,-4
		usart_write_line(serialPORT_USART, light_usart);
80003efa:	ee c8 00 48 	sub	r8,r7,72
80003efe:	10 9b       	mov	r11,r8
80003f00:	fe 7c 18 00 	mov	r12,-59392
80003f04:	f0 1f 00 28 	mcall	80003fa4 <vConsumer+0x240>
		dip204_set_cursor_position(15, 1);
80003f08:	30 1b       	mov	r11,1
80003f0a:	30 fc       	mov	r12,15
80003f0c:	f0 1f 00 16 	mcall	80003f64 <vConsumer+0x200>
		dip204_printf_string("%04d", temperature_received); //print value
80003f10:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003f14:	1a d8       	st.w	--sp,r8
80003f16:	4a 7c       	lddpc	r12,80003fb0 <vConsumer+0x24c>
80003f18:	f0 1f 00 27 	mcall	80003fb4 <vConsumer+0x250>
80003f1c:	2f fd       	sub	sp,-4
		dip204_set_cursor_position(15, 2);
80003f1e:	30 2b       	mov	r11,2
80003f20:	30 fc       	mov	r12,15
80003f22:	f0 1f 00 11 	mcall	80003f64 <vConsumer+0x200>
		dip204_printf_string("%04d", potentiometer_received); //print value
80003f26:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003f2a:	1a d8       	st.w	--sp,r8
80003f2c:	4a 1c       	lddpc	r12,80003fb0 <vConsumer+0x24c>
80003f2e:	f0 1f 00 22 	mcall	80003fb4 <vConsumer+0x250>
80003f32:	2f fd       	sub	sp,-4
		dip204_set_cursor_position(15, 3);
80003f34:	30 3b       	mov	r11,3
80003f36:	30 fc       	mov	r12,15
80003f38:	f0 1f 00 0b 	mcall	80003f64 <vConsumer+0x200>
		dip204_printf_string("%04d", light_received); //print value
80003f3c:	ee f8 ff e8 	ld.w	r8,r7[-24]
80003f40:	1a d8       	st.w	--sp,r8
80003f42:	49 cc       	lddpc	r12,80003fb0 <vConsumer+0x24c>
80003f44:	f0 1f 00 1c 	mcall	80003fb4 <vConsumer+0x250>
80003f48:	2f fd       	sub	sp,-4
		
		vTaskDelay(TASK_DELAY_MS(100));
80003f4a:	36 4c       	mov	r12,100
80003f4c:	f0 1f 00 1b 	mcall	80003fb8 <vConsumer+0x254>
	}
80003f50:	c4 9b       	rjmp	80003de2 <vConsumer+0x7e>
80003f52:	00 00       	add	r0,r0
80003f54:	80 00       	ld.sh	r0,r0[0x0]
80003f56:	3a bc       	mov	r12,-85
80003f58:	80 00       	ld.sh	r0,r0[0x0]
80003f5a:	3a cc       	mov	r12,-84
80003f5c:	80 00       	ld.sh	r0,r0[0x0]
80003f5e:	3a dc       	mov	r12,-83
80003f60:	80 00       	ld.sh	r0,r0[0x0]
80003f62:	2c a0       	sub	r0,-54
80003f64:	80 00       	ld.sh	r0,r0[0x0]
80003f66:	2c 18       	sub	r8,-63
80003f68:	80 00       	ld.sh	r0,r0[0x0]
80003f6a:	2e 1c       	sub	r12,-31
80003f6c:	80 00       	ld.sh	r0,r0[0x0]
80003f6e:	3a 9c       	mov	r12,-87
80003f70:	00 00       	add	r0,r0
80003f72:	07 d8       	ld.ub	r8,r3[0x5]
80003f74:	80 00       	ld.sh	r0,r0[0x0]
80003f76:	56 80       	stdsp	sp[0x1a0],r0
80003f78:	00 00       	add	r0,r0
80003f7a:	08 00       	add	r0,r4
80003f7c:	00 00       	add	r0,r0
80003f7e:	07 e0       	ld.ub	r0,r3[0x6]
80003f80:	80 00       	ld.sh	r0,r0[0x0]
80003f82:	55 18       	stdsp	sp[0x144],r8
80003f84:	00 00       	add	r0,r0
80003f86:	07 e8       	ld.ub	r8,r3[0x6]
80003f88:	00 00       	add	r0,r0
80003f8a:	07 f8       	ld.ub	r8,r3[0x7]
80003f8c:	00 00       	add	r0,r0
80003f8e:	08 04       	add	r4,r4
80003f90:	00 00       	add	r0,r0
80003f92:	08 08       	add	r8,r4
80003f94:	00 00       	add	r0,r0
80003f96:	07 ec       	ld.ub	r12,r3[0x6]
80003f98:	00 00       	add	r0,r0
80003f9a:	07 fc       	ld.ub	r12,r3[0x7]
80003f9c:	80 00       	ld.sh	r0,r0[0x0]
80003f9e:	3a e4       	mov	r4,-82
80003fa0:	80 00       	ld.sh	r0,r0[0x0]
80003fa2:	71 8c       	ld.w	r12,r8[0x60]
80003fa4:	80 00       	ld.sh	r0,r0[0x0]
80003fa6:	4b d0       	lddpc	r0,80004098 <main+0xdc>
80003fa8:	80 00       	ld.sh	r0,r0[0x0]
80003faa:	3a f4       	mov	r4,-81
80003fac:	80 00       	ld.sh	r0,r0[0x0]
80003fae:	3b 08       	mov	r8,-80
80003fb0:	80 00       	ld.sh	r0,r0[0x0]
80003fb2:	3b 14       	mov	r4,-79
80003fb4:	80 00       	ld.sh	r0,r0[0x0]
80003fb6:	2e 8c       	sub	r12,-24
80003fb8:	80 00       	ld.sh	r0,r0[0x0]
80003fba:	5c 8c       	casts.h	r12

80003fbc <main>:
}

int main(void)
{
80003fbc:	eb cd 40 80 	pushm	r7,lr
80003fc0:	1a 97       	mov	r7,sp
	initLED();
80003fc2:	f0 1f 00 57 	mcall	8000411c <main+0x160>
	init_usart();
80003fc6:	f0 1f 00 57 	mcall	80004120 <main+0x164>
	display_init();
80003fca:	f0 1f 00 57 	mcall	80004124 <main+0x168>
	dip204_clear_display();
80003fce:	f0 1f 00 57 	mcall	80004128 <main+0x16c>
	
	// Configure the ADC module and enable the potentiometer, temperature and light channel
	adc_configure(&AVR32_ADC);
80003fd2:	fe 7c 3c 00 	mov	r12,-50176
80003fd6:	f0 1f 00 56 	mcall	8000412c <main+0x170>
	adc_enable(&AVR32_ADC, ADC_POTENTIOMETER_CHANNEL);
80003fda:	30 1b       	mov	r11,1
80003fdc:	fe 7c 3c 00 	mov	r12,-50176
80003fe0:	f0 1f 00 54 	mcall	80004130 <main+0x174>
	adc_enable(&AVR32_ADC, ADC_TEMPERATURE_CHANNEL);
80003fe4:	30 0b       	mov	r11,0
80003fe6:	fe 7c 3c 00 	mov	r12,-50176
80003fea:	f0 1f 00 52 	mcall	80004130 <main+0x174>
	adc_enable(&AVR32_ADC, ADC_LIGHT_CHANNEL);
80003fee:	30 2b       	mov	r11,2
80003ff0:	fe 7c 3c 00 	mov	r12,-50176
80003ff4:	f0 1f 00 4f 	mcall	80004130 <main+0x174>
	
	vSemaphoreCreateBinary(xLCDSemaphore);	// Semaphore - Display
80003ff8:	30 0b       	mov	r11,0
80003ffa:	30 1c       	mov	r12,1
80003ffc:	f0 1f 00 4e 	mcall	80004134 <main+0x178>
80004000:	18 99       	mov	r9,r12
80004002:	4c e8       	lddpc	r8,80004138 <main+0x17c>
80004004:	91 09       	st.w	r8[0x0],r9
80004006:	4c d8       	lddpc	r8,80004138 <main+0x17c>
80004008:	70 08       	ld.w	r8,r8[0x0]
8000400a:	58 08       	cp.w	r8,0
8000400c:	c0 90       	breq	8000401e <main+0x62>
8000400e:	4c b8       	lddpc	r8,80004138 <main+0x17c>
80004010:	70 08       	ld.w	r8,r8[0x0]
80004012:	30 09       	mov	r9,0
80004014:	30 0a       	mov	r10,0
80004016:	30 0b       	mov	r11,0
80004018:	10 9c       	mov	r12,r8
8000401a:	f0 1f 00 49 	mcall	8000413c <main+0x180>
	
	xFillCountPotentiometer = xSemaphoreCreateCounting(BUFFER_SIZE, 0);
8000401e:	30 0b       	mov	r11,0
80004020:	30 1c       	mov	r12,1
80004022:	f0 1f 00 48 	mcall	80004140 <main+0x184>
80004026:	18 99       	mov	r9,r12
80004028:	4c 78       	lddpc	r8,80004144 <main+0x188>
8000402a:	91 09       	st.w	r8[0x0],r9
	xEmptyCountPotentiometer = xSemaphoreCreateCounting(BUFFER_SIZE, BUFFER_SIZE);
8000402c:	30 1b       	mov	r11,1
8000402e:	30 1c       	mov	r12,1
80004030:	f0 1f 00 44 	mcall	80004140 <main+0x184>
80004034:	18 99       	mov	r9,r12
80004036:	4c 58       	lddpc	r8,80004148 <main+0x18c>
80004038:	91 09       	st.w	r8[0x0],r9
	
	xFillCountTemperature = xSemaphoreCreateCounting(BUFFER_SIZE, 0);
8000403a:	30 0b       	mov	r11,0
8000403c:	30 1c       	mov	r12,1
8000403e:	f0 1f 00 41 	mcall	80004140 <main+0x184>
80004042:	18 99       	mov	r9,r12
80004044:	4c 28       	lddpc	r8,8000414c <main+0x190>
80004046:	91 09       	st.w	r8[0x0],r9
	xEmptyCountTemperature = xSemaphoreCreateCounting(BUFFER_SIZE, BUFFER_SIZE);
80004048:	30 1b       	mov	r11,1
8000404a:	30 1c       	mov	r12,1
8000404c:	f0 1f 00 3d 	mcall	80004140 <main+0x184>
80004050:	18 99       	mov	r9,r12
80004052:	4c 08       	lddpc	r8,80004150 <main+0x194>
80004054:	91 09       	st.w	r8[0x0],r9
	
	xFillCountLight = xSemaphoreCreateCounting(BUFFER_SIZE, 0);
80004056:	30 0b       	mov	r11,0
80004058:	30 1c       	mov	r12,1
8000405a:	f0 1f 00 3a 	mcall	80004140 <main+0x184>
8000405e:	18 99       	mov	r9,r12
80004060:	4b d8       	lddpc	r8,80004154 <main+0x198>
80004062:	91 09       	st.w	r8[0x0],r9
	xEmptyCountLight = xSemaphoreCreateCounting(BUFFER_SIZE, BUFFER_SIZE);
80004064:	30 1b       	mov	r11,1
80004066:	30 1c       	mov	r12,1
80004068:	f0 1f 00 36 	mcall	80004140 <main+0x184>
8000406c:	18 99       	mov	r9,r12
8000406e:	4b b8       	lddpc	r8,80004158 <main+0x19c>
80004070:	91 09       	st.w	r8[0x0],r9
	
	xQHandlePotentiometer = xQueueCreate(BUFFER_SIZE, sizeof(uint32_t*));
80004072:	30 4b       	mov	r11,4
80004074:	30 1c       	mov	r12,1
80004076:	f0 1f 00 30 	mcall	80004134 <main+0x178>
8000407a:	18 99       	mov	r9,r12
8000407c:	4b 88       	lddpc	r8,8000415c <main+0x1a0>
8000407e:	91 09       	st.w	r8[0x0],r9
	xQHandleTemperature = xQueueCreate(BUFFER_SIZE, sizeof(uint32_t*));
80004080:	30 4b       	mov	r11,4
80004082:	30 1c       	mov	r12,1
80004084:	f0 1f 00 2c 	mcall	80004134 <main+0x178>
80004088:	18 99       	mov	r9,r12
8000408a:	4b 68       	lddpc	r8,80004160 <main+0x1a4>
8000408c:	91 09       	st.w	r8[0x0],r9
	xQHandleLight = xQueueCreate(BUFFER_SIZE, sizeof(uint32_t*));
8000408e:	30 4b       	mov	r11,4
80004090:	30 1c       	mov	r12,1
80004092:	f0 1f 00 29 	mcall	80004134 <main+0x178>
80004096:	18 99       	mov	r9,r12
80004098:	4b 38       	lddpc	r8,80004164 <main+0x1a8>
8000409a:	91 09       	st.w	r8[0x0],r9
	
	xTaskCreate(	vConsumer, "vConsumer", (( unsigned portSHORT ) 2000), NULL, 1, NULL);	
8000409c:	4b 3b       	lddpc	r11,80004168 <main+0x1ac>
8000409e:	30 08       	mov	r8,0
800040a0:	1a d8       	st.w	--sp,r8
800040a2:	30 08       	mov	r8,0
800040a4:	1a d8       	st.w	--sp,r8
800040a6:	30 08       	mov	r8,0
800040a8:	1a d8       	st.w	--sp,r8
800040aa:	30 18       	mov	r8,1
800040ac:	30 09       	mov	r9,0
800040ae:	e0 6a 07 d0 	mov	r10,2000
800040b2:	4a fc       	lddpc	r12,8000416c <main+0x1b0>
800040b4:	f0 1f 00 2f 	mcall	80004170 <main+0x1b4>
800040b8:	2f dd       	sub	sp,-12
	xTaskCreate(	vTemperature, "vTemperature", (( unsigned portSHORT ) 2000), NULL, 1,NULL);
800040ba:	4a fb       	lddpc	r11,80004174 <main+0x1b8>
800040bc:	30 08       	mov	r8,0
800040be:	1a d8       	st.w	--sp,r8
800040c0:	30 08       	mov	r8,0
800040c2:	1a d8       	st.w	--sp,r8
800040c4:	30 08       	mov	r8,0
800040c6:	1a d8       	st.w	--sp,r8
800040c8:	30 18       	mov	r8,1
800040ca:	30 09       	mov	r9,0
800040cc:	e0 6a 07 d0 	mov	r10,2000
800040d0:	4a ac       	lddpc	r12,80004178 <main+0x1bc>
800040d2:	f0 1f 00 28 	mcall	80004170 <main+0x1b4>
800040d6:	2f dd       	sub	sp,-12
	xTaskCreate(	vPotentiometer, "vPotentiometer", (( unsigned portSHORT ) 2000), NULL, 1, NULL);
800040d8:	4a 9b       	lddpc	r11,8000417c <main+0x1c0>
800040da:	30 08       	mov	r8,0
800040dc:	1a d8       	st.w	--sp,r8
800040de:	30 08       	mov	r8,0
800040e0:	1a d8       	st.w	--sp,r8
800040e2:	30 08       	mov	r8,0
800040e4:	1a d8       	st.w	--sp,r8
800040e6:	30 18       	mov	r8,1
800040e8:	30 09       	mov	r9,0
800040ea:	e0 6a 07 d0 	mov	r10,2000
800040ee:	4a 5c       	lddpc	r12,80004180 <main+0x1c4>
800040f0:	f0 1f 00 20 	mcall	80004170 <main+0x1b4>
800040f4:	2f dd       	sub	sp,-12
	xTaskCreate(	vLight, "vLight", (( unsigned portSHORT ) 2000), NULL, 1, NULL);
800040f6:	4a 4b       	lddpc	r11,80004184 <main+0x1c8>
800040f8:	30 08       	mov	r8,0
800040fa:	1a d8       	st.w	--sp,r8
800040fc:	30 08       	mov	r8,0
800040fe:	1a d8       	st.w	--sp,r8
80004100:	30 08       	mov	r8,0
80004102:	1a d8       	st.w	--sp,r8
80004104:	30 18       	mov	r8,1
80004106:	30 09       	mov	r9,0
80004108:	e0 6a 07 d0 	mov	r10,2000
8000410c:	49 fc       	lddpc	r12,80004188 <main+0x1cc>
8000410e:	f0 1f 00 19 	mcall	80004170 <main+0x1b4>
80004112:	2f dd       	sub	sp,-12
	
	vTaskStartScheduler();		// Starts the schedueling
80004114:	f0 1f 00 1e 	mcall	8000418c <main+0x1d0>

	
	for( ;; )
	{
		
	}
80004118:	c0 08       	rjmp	80004118 <main+0x15c>
8000411a:	00 00       	add	r0,r0
8000411c:	80 00       	ld.sh	r0,r0[0x0]
8000411e:	3a 20       	mov	r0,-94
80004120:	80 00       	ld.sh	r0,r0[0x0]
80004122:	3b 50       	mov	r0,-75
80004124:	80 00       	ld.sh	r0,r0[0x0]
80004126:	37 f8       	mov	r8,127
80004128:	80 00       	ld.sh	r0,r0[0x0]
8000412a:	2c a0       	sub	r0,-54
8000412c:	80 00       	ld.sh	r0,r0[0x0]
8000412e:	30 a0       	mov	r0,10
80004130:	80 00       	ld.sh	r0,r0[0x0]
80004132:	30 f0       	mov	r0,15
80004134:	80 00       	ld.sh	r0,r0[0x0]
80004136:	53 bc       	stdsp	sp[0xec],r12
80004138:	00 00       	add	r0,r0
8000413a:	07 dc       	ld.ub	r12,r3[0x5]
8000413c:	80 00       	ld.sh	r0,r0[0x0]
8000413e:	55 18       	stdsp	sp[0x144],r8
80004140:	80 00       	ld.sh	r0,r0[0x0]
80004142:	54 d4       	stdsp	sp[0x134],r4
80004144:	00 00       	add	r0,r0
80004146:	07 e8       	ld.ub	r8,r3[0x6]
80004148:	00 00       	add	r0,r0
8000414a:	08 04       	add	r4,r4
8000414c:	00 00       	add	r0,r0
8000414e:	07 d8       	ld.ub	r8,r3[0x5]
80004150:	00 00       	add	r0,r0
80004152:	07 e0       	ld.ub	r0,r3[0x6]
80004154:	00 00       	add	r0,r0
80004156:	08 08       	add	r8,r4
80004158:	00 00       	add	r0,r0
8000415a:	07 fc       	ld.ub	r12,r3[0x7]
8000415c:	00 00       	add	r0,r0
8000415e:	07 f8       	ld.ub	r8,r3[0x7]
80004160:	00 00       	add	r0,r0
80004162:	08 00       	add	r0,r4
80004164:	00 00       	add	r0,r0
80004166:	07 ec       	ld.ub	r12,r3[0x6]
80004168:	80 00       	ld.sh	r0,r0[0x0]
8000416a:	3b 1c       	mov	r12,-79
8000416c:	80 00       	ld.sh	r0,r0[0x0]
8000416e:	3d 64       	mov	r4,-42
80004170:	80 00       	ld.sh	r0,r0[0x0]
80004172:	5a c4       	cp.w	r4,-20
80004174:	80 00       	ld.sh	r0,r0[0x0]
80004176:	3b 28       	mov	r8,-78
80004178:	80 00       	ld.sh	r0,r0[0x0]
8000417a:	3b b8       	mov	r8,-69
8000417c:	80 00       	ld.sh	r0,r0[0x0]
8000417e:	3b 38       	mov	r8,-77
80004180:	80 00       	ld.sh	r0,r0[0x0]
80004182:	3c 44       	mov	r4,-60
80004184:	80 00       	ld.sh	r0,r0[0x0]
80004186:	3b 48       	mov	r8,-76
80004188:	80 00       	ld.sh	r0,r0[0x0]
8000418a:	3c d8       	mov	r8,-51
8000418c:	80 00       	ld.sh	r0,r0[0x0]
8000418e:	5d 00       	ror	r0

80004190 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80004190:	eb cd 40 80 	pushm	r7,lr
80004194:	1a 97       	mov	r7,sp
80004196:	20 4d       	sub	sp,16
80004198:	ef 4c ff f4 	st.w	r7[-12],r12
8000419c:	ef 4b ff f0 	st.w	r7[-16],r11
	uint32_t status = GPIO_SUCCESS;
800041a0:	30 08       	mov	r8,0
800041a2:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t i;

	for (i = 0; i < size; i++) {
800041a6:	30 08       	mov	r8,0
800041a8:	ef 48 ff fc 	st.w	r7[-4],r8
800041ac:	c1 c8       	rjmp	800041e4 <gpio_enable_module+0x54>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800041ae:	ee f8 ff f4 	ld.w	r8,r7[-12]
800041b2:	70 19       	ld.w	r9,r8[0x4]
800041b4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800041b8:	70 08       	ld.w	r8,r8[0x0]
800041ba:	12 9b       	mov	r11,r9
800041bc:	10 9c       	mov	r12,r8
800041be:	f0 1f 00 10 	mcall	800041fc <gpio_enable_module+0x6c>
800041c2:	18 98       	mov	r8,r12
800041c4:	ee f9 ff f8 	ld.w	r9,r7[-8]
800041c8:	f3 e8 10 08 	or	r8,r9,r8
800041cc:	ef 48 ff f8 	st.w	r7[-8],r8
		gpiomap++;
800041d0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800041d4:	2f 88       	sub	r8,-8
800041d6:	ef 48 ff f4 	st.w	r7[-12],r8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800041da:	ee f8 ff fc 	ld.w	r8,r7[-4]
800041de:	2f f8       	sub	r8,-1
800041e0:	ef 48 ff fc 	st.w	r7[-4],r8
800041e4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800041e8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800041ec:	10 39       	cp.w	r9,r8
800041ee:	ce 03       	brcs	800041ae <gpio_enable_module+0x1e>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
800041f0:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800041f4:	10 9c       	mov	r12,r8
800041f6:	2f cd       	sub	sp,-16
800041f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800041fc:	80 00       	ld.sh	r0,r0[0x0]
800041fe:	42 00       	lddsp	r0,sp[0x80]

80004200 <gpio_enable_module_pin>:
 * \param function The pin function.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
80004200:	eb cd 40 80 	pushm	r7,lr
80004204:	1a 97       	mov	r7,sp
80004206:	20 3d       	sub	sp,12
80004208:	ef 4c ff f8 	st.w	r7[-8],r12
8000420c:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004210:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004214:	a5 98       	lsr	r8,0x5
80004216:	a9 68       	lsl	r8,0x8
80004218:	e0 28 f0 00 	sub	r8,61440
8000421c:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Enable the correct function. */
	switch (function) {
80004220:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004224:	58 18       	cp.w	r8,1
80004226:	c1 e0       	breq	80004262 <gpio_enable_module_pin+0x62>
80004228:	c0 63       	brcs	80004234 <gpio_enable_module_pin+0x34>
8000422a:	58 28       	cp.w	r8,2
8000422c:	c3 20       	breq	80004290 <gpio_enable_module_pin+0x90>
8000422e:	58 38       	cp.w	r8,3
80004230:	c4 70       	breq	800042be <gpio_enable_module_pin+0xbe>
80004232:	c5 d8       	rjmp	800042ec <gpio_enable_module_pin+0xec>
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004234:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004238:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000423c:	30 19       	mov	r9,1
8000423e:	f2 08 09 48 	lsl	r8,r9,r8
80004242:	10 99       	mov	r9,r8
80004244:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004248:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000424a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000424e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004252:	30 19       	mov	r9,1
80004254:	f2 08 09 48 	lsl	r8,r9,r8
80004258:	10 99       	mov	r9,r8
8000425a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000425e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004260:	c4 88       	rjmp	800042f0 <gpio_enable_module_pin+0xf0>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004262:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004266:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000426a:	30 19       	mov	r9,1
8000426c:	f2 08 09 48 	lsl	r8,r9,r8
80004270:	10 99       	mov	r9,r8
80004272:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004276:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004278:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000427c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004280:	30 19       	mov	r9,1
80004282:	f2 08 09 48 	lsl	r8,r9,r8
80004286:	10 99       	mov	r9,r8
80004288:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000428c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000428e:	c3 18       	rjmp	800042f0 <gpio_enable_module_pin+0xf0>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004290:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004294:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004298:	30 19       	mov	r9,1
8000429a:	f2 08 09 48 	lsl	r8,r9,r8
8000429e:	10 99       	mov	r9,r8
800042a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042a4:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800042a6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042aa:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800042ae:	30 19       	mov	r9,1
800042b0:	f2 08 09 48 	lsl	r8,r9,r8
800042b4:	10 99       	mov	r9,r8
800042b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042ba:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800042bc:	c1 a8       	rjmp	800042f0 <gpio_enable_module_pin+0xf0>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800042be:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042c2:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800042c6:	30 19       	mov	r9,1
800042c8:	f2 08 09 48 	lsl	r8,r9,r8
800042cc:	10 99       	mov	r9,r8
800042ce:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042d2:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800042d4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042d8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800042dc:	30 19       	mov	r9,1
800042de:	f2 08 09 48 	lsl	r8,r9,r8
800042e2:	10 99       	mov	r9,r8
800042e4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042e8:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800042ea:	c0 38       	rjmp	800042f0 <gpio_enable_module_pin+0xf0>
		gpio_port->pmr2s = 1 << (pin & 0x1F);
		break;
#endif

	default:
		return GPIO_INVALID_ARGUMENT;
800042ec:	30 18       	mov	r8,1
800042ee:	c0 d8       	rjmp	80004308 <gpio_enable_module_pin+0x108>
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800042f0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042f4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800042f8:	30 19       	mov	r9,1
800042fa:	f2 08 09 48 	lsl	r8,r9,r8
800042fe:	10 99       	mov	r9,r8
80004300:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004304:	91 29       	st.w	r8[0x8],r9

	return GPIO_SUCCESS;
80004306:	30 08       	mov	r8,0
}
80004308:	10 9c       	mov	r12,r8
8000430a:	2f dd       	sub	sp,-12
8000430c:	e3 cd 80 80 	ldm	sp++,r7,pc

80004310 <gpio_set_gpio_pin>:
/** \brief Drives a GPIO pin to 1.
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
80004310:	eb cd 40 80 	pushm	r7,lr
80004314:	1a 97       	mov	r7,sp
80004316:	20 2d       	sub	sp,8
80004318:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000431c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004320:	a5 98       	lsr	r8,0x5
80004322:	a9 68       	lsl	r8,0x8
80004324:	e0 28 f0 00 	sub	r8,61440
80004328:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000432c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004330:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004334:	30 19       	mov	r9,1
80004336:	f2 08 09 48 	lsl	r8,r9,r8
8000433a:	10 99       	mov	r9,r8
8000433c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004340:	f1 49 00 54 	st.w	r8[84],r9
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80004344:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004348:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000434c:	30 19       	mov	r9,1
8000434e:	f2 08 09 48 	lsl	r8,r9,r8
80004352:	10 99       	mov	r9,r8
80004354:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004358:	f1 49 00 44 	st.w	r8[68],r9
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000435c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004360:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004364:	30 19       	mov	r9,1
80004366:	f2 08 09 48 	lsl	r8,r9,r8
8000436a:	10 99       	mov	r9,r8
8000436c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004370:	91 19       	st.w	r8[0x4],r9
}
80004372:	2f ed       	sub	sp,-8
80004374:	e3 cd 80 80 	ldm	sp++,r7,pc

80004378 <gpio_clr_gpio_pin>:
/** \brief Drives a GPIO pin to 0.
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
80004378:	eb cd 40 80 	pushm	r7,lr
8000437c:	1a 97       	mov	r7,sp
8000437e:	20 2d       	sub	sp,8
80004380:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004384:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004388:	a5 98       	lsr	r8,0x5
8000438a:	a9 68       	lsl	r8,0x8
8000438c:	e0 28 f0 00 	sub	r8,61440
80004390:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80004394:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004398:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000439c:	30 19       	mov	r9,1
8000439e:	f2 08 09 48 	lsl	r8,r9,r8
800043a2:	10 99       	mov	r9,r8
800043a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043a8:	f1 49 00 58 	st.w	r8[88],r9
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800043ac:	ee f8 ff f8 	ld.w	r8,r7[-8]
800043b0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800043b4:	30 19       	mov	r9,1
800043b6:	f2 08 09 48 	lsl	r8,r9,r8
800043ba:	10 99       	mov	r9,r8
800043bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043c0:	f1 49 00 44 	st.w	r8[68],r9
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800043c4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800043c8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800043cc:	30 19       	mov	r9,1
800043ce:	f2 08 09 48 	lsl	r8,r9,r8
800043d2:	10 99       	mov	r9,r8
800043d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043d8:	91 19       	st.w	r8[0x4],r9
}
800043da:	2f ed       	sub	sp,-8
800043dc:	e3 cd 80 80 	ldm	sp++,r7,pc

800043e0 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800043e0:	eb cd 40 80 	pushm	r7,lr
800043e4:	1a 97       	mov	r7,sp
	// Catch unregistered interrupts.
	while (true);
800043e6:	c0 08       	rjmp	800043e6 <_unhandled_interrupt+0x6>

800043e8 <_get_interrupt_handler>:
 *
 * \return Interrupt handler to execute.
 */
__int_handler _get_interrupt_handler(uint32_t int_level);
__int_handler _get_interrupt_handler(uint32_t int_level)
{
800043e8:	eb cd 40 80 	pushm	r7,lr
800043ec:	1a 97       	mov	r7,sp
800043ee:	20 3d       	sub	sp,12
800043f0:	ef 4c ff f4 	st.w	r7[-12],r12
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800043f4:	fe 78 08 00 	mov	r8,-63488
800043f8:	ee f9 ff f4 	ld.w	r9,r7[-12]
800043fc:	f2 09 11 03 	rsub	r9,r9,3
80004400:	28 09       	sub	r9,-128
80004402:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80004406:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t int_req = AVR32_INTC.irr[int_grp];
8000440a:	fe 78 08 00 	mov	r8,-63488
8000440e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004412:	2c 09       	sub	r9,-64
80004414:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80004418:	ef 48 ff fc 	st.w	r7[-4],r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000441c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004420:	58 08       	cp.w	r8,0
80004422:	c1 30       	breq	80004448 <_get_interrupt_handler+0x60>
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004424:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004428:	48 b8       	lddpc	r8,80004454 <_get_interrupt_handler+0x6c>
8000442a:	a1 79       	lsl	r9,0x1
8000442c:	2f f9       	sub	r9,-1
8000442e:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80004432:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004436:	f0 08 12 00 	clz	r8,r8
8000443a:	f0 08 11 1f 	rsub	r8,r8,31
			- clz(int_req) - 1]
8000443e:	a3 68       	lsl	r8,0x2
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004440:	f2 08 00 08 	add	r8,r9,r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004444:	70 08       	ld.w	r8,r8[0x0]
80004446:	c0 28       	rjmp	8000444a <_get_interrupt_handler+0x62>
80004448:	30 08       	mov	r8,0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000444a:	10 9c       	mov	r12,r8
8000444c:	2f dd       	sub	sp,-12
8000444e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004452:	00 00       	add	r0,r0
80004454:	80 00       	ld.sh	r0,r0[0x0]
80004456:	c4 74       	brge	800044e4 <INTC_init_interrupts+0x78>

80004458 <INTC_init_evba>:
 * \internal
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
80004458:	eb cd 40 80 	pushm	r7,lr
8000445c:	1a 97       	mov	r7,sp
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000445e:	48 38       	lddpc	r8,80004468 <INTC_init_evba+0x10>
80004460:	e3 b8 00 01 	mtsr	0x4,r8
}
80004464:	e3 cd 80 80 	ldm	sp++,r7,pc
80004468:	80 00       	ld.sh	r0,r0[0x0]
8000446a:	c2 00       	breq	800044aa <INTC_init_interrupts+0x3e>

8000446c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
8000446c:	eb cd 40 80 	pushm	r7,lr
80004470:	1a 97       	mov	r7,sp
80004472:	20 2d       	sub	sp,8
	uint32_t int_grp, int_req;

	INTC_init_evba();
80004474:	f0 1f 00 1f 	mcall	800044f0 <INTC_init_interrupts+0x84>

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004478:	30 08       	mov	r8,0
8000447a:	ef 48 ff f8 	st.w	r7[-8],r8
8000447e:	c3 18       	rjmp	800044e0 <INTC_init_interrupts+0x74>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004480:	30 08       	mov	r8,0
80004482:	ef 48 ff fc 	st.w	r7[-4],r8
80004486:	c1 48       	rjmp	800044ae <INTC_init_interrupts+0x42>
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004488:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000448c:	49 a8       	lddpc	r8,800044f4 <INTC_init_interrupts+0x88>
8000448e:	a1 79       	lsl	r9,0x1
80004490:	2f f9       	sub	r9,-1
80004492:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80004496:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000449a:	a3 68       	lsl	r8,0x2
8000449c:	f2 08 00 08 	add	r8,r9,r8
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800044a0:	49 69       	lddpc	r9,800044f8 <INTC_init_interrupts+0x8c>
800044a2:	91 09       	st.w	r8[0x0],r9
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800044a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800044a8:	2f f8       	sub	r8,-1
800044aa:	ef 48 ff fc 	st.w	r7[-4],r8
	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
800044ae:	ee f9 ff f8 	ld.w	r9,r7[-8]
800044b2:	49 18       	lddpc	r8,800044f4 <INTC_init_interrupts+0x88>
800044b4:	f0 09 03 39 	ld.w	r9,r8[r9<<0x3]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800044b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800044bc:	10 39       	cp.w	r9,r8
800044be:	fe 9b ff e5 	brhi	80004488 <INTC_init_interrupts+0x1c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800044c2:	fe 78 08 00 	mov	r8,-63488
800044c6:	ee f9 ff f8 	ld.w	r9,r7[-8]
800044ca:	48 db       	lddpc	r11,800044fc <INTC_init_interrupts+0x90>
800044cc:	48 da       	lddpc	r10,80004500 <INTC_init_interrupts+0x94>
800044ce:	f6 0a 01 0a 	sub	r10,r11,r10
800044d2:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800044d6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044da:	2f f8       	sub	r8,-1
800044dc:	ef 48 ff f8 	st.w	r7[-8],r8
800044e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044e4:	59 38       	cp.w	r8,19
800044e6:	fe 98 ff cd 	brls	80004480 <INTC_init_interrupts+0x14>
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	}
}
800044ea:	2f ed       	sub	sp,-8
800044ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800044f0:	80 00       	ld.sh	r0,r0[0x0]
800044f2:	44 58       	lddsp	r8,sp[0x114]
800044f4:	80 00       	ld.sh	r0,r0[0x0]
800044f6:	c4 74       	brge	80004584 <INTC_register_interrupt+0x80>
800044f8:	80 00       	ld.sh	r0,r0[0x0]
800044fa:	43 e0       	lddsp	r0,sp[0xf8]
800044fc:	80 00       	ld.sh	r0,r0[0x0]
800044fe:	c3 04       	brge	8000455e <INTC_register_interrupt+0x5a>
80004500:	80 00       	ld.sh	r0,r0[0x0]
80004502:	c2 00       	breq	80004542 <INTC_register_interrupt+0x3e>

80004504 <INTC_register_interrupt>:
 *          be effective.
 *
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
80004504:	eb cd 40 80 	pushm	r7,lr
80004508:	1a 97       	mov	r7,sp
8000450a:	20 4d       	sub	sp,16
8000450c:	ef 4c ff f8 	st.w	r7[-8],r12
80004510:	ef 4b ff f4 	st.w	r7[-12],r11
80004514:	ef 4a ff f0 	st.w	r7[-16],r10
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004518:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000451c:	a5 98       	lsr	r8,0x5
8000451e:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004522:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004526:	4a 78       	lddpc	r8,800045c0 <INTC_register_interrupt+0xbc>
80004528:	a1 79       	lsl	r9,0x1
8000452a:	2f f9       	sub	r9,-1
8000452c:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80004530:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004534:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004538:	a3 68       	lsl	r8,0x2
8000453a:	f2 08 00 08 	add	r8,r9,r8
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000453e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004542:	91 09       	st.w	r8[0x0],r9
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004544:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004548:	58 08       	cp.w	r8,0
8000454a:	c0 c1       	brne	80004562 <INTC_register_interrupt+0x5e>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000454c:	fe 78 08 00 	mov	r8,-63488
80004550:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004554:	49 cb       	lddpc	r11,800045c4 <INTC_register_interrupt+0xc0>
80004556:	49 da       	lddpc	r10,800045c8 <INTC_register_interrupt+0xc4>
80004558:	f6 0a 01 0a 	sub	r10,r11,r10
8000455c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004560:	c2 d8       	rjmp	800045ba <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT1) {
80004562:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004566:	58 18       	cp.w	r8,1
80004568:	c0 d1       	brne	80004582 <INTC_register_interrupt+0x7e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000456a:	fe 78 08 00 	mov	r8,-63488
8000456e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004572:	49 7b       	lddpc	r11,800045cc <INTC_register_interrupt+0xc8>
80004574:	49 5a       	lddpc	r10,800045c8 <INTC_register_interrupt+0xc4>
80004576:	f6 0a 01 0a 	sub	r10,r11,r10
8000457a:	bf aa       	sbr	r10,0x1e
8000457c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004580:	c1 d8       	rjmp	800045ba <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT2) {
80004582:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004586:	58 28       	cp.w	r8,2
80004588:	c0 d1       	brne	800045a2 <INTC_register_interrupt+0x9e>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000458a:	fe 78 08 00 	mov	r8,-63488
8000458e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004592:	49 0b       	lddpc	r11,800045d0 <INTC_register_interrupt+0xcc>
80004594:	48 da       	lddpc	r10,800045c8 <INTC_register_interrupt+0xc4>
80004596:	f6 0a 01 0a 	sub	r10,r11,r10
8000459a:	bf ba       	sbr	r10,0x1f
8000459c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
800045a0:	c0 d8       	rjmp	800045ba <INTC_register_interrupt+0xb6>
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800045a2:	fe 78 08 00 	mov	r8,-63488
800045a6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800045aa:	48 bb       	lddpc	r11,800045d4 <INTC_register_interrupt+0xd0>
800045ac:	48 7a       	lddpc	r10,800045c8 <INTC_register_interrupt+0xc4>
800045ae:	f6 0a 01 0a 	sub	r10,r11,r10
800045b2:	ea 1a c0 00 	orh	r10,0xc000
800045b6:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	}
}
800045ba:	2f cd       	sub	sp,-16
800045bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800045c0:	80 00       	ld.sh	r0,r0[0x0]
800045c2:	c4 74       	brge	80004650 <pm_enable_osc0_crystal+0x2c>
800045c4:	80 00       	ld.sh	r0,r0[0x0]
800045c6:	c3 04       	brge	80004626 <pm_enable_osc0_crystal+0x2>
800045c8:	80 00       	ld.sh	r0,r0[0x0]
800045ca:	c2 00       	breq	8000460a <pm_set_osc0_mode+0x32>
800045cc:	80 00       	ld.sh	r0,r0[0x0]
800045ce:	c3 12       	brcc	80004630 <pm_enable_osc0_crystal+0xc>
800045d0:	80 00       	ld.sh	r0,r0[0x0]
800045d2:	c3 20       	breq	80004636 <pm_enable_osc0_crystal+0x12>
800045d4:	80 00       	ld.sh	r0,r0[0x0]
800045d6:	c3 2e       	rcall	8000423a <gpio_enable_module_pin+0x3a>

800045d8 <pm_set_osc0_mode>:
 *
 * \param pm Base address of the Power Manager (i.e. &AVR32_PM).
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
800045d8:	eb cd 40 80 	pushm	r7,lr
800045dc:	1a 97       	mov	r7,sp
800045de:	20 3d       	sub	sp,12
800045e0:	ef 4c ff f8 	st.w	r7[-8],r12
800045e4:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800045e8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045ec:	70 a8       	ld.w	r8,r8[0x28]
800045ee:	30 09       	mov	r9,0
800045f0:	ef 49 ff fc 	st.w	r7[-4],r9
800045f4:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800045f8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800045fc:	5c 58       	castu.b	r8
800045fe:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004602:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80004606:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000460a:	f1 d9 d0 03 	bfins	r8,r9,0x0,0x3
8000460e:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80004612:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004616:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000461a:	91 a9       	st.w	r8[0x28],r9
}
8000461c:	2f dd       	sub	sp,-12
8000461e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004622:	d7 03       	nop

80004624 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80004624:	eb cd 40 80 	pushm	r7,lr
80004628:	1a 97       	mov	r7,sp
8000462a:	20 2d       	sub	sp,8
8000462c:	ef 4c ff fc 	st.w	r7[-4],r12
80004630:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80004634:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004638:	ec 58 bb 9f 	cp.w	r8,899999
8000463c:	e0 88 00 1a 	brls	80004670 <pm_enable_osc0_crystal+0x4c>
80004640:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004644:	e0 69 c6 bf 	mov	r9,50879
80004648:	ea 19 00 2d 	orh	r9,0x2d
8000464c:	12 38       	cp.w	r8,r9
8000464e:	e0 88 00 0f 	brls	8000466c <pm_enable_osc0_crystal+0x48>
80004652:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004656:	e0 69 11 ff 	mov	r9,4607
8000465a:	ea 19 00 7a 	orh	r9,0x7a
8000465e:	12 38       	cp.w	r8,r9
80004660:	e0 8b 00 04 	brhi	80004668 <pm_enable_osc0_crystal+0x44>
80004664:	30 68       	mov	r8,6
80004666:	c0 28       	rjmp	8000466a <pm_enable_osc0_crystal+0x46>
80004668:	30 78       	mov	r8,7
8000466a:	c0 28       	rjmp	8000466e <pm_enable_osc0_crystal+0x4a>
8000466c:	30 58       	mov	r8,5
8000466e:	c0 28       	rjmp	80004672 <pm_enable_osc0_crystal+0x4e>
80004670:	30 48       	mov	r8,4
80004672:	10 9b       	mov	r11,r8
80004674:	ee fc ff fc 	ld.w	r12,r7[-4]
80004678:	f0 1f 00 03 	mcall	80004684 <pm_enable_osc0_crystal+0x60>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000467c:	2f ed       	sub	sp,-8
8000467e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004682:	00 00       	add	r0,r0
80004684:	80 00       	ld.sh	r0,r0[0x0]
80004686:	45 d8       	lddsp	r8,sp[0x174]

80004688 <pm_enable_clk0>:


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80004688:	eb cd 40 80 	pushm	r7,lr
8000468c:	1a 97       	mov	r7,sp
8000468e:	20 2d       	sub	sp,8
80004690:	ef 4c ff fc 	st.w	r7[-4],r12
80004694:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_enable_clk0_no_wait(pm, startup);
80004698:	ee fb ff f8 	ld.w	r11,r7[-8]
8000469c:	ee fc ff fc 	ld.w	r12,r7[-4]
800046a0:	f0 1f 00 05 	mcall	800046b4 <pm_enable_clk0+0x2c>
  pm_wait_for_clk0_ready(pm);
800046a4:	ee fc ff fc 	ld.w	r12,r7[-4]
800046a8:	f0 1f 00 04 	mcall	800046b8 <pm_enable_clk0+0x30>
}
800046ac:	2f ed       	sub	sp,-8
800046ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800046b2:	00 00       	add	r0,r0
800046b4:	80 00       	ld.sh	r0,r0[0x0]
800046b6:	46 bc       	lddsp	r12,sp[0x1ac]
800046b8:	80 00       	ld.sh	r0,r0[0x0]
800046ba:	47 16       	lddsp	r6,sp[0x1c4]

800046bc <pm_enable_clk0_no_wait>:
  pm->mcctrl &= ~AVR32_PM_MCCTRL_OSC0EN_MASK;
}


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
800046bc:	eb cd 40 80 	pushm	r7,lr
800046c0:	1a 97       	mov	r7,sp
800046c2:	20 3d       	sub	sp,12
800046c4:	ef 4c ff f8 	st.w	r7[-8],r12
800046c8:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800046cc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046d0:	70 a8       	ld.w	r8,r8[0x28]
800046d2:	30 09       	mov	r9,0
800046d4:	ef 49 ff fc 	st.w	r7[-4],r9
800046d8:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800046dc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800046e0:	5c 58       	castu.b	r8
800046e2:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800046e6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800046ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046ee:	f1 d9 d1 03 	bfins	r8,r9,0x8,0x3
800046f2:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800046f6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800046fa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046fe:	91 a9       	st.w	r8[0x28],r9

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80004700:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004704:	70 08       	ld.w	r8,r8[0x0]
80004706:	10 99       	mov	r9,r8
80004708:	a3 a9       	sbr	r9,0x2
8000470a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000470e:	91 09       	st.w	r8[0x0],r9
}
80004710:	2f dd       	sub	sp,-12
80004712:	e3 cd 80 80 	ldm	sp++,r7,pc

80004716 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
80004716:	eb cd 40 80 	pushm	r7,lr
8000471a:	1a 97       	mov	r7,sp
8000471c:	20 1d       	sub	sp,4
8000471e:	ef 4c ff fc 	st.w	r7[-4],r12
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004722:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004726:	71 58       	ld.w	r8,r8[0x54]
80004728:	e2 18 00 80 	andl	r8,0x80,COH
8000472c:	cf b0       	breq	80004722 <pm_wait_for_clk0_ready+0xc>
}
8000472e:	2f fd       	sub	sp,-4
80004730:	e3 cd 80 80 	ldm	sp++,r7,pc

80004734 <pm_switch_to_clock>:
  return u_avr32_pm_mcctrl.MCCTRL.mcsel;
}


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
80004734:	eb cd 40 80 	pushm	r7,lr
80004738:	1a 97       	mov	r7,sp
8000473a:	20 3d       	sub	sp,12
8000473c:	ef 4c ff f8 	st.w	r7[-8],r12
80004740:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80004744:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004748:	70 08       	ld.w	r8,r8[0x0]
8000474a:	30 09       	mov	r9,0
8000474c:	ef 49 ff fc 	st.w	r7[-4],r9
80004750:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80004754:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004758:	5c 58       	castu.b	r8
8000475a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000475e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80004762:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004766:	f1 d9 d0 02 	bfins	r8,r9,0x0,0x2
8000476a:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000476e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004772:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004776:	91 09       	st.w	r8[0x0],r9
}
80004778:	2f dd       	sub	sp,-12
8000477a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000477e:	d7 03       	nop

80004780 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80004780:	eb cd 40 80 	pushm	r7,lr
80004784:	1a 97       	mov	r7,sp
80004786:	20 3d       	sub	sp,12
80004788:	ef 4c ff fc 	st.w	r7[-4],r12
8000478c:	ef 4b ff f8 	st.w	r7[-8],r11
80004790:	ef 4a ff f4 	st.w	r7[-12],r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80004794:	ee fb ff f8 	ld.w	r11,r7[-8]
80004798:	ee fc ff fc 	ld.w	r12,r7[-4]
8000479c:	f0 1f 00 08 	mcall	800047bc <pm_switch_to_osc0+0x3c>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800047a0:	ee fb ff f4 	ld.w	r11,r7[-12]
800047a4:	ee fc ff fc 	ld.w	r12,r7[-4]
800047a8:	f0 1f 00 06 	mcall	800047c0 <pm_switch_to_osc0+0x40>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800047ac:	30 1b       	mov	r11,1
800047ae:	ee fc ff fc 	ld.w	r12,r7[-4]
800047b2:	f0 1f 00 05 	mcall	800047c4 <pm_switch_to_osc0+0x44>
}
800047b6:	2f dd       	sub	sp,-12
800047b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800047bc:	80 00       	ld.sh	r0,r0[0x0]
800047be:	46 24       	lddsp	r4,sp[0x188]
800047c0:	80 00       	ld.sh	r0,r0[0x0]
800047c2:	46 88       	lddsp	r8,sp[0x1a0]
800047c4:	80 00       	ld.sh	r0,r0[0x0]
800047c6:	47 34       	lddsp	r4,sp[0x1cc]

800047c8 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
800047c8:	eb cd 40 80 	pushm	r7,lr
800047cc:	1a 97       	mov	r7,sp
800047ce:	20 1d       	sub	sp,4
800047d0:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
800047d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800047d8:	e6 18 00 01 	andh	r8,0x1,COH
800047dc:	5f 08       	sreq	r8
800047de:	5c 58       	castu.b	r8
}
800047e0:	10 9c       	mov	r12,r8
800047e2:	2f fd       	sub	sp,-4
800047e4:	e3 cd 80 80 	ldm	sp++,r7,pc

800047e8 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800047e8:	eb cd 40 80 	pushm	r7,lr
800047ec:	1a 97       	mov	r7,sp
800047ee:	20 7d       	sub	sp,28
800047f0:	ef 4c ff ec 	st.w	r7[-20],r12
800047f4:	ef 4b ff e8 	st.w	r7[-24],r11
800047f8:	ef 4a ff e4 	st.w	r7[-28],r10
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800047fc:	ee f8 ff e8 	ld.w	r8,r7[-24]
80004800:	f0 09 15 04 	lsl	r9,r8,0x4
80004804:	ee f8 ff e4 	ld.w	r8,r7[-28]
80004808:	10 39       	cp.w	r9,r8
8000480a:	e0 8b 00 04 	brhi	80004812 <usart_set_async_baudrate+0x2a>
8000480e:	31 08       	mov	r8,16
80004810:	c0 28       	rjmp	80004814 <usart_set_async_baudrate+0x2c>
80004812:	30 88       	mov	r8,8
80004814:	ef 48 ff f0 	st.w	r7[-16],r8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004818:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000481c:	f0 09 15 03 	lsl	r9,r8,0x3
80004820:	ee fa ff f0 	ld.w	r10,r7[-16]
80004824:	ee f8 ff e8 	ld.w	r8,r7[-24]
80004828:	f4 08 02 48 	mul	r8,r10,r8
8000482c:	a1 98       	lsr	r8,0x1
8000482e:	f2 08 00 08 	add	r8,r9,r8
80004832:	ee fa ff f0 	ld.w	r10,r7[-16]
80004836:	ee f9 ff e8 	ld.w	r9,r7[-24]
8000483a:	f4 09 02 49 	mul	r9,r10,r9
8000483e:	f0 09 0d 08 	divu	r8,r8,r9
80004842:	ef 48 ff f4 	st.w	r7[-12],r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004846:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000484a:	a3 98       	lsr	r8,0x3
8000484c:	ef 48 ff f8 	st.w	r7[-8],r8
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);
80004850:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004854:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004858:	ef 48 ff fc 	st.w	r7[-4],r8

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
8000485c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004860:	58 08       	cp.w	r8,0
80004862:	c0 70       	breq	80004870 <usart_set_async_baudrate+0x88>
80004864:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004868:	e0 48 ff ff 	cp.w	r8,65535
8000486c:	e0 88 00 04 	brls	80004874 <usart_set_async_baudrate+0x8c>
    return USART_INVALID_INPUT;
80004870:	30 18       	mov	r8,1
80004872:	c2 08       	rjmp	800048b2 <usart_set_async_baudrate+0xca>

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004874:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004878:	70 18       	ld.w	r8,r8[0x4]
8000487a:	10 99       	mov	r9,r8
8000487c:	e4 19 ff f7 	andh	r9,0xfff7
80004880:	e0 19 fe cf 	andl	r9,0xfecf
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004884:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004888:	59 08       	cp.w	r8,16
8000488a:	c0 40       	breq	80004892 <usart_set_async_baudrate+0xaa>
8000488c:	e8 68 00 00 	mov	r8,524288
80004890:	c0 28       	rjmp	80004894 <usart_set_async_baudrate+0xac>
80004892:	30 08       	mov	r8,0
80004894:	10 49       	or	r9,r8
80004896:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000489a:	91 19       	st.w	r8[0x4],r9
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
                fp << AVR32_USART_BRGR_FP_OFFSET;
8000489c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800048a0:	f0 09 15 10 	lsl	r9,r8,0x10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
800048a4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048a8:	10 49       	or	r9,r8
800048aa:	ee f8 ff ec 	ld.w	r8,r7[-20]
800048ae:	91 89       	st.w	r8[0x20],r9
                fp << AVR32_USART_BRGR_FP_OFFSET;

  return USART_SUCCESS;
800048b0:	30 08       	mov	r8,0
}
800048b2:	10 9c       	mov	r12,r8
800048b4:	2f 9d       	sub	sp,-28
800048b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800048ba:	d7 03       	nop

800048bc <usart_reset>:
 */
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
800048bc:	eb cd 40 80 	pushm	r7,lr
800048c0:	1a 97       	mov	r7,sp
800048c2:	20 2d       	sub	sp,8
800048c4:	ef 4c ff f8 	st.w	r7[-8],r12
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800048c8:	e1 b8 00 00 	mfsr	r8,0x0
800048cc:	10 9c       	mov	r12,r8
800048ce:	f0 1f 00 18 	mcall	8000492c <usart_reset+0x70>
800048d2:	18 98       	mov	r8,r12
800048d4:	ef 68 ff ff 	st.b	r7[-1],r8

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800048d8:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800048dc:	30 08       	mov	r8,0
800048de:	f0 09 18 00 	cp.b	r9,r8
800048e2:	c0 20       	breq	800048e6 <usart_reset+0x2a>
800048e4:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800048e6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048ea:	3f f9       	mov	r9,-1
800048ec:	91 39       	st.w	r8[0xc],r9
  usart->csr;
800048ee:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048f2:	70 58       	ld.w	r8,r8[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800048f4:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800048f8:	30 08       	mov	r8,0
800048fa:	f0 09 18 00 	cp.b	r9,r8
800048fe:	c0 20       	breq	80004902 <usart_reset+0x46>
80004900:	d5 03       	csrf	0x10

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004902:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004906:	30 09       	mov	r9,0
80004908:	91 19       	st.w	r8[0x4],r9
  usart->rtor = 0;
8000490a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000490e:	30 09       	mov	r9,0
80004910:	91 99       	st.w	r8[0x24],r9
  usart->ttgr = 0;
80004912:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004916:	30 09       	mov	r9,0
80004918:	91 a9       	st.w	r8[0x28],r9

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
8000491a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000491e:	ea 69 61 0c 	mov	r9,680204
80004922:	91 09       	st.w	r8[0x0],r9
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004924:	2f ed       	sub	sp,-8
80004926:	e3 cd 80 80 	ldm	sp++,r7,pc
8000492a:	00 00       	add	r0,r0
8000492c:	80 00       	ld.sh	r0,r0[0x0]
8000492e:	47 c8       	lddsp	r8,sp[0x1f0]

80004930 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004930:	eb cd 40 80 	pushm	r7,lr
80004934:	1a 97       	mov	r7,sp
80004936:	20 3d       	sub	sp,12
80004938:	ef 4c ff fc 	st.w	r7[-4],r12
8000493c:	ef 4b ff f8 	st.w	r7[-8],r11
80004940:	ef 4a ff f4 	st.w	r7[-12],r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004944:	ee fc ff fc 	ld.w	r12,r7[-4]
80004948:	f0 1f 00 54 	mcall	80004a98 <usart_init_rs232+0x168>

  // Check input values.
  if (!opt || // Null pointer.
8000494c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004950:	58 08       	cp.w	r8,0
80004952:	c3 90       	breq	800049c4 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80004954:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004958:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000495a:	30 48       	mov	r8,4
8000495c:	f0 09 18 00 	cp.b	r9,r8
80004960:	e0 88 00 32 	brls	800049c4 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80004964:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004968:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000496a:	30 98       	mov	r8,9
8000496c:	f0 09 18 00 	cp.b	r9,r8
80004970:	e0 8b 00 2a 	brhi	800049c4 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004974:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004978:	11 d9       	ld.ub	r9,r8[0x5]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000497a:	30 78       	mov	r8,7
8000497c:	f0 09 18 00 	cp.b	r9,r8
80004980:	e0 8b 00 22 	brhi	800049c4 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
80004984:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004988:	90 39       	ld.sh	r9,r8[0x6]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000498a:	e0 68 01 01 	mov	r8,257
8000498e:	f0 09 19 00 	cp.h	r9,r8
80004992:	e0 8b 00 19 	brhi	800049c4 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
80004996:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000499a:	f1 39 00 08 	ld.ub	r9,r8[8]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000499e:	30 38       	mov	r8,3
800049a0:	f0 09 18 00 	cp.b	r9,r8
800049a4:	e0 8b 00 10 	brhi	800049c4 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
800049a8:	ee f9 ff f4 	ld.w	r9,r7[-12]
800049ac:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049b0:	70 08       	ld.w	r8,r8[0x0]
800049b2:	12 9a       	mov	r10,r9
800049b4:	10 9b       	mov	r11,r8
800049b6:	ee fc ff fc 	ld.w	r12,r7[-4]
800049ba:	f0 1f 00 39 	mcall	80004a9c <usart_init_rs232+0x16c>
800049be:	18 98       	mov	r8,r12
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800049c0:	58 18       	cp.w	r8,1
800049c2:	c0 31       	brne	800049c8 <usart_init_rs232+0x98>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;
800049c4:	30 18       	mov	r8,1
800049c6:	c6 48       	rjmp	80004a8e <usart_init_rs232+0x15e>

  if (opt->charlength == 9)
800049c8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049cc:	11 c9       	ld.ub	r9,r8[0x4]
800049ce:	30 98       	mov	r8,9
800049d0:	f0 09 18 00 	cp.b	r9,r8
800049d4:	c0 a1       	brne	800049e8 <usart_init_rs232+0xb8>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800049d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800049da:	70 18       	ld.w	r8,r8[0x4]
800049dc:	10 99       	mov	r9,r8
800049de:	b1 b9       	sbr	r9,0x11
800049e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800049e4:	91 19       	st.w	r8[0x4],r9
800049e6:	c0 d8       	rjmp	80004a00 <usart_init_rs232+0xd0>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800049e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800049ec:	70 19       	ld.w	r9,r8[0x4]
800049ee:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049f2:	11 c8       	ld.ub	r8,r8[0x4]
800049f4:	20 58       	sub	r8,5
800049f6:	a7 68       	lsl	r8,0x6
800049f8:	10 49       	or	r9,r8
800049fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800049fe:	91 19       	st.w	r8[0x4],r9
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004a00:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a04:	70 19       	ld.w	r9,r8[0x4]
80004a06:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a0a:	11 d8       	ld.ub	r8,r8[0x5]
80004a0c:	f0 0a 15 09 	lsl	r10,r8,0x9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;
80004a10:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a14:	f1 38 00 08 	ld.ub	r8,r8[8]
80004a18:	af 68       	lsl	r8,0xe
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004a1a:	f5 e8 10 08 	or	r8,r10,r8
80004a1e:	10 49       	or	r9,r8
80004a20:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a24:	91 19       	st.w	r8[0x4],r9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004a26:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a2a:	90 39       	ld.sh	r9,r8[0x6]
80004a2c:	30 28       	mov	r8,2
80004a2e:	f0 09 19 00 	cp.h	r9,r8
80004a32:	e0 88 00 14 	brls	80004a5a <usart_init_rs232+0x12a>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004a36:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a3a:	70 18       	ld.w	r8,r8[0x4]
80004a3c:	10 99       	mov	r9,r8
80004a3e:	ad b9       	sbr	r9,0xd
80004a40:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a44:	91 19       	st.w	r8[0x4],r9
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004a46:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a4a:	90 38       	ld.sh	r8,r8[0x6]
80004a4c:	5c 78       	castu.h	r8
80004a4e:	20 28       	sub	r8,2
80004a50:	10 99       	mov	r9,r8
80004a52:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a56:	91 a9       	st.w	r8[0x28],r9
80004a58:	c0 d8       	rjmp	80004a72 <usart_init_rs232+0x142>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004a5a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a5e:	70 19       	ld.w	r9,r8[0x4]
80004a60:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a64:	90 38       	ld.sh	r8,r8[0x6]
80004a66:	5c 78       	castu.h	r8
80004a68:	ad 68       	lsl	r8,0xc
80004a6a:	10 49       	or	r9,r8
80004a6c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a70:	91 19       	st.w	r8[0x4],r9

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004a72:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a76:	70 18       	ld.w	r8,r8[0x4]
80004a78:	10 99       	mov	r9,r8
80004a7a:	e0 19 ff f0 	andl	r9,0xfff0
80004a7e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a82:	91 19       	st.w	r8[0x4],r9
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004a84:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a88:	35 09       	mov	r9,80
80004a8a:	91 09       	st.w	r8[0x0],r9
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004a8c:	30 08       	mov	r8,0
}
80004a8e:	10 9c       	mov	r12,r8
80004a90:	2f dd       	sub	sp,-12
80004a92:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a96:	00 00       	add	r0,r0
80004a98:	80 00       	ld.sh	r0,r0[0x0]
80004a9a:	48 bc       	lddpc	r12,80004ac4 <usart_write_char+0x24>
80004a9c:	80 00       	ld.sh	r0,r0[0x0]
80004a9e:	47 e8       	lddsp	r8,sp[0x1f8]

80004aa0 <usart_write_char>:
  return USART_SUCCESS;
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
80004aa0:	eb cd 40 80 	pushm	r7,lr
80004aa4:	1a 97       	mov	r7,sp
80004aa6:	20 3d       	sub	sp,12
80004aa8:	ef 4c ff f8 	st.w	r7[-8],r12
80004aac:	ef 4b ff f4 	st.w	r7[-12],r11
80004ab0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ab4:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004ab8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004abc:	70 58       	ld.w	r8,r8[0x14]
80004abe:	e2 18 00 02 	andl	r8,0x2,COH
80004ac2:	5f 18       	srne	r8
  if (usart_tx_ready(usart))
80004ac4:	58 08       	cp.w	r8,0
80004ac6:	c0 a0       	breq	80004ada <usart_write_char+0x3a>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004ac8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004acc:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80004ad0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ad4:	91 79       	st.w	r8[0x1c],r9
    return USART_SUCCESS;
80004ad6:	30 08       	mov	r8,0
80004ad8:	c0 28       	rjmp	80004adc <usart_write_char+0x3c>
  }
  else
    return USART_TX_BUSY;
80004ada:	30 28       	mov	r8,2
}
80004adc:	10 9c       	mov	r12,r8
80004ade:	2f dd       	sub	sp,-12
80004ae0:	e3 cd 80 80 	ldm	sp++,r7,pc

80004ae4 <usart_putchar>:


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004ae4:	eb cd 40 80 	pushm	r7,lr
80004ae8:	1a 97       	mov	r7,sp
80004aea:	20 3d       	sub	sp,12
80004aec:	ef 4c ff f8 	st.w	r7[-8],r12
80004af0:	ef 4b ff f4 	st.w	r7[-12],r11
  int timeout = USART_DEFAULT_TIMEOUT;
80004af4:	e0 68 27 10 	mov	r8,10000
80004af8:	ef 48 ff fc 	st.w	r7[-4],r8

  do
  {
    if (!timeout--) return USART_FAILURE;
80004afc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b00:	58 08       	cp.w	r8,0
80004b02:	5f 08       	sreq	r8
80004b04:	5c 58       	castu.b	r8
80004b06:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004b0a:	20 19       	sub	r9,1
80004b0c:	ef 49 ff fc 	st.w	r7[-4],r9
80004b10:	58 08       	cp.w	r8,0
80004b12:	c0 30       	breq	80004b18 <usart_putchar+0x34>
80004b14:	3f f8       	mov	r8,-1
80004b16:	c0 b8       	rjmp	80004b2c <usart_putchar+0x48>
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004b18:	ee fb ff f4 	ld.w	r11,r7[-12]
80004b1c:	ee fc ff f8 	ld.w	r12,r7[-8]
80004b20:	f0 1f 00 05 	mcall	80004b34 <usart_putchar+0x50>
80004b24:	18 98       	mov	r8,r12
80004b26:	58 08       	cp.w	r8,0
80004b28:	ce a1       	brne	80004afc <usart_putchar+0x18>

  return USART_SUCCESS;
80004b2a:	30 08       	mov	r8,0
}
80004b2c:	10 9c       	mov	r12,r8
80004b2e:	2f dd       	sub	sp,-12
80004b30:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b34:	80 00       	ld.sh	r0,r0[0x0]
80004b36:	4a a0       	lddpc	r0,80004bdc <usart_write_line+0xc>

80004b38 <usart_read_char>:


int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
80004b38:	eb cd 40 80 	pushm	r7,lr
80004b3c:	1a 97       	mov	r7,sp
80004b3e:	20 3d       	sub	sp,12
80004b40:	ef 4c ff f8 	st.w	r7[-8],r12
80004b44:	ef 4b ff f4 	st.w	r7[-12],r11
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004b48:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b4c:	70 58       	ld.w	r8,r8[0x14]
80004b4e:	e2 18 00 e0 	andl	r8,0xe0,COH
80004b52:	c0 30       	breq	80004b58 <usart_read_char+0x20>
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;
80004b54:	30 48       	mov	r8,4
80004b56:	c1 68       	rjmp	80004b82 <usart_read_char+0x4a>
80004b58:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b5c:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004b60:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b64:	70 58       	ld.w	r8,r8[0x14]
80004b66:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004b6a:	c0 b0       	breq	80004b80 <usart_read_char+0x48>
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004b6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b70:	70 68       	ld.w	r8,r8[0x18]
80004b72:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80004b76:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004b7a:	91 09       	st.w	r8[0x0],r9
    return USART_SUCCESS;
80004b7c:	30 08       	mov	r8,0
80004b7e:	c0 28       	rjmp	80004b82 <usart_read_char+0x4a>
  }
  else
    return USART_RX_EMPTY;
80004b80:	30 38       	mov	r8,3
}
80004b82:	10 9c       	mov	r12,r8
80004b84:	2f dd       	sub	sp,-12
80004b86:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b8a:	d7 03       	nop

80004b8c <usart_getchar>:


int usart_getchar(volatile avr32_usart_t *usart)
{
80004b8c:	eb cd 40 80 	pushm	r7,lr
80004b90:	1a 97       	mov	r7,sp
80004b92:	20 3d       	sub	sp,12
80004b94:	ef 4c ff f4 	st.w	r7[-12],r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004b98:	ee c8 00 08 	sub	r8,r7,8
80004b9c:	10 9b       	mov	r11,r8
80004b9e:	ee fc ff f4 	ld.w	r12,r7[-12]
80004ba2:	f0 1f 00 0b 	mcall	80004bcc <usart_getchar+0x40>
80004ba6:	18 98       	mov	r8,r12
80004ba8:	ef 48 ff fc 	st.w	r7[-4],r8
80004bac:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bb0:	58 38       	cp.w	r8,3
80004bb2:	cf 30       	breq	80004b98 <usart_getchar+0xc>

  if (ret == USART_RX_ERROR)
80004bb4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bb8:	58 48       	cp.w	r8,4
80004bba:	c0 31       	brne	80004bc0 <usart_getchar+0x34>
    return USART_FAILURE;
80004bbc:	3f f8       	mov	r8,-1
80004bbe:	c0 38       	rjmp	80004bc4 <usart_getchar+0x38>

  return c;
80004bc0:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80004bc4:	10 9c       	mov	r12,r8
80004bc6:	2f dd       	sub	sp,-12
80004bc8:	e3 cd 80 80 	ldm	sp++,r7,pc
80004bcc:	80 00       	ld.sh	r0,r0[0x0]
80004bce:	4b 38       	lddpc	r8,80004c98 <vListInsertEnd+0x22>

80004bd0 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004bd0:	eb cd 40 80 	pushm	r7,lr
80004bd4:	1a 97       	mov	r7,sp
80004bd6:	20 2d       	sub	sp,8
80004bd8:	ef 4c ff fc 	st.w	r7[-4],r12
80004bdc:	ef 4b ff f8 	st.w	r7[-8],r11
  while (*string != '\0')
80004be0:	c0 e8       	rjmp	80004bfc <usart_write_line+0x2c>
    usart_putchar(usart, *string++);
80004be2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004be6:	11 88       	ld.ub	r8,r8[0x0]
80004be8:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004bec:	2f f9       	sub	r9,-1
80004bee:	ef 49 ff f8 	st.w	r7[-8],r9
80004bf2:	10 9b       	mov	r11,r8
80004bf4:	ee fc ff fc 	ld.w	r12,r7[-4]
80004bf8:	f0 1f 00 05 	mcall	80004c0c <usart_write_line+0x3c>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80004bfc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c00:	11 88       	ld.ub	r8,r8[0x0]
80004c02:	58 08       	cp.w	r8,0
80004c04:	ce f1       	brne	80004be2 <usart_write_line+0x12>
    usart_putchar(usart, *string++);
}
80004c06:	2f ed       	sub	sp,-8
80004c08:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c0c:	80 00       	ld.sh	r0,r0[0x0]
80004c0e:	4a e4       	lddpc	r4,80004cc4 <vListInsertEnd+0x4e>

80004c10 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
80004c10:	eb cd 40 80 	pushm	r7,lr
80004c14:	1a 97       	mov	r7,sp
80004c16:	20 1d       	sub	sp,4
80004c18:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004c1c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c20:	2f 88       	sub	r8,-8
80004c22:	10 99       	mov	r9,r8
80004c24:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c28:	91 19       	st.w	r8[0x4],r9

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004c2a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c2e:	3f f9       	mov	r9,-1
80004c30:	91 29       	st.w	r8[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004c32:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c36:	2f 88       	sub	r8,-8
80004c38:	10 99       	mov	r9,r8
80004c3a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c3e:	91 39       	st.w	r8[0xc],r9
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004c40:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c44:	2f 88       	sub	r8,-8
80004c46:	10 99       	mov	r9,r8
80004c48:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c4c:	91 49       	st.w	r8[0x10],r9

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004c4e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c52:	30 09       	mov	r9,0
80004c54:	91 09       	st.w	r8[0x0],r9
}
80004c56:	2f fd       	sub	sp,-4
80004c58:	e3 cd 80 80 	ldm	sp++,r7,pc

80004c5c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
80004c5c:	eb cd 40 80 	pushm	r7,lr
80004c60:	1a 97       	mov	r7,sp
80004c62:	20 1d       	sub	sp,4
80004c64:	ef 4c ff fc 	st.w	r7[-4],r12
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004c68:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c6c:	30 09       	mov	r9,0
80004c6e:	91 49       	st.w	r8[0x10],r9
}
80004c70:	2f fd       	sub	sp,-4
80004c72:	e3 cd 80 80 	ldm	sp++,r7,pc

80004c76 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
80004c76:	eb cd 40 80 	pushm	r7,lr
80004c7a:	1a 97       	mov	r7,sp
80004c7c:	20 3d       	sub	sp,12
80004c7e:	ef 4c ff f8 	st.w	r7[-8],r12
80004c82:	ef 4b ff f4 	st.w	r7[-12],r11

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004c86:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c8a:	70 18       	ld.w	r8,r8[0x4]
80004c8c:	ef 48 ff fc 	st.w	r7[-4],r8

	pxNewListItem->pxNext = pxIndex->pxNext;
80004c90:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c94:	70 19       	ld.w	r9,r8[0x4]
80004c96:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004c9a:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004c9c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ca0:	70 19       	ld.w	r9,r8[0x4]
80004ca2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004ca6:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004ca8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004cac:	70 18       	ld.w	r8,r8[0x4]
80004cae:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004cb2:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004cb4:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004cb8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004cbc:	91 19       	st.w	r8[0x4],r9
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004cbe:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004cc2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004cc6:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004cc8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004ccc:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004cd0:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80004cd2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004cd6:	70 08       	ld.w	r8,r8[0x0]
80004cd8:	f0 c9 ff ff 	sub	r9,r8,-1
80004cdc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ce0:	91 09       	st.w	r8[0x0],r9
}
80004ce2:	2f dd       	sub	sp,-12
80004ce4:	e3 cd 80 80 	ldm	sp++,r7,pc

80004ce8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
80004ce8:	eb cd 40 80 	pushm	r7,lr
80004cec:	1a 97       	mov	r7,sp
80004cee:	20 4d       	sub	sp,16
80004cf0:	ef 4c ff f4 	st.w	r7[-12],r12
80004cf4:	ef 4b ff f0 	st.w	r7[-16],r11
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004cf8:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004cfc:	70 08       	ld.w	r8,r8[0x0]
80004cfe:	ef 48 ff fc 	st.w	r7[-4],r8
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004d02:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d06:	5b f8       	cp.w	r8,-1
80004d08:	c0 71       	brne	80004d16 <vListInsert+0x2e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004d0a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d0e:	70 48       	ld.w	r8,r8[0x10]
80004d10:	ef 48 ff f8 	st.w	r7[-8],r8
80004d14:	c1 58       	rjmp	80004d3e <vListInsert+0x56>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004d16:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d1a:	2f 88       	sub	r8,-8
80004d1c:	ef 48 ff f8 	st.w	r7[-8],r8
80004d20:	c0 68       	rjmp	80004d2c <vListInsert+0x44>
80004d22:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d26:	70 18       	ld.w	r8,r8[0x4]
80004d28:	ef 48 ff f8 	st.w	r7[-8],r8
80004d2c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d30:	70 18       	ld.w	r8,r8[0x4]
80004d32:	70 09       	ld.w	r9,r8[0x0]
80004d34:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d38:	10 39       	cp.w	r9,r8
80004d3a:	fe 98 ff f4 	brls	80004d22 <vListInsert+0x3a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004d3e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d42:	70 19       	ld.w	r9,r8[0x4]
80004d44:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004d48:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004d4a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004d4e:	70 18       	ld.w	r8,r8[0x4]
80004d50:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004d54:	91 29       	st.w	r8[0x8],r9
	pxNewListItem->pxPrevious = pxIterator;
80004d56:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004d5a:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004d5e:	91 29       	st.w	r8[0x8],r9
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004d60:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004d64:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d68:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004d6a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004d6e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004d72:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80004d74:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d78:	70 08       	ld.w	r8,r8[0x0]
80004d7a:	f0 c9 ff ff 	sub	r9,r8,-1
80004d7e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d82:	91 09       	st.w	r8[0x0],r9
}
80004d84:	2f cd       	sub	sp,-16
80004d86:	e3 cd 80 80 	ldm	sp++,r7,pc

80004d8a <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
80004d8a:	eb cd 40 80 	pushm	r7,lr
80004d8e:	1a 97       	mov	r7,sp
80004d90:	20 2d       	sub	sp,8
80004d92:	ef 4c ff f8 	st.w	r7[-8],r12
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004d96:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d9a:	70 18       	ld.w	r8,r8[0x4]
80004d9c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004da0:	72 29       	ld.w	r9,r9[0x8]
80004da2:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004da4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004da8:	70 28       	ld.w	r8,r8[0x8]
80004daa:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004dae:	72 19       	ld.w	r9,r9[0x4]
80004db0:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004db2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004db6:	70 48       	ld.w	r8,r8[0x10]
80004db8:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004dbc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004dc0:	70 19       	ld.w	r9,r8[0x4]
80004dc2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004dc6:	10 39       	cp.w	r9,r8
80004dc8:	c0 71       	brne	80004dd6 <vListRemove+0x4c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004dca:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004dce:	70 29       	ld.w	r9,r8[0x8]
80004dd0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004dd4:	91 19       	st.w	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004dd6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004dda:	30 09       	mov	r9,0
80004ddc:	91 49       	st.w	r8[0x10],r9
	( pxList->uxNumberOfItems )--;
80004dde:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004de2:	70 08       	ld.w	r8,r8[0x0]
80004de4:	f0 c9 00 01 	sub	r9,r8,1
80004de8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004dec:	91 09       	st.w	r8[0x0],r9
}
80004dee:	2f ed       	sub	sp,-8
80004df0:	e3 cd 80 80 	ldm	sp++,r7,pc

80004df4 <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80004df4:	eb cd 40 80 	pushm	r7,lr
80004df8:	1a 97       	mov	r7,sp
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
80004dfa:	48 e8       	lddpc	r8,80004e30 <_init_startup+0x3c>
80004dfc:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
80004e00:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
80004e02:	f0 1f 00 0d 	mcall	80004e34 <_init_startup+0x40>
			.channelmode = USART_NORMAL_CHMODE
		};

		/* Initialize the USART used for the debug trace with the configured parameters. */
		extern volatile avr32_usart_t *volatile stdio_usart_base;
		stdio_usart_base = configDBG_USART;
80004e06:	48 d8       	lddpc	r8,80004e38 <_init_startup+0x44>
80004e08:	fe 79 18 00 	mov	r9,-59392
80004e0c:	91 09       	st.w	r8[0x0],r9
		gpio_enable_module( DBG_USART_GPIO_MAP,
80004e0e:	30 2b       	mov	r11,2
80004e10:	48 bc       	lddpc	r12,80004e3c <_init_startup+0x48>
80004e12:	f0 1f 00 0c 	mcall	80004e40 <_init_startup+0x4c>
		                    sizeof( DBG_USART_GPIO_MAP ) / sizeof( DBG_USART_GPIO_MAP[0] ) );
		usart_init_rs232(configDBG_USART, &DBG_USART_OPTIONS, configPBA_CLOCK_HZ);
80004e16:	e0 6a 1b 00 	mov	r10,6912
80004e1a:	ea 1a 00 b7 	orh	r10,0xb7
80004e1e:	48 ab       	lddpc	r11,80004e44 <_init_startup+0x50>
80004e20:	fe 7c 18 00 	mov	r12,-59392
80004e24:	f0 1f 00 09 	mcall	80004e48 <_init_startup+0x54>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
80004e28:	30 18       	mov	r8,1
}
80004e2a:	10 9c       	mov	r12,r8
80004e2c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	c2 00       	breq	80004e72 <__malloc_unlock+0xa>
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	44 6c       	lddsp	r12,sp[0x118]
80004e38:	00 00       	add	r0,r0
80004e3a:	08 0c       	add	r12,r4
80004e3c:	80 00       	ld.sh	r0,r0[0x0]
80004e3e:	c5 14       	brge	80004ee0 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
80004e40:	80 00       	ld.sh	r0,r0[0x0]
80004e42:	41 90       	lddsp	r0,sp[0x64]
80004e44:	80 00       	ld.sh	r0,r0[0x0]
80004e46:	c5 24       	brge	80004eea <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0xa>
80004e48:	80 00       	ld.sh	r0,r0[0x0]
80004e4a:	49 30       	lddpc	r0,80004e94 <vTick+0x10>

80004e4c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80004e4c:	eb cd 40 80 	pushm	r7,lr
80004e50:	1a 97       	mov	r7,sp
80004e52:	20 1d       	sub	sp,4
80004e54:	ef 4c ff fc 	st.w	r7[-4],r12
	vTaskSuspendAll();
80004e58:	f0 1f 00 03 	mcall	80004e64 <__malloc_lock+0x18>
}
80004e5c:	2f fd       	sub	sp,-4
80004e5e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e62:	00 00       	add	r0,r0
80004e64:	80 00       	ld.sh	r0,r0[0x0]
80004e66:	5d 64       	*unknown*

80004e68 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80004e68:	eb cd 40 80 	pushm	r7,lr
80004e6c:	1a 97       	mov	r7,sp
80004e6e:	20 1d       	sub	sp,4
80004e70:	ef 4c ff fc 	st.w	r7[-4],r12
	xTaskResumeAll();
80004e74:	f0 1f 00 03 	mcall	80004e80 <__malloc_unlock+0x18>
}
80004e78:	2f fd       	sub	sp,-4
80004e7a:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e7e:	00 00       	add	r0,r0
80004e80:	80 00       	ld.sh	r0,r0[0x0]
80004e82:	5d 80       	*unknown*

80004e84 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004e84:	eb cd 00 ff 	pushm	r0-r7
80004e88:	e0 68 00 20 	mov	r8,32
80004e8c:	ea 18 00 00 	orh	r8,0x0
80004e90:	70 00       	ld.w	r0,r8[0x0]
80004e92:	1a d0       	st.w	--sp,r0
80004e94:	7a 90       	ld.w	r0,sp[0x24]
80004e96:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004e9a:	58 10       	cp.w	r0,1
80004e9c:	e0 8b 00 08 	brhi	80004eac <LABEL_INT_SKIP_SAVE_CONTEXT_234>
80004ea0:	e0 68 06 60 	mov	r8,1632
80004ea4:	ea 18 00 00 	orh	r8,0x0
80004ea8:	70 00       	ld.w	r0,r8[0x0]
80004eaa:	81 0d       	st.w	r0[0x0],sp

80004eac <LABEL_INT_SKIP_SAVE_CONTEXT_234>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80004eac:	f0 1f 00 12 	mcall	80004ef4 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80004eb0:	f0 1f 00 12 	mcall	80004ef8 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
		vTaskIncrementTick();
80004eb4:	f0 1f 00 12 	mcall	80004efc <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x1c>
	portEXIT_CRITICAL();
80004eb8:	f0 1f 00 12 	mcall	80004f00 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80004ebc:	7a 90       	ld.w	r0,sp[0x24]
80004ebe:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004ec2:	58 10       	cp.w	r0,1
80004ec4:	e0 8b 00 0e 	brhi	80004ee0 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
80004ec8:	f0 1f 00 0c 	mcall	80004ef8 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
80004ecc:	f0 1f 00 0e 	mcall	80004f04 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x24>
80004ed0:	f0 1f 00 0c 	mcall	80004f00 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>
80004ed4:	e0 68 06 60 	mov	r8,1632
80004ed8:	ea 18 00 00 	orh	r8,0x0
80004edc:	70 00       	ld.w	r0,r8[0x0]
80004ede:	60 0d       	ld.w	sp,r0[0x0]

80004ee0 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>:
80004ee0:	1b 00       	ld.w	r0,sp++
80004ee2:	e0 68 00 20 	mov	r8,32
80004ee6:	ea 18 00 00 	orh	r8,0x0
80004eea:	91 00       	st.w	r8[0x0],r0
80004eec:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004ef0:	d6 03       	rete
80004ef2:	00 00       	add	r0,r0
80004ef4:	80 00       	ld.sh	r0,r0[0x0]
80004ef6:	51 f0       	stdsp	sp[0x7c],r0
80004ef8:	80 00       	ld.sh	r0,r0[0x0]
80004efa:	4f a0       	lddpc	r0,800050e0 <pxPortInitialiseStack+0xf8>
80004efc:	80 00       	ld.sh	r0,r0[0x0]
80004efe:	5e d8       	retvc	r8
80004f00:	80 00       	ld.sh	r0,r0[0x0]
80004f02:	4f bc       	lddpc	r12,800050ec <pxPortInitialiseStack+0x104>
80004f04:	80 00       	ld.sh	r0,r0[0x0]
80004f06:	60 38       	ld.w	r8,r0[0xc]

80004f08 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004f08:	20 6d       	sub	sp,24
80004f0a:	eb cd 00 ff 	pushm	r0-r7
80004f0e:	fa c7 ff c0 	sub	r7,sp,-64
80004f12:	ee f0 ff f8 	ld.w	r0,r7[-8]
80004f16:	ef 40 ff e0 	st.w	r7[-32],r0
80004f1a:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004f1e:	ef 40 ff e4 	st.w	r7[-28],r0
80004f22:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80004f26:	e0 68 00 20 	mov	r8,32
80004f2a:	ea 18 00 00 	orh	r8,0x0
80004f2e:	70 00       	ld.w	r0,r8[0x0]
80004f30:	1a d0       	st.w	--sp,r0
80004f32:	f0 1f 00 1a 	mcall	80004f98 <LABEL_RET_SCALL_260+0x14>
80004f36:	e0 68 06 60 	mov	r8,1632
80004f3a:	ea 18 00 00 	orh	r8,0x0
80004f3e:	70 00       	ld.w	r0,r8[0x0]
80004f40:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80004f42:	f0 1f 00 17 	mcall	80004f9c <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
80004f46:	e0 68 06 60 	mov	r8,1632
80004f4a:	ea 18 00 00 	orh	r8,0x0
80004f4e:	70 00       	ld.w	r0,r8[0x0]
80004f50:	60 0d       	ld.w	sp,r0[0x0]
80004f52:	1b 00       	ld.w	r0,sp++
80004f54:	e0 68 00 20 	mov	r8,32
80004f58:	ea 18 00 00 	orh	r8,0x0
80004f5c:	91 00       	st.w	r8[0x0],r0
80004f5e:	fa c7 ff d8 	sub	r7,sp,-40
80004f62:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80004f66:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004f6a:	e0 61 00 20 	mov	r1,32
80004f6e:	ea 11 00 00 	orh	r1,0x0
80004f72:	62 02       	ld.w	r2,r1[0x0]
80004f74:	58 02       	cp.w	r2,0
80004f76:	c0 70       	breq	80004f84 <LABEL_RET_SCALL_260>
80004f78:	e4 c2 00 01 	sub	r2,r2,1
80004f7c:	83 02       	st.w	r1[0x0],r2
80004f7e:	58 02       	cp.w	r2,0
80004f80:	c0 21       	brne	80004f84 <LABEL_RET_SCALL_260>
80004f82:	b1 c0       	cbr	r0,0x10

80004f84 <LABEL_RET_SCALL_260>:
80004f84:	ef 40 ff f8 	st.w	r7[-8],r0
80004f88:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004f8c:	ef 40 ff fc 	st.w	r7[-4],r0
80004f90:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004f94:	2f ad       	sub	sp,-24
80004f96:	d6 13       	rets
80004f98:	80 00       	ld.sh	r0,r0[0x0]
80004f9a:	4f a0       	lddpc	r0,80005180 <pxPortInitialiseStack+0x198>
80004f9c:	80 00       	ld.sh	r0,r0[0x0]
80004f9e:	60 38       	ld.w	r8,r0[0xc]

80004fa0 <vPortEnterCritical>:
/* The code generated by the GCC compiler uses the stack in different ways at
different optimisation levels.  The interrupt flags can therefore not always
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
80004fa0:	eb cd 40 80 	pushm	r7,lr
80004fa4:	1a 97       	mov	r7,sp
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004fa6:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80004fa8:	48 48       	lddpc	r8,80004fb8 <vPortEnterCritical+0x18>
80004faa:	70 08       	ld.w	r8,r8[0x0]
80004fac:	f0 c9 ff ff 	sub	r9,r8,-1
80004fb0:	48 28       	lddpc	r8,80004fb8 <vPortEnterCritical+0x18>
80004fb2:	91 09       	st.w	r8[0x0],r9
}
80004fb4:	e3 cd 80 80 	ldm	sp++,r7,pc
80004fb8:	00 00       	add	r0,r0
80004fba:	00 20       	rsub	r0,r0

80004fbc <vPortExitCritical>:
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
80004fbc:	eb cd 40 80 	pushm	r7,lr
80004fc0:	1a 97       	mov	r7,sp
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004fc2:	48 98       	lddpc	r8,80004fe4 <vPortExitCritical+0x28>
80004fc4:	70 08       	ld.w	r8,r8[0x0]
80004fc6:	58 08       	cp.w	r8,0
80004fc8:	c0 c0       	breq	80004fe0 <vPortExitCritical+0x24>
	{
		ulCriticalNesting--;
80004fca:	48 78       	lddpc	r8,80004fe4 <vPortExitCritical+0x28>
80004fcc:	70 08       	ld.w	r8,r8[0x0]
80004fce:	f0 c9 00 01 	sub	r9,r8,1
80004fd2:	48 58       	lddpc	r8,80004fe4 <vPortExitCritical+0x28>
80004fd4:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004fd6:	48 48       	lddpc	r8,80004fe4 <vPortExitCritical+0x28>
80004fd8:	70 08       	ld.w	r8,r8[0x0]
80004fda:	58 08       	cp.w	r8,0
80004fdc:	c0 21       	brne	80004fe0 <vPortExitCritical+0x24>
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80004fde:	d5 03       	csrf	0x10
		}
	}
}
80004fe0:	e3 cd 80 80 	ldm	sp++,r7,pc
80004fe4:	00 00       	add	r0,r0
80004fe6:	00 20       	rsub	r0,r0

80004fe8 <pxPortInitialiseStack>:
 * portSAVE_CONTEXT had been called.
 *
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
80004fe8:	eb cd 40 80 	pushm	r7,lr
80004fec:	1a 97       	mov	r7,sp
80004fee:	20 3d       	sub	sp,12
80004ff0:	ef 4c ff fc 	st.w	r7[-4],r12
80004ff4:	ef 4b ff f8 	st.w	r7[-8],r11
80004ff8:	ef 4a ff f4 	st.w	r7[-12],r10
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
80004ffc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005000:	20 48       	sub	r8,4
80005002:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005006:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000500a:	e0 69 08 08 	mov	r9,2056
8000500e:	ea 19 08 08 	orh	r9,0x808
80005012:	91 09       	st.w	r8[0x0],r9
80005014:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005018:	20 48       	sub	r8,4
8000501a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000501e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005022:	e0 69 09 09 	mov	r9,2313
80005026:	ea 19 09 09 	orh	r9,0x909
8000502a:	91 09       	st.w	r8[0x0],r9
8000502c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005030:	20 48       	sub	r8,4
80005032:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005036:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000503a:	e0 69 0a 0a 	mov	r9,2570
8000503e:	ea 19 0a 0a 	orh	r9,0xa0a
80005042:	91 09       	st.w	r8[0x0],r9
80005044:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005048:	20 48       	sub	r8,4
8000504a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
8000504e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005052:	e0 69 0b 0b 	mov	r9,2827
80005056:	ea 19 0b 0b 	orh	r9,0xb0b
8000505a:	91 09       	st.w	r8[0x0],r9
8000505c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005060:	20 48       	sub	r8,4
80005062:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005066:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000506a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000506e:	91 09       	st.w	r8[0x0],r9
80005070:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005074:	20 48       	sub	r8,4
80005076:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
8000507a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000507e:	e0 69 be ef 	mov	r9,48879
80005082:	ea 19 de ad 	orh	r9,0xdead
80005086:	91 09       	st.w	r8[0x0],r9
80005088:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000508c:	20 48       	sub	r8,4
8000508e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005092:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005096:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000509a:	91 09       	st.w	r8[0x0],r9
8000509c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050a0:	20 48       	sub	r8,4
800050a2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800050a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050aa:	fc 19 00 40 	movh	r9,0x40
800050ae:	91 09       	st.w	r8[0x0],r9
800050b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050b4:	20 48       	sub	r8,4
800050b6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
800050ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050be:	e0 69 00 ff 	mov	r9,255
800050c2:	ea 19 ff 00 	orh	r9,0xff00
800050c6:	91 09       	st.w	r8[0x0],r9
800050c8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050cc:	20 48       	sub	r8,4
800050ce:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800050d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050d6:	e0 69 01 01 	mov	r9,257
800050da:	ea 19 01 01 	orh	r9,0x101
800050de:	91 09       	st.w	r8[0x0],r9
800050e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050e4:	20 48       	sub	r8,4
800050e6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
800050ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050ee:	e0 69 02 02 	mov	r9,514
800050f2:	ea 19 02 02 	orh	r9,0x202
800050f6:	91 09       	st.w	r8[0x0],r9
800050f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050fc:	20 48       	sub	r8,4
800050fe:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005102:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005106:	e0 69 03 03 	mov	r9,771
8000510a:	ea 19 03 03 	orh	r9,0x303
8000510e:	91 09       	st.w	r8[0x0],r9
80005110:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005114:	20 48       	sub	r8,4
80005116:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
8000511a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000511e:	e0 69 04 04 	mov	r9,1028
80005122:	ea 19 04 04 	orh	r9,0x404
80005126:	91 09       	st.w	r8[0x0],r9
80005128:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000512c:	20 48       	sub	r8,4
8000512e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005132:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005136:	e0 69 05 05 	mov	r9,1285
8000513a:	ea 19 05 05 	orh	r9,0x505
8000513e:	91 09       	st.w	r8[0x0],r9
80005140:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005144:	20 48       	sub	r8,4
80005146:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
8000514a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000514e:	e0 69 06 06 	mov	r9,1542
80005152:	ea 19 06 06 	orh	r9,0x606
80005156:	91 09       	st.w	r8[0x0],r9
80005158:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000515c:	20 48       	sub	r8,4
8000515e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005162:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005166:	e0 69 07 07 	mov	r9,1799
8000516a:	ea 19 07 07 	orh	r9,0x707
8000516e:	91 09       	st.w	r8[0x0],r9
80005170:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005174:	20 48       	sub	r8,4
80005176:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
8000517a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000517e:	30 09       	mov	r9,0
80005180:	91 09       	st.w	r8[0x0],r9

	return pxTopOfStack;
80005182:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005186:	10 9c       	mov	r12,r8
80005188:	2f dd       	sub	sp,-12
8000518a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000518e:	d7 03       	nop

80005190 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005190:	eb cd 40 80 	pushm	r7,lr
80005194:	1a 97       	mov	r7,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
80005196:	f0 1f 00 10 	mcall	800051d4 <xPortStartScheduler+0x44>

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000519a:	e0 68 06 60 	mov	r8,1632
8000519e:	ea 18 00 00 	orh	r8,0x0
800051a2:	70 00       	ld.w	r0,r8[0x0]
800051a4:	60 0d       	ld.w	sp,r0[0x0]
800051a6:	1b 00       	ld.w	r0,sp++
800051a8:	e0 68 00 20 	mov	r8,32
800051ac:	ea 18 00 00 	orh	r8,0x0
800051b0:	91 00       	st.w	r8[0x0],r0
800051b2:	e3 cd 00 ff 	ldm	sp++,r0-r7
800051b6:	2f ed       	sub	sp,-8
800051b8:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800051bc:	fa f0 ff e0 	ld.w	r0,sp[-32]
800051c0:	e3 b0 00 00 	mtsr	0x0,r0
800051c4:	fa f0 ff dc 	ld.w	r0,sp[-36]
800051c8:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
800051cc:	30 08       	mov	r8,0
}
800051ce:	10 9c       	mov	r12,r8
800051d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800051d4:	80 00       	ld.sh	r0,r0[0x0]
800051d6:	52 04       	stdsp	sp[0x80],r4

800051d8 <prvScheduleFirstTick>:

/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
800051d8:	eb cd 40 80 	pushm	r7,lr
800051dc:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
800051de:	e0 68 2e e0 	mov	r8,12000
800051e2:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800051e6:	30 08       	mov	r8,0
800051e8:	e3 b8 00 42 	mtsr	0x108,r8
	}
800051ec:	e3 cd 80 80 	ldm	sp++,r7,pc

800051f0 <prvClearCcInt>:

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
800051f0:	eb cd 40 80 	pushm	r7,lr
800051f4:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800051f6:	e1 b8 00 43 	mfsr	r8,0x10c
800051fa:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800051fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80005202:	d7 03       	nop

80005204 <prvSetupTimerInterrupt>:
#endif
/*-----------------------------------------------------------*/

/* Setup the timer to generate the tick interrupts. */
static void prvSetupTimerInterrupt(void)
{
80005204:	eb cd 40 80 	pushm	r7,lr
80005208:	1a 97       	mov	r7,sp
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000520a:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
8000520c:	30 0a       	mov	r10,0
8000520e:	30 0b       	mov	r11,0
80005210:	48 4c       	lddpc	r12,80005220 <prvSetupTimerInterrupt+0x1c>
80005212:	f0 1f 00 05 	mcall	80005224 <prvSetupTimerInterrupt+0x20>
		prvScheduleFirstTick();
80005216:	f0 1f 00 05 	mcall	80005228 <prvSetupTimerInterrupt+0x24>
	}
	#endif
}
8000521a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000521e:	00 00       	add	r0,r0
80005220:	80 00       	ld.sh	r0,r0[0x0]
80005222:	4e 84       	lddpc	r4,800053c0 <xQueueCreate+0x4>
80005224:	80 00       	ld.sh	r0,r0[0x0]
80005226:	45 04       	lddsp	r4,sp[0x140]
80005228:	80 00       	ld.sh	r0,r0[0x0]
8000522a:	51 d8       	stdsp	sp[0x74],r8

8000522c <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
8000522c:	eb cd 40 80 	pushm	r7,lr
80005230:	1a 97       	mov	r7,sp
80005232:	20 5d       	sub	sp,20
80005234:	ef 4c ff f4 	st.w	r7[-12],r12
80005238:	ef 4b ff f0 	st.w	r7[-16],r11
8000523c:	ef 4a ff ec 	st.w	r7[-20],r10
  int nChars = 0;
80005240:	30 08       	mov	r8,0
80005242:	ef 48 ff f8 	st.w	r7[-8],r8

  if (file != 0)
80005246:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000524a:	58 08       	cp.w	r8,0
8000524c:	c2 40       	breq	80005294 <_read+0x68>
    return -1;
8000524e:	3f f8       	mov	r8,-1
80005250:	c2 b8       	rjmp	800052a6 <_read+0x7a>

  for (; len > 0; --len)
  {
    int c = usart_getchar(stdio_usart_base);
80005252:	49 88       	lddpc	r8,800052b0 <_read+0x84>
80005254:	70 08       	ld.w	r8,r8[0x0]
80005256:	10 9c       	mov	r12,r8
80005258:	f0 1f 00 17 	mcall	800052b4 <_read+0x88>
8000525c:	18 98       	mov	r8,r12
8000525e:	ef 48 ff fc 	st.w	r7[-4],r8
    if (c < 0)
80005262:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005266:	58 08       	cp.w	r8,0
80005268:	c1 c5       	brlt	800052a0 <_read+0x74>
      break;

    *ptr++ = c;
8000526a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000526e:	5c 58       	castu.b	r8
80005270:	ee f9 ff f0 	ld.w	r9,r7[-16]
80005274:	b2 88       	st.b	r9[0x0],r8
80005276:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000527a:	2f f8       	sub	r8,-1
8000527c:	ef 48 ff f0 	st.w	r7[-16],r8
    ++nChars;
80005280:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005284:	2f f8       	sub	r8,-1
80005286:	ef 48 ff f8 	st.w	r7[-8],r8
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
8000528a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000528e:	20 18       	sub	r8,1
80005290:	ef 48 ff ec 	st.w	r7[-20],r8
80005294:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005298:	58 08       	cp.w	r8,0
8000529a:	fe 99 ff dc 	brgt	80005252 <_read+0x26>
8000529e:	c0 28       	rjmp	800052a2 <_read+0x76>
  {
    int c = usart_getchar(stdio_usart_base);
    if (c < 0)
      break;
800052a0:	d7 03       	nop

    *ptr++ = c;
    ++nChars;
  }

  return nChars;
800052a2:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800052a6:	10 9c       	mov	r12,r8
800052a8:	2f bd       	sub	sp,-20
800052aa:	e3 cd 80 80 	ldm	sp++,r7,pc
800052ae:	00 00       	add	r0,r0
800052b0:	00 00       	add	r0,r0
800052b2:	08 0c       	add	r12,r4
800052b4:	80 00       	ld.sh	r0,r0[0x0]
800052b6:	4b 8c       	lddpc	r12,80005394 <vPortFree+0x10>

800052b8 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
800052b8:	eb cd 40 80 	pushm	r7,lr
800052bc:	1a 97       	mov	r7,sp
800052be:	20 4d       	sub	sp,16
800052c0:	ef 4c ff f8 	st.w	r7[-8],r12
800052c4:	ef 4b ff f4 	st.w	r7[-12],r11
800052c8:	ef 4a ff f0 	st.w	r7[-16],r10
  int nChars = 0;
800052cc:	30 08       	mov	r8,0
800052ce:	ef 48 ff fc 	st.w	r7[-4],r8

  if ( (file != 1)
800052d2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800052d6:	58 18       	cp.w	r8,1
800052d8:	c2 90       	breq	8000532a <_write+0x72>
800052da:	ee f8 ff f8 	ld.w	r8,r7[-8]
800052de:	58 28       	cp.w	r8,2
800052e0:	c2 50       	breq	8000532a <_write+0x72>
800052e2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800052e6:	58 38       	cp.w	r8,3
800052e8:	c2 10       	breq	8000532a <_write+0x72>
       && (file != 2) && (file!=3))
    return -1;
800052ea:	3f f8       	mov	r8,-1
800052ec:	c2 58       	rjmp	80005336 <_write+0x7e>

  for (; len != 0; --len)
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
800052ee:	ee f8 ff f4 	ld.w	r8,r7[-12]
800052f2:	11 88       	ld.ub	r8,r8[0x0]
800052f4:	10 99       	mov	r9,r8
800052f6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800052fa:	2f f8       	sub	r8,-1
800052fc:	ef 48 ff f4 	st.w	r7[-12],r8
80005300:	49 08       	lddpc	r8,80005340 <_write+0x88>
80005302:	70 08       	ld.w	r8,r8[0x0]
80005304:	12 9b       	mov	r11,r9
80005306:	10 9c       	mov	r12,r8
80005308:	f0 1f 00 0f 	mcall	80005344 <_write+0x8c>
8000530c:	18 98       	mov	r8,r12
8000530e:	58 08       	cp.w	r8,0
80005310:	c0 34       	brge	80005316 <_write+0x5e>
    {
      return -1;
80005312:	3f f8       	mov	r8,-1
80005314:	c1 18       	rjmp	80005336 <_write+0x7e>
    }

    ++nChars;
80005316:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000531a:	2f f8       	sub	r8,-1
8000531c:	ef 48 ff fc 	st.w	r7[-4],r8

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005320:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005324:	20 18       	sub	r8,1
80005326:	ef 48 ff f0 	st.w	r7[-16],r8
8000532a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000532e:	58 08       	cp.w	r8,0
80005330:	cd f1       	brne	800052ee <_write+0x36>
    }

    ++nChars;
  }

  return nChars;
80005332:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005336:	10 9c       	mov	r12,r8
80005338:	2f cd       	sub	sp,-16
8000533a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000533e:	00 00       	add	r0,r0
80005340:	00 00       	add	r0,r0
80005342:	08 0c       	add	r12,r4
80005344:	80 00       	ld.sh	r0,r0[0x0]
80005346:	4a e4       	lddpc	r4,800053fc <xQueueCreate+0x40>

80005348 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005348:	eb cd 40 80 	pushm	r7,lr
8000534c:	1a 97       	mov	r7,sp
8000534e:	20 2d       	sub	sp,8
80005350:	ef 4c ff f8 	st.w	r7[-8],r12
void *pvReturn;

	vTaskSuspendAll();
80005354:	f0 1f 00 09 	mcall	80005378 <pvPortMalloc+0x30>
	{
		pvReturn = malloc( xWantedSize );
80005358:	ee fc ff f8 	ld.w	r12,r7[-8]
8000535c:	f0 1f 00 08 	mcall	8000537c <pvPortMalloc+0x34>
80005360:	18 98       	mov	r8,r12
80005362:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	xTaskResumeAll();
80005366:	f0 1f 00 07 	mcall	80005380 <pvPortMalloc+0x38>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
8000536a:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000536e:	10 9c       	mov	r12,r8
80005370:	2f ed       	sub	sp,-8
80005372:	e3 cd 80 80 	ldm	sp++,r7,pc
80005376:	00 00       	add	r0,r0
80005378:	80 00       	ld.sh	r0,r0[0x0]
8000537a:	5d 64       	*unknown*
8000537c:	80 00       	ld.sh	r0,r0[0x0]
8000537e:	69 0c       	ld.w	r12,r4[0x40]
80005380:	80 00       	ld.sh	r0,r0[0x0]
80005382:	5d 80       	*unknown*

80005384 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005384:	eb cd 40 80 	pushm	r7,lr
80005388:	1a 97       	mov	r7,sp
8000538a:	20 1d       	sub	sp,4
8000538c:	ef 4c ff fc 	st.w	r7[-4],r12
	if( pv )
80005390:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005394:	58 08       	cp.w	r8,0
80005396:	c0 90       	breq	800053a8 <vPortFree+0x24>
	{
		vTaskSuspendAll();
80005398:	f0 1f 00 06 	mcall	800053b0 <vPortFree+0x2c>
		{
			free( pv );
8000539c:	ee fc ff fc 	ld.w	r12,r7[-4]
800053a0:	f0 1f 00 05 	mcall	800053b4 <vPortFree+0x30>
		}
		xTaskResumeAll();
800053a4:	f0 1f 00 05 	mcall	800053b8 <vPortFree+0x34>
	}
}
800053a8:	2f fd       	sub	sp,-4
800053aa:	e3 cd 80 80 	ldm	sp++,r7,pc
800053ae:	00 00       	add	r0,r0
800053b0:	80 00       	ld.sh	r0,r0[0x0]
800053b2:	5d 64       	*unknown*
800053b4:	80 00       	ld.sh	r0,r0[0x0]
800053b6:	68 fc       	ld.w	r12,r4[0x3c]
800053b8:	80 00       	ld.sh	r0,r0[0x0]
800053ba:	5d 80       	*unknown*

800053bc <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800053bc:	eb cd 40 80 	pushm	r7,lr
800053c0:	1a 97       	mov	r7,sp
800053c2:	20 5d       	sub	sp,20
800053c4:	ef 4c ff f0 	st.w	r7[-16],r12
800053c8:	ef 4b ff ec 	st.w	r7[-20],r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
800053cc:	30 08       	mov	r8,0
800053ce:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800053d2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800053d6:	58 08       	cp.w	r8,0
800053d8:	c7 20       	breq	800054bc <xQueueCreate+0x100>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800053da:	34 cc       	mov	r12,76
800053dc:	f0 1f 00 3b 	mcall	800054c8 <xQueueCreate+0x10c>
800053e0:	18 98       	mov	r8,r12
800053e2:	ef 48 ff f4 	st.w	r7[-12],r8
		if( pxNewQueue != NULL )
800053e6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800053ea:	58 08       	cp.w	r8,0
800053ec:	c6 80       	breq	800054bc <xQueueCreate+0x100>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800053ee:	ee f9 ff f0 	ld.w	r9,r7[-16]
800053f2:	ee f8 ff ec 	ld.w	r8,r7[-20]
800053f6:	f2 08 02 48 	mul	r8,r9,r8
800053fa:	2f f8       	sub	r8,-1
800053fc:	ef 48 ff f8 	st.w	r7[-8],r8

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005400:	ee fc ff f8 	ld.w	r12,r7[-8]
80005404:	f0 1f 00 31 	mcall	800054c8 <xQueueCreate+0x10c>
80005408:	18 98       	mov	r8,r12
8000540a:	10 99       	mov	r9,r8
8000540c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005410:	91 09       	st.w	r8[0x0],r9
			if( pxNewQueue->pcHead != NULL )
80005412:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005416:	70 08       	ld.w	r8,r8[0x0]
80005418:	58 08       	cp.w	r8,0
8000541a:	c4 d0       	breq	800054b4 <xQueueCreate+0xf8>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000541c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005420:	70 09       	ld.w	r9,r8[0x0]
80005422:	ee fa ff f0 	ld.w	r10,r7[-16]
80005426:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000542a:	f4 08 02 48 	mul	r8,r10,r8
8000542e:	10 09       	add	r9,r8
80005430:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005434:	91 19       	st.w	r8[0x4],r9
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005436:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000543a:	30 09       	mov	r9,0
8000543c:	91 e9       	st.w	r8[0x38],r9
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000543e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005442:	70 09       	ld.w	r9,r8[0x0]
80005444:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005448:	91 29       	st.w	r8[0x8],r9
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000544a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000544e:	70 09       	ld.w	r9,r8[0x0]
80005450:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005454:	f0 ca 00 01 	sub	r10,r8,1
80005458:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000545c:	f4 08 02 48 	mul	r8,r10,r8
80005460:	10 09       	add	r9,r8
80005462:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005466:	91 39       	st.w	r8[0xc],r9
				pxNewQueue->uxLength = uxQueueLength;
80005468:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000546c:	ee f9 ff f0 	ld.w	r9,r7[-16]
80005470:	91 f9       	st.w	r8[0x3c],r9
				pxNewQueue->uxItemSize = uxItemSize;
80005472:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005476:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000547a:	f1 49 00 40 	st.w	r8[64],r9
				pxNewQueue->xRxLock = queueUNLOCKED;
8000547e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005482:	3f f9       	mov	r9,-1
80005484:	f1 49 00 44 	st.w	r8[68],r9
				pxNewQueue->xTxLock = queueUNLOCKED;
80005488:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000548c:	3f f9       	mov	r9,-1
8000548e:	f1 49 00 48 	st.w	r8[72],r9

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005492:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005496:	2f 08       	sub	r8,-16
80005498:	10 9c       	mov	r12,r8
8000549a:	f0 1f 00 0d 	mcall	800054cc <xQueueCreate+0x110>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000549e:	ee f8 ff f4 	ld.w	r8,r7[-12]
800054a2:	2d c8       	sub	r8,-36
800054a4:	10 9c       	mov	r12,r8
800054a6:	f0 1f 00 0a 	mcall	800054cc <xQueueCreate+0x110>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
800054aa:	ee f8 ff f4 	ld.w	r8,r7[-12]
800054ae:	ef 48 ff fc 	st.w	r7[-4],r8
800054b2:	c0 58       	rjmp	800054bc <xQueueCreate+0x100>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800054b4:	ee fc ff f4 	ld.w	r12,r7[-12]
800054b8:	f0 1f 00 06 	mcall	800054d0 <xQueueCreate+0x114>
		}
	}

	configASSERT( xReturn );

	return xReturn;
800054bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800054c0:	10 9c       	mov	r12,r8
800054c2:	2f bd       	sub	sp,-20
800054c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800054c8:	80 00       	ld.sh	r0,r0[0x0]
800054ca:	53 48       	stdsp	sp[0xd0],r8
800054cc:	80 00       	ld.sh	r0,r0[0x0]
800054ce:	4c 10       	lddpc	r0,800055d0 <xQueueGenericSend+0xb8>
800054d0:	80 00       	ld.sh	r0,r0[0x0]
800054d2:	53 84       	stdsp	sp[0xe0],r4

800054d4 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
800054d4:	eb cd 40 80 	pushm	r7,lr
800054d8:	1a 97       	mov	r7,sp
800054da:	20 3d       	sub	sp,12
800054dc:	ef 4c ff f8 	st.w	r7[-8],r12
800054e0:	ef 4b ff f4 	st.w	r7[-12],r11
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
800054e4:	30 0b       	mov	r11,0
800054e6:	ee fc ff f8 	ld.w	r12,r7[-8]
800054ea:	f0 1f 00 0b 	mcall	80005514 <xQueueCreateCountingSemaphore+0x40>
800054ee:	18 98       	mov	r8,r12
800054f0:	ef 48 ff fc 	st.w	r7[-4],r8

		if( pxHandle != NULL )
800054f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800054f8:	58 08       	cp.w	r8,0
800054fa:	c0 60       	breq	80005506 <xQueueCreateCountingSemaphore+0x32>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
800054fc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005500:	ee f9 ff f4 	ld.w	r9,r7[-12]
80005504:	91 e9       	st.w	r8[0x38],r9
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
80005506:	ee f8 ff fc 	ld.w	r8,r7[-4]
	}
8000550a:	10 9c       	mov	r12,r8
8000550c:	2f dd       	sub	sp,-12
8000550e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005512:	00 00       	add	r0,r0
80005514:	80 00       	ld.sh	r0,r0[0x0]
80005516:	53 bc       	stdsp	sp[0xec],r12

80005518 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005518:	eb cd 40 80 	pushm	r7,lr
8000551c:	1a 97       	mov	r7,sp
8000551e:	20 7d       	sub	sp,28
80005520:	ef 4c ff f0 	st.w	r7[-16],r12
80005524:	ef 4b ff ec 	st.w	r7[-20],r11
80005528:	ef 4a ff e8 	st.w	r7[-24],r10
8000552c:	ef 49 ff e4 	st.w	r7[-28],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
80005530:	30 08       	mov	r8,0
80005532:	ef 48 ff fc 	st.w	r7[-4],r8
80005536:	c0 28       	rjmp	8000553a <xQueueGenericSend+0x22>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80005538:	d7 03       	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000553a:	f0 1f 00 47 	mcall	80005654 <xQueueGenericSend+0x13c>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000553e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005542:	70 e9       	ld.w	r9,r8[0x38]
80005544:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005548:	70 f8       	ld.w	r8,r8[0x3c]
8000554a:	10 39       	cp.w	r9,r8
8000554c:	c1 c2       	brcc	80005584 <xQueueGenericSend+0x6c>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000554e:	ee fa ff e4 	ld.w	r10,r7[-28]
80005552:	ee fb ff ec 	ld.w	r11,r7[-20]
80005556:	ee fc ff f0 	ld.w	r12,r7[-16]
8000555a:	f0 1f 00 40 	mcall	80005658 <xQueueGenericSend+0x140>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000555e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005562:	70 98       	ld.w	r8,r8[0x24]
80005564:	58 08       	cp.w	r8,0
80005566:	c0 b0       	breq	8000557c <xQueueGenericSend+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005568:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000556c:	2d c8       	sub	r8,-36
8000556e:	10 9c       	mov	r12,r8
80005570:	f0 1f 00 3b 	mcall	8000565c <xQueueGenericSend+0x144>
80005574:	18 98       	mov	r8,r12
80005576:	58 18       	cp.w	r8,1
80005578:	c0 21       	brne	8000557c <xQueueGenericSend+0x64>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
8000557a:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
8000557c:	f0 1f 00 39 	mcall	80005660 <xQueueGenericSend+0x148>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005580:	30 18       	mov	r8,1
80005582:	c6 58       	rjmp	8000564c <xQueueGenericSend+0x134>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005584:	ee f8 ff e8 	ld.w	r8,r7[-24]
80005588:	58 08       	cp.w	r8,0
8000558a:	c0 51       	brne	80005594 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000558c:	f0 1f 00 35 	mcall	80005660 <xQueueGenericSend+0x148>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005590:	30 08       	mov	r8,0
80005592:	c5 d8       	rjmp	8000564c <xQueueGenericSend+0x134>
				}
				else if( xEntryTimeSet == pdFALSE )
80005594:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005598:	58 08       	cp.w	r8,0
8000559a:	c0 91       	brne	800055ac <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000559c:	ee c8 00 0c 	sub	r8,r7,12
800055a0:	10 9c       	mov	r12,r8
800055a2:	f0 1f 00 31 	mcall	80005664 <xQueueGenericSend+0x14c>
					xEntryTimeSet = pdTRUE;
800055a6:	30 18       	mov	r8,1
800055a8:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}
		}
		taskEXIT_CRITICAL();
800055ac:	f0 1f 00 2d 	mcall	80005660 <xQueueGenericSend+0x148>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800055b0:	f0 1f 00 2e 	mcall	80005668 <xQueueGenericSend+0x150>
		prvLockQueue( pxQueue );
800055b4:	f0 1f 00 28 	mcall	80005654 <xQueueGenericSend+0x13c>
800055b8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800055bc:	71 18       	ld.w	r8,r8[0x44]
800055be:	5b f8       	cp.w	r8,-1
800055c0:	c0 61       	brne	800055cc <xQueueGenericSend+0xb4>
800055c2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800055c6:	30 09       	mov	r9,0
800055c8:	f1 49 00 44 	st.w	r8[68],r9
800055cc:	ee f8 ff f0 	ld.w	r8,r7[-16]
800055d0:	71 28       	ld.w	r8,r8[0x48]
800055d2:	5b f8       	cp.w	r8,-1
800055d4:	c0 61       	brne	800055e0 <xQueueGenericSend+0xc8>
800055d6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800055da:	30 09       	mov	r9,0
800055dc:	f1 49 00 48 	st.w	r8[72],r9
800055e0:	f0 1f 00 20 	mcall	80005660 <xQueueGenericSend+0x148>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800055e4:	ee c9 00 18 	sub	r9,r7,24
800055e8:	ee c8 00 0c 	sub	r8,r7,12
800055ec:	12 9b       	mov	r11,r9
800055ee:	10 9c       	mov	r12,r8
800055f0:	f0 1f 00 1f 	mcall	8000566c <xQueueGenericSend+0x154>
800055f4:	18 98       	mov	r8,r12
800055f6:	58 08       	cp.w	r8,0
800055f8:	c2 31       	brne	8000563e <xQueueGenericSend+0x126>
		{
			if( prvIsQueueFull( pxQueue ) )
800055fa:	ee fc ff f0 	ld.w	r12,r7[-16]
800055fe:	f0 1f 00 1d 	mcall	80005670 <xQueueGenericSend+0x158>
80005602:	18 98       	mov	r8,r12
80005604:	58 08       	cp.w	r8,0
80005606:	c1 50       	breq	80005630 <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005608:	ee f9 ff e8 	ld.w	r9,r7[-24]
8000560c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005610:	2f 08       	sub	r8,-16
80005612:	12 9b       	mov	r11,r9
80005614:	10 9c       	mov	r12,r8
80005616:	f0 1f 00 18 	mcall	80005674 <xQueueGenericSend+0x15c>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000561a:	ee fc ff f0 	ld.w	r12,r7[-16]
8000561e:	f0 1f 00 17 	mcall	80005678 <xQueueGenericSend+0x160>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005622:	f0 1f 00 17 	mcall	8000567c <xQueueGenericSend+0x164>
80005626:	18 98       	mov	r8,r12
80005628:	58 08       	cp.w	r8,0
8000562a:	c8 71       	brne	80005538 <xQueueGenericSend+0x20>
				{
					portYIELD_WITHIN_API();
8000562c:	d7 33       	scall
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
8000562e:	c8 6b       	rjmp	8000553a <xQueueGenericSend+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005630:	ee fc ff f0 	ld.w	r12,r7[-16]
80005634:	f0 1f 00 11 	mcall	80005678 <xQueueGenericSend+0x160>
				( void ) xTaskResumeAll();
80005638:	f0 1f 00 11 	mcall	8000567c <xQueueGenericSend+0x164>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
8000563c:	c7 fb       	rjmp	8000553a <xQueueGenericSend+0x22>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000563e:	ee fc ff f0 	ld.w	r12,r7[-16]
80005642:	f0 1f 00 0e 	mcall	80005678 <xQueueGenericSend+0x160>
			( void ) xTaskResumeAll();
80005646:	f0 1f 00 0e 	mcall	8000567c <xQueueGenericSend+0x164>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
8000564a:	30 08       	mov	r8,0
		}
	}
}
8000564c:	10 9c       	mov	r12,r8
8000564e:	2f 9d       	sub	sp,-28
80005650:	e3 cd 80 80 	ldm	sp++,r7,pc
80005654:	80 00       	ld.sh	r0,r0[0x0]
80005656:	4f a0       	lddpc	r0,8000583c <prvCopyDataToQueue+0x10>
80005658:	80 00       	ld.sh	r0,r0[0x0]
8000565a:	58 2c       	cp.w	r12,2
8000565c:	80 00       	ld.sh	r0,r0[0x0]
8000565e:	61 68       	ld.w	r8,r0[0x58]
80005660:	80 00       	ld.sh	r0,r0[0x0]
80005662:	4f bc       	lddpc	r12,8000584c <prvCopyDataToQueue+0x20>
80005664:	80 00       	ld.sh	r0,r0[0x0]
80005666:	62 38       	ld.w	r8,r1[0xc]
80005668:	80 00       	ld.sh	r0,r0[0x0]
8000566a:	5d 64       	*unknown*
8000566c:	80 00       	ld.sh	r0,r0[0x0]
8000566e:	62 68       	ld.w	r8,r1[0x18]
80005670:	80 00       	ld.sh	r0,r0[0x0]
80005672:	5a 80       	cp.w	r0,-24
80005674:	80 00       	ld.sh	r0,r0[0x0]
80005676:	60 e8       	ld.w	r8,r0[0x38]
80005678:	80 00       	ld.sh	r0,r0[0x0]
8000567a:	59 78       	cp.w	r8,23
8000567c:	80 00       	ld.sh	r0,r0[0x0]
8000567e:	5d 80       	*unknown*

80005680 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005680:	eb cd 40 80 	pushm	r7,lr
80005684:	1a 97       	mov	r7,sp
80005686:	20 8d       	sub	sp,32
80005688:	ef 4c ff ec 	st.w	r7[-20],r12
8000568c:	ef 4b ff e8 	st.w	r7[-24],r11
80005690:	ef 4a ff e4 	st.w	r7[-28],r10
80005694:	ef 49 ff e0 	st.w	r7[-32],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
80005698:	30 08       	mov	r8,0
8000569a:	ef 48 ff f8 	st.w	r7[-8],r8
8000569e:	c0 28       	rjmp	800056a2 <xQueueGenericReceive+0x22>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800056a0:	d7 03       	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800056a2:	f0 1f 00 58 	mcall	80005800 <xQueueGenericReceive+0x180>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800056a6:	ee f8 ff ec 	ld.w	r8,r7[-20]
800056aa:	70 e8       	ld.w	r8,r8[0x38]
800056ac:	58 08       	cp.w	r8,0
800056ae:	c4 00       	breq	8000572e <xQueueGenericReceive+0xae>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800056b0:	ee f8 ff ec 	ld.w	r8,r7[-20]
800056b4:	70 38       	ld.w	r8,r8[0xc]
800056b6:	ef 48 ff fc 	st.w	r7[-4],r8

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800056ba:	ee fb ff e8 	ld.w	r11,r7[-24]
800056be:	ee fc ff ec 	ld.w	r12,r7[-20]
800056c2:	f0 1f 00 51 	mcall	80005804 <xQueueGenericReceive+0x184>

				if( xJustPeeking == pdFALSE )
800056c6:	ee f8 ff e0 	ld.w	r8,r7[-32]
800056ca:	58 08       	cp.w	r8,0
800056cc:	c1 91       	brne	800056fe <xQueueGenericReceive+0x7e>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800056ce:	ee f8 ff ec 	ld.w	r8,r7[-20]
800056d2:	70 e8       	ld.w	r8,r8[0x38]
800056d4:	f0 c9 00 01 	sub	r9,r8,1
800056d8:	ee f8 ff ec 	ld.w	r8,r7[-20]
800056dc:	91 e9       	st.w	r8[0x38],r9
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800056de:	ee f8 ff ec 	ld.w	r8,r7[-20]
800056e2:	70 48       	ld.w	r8,r8[0x10]
800056e4:	58 08       	cp.w	r8,0
800056e6:	c2 00       	breq	80005726 <xQueueGenericReceive+0xa6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800056e8:	ee f8 ff ec 	ld.w	r8,r7[-20]
800056ec:	2f 08       	sub	r8,-16
800056ee:	10 9c       	mov	r12,r8
800056f0:	f0 1f 00 46 	mcall	80005808 <xQueueGenericReceive+0x188>
800056f4:	18 98       	mov	r8,r12
800056f6:	58 18       	cp.w	r8,1
800056f8:	c1 71       	brne	80005726 <xQueueGenericReceive+0xa6>
						{
							portYIELD_WITHIN_API();
800056fa:	d7 33       	scall
800056fc:	c1 58       	rjmp	80005726 <xQueueGenericReceive+0xa6>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800056fe:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005702:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005706:	91 39       	st.w	r8[0xc],r9

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005708:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000570c:	70 98       	ld.w	r8,r8[0x24]
8000570e:	58 08       	cp.w	r8,0
80005710:	c0 b0       	breq	80005726 <xQueueGenericReceive+0xa6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005712:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005716:	2d c8       	sub	r8,-36
80005718:	10 9c       	mov	r12,r8
8000571a:	f0 1f 00 3c 	mcall	80005808 <xQueueGenericReceive+0x188>
8000571e:	18 98       	mov	r8,r12
80005720:	58 08       	cp.w	r8,0
80005722:	c0 20       	breq	80005726 <xQueueGenericReceive+0xa6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005724:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005726:	f0 1f 00 3a 	mcall	8000580c <xQueueGenericReceive+0x18c>
				return pdPASS;
8000572a:	30 18       	mov	r8,1
8000572c:	c6 68       	rjmp	800057f8 <xQueueGenericReceive+0x178>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000572e:	ee f8 ff e4 	ld.w	r8,r7[-28]
80005732:	58 08       	cp.w	r8,0
80005734:	c0 51       	brne	8000573e <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005736:	f0 1f 00 36 	mcall	8000580c <xQueueGenericReceive+0x18c>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000573a:	30 08       	mov	r8,0
8000573c:	c5 e8       	rjmp	800057f8 <xQueueGenericReceive+0x178>
				}
				else if( xEntryTimeSet == pdFALSE )
8000573e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005742:	58 08       	cp.w	r8,0
80005744:	c0 91       	brne	80005756 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005746:	ee c8 00 10 	sub	r8,r7,16
8000574a:	10 9c       	mov	r12,r8
8000574c:	f0 1f 00 31 	mcall	80005810 <xQueueGenericReceive+0x190>
					xEntryTimeSet = pdTRUE;
80005750:	30 18       	mov	r8,1
80005752:	ef 48 ff f8 	st.w	r7[-8],r8
				}
			}
		}
		taskEXIT_CRITICAL();
80005756:	f0 1f 00 2e 	mcall	8000580c <xQueueGenericReceive+0x18c>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000575a:	f0 1f 00 2f 	mcall	80005814 <xQueueGenericReceive+0x194>
		prvLockQueue( pxQueue );
8000575e:	f0 1f 00 29 	mcall	80005800 <xQueueGenericReceive+0x180>
80005762:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005766:	71 18       	ld.w	r8,r8[0x44]
80005768:	5b f8       	cp.w	r8,-1
8000576a:	c0 61       	brne	80005776 <xQueueGenericReceive+0xf6>
8000576c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005770:	30 09       	mov	r9,0
80005772:	f1 49 00 44 	st.w	r8[68],r9
80005776:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000577a:	71 28       	ld.w	r8,r8[0x48]
8000577c:	5b f8       	cp.w	r8,-1
8000577e:	c0 61       	brne	8000578a <xQueueGenericReceive+0x10a>
80005780:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005784:	30 09       	mov	r9,0
80005786:	f1 49 00 48 	st.w	r8[72],r9
8000578a:	f0 1f 00 21 	mcall	8000580c <xQueueGenericReceive+0x18c>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000578e:	ee c9 00 1c 	sub	r9,r7,28
80005792:	ee c8 00 10 	sub	r8,r7,16
80005796:	12 9b       	mov	r11,r9
80005798:	10 9c       	mov	r12,r8
8000579a:	f0 1f 00 20 	mcall	80005818 <xQueueGenericReceive+0x198>
8000579e:	18 98       	mov	r8,r12
800057a0:	58 08       	cp.w	r8,0
800057a2:	c2 41       	brne	800057ea <xQueueGenericReceive+0x16a>
		{
			if( prvIsQueueEmpty( pxQueue ) )
800057a4:	ee fc ff ec 	ld.w	r12,r7[-20]
800057a8:	f0 1f 00 1d 	mcall	8000581c <xQueueGenericReceive+0x19c>
800057ac:	18 98       	mov	r8,r12
800057ae:	58 08       	cp.w	r8,0
800057b0:	c1 60       	breq	800057dc <xQueueGenericReceive+0x15c>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800057b2:	ee f9 ff e4 	ld.w	r9,r7[-28]
800057b6:	ee f8 ff ec 	ld.w	r8,r7[-20]
800057ba:	2d c8       	sub	r8,-36
800057bc:	12 9b       	mov	r11,r9
800057be:	10 9c       	mov	r12,r8
800057c0:	f0 1f 00 18 	mcall	80005820 <xQueueGenericReceive+0x1a0>
				prvUnlockQueue( pxQueue );
800057c4:	ee fc ff ec 	ld.w	r12,r7[-20]
800057c8:	f0 1f 00 17 	mcall	80005824 <xQueueGenericReceive+0x1a4>
				if( !xTaskResumeAll() )
800057cc:	f0 1f 00 17 	mcall	80005828 <xQueueGenericReceive+0x1a8>
800057d0:	18 98       	mov	r8,r12
800057d2:	58 08       	cp.w	r8,0
800057d4:	fe 91 ff 66 	brne	800056a0 <xQueueGenericReceive+0x20>
				{
					portYIELD_WITHIN_API();
800057d8:	d7 33       	scall
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800057da:	c6 4b       	rjmp	800056a2 <xQueueGenericReceive+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800057dc:	ee fc ff ec 	ld.w	r12,r7[-20]
800057e0:	f0 1f 00 11 	mcall	80005824 <xQueueGenericReceive+0x1a4>
				( void ) xTaskResumeAll();
800057e4:	f0 1f 00 11 	mcall	80005828 <xQueueGenericReceive+0x1a8>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800057e8:	c5 db       	rjmp	800056a2 <xQueueGenericReceive+0x22>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800057ea:	ee fc ff ec 	ld.w	r12,r7[-20]
800057ee:	f0 1f 00 0e 	mcall	80005824 <xQueueGenericReceive+0x1a4>
			( void ) xTaskResumeAll();
800057f2:	f0 1f 00 0e 	mcall	80005828 <xQueueGenericReceive+0x1a8>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
800057f6:	30 08       	mov	r8,0
		}
	}
}
800057f8:	10 9c       	mov	r12,r8
800057fa:	2f 8d       	sub	sp,-32
800057fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80005800:	80 00       	ld.sh	r0,r0[0x0]
80005802:	4f a0       	lddpc	r0,800059e8 <prvUnlockQueue+0x70>
80005804:	80 00       	ld.sh	r0,r0[0x0]
80005806:	59 0c       	cp.w	r12,16
80005808:	80 00       	ld.sh	r0,r0[0x0]
8000580a:	61 68       	ld.w	r8,r0[0x58]
8000580c:	80 00       	ld.sh	r0,r0[0x0]
8000580e:	4f bc       	lddpc	r12,800059f8 <prvUnlockQueue+0x80>
80005810:	80 00       	ld.sh	r0,r0[0x0]
80005812:	62 38       	ld.w	r8,r1[0xc]
80005814:	80 00       	ld.sh	r0,r0[0x0]
80005816:	5d 64       	*unknown*
80005818:	80 00       	ld.sh	r0,r0[0x0]
8000581a:	62 68       	ld.w	r8,r1[0x18]
8000581c:	80 00       	ld.sh	r0,r0[0x0]
8000581e:	5a 48       	cp.w	r8,-28
80005820:	80 00       	ld.sh	r0,r0[0x0]
80005822:	60 e8       	ld.w	r8,r0[0x38]
80005824:	80 00       	ld.sh	r0,r0[0x0]
80005826:	59 78       	cp.w	r8,23
80005828:	80 00       	ld.sh	r0,r0[0x0]
8000582a:	5d 80       	*unknown*

8000582c <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
8000582c:	eb cd 40 80 	pushm	r7,lr
80005830:	1a 97       	mov	r7,sp
80005832:	20 3d       	sub	sp,12
80005834:	ef 4c ff fc 	st.w	r7[-4],r12
80005838:	ef 4b ff f8 	st.w	r7[-8],r11
8000583c:	ef 4a ff f4 	st.w	r7[-12],r10
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005840:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005844:	71 08       	ld.w	r8,r8[0x40]
80005846:	58 08       	cp.w	r8,0
80005848:	c5 40       	breq	800058f0 <prvCopyDataToQueue+0xc4>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000584a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000584e:	58 08       	cp.w	r8,0
80005850:	c2 61       	brne	8000589c <prvCopyDataToQueue+0x70>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005852:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005856:	71 09       	ld.w	r9,r8[0x40]
80005858:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000585c:	70 28       	ld.w	r8,r8[0x8]
8000585e:	12 9a       	mov	r10,r9
80005860:	ee fb ff f8 	ld.w	r11,r7[-8]
80005864:	10 9c       	mov	r12,r8
80005866:	f0 1f 00 29 	mcall	80005908 <prvCopyDataToQueue+0xdc>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000586a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000586e:	70 29       	ld.w	r9,r8[0x8]
80005870:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005874:	71 08       	ld.w	r8,r8[0x40]
80005876:	10 09       	add	r9,r8
80005878:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000587c:	91 29       	st.w	r8[0x8],r9
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000587e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005882:	70 29       	ld.w	r9,r8[0x8]
80005884:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005888:	70 18       	ld.w	r8,r8[0x4]
8000588a:	10 39       	cp.w	r9,r8
8000588c:	c3 23       	brcs	800058f0 <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000588e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005892:	70 09       	ld.w	r9,r8[0x0]
80005894:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005898:	91 29       	st.w	r8[0x8],r9
8000589a:	c2 b8       	rjmp	800058f0 <prvCopyDataToQueue+0xc4>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000589c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058a0:	71 09       	ld.w	r9,r8[0x40]
800058a2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058a6:	70 38       	ld.w	r8,r8[0xc]
800058a8:	12 9a       	mov	r10,r9
800058aa:	ee fb ff f8 	ld.w	r11,r7[-8]
800058ae:	10 9c       	mov	r12,r8
800058b0:	f0 1f 00 16 	mcall	80005908 <prvCopyDataToQueue+0xdc>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800058b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058b8:	70 39       	ld.w	r9,r8[0xc]
800058ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058be:	71 08       	ld.w	r8,r8[0x40]
800058c0:	5c 38       	neg	r8
800058c2:	10 09       	add	r9,r8
800058c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058c8:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800058ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058ce:	70 39       	ld.w	r9,r8[0xc]
800058d0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058d4:	70 08       	ld.w	r8,r8[0x0]
800058d6:	10 39       	cp.w	r9,r8
800058d8:	c0 c2       	brcc	800058f0 <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800058da:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058de:	70 19       	ld.w	r9,r8[0x4]
800058e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058e4:	71 08       	ld.w	r8,r8[0x40]
800058e6:	5c 38       	neg	r8
800058e8:	10 09       	add	r9,r8
800058ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058ee:	91 39       	st.w	r8[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800058f0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058f4:	70 e8       	ld.w	r8,r8[0x38]
800058f6:	f0 c9 ff ff 	sub	r9,r8,-1
800058fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058fe:	91 e9       	st.w	r8[0x38],r9
}
80005900:	2f dd       	sub	sp,-12
80005902:	e3 cd 80 80 	ldm	sp++,r7,pc
80005906:	00 00       	add	r0,r0
80005908:	80 00       	ld.sh	r0,r0[0x0]
8000590a:	6d 54       	ld.w	r4,r6[0x54]

8000590c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
8000590c:	eb cd 40 80 	pushm	r7,lr
80005910:	1a 97       	mov	r7,sp
80005912:	20 2d       	sub	sp,8
80005914:	ef 4c ff fc 	st.w	r7[-4],r12
80005918:	ef 4b ff f8 	st.w	r7[-8],r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
8000591c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005920:	70 08       	ld.w	r8,r8[0x0]
80005922:	58 08       	cp.w	r8,0
80005924:	c2 50       	breq	8000596e <prvCopyDataFromQueue+0x62>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005926:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000592a:	70 39       	ld.w	r9,r8[0xc]
8000592c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005930:	71 08       	ld.w	r8,r8[0x40]
80005932:	10 09       	add	r9,r8
80005934:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005938:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
8000593a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000593e:	70 39       	ld.w	r9,r8[0xc]
80005940:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005944:	70 18       	ld.w	r8,r8[0x4]
80005946:	10 39       	cp.w	r9,r8
80005948:	c0 73       	brcs	80005956 <prvCopyDataFromQueue+0x4a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000594a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000594e:	70 09       	ld.w	r9,r8[0x0]
80005950:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005954:	91 39       	st.w	r8[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005956:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000595a:	71 09       	ld.w	r9,r8[0x40]
8000595c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005960:	70 38       	ld.w	r8,r8[0xc]
80005962:	12 9a       	mov	r10,r9
80005964:	10 9b       	mov	r11,r8
80005966:	ee fc ff f8 	ld.w	r12,r7[-8]
8000596a:	f0 1f 00 03 	mcall	80005974 <prvCopyDataFromQueue+0x68>
	}
}
8000596e:	2f ed       	sub	sp,-8
80005970:	e3 cd 80 80 	ldm	sp++,r7,pc
80005974:	80 00       	ld.sh	r0,r0[0x0]
80005976:	6d 54       	ld.w	r4,r6[0x54]

80005978 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005978:	eb cd 40 80 	pushm	r7,lr
8000597c:	1a 97       	mov	r7,sp
8000597e:	20 1d       	sub	sp,4
80005980:	ef 4c ff fc 	st.w	r7[-4],r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005984:	f0 1f 00 2d 	mcall	80005a38 <prvUnlockQueue+0xc0>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005988:	c1 a8       	rjmp	800059bc <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000598a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000598e:	70 98       	ld.w	r8,r8[0x24]
80005990:	58 08       	cp.w	r8,0
80005992:	c1 c0       	breq	800059ca <prvUnlockQueue+0x52>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005994:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005998:	2d c8       	sub	r8,-36
8000599a:	10 9c       	mov	r12,r8
8000599c:	f0 1f 00 28 	mcall	80005a3c <prvUnlockQueue+0xc4>
800059a0:	18 98       	mov	r8,r12
800059a2:	58 08       	cp.w	r8,0
800059a4:	c0 30       	breq	800059aa <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800059a6:	f0 1f 00 27 	mcall	80005a40 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xTxLock );
800059aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059ae:	71 28       	ld.w	r8,r8[0x48]
800059b0:	f0 c9 00 01 	sub	r9,r8,1
800059b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059b8:	f1 49 00 48 	st.w	r8[72],r9
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800059bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059c0:	71 28       	ld.w	r8,r8[0x48]
800059c2:	58 08       	cp.w	r8,0
800059c4:	fe 99 ff e3 	brgt	8000598a <prvUnlockQueue+0x12>
800059c8:	c0 28       	rjmp	800059cc <prvUnlockQueue+0x54>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
800059ca:	d7 03       	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800059cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059d0:	3f f9       	mov	r9,-1
800059d2:	f1 49 00 48 	st.w	r8[72],r9
	}
	taskEXIT_CRITICAL();
800059d6:	f0 1f 00 1c 	mcall	80005a44 <prvUnlockQueue+0xcc>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800059da:	f0 1f 00 18 	mcall	80005a38 <prvUnlockQueue+0xc0>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800059de:	c1 a8       	rjmp	80005a12 <prvUnlockQueue+0x9a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800059e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059e4:	70 48       	ld.w	r8,r8[0x10]
800059e6:	58 08       	cp.w	r8,0
800059e8:	c1 c0       	breq	80005a20 <prvUnlockQueue+0xa8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800059ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059ee:	2f 08       	sub	r8,-16
800059f0:	10 9c       	mov	r12,r8
800059f2:	f0 1f 00 13 	mcall	80005a3c <prvUnlockQueue+0xc4>
800059f6:	18 98       	mov	r8,r12
800059f8:	58 08       	cp.w	r8,0
800059fa:	c0 30       	breq	80005a00 <prvUnlockQueue+0x88>
				{
					vTaskMissedYield();
800059fc:	f0 1f 00 11 	mcall	80005a40 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xRxLock );
80005a00:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005a04:	71 18       	ld.w	r8,r8[0x44]
80005a06:	f0 c9 00 01 	sub	r9,r8,1
80005a0a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005a0e:	f1 49 00 44 	st.w	r8[68],r9
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005a12:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005a16:	71 18       	ld.w	r8,r8[0x44]
80005a18:	58 08       	cp.w	r8,0
80005a1a:	fe 99 ff e3 	brgt	800059e0 <prvUnlockQueue+0x68>
80005a1e:	c0 28       	rjmp	80005a22 <prvUnlockQueue+0xaa>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
80005a20:	d7 03       	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005a22:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005a26:	3f f9       	mov	r9,-1
80005a28:	f1 49 00 44 	st.w	r8[68],r9
	}
	taskEXIT_CRITICAL();
80005a2c:	f0 1f 00 06 	mcall	80005a44 <prvUnlockQueue+0xcc>
}
80005a30:	2f fd       	sub	sp,-4
80005a32:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a36:	00 00       	add	r0,r0
80005a38:	80 00       	ld.sh	r0,r0[0x0]
80005a3a:	4f a0       	lddpc	r0,80005c20 <xTaskGenericCreate+0x15c>
80005a3c:	80 00       	ld.sh	r0,r0[0x0]
80005a3e:	61 68       	ld.w	r8,r0[0x58]
80005a40:	80 00       	ld.sh	r0,r0[0x0]
80005a42:	63 20       	ld.w	r0,r1[0x48]
80005a44:	80 00       	ld.sh	r0,r0[0x0]
80005a46:	4f bc       	lddpc	r12,80005c30 <xTaskGenericCreate+0x16c>

80005a48 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
80005a48:	eb cd 40 80 	pushm	r7,lr
80005a4c:	1a 97       	mov	r7,sp
80005a4e:	20 2d       	sub	sp,8
80005a50:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005a54:	f0 1f 00 09 	mcall	80005a78 <prvIsQueueEmpty+0x30>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005a58:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005a5c:	70 e8       	ld.w	r8,r8[0x38]
80005a5e:	58 08       	cp.w	r8,0
80005a60:	5f 08       	sreq	r8
80005a62:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80005a66:	f0 1f 00 06 	mcall	80005a7c <prvIsQueueEmpty+0x34>

	return xReturn;
80005a6a:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005a6e:	10 9c       	mov	r12,r8
80005a70:	2f ed       	sub	sp,-8
80005a72:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a76:	00 00       	add	r0,r0
80005a78:	80 00       	ld.sh	r0,r0[0x0]
80005a7a:	4f a0       	lddpc	r0,80005c60 <xTaskGenericCreate+0x19c>
80005a7c:	80 00       	ld.sh	r0,r0[0x0]
80005a7e:	4f bc       	lddpc	r12,80005c68 <xTaskGenericCreate+0x1a4>

80005a80 <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
80005a80:	eb cd 40 80 	pushm	r7,lr
80005a84:	1a 97       	mov	r7,sp
80005a86:	20 2d       	sub	sp,8
80005a88:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005a8c:	f0 1f 00 0a 	mcall	80005ab4 <prvIsQueueFull+0x34>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005a90:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005a94:	70 e9       	ld.w	r9,r8[0x38]
80005a96:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005a9a:	70 f8       	ld.w	r8,r8[0x3c]
80005a9c:	10 39       	cp.w	r9,r8
80005a9e:	5f 08       	sreq	r8
80005aa0:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80005aa4:	f0 1f 00 05 	mcall	80005ab8 <prvIsQueueFull+0x38>

	return xReturn;
80005aa8:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005aac:	10 9c       	mov	r12,r8
80005aae:	2f ed       	sub	sp,-8
80005ab0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ab4:	80 00       	ld.sh	r0,r0[0x0]
80005ab6:	4f a0       	lddpc	r0,80005c9c <vTaskDelay+0x10>
80005ab8:	80 00       	ld.sh	r0,r0[0x0]
80005aba:	4f bc       	lddpc	r12,80005ca4 <vTaskDelay+0x18>
80005abc:	49 44       	lddpc	r4,80005b0c <xTaskGenericCreate+0x48>
80005abe:	4c 45       	lddpc	r5,80005bcc <xTaskGenericCreate+0x108>
80005ac0:	00 00       	add	r0,r0
	...

80005ac4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005ac4:	eb cd 40 c0 	pushm	r6-r7,lr
80005ac8:	1a 97       	mov	r7,sp
80005aca:	20 8d       	sub	sp,32
80005acc:	ee c6 ff f4 	sub	r6,r7,-12
80005ad0:	ef 4c ff f0 	st.w	r7[-16],r12
80005ad4:	ef 4b ff ec 	st.w	r7[-20],r11
80005ad8:	ef 49 ff e4 	st.w	r7[-28],r9
80005adc:	ef 48 ff e0 	st.w	r7[-32],r8
80005ae0:	14 98       	mov	r8,r10
80005ae2:	ef 58 ff e8 	st.h	r7[-24],r8
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
80005ae6:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80005aea:	6c 1b       	ld.w	r11,r6[0x4]
80005aec:	10 9c       	mov	r12,r8
80005aee:	f0 1f 00 5a 	mcall	80005c54 <xTaskGenericCreate+0x190>
80005af2:	18 98       	mov	r8,r12
80005af4:	ef 48 ff f8 	st.w	r7[-8],r8

	if( pxNewTCB != NULL )
80005af8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005afc:	58 08       	cp.w	r8,0
80005afe:	e0 80 00 92 	breq	80005c22 <xTaskGenericCreate+0x15e>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
80005b02:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005b06:	70 c9       	ld.w	r9,r8[0x30]
80005b08:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80005b0c:	20 18       	sub	r8,1
80005b0e:	a3 68       	lsl	r8,0x2
80005b10:	f2 08 00 08 	add	r8,r9,r8
80005b14:	ef 48 ff fc 	st.w	r7[-4],r8
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005b18:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b1c:	e0 18 ff fc 	andl	r8,0xfffc
80005b20:	ef 48 ff fc 	st.w	r7[-4],r8
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
80005b24:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80005b28:	6c 29       	ld.w	r9,r6[0x8]
80005b2a:	ee fa ff e0 	ld.w	r10,r7[-32]
80005b2e:	ee fb ff ec 	ld.w	r11,r7[-20]
80005b32:	ee fc ff f8 	ld.w	r12,r7[-8]
80005b36:	f0 1f 00 49 	mcall	80005c58 <xTaskGenericCreate+0x194>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005b3a:	ee fa ff e4 	ld.w	r10,r7[-28]
80005b3e:	ee fb ff f0 	ld.w	r11,r7[-16]
80005b42:	ee fc ff fc 	ld.w	r12,r7[-4]
80005b46:	f0 1f 00 46 	mcall	80005c5c <xTaskGenericCreate+0x198>
80005b4a:	18 98       	mov	r8,r12
80005b4c:	10 99       	mov	r9,r8
80005b4e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005b52:	91 09       	st.w	r8[0x0],r9
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
80005b54:	6c 08       	ld.w	r8,r6[0x0]
80005b56:	58 08       	cp.w	r8,0
80005b58:	c0 50       	breq	80005b62 <xTaskGenericCreate+0x9e>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005b5a:	6c 08       	ld.w	r8,r6[0x0]
80005b5c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005b60:	91 09       	st.w	r8[0x0],r9
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005b62:	f0 1f 00 40 	mcall	80005c60 <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
80005b66:	4c 08       	lddpc	r8,80005c64 <xTaskGenericCreate+0x1a0>
80005b68:	70 08       	ld.w	r8,r8[0x0]
80005b6a:	f0 c9 ff ff 	sub	r9,r8,-1
80005b6e:	4b e8       	lddpc	r8,80005c64 <xTaskGenericCreate+0x1a0>
80005b70:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005b72:	4b e8       	lddpc	r8,80005c68 <xTaskGenericCreate+0x1a4>
80005b74:	70 08       	ld.w	r8,r8[0x0]
80005b76:	58 08       	cp.w	r8,0
80005b78:	c0 c1       	brne	80005b90 <xTaskGenericCreate+0xcc>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005b7a:	4b c8       	lddpc	r8,80005c68 <xTaskGenericCreate+0x1a4>
80005b7c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005b80:	91 09       	st.w	r8[0x0],r9

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005b82:	4b 98       	lddpc	r8,80005c64 <xTaskGenericCreate+0x1a0>
80005b84:	70 08       	ld.w	r8,r8[0x0]
80005b86:	58 18       	cp.w	r8,1
80005b88:	c1 41       	brne	80005bb0 <xTaskGenericCreate+0xec>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
80005b8a:	f0 1f 00 39 	mcall	80005c6c <xTaskGenericCreate+0x1a8>
80005b8e:	c1 18       	rjmp	80005bb0 <xTaskGenericCreate+0xec>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005b90:	4b 88       	lddpc	r8,80005c70 <xTaskGenericCreate+0x1ac>
80005b92:	70 08       	ld.w	r8,r8[0x0]
80005b94:	58 08       	cp.w	r8,0
80005b96:	c0 d1       	brne	80005bb0 <xTaskGenericCreate+0xec>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005b98:	4b 48       	lddpc	r8,80005c68 <xTaskGenericCreate+0x1a4>
80005b9a:	70 08       	ld.w	r8,r8[0x0]
80005b9c:	70 b9       	ld.w	r9,r8[0x2c]
80005b9e:	ee f8 ff e0 	ld.w	r8,r7[-32]
80005ba2:	10 39       	cp.w	r9,r8
80005ba4:	e0 8b 00 06 	brhi	80005bb0 <xTaskGenericCreate+0xec>
					{
						pxCurrentTCB = pxNewTCB;
80005ba8:	4b 08       	lddpc	r8,80005c68 <xTaskGenericCreate+0x1a4>
80005baa:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005bae:	91 09       	st.w	r8[0x0],r9
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005bb0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005bb4:	70 b9       	ld.w	r9,r8[0x2c]
80005bb6:	4b 08       	lddpc	r8,80005c74 <xTaskGenericCreate+0x1b0>
80005bb8:	70 08       	ld.w	r8,r8[0x0]
80005bba:	10 39       	cp.w	r9,r8
80005bbc:	e0 88 00 07 	brls	80005bca <xTaskGenericCreate+0x106>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005bc0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005bc4:	70 b9       	ld.w	r9,r8[0x2c]
80005bc6:	4a c8       	lddpc	r8,80005c74 <xTaskGenericCreate+0x1b0>
80005bc8:	91 09       	st.w	r8[0x0],r9
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005bca:	4a c8       	lddpc	r8,80005c78 <xTaskGenericCreate+0x1b4>
80005bcc:	70 08       	ld.w	r8,r8[0x0]
80005bce:	f0 c9 ff ff 	sub	r9,r8,-1
80005bd2:	4a a8       	lddpc	r8,80005c78 <xTaskGenericCreate+0x1b4>
80005bd4:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005bd6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005bda:	70 b9       	ld.w	r9,r8[0x2c]
80005bdc:	4a 88       	lddpc	r8,80005c7c <xTaskGenericCreate+0x1b8>
80005bde:	70 08       	ld.w	r8,r8[0x0]
80005be0:	10 39       	cp.w	r9,r8
80005be2:	e0 88 00 07 	brls	80005bf0 <xTaskGenericCreate+0x12c>
80005be6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005bea:	70 b9       	ld.w	r9,r8[0x2c]
80005bec:	4a 48       	lddpc	r8,80005c7c <xTaskGenericCreate+0x1b8>
80005bee:	91 09       	st.w	r8[0x0],r9
80005bf0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005bf4:	f0 ca ff fc 	sub	r10,r8,-4
80005bf8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005bfc:	70 b9       	ld.w	r9,r8[0x2c]
80005bfe:	12 98       	mov	r8,r9
80005c00:	a3 68       	lsl	r8,0x2
80005c02:	12 08       	add	r8,r9
80005c04:	a3 68       	lsl	r8,0x2
80005c06:	10 99       	mov	r9,r8
80005c08:	49 e8       	lddpc	r8,80005c80 <xTaskGenericCreate+0x1bc>
80005c0a:	f2 08 00 08 	add	r8,r9,r8
80005c0e:	14 9b       	mov	r11,r10
80005c10:	10 9c       	mov	r12,r8
80005c12:	f0 1f 00 1d 	mcall	80005c84 <xTaskGenericCreate+0x1c0>

			xReturn = pdPASS;
80005c16:	30 18       	mov	r8,1
80005c18:	ef 48 ff f4 	st.w	r7[-12],r8
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80005c1c:	f0 1f 00 1b 	mcall	80005c88 <xTaskGenericCreate+0x1c4>
80005c20:	c0 48       	rjmp	80005c28 <xTaskGenericCreate+0x164>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
80005c22:	3f f8       	mov	r8,-1
80005c24:	ef 48 ff f4 	st.w	r7[-12],r8
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
80005c28:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005c2c:	58 18       	cp.w	r8,1
80005c2e:	c0 d1       	brne	80005c48 <xTaskGenericCreate+0x184>
	{
		if( xSchedulerRunning != pdFALSE )
80005c30:	49 08       	lddpc	r8,80005c70 <xTaskGenericCreate+0x1ac>
80005c32:	70 08       	ld.w	r8,r8[0x0]
80005c34:	58 08       	cp.w	r8,0
80005c36:	c0 90       	breq	80005c48 <xTaskGenericCreate+0x184>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005c38:	48 c8       	lddpc	r8,80005c68 <xTaskGenericCreate+0x1a4>
80005c3a:	70 08       	ld.w	r8,r8[0x0]
80005c3c:	70 b9       	ld.w	r9,r8[0x2c]
80005c3e:	ee f8 ff e0 	ld.w	r8,r7[-32]
80005c42:	10 39       	cp.w	r9,r8
80005c44:	c0 22       	brcc	80005c48 <xTaskGenericCreate+0x184>
			{
				portYIELD_WITHIN_API();
80005c46:	d7 33       	scall
			}
		}
	}

	return xReturn;
80005c48:	ee f8 ff f4 	ld.w	r8,r7[-12]
}
80005c4c:	10 9c       	mov	r12,r8
80005c4e:	2f 8d       	sub	sp,-32
80005c50:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005c54:	80 00       	ld.sh	r0,r0[0x0]
80005c56:	65 a8       	ld.w	r8,r2[0x68]
80005c58:	80 00       	ld.sh	r0,r0[0x0]
80005c5a:	63 60       	ld.w	r0,r1[0x58]
80005c5c:	80 00       	ld.sh	r0,r0[0x0]
80005c5e:	4f e8       	lddpc	r8,80005e54 <xTaskResumeAll+0xd4>
80005c60:	80 00       	ld.sh	r0,r0[0x0]
80005c62:	4f a0       	lddpc	r0,80005e48 <xTaskResumeAll+0xc8>
80005c64:	00 00       	add	r0,r0
80005c66:	07 74       	ld.ub	r4,--r3
80005c68:	00 00       	add	r0,r0
80005c6a:	06 60       	and	r0,r3
80005c6c:	80 00       	ld.sh	r0,r0[0x0]
80005c6e:	63 fc       	ld.w	r12,r1[0x7c]
80005c70:	00 00       	add	r0,r0
80005c72:	07 84       	ld.ub	r4,r3[0x0]
80005c74:	00 00       	add	r0,r0
80005c76:	07 7c       	ld.ub	r12,--r3
80005c78:	00 00       	add	r0,r0
80005c7a:	07 98       	ld.ub	r8,r3[0x1]
80005c7c:	00 00       	add	r0,r0
80005c7e:	07 80       	ld.ub	r0,r3[0x0]
80005c80:	00 00       	add	r0,r0
80005c82:	06 64       	and	r4,r3
80005c84:	80 00       	ld.sh	r0,r0[0x0]
80005c86:	4c 76       	lddpc	r6,80005da0 <xTaskResumeAll+0x20>
80005c88:	80 00       	ld.sh	r0,r0[0x0]
80005c8a:	4f bc       	lddpc	r12,80005e74 <xTaskResumeAll+0xf4>

80005c8c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80005c8c:	eb cd 40 80 	pushm	r7,lr
80005c90:	1a 97       	mov	r7,sp
80005c92:	20 3d       	sub	sp,12
80005c94:	ef 4c ff f4 	st.w	r7[-12],r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
80005c98:	30 08       	mov	r8,0
80005c9a:	ef 48 ff fc 	st.w	r7[-4],r8

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80005c9e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005ca2:	58 08       	cp.w	r8,0
80005ca4:	c1 a0       	breq	80005cd8 <vTaskDelay+0x4c>
		{
			vTaskSuspendAll();
80005ca6:	f0 1f 00 11 	mcall	80005ce8 <vTaskDelay+0x5c>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80005caa:	49 18       	lddpc	r8,80005cec <vTaskDelay+0x60>
80005cac:	70 09       	ld.w	r9,r8[0x0]
80005cae:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005cb2:	f2 08 00 08 	add	r8,r9,r8
80005cb6:	ef 48 ff f8 	st.w	r7[-8],r8

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005cba:	48 e8       	lddpc	r8,80005cf0 <vTaskDelay+0x64>
80005cbc:	70 08       	ld.w	r8,r8[0x0]
80005cbe:	2f c8       	sub	r8,-4
80005cc0:	10 9c       	mov	r12,r8
80005cc2:	f0 1f 00 0d 	mcall	80005cf4 <vTaskDelay+0x68>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005cc6:	ee fc ff f8 	ld.w	r12,r7[-8]
80005cca:	f0 1f 00 0c 	mcall	80005cf8 <vTaskDelay+0x6c>
			}
			xAlreadyYielded = xTaskResumeAll();
80005cce:	f0 1f 00 0c 	mcall	80005cfc <vTaskDelay+0x70>
80005cd2:	18 98       	mov	r8,r12
80005cd4:	ef 48 ff fc 	st.w	r7[-4],r8
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005cd8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005cdc:	58 08       	cp.w	r8,0
80005cde:	c0 21       	brne	80005ce2 <vTaskDelay+0x56>
		{
			portYIELD_WITHIN_API();
80005ce0:	d7 33       	scall
		}
	}
80005ce2:	2f dd       	sub	sp,-12
80005ce4:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ce8:	80 00       	ld.sh	r0,r0[0x0]
80005cea:	5d 64       	*unknown*
80005cec:	00 00       	add	r0,r0
80005cee:	07 78       	ld.ub	r8,--r3
80005cf0:	00 00       	add	r0,r0
80005cf2:	06 60       	and	r0,r3
80005cf4:	80 00       	ld.sh	r0,r0[0x0]
80005cf6:	4d 8a       	lddpc	r10,80005e54 <xTaskResumeAll+0xd4>
80005cf8:	80 00       	ld.sh	r0,r0[0x0]
80005cfa:	65 28       	ld.w	r8,r2[0x48]
80005cfc:	80 00       	ld.sh	r0,r0[0x0]
80005cfe:	5d 80       	*unknown*

80005d00 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005d00:	eb cd 40 80 	pushm	r7,lr
80005d04:	1a 97       	mov	r7,sp
80005d06:	20 1d       	sub	sp,4
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005d08:	49 1b       	lddpc	r11,80005d4c <vTaskStartScheduler+0x4c>
80005d0a:	30 08       	mov	r8,0
80005d0c:	1a d8       	st.w	--sp,r8
80005d0e:	30 08       	mov	r8,0
80005d10:	1a d8       	st.w	--sp,r8
80005d12:	30 08       	mov	r8,0
80005d14:	1a d8       	st.w	--sp,r8
80005d16:	30 08       	mov	r8,0
80005d18:	30 09       	mov	r9,0
80005d1a:	e0 6a 01 00 	mov	r10,256
80005d1e:	48 dc       	lddpc	r12,80005d50 <vTaskStartScheduler+0x50>
80005d20:	f0 1f 00 0d 	mcall	80005d54 <vTaskStartScheduler+0x54>
80005d24:	2f dd       	sub	sp,-12
80005d26:	18 98       	mov	r8,r12
80005d28:	ef 48 ff fc 	st.w	r7[-4],r8
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005d2c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005d30:	58 18       	cp.w	r8,1
80005d32:	c0 a1       	brne	80005d46 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005d34:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005d36:	48 98       	lddpc	r8,80005d58 <vTaskStartScheduler+0x58>
80005d38:	30 19       	mov	r9,1
80005d3a:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005d3c:	48 88       	lddpc	r8,80005d5c <vTaskStartScheduler+0x5c>
80005d3e:	30 09       	mov	r9,0
80005d40:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005d42:	f0 1f 00 08 	mcall	80005d60 <vTaskStartScheduler+0x60>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
80005d46:	2f fd       	sub	sp,-4
80005d48:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d4c:	80 00       	ld.sh	r0,r0[0x0]
80005d4e:	5a bc       	cp.w	r12,-21
80005d50:	80 00       	ld.sh	r0,r0[0x0]
80005d52:	63 34       	ld.w	r4,r1[0x4c]
80005d54:	80 00       	ld.sh	r0,r0[0x0]
80005d56:	5a c4       	cp.w	r4,-20
80005d58:	00 00       	add	r0,r0
80005d5a:	07 84       	ld.ub	r4,r3[0x0]
80005d5c:	00 00       	add	r0,r0
80005d5e:	07 78       	ld.ub	r8,--r3
80005d60:	80 00       	ld.sh	r0,r0[0x0]
80005d62:	51 90       	stdsp	sp[0x64],r0

80005d64 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
80005d64:	eb cd 40 80 	pushm	r7,lr
80005d68:	1a 97       	mov	r7,sp
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005d6a:	48 58       	lddpc	r8,80005d7c <vTaskSuspendAll+0x18>
80005d6c:	70 08       	ld.w	r8,r8[0x0]
80005d6e:	f0 c9 ff ff 	sub	r9,r8,-1
80005d72:	48 38       	lddpc	r8,80005d7c <vTaskSuspendAll+0x18>
80005d74:	91 09       	st.w	r8[0x0],r9
}
80005d76:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d7a:	00 00       	add	r0,r0
80005d7c:	00 00       	add	r0,r0
80005d7e:	07 88       	ld.ub	r8,r3[0x0]

80005d80 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005d80:	eb cd 40 c0 	pushm	r6-r7,lr
80005d84:	1a 97       	mov	r7,sp
80005d86:	20 2d       	sub	sp,8
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
80005d88:	30 08       	mov	r8,0
80005d8a:	ef 48 ff f8 	st.w	r7[-8],r8
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005d8e:	f0 1f 00 3a 	mcall	80005e74 <xTaskResumeAll+0xf4>
	{
		--uxSchedulerSuspended;
80005d92:	4b a8       	lddpc	r8,80005e78 <xTaskResumeAll+0xf8>
80005d94:	70 08       	ld.w	r8,r8[0x0]
80005d96:	f0 c9 00 01 	sub	r9,r8,1
80005d9a:	4b 88       	lddpc	r8,80005e78 <xTaskResumeAll+0xf8>
80005d9c:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005d9e:	4b 78       	lddpc	r8,80005e78 <xTaskResumeAll+0xf8>
80005da0:	70 08       	ld.w	r8,r8[0x0]
80005da2:	58 08       	cp.w	r8,0
80005da4:	c5 f1       	brne	80005e62 <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005da6:	4b 68       	lddpc	r8,80005e7c <xTaskResumeAll+0xfc>
80005da8:	70 08       	ld.w	r8,r8[0x0]
80005daa:	58 08       	cp.w	r8,0
80005dac:	c5 b0       	breq	80005e62 <xTaskResumeAll+0xe2>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
80005dae:	30 08       	mov	r8,0
80005db0:	ef 48 ff fc 	st.w	r7[-4],r8

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005db4:	c3 08       	rjmp	80005e14 <xTaskResumeAll+0x94>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005db6:	4b 38       	lddpc	r8,80005e80 <xTaskResumeAll+0x100>
80005db8:	70 38       	ld.w	r8,r8[0xc]
80005dba:	70 38       	ld.w	r8,r8[0xc]
80005dbc:	10 96       	mov	r6,r8
					vListRemove( &( pxTCB->xEventListItem ) );
80005dbe:	ec c8 ff e8 	sub	r8,r6,-24
80005dc2:	10 9c       	mov	r12,r8
80005dc4:	f0 1f 00 30 	mcall	80005e84 <xTaskResumeAll+0x104>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005dc8:	ec c8 ff fc 	sub	r8,r6,-4
80005dcc:	10 9c       	mov	r12,r8
80005dce:	f0 1f 00 2e 	mcall	80005e84 <xTaskResumeAll+0x104>
					prvAddTaskToReadyQueue( pxTCB );
80005dd2:	6c b9       	ld.w	r9,r6[0x2c]
80005dd4:	4a d8       	lddpc	r8,80005e88 <xTaskResumeAll+0x108>
80005dd6:	70 08       	ld.w	r8,r8[0x0]
80005dd8:	10 39       	cp.w	r9,r8
80005dda:	e0 88 00 05 	brls	80005de4 <xTaskResumeAll+0x64>
80005dde:	6c b9       	ld.w	r9,r6[0x2c]
80005de0:	4a a8       	lddpc	r8,80005e88 <xTaskResumeAll+0x108>
80005de2:	91 09       	st.w	r8[0x0],r9
80005de4:	ec ca ff fc 	sub	r10,r6,-4
80005de8:	6c b9       	ld.w	r9,r6[0x2c]
80005dea:	12 98       	mov	r8,r9
80005dec:	a3 68       	lsl	r8,0x2
80005dee:	12 08       	add	r8,r9
80005df0:	a3 68       	lsl	r8,0x2
80005df2:	10 99       	mov	r9,r8
80005df4:	4a 68       	lddpc	r8,80005e8c <xTaskResumeAll+0x10c>
80005df6:	f2 08 00 08 	add	r8,r9,r8
80005dfa:	14 9b       	mov	r11,r10
80005dfc:	10 9c       	mov	r12,r8
80005dfe:	f0 1f 00 25 	mcall	80005e90 <xTaskResumeAll+0x110>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005e02:	6c b9       	ld.w	r9,r6[0x2c]
80005e04:	4a 48       	lddpc	r8,80005e94 <xTaskResumeAll+0x114>
80005e06:	70 08       	ld.w	r8,r8[0x0]
80005e08:	70 b8       	ld.w	r8,r8[0x2c]
80005e0a:	10 39       	cp.w	r9,r8
80005e0c:	c0 43       	brcs	80005e14 <xTaskResumeAll+0x94>
					{
						xYieldRequired = pdTRUE;
80005e0e:	30 18       	mov	r8,1
80005e10:	ef 48 ff fc 	st.w	r7[-4],r8
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005e14:	49 b8       	lddpc	r8,80005e80 <xTaskResumeAll+0x100>
80005e16:	70 08       	ld.w	r8,r8[0x0]
80005e18:	58 08       	cp.w	r8,0
80005e1a:	cc e1       	brne	80005db6 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005e1c:	49 f8       	lddpc	r8,80005e98 <xTaskResumeAll+0x118>
80005e1e:	70 08       	ld.w	r8,r8[0x0]
80005e20:	58 08       	cp.w	r8,0
80005e22:	c1 10       	breq	80005e44 <xTaskResumeAll+0xc4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005e24:	c0 98       	rjmp	80005e36 <xTaskResumeAll+0xb6>
					{
						vTaskIncrementTick();
80005e26:	f0 1f 00 1e 	mcall	80005e9c <xTaskResumeAll+0x11c>
						--uxMissedTicks;
80005e2a:	49 c8       	lddpc	r8,80005e98 <xTaskResumeAll+0x118>
80005e2c:	70 08       	ld.w	r8,r8[0x0]
80005e2e:	f0 c9 00 01 	sub	r9,r8,1
80005e32:	49 a8       	lddpc	r8,80005e98 <xTaskResumeAll+0x118>
80005e34:	91 09       	st.w	r8[0x0],r9
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005e36:	49 98       	lddpc	r8,80005e98 <xTaskResumeAll+0x118>
80005e38:	70 08       	ld.w	r8,r8[0x0]
80005e3a:	58 08       	cp.w	r8,0
80005e3c:	cf 51       	brne	80005e26 <xTaskResumeAll+0xa6>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
80005e3e:	30 18       	mov	r8,1
80005e40:	ef 48 ff fc 	st.w	r7[-4],r8
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005e44:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005e48:	58 18       	cp.w	r8,1
80005e4a:	c0 50       	breq	80005e54 <xTaskResumeAll+0xd4>
80005e4c:	49 58       	lddpc	r8,80005ea0 <xTaskResumeAll+0x120>
80005e4e:	70 08       	ld.w	r8,r8[0x0]
80005e50:	58 18       	cp.w	r8,1
80005e52:	c0 81       	brne	80005e62 <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
80005e54:	30 18       	mov	r8,1
80005e56:	ef 48 ff f8 	st.w	r7[-8],r8
					xMissedYield = pdFALSE;
80005e5a:	49 28       	lddpc	r8,80005ea0 <xTaskResumeAll+0x120>
80005e5c:	30 09       	mov	r9,0
80005e5e:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005e60:	d7 33       	scall
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005e62:	f0 1f 00 11 	mcall	80005ea4 <xTaskResumeAll+0x124>

	return xAlreadyYielded;
80005e66:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80005e6a:	10 9c       	mov	r12,r8
80005e6c:	2f ed       	sub	sp,-8
80005e6e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e72:	00 00       	add	r0,r0
80005e74:	80 00       	ld.sh	r0,r0[0x0]
80005e76:	4f a0       	lddpc	r0,8000605c <vTaskSwitchContext+0x24>
80005e78:	00 00       	add	r0,r0
80005e7a:	07 88       	ld.ub	r8,r3[0x0]
80005e7c:	00 00       	add	r0,r0
80005e7e:	07 74       	ld.ub	r4,--r3
80005e80:	00 00       	add	r0,r0
80005e82:	07 34       	ld.ub	r4,r3++
80005e84:	80 00       	ld.sh	r0,r0[0x0]
80005e86:	4d 8a       	lddpc	r10,80005fe4 <vTaskIncrementTick+0x10c>
80005e88:	00 00       	add	r0,r0
80005e8a:	07 80       	ld.ub	r0,r3[0x0]
80005e8c:	00 00       	add	r0,r0
80005e8e:	06 64       	and	r4,r3
80005e90:	80 00       	ld.sh	r0,r0[0x0]
80005e92:	4c 76       	lddpc	r6,80005fac <vTaskIncrementTick+0xd4>
80005e94:	00 00       	add	r0,r0
80005e96:	06 60       	and	r0,r3
80005e98:	00 00       	add	r0,r0
80005e9a:	07 8c       	ld.ub	r12,r3[0x0]
80005e9c:	80 00       	ld.sh	r0,r0[0x0]
80005e9e:	5e d8       	retvc	r8
80005ea0:	00 00       	add	r0,r0
80005ea2:	07 90       	ld.ub	r0,r3[0x1]
80005ea4:	80 00       	ld.sh	r0,r0[0x0]
80005ea6:	4f bc       	lddpc	r12,80006090 <vTaskSwitchContext+0x58>

80005ea8 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005ea8:	eb cd 40 80 	pushm	r7,lr
80005eac:	1a 97       	mov	r7,sp
80005eae:	20 1d       	sub	sp,4
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005eb0:	f0 1f 00 07 	mcall	80005ecc <xTaskGetTickCount+0x24>
	{
		xTicks = xTickCount;
80005eb4:	48 78       	lddpc	r8,80005ed0 <xTaskGetTickCount+0x28>
80005eb6:	70 08       	ld.w	r8,r8[0x0]
80005eb8:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	taskEXIT_CRITICAL();
80005ebc:	f0 1f 00 06 	mcall	80005ed4 <xTaskGetTickCount+0x2c>

	return xTicks;
80005ec0:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005ec4:	10 9c       	mov	r12,r8
80005ec6:	2f fd       	sub	sp,-4
80005ec8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ecc:	80 00       	ld.sh	r0,r0[0x0]
80005ece:	4f a0       	lddpc	r0,800060b4 <vTaskSwitchContext+0x7c>
80005ed0:	00 00       	add	r0,r0
80005ed2:	07 78       	ld.ub	r8,--r3
80005ed4:	80 00       	ld.sh	r0,r0[0x0]
80005ed6:	4f bc       	lddpc	r12,800060c0 <vTaskSwitchContext+0x88>

80005ed8 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005ed8:	eb cd 40 80 	pushm	r7,lr
80005edc:	1a 97       	mov	r7,sp
80005ede:	20 3d       	sub	sp,12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005ee0:	4c b8       	lddpc	r8,8000600c <vTaskIncrementTick+0x134>
80005ee2:	70 08       	ld.w	r8,r8[0x0]
80005ee4:	58 08       	cp.w	r8,0
80005ee6:	e0 81 00 89 	brne	80005ff8 <vTaskIncrementTick+0x120>
	{
		++xTickCount;
80005eea:	4c a8       	lddpc	r8,80006010 <vTaskIncrementTick+0x138>
80005eec:	70 08       	ld.w	r8,r8[0x0]
80005eee:	f0 c9 ff ff 	sub	r9,r8,-1
80005ef2:	4c 88       	lddpc	r8,80006010 <vTaskIncrementTick+0x138>
80005ef4:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005ef6:	4c 78       	lddpc	r8,80006010 <vTaskIncrementTick+0x138>
80005ef8:	70 08       	ld.w	r8,r8[0x0]
80005efa:	58 08       	cp.w	r8,0
80005efc:	c2 71       	brne	80005f4a <vTaskIncrementTick+0x72>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005efe:	4c 68       	lddpc	r8,80006014 <vTaskIncrementTick+0x13c>
80005f00:	70 08       	ld.w	r8,r8[0x0]
80005f02:	ef 48 ff f8 	st.w	r7[-8],r8
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005f06:	4c 58       	lddpc	r8,80006018 <vTaskIncrementTick+0x140>
80005f08:	70 09       	ld.w	r9,r8[0x0]
80005f0a:	4c 38       	lddpc	r8,80006014 <vTaskIncrementTick+0x13c>
80005f0c:	91 09       	st.w	r8[0x0],r9
			pxOverflowDelayedTaskList = pxTemp;
80005f0e:	4c 38       	lddpc	r8,80006018 <vTaskIncrementTick+0x140>
80005f10:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005f14:	91 09       	st.w	r8[0x0],r9
			xNumOfOverflows++;
80005f16:	4c 28       	lddpc	r8,8000601c <vTaskIncrementTick+0x144>
80005f18:	70 08       	ld.w	r8,r8[0x0]
80005f1a:	f0 c9 ff ff 	sub	r9,r8,-1
80005f1e:	4c 08       	lddpc	r8,8000601c <vTaskIncrementTick+0x144>
80005f20:	91 09       	st.w	r8[0x0],r9

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005f22:	4b d8       	lddpc	r8,80006014 <vTaskIncrementTick+0x13c>
80005f24:	70 08       	ld.w	r8,r8[0x0]
80005f26:	70 08       	ld.w	r8,r8[0x0]
80005f28:	58 08       	cp.w	r8,0
80005f2a:	c0 51       	brne	80005f34 <vTaskIncrementTick+0x5c>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005f2c:	4b d8       	lddpc	r8,80006020 <vTaskIncrementTick+0x148>
80005f2e:	3f f9       	mov	r9,-1
80005f30:	91 09       	st.w	r8[0x0],r9
80005f32:	c0 c8       	rjmp	80005f4a <vTaskIncrementTick+0x72>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005f34:	4b 88       	lddpc	r8,80006014 <vTaskIncrementTick+0x13c>
80005f36:	70 08       	ld.w	r8,r8[0x0]
80005f38:	70 38       	ld.w	r8,r8[0xc]
80005f3a:	70 38       	ld.w	r8,r8[0xc]
80005f3c:	ef 48 ff f4 	st.w	r7[-12],r8
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005f40:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005f44:	70 19       	ld.w	r9,r8[0x4]
80005f46:	4b 78       	lddpc	r8,80006020 <vTaskIncrementTick+0x148>
80005f48:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005f4a:	4b 28       	lddpc	r8,80006010 <vTaskIncrementTick+0x138>
80005f4c:	70 09       	ld.w	r9,r8[0x0]
80005f4e:	4b 58       	lddpc	r8,80006020 <vTaskIncrementTick+0x148>
80005f50:	70 08       	ld.w	r8,r8[0x0]
80005f52:	10 39       	cp.w	r9,r8
80005f54:	c5 83       	brcs	80006004 <vTaskIncrementTick+0x12c>
80005f56:	4b 08       	lddpc	r8,80006014 <vTaskIncrementTick+0x13c>
80005f58:	70 08       	ld.w	r8,r8[0x0]
80005f5a:	70 08       	ld.w	r8,r8[0x0]
80005f5c:	58 08       	cp.w	r8,0
80005f5e:	c0 51       	brne	80005f68 <vTaskIncrementTick+0x90>
80005f60:	4b 08       	lddpc	r8,80006020 <vTaskIncrementTick+0x148>
80005f62:	3f f9       	mov	r9,-1
80005f64:	91 09       	st.w	r8[0x0],r9
80005f66:	c4 f8       	rjmp	80006004 <vTaskIncrementTick+0x12c>
80005f68:	4a b8       	lddpc	r8,80006014 <vTaskIncrementTick+0x13c>
80005f6a:	70 08       	ld.w	r8,r8[0x0]
80005f6c:	70 38       	ld.w	r8,r8[0xc]
80005f6e:	70 38       	ld.w	r8,r8[0xc]
80005f70:	ef 48 ff f4 	st.w	r7[-12],r8
80005f74:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005f78:	70 18       	ld.w	r8,r8[0x4]
80005f7a:	ef 48 ff fc 	st.w	r7[-4],r8
80005f7e:	4a 58       	lddpc	r8,80006010 <vTaskIncrementTick+0x138>
80005f80:	70 09       	ld.w	r9,r8[0x0]
80005f82:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005f86:	10 39       	cp.w	r9,r8
80005f88:	c0 62       	brcc	80005f94 <vTaskIncrementTick+0xbc>
80005f8a:	4a 68       	lddpc	r8,80006020 <vTaskIncrementTick+0x148>
80005f8c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005f90:	91 09       	st.w	r8[0x0],r9
80005f92:	c3 98       	rjmp	80006004 <vTaskIncrementTick+0x12c>
80005f94:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005f98:	2f c8       	sub	r8,-4
80005f9a:	10 9c       	mov	r12,r8
80005f9c:	f0 1f 00 22 	mcall	80006024 <vTaskIncrementTick+0x14c>
80005fa0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005fa4:	70 a8       	ld.w	r8,r8[0x28]
80005fa6:	58 08       	cp.w	r8,0
80005fa8:	c0 70       	breq	80005fb6 <vTaskIncrementTick+0xde>
80005faa:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005fae:	2e 88       	sub	r8,-24
80005fb0:	10 9c       	mov	r12,r8
80005fb2:	f0 1f 00 1d 	mcall	80006024 <vTaskIncrementTick+0x14c>
80005fb6:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005fba:	70 b9       	ld.w	r9,r8[0x2c]
80005fbc:	49 b8       	lddpc	r8,80006028 <vTaskIncrementTick+0x150>
80005fbe:	70 08       	ld.w	r8,r8[0x0]
80005fc0:	10 39       	cp.w	r9,r8
80005fc2:	e0 88 00 07 	brls	80005fd0 <vTaskIncrementTick+0xf8>
80005fc6:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005fca:	70 b9       	ld.w	r9,r8[0x2c]
80005fcc:	49 78       	lddpc	r8,80006028 <vTaskIncrementTick+0x150>
80005fce:	91 09       	st.w	r8[0x0],r9
80005fd0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005fd4:	f0 ca ff fc 	sub	r10,r8,-4
80005fd8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005fdc:	70 b9       	ld.w	r9,r8[0x2c]
80005fde:	12 98       	mov	r8,r9
80005fe0:	a3 68       	lsl	r8,0x2
80005fe2:	12 08       	add	r8,r9
80005fe4:	a3 68       	lsl	r8,0x2
80005fe6:	10 99       	mov	r9,r8
80005fe8:	49 18       	lddpc	r8,8000602c <vTaskIncrementTick+0x154>
80005fea:	f2 08 00 08 	add	r8,r9,r8
80005fee:	14 9b       	mov	r11,r10
80005ff0:	10 9c       	mov	r12,r8
80005ff2:	f0 1f 00 10 	mcall	80006030 <vTaskIncrementTick+0x158>
80005ff6:	cb 0b       	rjmp	80005f56 <vTaskIncrementTick+0x7e>
	}
	else
	{
		++uxMissedTicks;
80005ff8:	48 f8       	lddpc	r8,80006034 <vTaskIncrementTick+0x15c>
80005ffa:	70 08       	ld.w	r8,r8[0x0]
80005ffc:	f0 c9 ff ff 	sub	r9,r8,-1
80006000:	48 d8       	lddpc	r8,80006034 <vTaskIncrementTick+0x15c>
80006002:	91 09       	st.w	r8[0x0],r9
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
80006004:	2f dd       	sub	sp,-12
80006006:	e3 cd 80 80 	ldm	sp++,r7,pc
8000600a:	00 00       	add	r0,r0
8000600c:	00 00       	add	r0,r0
8000600e:	07 88       	ld.ub	r8,r3[0x0]
80006010:	00 00       	add	r0,r0
80006012:	07 78       	ld.ub	r8,--r3
80006014:	00 00       	add	r0,r0
80006016:	07 2c       	ld.uh	r12,r3++
80006018:	00 00       	add	r0,r0
8000601a:	07 30       	ld.ub	r0,r3++
8000601c:	00 00       	add	r0,r0
8000601e:	07 94       	ld.ub	r4,r3[0x1]
80006020:	00 00       	add	r0,r0
80006022:	00 24       	rsub	r4,r0
80006024:	80 00       	ld.sh	r0,r0[0x0]
80006026:	4d 8a       	lddpc	r10,80006184 <xTaskRemoveFromEventList+0x1c>
80006028:	00 00       	add	r0,r0
8000602a:	07 80       	ld.ub	r0,r3[0x0]
8000602c:	00 00       	add	r0,r0
8000602e:	06 64       	and	r4,r3
80006030:	80 00       	ld.sh	r0,r0[0x0]
80006032:	4c 76       	lddpc	r6,8000614c <vTaskPlaceOnEventList+0x64>
80006034:	00 00       	add	r0,r0
80006036:	07 8c       	ld.ub	r12,r3[0x0]

80006038 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
80006038:	eb cd 40 80 	pushm	r7,lr
8000603c:	1a 97       	mov	r7,sp
8000603e:	20 1d       	sub	sp,4
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006040:	4a 58       	lddpc	r8,800060d4 <vTaskSwitchContext+0x9c>
80006042:	70 08       	ld.w	r8,r8[0x0]
80006044:	58 08       	cp.w	r8,0
80006046:	c0 c0       	breq	8000605e <vTaskSwitchContext+0x26>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006048:	4a 48       	lddpc	r8,800060d8 <vTaskSwitchContext+0xa0>
8000604a:	30 19       	mov	r9,1
8000604c:	91 09       	st.w	r8[0x0],r9
8000604e:	c3 f8       	rjmp	800060cc <vTaskSwitchContext+0x94>

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006050:	4a 38       	lddpc	r8,800060dc <vTaskSwitchContext+0xa4>
80006052:	70 08       	ld.w	r8,r8[0x0]
80006054:	f0 c9 00 01 	sub	r9,r8,1
80006058:	4a 18       	lddpc	r8,800060dc <vTaskSwitchContext+0xa4>
8000605a:	91 09       	st.w	r8[0x0],r9
8000605c:	c0 28       	rjmp	80006060 <vTaskSwitchContext+0x28>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000605e:	d7 03       	nop
80006060:	49 f8       	lddpc	r8,800060dc <vTaskSwitchContext+0xa4>
80006062:	70 09       	ld.w	r9,r8[0x0]
80006064:	12 98       	mov	r8,r9
80006066:	a3 68       	lsl	r8,0x2
80006068:	12 08       	add	r8,r9
8000606a:	a3 68       	lsl	r8,0x2
8000606c:	10 99       	mov	r9,r8
8000606e:	49 d8       	lddpc	r8,800060e0 <vTaskSwitchContext+0xa8>
80006070:	f2 08 00 08 	add	r8,r9,r8
80006074:	70 08       	ld.w	r8,r8[0x0]
80006076:	58 08       	cp.w	r8,0
80006078:	ce c0       	breq	80006050 <vTaskSwitchContext+0x18>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
8000607a:	49 98       	lddpc	r8,800060dc <vTaskSwitchContext+0xa4>
8000607c:	70 09       	ld.w	r9,r8[0x0]
8000607e:	12 98       	mov	r8,r9
80006080:	a3 68       	lsl	r8,0x2
80006082:	12 08       	add	r8,r9
80006084:	a3 68       	lsl	r8,0x2
80006086:	10 99       	mov	r9,r8
80006088:	49 68       	lddpc	r8,800060e0 <vTaskSwitchContext+0xa8>
8000608a:	f2 08 00 08 	add	r8,r9,r8
8000608e:	ef 48 ff fc 	st.w	r7[-4],r8
80006092:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006096:	70 18       	ld.w	r8,r8[0x4]
80006098:	70 19       	ld.w	r9,r8[0x4]
8000609a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000609e:	91 19       	st.w	r8[0x4],r9
800060a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800060a4:	70 19       	ld.w	r9,r8[0x4]
800060a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800060aa:	2f 88       	sub	r8,-8
800060ac:	10 39       	cp.w	r9,r8
800060ae:	c0 81       	brne	800060be <vTaskSwitchContext+0x86>
800060b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800060b4:	70 18       	ld.w	r8,r8[0x4]
800060b6:	70 19       	ld.w	r9,r8[0x4]
800060b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800060bc:	91 19       	st.w	r8[0x4],r9
800060be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800060c2:	70 18       	ld.w	r8,r8[0x4]
800060c4:	70 38       	ld.w	r8,r8[0xc]
800060c6:	10 99       	mov	r9,r8
800060c8:	48 78       	lddpc	r8,800060e4 <vTaskSwitchContext+0xac>
800060ca:	91 09       	st.w	r8[0x0],r9

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
800060cc:	2f fd       	sub	sp,-4
800060ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800060d2:	00 00       	add	r0,r0
800060d4:	00 00       	add	r0,r0
800060d6:	07 88       	ld.ub	r8,r3[0x0]
800060d8:	00 00       	add	r0,r0
800060da:	07 90       	ld.ub	r0,r3[0x1]
800060dc:	00 00       	add	r0,r0
800060de:	07 80       	ld.ub	r0,r3[0x0]
800060e0:	00 00       	add	r0,r0
800060e2:	06 64       	and	r4,r3
800060e4:	00 00       	add	r0,r0
800060e6:	06 60       	and	r0,r3

800060e8 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800060e8:	eb cd 40 80 	pushm	r7,lr
800060ec:	1a 97       	mov	r7,sp
800060ee:	20 3d       	sub	sp,12
800060f0:	ef 4c ff f8 	st.w	r7[-8],r12
800060f4:	ef 4b ff f4 	st.w	r7[-12],r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800060f8:	49 58       	lddpc	r8,8000614c <vTaskPlaceOnEventList+0x64>
800060fa:	70 08       	ld.w	r8,r8[0x0]
800060fc:	2e 88       	sub	r8,-24
800060fe:	10 9b       	mov	r11,r8
80006100:	ee fc ff f8 	ld.w	r12,r7[-8]
80006104:	f0 1f 00 13 	mcall	80006150 <vTaskPlaceOnEventList+0x68>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006108:	49 18       	lddpc	r8,8000614c <vTaskPlaceOnEventList+0x64>
8000610a:	70 08       	ld.w	r8,r8[0x0]
8000610c:	2f c8       	sub	r8,-4
8000610e:	10 9c       	mov	r12,r8
80006110:	f0 1f 00 11 	mcall	80006154 <vTaskPlaceOnEventList+0x6c>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006114:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006118:	5b f8       	cp.w	r8,-1
8000611a:	c0 91       	brne	8000612c <vTaskPlaceOnEventList+0x44>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000611c:	48 c8       	lddpc	r8,8000614c <vTaskPlaceOnEventList+0x64>
8000611e:	70 08       	ld.w	r8,r8[0x0]
80006120:	2f c8       	sub	r8,-4
80006122:	10 9b       	mov	r11,r8
80006124:	48 dc       	lddpc	r12,80006158 <vTaskPlaceOnEventList+0x70>
80006126:	f0 1f 00 0e 	mcall	8000615c <vTaskPlaceOnEventList+0x74>
8000612a:	c0 d8       	rjmp	80006144 <vTaskPlaceOnEventList+0x5c>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
8000612c:	48 d8       	lddpc	r8,80006160 <vTaskPlaceOnEventList+0x78>
8000612e:	70 09       	ld.w	r9,r8[0x0]
80006130:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006134:	f2 08 00 08 	add	r8,r9,r8
80006138:	ef 48 ff fc 	st.w	r7[-4],r8
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000613c:	ee fc ff fc 	ld.w	r12,r7[-4]
80006140:	f0 1f 00 09 	mcall	80006164 <vTaskPlaceOnEventList+0x7c>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
80006144:	2f dd       	sub	sp,-12
80006146:	e3 cd 80 80 	ldm	sp++,r7,pc
8000614a:	00 00       	add	r0,r0
8000614c:	00 00       	add	r0,r0
8000614e:	06 60       	and	r0,r3
80006150:	80 00       	ld.sh	r0,r0[0x0]
80006152:	4c e8       	lddpc	r8,80006288 <xTaskCheckForTimeOut+0x20>
80006154:	80 00       	ld.sh	r0,r0[0x0]
80006156:	4d 8a       	lddpc	r10,800062b4 <xTaskCheckForTimeOut+0x4c>
80006158:	00 00       	add	r0,r0
8000615a:	07 60       	ld.uh	r0,--r3
8000615c:	80 00       	ld.sh	r0,r0[0x0]
8000615e:	4c 76       	lddpc	r6,80006278 <xTaskCheckForTimeOut+0x10>
80006160:	00 00       	add	r0,r0
80006162:	07 78       	ld.ub	r8,--r3
80006164:	80 00       	ld.sh	r0,r0[0x0]
80006166:	65 28       	ld.w	r8,r2[0x48]

80006168 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006168:	eb cd 40 80 	pushm	r7,lr
8000616c:	1a 97       	mov	r7,sp
8000616e:	20 3d       	sub	sp,12
80006170:	ef 4c ff f4 	st.w	r7[-12],r12
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006174:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006178:	70 38       	ld.w	r8,r8[0xc]
8000617a:	70 38       	ld.w	r8,r8[0xc]
8000617c:	ef 48 ff f8 	st.w	r7[-8],r8
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006180:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006184:	2e 88       	sub	r8,-24
80006186:	10 9c       	mov	r12,r8
80006188:	f0 1f 00 25 	mcall	8000621c <xTaskRemoveFromEventList+0xb4>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000618c:	4a 58       	lddpc	r8,80006220 <xTaskRemoveFromEventList+0xb8>
8000618e:	70 08       	ld.w	r8,r8[0x0]
80006190:	58 08       	cp.w	r8,0
80006192:	c2 81       	brne	800061e2 <xTaskRemoveFromEventList+0x7a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006194:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006198:	2f c8       	sub	r8,-4
8000619a:	10 9c       	mov	r12,r8
8000619c:	f0 1f 00 20 	mcall	8000621c <xTaskRemoveFromEventList+0xb4>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800061a0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800061a4:	70 b9       	ld.w	r9,r8[0x2c]
800061a6:	4a 08       	lddpc	r8,80006224 <xTaskRemoveFromEventList+0xbc>
800061a8:	70 08       	ld.w	r8,r8[0x0]
800061aa:	10 39       	cp.w	r9,r8
800061ac:	e0 88 00 07 	brls	800061ba <xTaskRemoveFromEventList+0x52>
800061b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800061b4:	70 b9       	ld.w	r9,r8[0x2c]
800061b6:	49 c8       	lddpc	r8,80006224 <xTaskRemoveFromEventList+0xbc>
800061b8:	91 09       	st.w	r8[0x0],r9
800061ba:	ee f8 ff f8 	ld.w	r8,r7[-8]
800061be:	f0 ca ff fc 	sub	r10,r8,-4
800061c2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800061c6:	70 b9       	ld.w	r9,r8[0x2c]
800061c8:	12 98       	mov	r8,r9
800061ca:	a3 68       	lsl	r8,0x2
800061cc:	12 08       	add	r8,r9
800061ce:	a3 68       	lsl	r8,0x2
800061d0:	10 99       	mov	r9,r8
800061d2:	49 68       	lddpc	r8,80006228 <xTaskRemoveFromEventList+0xc0>
800061d4:	f2 08 00 08 	add	r8,r9,r8
800061d8:	14 9b       	mov	r11,r10
800061da:	10 9c       	mov	r12,r8
800061dc:	f0 1f 00 14 	mcall	8000622c <xTaskRemoveFromEventList+0xc4>
800061e0:	c0 88       	rjmp	800061f0 <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800061e2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800061e6:	2e 88       	sub	r8,-24
800061e8:	10 9b       	mov	r11,r8
800061ea:	49 2c       	lddpc	r12,80006230 <xTaskRemoveFromEventList+0xc8>
800061ec:	f0 1f 00 10 	mcall	8000622c <xTaskRemoveFromEventList+0xc4>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800061f0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800061f4:	70 b9       	ld.w	r9,r8[0x2c]
800061f6:	49 08       	lddpc	r8,80006234 <xTaskRemoveFromEventList+0xcc>
800061f8:	70 08       	ld.w	r8,r8[0x0]
800061fa:	70 b8       	ld.w	r8,r8[0x2c]
800061fc:	10 39       	cp.w	r9,r8
800061fe:	c0 53       	brcs	80006208 <xTaskRemoveFromEventList+0xa0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
80006200:	30 18       	mov	r8,1
80006202:	ef 48 ff fc 	st.w	r7[-4],r8
80006206:	c0 48       	rjmp	8000620e <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		xReturn = pdFALSE;
80006208:	30 08       	mov	r8,0
8000620a:	ef 48 ff fc 	st.w	r7[-4],r8
	}

	return xReturn;
8000620e:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80006212:	10 9c       	mov	r12,r8
80006214:	2f dd       	sub	sp,-12
80006216:	e3 cd 80 80 	ldm	sp++,r7,pc
8000621a:	00 00       	add	r0,r0
8000621c:	80 00       	ld.sh	r0,r0[0x0]
8000621e:	4d 8a       	lddpc	r10,8000637c <prvInitialiseTCBVariables+0x1c>
80006220:	00 00       	add	r0,r0
80006222:	07 88       	ld.ub	r8,r3[0x0]
80006224:	00 00       	add	r0,r0
80006226:	07 80       	ld.ub	r0,r3[0x0]
80006228:	00 00       	add	r0,r0
8000622a:	06 64       	and	r4,r3
8000622c:	80 00       	ld.sh	r0,r0[0x0]
8000622e:	4c 76       	lddpc	r6,80006348 <prvIdleTask+0x14>
80006230:	00 00       	add	r0,r0
80006232:	07 34       	ld.ub	r4,r3++
80006234:	00 00       	add	r0,r0
80006236:	06 60       	and	r0,r3

80006238 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
80006238:	eb cd 40 80 	pushm	r7,lr
8000623c:	1a 97       	mov	r7,sp
8000623e:	20 1d       	sub	sp,4
80006240:	ef 4c ff fc 	st.w	r7[-4],r12
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006244:	48 78       	lddpc	r8,80006260 <vTaskSetTimeOutState+0x28>
80006246:	70 09       	ld.w	r9,r8[0x0]
80006248:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000624c:	91 09       	st.w	r8[0x0],r9
	pxTimeOut->xTimeOnEntering = xTickCount;
8000624e:	48 68       	lddpc	r8,80006264 <vTaskSetTimeOutState+0x2c>
80006250:	70 09       	ld.w	r9,r8[0x0]
80006252:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006256:	91 19       	st.w	r8[0x4],r9
}
80006258:	2f fd       	sub	sp,-4
8000625a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000625e:	00 00       	add	r0,r0
80006260:	00 00       	add	r0,r0
80006262:	07 94       	ld.ub	r4,r3[0x1]
80006264:	00 00       	add	r0,r0
80006266:	07 78       	ld.ub	r8,--r3

80006268 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006268:	eb cd 40 80 	pushm	r7,lr
8000626c:	1a 97       	mov	r7,sp
8000626e:	20 3d       	sub	sp,12
80006270:	ef 4c ff f8 	st.w	r7[-8],r12
80006274:	ef 4b ff f4 	st.w	r7[-12],r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006278:	f0 1f 00 25 	mcall	8000630c <xTaskCheckForTimeOut+0xa4>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
8000627c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006280:	70 08       	ld.w	r8,r8[0x0]
80006282:	5b f8       	cp.w	r8,-1
80006284:	c0 51       	brne	8000628e <xTaskCheckForTimeOut+0x26>
			{
				xReturn = pdFALSE;
80006286:	30 08       	mov	r8,0
80006288:	ef 48 ff fc 	st.w	r7[-4],r8
8000628c:	c3 88       	rjmp	800062fc <xTaskCheckForTimeOut+0x94>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000628e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006292:	70 09       	ld.w	r9,r8[0x0]
80006294:	49 f8       	lddpc	r8,80006310 <xTaskCheckForTimeOut+0xa8>
80006296:	70 08       	ld.w	r8,r8[0x0]
80006298:	10 39       	cp.w	r9,r8
8000629a:	c0 d0       	breq	800062b4 <xTaskCheckForTimeOut+0x4c>
8000629c:	ee f8 ff f8 	ld.w	r8,r7[-8]
800062a0:	70 19       	ld.w	r9,r8[0x4]
800062a2:	49 d8       	lddpc	r8,80006314 <xTaskCheckForTimeOut+0xac>
800062a4:	70 08       	ld.w	r8,r8[0x0]
800062a6:	10 39       	cp.w	r9,r8
800062a8:	e0 8b 00 06 	brhi	800062b4 <xTaskCheckForTimeOut+0x4c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
800062ac:	30 18       	mov	r8,1
800062ae:	ef 48 ff fc 	st.w	r7[-4],r8
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800062b2:	c2 58       	rjmp	800062fc <xTaskCheckForTimeOut+0x94>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800062b4:	49 88       	lddpc	r8,80006314 <xTaskCheckForTimeOut+0xac>
800062b6:	70 09       	ld.w	r9,r8[0x0]
800062b8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800062bc:	70 18       	ld.w	r8,r8[0x4]
800062be:	10 19       	sub	r9,r8
800062c0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800062c4:	70 08       	ld.w	r8,r8[0x0]
800062c6:	10 39       	cp.w	r9,r8
800062c8:	c1 72       	brcc	800062f6 <xTaskCheckForTimeOut+0x8e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800062ca:	ee f8 ff f4 	ld.w	r8,r7[-12]
800062ce:	70 09       	ld.w	r9,r8[0x0]
800062d0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800062d4:	70 1a       	ld.w	r10,r8[0x4]
800062d6:	49 08       	lddpc	r8,80006314 <xTaskCheckForTimeOut+0xac>
800062d8:	70 08       	ld.w	r8,r8[0x0]
800062da:	f4 08 01 08 	sub	r8,r10,r8
800062de:	10 09       	add	r9,r8
800062e0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800062e4:	91 09       	st.w	r8[0x0],r9
			vTaskSetTimeOutState( pxTimeOut );
800062e6:	ee fc ff f8 	ld.w	r12,r7[-8]
800062ea:	f0 1f 00 0c 	mcall	80006318 <xTaskCheckForTimeOut+0xb0>
			xReturn = pdFALSE;
800062ee:	30 08       	mov	r8,0
800062f0:	ef 48 ff fc 	st.w	r7[-4],r8
800062f4:	c0 48       	rjmp	800062fc <xTaskCheckForTimeOut+0x94>
		}
		else
		{
			xReturn = pdTRUE;
800062f6:	30 18       	mov	r8,1
800062f8:	ef 48 ff fc 	st.w	r7[-4],r8
		}
	}
	taskEXIT_CRITICAL();
800062fc:	f0 1f 00 08 	mcall	8000631c <xTaskCheckForTimeOut+0xb4>

	return xReturn;
80006300:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80006304:	10 9c       	mov	r12,r8
80006306:	2f dd       	sub	sp,-12
80006308:	e3 cd 80 80 	ldm	sp++,r7,pc
8000630c:	80 00       	ld.sh	r0,r0[0x0]
8000630e:	4f a0       	lddpc	r0,800064f4 <prvCheckTasksWaitingTermination+0x64>
80006310:	00 00       	add	r0,r0
80006312:	07 94       	ld.ub	r4,r3[0x1]
80006314:	00 00       	add	r0,r0
80006316:	07 78       	ld.ub	r8,--r3
80006318:	80 00       	ld.sh	r0,r0[0x0]
8000631a:	62 38       	ld.w	r8,r1[0xc]
8000631c:	80 00       	ld.sh	r0,r0[0x0]
8000631e:	4f bc       	lddpc	r12,80006508 <prvCheckTasksWaitingTermination+0x78>

80006320 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
80006320:	eb cd 40 80 	pushm	r7,lr
80006324:	1a 97       	mov	r7,sp
	xMissedYield = pdTRUE;
80006326:	48 38       	lddpc	r8,80006330 <vTaskMissedYield+0x10>
80006328:	30 19       	mov	r9,1
8000632a:	91 09       	st.w	r8[0x0],r9
}
8000632c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006330:	00 00       	add	r0,r0
80006332:	07 90       	ld.ub	r0,r3[0x1]

80006334 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006334:	eb cd 40 80 	pushm	r7,lr
80006338:	1a 97       	mov	r7,sp
8000633a:	20 1d       	sub	sp,4
8000633c:	ef 4c ff fc 	st.w	r7[-4],r12
80006340:	c0 28       	rjmp	80006344 <prvIdleTask+0x10>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
80006342:	d7 03       	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
80006344:	f0 1f 00 05 	mcall	80006358 <prvIdleTask+0x24>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006348:	48 58       	lddpc	r8,8000635c <prvIdleTask+0x28>
8000634a:	70 08       	ld.w	r8,r8[0x0]
8000634c:	58 18       	cp.w	r8,1
8000634e:	fe 98 ff fa 	brls	80006342 <prvIdleTask+0xe>
			{
				taskYIELD();
80006352:	d7 33       	scall
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
80006354:	cf 8b       	rjmp	80006344 <prvIdleTask+0x10>
80006356:	00 00       	add	r0,r0
80006358:	80 00       	ld.sh	r0,r0[0x0]
8000635a:	64 90       	ld.w	r0,r2[0x24]
8000635c:	00 00       	add	r0,r0
8000635e:	06 64       	and	r4,r3

80006360 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
80006360:	eb cd 40 80 	pushm	r7,lr
80006364:	1a 97       	mov	r7,sp
80006366:	20 5d       	sub	sp,20
80006368:	ef 4c ff fc 	st.w	r7[-4],r12
8000636c:	ef 4b ff f8 	st.w	r7[-8],r11
80006370:	ef 4a ff f4 	st.w	r7[-12],r10
80006374:	ef 49 ff f0 	st.w	r7[-16],r9
80006378:	ef 58 ff ec 	st.h	r7[-20],r8
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
8000637c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006380:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006384:	2c c8       	sub	r8,-52
80006386:	31 0a       	mov	r10,16
80006388:	12 9b       	mov	r11,r9
8000638a:	10 9c       	mov	r12,r8
8000638c:	f0 1f 00 1a 	mcall	800063f4 <prvInitialiseTCBVariables+0x94>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006390:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006394:	30 08       	mov	r8,0
80006396:	f3 68 00 43 	st.b	r9[67],r8

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
8000639a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000639e:	58 78       	cp.w	r8,7
800063a0:	e0 88 00 05 	brls	800063aa <prvInitialiseTCBVariables+0x4a>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
800063a4:	30 78       	mov	r8,7
800063a6:	ef 48 ff f4 	st.w	r7[-12],r8
	}

	pxTCB->uxPriority = uxPriority;
800063aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800063ae:	ee f9 ff f4 	ld.w	r9,r7[-12]
800063b2:	91 b9       	st.w	r8[0x2c],r9
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800063b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800063b8:	2f c8       	sub	r8,-4
800063ba:	10 9c       	mov	r12,r8
800063bc:	f0 1f 00 0f 	mcall	800063f8 <prvInitialiseTCBVariables+0x98>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800063c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800063c4:	2e 88       	sub	r8,-24
800063c6:	10 9c       	mov	r12,r8
800063c8:	f0 1f 00 0c 	mcall	800063f8 <prvInitialiseTCBVariables+0x98>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800063cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800063d0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800063d4:	91 49       	st.w	r8[0x10],r9

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800063d6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800063da:	f0 09 11 08 	rsub	r9,r8,8
800063de:	ee f8 ff fc 	ld.w	r8,r7[-4]
800063e2:	91 69       	st.w	r8[0x18],r9
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800063e4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800063e8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800063ec:	91 99       	st.w	r8[0x24],r9
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
800063ee:	2f bd       	sub	sp,-20
800063f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800063f4:	80 00       	ld.sh	r0,r0[0x0]
800063f6:	71 c8       	ld.w	r8,r8[0x70]
800063f8:	80 00       	ld.sh	r0,r0[0x0]
800063fa:	4c 5c       	lddpc	r12,8000650c <prvCheckTasksWaitingTermination+0x7c>

800063fc <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
800063fc:	eb cd 40 80 	pushm	r7,lr
80006400:	1a 97       	mov	r7,sp
80006402:	20 1d       	sub	sp,4
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006404:	30 08       	mov	r8,0
80006406:	ef 48 ff fc 	st.w	r7[-4],r8
8000640a:	c1 38       	rjmp	80006430 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
8000640c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006410:	12 98       	mov	r8,r9
80006412:	a3 68       	lsl	r8,0x2
80006414:	12 08       	add	r8,r9
80006416:	a3 68       	lsl	r8,0x2
80006418:	10 99       	mov	r9,r8
8000641a:	49 58       	lddpc	r8,8000646c <prvInitialiseTaskLists+0x70>
8000641c:	f2 08 00 08 	add	r8,r9,r8
80006420:	10 9c       	mov	r12,r8
80006422:	f0 1f 00 14 	mcall	80006470 <prvInitialiseTaskLists+0x74>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006426:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000642a:	2f f8       	sub	r8,-1
8000642c:	ef 48 ff fc 	st.w	r7[-4],r8
80006430:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006434:	58 78       	cp.w	r8,7
80006436:	fe 98 ff eb 	brls	8000640c <prvInitialiseTaskLists+0x10>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
8000643a:	48 fc       	lddpc	r12,80006474 <prvInitialiseTaskLists+0x78>
8000643c:	f0 1f 00 0d 	mcall	80006470 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006440:	48 ec       	lddpc	r12,80006478 <prvInitialiseTaskLists+0x7c>
80006442:	f0 1f 00 0c 	mcall	80006470 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006446:	48 ec       	lddpc	r12,8000647c <prvInitialiseTaskLists+0x80>
80006448:	f0 1f 00 0a 	mcall	80006470 <prvInitialiseTaskLists+0x74>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
8000644c:	48 dc       	lddpc	r12,80006480 <prvInitialiseTaskLists+0x84>
8000644e:	f0 1f 00 09 	mcall	80006470 <prvInitialiseTaskLists+0x74>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006452:	48 dc       	lddpc	r12,80006484 <prvInitialiseTaskLists+0x88>
80006454:	f0 1f 00 07 	mcall	80006470 <prvInitialiseTaskLists+0x74>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006458:	48 c8       	lddpc	r8,80006488 <prvInitialiseTaskLists+0x8c>
8000645a:	48 79       	lddpc	r9,80006474 <prvInitialiseTaskLists+0x78>
8000645c:	91 09       	st.w	r8[0x0],r9
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000645e:	48 c8       	lddpc	r8,8000648c <prvInitialiseTaskLists+0x90>
80006460:	48 69       	lddpc	r9,80006478 <prvInitialiseTaskLists+0x7c>
80006462:	91 09       	st.w	r8[0x0],r9
}
80006464:	2f fd       	sub	sp,-4
80006466:	e3 cd 80 80 	ldm	sp++,r7,pc
8000646a:	00 00       	add	r0,r0
8000646c:	00 00       	add	r0,r0
8000646e:	06 64       	and	r4,r3
80006470:	80 00       	ld.sh	r0,r0[0x0]
80006472:	4c 10       	lddpc	r0,80006574 <prvAddCurrentTaskToDelayedList+0x4c>
80006474:	00 00       	add	r0,r0
80006476:	07 04       	ld.w	r4,r3++
80006478:	00 00       	add	r0,r0
8000647a:	07 18       	ld.sh	r8,r3++
8000647c:	00 00       	add	r0,r0
8000647e:	07 34       	ld.ub	r4,r3++
80006480:	00 00       	add	r0,r0
80006482:	07 48       	ld.w	r8,--r3
80006484:	00 00       	add	r0,r0
80006486:	07 60       	ld.uh	r0,--r3
80006488:	00 00       	add	r0,r0
8000648a:	07 2c       	ld.uh	r12,r3++
8000648c:	00 00       	add	r0,r0
8000648e:	07 30       	ld.ub	r0,r3++

80006490 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
80006490:	eb cd 40 80 	pushm	r7,lr
80006494:	1a 97       	mov	r7,sp
80006496:	20 2d       	sub	sp,8
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006498:	49 b8       	lddpc	r8,80006504 <prvCheckTasksWaitingTermination+0x74>
8000649a:	70 08       	ld.w	r8,r8[0x0]
8000649c:	58 08       	cp.w	r8,0
8000649e:	c2 f0       	breq	800064fc <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
800064a0:	f0 1f 00 1a 	mcall	80006508 <prvCheckTasksWaitingTermination+0x78>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800064a4:	49 a8       	lddpc	r8,8000650c <prvCheckTasksWaitingTermination+0x7c>
800064a6:	70 08       	ld.w	r8,r8[0x0]
800064a8:	58 08       	cp.w	r8,0
800064aa:	5f 08       	sreq	r8
800064ac:	ef 48 ff f8 	st.w	r7[-8],r8
			xTaskResumeAll();
800064b0:	f0 1f 00 18 	mcall	80006510 <prvCheckTasksWaitingTermination+0x80>

			if( xListIsEmpty == pdFALSE )
800064b4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800064b8:	58 08       	cp.w	r8,0
800064ba:	c2 11       	brne	800064fc <prvCheckTasksWaitingTermination+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800064bc:	f0 1f 00 16 	mcall	80006514 <prvCheckTasksWaitingTermination+0x84>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800064c0:	49 38       	lddpc	r8,8000650c <prvCheckTasksWaitingTermination+0x7c>
800064c2:	2f 88       	sub	r8,-8
800064c4:	70 18       	ld.w	r8,r8[0x4]
800064c6:	70 38       	ld.w	r8,r8[0xc]
800064c8:	ef 48 ff fc 	st.w	r7[-4],r8
					vListRemove( &( pxTCB->xGenericListItem ) );
800064cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800064d0:	2f c8       	sub	r8,-4
800064d2:	10 9c       	mov	r12,r8
800064d4:	f0 1f 00 11 	mcall	80006518 <prvCheckTasksWaitingTermination+0x88>
					--uxCurrentNumberOfTasks;
800064d8:	49 18       	lddpc	r8,8000651c <prvCheckTasksWaitingTermination+0x8c>
800064da:	70 08       	ld.w	r8,r8[0x0]
800064dc:	f0 c9 00 01 	sub	r9,r8,1
800064e0:	48 f8       	lddpc	r8,8000651c <prvCheckTasksWaitingTermination+0x8c>
800064e2:	91 09       	st.w	r8[0x0],r9
					--uxTasksDeleted;
800064e4:	48 88       	lddpc	r8,80006504 <prvCheckTasksWaitingTermination+0x74>
800064e6:	70 08       	ld.w	r8,r8[0x0]
800064e8:	f0 c9 00 01 	sub	r9,r8,1
800064ec:	48 68       	lddpc	r8,80006504 <prvCheckTasksWaitingTermination+0x74>
800064ee:	91 09       	st.w	r8[0x0],r9
				}
				taskEXIT_CRITICAL();
800064f0:	f0 1f 00 0c 	mcall	80006520 <prvCheckTasksWaitingTermination+0x90>

				prvDeleteTCB( pxTCB );
800064f4:	ee fc ff fc 	ld.w	r12,r7[-4]
800064f8:	f0 1f 00 0b 	mcall	80006524 <prvCheckTasksWaitingTermination+0x94>
			}
		}
	}
	#endif
}
800064fc:	2f ed       	sub	sp,-8
800064fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80006502:	00 00       	add	r0,r0
80006504:	00 00       	add	r0,r0
80006506:	07 5c       	ld.sh	r12,--r3
80006508:	80 00       	ld.sh	r0,r0[0x0]
8000650a:	5d 64       	*unknown*
8000650c:	00 00       	add	r0,r0
8000650e:	07 48       	ld.w	r8,--r3
80006510:	80 00       	ld.sh	r0,r0[0x0]
80006512:	5d 80       	*unknown*
80006514:	80 00       	ld.sh	r0,r0[0x0]
80006516:	4f a0       	lddpc	r0,800066fc <__avr32_udiv64+0x94>
80006518:	80 00       	ld.sh	r0,r0[0x0]
8000651a:	4d 8a       	lddpc	r10,80006678 <__avr32_udiv64+0x10>
8000651c:	00 00       	add	r0,r0
8000651e:	07 74       	ld.ub	r4,--r3
80006520:	80 00       	ld.sh	r0,r0[0x0]
80006522:	4f bc       	lddpc	r12,8000670c <__avr32_udiv64+0xa4>
80006524:	80 00       	ld.sh	r0,r0[0x0]
80006526:	66 3c       	ld.w	r12,r3[0xc]

80006528 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006528:	eb cd 40 80 	pushm	r7,lr
8000652c:	1a 97       	mov	r7,sp
8000652e:	20 1d       	sub	sp,4
80006530:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006534:	49 78       	lddpc	r8,80006590 <prvAddCurrentTaskToDelayedList+0x68>
80006536:	70 08       	ld.w	r8,r8[0x0]
80006538:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000653c:	91 19       	st.w	r8[0x4],r9

	if( xTimeToWake < xTickCount )
8000653e:	49 68       	lddpc	r8,80006594 <prvAddCurrentTaskToDelayedList+0x6c>
80006540:	70 08       	ld.w	r8,r8[0x0]
80006542:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006546:	10 39       	cp.w	r9,r8
80006548:	c0 c2       	brcc	80006560 <prvAddCurrentTaskToDelayedList+0x38>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000654a:	49 28       	lddpc	r8,80006590 <prvAddCurrentTaskToDelayedList+0x68>
8000654c:	70 08       	ld.w	r8,r8[0x0]
8000654e:	f0 c9 ff fc 	sub	r9,r8,-4
80006552:	49 28       	lddpc	r8,80006598 <prvAddCurrentTaskToDelayedList+0x70>
80006554:	70 08       	ld.w	r8,r8[0x0]
80006556:	12 9b       	mov	r11,r9
80006558:	10 9c       	mov	r12,r8
8000655a:	f0 1f 00 11 	mcall	8000659c <prvAddCurrentTaskToDelayedList+0x74>
8000655e:	c1 58       	rjmp	80006588 <prvAddCurrentTaskToDelayedList+0x60>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006560:	48 c8       	lddpc	r8,80006590 <prvAddCurrentTaskToDelayedList+0x68>
80006562:	70 08       	ld.w	r8,r8[0x0]
80006564:	f0 c9 ff fc 	sub	r9,r8,-4
80006568:	48 e8       	lddpc	r8,800065a0 <prvAddCurrentTaskToDelayedList+0x78>
8000656a:	70 08       	ld.w	r8,r8[0x0]
8000656c:	12 9b       	mov	r11,r9
8000656e:	10 9c       	mov	r12,r8
80006570:	f0 1f 00 0b 	mcall	8000659c <prvAddCurrentTaskToDelayedList+0x74>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006574:	48 c8       	lddpc	r8,800065a4 <prvAddCurrentTaskToDelayedList+0x7c>
80006576:	70 08       	ld.w	r8,r8[0x0]
80006578:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000657c:	10 39       	cp.w	r9,r8
8000657e:	c0 52       	brcc	80006588 <prvAddCurrentTaskToDelayedList+0x60>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006580:	48 98       	lddpc	r8,800065a4 <prvAddCurrentTaskToDelayedList+0x7c>
80006582:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006586:	91 09       	st.w	r8[0x0],r9
		}
	}
}
80006588:	2f fd       	sub	sp,-4
8000658a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000658e:	00 00       	add	r0,r0
80006590:	00 00       	add	r0,r0
80006592:	06 60       	and	r0,r3
80006594:	00 00       	add	r0,r0
80006596:	07 78       	ld.ub	r8,--r3
80006598:	00 00       	add	r0,r0
8000659a:	07 30       	ld.ub	r0,r3++
8000659c:	80 00       	ld.sh	r0,r0[0x0]
8000659e:	4c e8       	lddpc	r8,800066d4 <__avr32_udiv64+0x6c>
800065a0:	00 00       	add	r0,r0
800065a2:	07 2c       	ld.uh	r12,r3++
800065a4:	00 00       	add	r0,r0
800065a6:	00 24       	rsub	r4,r0

800065a8 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
800065a8:	eb cd 40 80 	pushm	r7,lr
800065ac:	1a 97       	mov	r7,sp
800065ae:	20 3d       	sub	sp,12
800065b0:	18 98       	mov	r8,r12
800065b2:	ef 4b ff f4 	st.w	r7[-12],r11
800065b6:	ef 58 ff f8 	st.h	r7[-8],r8
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800065ba:	34 4c       	mov	r12,68
800065bc:	f0 1f 00 1d 	mcall	80006630 <prvAllocateTCBAndStack+0x88>
800065c0:	18 98       	mov	r8,r12
800065c2:	ef 48 ff fc 	st.w	r7[-4],r8

	if( pxNewTCB != NULL )
800065c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800065ca:	58 08       	cp.w	r8,0
800065cc:	c2 c0       	breq	80006624 <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800065ce:	ee f8 ff f4 	ld.w	r8,r7[-12]
800065d2:	58 08       	cp.w	r8,0
800065d4:	c0 91       	brne	800065e6 <prvAllocateTCBAndStack+0x3e>
800065d6:	ef 18 ff f8 	ld.uh	r8,r7[-8]
800065da:	a3 68       	lsl	r8,0x2
800065dc:	10 9c       	mov	r12,r8
800065de:	f0 1f 00 15 	mcall	80006630 <prvAllocateTCBAndStack+0x88>
800065e2:	18 98       	mov	r8,r12
800065e4:	c0 38       	rjmp	800065ea <prvAllocateTCBAndStack+0x42>
800065e6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800065ea:	ee f9 ff fc 	ld.w	r9,r7[-4]
800065ee:	93 c8       	st.w	r9[0x30],r8

		if( pxNewTCB->pxStack == NULL )
800065f0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800065f4:	70 c8       	ld.w	r8,r8[0x30]
800065f6:	58 08       	cp.w	r8,0
800065f8:	c0 91       	brne	8000660a <prvAllocateTCBAndStack+0x62>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800065fa:	ee fc ff fc 	ld.w	r12,r7[-4]
800065fe:	f0 1f 00 0e 	mcall	80006634 <prvAllocateTCBAndStack+0x8c>
			pxNewTCB = NULL;
80006602:	30 08       	mov	r8,0
80006604:	ef 48 ff fc 	st.w	r7[-4],r8
80006608:	c0 e8       	rjmp	80006624 <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
8000660a:	ef 18 ff f8 	ld.uh	r8,r7[-8]
8000660e:	f0 09 15 02 	lsl	r9,r8,0x2
80006612:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006616:	70 c8       	ld.w	r8,r8[0x30]
80006618:	12 9a       	mov	r10,r9
8000661a:	e0 6b 00 a5 	mov	r11,165
8000661e:	10 9c       	mov	r12,r8
80006620:	f0 1f 00 06 	mcall	80006638 <prvAllocateTCBAndStack+0x90>
		}
	}

	return pxNewTCB;
80006624:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80006628:	10 9c       	mov	r12,r8
8000662a:	2f dd       	sub	sp,-12
8000662c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006630:	80 00       	ld.sh	r0,r0[0x0]
80006632:	53 48       	stdsp	sp[0xd0],r8
80006634:	80 00       	ld.sh	r0,r0[0x0]
80006636:	53 84       	stdsp	sp[0xe0],r4
80006638:	80 00       	ld.sh	r0,r0[0x0]
8000663a:	6e 9c       	ld.w	r12,r7[0x24]

8000663c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
8000663c:	eb cd 40 80 	pushm	r7,lr
80006640:	1a 97       	mov	r7,sp
80006642:	20 1d       	sub	sp,4
80006644:	ef 4c ff fc 	st.w	r7[-4],r12
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006648:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000664c:	70 c8       	ld.w	r8,r8[0x30]
8000664e:	10 9c       	mov	r12,r8
80006650:	f0 1f 00 05 	mcall	80006664 <prvDeleteTCB+0x28>
		vPortFree( pxTCB );
80006654:	ee fc ff fc 	ld.w	r12,r7[-4]
80006658:	f0 1f 00 03 	mcall	80006664 <prvDeleteTCB+0x28>
	}
8000665c:	2f fd       	sub	sp,-4
8000665e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006662:	00 00       	add	r0,r0
80006664:	80 00       	ld.sh	r0,r0[0x0]
80006666:	53 84       	stdsp	sp[0xe0],r4

80006668 <__avr32_udiv64>:
80006668:	d4 31       	pushm	r0-r7,lr
8000666a:	1a 97       	mov	r7,sp
8000666c:	20 3d       	sub	sp,12
8000666e:	10 9c       	mov	r12,r8
80006670:	12 9e       	mov	lr,r9
80006672:	14 93       	mov	r3,r10
80006674:	58 09       	cp.w	r9,0
80006676:	e0 81 00 bd 	brne	800067f0 <__avr32_udiv64+0x188>
8000667a:	16 38       	cp.w	r8,r11
8000667c:	e0 88 00 40 	brls	800066fc <__avr32_udiv64+0x94>
80006680:	f0 08 12 00 	clz	r8,r8
80006684:	c0 d0       	breq	8000669e <__avr32_udiv64+0x36>
80006686:	f6 08 09 4b 	lsl	r11,r11,r8
8000668a:	f0 09 11 20 	rsub	r9,r8,32
8000668e:	f8 08 09 4c 	lsl	r12,r12,r8
80006692:	f4 09 0a 49 	lsr	r9,r10,r9
80006696:	f4 08 09 43 	lsl	r3,r10,r8
8000669a:	f3 eb 10 0b 	or	r11,r9,r11
8000669e:	f8 0e 16 10 	lsr	lr,r12,0x10
800066a2:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
800066a6:	f6 0e 0d 00 	divu	r0,r11,lr
800066aa:	e6 0b 16 10 	lsr	r11,r3,0x10
800066ae:	00 99       	mov	r9,r0
800066b0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800066b4:	e0 0a 02 48 	mul	r8,r0,r10
800066b8:	10 3b       	cp.w	r11,r8
800066ba:	c0 a2       	brcc	800066ce <__avr32_udiv64+0x66>
800066bc:	20 19       	sub	r9,1
800066be:	18 0b       	add	r11,r12
800066c0:	18 3b       	cp.w	r11,r12
800066c2:	c0 63       	brcs	800066ce <__avr32_udiv64+0x66>
800066c4:	10 3b       	cp.w	r11,r8
800066c6:	f7 b9 03 01 	sublo	r9,1
800066ca:	f7 dc e3 0b 	addcs	r11,r11,r12
800066ce:	f6 08 01 01 	sub	r1,r11,r8
800066d2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
800066d6:	e2 0e 0d 00 	divu	r0,r1,lr
800066da:	e7 e1 11 03 	or	r3,r3,r1<<0x10
800066de:	00 98       	mov	r8,r0
800066e0:	e0 0a 02 4a 	mul	r10,r0,r10
800066e4:	14 33       	cp.w	r3,r10
800066e6:	c0 82       	brcc	800066f6 <__avr32_udiv64+0x8e>
800066e8:	20 18       	sub	r8,1
800066ea:	18 03       	add	r3,r12
800066ec:	18 33       	cp.w	r3,r12
800066ee:	c0 43       	brcs	800066f6 <__avr32_udiv64+0x8e>
800066f0:	14 33       	cp.w	r3,r10
800066f2:	f7 b8 03 01 	sublo	r8,1
800066f6:	f1 e9 11 08 	or	r8,r8,r9<<0x10
800066fa:	cd f8       	rjmp	800068b8 <__avr32_udiv64+0x250>
800066fc:	58 08       	cp.w	r8,0
800066fe:	c0 51       	brne	80006708 <__avr32_udiv64+0xa0>
80006700:	30 19       	mov	r9,1
80006702:	f2 08 0d 08 	divu	r8,r9,r8
80006706:	10 9c       	mov	r12,r8
80006708:	f8 06 12 00 	clz	r6,r12
8000670c:	c0 41       	brne	80006714 <__avr32_udiv64+0xac>
8000670e:	18 1b       	sub	r11,r12
80006710:	30 19       	mov	r9,1
80006712:	c4 08       	rjmp	80006792 <__avr32_udiv64+0x12a>
80006714:	ec 01 11 20 	rsub	r1,r6,32
80006718:	f4 01 0a 49 	lsr	r9,r10,r1
8000671c:	f8 06 09 4c 	lsl	r12,r12,r6
80006720:	f6 06 09 48 	lsl	r8,r11,r6
80006724:	f6 01 0a 41 	lsr	r1,r11,r1
80006728:	f3 e8 10 08 	or	r8,r9,r8
8000672c:	f8 03 16 10 	lsr	r3,r12,0x10
80006730:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
80006734:	e2 03 0d 00 	divu	r0,r1,r3
80006738:	f0 0b 16 10 	lsr	r11,r8,0x10
8000673c:	00 9e       	mov	lr,r0
8000673e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80006742:	e0 05 02 49 	mul	r9,r0,r5
80006746:	12 3b       	cp.w	r11,r9
80006748:	c0 a2       	brcc	8000675c <__avr32_udiv64+0xf4>
8000674a:	20 1e       	sub	lr,1
8000674c:	18 0b       	add	r11,r12
8000674e:	18 3b       	cp.w	r11,r12
80006750:	c0 63       	brcs	8000675c <__avr32_udiv64+0xf4>
80006752:	12 3b       	cp.w	r11,r9
80006754:	f7 be 03 01 	sublo	lr,1
80006758:	f7 dc e3 0b 	addcs	r11,r11,r12
8000675c:	12 1b       	sub	r11,r9
8000675e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80006762:	f6 03 0d 02 	divu	r2,r11,r3
80006766:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000676a:	04 99       	mov	r9,r2
8000676c:	e4 05 02 4b 	mul	r11,r2,r5
80006770:	16 38       	cp.w	r8,r11
80006772:	c0 a2       	brcc	80006786 <__avr32_udiv64+0x11e>
80006774:	20 19       	sub	r9,1
80006776:	18 08       	add	r8,r12
80006778:	18 38       	cp.w	r8,r12
8000677a:	c0 63       	brcs	80006786 <__avr32_udiv64+0x11e>
8000677c:	16 38       	cp.w	r8,r11
8000677e:	f7 b9 03 01 	sublo	r9,1
80006782:	f1 dc e3 08 	addcs	r8,r8,r12
80006786:	f4 06 09 43 	lsl	r3,r10,r6
8000678a:	f0 0b 01 0b 	sub	r11,r8,r11
8000678e:	f3 ee 11 09 	or	r9,r9,lr<<0x10
80006792:	f8 06 16 10 	lsr	r6,r12,0x10
80006796:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000679a:	f6 06 0d 00 	divu	r0,r11,r6
8000679e:	e6 0b 16 10 	lsr	r11,r3,0x10
800067a2:	00 9a       	mov	r10,r0
800067a4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800067a8:	e0 0e 02 48 	mul	r8,r0,lr
800067ac:	10 3b       	cp.w	r11,r8
800067ae:	c0 a2       	brcc	800067c2 <__avr32_udiv64+0x15a>
800067b0:	20 1a       	sub	r10,1
800067b2:	18 0b       	add	r11,r12
800067b4:	18 3b       	cp.w	r11,r12
800067b6:	c0 63       	brcs	800067c2 <__avr32_udiv64+0x15a>
800067b8:	10 3b       	cp.w	r11,r8
800067ba:	f7 ba 03 01 	sublo	r10,1
800067be:	f7 dc e3 0b 	addcs	r11,r11,r12
800067c2:	f6 08 01 01 	sub	r1,r11,r8
800067c6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
800067ca:	e2 06 0d 00 	divu	r0,r1,r6
800067ce:	e7 e1 11 03 	or	r3,r3,r1<<0x10
800067d2:	00 98       	mov	r8,r0
800067d4:	e0 0e 02 4b 	mul	r11,r0,lr
800067d8:	16 33       	cp.w	r3,r11
800067da:	c0 82       	brcc	800067ea <__avr32_udiv64+0x182>
800067dc:	20 18       	sub	r8,1
800067de:	18 03       	add	r3,r12
800067e0:	18 33       	cp.w	r3,r12
800067e2:	c0 43       	brcs	800067ea <__avr32_udiv64+0x182>
800067e4:	16 33       	cp.w	r3,r11
800067e6:	f7 b8 03 01 	sublo	r8,1
800067ea:	f1 ea 11 08 	or	r8,r8,r10<<0x10
800067ee:	c6 98       	rjmp	800068c0 <__avr32_udiv64+0x258>
800067f0:	16 39       	cp.w	r9,r11
800067f2:	e0 8b 00 65 	brhi	800068bc <__avr32_udiv64+0x254>
800067f6:	f2 09 12 00 	clz	r9,r9
800067fa:	c0 b1       	brne	80006810 <__avr32_udiv64+0x1a8>
800067fc:	10 3a       	cp.w	r10,r8
800067fe:	5f 2a       	srhs	r10
80006800:	1c 3b       	cp.w	r11,lr
80006802:	5f b8       	srhi	r8
80006804:	10 4a       	or	r10,r8
80006806:	f2 0a 18 00 	cp.b	r10,r9
8000680a:	c5 90       	breq	800068bc <__avr32_udiv64+0x254>
8000680c:	30 18       	mov	r8,1
8000680e:	c5 98       	rjmp	800068c0 <__avr32_udiv64+0x258>
80006810:	f0 09 09 46 	lsl	r6,r8,r9
80006814:	f2 03 11 20 	rsub	r3,r9,32
80006818:	fc 09 09 4e 	lsl	lr,lr,r9
8000681c:	f0 03 0a 48 	lsr	r8,r8,r3
80006820:	f6 09 09 4c 	lsl	r12,r11,r9
80006824:	f4 03 0a 42 	lsr	r2,r10,r3
80006828:	ef 46 ff f4 	st.w	r7[-12],r6
8000682c:	f6 03 0a 43 	lsr	r3,r11,r3
80006830:	18 42       	or	r2,r12
80006832:	f1 ee 10 0c 	or	r12,r8,lr
80006836:	f8 01 16 10 	lsr	r1,r12,0x10
8000683a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000683e:	e6 01 0d 04 	divu	r4,r3,r1
80006842:	e4 03 16 10 	lsr	r3,r2,0x10
80006846:	08 9e       	mov	lr,r4
80006848:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000684c:	e8 06 02 48 	mul	r8,r4,r6
80006850:	10 33       	cp.w	r3,r8
80006852:	c0 a2       	brcc	80006866 <__avr32_udiv64+0x1fe>
80006854:	20 1e       	sub	lr,1
80006856:	18 03       	add	r3,r12
80006858:	18 33       	cp.w	r3,r12
8000685a:	c0 63       	brcs	80006866 <__avr32_udiv64+0x1fe>
8000685c:	10 33       	cp.w	r3,r8
8000685e:	f7 be 03 01 	sublo	lr,1
80006862:	e7 dc e3 03 	addcs	r3,r3,r12
80006866:	10 13       	sub	r3,r8
80006868:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000686c:	e6 01 0d 00 	divu	r0,r3,r1
80006870:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80006874:	00 98       	mov	r8,r0
80006876:	e0 06 02 46 	mul	r6,r0,r6
8000687a:	0c 3b       	cp.w	r11,r6
8000687c:	c0 a2       	brcc	80006890 <__avr32_udiv64+0x228>
8000687e:	20 18       	sub	r8,1
80006880:	18 0b       	add	r11,r12
80006882:	18 3b       	cp.w	r11,r12
80006884:	c0 63       	brcs	80006890 <__avr32_udiv64+0x228>
80006886:	0c 3b       	cp.w	r11,r6
80006888:	f7 dc e3 0b 	addcs	r11,r11,r12
8000688c:	f7 b8 03 01 	sublo	r8,1
80006890:	f1 ee 11 08 	or	r8,r8,lr<<0x10
80006894:	ee f4 ff f4 	ld.w	r4,r7[-12]
80006898:	0c 1b       	sub	r11,r6
8000689a:	f0 04 06 42 	mulu.d	r2,r8,r4
8000689e:	06 95       	mov	r5,r3
800068a0:	16 35       	cp.w	r5,r11
800068a2:	e0 8b 00 0a 	brhi	800068b6 <__avr32_udiv64+0x24e>
800068a6:	5f 0b       	sreq	r11
800068a8:	f4 09 09 49 	lsl	r9,r10,r9
800068ac:	12 32       	cp.w	r2,r9
800068ae:	5f b9       	srhi	r9
800068b0:	f7 e9 00 09 	and	r9,r11,r9
800068b4:	c0 60       	breq	800068c0 <__avr32_udiv64+0x258>
800068b6:	20 18       	sub	r8,1
800068b8:	30 09       	mov	r9,0
800068ba:	c0 38       	rjmp	800068c0 <__avr32_udiv64+0x258>
800068bc:	30 09       	mov	r9,0
800068be:	12 98       	mov	r8,r9
800068c0:	10 9a       	mov	r10,r8
800068c2:	12 93       	mov	r3,r9
800068c4:	10 92       	mov	r2,r8
800068c6:	12 9b       	mov	r11,r9
800068c8:	2f dd       	sub	sp,-12
800068ca:	d8 32       	popm	r0-r7,pc

800068cc <atexit>:
800068cc:	d4 01       	pushm	lr
800068ce:	30 09       	mov	r9,0
800068d0:	18 9b       	mov	r11,r12
800068d2:	12 9a       	mov	r10,r9
800068d4:	12 9c       	mov	r12,r9
800068d6:	e0 a0 16 af 	rcall	80009634 <__register_exitproc>
800068da:	d8 02       	popm	pc

800068dc <exit>:
800068dc:	d4 21       	pushm	r4-r7,lr
800068de:	30 0b       	mov	r11,0
800068e0:	18 97       	mov	r7,r12
800068e2:	e0 a0 16 fb 	rcall	800096d8 <__call_exitprocs>
800068e6:	fe c8 a3 b2 	sub	r8,pc,-23630
800068ea:	70 0c       	ld.w	r12,r8[0x0]
800068ec:	78 a8       	ld.w	r8,r12[0x28]
800068ee:	58 08       	cp.w	r8,0
800068f0:	c0 20       	breq	800068f4 <exit+0x18>
800068f2:	5d 18       	icall	r8
800068f4:	0e 9c       	mov	r12,r7
800068f6:	e0 a0 04 7e 	rcall	800071f2 <_exit>
800068fa:	d7 03       	nop

800068fc <free>:
800068fc:	d4 01       	pushm	lr
800068fe:	e0 68 01 18 	mov	r8,280
80006902:	18 9b       	mov	r11,r12
80006904:	70 0c       	ld.w	r12,r8[0x0]
80006906:	e0 a0 1f 45 	rcall	8000a790 <_free_r>
8000690a:	d8 02       	popm	pc

8000690c <malloc>:
8000690c:	d4 01       	pushm	lr
8000690e:	e0 68 01 18 	mov	r8,280
80006912:	18 9b       	mov	r11,r12
80006914:	70 0c       	ld.w	r12,r8[0x0]
80006916:	c0 3c       	rcall	8000691c <_malloc_r>
80006918:	d8 02       	popm	pc
8000691a:	d7 03       	nop

8000691c <_malloc_r>:
8000691c:	d4 31       	pushm	r0-r7,lr
8000691e:	f6 c8 ff f5 	sub	r8,r11,-11
80006922:	18 95       	mov	r5,r12
80006924:	10 97       	mov	r7,r8
80006926:	e0 17 ff f8 	andl	r7,0xfff8
8000692a:	59 68       	cp.w	r8,22
8000692c:	f9 b7 08 10 	movls	r7,16
80006930:	16 37       	cp.w	r7,r11
80006932:	5f 38       	srlo	r8
80006934:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006938:	c0 50       	breq	80006942 <_malloc_r+0x26>
8000693a:	30 c8       	mov	r8,12
8000693c:	99 38       	st.w	r12[0xc],r8
8000693e:	e0 8f 01 fa 	bral	80006d32 <_malloc_r+0x416>
80006942:	fe b0 f2 85 	rcall	80004e4c <__malloc_lock>
80006946:	e0 47 01 f7 	cp.w	r7,503
8000694a:	e0 8b 00 1d 	brhi	80006984 <_malloc_r+0x68>
8000694e:	ee 03 16 03 	lsr	r3,r7,0x3
80006952:	e0 68 01 1c 	mov	r8,284
80006956:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000695a:	70 36       	ld.w	r6,r8[0xc]
8000695c:	10 36       	cp.w	r6,r8
8000695e:	c0 61       	brne	8000696a <_malloc_r+0x4e>
80006960:	ec c8 ff f8 	sub	r8,r6,-8
80006964:	70 36       	ld.w	r6,r8[0xc]
80006966:	10 36       	cp.w	r6,r8
80006968:	c0 c0       	breq	80006980 <_malloc_r+0x64>
8000696a:	6c 18       	ld.w	r8,r6[0x4]
8000696c:	e0 18 ff fc 	andl	r8,0xfffc
80006970:	6c 3a       	ld.w	r10,r6[0xc]
80006972:	ec 08 00 09 	add	r9,r6,r8
80006976:	0a 9c       	mov	r12,r5
80006978:	6c 28       	ld.w	r8,r6[0x8]
8000697a:	95 28       	st.w	r10[0x8],r8
8000697c:	91 3a       	st.w	r8[0xc],r10
8000697e:	c4 78       	rjmp	80006a0c <_malloc_r+0xf0>
80006980:	2f e3       	sub	r3,-2
80006982:	c4 d8       	rjmp	80006a1c <_malloc_r+0x100>
80006984:	ee 03 16 09 	lsr	r3,r7,0x9
80006988:	c0 41       	brne	80006990 <_malloc_r+0x74>
8000698a:	ee 03 16 03 	lsr	r3,r7,0x3
8000698e:	c2 68       	rjmp	800069da <_malloc_r+0xbe>
80006990:	58 43       	cp.w	r3,4
80006992:	e0 8b 00 06 	brhi	8000699e <_malloc_r+0x82>
80006996:	ee 03 16 06 	lsr	r3,r7,0x6
8000699a:	2c 83       	sub	r3,-56
8000699c:	c1 f8       	rjmp	800069da <_malloc_r+0xbe>
8000699e:	59 43       	cp.w	r3,20
800069a0:	e0 8b 00 04 	brhi	800069a8 <_malloc_r+0x8c>
800069a4:	2a 53       	sub	r3,-91
800069a6:	c1 a8       	rjmp	800069da <_malloc_r+0xbe>
800069a8:	e0 43 00 54 	cp.w	r3,84
800069ac:	e0 8b 00 06 	brhi	800069b8 <_malloc_r+0x9c>
800069b0:	ee 03 16 0c 	lsr	r3,r7,0xc
800069b4:	29 23       	sub	r3,-110
800069b6:	c1 28       	rjmp	800069da <_malloc_r+0xbe>
800069b8:	e0 43 01 54 	cp.w	r3,340
800069bc:	e0 8b 00 06 	brhi	800069c8 <_malloc_r+0xac>
800069c0:	ee 03 16 0f 	lsr	r3,r7,0xf
800069c4:	28 93       	sub	r3,-119
800069c6:	c0 a8       	rjmp	800069da <_malloc_r+0xbe>
800069c8:	e0 43 05 54 	cp.w	r3,1364
800069cc:	e0 88 00 04 	brls	800069d4 <_malloc_r+0xb8>
800069d0:	37 e3       	mov	r3,126
800069d2:	c0 48       	rjmp	800069da <_malloc_r+0xbe>
800069d4:	ee 03 16 12 	lsr	r3,r7,0x12
800069d8:	28 43       	sub	r3,-124
800069da:	e0 6a 01 1c 	mov	r10,284
800069de:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800069e2:	74 36       	ld.w	r6,r10[0xc]
800069e4:	c1 98       	rjmp	80006a16 <_malloc_r+0xfa>
800069e6:	6c 19       	ld.w	r9,r6[0x4]
800069e8:	e0 19 ff fc 	andl	r9,0xfffc
800069ec:	f2 07 01 0b 	sub	r11,r9,r7
800069f0:	58 fb       	cp.w	r11,15
800069f2:	e0 8a 00 04 	brle	800069fa <_malloc_r+0xde>
800069f6:	20 13       	sub	r3,1
800069f8:	c1 18       	rjmp	80006a1a <_malloc_r+0xfe>
800069fa:	6c 38       	ld.w	r8,r6[0xc]
800069fc:	58 0b       	cp.w	r11,0
800069fe:	c0 b5       	brlt	80006a14 <_malloc_r+0xf8>
80006a00:	6c 2a       	ld.w	r10,r6[0x8]
80006a02:	ec 09 00 09 	add	r9,r6,r9
80006a06:	0a 9c       	mov	r12,r5
80006a08:	91 2a       	st.w	r8[0x8],r10
80006a0a:	95 38       	st.w	r10[0xc],r8
80006a0c:	72 18       	ld.w	r8,r9[0x4]
80006a0e:	a1 a8       	sbr	r8,0x0
80006a10:	93 18       	st.w	r9[0x4],r8
80006a12:	cb c8       	rjmp	80006b8a <_malloc_r+0x26e>
80006a14:	10 96       	mov	r6,r8
80006a16:	14 36       	cp.w	r6,r10
80006a18:	ce 71       	brne	800069e6 <_malloc_r+0xca>
80006a1a:	2f f3       	sub	r3,-1
80006a1c:	e0 6a 01 1c 	mov	r10,284
80006a20:	f4 cc ff f8 	sub	r12,r10,-8
80006a24:	78 26       	ld.w	r6,r12[0x8]
80006a26:	18 36       	cp.w	r6,r12
80006a28:	c6 c0       	breq	80006b00 <_malloc_r+0x1e4>
80006a2a:	6c 19       	ld.w	r9,r6[0x4]
80006a2c:	e0 19 ff fc 	andl	r9,0xfffc
80006a30:	f2 07 01 08 	sub	r8,r9,r7
80006a34:	58 f8       	cp.w	r8,15
80006a36:	e0 89 00 8f 	brgt	80006b54 <_malloc_r+0x238>
80006a3a:	99 3c       	st.w	r12[0xc],r12
80006a3c:	99 2c       	st.w	r12[0x8],r12
80006a3e:	58 08       	cp.w	r8,0
80006a40:	c0 55       	brlt	80006a4a <_malloc_r+0x12e>
80006a42:	ec 09 00 09 	add	r9,r6,r9
80006a46:	0a 9c       	mov	r12,r5
80006a48:	ce 2b       	rjmp	80006a0c <_malloc_r+0xf0>
80006a4a:	e0 49 01 ff 	cp.w	r9,511
80006a4e:	e0 8b 00 13 	brhi	80006a74 <_malloc_r+0x158>
80006a52:	a3 99       	lsr	r9,0x3
80006a54:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006a58:	70 2b       	ld.w	r11,r8[0x8]
80006a5a:	8d 38       	st.w	r6[0xc],r8
80006a5c:	8d 2b       	st.w	r6[0x8],r11
80006a5e:	97 36       	st.w	r11[0xc],r6
80006a60:	91 26       	st.w	r8[0x8],r6
80006a62:	a3 49       	asr	r9,0x2
80006a64:	74 18       	ld.w	r8,r10[0x4]
80006a66:	30 1b       	mov	r11,1
80006a68:	f6 09 09 49 	lsl	r9,r11,r9
80006a6c:	f1 e9 10 09 	or	r9,r8,r9
80006a70:	95 19       	st.w	r10[0x4],r9
80006a72:	c4 78       	rjmp	80006b00 <_malloc_r+0x1e4>
80006a74:	f2 0a 16 09 	lsr	r10,r9,0x9
80006a78:	58 4a       	cp.w	r10,4
80006a7a:	e0 8b 00 07 	brhi	80006a88 <_malloc_r+0x16c>
80006a7e:	f2 0a 16 06 	lsr	r10,r9,0x6
80006a82:	2c 8a       	sub	r10,-56
80006a84:	c2 08       	rjmp	80006ac4 <_malloc_r+0x1a8>
80006a86:	d7 03       	nop
80006a88:	59 4a       	cp.w	r10,20
80006a8a:	e0 8b 00 04 	brhi	80006a92 <_malloc_r+0x176>
80006a8e:	2a 5a       	sub	r10,-91
80006a90:	c1 a8       	rjmp	80006ac4 <_malloc_r+0x1a8>
80006a92:	e0 4a 00 54 	cp.w	r10,84
80006a96:	e0 8b 00 06 	brhi	80006aa2 <_malloc_r+0x186>
80006a9a:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006a9e:	29 2a       	sub	r10,-110
80006aa0:	c1 28       	rjmp	80006ac4 <_malloc_r+0x1a8>
80006aa2:	e0 4a 01 54 	cp.w	r10,340
80006aa6:	e0 8b 00 06 	brhi	80006ab2 <_malloc_r+0x196>
80006aaa:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006aae:	28 9a       	sub	r10,-119
80006ab0:	c0 a8       	rjmp	80006ac4 <_malloc_r+0x1a8>
80006ab2:	e0 4a 05 54 	cp.w	r10,1364
80006ab6:	e0 88 00 04 	brls	80006abe <_malloc_r+0x1a2>
80006aba:	37 ea       	mov	r10,126
80006abc:	c0 48       	rjmp	80006ac4 <_malloc_r+0x1a8>
80006abe:	f2 0a 16 12 	lsr	r10,r9,0x12
80006ac2:	28 4a       	sub	r10,-124
80006ac4:	e0 6b 01 1c 	mov	r11,284
80006ac8:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006acc:	68 28       	ld.w	r8,r4[0x8]
80006ace:	08 38       	cp.w	r8,r4
80006ad0:	c0 e1       	brne	80006aec <_malloc_r+0x1d0>
80006ad2:	76 19       	ld.w	r9,r11[0x4]
80006ad4:	a3 4a       	asr	r10,0x2
80006ad6:	30 1e       	mov	lr,1
80006ad8:	fc 0a 09 4a 	lsl	r10,lr,r10
80006adc:	f3 ea 10 0a 	or	r10,r9,r10
80006ae0:	10 99       	mov	r9,r8
80006ae2:	97 1a       	st.w	r11[0x4],r10
80006ae4:	c0 a8       	rjmp	80006af8 <_malloc_r+0x1dc>
80006ae6:	70 28       	ld.w	r8,r8[0x8]
80006ae8:	08 38       	cp.w	r8,r4
80006aea:	c0 60       	breq	80006af6 <_malloc_r+0x1da>
80006aec:	70 1a       	ld.w	r10,r8[0x4]
80006aee:	e0 1a ff fc 	andl	r10,0xfffc
80006af2:	14 39       	cp.w	r9,r10
80006af4:	cf 93       	brcs	80006ae6 <_malloc_r+0x1ca>
80006af6:	70 39       	ld.w	r9,r8[0xc]
80006af8:	8d 39       	st.w	r6[0xc],r9
80006afa:	8d 28       	st.w	r6[0x8],r8
80006afc:	91 36       	st.w	r8[0xc],r6
80006afe:	93 26       	st.w	r9[0x8],r6
80006b00:	e6 08 14 02 	asr	r8,r3,0x2
80006b04:	30 1b       	mov	r11,1
80006b06:	e0 64 01 1c 	mov	r4,284
80006b0a:	f6 08 09 4b 	lsl	r11,r11,r8
80006b0e:	68 18       	ld.w	r8,r4[0x4]
80006b10:	10 3b       	cp.w	r11,r8
80006b12:	e0 8b 00 6b 	brhi	80006be8 <_malloc_r+0x2cc>
80006b16:	f7 e8 00 09 	and	r9,r11,r8
80006b1a:	c0 b1       	brne	80006b30 <_malloc_r+0x214>
80006b1c:	e0 13 ff fc 	andl	r3,0xfffc
80006b20:	a1 7b       	lsl	r11,0x1
80006b22:	2f c3       	sub	r3,-4
80006b24:	c0 38       	rjmp	80006b2a <_malloc_r+0x20e>
80006b26:	2f c3       	sub	r3,-4
80006b28:	a1 7b       	lsl	r11,0x1
80006b2a:	f7 e8 00 09 	and	r9,r11,r8
80006b2e:	cf c0       	breq	80006b26 <_malloc_r+0x20a>
80006b30:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006b34:	06 92       	mov	r2,r3
80006b36:	1c 91       	mov	r1,lr
80006b38:	62 36       	ld.w	r6,r1[0xc]
80006b3a:	c2 e8       	rjmp	80006b96 <_malloc_r+0x27a>
80006b3c:	6c 1a       	ld.w	r10,r6[0x4]
80006b3e:	e0 1a ff fc 	andl	r10,0xfffc
80006b42:	f4 07 01 08 	sub	r8,r10,r7
80006b46:	58 f8       	cp.w	r8,15
80006b48:	e0 8a 00 15 	brle	80006b72 <_malloc_r+0x256>
80006b4c:	6c 3a       	ld.w	r10,r6[0xc]
80006b4e:	6c 29       	ld.w	r9,r6[0x8]
80006b50:	95 29       	st.w	r10[0x8],r9
80006b52:	93 3a       	st.w	r9[0xc],r10
80006b54:	0e 99       	mov	r9,r7
80006b56:	ec 07 00 07 	add	r7,r6,r7
80006b5a:	a1 a9       	sbr	r9,0x0
80006b5c:	99 37       	st.w	r12[0xc],r7
80006b5e:	99 27       	st.w	r12[0x8],r7
80006b60:	8d 19       	st.w	r6[0x4],r9
80006b62:	ee 08 09 08 	st.w	r7[r8],r8
80006b66:	8f 2c       	st.w	r7[0x8],r12
80006b68:	8f 3c       	st.w	r7[0xc],r12
80006b6a:	a1 a8       	sbr	r8,0x0
80006b6c:	0a 9c       	mov	r12,r5
80006b6e:	8f 18       	st.w	r7[0x4],r8
80006b70:	c0 d8       	rjmp	80006b8a <_malloc_r+0x26e>
80006b72:	6c 39       	ld.w	r9,r6[0xc]
80006b74:	58 08       	cp.w	r8,0
80006b76:	c0 f5       	brlt	80006b94 <_malloc_r+0x278>
80006b78:	ec 0a 00 0a 	add	r10,r6,r10
80006b7c:	74 18       	ld.w	r8,r10[0x4]
80006b7e:	a1 a8       	sbr	r8,0x0
80006b80:	0a 9c       	mov	r12,r5
80006b82:	95 18       	st.w	r10[0x4],r8
80006b84:	6c 28       	ld.w	r8,r6[0x8]
80006b86:	93 28       	st.w	r9[0x8],r8
80006b88:	91 39       	st.w	r8[0xc],r9
80006b8a:	fe b0 f1 6f 	rcall	80004e68 <__malloc_unlock>
80006b8e:	ec cc ff f8 	sub	r12,r6,-8
80006b92:	d8 32       	popm	r0-r7,pc
80006b94:	12 96       	mov	r6,r9
80006b96:	02 36       	cp.w	r6,r1
80006b98:	cd 21       	brne	80006b3c <_malloc_r+0x220>
80006b9a:	2f f2       	sub	r2,-1
80006b9c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006ba0:	c0 30       	breq	80006ba6 <_malloc_r+0x28a>
80006ba2:	2f 81       	sub	r1,-8
80006ba4:	cc ab       	rjmp	80006b38 <_malloc_r+0x21c>
80006ba6:	1c 98       	mov	r8,lr
80006ba8:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006bac:	c0 81       	brne	80006bbc <_malloc_r+0x2a0>
80006bae:	68 19       	ld.w	r9,r4[0x4]
80006bb0:	f6 08 11 ff 	rsub	r8,r11,-1
80006bb4:	f3 e8 00 08 	and	r8,r9,r8
80006bb8:	89 18       	st.w	r4[0x4],r8
80006bba:	c0 78       	rjmp	80006bc8 <_malloc_r+0x2ac>
80006bbc:	f0 c9 00 08 	sub	r9,r8,8
80006bc0:	20 13       	sub	r3,1
80006bc2:	70 08       	ld.w	r8,r8[0x0]
80006bc4:	12 38       	cp.w	r8,r9
80006bc6:	cf 10       	breq	80006ba8 <_malloc_r+0x28c>
80006bc8:	a1 7b       	lsl	r11,0x1
80006bca:	68 18       	ld.w	r8,r4[0x4]
80006bcc:	10 3b       	cp.w	r11,r8
80006bce:	e0 8b 00 0d 	brhi	80006be8 <_malloc_r+0x2cc>
80006bd2:	58 0b       	cp.w	r11,0
80006bd4:	c0 a0       	breq	80006be8 <_malloc_r+0x2cc>
80006bd6:	04 93       	mov	r3,r2
80006bd8:	c0 38       	rjmp	80006bde <_malloc_r+0x2c2>
80006bda:	2f c3       	sub	r3,-4
80006bdc:	a1 7b       	lsl	r11,0x1
80006bde:	f7 e8 00 09 	and	r9,r11,r8
80006be2:	ca 71       	brne	80006b30 <_malloc_r+0x214>
80006be4:	cf bb       	rjmp	80006bda <_malloc_r+0x2be>
80006be6:	d7 03       	nop
80006be8:	68 23       	ld.w	r3,r4[0x8]
80006bea:	66 12       	ld.w	r2,r3[0x4]
80006bec:	e0 12 ff fc 	andl	r2,0xfffc
80006bf0:	0e 32       	cp.w	r2,r7
80006bf2:	5f 39       	srlo	r9
80006bf4:	e4 07 01 08 	sub	r8,r2,r7
80006bf8:	58 f8       	cp.w	r8,15
80006bfa:	5f aa       	srle	r10
80006bfc:	f5 e9 10 09 	or	r9,r10,r9
80006c00:	e0 80 00 9a 	breq	80006d34 <_malloc_r+0x418>
80006c04:	e0 68 07 a4 	mov	r8,1956
80006c08:	70 01       	ld.w	r1,r8[0x0]
80006c0a:	e0 68 05 28 	mov	r8,1320
80006c0e:	2f 01       	sub	r1,-16
80006c10:	70 08       	ld.w	r8,r8[0x0]
80006c12:	0e 01       	add	r1,r7
80006c14:	5b f8       	cp.w	r8,-1
80006c16:	c0 40       	breq	80006c1e <_malloc_r+0x302>
80006c18:	28 11       	sub	r1,-127
80006c1a:	e0 11 ff 80 	andl	r1,0xff80
80006c1e:	02 9b       	mov	r11,r1
80006c20:	0a 9c       	mov	r12,r5
80006c22:	e0 a0 02 a5 	rcall	8000716c <_sbrk_r>
80006c26:	18 96       	mov	r6,r12
80006c28:	5b fc       	cp.w	r12,-1
80006c2a:	c7 50       	breq	80006d14 <_malloc_r+0x3f8>
80006c2c:	e6 02 00 08 	add	r8,r3,r2
80006c30:	10 3c       	cp.w	r12,r8
80006c32:	c0 32       	brcc	80006c38 <_malloc_r+0x31c>
80006c34:	08 33       	cp.w	r3,r4
80006c36:	c6 f1       	brne	80006d14 <_malloc_r+0x3f8>
80006c38:	e0 6a 07 a8 	mov	r10,1960
80006c3c:	74 09       	ld.w	r9,r10[0x0]
80006c3e:	e2 09 00 09 	add	r9,r1,r9
80006c42:	95 09       	st.w	r10[0x0],r9
80006c44:	10 36       	cp.w	r6,r8
80006c46:	c0 a1       	brne	80006c5a <_malloc_r+0x33e>
80006c48:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006c4c:	c0 71       	brne	80006c5a <_malloc_r+0x33e>
80006c4e:	e2 02 00 02 	add	r2,r1,r2
80006c52:	68 28       	ld.w	r8,r4[0x8]
80006c54:	a1 a2       	sbr	r2,0x0
80006c56:	91 12       	st.w	r8[0x4],r2
80006c58:	c4 f8       	rjmp	80006cf6 <_malloc_r+0x3da>
80006c5a:	e0 6a 05 28 	mov	r10,1320
80006c5e:	74 0b       	ld.w	r11,r10[0x0]
80006c60:	5b fb       	cp.w	r11,-1
80006c62:	c0 31       	brne	80006c68 <_malloc_r+0x34c>
80006c64:	95 06       	st.w	r10[0x0],r6
80006c66:	c0 78       	rjmp	80006c74 <_malloc_r+0x358>
80006c68:	ec 09 00 09 	add	r9,r6,r9
80006c6c:	e0 6a 07 a8 	mov	r10,1960
80006c70:	10 19       	sub	r9,r8
80006c72:	95 09       	st.w	r10[0x0],r9
80006c74:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006c78:	f0 09 11 08 	rsub	r9,r8,8
80006c7c:	58 08       	cp.w	r8,0
80006c7e:	f2 08 17 10 	movne	r8,r9
80006c82:	ed d8 e1 06 	addne	r6,r6,r8
80006c86:	28 08       	sub	r8,-128
80006c88:	ec 01 00 01 	add	r1,r6,r1
80006c8c:	0a 9c       	mov	r12,r5
80006c8e:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006c92:	f0 01 01 01 	sub	r1,r8,r1
80006c96:	02 9b       	mov	r11,r1
80006c98:	e0 a0 02 6a 	rcall	8000716c <_sbrk_r>
80006c9c:	e0 68 07 a8 	mov	r8,1960
80006ca0:	5b fc       	cp.w	r12,-1
80006ca2:	ec 0c 17 00 	moveq	r12,r6
80006ca6:	f9 b1 00 00 	moveq	r1,0
80006caa:	70 09       	ld.w	r9,r8[0x0]
80006cac:	0c 1c       	sub	r12,r6
80006cae:	89 26       	st.w	r4[0x8],r6
80006cb0:	02 0c       	add	r12,r1
80006cb2:	12 01       	add	r1,r9
80006cb4:	a1 ac       	sbr	r12,0x0
80006cb6:	91 01       	st.w	r8[0x0],r1
80006cb8:	8d 1c       	st.w	r6[0x4],r12
80006cba:	08 33       	cp.w	r3,r4
80006cbc:	c1 d0       	breq	80006cf6 <_malloc_r+0x3da>
80006cbe:	58 f2       	cp.w	r2,15
80006cc0:	e0 8b 00 05 	brhi	80006cca <_malloc_r+0x3ae>
80006cc4:	30 18       	mov	r8,1
80006cc6:	8d 18       	st.w	r6[0x4],r8
80006cc8:	c2 68       	rjmp	80006d14 <_malloc_r+0x3f8>
80006cca:	30 59       	mov	r9,5
80006ccc:	20 c2       	sub	r2,12
80006cce:	e0 12 ff f8 	andl	r2,0xfff8
80006cd2:	e6 02 00 08 	add	r8,r3,r2
80006cd6:	91 29       	st.w	r8[0x8],r9
80006cd8:	91 19       	st.w	r8[0x4],r9
80006cda:	66 18       	ld.w	r8,r3[0x4]
80006cdc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006ce0:	e5 e8 10 08 	or	r8,r2,r8
80006ce4:	87 18       	st.w	r3[0x4],r8
80006ce6:	58 f2       	cp.w	r2,15
80006ce8:	e0 88 00 07 	brls	80006cf6 <_malloc_r+0x3da>
80006cec:	e6 cb ff f8 	sub	r11,r3,-8
80006cf0:	0a 9c       	mov	r12,r5
80006cf2:	e0 a0 1d 4f 	rcall	8000a790 <_free_r>
80006cf6:	e0 69 07 a0 	mov	r9,1952
80006cfa:	72 0a       	ld.w	r10,r9[0x0]
80006cfc:	e0 68 07 a8 	mov	r8,1960
80006d00:	70 08       	ld.w	r8,r8[0x0]
80006d02:	14 38       	cp.w	r8,r10
80006d04:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006d08:	e0 69 07 9c 	mov	r9,1948
80006d0c:	72 0a       	ld.w	r10,r9[0x0]
80006d0e:	14 38       	cp.w	r8,r10
80006d10:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006d14:	68 28       	ld.w	r8,r4[0x8]
80006d16:	70 18       	ld.w	r8,r8[0x4]
80006d18:	e0 18 ff fc 	andl	r8,0xfffc
80006d1c:	0e 38       	cp.w	r8,r7
80006d1e:	5f 39       	srlo	r9
80006d20:	0e 18       	sub	r8,r7
80006d22:	58 f8       	cp.w	r8,15
80006d24:	5f aa       	srle	r10
80006d26:	f5 e9 10 09 	or	r9,r10,r9
80006d2a:	c0 50       	breq	80006d34 <_malloc_r+0x418>
80006d2c:	0a 9c       	mov	r12,r5
80006d2e:	fe b0 f0 9d 	rcall	80004e68 <__malloc_unlock>
80006d32:	d8 3a       	popm	r0-r7,pc,r12=0
80006d34:	68 26       	ld.w	r6,r4[0x8]
80006d36:	a1 a8       	sbr	r8,0x0
80006d38:	0e 99       	mov	r9,r7
80006d3a:	a1 a9       	sbr	r9,0x0
80006d3c:	8d 19       	st.w	r6[0x4],r9
80006d3e:	ec 07 00 07 	add	r7,r6,r7
80006d42:	0a 9c       	mov	r12,r5
80006d44:	89 27       	st.w	r4[0x8],r7
80006d46:	8f 18       	st.w	r7[0x4],r8
80006d48:	fe b0 f0 90 	rcall	80004e68 <__malloc_unlock>
80006d4c:	ec cc ff f8 	sub	r12,r6,-8
80006d50:	d8 32       	popm	r0-r7,pc
80006d52:	d7 03       	nop

80006d54 <memcpy>:
80006d54:	58 8a       	cp.w	r10,8
80006d56:	c2 f5       	brlt	80006db4 <memcpy+0x60>
80006d58:	f9 eb 10 09 	or	r9,r12,r11
80006d5c:	e2 19 00 03 	andl	r9,0x3,COH
80006d60:	e0 81 00 97 	brne	80006e8e <memcpy+0x13a>
80006d64:	e0 4a 00 20 	cp.w	r10,32
80006d68:	c3 b4       	brge	80006dde <memcpy+0x8a>
80006d6a:	f4 08 14 02 	asr	r8,r10,0x2
80006d6e:	f0 09 11 08 	rsub	r9,r8,8
80006d72:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80006d76:	76 69       	ld.w	r9,r11[0x18]
80006d78:	99 69       	st.w	r12[0x18],r9
80006d7a:	76 59       	ld.w	r9,r11[0x14]
80006d7c:	99 59       	st.w	r12[0x14],r9
80006d7e:	76 49       	ld.w	r9,r11[0x10]
80006d80:	99 49       	st.w	r12[0x10],r9
80006d82:	76 39       	ld.w	r9,r11[0xc]
80006d84:	99 39       	st.w	r12[0xc],r9
80006d86:	76 29       	ld.w	r9,r11[0x8]
80006d88:	99 29       	st.w	r12[0x8],r9
80006d8a:	76 19       	ld.w	r9,r11[0x4]
80006d8c:	99 19       	st.w	r12[0x4],r9
80006d8e:	76 09       	ld.w	r9,r11[0x0]
80006d90:	99 09       	st.w	r12[0x0],r9
80006d92:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006d96:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006d9a:	e0 1a 00 03 	andl	r10,0x3
80006d9e:	f4 0a 11 04 	rsub	r10,r10,4
80006da2:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006da6:	17 a9       	ld.ub	r9,r11[0x2]
80006da8:	b0 a9       	st.b	r8[0x2],r9
80006daa:	17 99       	ld.ub	r9,r11[0x1]
80006dac:	b0 99       	st.b	r8[0x1],r9
80006dae:	17 89       	ld.ub	r9,r11[0x0]
80006db0:	b0 89       	st.b	r8[0x0],r9
80006db2:	5e fc       	retal	r12
80006db4:	f4 0a 11 09 	rsub	r10,r10,9
80006db8:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006dbc:	17 f9       	ld.ub	r9,r11[0x7]
80006dbe:	b8 f9       	st.b	r12[0x7],r9
80006dc0:	17 e9       	ld.ub	r9,r11[0x6]
80006dc2:	b8 e9       	st.b	r12[0x6],r9
80006dc4:	17 d9       	ld.ub	r9,r11[0x5]
80006dc6:	b8 d9       	st.b	r12[0x5],r9
80006dc8:	17 c9       	ld.ub	r9,r11[0x4]
80006dca:	b8 c9       	st.b	r12[0x4],r9
80006dcc:	17 b9       	ld.ub	r9,r11[0x3]
80006dce:	b8 b9       	st.b	r12[0x3],r9
80006dd0:	17 a9       	ld.ub	r9,r11[0x2]
80006dd2:	b8 a9       	st.b	r12[0x2],r9
80006dd4:	17 99       	ld.ub	r9,r11[0x1]
80006dd6:	b8 99       	st.b	r12[0x1],r9
80006dd8:	17 89       	ld.ub	r9,r11[0x0]
80006dda:	b8 89       	st.b	r12[0x0],r9
80006ddc:	5e fc       	retal	r12
80006dde:	eb cd 40 c0 	pushm	r6-r7,lr
80006de2:	18 99       	mov	r9,r12
80006de4:	22 0a       	sub	r10,32
80006de6:	b7 07       	ld.d	r6,r11++
80006de8:	b3 26       	st.d	r9++,r6
80006dea:	b7 07       	ld.d	r6,r11++
80006dec:	b3 26       	st.d	r9++,r6
80006dee:	b7 07       	ld.d	r6,r11++
80006df0:	b3 26       	st.d	r9++,r6
80006df2:	b7 07       	ld.d	r6,r11++
80006df4:	b3 26       	st.d	r9++,r6
80006df6:	22 0a       	sub	r10,32
80006df8:	cf 74       	brge	80006de6 <memcpy+0x92>
80006dfa:	2f 0a       	sub	r10,-16
80006dfc:	c0 65       	brlt	80006e08 <memcpy+0xb4>
80006dfe:	b7 07       	ld.d	r6,r11++
80006e00:	b3 26       	st.d	r9++,r6
80006e02:	b7 07       	ld.d	r6,r11++
80006e04:	b3 26       	st.d	r9++,r6
80006e06:	21 0a       	sub	r10,16
80006e08:	5c 3a       	neg	r10
80006e0a:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006e0e:	d7 03       	nop
80006e10:	d7 03       	nop
80006e12:	f7 36 00 0e 	ld.ub	r6,r11[14]
80006e16:	f3 66 00 0e 	st.b	r9[14],r6
80006e1a:	f7 36 00 0d 	ld.ub	r6,r11[13]
80006e1e:	f3 66 00 0d 	st.b	r9[13],r6
80006e22:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006e26:	f3 66 00 0c 	st.b	r9[12],r6
80006e2a:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006e2e:	f3 66 00 0b 	st.b	r9[11],r6
80006e32:	f7 36 00 0a 	ld.ub	r6,r11[10]
80006e36:	f3 66 00 0a 	st.b	r9[10],r6
80006e3a:	f7 36 00 09 	ld.ub	r6,r11[9]
80006e3e:	f3 66 00 09 	st.b	r9[9],r6
80006e42:	f7 36 00 08 	ld.ub	r6,r11[8]
80006e46:	f3 66 00 08 	st.b	r9[8],r6
80006e4a:	f7 36 00 07 	ld.ub	r6,r11[7]
80006e4e:	f3 66 00 07 	st.b	r9[7],r6
80006e52:	f7 36 00 06 	ld.ub	r6,r11[6]
80006e56:	f3 66 00 06 	st.b	r9[6],r6
80006e5a:	f7 36 00 05 	ld.ub	r6,r11[5]
80006e5e:	f3 66 00 05 	st.b	r9[5],r6
80006e62:	f7 36 00 04 	ld.ub	r6,r11[4]
80006e66:	f3 66 00 04 	st.b	r9[4],r6
80006e6a:	f7 36 00 03 	ld.ub	r6,r11[3]
80006e6e:	f3 66 00 03 	st.b	r9[3],r6
80006e72:	f7 36 00 02 	ld.ub	r6,r11[2]
80006e76:	f3 66 00 02 	st.b	r9[2],r6
80006e7a:	f7 36 00 01 	ld.ub	r6,r11[1]
80006e7e:	f3 66 00 01 	st.b	r9[1],r6
80006e82:	f7 36 00 00 	ld.ub	r6,r11[0]
80006e86:	f3 66 00 00 	st.b	r9[0],r6
80006e8a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006e8e:	20 1a       	sub	r10,1
80006e90:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006e94:	f8 0a 0b 09 	st.b	r12[r10],r9
80006e98:	cf b1       	brne	80006e8e <memcpy+0x13a>
80006e9a:	5e fc       	retal	r12

80006e9c <memset>:
80006e9c:	18 98       	mov	r8,r12
80006e9e:	c0 38       	rjmp	80006ea4 <memset+0x8>
80006ea0:	10 cb       	st.b	r8++,r11
80006ea2:	20 1a       	sub	r10,1
80006ea4:	58 0a       	cp.w	r10,0
80006ea6:	cf d1       	brne	80006ea0 <memset+0x4>
80006ea8:	5e fc       	retal	r12
80006eaa:	d7 03       	nop

80006eac <_realloc_r>:
80006eac:	d4 31       	pushm	r0-r7,lr
80006eae:	20 1d       	sub	sp,4
80006eb0:	16 94       	mov	r4,r11
80006eb2:	18 92       	mov	r2,r12
80006eb4:	14 9b       	mov	r11,r10
80006eb6:	58 04       	cp.w	r4,0
80006eb8:	c0 51       	brne	80006ec2 <_realloc_r+0x16>
80006eba:	fe b0 fd 31 	rcall	8000691c <_malloc_r>
80006ebe:	18 95       	mov	r5,r12
80006ec0:	c5 39       	rjmp	80007166 <_realloc_r+0x2ba>
80006ec2:	50 0a       	stdsp	sp[0x0],r10
80006ec4:	fe b0 ef c4 	rcall	80004e4c <__malloc_lock>
80006ec8:	40 0b       	lddsp	r11,sp[0x0]
80006eca:	f6 c8 ff f5 	sub	r8,r11,-11
80006ece:	e8 c1 00 08 	sub	r1,r4,8
80006ed2:	10 96       	mov	r6,r8
80006ed4:	62 1c       	ld.w	r12,r1[0x4]
80006ed6:	e0 16 ff f8 	andl	r6,0xfff8
80006eda:	59 68       	cp.w	r8,22
80006edc:	f9 b6 08 10 	movls	r6,16
80006ee0:	16 36       	cp.w	r6,r11
80006ee2:	5f 38       	srlo	r8
80006ee4:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006ee8:	c0 50       	breq	80006ef2 <_realloc_r+0x46>
80006eea:	30 c8       	mov	r8,12
80006eec:	30 05       	mov	r5,0
80006eee:	85 38       	st.w	r2[0xc],r8
80006ef0:	c3 b9       	rjmp	80007166 <_realloc_r+0x2ba>
80006ef2:	18 90       	mov	r0,r12
80006ef4:	e0 10 ff fc 	andl	r0,0xfffc
80006ef8:	0c 30       	cp.w	r0,r6
80006efa:	e0 84 01 0b 	brge	80007110 <_realloc_r+0x264>
80006efe:	e0 68 01 1c 	mov	r8,284
80006f02:	e2 00 00 09 	add	r9,r1,r0
80006f06:	70 25       	ld.w	r5,r8[0x8]
80006f08:	0a 39       	cp.w	r9,r5
80006f0a:	c0 90       	breq	80006f1c <_realloc_r+0x70>
80006f0c:	72 1a       	ld.w	r10,r9[0x4]
80006f0e:	a1 ca       	cbr	r10,0x0
80006f10:	f2 0a 00 0a 	add	r10,r9,r10
80006f14:	74 1a       	ld.w	r10,r10[0x4]
80006f16:	ed ba 00 00 	bld	r10,0x0
80006f1a:	c2 20       	breq	80006f5e <_realloc_r+0xb2>
80006f1c:	72 1a       	ld.w	r10,r9[0x4]
80006f1e:	e0 1a ff fc 	andl	r10,0xfffc
80006f22:	f4 00 00 03 	add	r3,r10,r0
80006f26:	0a 39       	cp.w	r9,r5
80006f28:	c1 31       	brne	80006f4e <_realloc_r+0xa2>
80006f2a:	ec c7 ff f0 	sub	r7,r6,-16
80006f2e:	0e 33       	cp.w	r3,r7
80006f30:	c1 95       	brlt	80006f62 <_realloc_r+0xb6>
80006f32:	e2 06 00 09 	add	r9,r1,r6
80006f36:	0c 13       	sub	r3,r6
80006f38:	a1 a3       	sbr	r3,0x0
80006f3a:	93 13       	st.w	r9[0x4],r3
80006f3c:	91 29       	st.w	r8[0x8],r9
80006f3e:	04 9c       	mov	r12,r2
80006f40:	62 18       	ld.w	r8,r1[0x4]
80006f42:	08 95       	mov	r5,r4
80006f44:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006f48:	10 46       	or	r6,r8
80006f4a:	83 16       	st.w	r1[0x4],r6
80006f4c:	c0 b9       	rjmp	80007162 <_realloc_r+0x2b6>
80006f4e:	0c 33       	cp.w	r3,r6
80006f50:	c0 95       	brlt	80006f62 <_realloc_r+0xb6>
80006f52:	72 28       	ld.w	r8,r9[0x8]
80006f54:	02 97       	mov	r7,r1
80006f56:	72 39       	ld.w	r9,r9[0xc]
80006f58:	93 28       	st.w	r9[0x8],r8
80006f5a:	91 39       	st.w	r8[0xc],r9
80006f5c:	cd c8       	rjmp	80007114 <_realloc_r+0x268>
80006f5e:	30 0a       	mov	r10,0
80006f60:	14 99       	mov	r9,r10
80006f62:	ed bc 00 00 	bld	r12,0x0
80006f66:	e0 80 00 95 	breq	80007090 <_realloc_r+0x1e4>
80006f6a:	62 07       	ld.w	r7,r1[0x0]
80006f6c:	e2 07 01 07 	sub	r7,r1,r7
80006f70:	6e 1c       	ld.w	r12,r7[0x4]
80006f72:	e0 1c ff fc 	andl	r12,0xfffc
80006f76:	58 09       	cp.w	r9,0
80006f78:	c5 60       	breq	80007024 <_realloc_r+0x178>
80006f7a:	f8 00 00 03 	add	r3,r12,r0
80006f7e:	0a 39       	cp.w	r9,r5
80006f80:	c4 81       	brne	80007010 <_realloc_r+0x164>
80006f82:	14 03       	add	r3,r10
80006f84:	ec c9 ff f0 	sub	r9,r6,-16
80006f88:	12 33       	cp.w	r3,r9
80006f8a:	c4 d5       	brlt	80007024 <_realloc_r+0x178>
80006f8c:	6e 3a       	ld.w	r10,r7[0xc]
80006f8e:	6e 29       	ld.w	r9,r7[0x8]
80006f90:	95 29       	st.w	r10[0x8],r9
80006f92:	93 3a       	st.w	r9[0xc],r10
80006f94:	ee c5 ff f8 	sub	r5,r7,-8
80006f98:	e0 ca 00 04 	sub	r10,r0,4
80006f9c:	e0 4a 00 24 	cp.w	r10,36
80006fa0:	e0 8b 00 25 	brhi	80006fea <_realloc_r+0x13e>
80006fa4:	0a 99       	mov	r9,r5
80006fa6:	59 3a       	cp.w	r10,19
80006fa8:	e0 88 00 1a 	brls	80006fdc <_realloc_r+0x130>
80006fac:	09 09       	ld.w	r9,r4++
80006fae:	8b 09       	st.w	r5[0x0],r9
80006fb0:	09 09       	ld.w	r9,r4++
80006fb2:	8f 39       	st.w	r7[0xc],r9
80006fb4:	ee c9 ff f0 	sub	r9,r7,-16
80006fb8:	59 ba       	cp.w	r10,27
80006fba:	e0 88 00 11 	brls	80006fdc <_realloc_r+0x130>
80006fbe:	09 0b       	ld.w	r11,r4++
80006fc0:	93 0b       	st.w	r9[0x0],r11
80006fc2:	09 09       	ld.w	r9,r4++
80006fc4:	8f 59       	st.w	r7[0x14],r9
80006fc6:	ee c9 ff e8 	sub	r9,r7,-24
80006fca:	e0 4a 00 24 	cp.w	r10,36
80006fce:	c0 71       	brne	80006fdc <_realloc_r+0x130>
80006fd0:	09 0a       	ld.w	r10,r4++
80006fd2:	93 0a       	st.w	r9[0x0],r10
80006fd4:	ee c9 ff e0 	sub	r9,r7,-32
80006fd8:	09 0a       	ld.w	r10,r4++
80006fda:	8f 7a       	st.w	r7[0x1c],r10
80006fdc:	09 0a       	ld.w	r10,r4++
80006fde:	12 aa       	st.w	r9++,r10
80006fe0:	68 0a       	ld.w	r10,r4[0x0]
80006fe2:	93 0a       	st.w	r9[0x0],r10
80006fe4:	68 1a       	ld.w	r10,r4[0x4]
80006fe6:	93 1a       	st.w	r9[0x4],r10
80006fe8:	c0 78       	rjmp	80006ff6 <_realloc_r+0x14a>
80006fea:	50 08       	stdsp	sp[0x0],r8
80006fec:	08 9b       	mov	r11,r4
80006fee:	0a 9c       	mov	r12,r5
80006ff0:	e0 a0 1e 73 	rcall	8000acd6 <memmove>
80006ff4:	40 08       	lddsp	r8,sp[0x0]
80006ff6:	ee 06 00 09 	add	r9,r7,r6
80006ffa:	0c 13       	sub	r3,r6
80006ffc:	a1 a3       	sbr	r3,0x0
80006ffe:	93 13       	st.w	r9[0x4],r3
80007000:	91 29       	st.w	r8[0x8],r9
80007002:	04 9c       	mov	r12,r2
80007004:	6e 18       	ld.w	r8,r7[0x4]
80007006:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000700a:	10 46       	or	r6,r8
8000700c:	8f 16       	st.w	r7[0x4],r6
8000700e:	ca a8       	rjmp	80007162 <_realloc_r+0x2b6>
80007010:	14 03       	add	r3,r10
80007012:	0c 33       	cp.w	r3,r6
80007014:	c0 85       	brlt	80007024 <_realloc_r+0x178>
80007016:	72 28       	ld.w	r8,r9[0x8]
80007018:	72 39       	ld.w	r9,r9[0xc]
8000701a:	93 28       	st.w	r9[0x8],r8
8000701c:	91 39       	st.w	r8[0xc],r9
8000701e:	6e 28       	ld.w	r8,r7[0x8]
80007020:	6e 39       	ld.w	r9,r7[0xc]
80007022:	c0 78       	rjmp	80007030 <_realloc_r+0x184>
80007024:	f8 00 00 03 	add	r3,r12,r0
80007028:	0c 33       	cp.w	r3,r6
8000702a:	c3 35       	brlt	80007090 <_realloc_r+0x1e4>
8000702c:	6e 39       	ld.w	r9,r7[0xc]
8000702e:	6e 28       	ld.w	r8,r7[0x8]
80007030:	93 28       	st.w	r9[0x8],r8
80007032:	91 39       	st.w	r8[0xc],r9
80007034:	e0 ca 00 04 	sub	r10,r0,4
80007038:	ee cc ff f8 	sub	r12,r7,-8
8000703c:	e0 4a 00 24 	cp.w	r10,36
80007040:	e0 8b 00 24 	brhi	80007088 <_realloc_r+0x1dc>
80007044:	59 3a       	cp.w	r10,19
80007046:	e0 88 00 1a 	brls	8000707a <_realloc_r+0x1ce>
8000704a:	09 08       	ld.w	r8,r4++
8000704c:	99 08       	st.w	r12[0x0],r8
8000704e:	09 08       	ld.w	r8,r4++
80007050:	8f 38       	st.w	r7[0xc],r8
80007052:	ee cc ff f0 	sub	r12,r7,-16
80007056:	59 ba       	cp.w	r10,27
80007058:	e0 88 00 11 	brls	8000707a <_realloc_r+0x1ce>
8000705c:	09 08       	ld.w	r8,r4++
8000705e:	99 08       	st.w	r12[0x0],r8
80007060:	09 08       	ld.w	r8,r4++
80007062:	8f 58       	st.w	r7[0x14],r8
80007064:	ee cc ff e8 	sub	r12,r7,-24
80007068:	e0 4a 00 24 	cp.w	r10,36
8000706c:	c0 71       	brne	8000707a <_realloc_r+0x1ce>
8000706e:	09 08       	ld.w	r8,r4++
80007070:	99 08       	st.w	r12[0x0],r8
80007072:	ee cc ff e0 	sub	r12,r7,-32
80007076:	09 08       	ld.w	r8,r4++
80007078:	8f 78       	st.w	r7[0x1c],r8
8000707a:	09 08       	ld.w	r8,r4++
8000707c:	18 a8       	st.w	r12++,r8
8000707e:	68 08       	ld.w	r8,r4[0x0]
80007080:	99 08       	st.w	r12[0x0],r8
80007082:	68 18       	ld.w	r8,r4[0x4]
80007084:	99 18       	st.w	r12[0x4],r8
80007086:	c4 78       	rjmp	80007114 <_realloc_r+0x268>
80007088:	08 9b       	mov	r11,r4
8000708a:	e0 a0 1e 26 	rcall	8000acd6 <memmove>
8000708e:	c4 38       	rjmp	80007114 <_realloc_r+0x268>
80007090:	04 9c       	mov	r12,r2
80007092:	fe b0 fc 45 	rcall	8000691c <_malloc_r>
80007096:	18 95       	mov	r5,r12
80007098:	c3 a0       	breq	8000710c <_realloc_r+0x260>
8000709a:	62 18       	ld.w	r8,r1[0x4]
8000709c:	f8 c9 00 08 	sub	r9,r12,8
800070a0:	a1 c8       	cbr	r8,0x0
800070a2:	e2 08 00 08 	add	r8,r1,r8
800070a6:	10 39       	cp.w	r9,r8
800070a8:	c0 71       	brne	800070b6 <_realloc_r+0x20a>
800070aa:	72 13       	ld.w	r3,r9[0x4]
800070ac:	02 97       	mov	r7,r1
800070ae:	e0 13 ff fc 	andl	r3,0xfffc
800070b2:	00 03       	add	r3,r0
800070b4:	c3 08       	rjmp	80007114 <_realloc_r+0x268>
800070b6:	e0 ca 00 04 	sub	r10,r0,4
800070ba:	e0 4a 00 24 	cp.w	r10,36
800070be:	e0 8b 00 20 	brhi	800070fe <_realloc_r+0x252>
800070c2:	08 99       	mov	r9,r4
800070c4:	18 98       	mov	r8,r12
800070c6:	59 3a       	cp.w	r10,19
800070c8:	e0 88 00 14 	brls	800070f0 <_realloc_r+0x244>
800070cc:	13 0b       	ld.w	r11,r9++
800070ce:	10 ab       	st.w	r8++,r11
800070d0:	13 0b       	ld.w	r11,r9++
800070d2:	10 ab       	st.w	r8++,r11
800070d4:	59 ba       	cp.w	r10,27
800070d6:	e0 88 00 0d 	brls	800070f0 <_realloc_r+0x244>
800070da:	13 0b       	ld.w	r11,r9++
800070dc:	10 ab       	st.w	r8++,r11
800070de:	13 0b       	ld.w	r11,r9++
800070e0:	10 ab       	st.w	r8++,r11
800070e2:	e0 4a 00 24 	cp.w	r10,36
800070e6:	c0 51       	brne	800070f0 <_realloc_r+0x244>
800070e8:	13 0a       	ld.w	r10,r9++
800070ea:	10 aa       	st.w	r8++,r10
800070ec:	13 0a       	ld.w	r10,r9++
800070ee:	10 aa       	st.w	r8++,r10
800070f0:	13 0a       	ld.w	r10,r9++
800070f2:	10 aa       	st.w	r8++,r10
800070f4:	72 0a       	ld.w	r10,r9[0x0]
800070f6:	91 0a       	st.w	r8[0x0],r10
800070f8:	72 19       	ld.w	r9,r9[0x4]
800070fa:	91 19       	st.w	r8[0x4],r9
800070fc:	c0 48       	rjmp	80007104 <_realloc_r+0x258>
800070fe:	08 9b       	mov	r11,r4
80007100:	e0 a0 1d eb 	rcall	8000acd6 <memmove>
80007104:	08 9b       	mov	r11,r4
80007106:	04 9c       	mov	r12,r2
80007108:	e0 a0 1b 44 	rcall	8000a790 <_free_r>
8000710c:	04 9c       	mov	r12,r2
8000710e:	c2 a8       	rjmp	80007162 <_realloc_r+0x2b6>
80007110:	00 93       	mov	r3,r0
80007112:	02 97       	mov	r7,r1
80007114:	e6 06 01 09 	sub	r9,r3,r6
80007118:	6e 18       	ld.w	r8,r7[0x4]
8000711a:	58 f9       	cp.w	r9,15
8000711c:	e0 88 00 16 	brls	80007148 <_realloc_r+0x29c>
80007120:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007124:	ed e8 10 08 	or	r8,r6,r8
80007128:	8f 18       	st.w	r7[0x4],r8
8000712a:	12 98       	mov	r8,r9
8000712c:	a1 a8       	sbr	r8,0x0
8000712e:	ee 06 00 0b 	add	r11,r7,r6
80007132:	f6 09 00 09 	add	r9,r11,r9
80007136:	97 18       	st.w	r11[0x4],r8
80007138:	72 18       	ld.w	r8,r9[0x4]
8000713a:	a1 a8       	sbr	r8,0x0
8000713c:	2f 8b       	sub	r11,-8
8000713e:	93 18       	st.w	r9[0x4],r8
80007140:	04 9c       	mov	r12,r2
80007142:	e0 a0 1b 27 	rcall	8000a790 <_free_r>
80007146:	c0 b8       	rjmp	8000715c <_realloc_r+0x2b0>
80007148:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000714c:	e7 e8 10 08 	or	r8,r3,r8
80007150:	8f 18       	st.w	r7[0x4],r8
80007152:	ee 03 00 03 	add	r3,r7,r3
80007156:	66 18       	ld.w	r8,r3[0x4]
80007158:	a1 a8       	sbr	r8,0x0
8000715a:	87 18       	st.w	r3[0x4],r8
8000715c:	04 9c       	mov	r12,r2
8000715e:	ee c5 ff f8 	sub	r5,r7,-8
80007162:	fe b0 ee 83 	rcall	80004e68 <__malloc_unlock>
80007166:	0a 9c       	mov	r12,r5
80007168:	2f fd       	sub	sp,-4
8000716a:	d8 32       	popm	r0-r7,pc

8000716c <_sbrk_r>:
8000716c:	d4 21       	pushm	r4-r7,lr
8000716e:	30 08       	mov	r8,0
80007170:	18 97       	mov	r7,r12
80007172:	e0 66 08 10 	mov	r6,2064
80007176:	16 9c       	mov	r12,r11
80007178:	8d 08       	st.w	r6[0x0],r8
8000717a:	c8 fc       	rcall	80007298 <_sbrk>
8000717c:	5b fc       	cp.w	r12,-1
8000717e:	c0 51       	brne	80007188 <_sbrk_r+0x1c>
80007180:	6c 08       	ld.w	r8,r6[0x0]
80007182:	58 08       	cp.w	r8,0
80007184:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007188:	d8 22       	popm	r4-r7,pc
8000718a:	d7 03       	nop

8000718c <sprintf>:
8000718c:	d4 01       	pushm	lr
8000718e:	21 7d       	sub	sp,92
80007190:	e0 68 ff ff 	mov	r8,65535
80007194:	ea 18 7f ff 	orh	r8,0x7fff
80007198:	50 58       	stdsp	sp[0x14],r8
8000719a:	50 28       	stdsp	sp[0x8],r8
8000719c:	e0 68 02 08 	mov	r8,520
800071a0:	ba 68       	st.h	sp[0xc],r8
800071a2:	3f f8       	mov	r8,-1
800071a4:	ba 78       	st.h	sp[0xe],r8
800071a6:	e0 68 01 18 	mov	r8,280
800071aa:	50 4c       	stdsp	sp[0x10],r12
800071ac:	16 9a       	mov	r10,r11
800071ae:	50 0c       	stdsp	sp[0x0],r12
800071b0:	fa c9 ff a0 	sub	r9,sp,-96
800071b4:	70 0c       	ld.w	r12,r8[0x0]
800071b6:	1a 9b       	mov	r11,sp
800071b8:	e0 a0 02 24 	rcall	80007600 <_vfprintf_r>
800071bc:	30 09       	mov	r9,0
800071be:	40 08       	lddsp	r8,sp[0x0]
800071c0:	b0 89       	st.b	r8[0x0],r9
800071c2:	2e 9d       	sub	sp,-92
800071c4:	d8 02       	popm	pc
800071c6:	d7 03       	nop

800071c8 <strncpy>:
800071c8:	30 08       	mov	r8,0
800071ca:	10 3a       	cp.w	r10,r8
800071cc:	5e 0c       	reteq	r12
800071ce:	f6 08 07 09 	ld.ub	r9,r11[r8]
800071d2:	f8 08 0b 09 	st.b	r12[r8],r9
800071d6:	2f f8       	sub	r8,-1
800071d8:	58 09       	cp.w	r9,0
800071da:	cf 81       	brne	800071ca <strncpy+0x2>
800071dc:	10 3a       	cp.w	r10,r8
800071de:	5e 0c       	reteq	r12
800071e0:	f8 08 0b 09 	st.b	r12[r8],r9
800071e4:	2f f8       	sub	r8,-1
800071e6:	cf bb       	rjmp	800071dc <strncpy+0x14>

800071e8 <_init_argv>:
800071e8:	30 e8       	mov	r8,14
800071ea:	d6 73       	breakpoint
800071ec:	3f fc       	mov	r12,-1
800071ee:	35 8b       	mov	r11,88
800071f0:	5e fc       	retal	r12

800071f2 <_exit>:
800071f2:	30 d8       	mov	r8,13
800071f4:	d6 73       	breakpoint
800071f6:	3f fc       	mov	r12,-1
800071f8:	35 8b       	mov	r11,88
800071fa:	c0 08       	rjmp	800071fa <_exit+0x8>

800071fc <_close>:
800071fc:	30 28       	mov	r8,2
800071fe:	d6 73       	breakpoint
80007200:	3f fc       	mov	r12,-1
80007202:	35 8b       	mov	r11,88
80007204:	58 0c       	cp.w	r12,0
80007206:	5e 4c       	retge	r12
80007208:	e0 6a 08 10 	mov	r10,2064
8000720c:	95 0b       	st.w	r10[0x0],r11
8000720e:	5e fc       	retal	r12

80007210 <_lseek>:
80007210:	30 58       	mov	r8,5
80007212:	d6 73       	breakpoint
80007214:	3f fc       	mov	r12,-1
80007216:	35 8b       	mov	r11,88
80007218:	58 0c       	cp.w	r12,0
8000721a:	5e 4c       	retge	r12
8000721c:	e0 6a 08 10 	mov	r10,2064
80007220:	95 0b       	st.w	r10[0x0],r11
80007222:	5e fc       	retal	r12

80007224 <isatty>:
80007224:	30 b8       	mov	r8,11
80007226:	d6 73       	breakpoint
80007228:	3f fc       	mov	r12,-1
8000722a:	35 8b       	mov	r11,88
8000722c:	58 0c       	cp.w	r12,0
8000722e:	5e 4c       	retge	r12
80007230:	e0 6a 08 10 	mov	r10,2064
80007234:	95 0b       	st.w	r10[0x0],r11
80007236:	5e fc       	retal	r12

80007238 <_fstat_host>:
80007238:	30 98       	mov	r8,9
8000723a:	d6 73       	breakpoint
8000723c:	3f fc       	mov	r12,-1
8000723e:	35 8b       	mov	r11,88
80007240:	58 0c       	cp.w	r12,0
80007242:	5e 4c       	retge	r12
80007244:	e0 6a 08 10 	mov	r10,2064
80007248:	95 0b       	st.w	r10[0x0],r11
8000724a:	5e fc       	retal	r12

8000724c <_fstat>:
8000724c:	d4 21       	pushm	r4-r7,lr
8000724e:	21 0d       	sub	sp,64
80007250:	16 97       	mov	r7,r11
80007252:	1a 9b       	mov	r11,sp
80007254:	cf 2f       	rcall	80007238 <_fstat_host>
80007256:	c0 34       	brge	8000725c <_fstat+0x10>
80007258:	3f fc       	mov	r12,-1
8000725a:	c1 c8       	rjmp	80007292 <_fstat+0x46>
8000725c:	40 08       	lddsp	r8,sp[0x0]
8000725e:	ae 08       	st.h	r7[0x0],r8
80007260:	40 18       	lddsp	r8,sp[0x4]
80007262:	ae 18       	st.h	r7[0x2],r8
80007264:	40 28       	lddsp	r8,sp[0x8]
80007266:	8f 18       	st.w	r7[0x4],r8
80007268:	40 38       	lddsp	r8,sp[0xc]
8000726a:	ae 48       	st.h	r7[0x8],r8
8000726c:	40 48       	lddsp	r8,sp[0x10]
8000726e:	ae 58       	st.h	r7[0xa],r8
80007270:	40 58       	lddsp	r8,sp[0x14]
80007272:	ae 68       	st.h	r7[0xc],r8
80007274:	40 68       	lddsp	r8,sp[0x18]
80007276:	ae 78       	st.h	r7[0xe],r8
80007278:	40 88       	lddsp	r8,sp[0x20]
8000727a:	8f 48       	st.w	r7[0x10],r8
8000727c:	40 a8       	lddsp	r8,sp[0x28]
8000727e:	8f b8       	st.w	r7[0x2c],r8
80007280:	40 c8       	lddsp	r8,sp[0x30]
80007282:	8f c8       	st.w	r7[0x30],r8
80007284:	40 d8       	lddsp	r8,sp[0x34]
80007286:	8f 58       	st.w	r7[0x14],r8
80007288:	40 e8       	lddsp	r8,sp[0x38]
8000728a:	30 0c       	mov	r12,0
8000728c:	8f 78       	st.w	r7[0x1c],r8
8000728e:	40 f8       	lddsp	r8,sp[0x3c]
80007290:	8f 98       	st.w	r7[0x24],r8
80007292:	2f 0d       	sub	sp,-64
80007294:	d8 22       	popm	r4-r7,pc
80007296:	d7 03       	nop

80007298 <_sbrk>:
80007298:	d4 01       	pushm	lr
8000729a:	e0 68 07 d0 	mov	r8,2000
8000729e:	70 09       	ld.w	r9,r8[0x0]
800072a0:	58 09       	cp.w	r9,0
800072a2:	c0 41       	brne	800072aa <_sbrk+0x12>
800072a4:	e0 69 08 18 	mov	r9,2072
800072a8:	91 09       	st.w	r8[0x0],r9
800072aa:	e0 69 07 d0 	mov	r9,2000
800072ae:	e0 6a f0 00 	mov	r10,61440
800072b2:	72 08       	ld.w	r8,r9[0x0]
800072b4:	f0 0c 00 0c 	add	r12,r8,r12
800072b8:	14 3c       	cp.w	r12,r10
800072ba:	e0 8b 00 04 	brhi	800072c2 <_sbrk+0x2a>
800072be:	93 0c       	st.w	r9[0x0],r12
800072c0:	c0 68       	rjmp	800072cc <_sbrk+0x34>
800072c2:	e0 a0 18 ef 	rcall	8000a4a0 <__errno>
800072c6:	30 c8       	mov	r8,12
800072c8:	99 08       	st.w	r12[0x0],r8
800072ca:	3f f8       	mov	r8,-1
800072cc:	10 9c       	mov	r12,r8
800072ce:	d8 02       	popm	pc

800072d0 <get_arg>:
800072d0:	d4 31       	pushm	r0-r7,lr
800072d2:	20 8d       	sub	sp,32
800072d4:	fa c4 ff bc 	sub	r4,sp,-68
800072d8:	50 4b       	stdsp	sp[0x10],r11
800072da:	68 2e       	ld.w	lr,r4[0x8]
800072dc:	50 58       	stdsp	sp[0x14],r8
800072de:	12 96       	mov	r6,r9
800072e0:	7c 0b       	ld.w	r11,lr[0x0]
800072e2:	70 05       	ld.w	r5,r8[0x0]
800072e4:	50 6e       	stdsp	sp[0x18],lr
800072e6:	58 0b       	cp.w	r11,0
800072e8:	f4 0b 17 00 	moveq	r11,r10
800072ec:	68 03       	ld.w	r3,r4[0x0]
800072ee:	68 11       	ld.w	r1,r4[0x4]
800072f0:	40 49       	lddsp	r9,sp[0x10]
800072f2:	30 08       	mov	r8,0
800072f4:	c2 89       	rjmp	80007544 <get_arg+0x274>
800072f6:	2f fb       	sub	r11,-1
800072f8:	32 5c       	mov	r12,37
800072fa:	17 8a       	ld.ub	r10,r11[0x0]
800072fc:	f8 0a 18 00 	cp.b	r10,r12
80007300:	5f 1e       	srne	lr
80007302:	f0 0a 18 00 	cp.b	r10,r8
80007306:	5f 1c       	srne	r12
80007308:	fd ec 00 0c 	and	r12,lr,r12
8000730c:	f0 0c 18 00 	cp.b	r12,r8
80007310:	cf 31       	brne	800072f6 <get_arg+0x26>
80007312:	58 0a       	cp.w	r10,0
80007314:	e0 80 01 25 	breq	8000755e <get_arg+0x28e>
80007318:	30 0c       	mov	r12,0
8000731a:	3f fa       	mov	r10,-1
8000731c:	18 90       	mov	r0,r12
8000731e:	50 3a       	stdsp	sp[0xc],r10
80007320:	18 94       	mov	r4,r12
80007322:	18 92       	mov	r2,r12
80007324:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007328:	16 97       	mov	r7,r11
8000732a:	50 7c       	stdsp	sp[0x1c],r12
8000732c:	fe cc ab 20 	sub	r12,pc,-21728
80007330:	0f 3a       	ld.ub	r10,r7++
80007332:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007336:	40 7c       	lddsp	r12,sp[0x1c]
80007338:	1c 0c       	add	r12,lr
8000733a:	fe ce ab f6 	sub	lr,pc,-21514
8000733e:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007342:	20 1e       	sub	lr,1
80007344:	50 0e       	stdsp	sp[0x0],lr
80007346:	fe ce ac 6e 	sub	lr,pc,-21394
8000734a:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000734e:	50 7c       	stdsp	sp[0x1c],r12
80007350:	40 0c       	lddsp	r12,sp[0x0]
80007352:	58 7c       	cp.w	r12,7
80007354:	e0 8b 00 f1 	brhi	80007536 <get_arg+0x266>
80007358:	fe ce ae 20 	sub	lr,pc,-20960
8000735c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007360:	36 8b       	mov	r11,104
80007362:	f6 0a 18 00 	cp.b	r10,r11
80007366:	e0 80 00 e8 	breq	80007536 <get_arg+0x266>
8000736a:	37 1b       	mov	r11,113
8000736c:	f6 0a 18 00 	cp.b	r10,r11
80007370:	c0 70       	breq	8000737e <get_arg+0xae>
80007372:	34 cb       	mov	r11,76
80007374:	f6 0a 18 00 	cp.b	r10,r11
80007378:	c0 51       	brne	80007382 <get_arg+0xb2>
8000737a:	a3 b4       	sbr	r4,0x3
8000737c:	cd d8       	rjmp	80007536 <get_arg+0x266>
8000737e:	a5 b4       	sbr	r4,0x5
80007380:	cd b8       	rjmp	80007536 <get_arg+0x266>
80007382:	08 9a       	mov	r10,r4
80007384:	0e 9b       	mov	r11,r7
80007386:	a5 aa       	sbr	r10,0x4
80007388:	17 3c       	ld.ub	r12,r11++
8000738a:	a5 b4       	sbr	r4,0x5
8000738c:	36 ce       	mov	lr,108
8000738e:	fc 0c 18 00 	cp.b	r12,lr
80007392:	e0 80 00 d3 	breq	80007538 <get_arg+0x268>
80007396:	14 94       	mov	r4,r10
80007398:	cc f8       	rjmp	80007536 <get_arg+0x266>
8000739a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000739e:	36 7c       	mov	r12,103
800073a0:	f8 0a 18 00 	cp.b	r10,r12
800073a4:	e0 8b 00 27 	brhi	800073f2 <get_arg+0x122>
800073a8:	36 5b       	mov	r11,101
800073aa:	f6 0a 18 00 	cp.b	r10,r11
800073ae:	c4 82       	brcc	8000743e <get_arg+0x16e>
800073b0:	34 fb       	mov	r11,79
800073b2:	f6 0a 18 00 	cp.b	r10,r11
800073b6:	c4 80       	breq	80007446 <get_arg+0x176>
800073b8:	e0 8b 00 0c 	brhi	800073d0 <get_arg+0x100>
800073bc:	34 5b       	mov	r11,69
800073be:	f6 0a 18 00 	cp.b	r10,r11
800073c2:	c3 e0       	breq	8000743e <get_arg+0x16e>
800073c4:	34 7b       	mov	r11,71
800073c6:	f6 0a 18 00 	cp.b	r10,r11
800073ca:	c3 a0       	breq	8000743e <get_arg+0x16e>
800073cc:	34 4b       	mov	r11,68
800073ce:	c0 88       	rjmp	800073de <get_arg+0x10e>
800073d0:	35 8b       	mov	r11,88
800073d2:	f6 0a 18 00 	cp.b	r10,r11
800073d6:	c2 c0       	breq	8000742e <get_arg+0x15e>
800073d8:	e0 8b 00 07 	brhi	800073e6 <get_arg+0x116>
800073dc:	35 5b       	mov	r11,85
800073de:	f6 0a 18 00 	cp.b	r10,r11
800073e2:	c3 51       	brne	8000744c <get_arg+0x17c>
800073e4:	c3 18       	rjmp	80007446 <get_arg+0x176>
800073e6:	36 3b       	mov	r11,99
800073e8:	f6 0a 18 00 	cp.b	r10,r11
800073ec:	c2 f0       	breq	8000744a <get_arg+0x17a>
800073ee:	36 4b       	mov	r11,100
800073f0:	c0 e8       	rjmp	8000740c <get_arg+0x13c>
800073f2:	37 0b       	mov	r11,112
800073f4:	f6 0a 18 00 	cp.b	r10,r11
800073f8:	c2 50       	breq	80007442 <get_arg+0x172>
800073fa:	e0 8b 00 0d 	brhi	80007414 <get_arg+0x144>
800073fe:	36 eb       	mov	r11,110
80007400:	f6 0a 18 00 	cp.b	r10,r11
80007404:	c1 f0       	breq	80007442 <get_arg+0x172>
80007406:	e0 8b 00 14 	brhi	8000742e <get_arg+0x15e>
8000740a:	36 9b       	mov	r11,105
8000740c:	f6 0a 18 00 	cp.b	r10,r11
80007410:	c1 e1       	brne	8000744c <get_arg+0x17c>
80007412:	c0 e8       	rjmp	8000742e <get_arg+0x15e>
80007414:	37 5b       	mov	r11,117
80007416:	f6 0a 18 00 	cp.b	r10,r11
8000741a:	c0 a0       	breq	8000742e <get_arg+0x15e>
8000741c:	37 8b       	mov	r11,120
8000741e:	f6 0a 18 00 	cp.b	r10,r11
80007422:	c0 60       	breq	8000742e <get_arg+0x15e>
80007424:	37 3b       	mov	r11,115
80007426:	f6 0a 18 00 	cp.b	r10,r11
8000742a:	c1 11       	brne	8000744c <get_arg+0x17c>
8000742c:	c0 b8       	rjmp	80007442 <get_arg+0x172>
8000742e:	ed b4 00 04 	bld	r4,0x4
80007432:	c0 a0       	breq	80007446 <get_arg+0x176>
80007434:	ed b4 00 05 	bld	r4,0x5
80007438:	c0 91       	brne	8000744a <get_arg+0x17a>
8000743a:	30 20       	mov	r0,2
8000743c:	c0 88       	rjmp	8000744c <get_arg+0x17c>
8000743e:	30 40       	mov	r0,4
80007440:	c0 68       	rjmp	8000744c <get_arg+0x17c>
80007442:	30 30       	mov	r0,3
80007444:	c0 48       	rjmp	8000744c <get_arg+0x17c>
80007446:	30 10       	mov	r0,1
80007448:	c0 28       	rjmp	8000744c <get_arg+0x17c>
8000744a:	30 00       	mov	r0,0
8000744c:	40 3b       	lddsp	r11,sp[0xc]
8000744e:	5b fb       	cp.w	r11,-1
80007450:	c0 40       	breq	80007458 <get_arg+0x188>
80007452:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007456:	c7 08       	rjmp	80007536 <get_arg+0x266>
80007458:	58 60       	cp.w	r0,6
8000745a:	e0 8b 00 6e 	brhi	80007536 <get_arg+0x266>
8000745e:	6c 0a       	ld.w	r10,r6[0x0]
80007460:	ea cc ff ff 	sub	r12,r5,-1
80007464:	fe ce af 0c 	sub	lr,pc,-20724
80007468:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000746c:	f4 cb ff f8 	sub	r11,r10,-8
80007470:	8d 0b       	st.w	r6[0x0],r11
80007472:	f4 ea 00 00 	ld.d	r10,r10[0]
80007476:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000747a:	c0 f8       	rjmp	80007498 <get_arg+0x1c8>
8000747c:	f4 cb ff fc 	sub	r11,r10,-4
80007480:	8d 0b       	st.w	r6[0x0],r11
80007482:	74 0a       	ld.w	r10,r10[0x0]
80007484:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007488:	c0 88       	rjmp	80007498 <get_arg+0x1c8>
8000748a:	f4 cb ff f8 	sub	r11,r10,-8
8000748e:	8d 0b       	st.w	r6[0x0],r11
80007490:	f4 ea 00 00 	ld.d	r10,r10[0]
80007494:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007498:	0e 9b       	mov	r11,r7
8000749a:	18 95       	mov	r5,r12
8000749c:	c4 e8       	rjmp	80007538 <get_arg+0x268>
8000749e:	62 0a       	ld.w	r10,r1[0x0]
800074a0:	5b fa       	cp.w	r10,-1
800074a2:	c0 b1       	brne	800074b8 <get_arg+0x1e8>
800074a4:	50 19       	stdsp	sp[0x4],r9
800074a6:	50 28       	stdsp	sp[0x8],r8
800074a8:	e0 6a 00 80 	mov	r10,128
800074ac:	30 0b       	mov	r11,0
800074ae:	02 9c       	mov	r12,r1
800074b0:	fe b0 fc f6 	rcall	80006e9c <memset>
800074b4:	40 28       	lddsp	r8,sp[0x8]
800074b6:	40 19       	lddsp	r9,sp[0x4]
800074b8:	e4 cc 00 01 	sub	r12,r2,1
800074bc:	0e 9b       	mov	r11,r7
800074be:	50 3c       	stdsp	sp[0xc],r12
800074c0:	f2 0c 0c 49 	max	r9,r9,r12
800074c4:	c3 a8       	rjmp	80007538 <get_arg+0x268>
800074c6:	62 0a       	ld.w	r10,r1[0x0]
800074c8:	5b fa       	cp.w	r10,-1
800074ca:	c0 b1       	brne	800074e0 <get_arg+0x210>
800074cc:	50 19       	stdsp	sp[0x4],r9
800074ce:	50 28       	stdsp	sp[0x8],r8
800074d0:	e0 6a 00 80 	mov	r10,128
800074d4:	30 0b       	mov	r11,0
800074d6:	02 9c       	mov	r12,r1
800074d8:	fe b0 fc e2 	rcall	80006e9c <memset>
800074dc:	40 28       	lddsp	r8,sp[0x8]
800074de:	40 19       	lddsp	r9,sp[0x4]
800074e0:	20 12       	sub	r2,1
800074e2:	30 0a       	mov	r10,0
800074e4:	0e 9b       	mov	r11,r7
800074e6:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
800074ea:	f2 02 0c 49 	max	r9,r9,r2
800074ee:	c2 58       	rjmp	80007538 <get_arg+0x268>
800074f0:	16 97       	mov	r7,r11
800074f2:	6c 0a       	ld.w	r10,r6[0x0]
800074f4:	f4 cb ff fc 	sub	r11,r10,-4
800074f8:	8d 0b       	st.w	r6[0x0],r11
800074fa:	74 0a       	ld.w	r10,r10[0x0]
800074fc:	0e 9b       	mov	r11,r7
800074fe:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007502:	2f f5       	sub	r5,-1
80007504:	c1 a8       	rjmp	80007538 <get_arg+0x268>
80007506:	f4 c2 00 30 	sub	r2,r10,48
8000750a:	c0 68       	rjmp	80007516 <get_arg+0x246>
8000750c:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007510:	2f f7       	sub	r7,-1
80007512:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007516:	0f 8a       	ld.ub	r10,r7[0x0]
80007518:	58 0a       	cp.w	r10,0
8000751a:	c0 e0       	breq	80007536 <get_arg+0x266>
8000751c:	23 0a       	sub	r10,48
8000751e:	58 9a       	cp.w	r10,9
80007520:	fe 98 ff f6 	brls	8000750c <get_arg+0x23c>
80007524:	c0 98       	rjmp	80007536 <get_arg+0x266>
80007526:	2f f7       	sub	r7,-1
80007528:	0f 8a       	ld.ub	r10,r7[0x0]
8000752a:	58 0a       	cp.w	r10,0
8000752c:	c0 50       	breq	80007536 <get_arg+0x266>
8000752e:	23 0a       	sub	r10,48
80007530:	58 9a       	cp.w	r10,9
80007532:	fe 98 ff fa 	brls	80007526 <get_arg+0x256>
80007536:	0e 9b       	mov	r11,r7
80007538:	40 7c       	lddsp	r12,sp[0x1c]
8000753a:	30 ba       	mov	r10,11
8000753c:	f4 0c 18 00 	cp.b	r12,r10
80007540:	fe 91 fe f2 	brne	80007324 <get_arg+0x54>
80007544:	40 42       	lddsp	r2,sp[0x10]
80007546:	17 8c       	ld.ub	r12,r11[0x0]
80007548:	0a 32       	cp.w	r2,r5
8000754a:	5f 4a       	srge	r10
8000754c:	f0 0c 18 00 	cp.b	r12,r8
80007550:	5f 1c       	srne	r12
80007552:	f9 ea 00 0a 	and	r10,r12,r10
80007556:	f0 0a 18 00 	cp.b	r10,r8
8000755a:	fe 91 fe cf 	brne	800072f8 <get_arg+0x28>
8000755e:	30 08       	mov	r8,0
80007560:	40 4e       	lddsp	lr,sp[0x10]
80007562:	17 8a       	ld.ub	r10,r11[0x0]
80007564:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007568:	f0 0a 18 00 	cp.b	r10,r8
8000756c:	fc 09 17 10 	movne	r9,lr
80007570:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007574:	06 9e       	mov	lr,r3
80007576:	c2 a8       	rjmp	800075ca <get_arg+0x2fa>
80007578:	62 0a       	ld.w	r10,r1[0x0]
8000757a:	58 3a       	cp.w	r10,3
8000757c:	c1 e0       	breq	800075b8 <get_arg+0x2e8>
8000757e:	e0 89 00 07 	brgt	8000758c <get_arg+0x2bc>
80007582:	58 1a       	cp.w	r10,1
80007584:	c1 a0       	breq	800075b8 <get_arg+0x2e8>
80007586:	58 2a       	cp.w	r10,2
80007588:	c1 81       	brne	800075b8 <get_arg+0x2e8>
8000758a:	c0 58       	rjmp	80007594 <get_arg+0x2c4>
8000758c:	58 5a       	cp.w	r10,5
8000758e:	c0 c0       	breq	800075a6 <get_arg+0x2d6>
80007590:	c0 b5       	brlt	800075a6 <get_arg+0x2d6>
80007592:	c1 38       	rjmp	800075b8 <get_arg+0x2e8>
80007594:	6c 0a       	ld.w	r10,r6[0x0]
80007596:	f4 cc ff f8 	sub	r12,r10,-8
8000759a:	8d 0c       	st.w	r6[0x0],r12
8000759c:	f4 e2 00 00 	ld.d	r2,r10[0]
800075a0:	f0 e3 00 00 	st.d	r8[0],r2
800075a4:	c1 08       	rjmp	800075c4 <get_arg+0x2f4>
800075a6:	6c 0a       	ld.w	r10,r6[0x0]
800075a8:	f4 cc ff f8 	sub	r12,r10,-8
800075ac:	8d 0c       	st.w	r6[0x0],r12
800075ae:	f4 e2 00 00 	ld.d	r2,r10[0]
800075b2:	f0 e3 00 00 	st.d	r8[0],r2
800075b6:	c0 78       	rjmp	800075c4 <get_arg+0x2f4>
800075b8:	6c 0a       	ld.w	r10,r6[0x0]
800075ba:	f4 cc ff fc 	sub	r12,r10,-4
800075be:	8d 0c       	st.w	r6[0x0],r12
800075c0:	74 0a       	ld.w	r10,r10[0x0]
800075c2:	91 0a       	st.w	r8[0x0],r10
800075c4:	2f f5       	sub	r5,-1
800075c6:	2f 88       	sub	r8,-8
800075c8:	2f c1       	sub	r1,-4
800075ca:	12 35       	cp.w	r5,r9
800075cc:	fe 9a ff d6 	brle	80007578 <get_arg+0x2a8>
800075d0:	1c 93       	mov	r3,lr
800075d2:	40 52       	lddsp	r2,sp[0x14]
800075d4:	40 6e       	lddsp	lr,sp[0x18]
800075d6:	85 05       	st.w	r2[0x0],r5
800075d8:	9d 0b       	st.w	lr[0x0],r11
800075da:	40 4b       	lddsp	r11,sp[0x10]
800075dc:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
800075e0:	2f 8d       	sub	sp,-32
800075e2:	d8 32       	popm	r0-r7,pc

800075e4 <__sprint_r>:
800075e4:	d4 21       	pushm	r4-r7,lr
800075e6:	14 97       	mov	r7,r10
800075e8:	74 28       	ld.w	r8,r10[0x8]
800075ea:	58 08       	cp.w	r8,0
800075ec:	c0 41       	brne	800075f4 <__sprint_r+0x10>
800075ee:	95 18       	st.w	r10[0x4],r8
800075f0:	10 9c       	mov	r12,r8
800075f2:	d8 22       	popm	r4-r7,pc
800075f4:	e0 a0 19 94 	rcall	8000a91c <__sfvwrite_r>
800075f8:	30 08       	mov	r8,0
800075fa:	8f 18       	st.w	r7[0x4],r8
800075fc:	8f 28       	st.w	r7[0x8],r8
800075fe:	d8 22       	popm	r4-r7,pc

80007600 <_vfprintf_r>:
80007600:	d4 31       	pushm	r0-r7,lr
80007602:	fa cd 06 bc 	sub	sp,sp,1724
80007606:	51 09       	stdsp	sp[0x40],r9
80007608:	16 91       	mov	r1,r11
8000760a:	14 97       	mov	r7,r10
8000760c:	18 95       	mov	r5,r12
8000760e:	e0 a0 1a f7 	rcall	8000abfc <_localeconv_r>
80007612:	78 0c       	ld.w	r12,r12[0x0]
80007614:	50 cc       	stdsp	sp[0x30],r12
80007616:	58 05       	cp.w	r5,0
80007618:	c0 70       	breq	80007626 <_vfprintf_r+0x26>
8000761a:	6a 68       	ld.w	r8,r5[0x18]
8000761c:	58 08       	cp.w	r8,0
8000761e:	c0 41       	brne	80007626 <_vfprintf_r+0x26>
80007620:	0a 9c       	mov	r12,r5
80007622:	e0 a0 18 1d 	rcall	8000a65c <__sinit>
80007626:	fe c8 ad 0a 	sub	r8,pc,-21238
8000762a:	10 31       	cp.w	r1,r8
8000762c:	c0 31       	brne	80007632 <_vfprintf_r+0x32>
8000762e:	6a 01       	ld.w	r1,r5[0x0]
80007630:	c0 c8       	rjmp	80007648 <_vfprintf_r+0x48>
80007632:	fe c8 ac f6 	sub	r8,pc,-21258
80007636:	10 31       	cp.w	r1,r8
80007638:	c0 31       	brne	8000763e <_vfprintf_r+0x3e>
8000763a:	6a 11       	ld.w	r1,r5[0x4]
8000763c:	c0 68       	rjmp	80007648 <_vfprintf_r+0x48>
8000763e:	fe c8 ac e2 	sub	r8,pc,-21278
80007642:	10 31       	cp.w	r1,r8
80007644:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007648:	82 68       	ld.sh	r8,r1[0xc]
8000764a:	ed b8 00 03 	bld	r8,0x3
8000764e:	c0 41       	brne	80007656 <_vfprintf_r+0x56>
80007650:	62 48       	ld.w	r8,r1[0x10]
80007652:	58 08       	cp.w	r8,0
80007654:	c0 71       	brne	80007662 <_vfprintf_r+0x62>
80007656:	02 9b       	mov	r11,r1
80007658:	0a 9c       	mov	r12,r5
8000765a:	e0 a0 0f 7f 	rcall	80009558 <__swsetup_r>
8000765e:	e0 81 0f 54 	brne	80009506 <_vfprintf_r+0x1f06>
80007662:	82 68       	ld.sh	r8,r1[0xc]
80007664:	10 99       	mov	r9,r8
80007666:	e2 19 00 1a 	andl	r9,0x1a,COH
8000766a:	58 a9       	cp.w	r9,10
8000766c:	c3 c1       	brne	800076e4 <_vfprintf_r+0xe4>
8000766e:	82 79       	ld.sh	r9,r1[0xe]
80007670:	30 0a       	mov	r10,0
80007672:	f4 09 19 00 	cp.h	r9,r10
80007676:	c3 75       	brlt	800076e4 <_vfprintf_r+0xe4>
80007678:	a1 d8       	cbr	r8,0x1
8000767a:	fb 58 05 d0 	st.h	sp[1488],r8
8000767e:	62 88       	ld.w	r8,r1[0x20]
80007680:	fb 48 05 e4 	st.w	sp[1508],r8
80007684:	62 a8       	ld.w	r8,r1[0x28]
80007686:	fb 48 05 ec 	st.w	sp[1516],r8
8000768a:	fa c8 ff bc 	sub	r8,sp,-68
8000768e:	fb 48 05 d4 	st.w	sp[1492],r8
80007692:	fb 48 05 c4 	st.w	sp[1476],r8
80007696:	e0 68 04 00 	mov	r8,1024
8000769a:	fb 48 05 d8 	st.w	sp[1496],r8
8000769e:	fb 48 05 cc 	st.w	sp[1484],r8
800076a2:	30 08       	mov	r8,0
800076a4:	fb 59 05 d2 	st.h	sp[1490],r9
800076a8:	0e 9a       	mov	r10,r7
800076aa:	41 09       	lddsp	r9,sp[0x40]
800076ac:	fa c7 fa 3c 	sub	r7,sp,-1476
800076b0:	fb 48 05 dc 	st.w	sp[1500],r8
800076b4:	0a 9c       	mov	r12,r5
800076b6:	0e 9b       	mov	r11,r7
800076b8:	ca 4f       	rcall	80007600 <_vfprintf_r>
800076ba:	50 bc       	stdsp	sp[0x2c],r12
800076bc:	c0 95       	brlt	800076ce <_vfprintf_r+0xce>
800076be:	0e 9b       	mov	r11,r7
800076c0:	0a 9c       	mov	r12,r5
800076c2:	e0 a0 16 f5 	rcall	8000a4ac <_fflush_r>
800076c6:	40 be       	lddsp	lr,sp[0x2c]
800076c8:	f9 be 01 ff 	movne	lr,-1
800076cc:	50 be       	stdsp	sp[0x2c],lr
800076ce:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800076d2:	ed b8 00 06 	bld	r8,0x6
800076d6:	e0 81 0f 1a 	brne	8000950a <_vfprintf_r+0x1f0a>
800076da:	82 68       	ld.sh	r8,r1[0xc]
800076dc:	a7 a8       	sbr	r8,0x6
800076de:	a2 68       	st.h	r1[0xc],r8
800076e0:	e0 8f 0f 15 	bral	8000950a <_vfprintf_r+0x1f0a>
800076e4:	30 08       	mov	r8,0
800076e6:	fb 48 06 b4 	st.w	sp[1716],r8
800076ea:	fb 48 06 90 	st.w	sp[1680],r8
800076ee:	fb 48 06 8c 	st.w	sp[1676],r8
800076f2:	fb 48 06 b0 	st.w	sp[1712],r8
800076f6:	30 08       	mov	r8,0
800076f8:	30 09       	mov	r9,0
800076fa:	50 a7       	stdsp	sp[0x28],r7
800076fc:	50 78       	stdsp	sp[0x1c],r8
800076fe:	fa c3 f9 e0 	sub	r3,sp,-1568
80007702:	3f f8       	mov	r8,-1
80007704:	50 59       	stdsp	sp[0x14],r9
80007706:	fb 43 06 88 	st.w	sp[1672],r3
8000770a:	fb 48 05 44 	st.w	sp[1348],r8
8000770e:	12 9c       	mov	r12,r9
80007710:	50 69       	stdsp	sp[0x18],r9
80007712:	50 d9       	stdsp	sp[0x34],r9
80007714:	50 e9       	stdsp	sp[0x38],r9
80007716:	50 b9       	stdsp	sp[0x2c],r9
80007718:	12 97       	mov	r7,r9
8000771a:	0a 94       	mov	r4,r5
8000771c:	40 a2       	lddsp	r2,sp[0x28]
8000771e:	32 5a       	mov	r10,37
80007720:	30 08       	mov	r8,0
80007722:	c0 28       	rjmp	80007726 <_vfprintf_r+0x126>
80007724:	2f f2       	sub	r2,-1
80007726:	05 89       	ld.ub	r9,r2[0x0]
80007728:	f0 09 18 00 	cp.b	r9,r8
8000772c:	5f 1b       	srne	r11
8000772e:	f4 09 18 00 	cp.b	r9,r10
80007732:	5f 19       	srne	r9
80007734:	f3 eb 00 0b 	and	r11,r9,r11
80007738:	f0 0b 18 00 	cp.b	r11,r8
8000773c:	cf 41       	brne	80007724 <_vfprintf_r+0x124>
8000773e:	40 ab       	lddsp	r11,sp[0x28]
80007740:	e4 0b 01 06 	sub	r6,r2,r11
80007744:	c1 e0       	breq	80007780 <_vfprintf_r+0x180>
80007746:	fa f8 06 90 	ld.w	r8,sp[1680]
8000774a:	0c 08       	add	r8,r6
8000774c:	87 0b       	st.w	r3[0x0],r11
8000774e:	fb 48 06 90 	st.w	sp[1680],r8
80007752:	87 16       	st.w	r3[0x4],r6
80007754:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007758:	2f f8       	sub	r8,-1
8000775a:	fb 48 06 8c 	st.w	sp[1676],r8
8000775e:	58 78       	cp.w	r8,7
80007760:	e0 89 00 04 	brgt	80007768 <_vfprintf_r+0x168>
80007764:	2f 83       	sub	r3,-8
80007766:	c0 a8       	rjmp	8000777a <_vfprintf_r+0x17a>
80007768:	fa ca f9 78 	sub	r10,sp,-1672
8000776c:	02 9b       	mov	r11,r1
8000776e:	08 9c       	mov	r12,r4
80007770:	c3 af       	rcall	800075e4 <__sprint_r>
80007772:	e0 81 0e c6 	brne	800094fe <_vfprintf_r+0x1efe>
80007776:	fa c3 f9 e0 	sub	r3,sp,-1568
8000777a:	40 ba       	lddsp	r10,sp[0x2c]
8000777c:	0c 0a       	add	r10,r6
8000777e:	50 ba       	stdsp	sp[0x2c],r10
80007780:	05 89       	ld.ub	r9,r2[0x0]
80007782:	30 08       	mov	r8,0
80007784:	f0 09 18 00 	cp.b	r9,r8
80007788:	e0 80 0e aa 	breq	800094dc <_vfprintf_r+0x1edc>
8000778c:	30 09       	mov	r9,0
8000778e:	fb 68 06 bb 	st.b	sp[1723],r8
80007792:	0e 96       	mov	r6,r7
80007794:	e4 c8 ff ff 	sub	r8,r2,-1
80007798:	3f fe       	mov	lr,-1
8000779a:	50 93       	stdsp	sp[0x24],r3
8000779c:	50 41       	stdsp	sp[0x10],r1
8000779e:	0e 93       	mov	r3,r7
800077a0:	04 91       	mov	r1,r2
800077a2:	50 89       	stdsp	sp[0x20],r9
800077a4:	50 a8       	stdsp	sp[0x28],r8
800077a6:	50 2e       	stdsp	sp[0x8],lr
800077a8:	50 39       	stdsp	sp[0xc],r9
800077aa:	12 95       	mov	r5,r9
800077ac:	12 90       	mov	r0,r9
800077ae:	10 97       	mov	r7,r8
800077b0:	08 92       	mov	r2,r4
800077b2:	c0 78       	rjmp	800077c0 <_vfprintf_r+0x1c0>
800077b4:	3f fc       	mov	r12,-1
800077b6:	08 97       	mov	r7,r4
800077b8:	50 2c       	stdsp	sp[0x8],r12
800077ba:	c0 38       	rjmp	800077c0 <_vfprintf_r+0x1c0>
800077bc:	30 0b       	mov	r11,0
800077be:	50 3b       	stdsp	sp[0xc],r11
800077c0:	0f 38       	ld.ub	r8,r7++
800077c2:	c0 28       	rjmp	800077c6 <_vfprintf_r+0x1c6>
800077c4:	12 90       	mov	r0,r9
800077c6:	f0 c9 00 20 	sub	r9,r8,32
800077ca:	e0 49 00 58 	cp.w	r9,88
800077ce:	e0 8b 0a 30 	brhi	80008c2e <_vfprintf_r+0x162e>
800077d2:	fe ca b2 5e 	sub	r10,pc,-19874
800077d6:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800077da:	50 a7       	stdsp	sp[0x28],r7
800077dc:	50 80       	stdsp	sp[0x20],r0
800077de:	0c 97       	mov	r7,r6
800077e0:	04 94       	mov	r4,r2
800077e2:	06 96       	mov	r6,r3
800077e4:	02 92       	mov	r2,r1
800077e6:	fe c9 b0 36 	sub	r9,pc,-20426
800077ea:	40 93       	lddsp	r3,sp[0x24]
800077ec:	10 90       	mov	r0,r8
800077ee:	40 41       	lddsp	r1,sp[0x10]
800077f0:	50 d9       	stdsp	sp[0x34],r9
800077f2:	e0 8f 08 8e 	bral	8000890e <_vfprintf_r+0x130e>
800077f6:	30 08       	mov	r8,0
800077f8:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800077fc:	f0 09 18 00 	cp.b	r9,r8
80007800:	ce 01       	brne	800077c0 <_vfprintf_r+0x1c0>
80007802:	32 08       	mov	r8,32
80007804:	c6 e8       	rjmp	800078e0 <_vfprintf_r+0x2e0>
80007806:	a1 a5       	sbr	r5,0x0
80007808:	cd cb       	rjmp	800077c0 <_vfprintf_r+0x1c0>
8000780a:	0f 89       	ld.ub	r9,r7[0x0]
8000780c:	f2 c8 00 30 	sub	r8,r9,48
80007810:	58 98       	cp.w	r8,9
80007812:	e0 8b 00 1d 	brhi	8000784c <_vfprintf_r+0x24c>
80007816:	ee c8 ff ff 	sub	r8,r7,-1
8000781a:	30 0b       	mov	r11,0
8000781c:	23 09       	sub	r9,48
8000781e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007822:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007826:	11 39       	ld.ub	r9,r8++
80007828:	f2 ca 00 30 	sub	r10,r9,48
8000782c:	58 9a       	cp.w	r10,9
8000782e:	fe 98 ff f7 	brls	8000781c <_vfprintf_r+0x21c>
80007832:	e0 49 00 24 	cp.w	r9,36
80007836:	cc 31       	brne	800077bc <_vfprintf_r+0x1bc>
80007838:	e0 4b 00 20 	cp.w	r11,32
8000783c:	e0 89 0e 60 	brgt	800094fc <_vfprintf_r+0x1efc>
80007840:	20 1b       	sub	r11,1
80007842:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007846:	12 3b       	cp.w	r11,r9
80007848:	c0 95       	brlt	8000785a <_vfprintf_r+0x25a>
8000784a:	c1 08       	rjmp	8000786a <_vfprintf_r+0x26a>
8000784c:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007850:	ec ca ff ff 	sub	r10,r6,-1
80007854:	12 36       	cp.w	r6,r9
80007856:	c1 f5       	brlt	80007894 <_vfprintf_r+0x294>
80007858:	c2 68       	rjmp	800078a4 <_vfprintf_r+0x2a4>
8000785a:	fa ce f9 44 	sub	lr,sp,-1724
8000785e:	10 97       	mov	r7,r8
80007860:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007864:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007868:	c3 58       	rjmp	800078d2 <_vfprintf_r+0x2d2>
8000786a:	10 97       	mov	r7,r8
8000786c:	fa c8 f9 50 	sub	r8,sp,-1712
80007870:	1a d8       	st.w	--sp,r8
80007872:	fa c8 fa b8 	sub	r8,sp,-1352
80007876:	1a d8       	st.w	--sp,r8
80007878:	fa c8 fb b4 	sub	r8,sp,-1100
8000787c:	02 9a       	mov	r10,r1
8000787e:	1a d8       	st.w	--sp,r8
80007880:	04 9c       	mov	r12,r2
80007882:	fa c8 f9 40 	sub	r8,sp,-1728
80007886:	fa c9 ff b4 	sub	r9,sp,-76
8000788a:	fe b0 fd 23 	rcall	800072d0 <get_arg>
8000788e:	2f dd       	sub	sp,-12
80007890:	78 00       	ld.w	r0,r12[0x0]
80007892:	c2 08       	rjmp	800078d2 <_vfprintf_r+0x2d2>
80007894:	fa cc f9 44 	sub	r12,sp,-1724
80007898:	14 96       	mov	r6,r10
8000789a:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000789e:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800078a2:	c1 88       	rjmp	800078d2 <_vfprintf_r+0x2d2>
800078a4:	41 08       	lddsp	r8,sp[0x40]
800078a6:	59 f9       	cp.w	r9,31
800078a8:	e0 89 00 11 	brgt	800078ca <_vfprintf_r+0x2ca>
800078ac:	f0 cb ff fc 	sub	r11,r8,-4
800078b0:	51 0b       	stdsp	sp[0x40],r11
800078b2:	70 00       	ld.w	r0,r8[0x0]
800078b4:	fa cb f9 44 	sub	r11,sp,-1724
800078b8:	f6 09 00 38 	add	r8,r11,r9<<0x3
800078bc:	f1 40 fd 88 	st.w	r8[-632],r0
800078c0:	2f f9       	sub	r9,-1
800078c2:	14 96       	mov	r6,r10
800078c4:	fb 49 06 b4 	st.w	sp[1716],r9
800078c8:	c0 58       	rjmp	800078d2 <_vfprintf_r+0x2d2>
800078ca:	70 00       	ld.w	r0,r8[0x0]
800078cc:	14 96       	mov	r6,r10
800078ce:	2f c8       	sub	r8,-4
800078d0:	51 08       	stdsp	sp[0x40],r8
800078d2:	58 00       	cp.w	r0,0
800078d4:	fe 94 ff 76 	brge	800077c0 <_vfprintf_r+0x1c0>
800078d8:	5c 30       	neg	r0
800078da:	a3 a5       	sbr	r5,0x2
800078dc:	c7 2b       	rjmp	800077c0 <_vfprintf_r+0x1c0>
800078de:	32 b8       	mov	r8,43
800078e0:	fb 68 06 bb 	st.b	sp[1723],r8
800078e4:	c6 eb       	rjmp	800077c0 <_vfprintf_r+0x1c0>
800078e6:	0f 38       	ld.ub	r8,r7++
800078e8:	e0 48 00 2a 	cp.w	r8,42
800078ec:	c0 30       	breq	800078f2 <_vfprintf_r+0x2f2>
800078ee:	30 09       	mov	r9,0
800078f0:	c7 98       	rjmp	800079e2 <_vfprintf_r+0x3e2>
800078f2:	0f 88       	ld.ub	r8,r7[0x0]
800078f4:	f0 c9 00 30 	sub	r9,r8,48
800078f8:	58 99       	cp.w	r9,9
800078fa:	e0 8b 00 1f 	brhi	80007938 <_vfprintf_r+0x338>
800078fe:	ee c4 ff ff 	sub	r4,r7,-1
80007902:	30 0b       	mov	r11,0
80007904:	23 08       	sub	r8,48
80007906:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000790a:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000790e:	09 38       	ld.ub	r8,r4++
80007910:	f0 c9 00 30 	sub	r9,r8,48
80007914:	58 99       	cp.w	r9,9
80007916:	fe 98 ff f7 	brls	80007904 <_vfprintf_r+0x304>
8000791a:	e0 48 00 24 	cp.w	r8,36
8000791e:	fe 91 ff 4f 	brne	800077bc <_vfprintf_r+0x1bc>
80007922:	e0 4b 00 20 	cp.w	r11,32
80007926:	e0 89 0d eb 	brgt	800094fc <_vfprintf_r+0x1efc>
8000792a:	20 1b       	sub	r11,1
8000792c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007930:	10 3b       	cp.w	r11,r8
80007932:	c0 a5       	brlt	80007946 <_vfprintf_r+0x346>
80007934:	c1 18       	rjmp	80007956 <_vfprintf_r+0x356>
80007936:	d7 03       	nop
80007938:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000793c:	ec c9 ff ff 	sub	r9,r6,-1
80007940:	14 36       	cp.w	r6,r10
80007942:	c1 f5       	brlt	80007980 <_vfprintf_r+0x380>
80007944:	c2 88       	rjmp	80007994 <_vfprintf_r+0x394>
80007946:	fa ca f9 44 	sub	r10,sp,-1724
8000794a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000794e:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007952:	50 2b       	stdsp	sp[0x8],r11
80007954:	c3 c8       	rjmp	800079cc <_vfprintf_r+0x3cc>
80007956:	fa c8 f9 50 	sub	r8,sp,-1712
8000795a:	1a d8       	st.w	--sp,r8
8000795c:	fa c8 fa b8 	sub	r8,sp,-1352
80007960:	1a d8       	st.w	--sp,r8
80007962:	fa c8 fb b4 	sub	r8,sp,-1100
80007966:	02 9a       	mov	r10,r1
80007968:	1a d8       	st.w	--sp,r8
8000796a:	04 9c       	mov	r12,r2
8000796c:	fa c8 f9 40 	sub	r8,sp,-1728
80007970:	fa c9 ff b4 	sub	r9,sp,-76
80007974:	fe b0 fc ae 	rcall	800072d0 <get_arg>
80007978:	2f dd       	sub	sp,-12
8000797a:	78 0c       	ld.w	r12,r12[0x0]
8000797c:	50 2c       	stdsp	sp[0x8],r12
8000797e:	c2 78       	rjmp	800079cc <_vfprintf_r+0x3cc>
80007980:	12 96       	mov	r6,r9
80007982:	0e 94       	mov	r4,r7
80007984:	fa c9 f9 44 	sub	r9,sp,-1724
80007988:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000798c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007990:	50 28       	stdsp	sp[0x8],r8
80007992:	c1 d8       	rjmp	800079cc <_vfprintf_r+0x3cc>
80007994:	41 08       	lddsp	r8,sp[0x40]
80007996:	59 fa       	cp.w	r10,31
80007998:	e0 89 00 14 	brgt	800079c0 <_vfprintf_r+0x3c0>
8000799c:	f0 cb ff fc 	sub	r11,r8,-4
800079a0:	70 08       	ld.w	r8,r8[0x0]
800079a2:	51 0b       	stdsp	sp[0x40],r11
800079a4:	50 28       	stdsp	sp[0x8],r8
800079a6:	fa c6 f9 44 	sub	r6,sp,-1724
800079aa:	40 2e       	lddsp	lr,sp[0x8]
800079ac:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800079b0:	f1 4e fd 88 	st.w	r8[-632],lr
800079b4:	2f fa       	sub	r10,-1
800079b6:	0e 94       	mov	r4,r7
800079b8:	fb 4a 06 b4 	st.w	sp[1716],r10
800079bc:	12 96       	mov	r6,r9
800079be:	c0 78       	rjmp	800079cc <_vfprintf_r+0x3cc>
800079c0:	70 0c       	ld.w	r12,r8[0x0]
800079c2:	0e 94       	mov	r4,r7
800079c4:	2f c8       	sub	r8,-4
800079c6:	50 2c       	stdsp	sp[0x8],r12
800079c8:	12 96       	mov	r6,r9
800079ca:	51 08       	stdsp	sp[0x40],r8
800079cc:	40 2b       	lddsp	r11,sp[0x8]
800079ce:	58 0b       	cp.w	r11,0
800079d0:	fe 95 fe f2 	brlt	800077b4 <_vfprintf_r+0x1b4>
800079d4:	08 97       	mov	r7,r4
800079d6:	cf 5a       	rjmp	800077c0 <_vfprintf_r+0x1c0>
800079d8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800079dc:	0f 38       	ld.ub	r8,r7++
800079de:	f4 09 00 19 	add	r9,r10,r9<<0x1
800079e2:	f0 ca 00 30 	sub	r10,r8,48
800079e6:	58 9a       	cp.w	r10,9
800079e8:	fe 98 ff f8 	brls	800079d8 <_vfprintf_r+0x3d8>
800079ec:	3f fa       	mov	r10,-1
800079ee:	f2 0a 0c 49 	max	r9,r9,r10
800079f2:	50 29       	stdsp	sp[0x8],r9
800079f4:	ce 9a       	rjmp	800077c6 <_vfprintf_r+0x1c6>
800079f6:	a7 b5       	sbr	r5,0x7
800079f8:	ce 4a       	rjmp	800077c0 <_vfprintf_r+0x1c0>
800079fa:	30 09       	mov	r9,0
800079fc:	23 08       	sub	r8,48
800079fe:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007a02:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007a06:	0f 38       	ld.ub	r8,r7++
80007a08:	f0 ca 00 30 	sub	r10,r8,48
80007a0c:	58 9a       	cp.w	r10,9
80007a0e:	fe 98 ff f7 	brls	800079fc <_vfprintf_r+0x3fc>
80007a12:	e0 48 00 24 	cp.w	r8,36
80007a16:	fe 91 fe d7 	brne	800077c4 <_vfprintf_r+0x1c4>
80007a1a:	e0 49 00 20 	cp.w	r9,32
80007a1e:	e0 89 0d 6f 	brgt	800094fc <_vfprintf_r+0x1efc>
80007a22:	f2 c3 00 01 	sub	r3,r9,1
80007a26:	30 19       	mov	r9,1
80007a28:	50 39       	stdsp	sp[0xc],r9
80007a2a:	cc ba       	rjmp	800077c0 <_vfprintf_r+0x1c0>
80007a2c:	a3 b5       	sbr	r5,0x3
80007a2e:	cc 9a       	rjmp	800077c0 <_vfprintf_r+0x1c0>
80007a30:	a7 a5       	sbr	r5,0x6
80007a32:	cc 7a       	rjmp	800077c0 <_vfprintf_r+0x1c0>
80007a34:	0a 98       	mov	r8,r5
80007a36:	a5 b5       	sbr	r5,0x5
80007a38:	a5 a8       	sbr	r8,0x4
80007a3a:	0f 89       	ld.ub	r9,r7[0x0]
80007a3c:	36 ce       	mov	lr,108
80007a3e:	fc 09 18 00 	cp.b	r9,lr
80007a42:	f7 b7 00 ff 	subeq	r7,-1
80007a46:	f0 05 17 10 	movne	r5,r8
80007a4a:	cb ba       	rjmp	800077c0 <_vfprintf_r+0x1c0>
80007a4c:	a5 b5       	sbr	r5,0x5
80007a4e:	cb 9a       	rjmp	800077c0 <_vfprintf_r+0x1c0>
80007a50:	50 a7       	stdsp	sp[0x28],r7
80007a52:	50 80       	stdsp	sp[0x20],r0
80007a54:	0c 97       	mov	r7,r6
80007a56:	10 90       	mov	r0,r8
80007a58:	06 96       	mov	r6,r3
80007a5a:	04 94       	mov	r4,r2
80007a5c:	40 93       	lddsp	r3,sp[0x24]
80007a5e:	02 92       	mov	r2,r1
80007a60:	0e 99       	mov	r9,r7
80007a62:	40 41       	lddsp	r1,sp[0x10]
80007a64:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a68:	40 3c       	lddsp	r12,sp[0xc]
80007a6a:	58 0c       	cp.w	r12,0
80007a6c:	c1 d0       	breq	80007aa6 <_vfprintf_r+0x4a6>
80007a6e:	10 36       	cp.w	r6,r8
80007a70:	c0 64       	brge	80007a7c <_vfprintf_r+0x47c>
80007a72:	fa cb f9 44 	sub	r11,sp,-1724
80007a76:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007a7a:	c1 d8       	rjmp	80007ab4 <_vfprintf_r+0x4b4>
80007a7c:	fa c8 f9 50 	sub	r8,sp,-1712
80007a80:	1a d8       	st.w	--sp,r8
80007a82:	fa c8 fa b8 	sub	r8,sp,-1352
80007a86:	1a d8       	st.w	--sp,r8
80007a88:	fa c8 fb b4 	sub	r8,sp,-1100
80007a8c:	1a d8       	st.w	--sp,r8
80007a8e:	fa c8 f9 40 	sub	r8,sp,-1728
80007a92:	fa c9 ff b4 	sub	r9,sp,-76
80007a96:	04 9a       	mov	r10,r2
80007a98:	0c 9b       	mov	r11,r6
80007a9a:	08 9c       	mov	r12,r4
80007a9c:	fe b0 fc 1a 	rcall	800072d0 <get_arg>
80007aa0:	2f dd       	sub	sp,-12
80007aa2:	19 b8       	ld.ub	r8,r12[0x3]
80007aa4:	c2 28       	rjmp	80007ae8 <_vfprintf_r+0x4e8>
80007aa6:	2f f7       	sub	r7,-1
80007aa8:	10 39       	cp.w	r9,r8
80007aaa:	c0 84       	brge	80007aba <_vfprintf_r+0x4ba>
80007aac:	fa ca f9 44 	sub	r10,sp,-1724
80007ab0:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007ab4:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007ab8:	c1 88       	rjmp	80007ae8 <_vfprintf_r+0x4e8>
80007aba:	41 09       	lddsp	r9,sp[0x40]
80007abc:	59 f8       	cp.w	r8,31
80007abe:	e0 89 00 12 	brgt	80007ae2 <_vfprintf_r+0x4e2>
80007ac2:	f2 ca ff fc 	sub	r10,r9,-4
80007ac6:	51 0a       	stdsp	sp[0x40],r10
80007ac8:	72 09       	ld.w	r9,r9[0x0]
80007aca:	fa c6 f9 44 	sub	r6,sp,-1724
80007ace:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007ad2:	2f f8       	sub	r8,-1
80007ad4:	f5 49 fd 88 	st.w	r10[-632],r9
80007ad8:	fb 48 06 b4 	st.w	sp[1716],r8
80007adc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007ae0:	c0 48       	rjmp	80007ae8 <_vfprintf_r+0x4e8>
80007ae2:	13 b8       	ld.ub	r8,r9[0x3]
80007ae4:	2f c9       	sub	r9,-4
80007ae6:	51 09       	stdsp	sp[0x40],r9
80007ae8:	fb 68 06 60 	st.b	sp[1632],r8
80007aec:	30 0e       	mov	lr,0
80007aee:	30 08       	mov	r8,0
80007af0:	30 12       	mov	r2,1
80007af2:	fb 68 06 bb 	st.b	sp[1723],r8
80007af6:	50 2e       	stdsp	sp[0x8],lr
80007af8:	e0 8f 08 ad 	bral	80008c52 <_vfprintf_r+0x1652>
80007afc:	50 a7       	stdsp	sp[0x28],r7
80007afe:	50 80       	stdsp	sp[0x20],r0
80007b00:	0c 97       	mov	r7,r6
80007b02:	04 94       	mov	r4,r2
80007b04:	06 96       	mov	r6,r3
80007b06:	02 92       	mov	r2,r1
80007b08:	40 93       	lddsp	r3,sp[0x24]
80007b0a:	10 90       	mov	r0,r8
80007b0c:	40 41       	lddsp	r1,sp[0x10]
80007b0e:	a5 a5       	sbr	r5,0x4
80007b10:	c0 a8       	rjmp	80007b24 <_vfprintf_r+0x524>
80007b12:	50 a7       	stdsp	sp[0x28],r7
80007b14:	50 80       	stdsp	sp[0x20],r0
80007b16:	0c 97       	mov	r7,r6
80007b18:	04 94       	mov	r4,r2
80007b1a:	06 96       	mov	r6,r3
80007b1c:	02 92       	mov	r2,r1
80007b1e:	40 93       	lddsp	r3,sp[0x24]
80007b20:	10 90       	mov	r0,r8
80007b22:	40 41       	lddsp	r1,sp[0x10]
80007b24:	ed b5 00 05 	bld	r5,0x5
80007b28:	c5 11       	brne	80007bca <_vfprintf_r+0x5ca>
80007b2a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b2e:	40 3c       	lddsp	r12,sp[0xc]
80007b30:	58 0c       	cp.w	r12,0
80007b32:	c1 e0       	breq	80007b6e <_vfprintf_r+0x56e>
80007b34:	10 36       	cp.w	r6,r8
80007b36:	c0 64       	brge	80007b42 <_vfprintf_r+0x542>
80007b38:	fa cb f9 44 	sub	r11,sp,-1724
80007b3c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007b40:	c2 08       	rjmp	80007b80 <_vfprintf_r+0x580>
80007b42:	fa c8 f9 50 	sub	r8,sp,-1712
80007b46:	1a d8       	st.w	--sp,r8
80007b48:	fa c8 fa b8 	sub	r8,sp,-1352
80007b4c:	0c 9b       	mov	r11,r6
80007b4e:	1a d8       	st.w	--sp,r8
80007b50:	fa c8 fb b4 	sub	r8,sp,-1100
80007b54:	1a d8       	st.w	--sp,r8
80007b56:	fa c9 ff b4 	sub	r9,sp,-76
80007b5a:	fa c8 f9 40 	sub	r8,sp,-1728
80007b5e:	04 9a       	mov	r10,r2
80007b60:	08 9c       	mov	r12,r4
80007b62:	fe b0 fb b7 	rcall	800072d0 <get_arg>
80007b66:	2f dd       	sub	sp,-12
80007b68:	78 1b       	ld.w	r11,r12[0x4]
80007b6a:	78 09       	ld.w	r9,r12[0x0]
80007b6c:	c2 b8       	rjmp	80007bc2 <_vfprintf_r+0x5c2>
80007b6e:	ee ca ff ff 	sub	r10,r7,-1
80007b72:	10 37       	cp.w	r7,r8
80007b74:	c0 b4       	brge	80007b8a <_vfprintf_r+0x58a>
80007b76:	fa c9 f9 44 	sub	r9,sp,-1724
80007b7a:	14 97       	mov	r7,r10
80007b7c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007b80:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007b84:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007b88:	c1 d8       	rjmp	80007bc2 <_vfprintf_r+0x5c2>
80007b8a:	41 09       	lddsp	r9,sp[0x40]
80007b8c:	59 f8       	cp.w	r8,31
80007b8e:	e0 89 00 14 	brgt	80007bb6 <_vfprintf_r+0x5b6>
80007b92:	f2 cb ff f8 	sub	r11,r9,-8
80007b96:	51 0b       	stdsp	sp[0x40],r11
80007b98:	fa c6 f9 44 	sub	r6,sp,-1724
80007b9c:	72 1b       	ld.w	r11,r9[0x4]
80007b9e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007ba2:	72 09       	ld.w	r9,r9[0x0]
80007ba4:	f9 4b fd 8c 	st.w	r12[-628],r11
80007ba8:	f9 49 fd 88 	st.w	r12[-632],r9
80007bac:	2f f8       	sub	r8,-1
80007bae:	14 97       	mov	r7,r10
80007bb0:	fb 48 06 b4 	st.w	sp[1716],r8
80007bb4:	c0 78       	rjmp	80007bc2 <_vfprintf_r+0x5c2>
80007bb6:	f2 c8 ff f8 	sub	r8,r9,-8
80007bba:	72 1b       	ld.w	r11,r9[0x4]
80007bbc:	14 97       	mov	r7,r10
80007bbe:	51 08       	stdsp	sp[0x40],r8
80007bc0:	72 09       	ld.w	r9,r9[0x0]
80007bc2:	16 98       	mov	r8,r11
80007bc4:	fa e9 00 00 	st.d	sp[0],r8
80007bc8:	ca e8       	rjmp	80007d24 <_vfprintf_r+0x724>
80007bca:	ed b5 00 04 	bld	r5,0x4
80007bce:	c1 71       	brne	80007bfc <_vfprintf_r+0x5fc>
80007bd0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007bd4:	40 3e       	lddsp	lr,sp[0xc]
80007bd6:	58 0e       	cp.w	lr,0
80007bd8:	c0 80       	breq	80007be8 <_vfprintf_r+0x5e8>
80007bda:	10 36       	cp.w	r6,r8
80007bdc:	c6 94       	brge	80007cae <_vfprintf_r+0x6ae>
80007bde:	fa cc f9 44 	sub	r12,sp,-1724
80007be2:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007be6:	c8 28       	rjmp	80007cea <_vfprintf_r+0x6ea>
80007be8:	ee ca ff ff 	sub	r10,r7,-1
80007bec:	10 37       	cp.w	r7,r8
80007bee:	e0 84 00 81 	brge	80007cf0 <_vfprintf_r+0x6f0>
80007bf2:	fa cb f9 44 	sub	r11,sp,-1724
80007bf6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007bfa:	c7 78       	rjmp	80007ce8 <_vfprintf_r+0x6e8>
80007bfc:	ed b5 00 06 	bld	r5,0x6
80007c00:	c4 b1       	brne	80007c96 <_vfprintf_r+0x696>
80007c02:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007c06:	40 3c       	lddsp	r12,sp[0xc]
80007c08:	58 0c       	cp.w	r12,0
80007c0a:	c1 d0       	breq	80007c44 <_vfprintf_r+0x644>
80007c0c:	10 36       	cp.w	r6,r8
80007c0e:	c0 64       	brge	80007c1a <_vfprintf_r+0x61a>
80007c10:	fa cb f9 44 	sub	r11,sp,-1724
80007c14:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007c18:	c1 f8       	rjmp	80007c56 <_vfprintf_r+0x656>
80007c1a:	fa c8 f9 50 	sub	r8,sp,-1712
80007c1e:	1a d8       	st.w	--sp,r8
80007c20:	fa c8 fa b8 	sub	r8,sp,-1352
80007c24:	1a d8       	st.w	--sp,r8
80007c26:	fa c8 fb b4 	sub	r8,sp,-1100
80007c2a:	1a d8       	st.w	--sp,r8
80007c2c:	fa c8 f9 40 	sub	r8,sp,-1728
80007c30:	fa c9 ff b4 	sub	r9,sp,-76
80007c34:	04 9a       	mov	r10,r2
80007c36:	0c 9b       	mov	r11,r6
80007c38:	08 9c       	mov	r12,r4
80007c3a:	fe b0 fb 4b 	rcall	800072d0 <get_arg>
80007c3e:	2f dd       	sub	sp,-12
80007c40:	98 18       	ld.sh	r8,r12[0x2]
80007c42:	c2 68       	rjmp	80007c8e <_vfprintf_r+0x68e>
80007c44:	ee ca ff ff 	sub	r10,r7,-1
80007c48:	10 37       	cp.w	r7,r8
80007c4a:	c0 94       	brge	80007c5c <_vfprintf_r+0x65c>
80007c4c:	fa c9 f9 44 	sub	r9,sp,-1724
80007c50:	14 97       	mov	r7,r10
80007c52:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007c56:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007c5a:	c1 a8       	rjmp	80007c8e <_vfprintf_r+0x68e>
80007c5c:	41 09       	lddsp	r9,sp[0x40]
80007c5e:	59 f8       	cp.w	r8,31
80007c60:	e0 89 00 13 	brgt	80007c86 <_vfprintf_r+0x686>
80007c64:	f2 cb ff fc 	sub	r11,r9,-4
80007c68:	51 0b       	stdsp	sp[0x40],r11
80007c6a:	72 09       	ld.w	r9,r9[0x0]
80007c6c:	fa c6 f9 44 	sub	r6,sp,-1724
80007c70:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007c74:	2f f8       	sub	r8,-1
80007c76:	f7 49 fd 88 	st.w	r11[-632],r9
80007c7a:	fb 48 06 b4 	st.w	sp[1716],r8
80007c7e:	14 97       	mov	r7,r10
80007c80:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007c84:	c0 58       	rjmp	80007c8e <_vfprintf_r+0x68e>
80007c86:	92 18       	ld.sh	r8,r9[0x2]
80007c88:	14 97       	mov	r7,r10
80007c8a:	2f c9       	sub	r9,-4
80007c8c:	51 09       	stdsp	sp[0x40],r9
80007c8e:	50 18       	stdsp	sp[0x4],r8
80007c90:	bf 58       	asr	r8,0x1f
80007c92:	50 08       	stdsp	sp[0x0],r8
80007c94:	c4 88       	rjmp	80007d24 <_vfprintf_r+0x724>
80007c96:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007c9a:	40 3c       	lddsp	r12,sp[0xc]
80007c9c:	58 0c       	cp.w	r12,0
80007c9e:	c1 d0       	breq	80007cd8 <_vfprintf_r+0x6d8>
80007ca0:	10 36       	cp.w	r6,r8
80007ca2:	c0 64       	brge	80007cae <_vfprintf_r+0x6ae>
80007ca4:	fa cb f9 44 	sub	r11,sp,-1724
80007ca8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007cac:	c1 f8       	rjmp	80007cea <_vfprintf_r+0x6ea>
80007cae:	fa c8 f9 50 	sub	r8,sp,-1712
80007cb2:	1a d8       	st.w	--sp,r8
80007cb4:	fa c8 fa b8 	sub	r8,sp,-1352
80007cb8:	0c 9b       	mov	r11,r6
80007cba:	1a d8       	st.w	--sp,r8
80007cbc:	fa c8 fb b4 	sub	r8,sp,-1100
80007cc0:	04 9a       	mov	r10,r2
80007cc2:	1a d8       	st.w	--sp,r8
80007cc4:	08 9c       	mov	r12,r4
80007cc6:	fa c8 f9 40 	sub	r8,sp,-1728
80007cca:	fa c9 ff b4 	sub	r9,sp,-76
80007cce:	fe b0 fb 01 	rcall	800072d0 <get_arg>
80007cd2:	2f dd       	sub	sp,-12
80007cd4:	78 0b       	ld.w	r11,r12[0x0]
80007cd6:	c2 48       	rjmp	80007d1e <_vfprintf_r+0x71e>
80007cd8:	ee ca ff ff 	sub	r10,r7,-1
80007cdc:	10 37       	cp.w	r7,r8
80007cde:	c0 94       	brge	80007cf0 <_vfprintf_r+0x6f0>
80007ce0:	fa c9 f9 44 	sub	r9,sp,-1724
80007ce4:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007ce8:	14 97       	mov	r7,r10
80007cea:	ec fb fd 88 	ld.w	r11,r6[-632]
80007cee:	c1 88       	rjmp	80007d1e <_vfprintf_r+0x71e>
80007cf0:	41 09       	lddsp	r9,sp[0x40]
80007cf2:	59 f8       	cp.w	r8,31
80007cf4:	e0 89 00 11 	brgt	80007d16 <_vfprintf_r+0x716>
80007cf8:	f2 cb ff fc 	sub	r11,r9,-4
80007cfc:	51 0b       	stdsp	sp[0x40],r11
80007cfe:	fa c6 f9 44 	sub	r6,sp,-1724
80007d02:	72 0b       	ld.w	r11,r9[0x0]
80007d04:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007d08:	f3 4b fd 88 	st.w	r9[-632],r11
80007d0c:	2f f8       	sub	r8,-1
80007d0e:	14 97       	mov	r7,r10
80007d10:	fb 48 06 b4 	st.w	sp[1716],r8
80007d14:	c0 58       	rjmp	80007d1e <_vfprintf_r+0x71e>
80007d16:	72 0b       	ld.w	r11,r9[0x0]
80007d18:	14 97       	mov	r7,r10
80007d1a:	2f c9       	sub	r9,-4
80007d1c:	51 09       	stdsp	sp[0x40],r9
80007d1e:	50 1b       	stdsp	sp[0x4],r11
80007d20:	bf 5b       	asr	r11,0x1f
80007d22:	50 0b       	stdsp	sp[0x0],r11
80007d24:	fa ea 00 00 	ld.d	r10,sp[0]
80007d28:	58 0a       	cp.w	r10,0
80007d2a:	5c 2b       	cpc	r11
80007d2c:	c0 e4       	brge	80007d48 <_vfprintf_r+0x748>
80007d2e:	30 08       	mov	r8,0
80007d30:	fa ea 00 00 	ld.d	r10,sp[0]
80007d34:	30 09       	mov	r9,0
80007d36:	f0 0a 01 0a 	sub	r10,r8,r10
80007d3a:	f2 0b 01 4b 	sbc	r11,r9,r11
80007d3e:	32 d8       	mov	r8,45
80007d40:	fa eb 00 00 	st.d	sp[0],r10
80007d44:	fb 68 06 bb 	st.b	sp[1723],r8
80007d48:	30 18       	mov	r8,1
80007d4a:	e0 8f 06 fa 	bral	80008b3e <_vfprintf_r+0x153e>
80007d4e:	50 a7       	stdsp	sp[0x28],r7
80007d50:	50 80       	stdsp	sp[0x20],r0
80007d52:	0c 97       	mov	r7,r6
80007d54:	04 94       	mov	r4,r2
80007d56:	06 96       	mov	r6,r3
80007d58:	02 92       	mov	r2,r1
80007d5a:	40 93       	lddsp	r3,sp[0x24]
80007d5c:	10 90       	mov	r0,r8
80007d5e:	40 41       	lddsp	r1,sp[0x10]
80007d60:	0e 99       	mov	r9,r7
80007d62:	ed b5 00 03 	bld	r5,0x3
80007d66:	c4 11       	brne	80007de8 <_vfprintf_r+0x7e8>
80007d68:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d6c:	40 3a       	lddsp	r10,sp[0xc]
80007d6e:	58 0a       	cp.w	r10,0
80007d70:	c1 90       	breq	80007da2 <_vfprintf_r+0x7a2>
80007d72:	10 36       	cp.w	r6,r8
80007d74:	c6 45       	brlt	80007e3c <_vfprintf_r+0x83c>
80007d76:	fa c8 f9 50 	sub	r8,sp,-1712
80007d7a:	1a d8       	st.w	--sp,r8
80007d7c:	fa c8 fa b8 	sub	r8,sp,-1352
80007d80:	1a d8       	st.w	--sp,r8
80007d82:	fa c8 fb b4 	sub	r8,sp,-1100
80007d86:	0c 9b       	mov	r11,r6
80007d88:	1a d8       	st.w	--sp,r8
80007d8a:	04 9a       	mov	r10,r2
80007d8c:	fa c8 f9 40 	sub	r8,sp,-1728
80007d90:	fa c9 ff b4 	sub	r9,sp,-76
80007d94:	08 9c       	mov	r12,r4
80007d96:	fe b0 fa 9d 	rcall	800072d0 <get_arg>
80007d9a:	2f dd       	sub	sp,-12
80007d9c:	78 16       	ld.w	r6,r12[0x4]
80007d9e:	50 76       	stdsp	sp[0x1c],r6
80007da0:	c4 88       	rjmp	80007e30 <_vfprintf_r+0x830>
80007da2:	2f f7       	sub	r7,-1
80007da4:	10 39       	cp.w	r9,r8
80007da6:	c0 c4       	brge	80007dbe <_vfprintf_r+0x7be>
80007da8:	fa ce f9 44 	sub	lr,sp,-1724
80007dac:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007db0:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007db4:	50 7c       	stdsp	sp[0x1c],r12
80007db6:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007dba:	50 56       	stdsp	sp[0x14],r6
80007dbc:	c6 68       	rjmp	80007e88 <_vfprintf_r+0x888>
80007dbe:	41 09       	lddsp	r9,sp[0x40]
80007dc0:	59 f8       	cp.w	r8,31
80007dc2:	e0 89 00 10 	brgt	80007de2 <_vfprintf_r+0x7e2>
80007dc6:	f2 ca ff f8 	sub	r10,r9,-8
80007dca:	72 1b       	ld.w	r11,r9[0x4]
80007dcc:	51 0a       	stdsp	sp[0x40],r10
80007dce:	72 09       	ld.w	r9,r9[0x0]
80007dd0:	fa ca f9 44 	sub	r10,sp,-1724
80007dd4:	50 7b       	stdsp	sp[0x1c],r11
80007dd6:	50 59       	stdsp	sp[0x14],r9
80007dd8:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007ddc:	40 5b       	lddsp	r11,sp[0x14]
80007dde:	40 7a       	lddsp	r10,sp[0x1c]
80007de0:	c4 78       	rjmp	80007e6e <_vfprintf_r+0x86e>
80007de2:	72 18       	ld.w	r8,r9[0x4]
80007de4:	50 78       	stdsp	sp[0x1c],r8
80007de6:	c4 c8       	rjmp	80007e7e <_vfprintf_r+0x87e>
80007de8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007dec:	40 3e       	lddsp	lr,sp[0xc]
80007dee:	58 0e       	cp.w	lr,0
80007df0:	c2 30       	breq	80007e36 <_vfprintf_r+0x836>
80007df2:	10 36       	cp.w	r6,r8
80007df4:	c0 94       	brge	80007e06 <_vfprintf_r+0x806>
80007df6:	fa cc f9 44 	sub	r12,sp,-1724
80007dfa:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007dfe:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007e02:	50 7b       	stdsp	sp[0x1c],r11
80007e04:	cd 9b       	rjmp	80007db6 <_vfprintf_r+0x7b6>
80007e06:	fa c8 f9 50 	sub	r8,sp,-1712
80007e0a:	1a d8       	st.w	--sp,r8
80007e0c:	fa c8 fa b8 	sub	r8,sp,-1352
80007e10:	04 9a       	mov	r10,r2
80007e12:	1a d8       	st.w	--sp,r8
80007e14:	fa c8 fb b4 	sub	r8,sp,-1100
80007e18:	0c 9b       	mov	r11,r6
80007e1a:	1a d8       	st.w	--sp,r8
80007e1c:	08 9c       	mov	r12,r4
80007e1e:	fa c8 f9 40 	sub	r8,sp,-1728
80007e22:	fa c9 ff b4 	sub	r9,sp,-76
80007e26:	fe b0 fa 55 	rcall	800072d0 <get_arg>
80007e2a:	2f dd       	sub	sp,-12
80007e2c:	78 1a       	ld.w	r10,r12[0x4]
80007e2e:	50 7a       	stdsp	sp[0x1c],r10
80007e30:	78 0c       	ld.w	r12,r12[0x0]
80007e32:	50 5c       	stdsp	sp[0x14],r12
80007e34:	c2 a8       	rjmp	80007e88 <_vfprintf_r+0x888>
80007e36:	2f f7       	sub	r7,-1
80007e38:	10 39       	cp.w	r9,r8
80007e3a:	c0 94       	brge	80007e4c <_vfprintf_r+0x84c>
80007e3c:	fa c9 f9 44 	sub	r9,sp,-1724
80007e40:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007e44:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80007e48:	50 78       	stdsp	sp[0x1c],r8
80007e4a:	cb 6b       	rjmp	80007db6 <_vfprintf_r+0x7b6>
80007e4c:	41 09       	lddsp	r9,sp[0x40]
80007e4e:	59 f8       	cp.w	r8,31
80007e50:	e0 89 00 15 	brgt	80007e7a <_vfprintf_r+0x87a>
80007e54:	f2 ca ff f8 	sub	r10,r9,-8
80007e58:	72 16       	ld.w	r6,r9[0x4]
80007e5a:	72 09       	ld.w	r9,r9[0x0]
80007e5c:	51 0a       	stdsp	sp[0x40],r10
80007e5e:	50 59       	stdsp	sp[0x14],r9
80007e60:	fa ce f9 44 	sub	lr,sp,-1724
80007e64:	50 76       	stdsp	sp[0x1c],r6
80007e66:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007e6a:	40 5b       	lddsp	r11,sp[0x14]
80007e6c:	0c 9a       	mov	r10,r6
80007e6e:	f2 eb fd 88 	st.d	r9[-632],r10
80007e72:	2f f8       	sub	r8,-1
80007e74:	fb 48 06 b4 	st.w	sp[1716],r8
80007e78:	c0 88       	rjmp	80007e88 <_vfprintf_r+0x888>
80007e7a:	72 1c       	ld.w	r12,r9[0x4]
80007e7c:	50 7c       	stdsp	sp[0x1c],r12
80007e7e:	f2 c8 ff f8 	sub	r8,r9,-8
80007e82:	51 08       	stdsp	sp[0x40],r8
80007e84:	72 09       	ld.w	r9,r9[0x0]
80007e86:	50 59       	stdsp	sp[0x14],r9
80007e88:	40 5b       	lddsp	r11,sp[0x14]
80007e8a:	40 7a       	lddsp	r10,sp[0x1c]
80007e8c:	e0 a0 1a 2e 	rcall	8000b2e8 <__isinfd>
80007e90:	18 96       	mov	r6,r12
80007e92:	c1 70       	breq	80007ec0 <_vfprintf_r+0x8c0>
80007e94:	30 08       	mov	r8,0
80007e96:	30 09       	mov	r9,0
80007e98:	40 5b       	lddsp	r11,sp[0x14]
80007e9a:	40 7a       	lddsp	r10,sp[0x1c]
80007e9c:	e0 a0 1e 8e 	rcall	8000bbb8 <__avr32_f64_cmp_lt>
80007ea0:	c0 40       	breq	80007ea8 <_vfprintf_r+0x8a8>
80007ea2:	32 d8       	mov	r8,45
80007ea4:	fb 68 06 bb 	st.b	sp[1723],r8
80007ea8:	fe c8 b6 e4 	sub	r8,pc,-18716
80007eac:	fe c6 b6 e4 	sub	r6,pc,-18716
80007eb0:	a7 d5       	cbr	r5,0x7
80007eb2:	e0 40 00 47 	cp.w	r0,71
80007eb6:	f0 06 17 a0 	movle	r6,r8
80007eba:	30 32       	mov	r2,3
80007ebc:	e0 8f 06 ce 	bral	80008c58 <_vfprintf_r+0x1658>
80007ec0:	40 5b       	lddsp	r11,sp[0x14]
80007ec2:	40 7a       	lddsp	r10,sp[0x1c]
80007ec4:	e0 a0 1a 27 	rcall	8000b312 <__isnand>
80007ec8:	c0 e0       	breq	80007ee4 <_vfprintf_r+0x8e4>
80007eca:	50 26       	stdsp	sp[0x8],r6
80007ecc:	fe c8 b7 00 	sub	r8,pc,-18688
80007ed0:	fe c6 b7 00 	sub	r6,pc,-18688
80007ed4:	a7 d5       	cbr	r5,0x7
80007ed6:	e0 40 00 47 	cp.w	r0,71
80007eda:	f0 06 17 a0 	movle	r6,r8
80007ede:	30 32       	mov	r2,3
80007ee0:	e0 8f 06 c2 	bral	80008c64 <_vfprintf_r+0x1664>
80007ee4:	40 2a       	lddsp	r10,sp[0x8]
80007ee6:	5b fa       	cp.w	r10,-1
80007ee8:	c0 41       	brne	80007ef0 <_vfprintf_r+0x8f0>
80007eea:	30 69       	mov	r9,6
80007eec:	50 29       	stdsp	sp[0x8],r9
80007eee:	c1 18       	rjmp	80007f10 <_vfprintf_r+0x910>
80007ef0:	e0 40 00 47 	cp.w	r0,71
80007ef4:	5f 09       	sreq	r9
80007ef6:	e0 40 00 67 	cp.w	r0,103
80007efa:	5f 08       	sreq	r8
80007efc:	f3 e8 10 08 	or	r8,r9,r8
80007f00:	f8 08 18 00 	cp.b	r8,r12
80007f04:	c0 60       	breq	80007f10 <_vfprintf_r+0x910>
80007f06:	40 28       	lddsp	r8,sp[0x8]
80007f08:	58 08       	cp.w	r8,0
80007f0a:	f9 b8 00 01 	moveq	r8,1
80007f0e:	50 28       	stdsp	sp[0x8],r8
80007f10:	40 78       	lddsp	r8,sp[0x1c]
80007f12:	40 59       	lddsp	r9,sp[0x14]
80007f14:	fa e9 06 94 	st.d	sp[1684],r8
80007f18:	a9 a5       	sbr	r5,0x8
80007f1a:	fa f8 06 94 	ld.w	r8,sp[1684]
80007f1e:	58 08       	cp.w	r8,0
80007f20:	c0 65       	brlt	80007f2c <_vfprintf_r+0x92c>
80007f22:	40 5e       	lddsp	lr,sp[0x14]
80007f24:	30 0c       	mov	r12,0
80007f26:	50 6e       	stdsp	sp[0x18],lr
80007f28:	50 9c       	stdsp	sp[0x24],r12
80007f2a:	c0 78       	rjmp	80007f38 <_vfprintf_r+0x938>
80007f2c:	40 5b       	lddsp	r11,sp[0x14]
80007f2e:	32 da       	mov	r10,45
80007f30:	ee 1b 80 00 	eorh	r11,0x8000
80007f34:	50 9a       	stdsp	sp[0x24],r10
80007f36:	50 6b       	stdsp	sp[0x18],r11
80007f38:	e0 40 00 46 	cp.w	r0,70
80007f3c:	5f 09       	sreq	r9
80007f3e:	e0 40 00 66 	cp.w	r0,102
80007f42:	5f 08       	sreq	r8
80007f44:	f3 e8 10 08 	or	r8,r9,r8
80007f48:	50 48       	stdsp	sp[0x10],r8
80007f4a:	c0 40       	breq	80007f52 <_vfprintf_r+0x952>
80007f4c:	40 22       	lddsp	r2,sp[0x8]
80007f4e:	30 39       	mov	r9,3
80007f50:	c1 08       	rjmp	80007f70 <_vfprintf_r+0x970>
80007f52:	e0 40 00 45 	cp.w	r0,69
80007f56:	5f 09       	sreq	r9
80007f58:	e0 40 00 65 	cp.w	r0,101
80007f5c:	5f 08       	sreq	r8
80007f5e:	40 22       	lddsp	r2,sp[0x8]
80007f60:	10 49       	or	r9,r8
80007f62:	2f f2       	sub	r2,-1
80007f64:	40 46       	lddsp	r6,sp[0x10]
80007f66:	ec 09 18 00 	cp.b	r9,r6
80007f6a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80007f6e:	30 29       	mov	r9,2
80007f70:	fa c8 f9 5c 	sub	r8,sp,-1700
80007f74:	1a d8       	st.w	--sp,r8
80007f76:	fa c8 f9 54 	sub	r8,sp,-1708
80007f7a:	1a d8       	st.w	--sp,r8
80007f7c:	fa c8 f9 4c 	sub	r8,sp,-1716
80007f80:	08 9c       	mov	r12,r4
80007f82:	1a d8       	st.w	--sp,r8
80007f84:	04 98       	mov	r8,r2
80007f86:	40 9b       	lddsp	r11,sp[0x24]
80007f88:	40 aa       	lddsp	r10,sp[0x28]
80007f8a:	e0 a0 0c 9d 	rcall	800098c4 <_dtoa_r>
80007f8e:	e0 40 00 47 	cp.w	r0,71
80007f92:	5f 19       	srne	r9
80007f94:	e0 40 00 67 	cp.w	r0,103
80007f98:	5f 18       	srne	r8
80007f9a:	18 96       	mov	r6,r12
80007f9c:	2f dd       	sub	sp,-12
80007f9e:	f3 e8 00 08 	and	r8,r9,r8
80007fa2:	c0 41       	brne	80007faa <_vfprintf_r+0x9aa>
80007fa4:	ed b5 00 00 	bld	r5,0x0
80007fa8:	c3 01       	brne	80008008 <_vfprintf_r+0xa08>
80007faa:	ec 02 00 0e 	add	lr,r6,r2
80007fae:	50 3e       	stdsp	sp[0xc],lr
80007fb0:	40 4c       	lddsp	r12,sp[0x10]
80007fb2:	58 0c       	cp.w	r12,0
80007fb4:	c1 50       	breq	80007fde <_vfprintf_r+0x9de>
80007fb6:	0d 89       	ld.ub	r9,r6[0x0]
80007fb8:	33 08       	mov	r8,48
80007fba:	f0 09 18 00 	cp.b	r9,r8
80007fbe:	c0 b1       	brne	80007fd4 <_vfprintf_r+0x9d4>
80007fc0:	30 08       	mov	r8,0
80007fc2:	30 09       	mov	r9,0
80007fc4:	40 6b       	lddsp	r11,sp[0x18]
80007fc6:	40 7a       	lddsp	r10,sp[0x1c]
80007fc8:	e0 a0 1d b1 	rcall	8000bb2a <__avr32_f64_cmp_eq>
80007fcc:	fb b2 00 01 	rsubeq	r2,1
80007fd0:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007fd4:	40 3b       	lddsp	r11,sp[0xc]
80007fd6:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007fda:	10 0b       	add	r11,r8
80007fdc:	50 3b       	stdsp	sp[0xc],r11
80007fde:	40 6b       	lddsp	r11,sp[0x18]
80007fe0:	30 08       	mov	r8,0
80007fe2:	30 09       	mov	r9,0
80007fe4:	40 7a       	lddsp	r10,sp[0x1c]
80007fe6:	e0 a0 1d a2 	rcall	8000bb2a <__avr32_f64_cmp_eq>
80007fea:	c0 90       	breq	80007ffc <_vfprintf_r+0x9fc>
80007fec:	40 3a       	lddsp	r10,sp[0xc]
80007fee:	fb 4a 06 a4 	st.w	sp[1700],r10
80007ff2:	c0 58       	rjmp	80007ffc <_vfprintf_r+0x9fc>
80007ff4:	10 c9       	st.b	r8++,r9
80007ff6:	fb 48 06 a4 	st.w	sp[1700],r8
80007ffa:	c0 28       	rjmp	80007ffe <_vfprintf_r+0x9fe>
80007ffc:	33 09       	mov	r9,48
80007ffe:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008002:	40 3e       	lddsp	lr,sp[0xc]
80008004:	1c 38       	cp.w	r8,lr
80008006:	cf 73       	brcs	80007ff4 <_vfprintf_r+0x9f4>
80008008:	e0 40 00 47 	cp.w	r0,71
8000800c:	5f 09       	sreq	r9
8000800e:	e0 40 00 67 	cp.w	r0,103
80008012:	5f 08       	sreq	r8
80008014:	f3 e8 10 08 	or	r8,r9,r8
80008018:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000801c:	0c 19       	sub	r9,r6
8000801e:	50 69       	stdsp	sp[0x18],r9
80008020:	58 08       	cp.w	r8,0
80008022:	c0 b0       	breq	80008038 <_vfprintf_r+0xa38>
80008024:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008028:	5b d8       	cp.w	r8,-3
8000802a:	c0 55       	brlt	80008034 <_vfprintf_r+0xa34>
8000802c:	40 2c       	lddsp	r12,sp[0x8]
8000802e:	18 38       	cp.w	r8,r12
80008030:	e0 8a 00 6a 	brle	80008104 <_vfprintf_r+0xb04>
80008034:	20 20       	sub	r0,2
80008036:	c0 58       	rjmp	80008040 <_vfprintf_r+0xa40>
80008038:	e0 40 00 65 	cp.w	r0,101
8000803c:	e0 89 00 46 	brgt	800080c8 <_vfprintf_r+0xac8>
80008040:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008044:	fb 60 06 9c 	st.b	sp[1692],r0
80008048:	20 1b       	sub	r11,1
8000804a:	fb 4b 06 ac 	st.w	sp[1708],r11
8000804e:	c0 47       	brpl	80008056 <_vfprintf_r+0xa56>
80008050:	5c 3b       	neg	r11
80008052:	32 d8       	mov	r8,45
80008054:	c0 28       	rjmp	80008058 <_vfprintf_r+0xa58>
80008056:	32 b8       	mov	r8,43
80008058:	fb 68 06 9d 	st.b	sp[1693],r8
8000805c:	58 9b       	cp.w	r11,9
8000805e:	e0 8a 00 1d 	brle	80008098 <_vfprintf_r+0xa98>
80008062:	fa c9 fa 35 	sub	r9,sp,-1483
80008066:	30 aa       	mov	r10,10
80008068:	12 98       	mov	r8,r9
8000806a:	0e 9c       	mov	r12,r7
8000806c:	0c 92       	mov	r2,r6
8000806e:	f6 0a 0c 06 	divs	r6,r11,r10
80008072:	0e 9b       	mov	r11,r7
80008074:	2d 0b       	sub	r11,-48
80008076:	10 fb       	st.b	--r8,r11
80008078:	0c 9b       	mov	r11,r6
8000807a:	58 96       	cp.w	r6,9
8000807c:	fe 99 ff f9 	brgt	8000806e <_vfprintf_r+0xa6e>
80008080:	2d 0b       	sub	r11,-48
80008082:	18 97       	mov	r7,r12
80008084:	04 96       	mov	r6,r2
80008086:	10 fb       	st.b	--r8,r11
80008088:	fa ca f9 62 	sub	r10,sp,-1694
8000808c:	c0 38       	rjmp	80008092 <_vfprintf_r+0xa92>
8000808e:	11 3b       	ld.ub	r11,r8++
80008090:	14 cb       	st.b	r10++,r11
80008092:	12 38       	cp.w	r8,r9
80008094:	cf d3       	brcs	8000808e <_vfprintf_r+0xa8e>
80008096:	c0 98       	rjmp	800080a8 <_vfprintf_r+0xaa8>
80008098:	2d 0b       	sub	r11,-48
8000809a:	33 08       	mov	r8,48
8000809c:	fb 6b 06 9f 	st.b	sp[1695],r11
800080a0:	fb 68 06 9e 	st.b	sp[1694],r8
800080a4:	fa ca f9 60 	sub	r10,sp,-1696
800080a8:	fa c8 f9 64 	sub	r8,sp,-1692
800080ac:	f4 08 01 08 	sub	r8,r10,r8
800080b0:	50 e8       	stdsp	sp[0x38],r8
800080b2:	10 92       	mov	r2,r8
800080b4:	40 6b       	lddsp	r11,sp[0x18]
800080b6:	16 02       	add	r2,r11
800080b8:	58 1b       	cp.w	r11,1
800080ba:	e0 89 00 05 	brgt	800080c4 <_vfprintf_r+0xac4>
800080be:	ed b5 00 00 	bld	r5,0x0
800080c2:	c3 51       	brne	8000812c <_vfprintf_r+0xb2c>
800080c4:	2f f2       	sub	r2,-1
800080c6:	c3 38       	rjmp	8000812c <_vfprintf_r+0xb2c>
800080c8:	e0 40 00 66 	cp.w	r0,102
800080cc:	c1 c1       	brne	80008104 <_vfprintf_r+0xb04>
800080ce:	fa f2 06 ac 	ld.w	r2,sp[1708]
800080d2:	58 02       	cp.w	r2,0
800080d4:	e0 8a 00 0c 	brle	800080ec <_vfprintf_r+0xaec>
800080d8:	40 2a       	lddsp	r10,sp[0x8]
800080da:	58 0a       	cp.w	r10,0
800080dc:	c0 41       	brne	800080e4 <_vfprintf_r+0xae4>
800080de:	ed b5 00 00 	bld	r5,0x0
800080e2:	c2 51       	brne	8000812c <_vfprintf_r+0xb2c>
800080e4:	2f f2       	sub	r2,-1
800080e6:	40 29       	lddsp	r9,sp[0x8]
800080e8:	12 02       	add	r2,r9
800080ea:	c0 b8       	rjmp	80008100 <_vfprintf_r+0xb00>
800080ec:	40 28       	lddsp	r8,sp[0x8]
800080ee:	58 08       	cp.w	r8,0
800080f0:	c0 61       	brne	800080fc <_vfprintf_r+0xafc>
800080f2:	ed b5 00 00 	bld	r5,0x0
800080f6:	c0 30       	breq	800080fc <_vfprintf_r+0xafc>
800080f8:	30 12       	mov	r2,1
800080fa:	c1 98       	rjmp	8000812c <_vfprintf_r+0xb2c>
800080fc:	40 22       	lddsp	r2,sp[0x8]
800080fe:	2f e2       	sub	r2,-2
80008100:	36 60       	mov	r0,102
80008102:	c1 58       	rjmp	8000812c <_vfprintf_r+0xb2c>
80008104:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008108:	40 6e       	lddsp	lr,sp[0x18]
8000810a:	1c 32       	cp.w	r2,lr
8000810c:	c0 65       	brlt	80008118 <_vfprintf_r+0xb18>
8000810e:	ed b5 00 00 	bld	r5,0x0
80008112:	f7 b2 00 ff 	subeq	r2,-1
80008116:	c0 a8       	rjmp	8000812a <_vfprintf_r+0xb2a>
80008118:	e4 08 11 02 	rsub	r8,r2,2
8000811c:	40 6c       	lddsp	r12,sp[0x18]
8000811e:	58 02       	cp.w	r2,0
80008120:	f0 02 17 a0 	movle	r2,r8
80008124:	f9 b2 09 01 	movgt	r2,1
80008128:	18 02       	add	r2,r12
8000812a:	36 70       	mov	r0,103
8000812c:	40 9b       	lddsp	r11,sp[0x24]
8000812e:	58 0b       	cp.w	r11,0
80008130:	e0 80 05 94 	breq	80008c58 <_vfprintf_r+0x1658>
80008134:	32 d8       	mov	r8,45
80008136:	fb 68 06 bb 	st.b	sp[1723],r8
8000813a:	e0 8f 05 93 	bral	80008c60 <_vfprintf_r+0x1660>
8000813e:	50 a7       	stdsp	sp[0x28],r7
80008140:	04 94       	mov	r4,r2
80008142:	0c 97       	mov	r7,r6
80008144:	02 92       	mov	r2,r1
80008146:	06 96       	mov	r6,r3
80008148:	40 41       	lddsp	r1,sp[0x10]
8000814a:	40 93       	lddsp	r3,sp[0x24]
8000814c:	0e 99       	mov	r9,r7
8000814e:	ed b5 00 05 	bld	r5,0x5
80008152:	c4 81       	brne	800081e2 <_vfprintf_r+0xbe2>
80008154:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008158:	40 3e       	lddsp	lr,sp[0xc]
8000815a:	58 0e       	cp.w	lr,0
8000815c:	c1 d0       	breq	80008196 <_vfprintf_r+0xb96>
8000815e:	10 36       	cp.w	r6,r8
80008160:	c0 64       	brge	8000816c <_vfprintf_r+0xb6c>
80008162:	fa cc f9 44 	sub	r12,sp,-1724
80008166:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000816a:	c1 d8       	rjmp	800081a4 <_vfprintf_r+0xba4>
8000816c:	fa c8 f9 50 	sub	r8,sp,-1712
80008170:	1a d8       	st.w	--sp,r8
80008172:	fa c8 fa b8 	sub	r8,sp,-1352
80008176:	04 9a       	mov	r10,r2
80008178:	1a d8       	st.w	--sp,r8
8000817a:	fa c8 fb b4 	sub	r8,sp,-1100
8000817e:	0c 9b       	mov	r11,r6
80008180:	1a d8       	st.w	--sp,r8
80008182:	08 9c       	mov	r12,r4
80008184:	fa c8 f9 40 	sub	r8,sp,-1728
80008188:	fa c9 ff b4 	sub	r9,sp,-76
8000818c:	fe b0 f8 a2 	rcall	800072d0 <get_arg>
80008190:	2f dd       	sub	sp,-12
80008192:	78 0a       	ld.w	r10,r12[0x0]
80008194:	c2 08       	rjmp	800081d4 <_vfprintf_r+0xbd4>
80008196:	2f f7       	sub	r7,-1
80008198:	10 39       	cp.w	r9,r8
8000819a:	c0 84       	brge	800081aa <_vfprintf_r+0xbaa>
8000819c:	fa cb f9 44 	sub	r11,sp,-1724
800081a0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081a4:	ec fa fd 88 	ld.w	r10,r6[-632]
800081a8:	c1 68       	rjmp	800081d4 <_vfprintf_r+0xbd4>
800081aa:	41 09       	lddsp	r9,sp[0x40]
800081ac:	59 f8       	cp.w	r8,31
800081ae:	e0 89 00 10 	brgt	800081ce <_vfprintf_r+0xbce>
800081b2:	f2 ca ff fc 	sub	r10,r9,-4
800081b6:	51 0a       	stdsp	sp[0x40],r10
800081b8:	fa c6 f9 44 	sub	r6,sp,-1724
800081bc:	72 0a       	ld.w	r10,r9[0x0]
800081be:	ec 08 00 39 	add	r9,r6,r8<<0x3
800081c2:	f3 4a fd 88 	st.w	r9[-632],r10
800081c6:	2f f8       	sub	r8,-1
800081c8:	fb 48 06 b4 	st.w	sp[1716],r8
800081cc:	c0 48       	rjmp	800081d4 <_vfprintf_r+0xbd4>
800081ce:	72 0a       	ld.w	r10,r9[0x0]
800081d0:	2f c9       	sub	r9,-4
800081d2:	51 09       	stdsp	sp[0x40],r9
800081d4:	40 be       	lddsp	lr,sp[0x2c]
800081d6:	1c 98       	mov	r8,lr
800081d8:	95 1e       	st.w	r10[0x4],lr
800081da:	bf 58       	asr	r8,0x1f
800081dc:	95 08       	st.w	r10[0x0],r8
800081de:	fe 9f fa 9f 	bral	8000771c <_vfprintf_r+0x11c>
800081e2:	ed b5 00 04 	bld	r5,0x4
800081e6:	c4 80       	breq	80008276 <_vfprintf_r+0xc76>
800081e8:	e2 15 00 40 	andl	r5,0x40,COH
800081ec:	c4 50       	breq	80008276 <_vfprintf_r+0xc76>
800081ee:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081f2:	40 3c       	lddsp	r12,sp[0xc]
800081f4:	58 0c       	cp.w	r12,0
800081f6:	c1 d0       	breq	80008230 <_vfprintf_r+0xc30>
800081f8:	10 36       	cp.w	r6,r8
800081fa:	c0 64       	brge	80008206 <_vfprintf_r+0xc06>
800081fc:	fa cb f9 44 	sub	r11,sp,-1724
80008200:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008204:	c1 d8       	rjmp	8000823e <_vfprintf_r+0xc3e>
80008206:	fa c8 f9 50 	sub	r8,sp,-1712
8000820a:	1a d8       	st.w	--sp,r8
8000820c:	fa c8 fa b8 	sub	r8,sp,-1352
80008210:	04 9a       	mov	r10,r2
80008212:	1a d8       	st.w	--sp,r8
80008214:	fa c8 fb b4 	sub	r8,sp,-1100
80008218:	0c 9b       	mov	r11,r6
8000821a:	1a d8       	st.w	--sp,r8
8000821c:	08 9c       	mov	r12,r4
8000821e:	fa c8 f9 40 	sub	r8,sp,-1728
80008222:	fa c9 ff b4 	sub	r9,sp,-76
80008226:	fe b0 f8 55 	rcall	800072d0 <get_arg>
8000822a:	2f dd       	sub	sp,-12
8000822c:	78 0a       	ld.w	r10,r12[0x0]
8000822e:	c2 08       	rjmp	8000826e <_vfprintf_r+0xc6e>
80008230:	2f f7       	sub	r7,-1
80008232:	10 39       	cp.w	r9,r8
80008234:	c0 84       	brge	80008244 <_vfprintf_r+0xc44>
80008236:	fa ca f9 44 	sub	r10,sp,-1724
8000823a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000823e:	ec fa fd 88 	ld.w	r10,r6[-632]
80008242:	c1 68       	rjmp	8000826e <_vfprintf_r+0xc6e>
80008244:	41 09       	lddsp	r9,sp[0x40]
80008246:	59 f8       	cp.w	r8,31
80008248:	e0 89 00 10 	brgt	80008268 <_vfprintf_r+0xc68>
8000824c:	f2 ca ff fc 	sub	r10,r9,-4
80008250:	51 0a       	stdsp	sp[0x40],r10
80008252:	fa c6 f9 44 	sub	r6,sp,-1724
80008256:	72 0a       	ld.w	r10,r9[0x0]
80008258:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000825c:	f3 4a fd 88 	st.w	r9[-632],r10
80008260:	2f f8       	sub	r8,-1
80008262:	fb 48 06 b4 	st.w	sp[1716],r8
80008266:	c0 48       	rjmp	8000826e <_vfprintf_r+0xc6e>
80008268:	72 0a       	ld.w	r10,r9[0x0]
8000826a:	2f c9       	sub	r9,-4
8000826c:	51 09       	stdsp	sp[0x40],r9
8000826e:	40 be       	lddsp	lr,sp[0x2c]
80008270:	b4 0e       	st.h	r10[0x0],lr
80008272:	fe 9f fa 55 	bral	8000771c <_vfprintf_r+0x11c>
80008276:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000827a:	40 3c       	lddsp	r12,sp[0xc]
8000827c:	58 0c       	cp.w	r12,0
8000827e:	c1 d0       	breq	800082b8 <_vfprintf_r+0xcb8>
80008280:	10 36       	cp.w	r6,r8
80008282:	c0 64       	brge	8000828e <_vfprintf_r+0xc8e>
80008284:	fa cb f9 44 	sub	r11,sp,-1724
80008288:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000828c:	c1 d8       	rjmp	800082c6 <_vfprintf_r+0xcc6>
8000828e:	fa c8 f9 50 	sub	r8,sp,-1712
80008292:	1a d8       	st.w	--sp,r8
80008294:	fa c8 fa b8 	sub	r8,sp,-1352
80008298:	04 9a       	mov	r10,r2
8000829a:	1a d8       	st.w	--sp,r8
8000829c:	fa c8 fb b4 	sub	r8,sp,-1100
800082a0:	0c 9b       	mov	r11,r6
800082a2:	1a d8       	st.w	--sp,r8
800082a4:	08 9c       	mov	r12,r4
800082a6:	fa c8 f9 40 	sub	r8,sp,-1728
800082aa:	fa c9 ff b4 	sub	r9,sp,-76
800082ae:	fe b0 f8 11 	rcall	800072d0 <get_arg>
800082b2:	2f dd       	sub	sp,-12
800082b4:	78 0a       	ld.w	r10,r12[0x0]
800082b6:	c2 08       	rjmp	800082f6 <_vfprintf_r+0xcf6>
800082b8:	2f f7       	sub	r7,-1
800082ba:	10 39       	cp.w	r9,r8
800082bc:	c0 84       	brge	800082cc <_vfprintf_r+0xccc>
800082be:	fa ca f9 44 	sub	r10,sp,-1724
800082c2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800082c6:	ec fa fd 88 	ld.w	r10,r6[-632]
800082ca:	c1 68       	rjmp	800082f6 <_vfprintf_r+0xcf6>
800082cc:	41 09       	lddsp	r9,sp[0x40]
800082ce:	59 f8       	cp.w	r8,31
800082d0:	e0 89 00 10 	brgt	800082f0 <_vfprintf_r+0xcf0>
800082d4:	f2 ca ff fc 	sub	r10,r9,-4
800082d8:	51 0a       	stdsp	sp[0x40],r10
800082da:	fa c6 f9 44 	sub	r6,sp,-1724
800082de:	72 0a       	ld.w	r10,r9[0x0]
800082e0:	ec 08 00 39 	add	r9,r6,r8<<0x3
800082e4:	f3 4a fd 88 	st.w	r9[-632],r10
800082e8:	2f f8       	sub	r8,-1
800082ea:	fb 48 06 b4 	st.w	sp[1716],r8
800082ee:	c0 48       	rjmp	800082f6 <_vfprintf_r+0xcf6>
800082f0:	72 0a       	ld.w	r10,r9[0x0]
800082f2:	2f c9       	sub	r9,-4
800082f4:	51 09       	stdsp	sp[0x40],r9
800082f6:	40 be       	lddsp	lr,sp[0x2c]
800082f8:	95 0e       	st.w	r10[0x0],lr
800082fa:	fe 9f fa 11 	bral	8000771c <_vfprintf_r+0x11c>
800082fe:	50 a7       	stdsp	sp[0x28],r7
80008300:	50 80       	stdsp	sp[0x20],r0
80008302:	0c 97       	mov	r7,r6
80008304:	04 94       	mov	r4,r2
80008306:	06 96       	mov	r6,r3
80008308:	02 92       	mov	r2,r1
8000830a:	40 93       	lddsp	r3,sp[0x24]
8000830c:	10 90       	mov	r0,r8
8000830e:	40 41       	lddsp	r1,sp[0x10]
80008310:	a5 a5       	sbr	r5,0x4
80008312:	c0 a8       	rjmp	80008326 <_vfprintf_r+0xd26>
80008314:	50 a7       	stdsp	sp[0x28],r7
80008316:	50 80       	stdsp	sp[0x20],r0
80008318:	0c 97       	mov	r7,r6
8000831a:	04 94       	mov	r4,r2
8000831c:	06 96       	mov	r6,r3
8000831e:	02 92       	mov	r2,r1
80008320:	40 93       	lddsp	r3,sp[0x24]
80008322:	10 90       	mov	r0,r8
80008324:	40 41       	lddsp	r1,sp[0x10]
80008326:	ed b5 00 05 	bld	r5,0x5
8000832a:	c5 d1       	brne	800083e4 <_vfprintf_r+0xde4>
8000832c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008330:	40 3c       	lddsp	r12,sp[0xc]
80008332:	58 0c       	cp.w	r12,0
80008334:	c2 60       	breq	80008380 <_vfprintf_r+0xd80>
80008336:	10 36       	cp.w	r6,r8
80008338:	c0 a4       	brge	8000834c <_vfprintf_r+0xd4c>
8000833a:	fa cb f9 44 	sub	r11,sp,-1724
8000833e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008342:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008346:	fa e9 00 00 	st.d	sp[0],r8
8000834a:	c1 88       	rjmp	8000837a <_vfprintf_r+0xd7a>
8000834c:	fa c8 f9 50 	sub	r8,sp,-1712
80008350:	1a d8       	st.w	--sp,r8
80008352:	fa c8 fa b8 	sub	r8,sp,-1352
80008356:	04 9a       	mov	r10,r2
80008358:	1a d8       	st.w	--sp,r8
8000835a:	0c 9b       	mov	r11,r6
8000835c:	fa c8 fb b4 	sub	r8,sp,-1100
80008360:	08 9c       	mov	r12,r4
80008362:	1a d8       	st.w	--sp,r8
80008364:	fa c8 f9 40 	sub	r8,sp,-1728
80008368:	fa c9 ff b4 	sub	r9,sp,-76
8000836c:	fe b0 f7 b2 	rcall	800072d0 <get_arg>
80008370:	2f dd       	sub	sp,-12
80008372:	f8 ea 00 00 	ld.d	r10,r12[0]
80008376:	fa eb 00 00 	st.d	sp[0],r10
8000837a:	30 08       	mov	r8,0
8000837c:	e0 8f 03 de 	bral	80008b38 <_vfprintf_r+0x1538>
80008380:	ee ca ff ff 	sub	r10,r7,-1
80008384:	10 37       	cp.w	r7,r8
80008386:	c0 b4       	brge	8000839c <_vfprintf_r+0xd9c>
80008388:	fa c9 f9 44 	sub	r9,sp,-1724
8000838c:	14 97       	mov	r7,r10
8000838e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008392:	ec ea fd 88 	ld.d	r10,r6[-632]
80008396:	fa eb 00 00 	st.d	sp[0],r10
8000839a:	c1 88       	rjmp	800083ca <_vfprintf_r+0xdca>
8000839c:	41 09       	lddsp	r9,sp[0x40]
8000839e:	59 f8       	cp.w	r8,31
800083a0:	e0 89 00 18 	brgt	800083d0 <_vfprintf_r+0xdd0>
800083a4:	f2 e6 00 00 	ld.d	r6,r9[0]
800083a8:	f2 cb ff f8 	sub	r11,r9,-8
800083ac:	fa e7 00 00 	st.d	sp[0],r6
800083b0:	51 0b       	stdsp	sp[0x40],r11
800083b2:	fa c6 f9 44 	sub	r6,sp,-1724
800083b6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800083ba:	fa e6 00 00 	ld.d	r6,sp[0]
800083be:	f2 e7 fd 88 	st.d	r9[-632],r6
800083c2:	2f f8       	sub	r8,-1
800083c4:	14 97       	mov	r7,r10
800083c6:	fb 48 06 b4 	st.w	sp[1716],r8
800083ca:	40 38       	lddsp	r8,sp[0xc]
800083cc:	e0 8f 03 b6 	bral	80008b38 <_vfprintf_r+0x1538>
800083d0:	f2 e6 00 00 	ld.d	r6,r9[0]
800083d4:	40 38       	lddsp	r8,sp[0xc]
800083d6:	fa e7 00 00 	st.d	sp[0],r6
800083da:	2f 89       	sub	r9,-8
800083dc:	14 97       	mov	r7,r10
800083de:	51 09       	stdsp	sp[0x40],r9
800083e0:	e0 8f 03 ac 	bral	80008b38 <_vfprintf_r+0x1538>
800083e4:	ed b5 00 04 	bld	r5,0x4
800083e8:	c1 61       	brne	80008414 <_vfprintf_r+0xe14>
800083ea:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083ee:	40 3e       	lddsp	lr,sp[0xc]
800083f0:	58 0e       	cp.w	lr,0
800083f2:	c0 80       	breq	80008402 <_vfprintf_r+0xe02>
800083f4:	10 36       	cp.w	r6,r8
800083f6:	c6 74       	brge	800084c4 <_vfprintf_r+0xec4>
800083f8:	fa cc f9 44 	sub	r12,sp,-1724
800083fc:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008400:	c8 08       	rjmp	80008500 <_vfprintf_r+0xf00>
80008402:	ee ca ff ff 	sub	r10,r7,-1
80008406:	10 37       	cp.w	r7,r8
80008408:	c7 f4       	brge	80008506 <_vfprintf_r+0xf06>
8000840a:	fa cb f9 44 	sub	r11,sp,-1724
8000840e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008412:	c7 68       	rjmp	800084fe <_vfprintf_r+0xefe>
80008414:	ed b5 00 06 	bld	r5,0x6
80008418:	c4 a1       	brne	800084ac <_vfprintf_r+0xeac>
8000841a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000841e:	40 3c       	lddsp	r12,sp[0xc]
80008420:	58 0c       	cp.w	r12,0
80008422:	c1 d0       	breq	8000845c <_vfprintf_r+0xe5c>
80008424:	10 36       	cp.w	r6,r8
80008426:	c0 64       	brge	80008432 <_vfprintf_r+0xe32>
80008428:	fa cb f9 44 	sub	r11,sp,-1724
8000842c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008430:	c1 f8       	rjmp	8000846e <_vfprintf_r+0xe6e>
80008432:	fa c8 f9 50 	sub	r8,sp,-1712
80008436:	1a d8       	st.w	--sp,r8
80008438:	fa c8 fa b8 	sub	r8,sp,-1352
8000843c:	1a d8       	st.w	--sp,r8
8000843e:	fa c8 fb b4 	sub	r8,sp,-1100
80008442:	1a d8       	st.w	--sp,r8
80008444:	fa c8 f9 40 	sub	r8,sp,-1728
80008448:	fa c9 ff b4 	sub	r9,sp,-76
8000844c:	04 9a       	mov	r10,r2
8000844e:	0c 9b       	mov	r11,r6
80008450:	08 9c       	mov	r12,r4
80008452:	fe b0 f7 3f 	rcall	800072d0 <get_arg>
80008456:	2f dd       	sub	sp,-12
80008458:	98 18       	ld.sh	r8,r12[0x2]
8000845a:	c2 68       	rjmp	800084a6 <_vfprintf_r+0xea6>
8000845c:	ee ca ff ff 	sub	r10,r7,-1
80008460:	10 37       	cp.w	r7,r8
80008462:	c0 94       	brge	80008474 <_vfprintf_r+0xe74>
80008464:	fa c9 f9 44 	sub	r9,sp,-1724
80008468:	14 97       	mov	r7,r10
8000846a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000846e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008472:	c1 a8       	rjmp	800084a6 <_vfprintf_r+0xea6>
80008474:	41 09       	lddsp	r9,sp[0x40]
80008476:	59 f8       	cp.w	r8,31
80008478:	e0 89 00 13 	brgt	8000849e <_vfprintf_r+0xe9e>
8000847c:	f2 cb ff fc 	sub	r11,r9,-4
80008480:	51 0b       	stdsp	sp[0x40],r11
80008482:	72 09       	ld.w	r9,r9[0x0]
80008484:	fa c6 f9 44 	sub	r6,sp,-1724
80008488:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000848c:	2f f8       	sub	r8,-1
8000848e:	f7 49 fd 88 	st.w	r11[-632],r9
80008492:	fb 48 06 b4 	st.w	sp[1716],r8
80008496:	14 97       	mov	r7,r10
80008498:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000849c:	c0 58       	rjmp	800084a6 <_vfprintf_r+0xea6>
8000849e:	92 18       	ld.sh	r8,r9[0x2]
800084a0:	14 97       	mov	r7,r10
800084a2:	2f c9       	sub	r9,-4
800084a4:	51 09       	stdsp	sp[0x40],r9
800084a6:	5c 78       	castu.h	r8
800084a8:	50 18       	stdsp	sp[0x4],r8
800084aa:	c4 68       	rjmp	80008536 <_vfprintf_r+0xf36>
800084ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084b0:	40 3c       	lddsp	r12,sp[0xc]
800084b2:	58 0c       	cp.w	r12,0
800084b4:	c1 d0       	breq	800084ee <_vfprintf_r+0xeee>
800084b6:	10 36       	cp.w	r6,r8
800084b8:	c0 64       	brge	800084c4 <_vfprintf_r+0xec4>
800084ba:	fa cb f9 44 	sub	r11,sp,-1724
800084be:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084c2:	c1 f8       	rjmp	80008500 <_vfprintf_r+0xf00>
800084c4:	fa c8 f9 50 	sub	r8,sp,-1712
800084c8:	1a d8       	st.w	--sp,r8
800084ca:	fa c8 fa b8 	sub	r8,sp,-1352
800084ce:	0c 9b       	mov	r11,r6
800084d0:	1a d8       	st.w	--sp,r8
800084d2:	fa c8 fb b4 	sub	r8,sp,-1100
800084d6:	04 9a       	mov	r10,r2
800084d8:	1a d8       	st.w	--sp,r8
800084da:	08 9c       	mov	r12,r4
800084dc:	fa c8 f9 40 	sub	r8,sp,-1728
800084e0:	fa c9 ff b4 	sub	r9,sp,-76
800084e4:	fe b0 f6 f6 	rcall	800072d0 <get_arg>
800084e8:	2f dd       	sub	sp,-12
800084ea:	78 0b       	ld.w	r11,r12[0x0]
800084ec:	c2 48       	rjmp	80008534 <_vfprintf_r+0xf34>
800084ee:	ee ca ff ff 	sub	r10,r7,-1
800084f2:	10 37       	cp.w	r7,r8
800084f4:	c0 94       	brge	80008506 <_vfprintf_r+0xf06>
800084f6:	fa c9 f9 44 	sub	r9,sp,-1724
800084fa:	f2 06 00 36 	add	r6,r9,r6<<0x3
800084fe:	14 97       	mov	r7,r10
80008500:	ec fb fd 88 	ld.w	r11,r6[-632]
80008504:	c1 88       	rjmp	80008534 <_vfprintf_r+0xf34>
80008506:	41 09       	lddsp	r9,sp[0x40]
80008508:	59 f8       	cp.w	r8,31
8000850a:	e0 89 00 11 	brgt	8000852c <_vfprintf_r+0xf2c>
8000850e:	f2 cb ff fc 	sub	r11,r9,-4
80008512:	51 0b       	stdsp	sp[0x40],r11
80008514:	fa c6 f9 44 	sub	r6,sp,-1724
80008518:	72 0b       	ld.w	r11,r9[0x0]
8000851a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000851e:	f3 4b fd 88 	st.w	r9[-632],r11
80008522:	2f f8       	sub	r8,-1
80008524:	14 97       	mov	r7,r10
80008526:	fb 48 06 b4 	st.w	sp[1716],r8
8000852a:	c0 58       	rjmp	80008534 <_vfprintf_r+0xf34>
8000852c:	72 0b       	ld.w	r11,r9[0x0]
8000852e:	14 97       	mov	r7,r10
80008530:	2f c9       	sub	r9,-4
80008532:	51 09       	stdsp	sp[0x40],r9
80008534:	50 1b       	stdsp	sp[0x4],r11
80008536:	30 0e       	mov	lr,0
80008538:	50 0e       	stdsp	sp[0x0],lr
8000853a:	1c 98       	mov	r8,lr
8000853c:	e0 8f 02 fe 	bral	80008b38 <_vfprintf_r+0x1538>
80008540:	50 a7       	stdsp	sp[0x28],r7
80008542:	50 80       	stdsp	sp[0x20],r0
80008544:	0c 97       	mov	r7,r6
80008546:	04 94       	mov	r4,r2
80008548:	06 96       	mov	r6,r3
8000854a:	02 92       	mov	r2,r1
8000854c:	40 93       	lddsp	r3,sp[0x24]
8000854e:	40 41       	lddsp	r1,sp[0x10]
80008550:	0e 99       	mov	r9,r7
80008552:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008556:	40 3c       	lddsp	r12,sp[0xc]
80008558:	58 0c       	cp.w	r12,0
8000855a:	c1 d0       	breq	80008594 <_vfprintf_r+0xf94>
8000855c:	10 36       	cp.w	r6,r8
8000855e:	c0 64       	brge	8000856a <_vfprintf_r+0xf6a>
80008560:	fa cb f9 44 	sub	r11,sp,-1724
80008564:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008568:	c1 d8       	rjmp	800085a2 <_vfprintf_r+0xfa2>
8000856a:	fa c8 f9 50 	sub	r8,sp,-1712
8000856e:	1a d8       	st.w	--sp,r8
80008570:	fa c8 fa b8 	sub	r8,sp,-1352
80008574:	1a d8       	st.w	--sp,r8
80008576:	fa c8 fb b4 	sub	r8,sp,-1100
8000857a:	1a d8       	st.w	--sp,r8
8000857c:	fa c9 ff b4 	sub	r9,sp,-76
80008580:	fa c8 f9 40 	sub	r8,sp,-1728
80008584:	04 9a       	mov	r10,r2
80008586:	0c 9b       	mov	r11,r6
80008588:	08 9c       	mov	r12,r4
8000858a:	fe b0 f6 a3 	rcall	800072d0 <get_arg>
8000858e:	2f dd       	sub	sp,-12
80008590:	78 09       	ld.w	r9,r12[0x0]
80008592:	c2 18       	rjmp	800085d4 <_vfprintf_r+0xfd4>
80008594:	2f f7       	sub	r7,-1
80008596:	10 39       	cp.w	r9,r8
80008598:	c0 84       	brge	800085a8 <_vfprintf_r+0xfa8>
8000859a:	fa ca f9 44 	sub	r10,sp,-1724
8000859e:	f4 06 00 36 	add	r6,r10,r6<<0x3
800085a2:	ec f9 fd 88 	ld.w	r9,r6[-632]
800085a6:	c1 78       	rjmp	800085d4 <_vfprintf_r+0xfd4>
800085a8:	41 09       	lddsp	r9,sp[0x40]
800085aa:	59 f8       	cp.w	r8,31
800085ac:	e0 89 00 10 	brgt	800085cc <_vfprintf_r+0xfcc>
800085b0:	f2 ca ff fc 	sub	r10,r9,-4
800085b4:	51 0a       	stdsp	sp[0x40],r10
800085b6:	fa c6 f9 44 	sub	r6,sp,-1724
800085ba:	72 09       	ld.w	r9,r9[0x0]
800085bc:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800085c0:	f5 49 fd 88 	st.w	r10[-632],r9
800085c4:	2f f8       	sub	r8,-1
800085c6:	fb 48 06 b4 	st.w	sp[1716],r8
800085ca:	c0 58       	rjmp	800085d4 <_vfprintf_r+0xfd4>
800085cc:	f2 c8 ff fc 	sub	r8,r9,-4
800085d0:	51 08       	stdsp	sp[0x40],r8
800085d2:	72 09       	ld.w	r9,r9[0x0]
800085d4:	33 08       	mov	r8,48
800085d6:	fb 68 06 b8 	st.b	sp[1720],r8
800085da:	37 88       	mov	r8,120
800085dc:	30 0e       	mov	lr,0
800085de:	fb 68 06 b9 	st.b	sp[1721],r8
800085e2:	fe cc be 0e 	sub	r12,pc,-16882
800085e6:	50 19       	stdsp	sp[0x4],r9
800085e8:	a1 b5       	sbr	r5,0x1
800085ea:	50 0e       	stdsp	sp[0x0],lr
800085ec:	50 dc       	stdsp	sp[0x34],r12
800085ee:	30 28       	mov	r8,2
800085f0:	37 80       	mov	r0,120
800085f2:	e0 8f 02 a3 	bral	80008b38 <_vfprintf_r+0x1538>
800085f6:	50 a7       	stdsp	sp[0x28],r7
800085f8:	50 80       	stdsp	sp[0x20],r0
800085fa:	10 90       	mov	r0,r8
800085fc:	30 08       	mov	r8,0
800085fe:	fb 68 06 bb 	st.b	sp[1723],r8
80008602:	0c 97       	mov	r7,r6
80008604:	04 94       	mov	r4,r2
80008606:	06 96       	mov	r6,r3
80008608:	02 92       	mov	r2,r1
8000860a:	40 93       	lddsp	r3,sp[0x24]
8000860c:	40 41       	lddsp	r1,sp[0x10]
8000860e:	0e 99       	mov	r9,r7
80008610:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008614:	40 3b       	lddsp	r11,sp[0xc]
80008616:	58 0b       	cp.w	r11,0
80008618:	c1 d0       	breq	80008652 <_vfprintf_r+0x1052>
8000861a:	10 36       	cp.w	r6,r8
8000861c:	c0 64       	brge	80008628 <_vfprintf_r+0x1028>
8000861e:	fa ca f9 44 	sub	r10,sp,-1724
80008622:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008626:	c1 d8       	rjmp	80008660 <_vfprintf_r+0x1060>
80008628:	fa c8 f9 50 	sub	r8,sp,-1712
8000862c:	1a d8       	st.w	--sp,r8
8000862e:	fa c8 fa b8 	sub	r8,sp,-1352
80008632:	1a d8       	st.w	--sp,r8
80008634:	fa c8 fb b4 	sub	r8,sp,-1100
80008638:	0c 9b       	mov	r11,r6
8000863a:	1a d8       	st.w	--sp,r8
8000863c:	04 9a       	mov	r10,r2
8000863e:	fa c8 f9 40 	sub	r8,sp,-1728
80008642:	fa c9 ff b4 	sub	r9,sp,-76
80008646:	08 9c       	mov	r12,r4
80008648:	fe b0 f6 44 	rcall	800072d0 <get_arg>
8000864c:	2f dd       	sub	sp,-12
8000864e:	78 06       	ld.w	r6,r12[0x0]
80008650:	c2 08       	rjmp	80008690 <_vfprintf_r+0x1090>
80008652:	2f f7       	sub	r7,-1
80008654:	10 39       	cp.w	r9,r8
80008656:	c0 84       	brge	80008666 <_vfprintf_r+0x1066>
80008658:	fa c9 f9 44 	sub	r9,sp,-1724
8000865c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008660:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008664:	c1 68       	rjmp	80008690 <_vfprintf_r+0x1090>
80008666:	41 09       	lddsp	r9,sp[0x40]
80008668:	59 f8       	cp.w	r8,31
8000866a:	e0 89 00 10 	brgt	8000868a <_vfprintf_r+0x108a>
8000866e:	f2 ca ff fc 	sub	r10,r9,-4
80008672:	51 0a       	stdsp	sp[0x40],r10
80008674:	72 06       	ld.w	r6,r9[0x0]
80008676:	fa ce f9 44 	sub	lr,sp,-1724
8000867a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000867e:	f3 46 fd 88 	st.w	r9[-632],r6
80008682:	2f f8       	sub	r8,-1
80008684:	fb 48 06 b4 	st.w	sp[1716],r8
80008688:	c0 48       	rjmp	80008690 <_vfprintf_r+0x1090>
8000868a:	72 06       	ld.w	r6,r9[0x0]
8000868c:	2f c9       	sub	r9,-4
8000868e:	51 09       	stdsp	sp[0x40],r9
80008690:	40 2c       	lddsp	r12,sp[0x8]
80008692:	58 0c       	cp.w	r12,0
80008694:	c1 05       	brlt	800086b4 <_vfprintf_r+0x10b4>
80008696:	18 9a       	mov	r10,r12
80008698:	30 0b       	mov	r11,0
8000869a:	0c 9c       	mov	r12,r6
8000869c:	e0 a0 13 12 	rcall	8000acc0 <memchr>
800086a0:	e0 80 02 df 	breq	80008c5e <_vfprintf_r+0x165e>
800086a4:	f8 06 01 02 	sub	r2,r12,r6
800086a8:	40 2b       	lddsp	r11,sp[0x8]
800086aa:	16 32       	cp.w	r2,r11
800086ac:	e0 89 02 d9 	brgt	80008c5e <_vfprintf_r+0x165e>
800086b0:	e0 8f 02 d4 	bral	80008c58 <_vfprintf_r+0x1658>
800086b4:	30 0a       	mov	r10,0
800086b6:	0c 9c       	mov	r12,r6
800086b8:	50 2a       	stdsp	sp[0x8],r10
800086ba:	e0 a0 16 73 	rcall	8000b3a0 <strlen>
800086be:	18 92       	mov	r2,r12
800086c0:	e0 8f 02 d2 	bral	80008c64 <_vfprintf_r+0x1664>
800086c4:	50 a7       	stdsp	sp[0x28],r7
800086c6:	50 80       	stdsp	sp[0x20],r0
800086c8:	0c 97       	mov	r7,r6
800086ca:	04 94       	mov	r4,r2
800086cc:	06 96       	mov	r6,r3
800086ce:	02 92       	mov	r2,r1
800086d0:	40 93       	lddsp	r3,sp[0x24]
800086d2:	10 90       	mov	r0,r8
800086d4:	40 41       	lddsp	r1,sp[0x10]
800086d6:	a5 a5       	sbr	r5,0x4
800086d8:	c0 a8       	rjmp	800086ec <_vfprintf_r+0x10ec>
800086da:	50 a7       	stdsp	sp[0x28],r7
800086dc:	50 80       	stdsp	sp[0x20],r0
800086de:	0c 97       	mov	r7,r6
800086e0:	04 94       	mov	r4,r2
800086e2:	06 96       	mov	r6,r3
800086e4:	02 92       	mov	r2,r1
800086e6:	40 93       	lddsp	r3,sp[0x24]
800086e8:	10 90       	mov	r0,r8
800086ea:	40 41       	lddsp	r1,sp[0x10]
800086ec:	ed b5 00 05 	bld	r5,0x5
800086f0:	c5 61       	brne	8000879c <_vfprintf_r+0x119c>
800086f2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086f6:	40 39       	lddsp	r9,sp[0xc]
800086f8:	58 09       	cp.w	r9,0
800086fa:	c2 10       	breq	8000873c <_vfprintf_r+0x113c>
800086fc:	10 36       	cp.w	r6,r8
800086fe:	c0 74       	brge	8000870c <_vfprintf_r+0x110c>
80008700:	fa c8 f9 44 	sub	r8,sp,-1724
80008704:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008708:	c2 38       	rjmp	8000874e <_vfprintf_r+0x114e>
8000870a:	d7 03       	nop
8000870c:	fa c8 f9 50 	sub	r8,sp,-1712
80008710:	1a d8       	st.w	--sp,r8
80008712:	fa c8 fa b8 	sub	r8,sp,-1352
80008716:	1a d8       	st.w	--sp,r8
80008718:	fa c8 fb b4 	sub	r8,sp,-1100
8000871c:	1a d8       	st.w	--sp,r8
8000871e:	fa c8 f9 40 	sub	r8,sp,-1728
80008722:	fa c9 ff b4 	sub	r9,sp,-76
80008726:	04 9a       	mov	r10,r2
80008728:	0c 9b       	mov	r11,r6
8000872a:	08 9c       	mov	r12,r4
8000872c:	fe b0 f5 d2 	rcall	800072d0 <get_arg>
80008730:	2f dd       	sub	sp,-12
80008732:	f8 e8 00 00 	ld.d	r8,r12[0]
80008736:	fa e9 00 00 	st.d	sp[0],r8
8000873a:	c2 e8       	rjmp	80008796 <_vfprintf_r+0x1196>
8000873c:	ee ca ff ff 	sub	r10,r7,-1
80008740:	10 37       	cp.w	r7,r8
80008742:	c0 b4       	brge	80008758 <_vfprintf_r+0x1158>
80008744:	fa c8 f9 44 	sub	r8,sp,-1724
80008748:	14 97       	mov	r7,r10
8000874a:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000874e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008752:	fa eb 00 00 	st.d	sp[0],r10
80008756:	c2 08       	rjmp	80008796 <_vfprintf_r+0x1196>
80008758:	41 09       	lddsp	r9,sp[0x40]
8000875a:	59 f8       	cp.w	r8,31
8000875c:	e0 89 00 16 	brgt	80008788 <_vfprintf_r+0x1188>
80008760:	f2 e6 00 00 	ld.d	r6,r9[0]
80008764:	f2 cb ff f8 	sub	r11,r9,-8
80008768:	fa e7 00 00 	st.d	sp[0],r6
8000876c:	51 0b       	stdsp	sp[0x40],r11
8000876e:	fa c6 f9 44 	sub	r6,sp,-1724
80008772:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008776:	fa e6 00 00 	ld.d	r6,sp[0]
8000877a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000877e:	2f f8       	sub	r8,-1
80008780:	14 97       	mov	r7,r10
80008782:	fb 48 06 b4 	st.w	sp[1716],r8
80008786:	c0 88       	rjmp	80008796 <_vfprintf_r+0x1196>
80008788:	f2 e6 00 00 	ld.d	r6,r9[0]
8000878c:	2f 89       	sub	r9,-8
8000878e:	fa e7 00 00 	st.d	sp[0],r6
80008792:	51 09       	stdsp	sp[0x40],r9
80008794:	14 97       	mov	r7,r10
80008796:	30 18       	mov	r8,1
80008798:	e0 8f 01 d0 	bral	80008b38 <_vfprintf_r+0x1538>
8000879c:	ed b5 00 04 	bld	r5,0x4
800087a0:	c1 61       	brne	800087cc <_vfprintf_r+0x11cc>
800087a2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087a6:	40 3e       	lddsp	lr,sp[0xc]
800087a8:	58 0e       	cp.w	lr,0
800087aa:	c0 80       	breq	800087ba <_vfprintf_r+0x11ba>
800087ac:	10 36       	cp.w	r6,r8
800087ae:	c6 74       	brge	8000887c <_vfprintf_r+0x127c>
800087b0:	fa cc f9 44 	sub	r12,sp,-1724
800087b4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800087b8:	c8 08       	rjmp	800088b8 <_vfprintf_r+0x12b8>
800087ba:	ee ca ff ff 	sub	r10,r7,-1
800087be:	10 37       	cp.w	r7,r8
800087c0:	c7 f4       	brge	800088be <_vfprintf_r+0x12be>
800087c2:	fa cb f9 44 	sub	r11,sp,-1724
800087c6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087ca:	c7 68       	rjmp	800088b6 <_vfprintf_r+0x12b6>
800087cc:	ed b5 00 06 	bld	r5,0x6
800087d0:	c4 a1       	brne	80008864 <_vfprintf_r+0x1264>
800087d2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087d6:	40 3c       	lddsp	r12,sp[0xc]
800087d8:	58 0c       	cp.w	r12,0
800087da:	c1 d0       	breq	80008814 <_vfprintf_r+0x1214>
800087dc:	10 36       	cp.w	r6,r8
800087de:	c0 64       	brge	800087ea <_vfprintf_r+0x11ea>
800087e0:	fa cb f9 44 	sub	r11,sp,-1724
800087e4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087e8:	c1 f8       	rjmp	80008826 <_vfprintf_r+0x1226>
800087ea:	fa c8 f9 50 	sub	r8,sp,-1712
800087ee:	1a d8       	st.w	--sp,r8
800087f0:	fa c8 fa b8 	sub	r8,sp,-1352
800087f4:	1a d8       	st.w	--sp,r8
800087f6:	fa c8 fb b4 	sub	r8,sp,-1100
800087fa:	1a d8       	st.w	--sp,r8
800087fc:	fa c8 f9 40 	sub	r8,sp,-1728
80008800:	fa c9 ff b4 	sub	r9,sp,-76
80008804:	04 9a       	mov	r10,r2
80008806:	0c 9b       	mov	r11,r6
80008808:	08 9c       	mov	r12,r4
8000880a:	fe b0 f5 63 	rcall	800072d0 <get_arg>
8000880e:	2f dd       	sub	sp,-12
80008810:	98 18       	ld.sh	r8,r12[0x2]
80008812:	c2 68       	rjmp	8000885e <_vfprintf_r+0x125e>
80008814:	ee ca ff ff 	sub	r10,r7,-1
80008818:	10 37       	cp.w	r7,r8
8000881a:	c0 94       	brge	8000882c <_vfprintf_r+0x122c>
8000881c:	fa c9 f9 44 	sub	r9,sp,-1724
80008820:	14 97       	mov	r7,r10
80008822:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008826:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000882a:	c1 a8       	rjmp	8000885e <_vfprintf_r+0x125e>
8000882c:	41 09       	lddsp	r9,sp[0x40]
8000882e:	59 f8       	cp.w	r8,31
80008830:	e0 89 00 13 	brgt	80008856 <_vfprintf_r+0x1256>
80008834:	f2 cb ff fc 	sub	r11,r9,-4
80008838:	51 0b       	stdsp	sp[0x40],r11
8000883a:	72 09       	ld.w	r9,r9[0x0]
8000883c:	fa c6 f9 44 	sub	r6,sp,-1724
80008840:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008844:	2f f8       	sub	r8,-1
80008846:	f7 49 fd 88 	st.w	r11[-632],r9
8000884a:	fb 48 06 b4 	st.w	sp[1716],r8
8000884e:	14 97       	mov	r7,r10
80008850:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008854:	c0 58       	rjmp	8000885e <_vfprintf_r+0x125e>
80008856:	92 18       	ld.sh	r8,r9[0x2]
80008858:	14 97       	mov	r7,r10
8000885a:	2f c9       	sub	r9,-4
8000885c:	51 09       	stdsp	sp[0x40],r9
8000885e:	5c 78       	castu.h	r8
80008860:	50 18       	stdsp	sp[0x4],r8
80008862:	c4 68       	rjmp	800088ee <_vfprintf_r+0x12ee>
80008864:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008868:	40 3c       	lddsp	r12,sp[0xc]
8000886a:	58 0c       	cp.w	r12,0
8000886c:	c1 d0       	breq	800088a6 <_vfprintf_r+0x12a6>
8000886e:	10 36       	cp.w	r6,r8
80008870:	c0 64       	brge	8000887c <_vfprintf_r+0x127c>
80008872:	fa cb f9 44 	sub	r11,sp,-1724
80008876:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000887a:	c1 f8       	rjmp	800088b8 <_vfprintf_r+0x12b8>
8000887c:	fa c8 f9 50 	sub	r8,sp,-1712
80008880:	1a d8       	st.w	--sp,r8
80008882:	fa c8 fa b8 	sub	r8,sp,-1352
80008886:	0c 9b       	mov	r11,r6
80008888:	1a d8       	st.w	--sp,r8
8000888a:	fa c8 fb b4 	sub	r8,sp,-1100
8000888e:	04 9a       	mov	r10,r2
80008890:	1a d8       	st.w	--sp,r8
80008892:	08 9c       	mov	r12,r4
80008894:	fa c8 f9 40 	sub	r8,sp,-1728
80008898:	fa c9 ff b4 	sub	r9,sp,-76
8000889c:	fe b0 f5 1a 	rcall	800072d0 <get_arg>
800088a0:	2f dd       	sub	sp,-12
800088a2:	78 0b       	ld.w	r11,r12[0x0]
800088a4:	c2 48       	rjmp	800088ec <_vfprintf_r+0x12ec>
800088a6:	ee ca ff ff 	sub	r10,r7,-1
800088aa:	10 37       	cp.w	r7,r8
800088ac:	c0 94       	brge	800088be <_vfprintf_r+0x12be>
800088ae:	fa c9 f9 44 	sub	r9,sp,-1724
800088b2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800088b6:	14 97       	mov	r7,r10
800088b8:	ec fb fd 88 	ld.w	r11,r6[-632]
800088bc:	c1 88       	rjmp	800088ec <_vfprintf_r+0x12ec>
800088be:	41 09       	lddsp	r9,sp[0x40]
800088c0:	59 f8       	cp.w	r8,31
800088c2:	e0 89 00 11 	brgt	800088e4 <_vfprintf_r+0x12e4>
800088c6:	f2 cb ff fc 	sub	r11,r9,-4
800088ca:	51 0b       	stdsp	sp[0x40],r11
800088cc:	fa c6 f9 44 	sub	r6,sp,-1724
800088d0:	72 0b       	ld.w	r11,r9[0x0]
800088d2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800088d6:	f3 4b fd 88 	st.w	r9[-632],r11
800088da:	2f f8       	sub	r8,-1
800088dc:	14 97       	mov	r7,r10
800088de:	fb 48 06 b4 	st.w	sp[1716],r8
800088e2:	c0 58       	rjmp	800088ec <_vfprintf_r+0x12ec>
800088e4:	72 0b       	ld.w	r11,r9[0x0]
800088e6:	14 97       	mov	r7,r10
800088e8:	2f c9       	sub	r9,-4
800088ea:	51 09       	stdsp	sp[0x40],r9
800088ec:	50 1b       	stdsp	sp[0x4],r11
800088ee:	30 0e       	mov	lr,0
800088f0:	30 18       	mov	r8,1
800088f2:	50 0e       	stdsp	sp[0x0],lr
800088f4:	c2 29       	rjmp	80008b38 <_vfprintf_r+0x1538>
800088f6:	50 a7       	stdsp	sp[0x28],r7
800088f8:	50 80       	stdsp	sp[0x20],r0
800088fa:	0c 97       	mov	r7,r6
800088fc:	04 94       	mov	r4,r2
800088fe:	06 96       	mov	r6,r3
80008900:	02 92       	mov	r2,r1
80008902:	fe cc c1 2e 	sub	r12,pc,-16082
80008906:	40 93       	lddsp	r3,sp[0x24]
80008908:	10 90       	mov	r0,r8
8000890a:	40 41       	lddsp	r1,sp[0x10]
8000890c:	50 dc       	stdsp	sp[0x34],r12
8000890e:	ed b5 00 05 	bld	r5,0x5
80008912:	c5 51       	brne	800089bc <_vfprintf_r+0x13bc>
80008914:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008918:	40 3b       	lddsp	r11,sp[0xc]
8000891a:	58 0b       	cp.w	r11,0
8000891c:	c2 20       	breq	80008960 <_vfprintf_r+0x1360>
8000891e:	10 36       	cp.w	r6,r8
80008920:	c0 a4       	brge	80008934 <_vfprintf_r+0x1334>
80008922:	fa ca f9 44 	sub	r10,sp,-1724
80008926:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000892a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000892e:	fa e9 00 00 	st.d	sp[0],r8
80008932:	cf 28       	rjmp	80008b16 <_vfprintf_r+0x1516>
80008934:	fa c8 f9 50 	sub	r8,sp,-1712
80008938:	1a d8       	st.w	--sp,r8
8000893a:	fa c8 fa b8 	sub	r8,sp,-1352
8000893e:	04 9a       	mov	r10,r2
80008940:	1a d8       	st.w	--sp,r8
80008942:	0c 9b       	mov	r11,r6
80008944:	fa c8 fb b4 	sub	r8,sp,-1100
80008948:	08 9c       	mov	r12,r4
8000894a:	1a d8       	st.w	--sp,r8
8000894c:	fa c8 f9 40 	sub	r8,sp,-1728
80008950:	fa c9 ff b4 	sub	r9,sp,-76
80008954:	fe b0 f4 be 	rcall	800072d0 <get_arg>
80008958:	2f dd       	sub	sp,-12
8000895a:	f8 ea 00 00 	ld.d	r10,r12[0]
8000895e:	c0 c8       	rjmp	80008976 <_vfprintf_r+0x1376>
80008960:	ee ca ff ff 	sub	r10,r7,-1
80008964:	10 37       	cp.w	r7,r8
80008966:	c0 b4       	brge	8000897c <_vfprintf_r+0x137c>
80008968:	fa c9 f9 44 	sub	r9,sp,-1724
8000896c:	14 97       	mov	r7,r10
8000896e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008972:	ec ea fd 88 	ld.d	r10,r6[-632]
80008976:	fa eb 00 00 	st.d	sp[0],r10
8000897a:	cc e8       	rjmp	80008b16 <_vfprintf_r+0x1516>
8000897c:	41 09       	lddsp	r9,sp[0x40]
8000897e:	59 f8       	cp.w	r8,31
80008980:	e0 89 00 16 	brgt	800089ac <_vfprintf_r+0x13ac>
80008984:	f2 e6 00 00 	ld.d	r6,r9[0]
80008988:	f2 cb ff f8 	sub	r11,r9,-8
8000898c:	fa e7 00 00 	st.d	sp[0],r6
80008990:	51 0b       	stdsp	sp[0x40],r11
80008992:	fa c6 f9 44 	sub	r6,sp,-1724
80008996:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000899a:	fa e6 00 00 	ld.d	r6,sp[0]
8000899e:	f2 e7 fd 88 	st.d	r9[-632],r6
800089a2:	2f f8       	sub	r8,-1
800089a4:	14 97       	mov	r7,r10
800089a6:	fb 48 06 b4 	st.w	sp[1716],r8
800089aa:	cb 68       	rjmp	80008b16 <_vfprintf_r+0x1516>
800089ac:	f2 e6 00 00 	ld.d	r6,r9[0]
800089b0:	2f 89       	sub	r9,-8
800089b2:	fa e7 00 00 	st.d	sp[0],r6
800089b6:	51 09       	stdsp	sp[0x40],r9
800089b8:	14 97       	mov	r7,r10
800089ba:	ca e8       	rjmp	80008b16 <_vfprintf_r+0x1516>
800089bc:	ed b5 00 04 	bld	r5,0x4
800089c0:	c1 71       	brne	800089ee <_vfprintf_r+0x13ee>
800089c2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089c6:	40 3e       	lddsp	lr,sp[0xc]
800089c8:	58 0e       	cp.w	lr,0
800089ca:	c0 80       	breq	800089da <_vfprintf_r+0x13da>
800089cc:	10 36       	cp.w	r6,r8
800089ce:	c6 94       	brge	80008aa0 <_vfprintf_r+0x14a0>
800089d0:	fa cc f9 44 	sub	r12,sp,-1724
800089d4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800089d8:	c8 28       	rjmp	80008adc <_vfprintf_r+0x14dc>
800089da:	ee ca ff ff 	sub	r10,r7,-1
800089de:	10 37       	cp.w	r7,r8
800089e0:	e0 84 00 81 	brge	80008ae2 <_vfprintf_r+0x14e2>
800089e4:	fa cb f9 44 	sub	r11,sp,-1724
800089e8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800089ec:	c7 78       	rjmp	80008ada <_vfprintf_r+0x14da>
800089ee:	ed b5 00 06 	bld	r5,0x6
800089f2:	c4 b1       	brne	80008a88 <_vfprintf_r+0x1488>
800089f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089f8:	40 3c       	lddsp	r12,sp[0xc]
800089fa:	58 0c       	cp.w	r12,0
800089fc:	c1 d0       	breq	80008a36 <_vfprintf_r+0x1436>
800089fe:	10 36       	cp.w	r6,r8
80008a00:	c0 64       	brge	80008a0c <_vfprintf_r+0x140c>
80008a02:	fa cb f9 44 	sub	r11,sp,-1724
80008a06:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a0a:	c1 f8       	rjmp	80008a48 <_vfprintf_r+0x1448>
80008a0c:	fa c8 f9 50 	sub	r8,sp,-1712
80008a10:	1a d8       	st.w	--sp,r8
80008a12:	fa c8 fa b8 	sub	r8,sp,-1352
80008a16:	1a d8       	st.w	--sp,r8
80008a18:	fa c8 fb b4 	sub	r8,sp,-1100
80008a1c:	1a d8       	st.w	--sp,r8
80008a1e:	fa c8 f9 40 	sub	r8,sp,-1728
80008a22:	fa c9 ff b4 	sub	r9,sp,-76
80008a26:	04 9a       	mov	r10,r2
80008a28:	0c 9b       	mov	r11,r6
80008a2a:	08 9c       	mov	r12,r4
80008a2c:	fe b0 f4 52 	rcall	800072d0 <get_arg>
80008a30:	2f dd       	sub	sp,-12
80008a32:	98 18       	ld.sh	r8,r12[0x2]
80008a34:	c2 78       	rjmp	80008a82 <_vfprintf_r+0x1482>
80008a36:	ee ca ff ff 	sub	r10,r7,-1
80008a3a:	10 37       	cp.w	r7,r8
80008a3c:	c0 a4       	brge	80008a50 <_vfprintf_r+0x1450>
80008a3e:	fa c9 f9 44 	sub	r9,sp,-1724
80008a42:	14 97       	mov	r7,r10
80008a44:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008a48:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008a4c:	c1 b8       	rjmp	80008a82 <_vfprintf_r+0x1482>
80008a4e:	d7 03       	nop
80008a50:	41 09       	lddsp	r9,sp[0x40]
80008a52:	59 f8       	cp.w	r8,31
80008a54:	e0 89 00 13 	brgt	80008a7a <_vfprintf_r+0x147a>
80008a58:	f2 cb ff fc 	sub	r11,r9,-4
80008a5c:	51 0b       	stdsp	sp[0x40],r11
80008a5e:	72 09       	ld.w	r9,r9[0x0]
80008a60:	fa c6 f9 44 	sub	r6,sp,-1724
80008a64:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008a68:	2f f8       	sub	r8,-1
80008a6a:	f7 49 fd 88 	st.w	r11[-632],r9
80008a6e:	fb 48 06 b4 	st.w	sp[1716],r8
80008a72:	14 97       	mov	r7,r10
80008a74:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008a78:	c0 58       	rjmp	80008a82 <_vfprintf_r+0x1482>
80008a7a:	92 18       	ld.sh	r8,r9[0x2]
80008a7c:	14 97       	mov	r7,r10
80008a7e:	2f c9       	sub	r9,-4
80008a80:	51 09       	stdsp	sp[0x40],r9
80008a82:	5c 78       	castu.h	r8
80008a84:	50 18       	stdsp	sp[0x4],r8
80008a86:	c4 68       	rjmp	80008b12 <_vfprintf_r+0x1512>
80008a88:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a8c:	40 3c       	lddsp	r12,sp[0xc]
80008a8e:	58 0c       	cp.w	r12,0
80008a90:	c1 d0       	breq	80008aca <_vfprintf_r+0x14ca>
80008a92:	10 36       	cp.w	r6,r8
80008a94:	c0 64       	brge	80008aa0 <_vfprintf_r+0x14a0>
80008a96:	fa cb f9 44 	sub	r11,sp,-1724
80008a9a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a9e:	c1 f8       	rjmp	80008adc <_vfprintf_r+0x14dc>
80008aa0:	fa c8 f9 50 	sub	r8,sp,-1712
80008aa4:	1a d8       	st.w	--sp,r8
80008aa6:	fa c8 fa b8 	sub	r8,sp,-1352
80008aaa:	0c 9b       	mov	r11,r6
80008aac:	1a d8       	st.w	--sp,r8
80008aae:	fa c8 fb b4 	sub	r8,sp,-1100
80008ab2:	04 9a       	mov	r10,r2
80008ab4:	1a d8       	st.w	--sp,r8
80008ab6:	08 9c       	mov	r12,r4
80008ab8:	fa c8 f9 40 	sub	r8,sp,-1728
80008abc:	fa c9 ff b4 	sub	r9,sp,-76
80008ac0:	fe b0 f4 08 	rcall	800072d0 <get_arg>
80008ac4:	2f dd       	sub	sp,-12
80008ac6:	78 0b       	ld.w	r11,r12[0x0]
80008ac8:	c2 48       	rjmp	80008b10 <_vfprintf_r+0x1510>
80008aca:	ee ca ff ff 	sub	r10,r7,-1
80008ace:	10 37       	cp.w	r7,r8
80008ad0:	c0 94       	brge	80008ae2 <_vfprintf_r+0x14e2>
80008ad2:	fa c9 f9 44 	sub	r9,sp,-1724
80008ad6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ada:	14 97       	mov	r7,r10
80008adc:	ec fb fd 88 	ld.w	r11,r6[-632]
80008ae0:	c1 88       	rjmp	80008b10 <_vfprintf_r+0x1510>
80008ae2:	41 09       	lddsp	r9,sp[0x40]
80008ae4:	59 f8       	cp.w	r8,31
80008ae6:	e0 89 00 11 	brgt	80008b08 <_vfprintf_r+0x1508>
80008aea:	f2 cb ff fc 	sub	r11,r9,-4
80008aee:	51 0b       	stdsp	sp[0x40],r11
80008af0:	fa c6 f9 44 	sub	r6,sp,-1724
80008af4:	72 0b       	ld.w	r11,r9[0x0]
80008af6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008afa:	f3 4b fd 88 	st.w	r9[-632],r11
80008afe:	2f f8       	sub	r8,-1
80008b00:	14 97       	mov	r7,r10
80008b02:	fb 48 06 b4 	st.w	sp[1716],r8
80008b06:	c0 58       	rjmp	80008b10 <_vfprintf_r+0x1510>
80008b08:	72 0b       	ld.w	r11,r9[0x0]
80008b0a:	14 97       	mov	r7,r10
80008b0c:	2f c9       	sub	r9,-4
80008b0e:	51 09       	stdsp	sp[0x40],r9
80008b10:	50 1b       	stdsp	sp[0x4],r11
80008b12:	30 0e       	mov	lr,0
80008b14:	50 0e       	stdsp	sp[0x0],lr
80008b16:	40 08       	lddsp	r8,sp[0x0]
80008b18:	40 1c       	lddsp	r12,sp[0x4]
80008b1a:	18 48       	or	r8,r12
80008b1c:	5f 19       	srne	r9
80008b1e:	0a 98       	mov	r8,r5
80008b20:	eb e9 00 09 	and	r9,r5,r9
80008b24:	a1 b8       	sbr	r8,0x1
80008b26:	58 09       	cp.w	r9,0
80008b28:	c0 70       	breq	80008b36 <_vfprintf_r+0x1536>
80008b2a:	10 95       	mov	r5,r8
80008b2c:	fb 60 06 b9 	st.b	sp[1721],r0
80008b30:	33 08       	mov	r8,48
80008b32:	fb 68 06 b8 	st.b	sp[1720],r8
80008b36:	30 28       	mov	r8,2
80008b38:	30 09       	mov	r9,0
80008b3a:	fb 69 06 bb 	st.b	sp[1723],r9
80008b3e:	0a 99       	mov	r9,r5
80008b40:	a7 d9       	cbr	r9,0x7
80008b42:	40 2b       	lddsp	r11,sp[0x8]
80008b44:	40 16       	lddsp	r6,sp[0x4]
80008b46:	58 0b       	cp.w	r11,0
80008b48:	5f 1a       	srne	r10
80008b4a:	f2 05 17 40 	movge	r5,r9
80008b4e:	fa c2 f9 78 	sub	r2,sp,-1672
80008b52:	40 09       	lddsp	r9,sp[0x0]
80008b54:	0c 49       	or	r9,r6
80008b56:	5f 19       	srne	r9
80008b58:	f5 e9 10 09 	or	r9,r10,r9
80008b5c:	c5 c0       	breq	80008c14 <_vfprintf_r+0x1614>
80008b5e:	30 19       	mov	r9,1
80008b60:	f2 08 18 00 	cp.b	r8,r9
80008b64:	c0 60       	breq	80008b70 <_vfprintf_r+0x1570>
80008b66:	30 29       	mov	r9,2
80008b68:	f2 08 18 00 	cp.b	r8,r9
80008b6c:	c0 41       	brne	80008b74 <_vfprintf_r+0x1574>
80008b6e:	c3 c8       	rjmp	80008be6 <_vfprintf_r+0x15e6>
80008b70:	04 96       	mov	r6,r2
80008b72:	c3 08       	rjmp	80008bd2 <_vfprintf_r+0x15d2>
80008b74:	04 96       	mov	r6,r2
80008b76:	fa e8 00 00 	ld.d	r8,sp[0]
80008b7a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008b7e:	2d 0a       	sub	r10,-48
80008b80:	0c fa       	st.b	--r6,r10
80008b82:	f0 0b 16 03 	lsr	r11,r8,0x3
80008b86:	f2 0c 16 03 	lsr	r12,r9,0x3
80008b8a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008b8e:	18 99       	mov	r9,r12
80008b90:	16 98       	mov	r8,r11
80008b92:	58 08       	cp.w	r8,0
80008b94:	5c 29       	cpc	r9
80008b96:	cf 21       	brne	80008b7a <_vfprintf_r+0x157a>
80008b98:	fa e9 00 00 	st.d	sp[0],r8
80008b9c:	ed b5 00 00 	bld	r5,0x0
80008ba0:	c4 51       	brne	80008c2a <_vfprintf_r+0x162a>
80008ba2:	33 09       	mov	r9,48
80008ba4:	f2 0a 18 00 	cp.b	r10,r9
80008ba8:	c4 10       	breq	80008c2a <_vfprintf_r+0x162a>
80008baa:	0c f9       	st.b	--r6,r9
80008bac:	c3 f8       	rjmp	80008c2a <_vfprintf_r+0x162a>
80008bae:	fa ea 00 00 	ld.d	r10,sp[0]
80008bb2:	30 a8       	mov	r8,10
80008bb4:	30 09       	mov	r9,0
80008bb6:	e0 a0 19 c1 	rcall	8000bf38 <__avr32_umod64>
80008bba:	30 a8       	mov	r8,10
80008bbc:	2d 0a       	sub	r10,-48
80008bbe:	30 09       	mov	r9,0
80008bc0:	ac 8a       	st.b	r6[0x0],r10
80008bc2:	fa ea 00 00 	ld.d	r10,sp[0]
80008bc6:	fe b0 ed 51 	rcall	80006668 <__avr32_udiv64>
80008bca:	16 99       	mov	r9,r11
80008bcc:	14 98       	mov	r8,r10
80008bce:	fa e9 00 00 	st.d	sp[0],r8
80008bd2:	20 16       	sub	r6,1
80008bd4:	fa ea 00 00 	ld.d	r10,sp[0]
80008bd8:	58 9a       	cp.w	r10,9
80008bda:	5c 2b       	cpc	r11
80008bdc:	fe 9b ff e9 	brhi	80008bae <_vfprintf_r+0x15ae>
80008be0:	1b f8       	ld.ub	r8,sp[0x7]
80008be2:	2d 08       	sub	r8,-48
80008be4:	c2 08       	rjmp	80008c24 <_vfprintf_r+0x1624>
80008be6:	04 96       	mov	r6,r2
80008be8:	fa e8 00 00 	ld.d	r8,sp[0]
80008bec:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008bf0:	40 de       	lddsp	lr,sp[0x34]
80008bf2:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008bf6:	0c fa       	st.b	--r6,r10
80008bf8:	f2 0b 16 04 	lsr	r11,r9,0x4
80008bfc:	f0 0a 16 04 	lsr	r10,r8,0x4
80008c00:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008c04:	16 99       	mov	r9,r11
80008c06:	14 98       	mov	r8,r10
80008c08:	58 08       	cp.w	r8,0
80008c0a:	5c 29       	cpc	r9
80008c0c:	cf 01       	brne	80008bec <_vfprintf_r+0x15ec>
80008c0e:	fa e9 00 00 	st.d	sp[0],r8
80008c12:	c0 c8       	rjmp	80008c2a <_vfprintf_r+0x162a>
80008c14:	58 08       	cp.w	r8,0
80008c16:	c0 91       	brne	80008c28 <_vfprintf_r+0x1628>
80008c18:	ed b5 00 00 	bld	r5,0x0
80008c1c:	c0 61       	brne	80008c28 <_vfprintf_r+0x1628>
80008c1e:	fa c6 f9 79 	sub	r6,sp,-1671
80008c22:	33 08       	mov	r8,48
80008c24:	ac 88       	st.b	r6[0x0],r8
80008c26:	c0 28       	rjmp	80008c2a <_vfprintf_r+0x162a>
80008c28:	04 96       	mov	r6,r2
80008c2a:	0c 12       	sub	r2,r6
80008c2c:	c1 c8       	rjmp	80008c64 <_vfprintf_r+0x1664>
80008c2e:	50 a7       	stdsp	sp[0x28],r7
80008c30:	50 80       	stdsp	sp[0x20],r0
80008c32:	40 93       	lddsp	r3,sp[0x24]
80008c34:	0c 97       	mov	r7,r6
80008c36:	10 90       	mov	r0,r8
80008c38:	04 94       	mov	r4,r2
80008c3a:	40 41       	lddsp	r1,sp[0x10]
80008c3c:	58 08       	cp.w	r8,0
80008c3e:	e0 80 04 4f 	breq	800094dc <_vfprintf_r+0x1edc>
80008c42:	fb 68 06 60 	st.b	sp[1632],r8
80008c46:	30 0c       	mov	r12,0
80008c48:	30 08       	mov	r8,0
80008c4a:	30 12       	mov	r2,1
80008c4c:	fb 68 06 bb 	st.b	sp[1723],r8
80008c50:	50 2c       	stdsp	sp[0x8],r12
80008c52:	fa c6 f9 a0 	sub	r6,sp,-1632
80008c56:	c0 78       	rjmp	80008c64 <_vfprintf_r+0x1664>
80008c58:	30 0b       	mov	r11,0
80008c5a:	50 2b       	stdsp	sp[0x8],r11
80008c5c:	c0 48       	rjmp	80008c64 <_vfprintf_r+0x1664>
80008c5e:	40 22       	lddsp	r2,sp[0x8]
80008c60:	30 0a       	mov	r10,0
80008c62:	50 2a       	stdsp	sp[0x8],r10
80008c64:	40 29       	lddsp	r9,sp[0x8]
80008c66:	e4 09 0c 49 	max	r9,r2,r9
80008c6a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008c6e:	50 39       	stdsp	sp[0xc],r9
80008c70:	0a 9e       	mov	lr,r5
80008c72:	30 09       	mov	r9,0
80008c74:	e2 1e 00 02 	andl	lr,0x2,COH
80008c78:	f2 08 18 00 	cp.b	r8,r9
80008c7c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008c80:	f7 b8 01 ff 	subne	r8,-1
80008c84:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008c88:	0a 9b       	mov	r11,r5
80008c8a:	58 0e       	cp.w	lr,0
80008c8c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008c90:	f7 bc 01 fe 	subne	r12,-2
80008c94:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008c98:	e2 1b 00 84 	andl	r11,0x84,COH
80008c9c:	50 fe       	stdsp	sp[0x3c],lr
80008c9e:	50 9b       	stdsp	sp[0x24],r11
80008ca0:	c4 71       	brne	80008d2e <_vfprintf_r+0x172e>
80008ca2:	40 8a       	lddsp	r10,sp[0x20]
80008ca4:	40 39       	lddsp	r9,sp[0xc]
80008ca6:	12 1a       	sub	r10,r9
80008ca8:	50 4a       	stdsp	sp[0x10],r10
80008caa:	58 0a       	cp.w	r10,0
80008cac:	e0 89 00 20 	brgt	80008cec <_vfprintf_r+0x16ec>
80008cb0:	c3 f8       	rjmp	80008d2e <_vfprintf_r+0x172e>
80008cb2:	2f 09       	sub	r9,-16
80008cb4:	2f f8       	sub	r8,-1
80008cb6:	fe ce c4 ca 	sub	lr,pc,-15158
80008cba:	31 0c       	mov	r12,16
80008cbc:	fb 49 06 90 	st.w	sp[1680],r9
80008cc0:	87 0e       	st.w	r3[0x0],lr
80008cc2:	87 1c       	st.w	r3[0x4],r12
80008cc4:	fb 48 06 8c 	st.w	sp[1676],r8
80008cc8:	58 78       	cp.w	r8,7
80008cca:	e0 89 00 04 	brgt	80008cd2 <_vfprintf_r+0x16d2>
80008cce:	2f 83       	sub	r3,-8
80008cd0:	c0 b8       	rjmp	80008ce6 <_vfprintf_r+0x16e6>
80008cd2:	fa ca f9 78 	sub	r10,sp,-1672
80008cd6:	02 9b       	mov	r11,r1
80008cd8:	08 9c       	mov	r12,r4
80008cda:	fe b0 f4 85 	rcall	800075e4 <__sprint_r>
80008cde:	e0 81 04 10 	brne	800094fe <_vfprintf_r+0x1efe>
80008ce2:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ce6:	40 4b       	lddsp	r11,sp[0x10]
80008ce8:	21 0b       	sub	r11,16
80008cea:	50 4b       	stdsp	sp[0x10],r11
80008cec:	fa f9 06 90 	ld.w	r9,sp[1680]
80008cf0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008cf4:	fe ca c5 08 	sub	r10,pc,-15096
80008cf8:	40 4e       	lddsp	lr,sp[0x10]
80008cfa:	59 0e       	cp.w	lr,16
80008cfc:	fe 99 ff db 	brgt	80008cb2 <_vfprintf_r+0x16b2>
80008d00:	1c 09       	add	r9,lr
80008d02:	2f f8       	sub	r8,-1
80008d04:	87 0a       	st.w	r3[0x0],r10
80008d06:	fb 49 06 90 	st.w	sp[1680],r9
80008d0a:	87 1e       	st.w	r3[0x4],lr
80008d0c:	fb 48 06 8c 	st.w	sp[1676],r8
80008d10:	58 78       	cp.w	r8,7
80008d12:	e0 89 00 04 	brgt	80008d1a <_vfprintf_r+0x171a>
80008d16:	2f 83       	sub	r3,-8
80008d18:	c0 b8       	rjmp	80008d2e <_vfprintf_r+0x172e>
80008d1a:	fa ca f9 78 	sub	r10,sp,-1672
80008d1e:	02 9b       	mov	r11,r1
80008d20:	08 9c       	mov	r12,r4
80008d22:	fe b0 f4 61 	rcall	800075e4 <__sprint_r>
80008d26:	e0 81 03 ec 	brne	800094fe <_vfprintf_r+0x1efe>
80008d2a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d2e:	30 09       	mov	r9,0
80008d30:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008d34:	f2 08 18 00 	cp.b	r8,r9
80008d38:	c1 f0       	breq	80008d76 <_vfprintf_r+0x1776>
80008d3a:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d3e:	fa c9 f9 45 	sub	r9,sp,-1723
80008d42:	2f f8       	sub	r8,-1
80008d44:	87 09       	st.w	r3[0x0],r9
80008d46:	fb 48 06 90 	st.w	sp[1680],r8
80008d4a:	30 19       	mov	r9,1
80008d4c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d50:	87 19       	st.w	r3[0x4],r9
80008d52:	2f f8       	sub	r8,-1
80008d54:	fb 48 06 8c 	st.w	sp[1676],r8
80008d58:	58 78       	cp.w	r8,7
80008d5a:	e0 89 00 04 	brgt	80008d62 <_vfprintf_r+0x1762>
80008d5e:	2f 83       	sub	r3,-8
80008d60:	c0 b8       	rjmp	80008d76 <_vfprintf_r+0x1776>
80008d62:	fa ca f9 78 	sub	r10,sp,-1672
80008d66:	02 9b       	mov	r11,r1
80008d68:	08 9c       	mov	r12,r4
80008d6a:	fe b0 f4 3d 	rcall	800075e4 <__sprint_r>
80008d6e:	e0 81 03 c8 	brne	800094fe <_vfprintf_r+0x1efe>
80008d72:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d76:	40 fc       	lddsp	r12,sp[0x3c]
80008d78:	58 0c       	cp.w	r12,0
80008d7a:	c1 f0       	breq	80008db8 <_vfprintf_r+0x17b8>
80008d7c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d80:	fa c9 f9 48 	sub	r9,sp,-1720
80008d84:	2f e8       	sub	r8,-2
80008d86:	87 09       	st.w	r3[0x0],r9
80008d88:	fb 48 06 90 	st.w	sp[1680],r8
80008d8c:	30 29       	mov	r9,2
80008d8e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d92:	87 19       	st.w	r3[0x4],r9
80008d94:	2f f8       	sub	r8,-1
80008d96:	fb 48 06 8c 	st.w	sp[1676],r8
80008d9a:	58 78       	cp.w	r8,7
80008d9c:	e0 89 00 04 	brgt	80008da4 <_vfprintf_r+0x17a4>
80008da0:	2f 83       	sub	r3,-8
80008da2:	c0 b8       	rjmp	80008db8 <_vfprintf_r+0x17b8>
80008da4:	fa ca f9 78 	sub	r10,sp,-1672
80008da8:	02 9b       	mov	r11,r1
80008daa:	08 9c       	mov	r12,r4
80008dac:	fe b0 f4 1c 	rcall	800075e4 <__sprint_r>
80008db0:	e0 81 03 a7 	brne	800094fe <_vfprintf_r+0x1efe>
80008db4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008db8:	40 9b       	lddsp	r11,sp[0x24]
80008dba:	e0 4b 00 80 	cp.w	r11,128
80008dbe:	c4 71       	brne	80008e4c <_vfprintf_r+0x184c>
80008dc0:	40 8a       	lddsp	r10,sp[0x20]
80008dc2:	40 39       	lddsp	r9,sp[0xc]
80008dc4:	12 1a       	sub	r10,r9
80008dc6:	50 4a       	stdsp	sp[0x10],r10
80008dc8:	58 0a       	cp.w	r10,0
80008dca:	e0 89 00 20 	brgt	80008e0a <_vfprintf_r+0x180a>
80008dce:	c3 f8       	rjmp	80008e4c <_vfprintf_r+0x184c>
80008dd0:	2f 09       	sub	r9,-16
80008dd2:	2f f8       	sub	r8,-1
80008dd4:	fe ce c5 d8 	sub	lr,pc,-14888
80008dd8:	31 0c       	mov	r12,16
80008dda:	fb 49 06 90 	st.w	sp[1680],r9
80008dde:	87 0e       	st.w	r3[0x0],lr
80008de0:	87 1c       	st.w	r3[0x4],r12
80008de2:	fb 48 06 8c 	st.w	sp[1676],r8
80008de6:	58 78       	cp.w	r8,7
80008de8:	e0 89 00 04 	brgt	80008df0 <_vfprintf_r+0x17f0>
80008dec:	2f 83       	sub	r3,-8
80008dee:	c0 b8       	rjmp	80008e04 <_vfprintf_r+0x1804>
80008df0:	fa ca f9 78 	sub	r10,sp,-1672
80008df4:	02 9b       	mov	r11,r1
80008df6:	08 9c       	mov	r12,r4
80008df8:	fe b0 f3 f6 	rcall	800075e4 <__sprint_r>
80008dfc:	e0 81 03 81 	brne	800094fe <_vfprintf_r+0x1efe>
80008e00:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e04:	40 4b       	lddsp	r11,sp[0x10]
80008e06:	21 0b       	sub	r11,16
80008e08:	50 4b       	stdsp	sp[0x10],r11
80008e0a:	fa f9 06 90 	ld.w	r9,sp[1680]
80008e0e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e12:	fe ca c6 16 	sub	r10,pc,-14826
80008e16:	40 4e       	lddsp	lr,sp[0x10]
80008e18:	59 0e       	cp.w	lr,16
80008e1a:	fe 99 ff db 	brgt	80008dd0 <_vfprintf_r+0x17d0>
80008e1e:	1c 09       	add	r9,lr
80008e20:	2f f8       	sub	r8,-1
80008e22:	87 0a       	st.w	r3[0x0],r10
80008e24:	fb 49 06 90 	st.w	sp[1680],r9
80008e28:	87 1e       	st.w	r3[0x4],lr
80008e2a:	fb 48 06 8c 	st.w	sp[1676],r8
80008e2e:	58 78       	cp.w	r8,7
80008e30:	e0 89 00 04 	brgt	80008e38 <_vfprintf_r+0x1838>
80008e34:	2f 83       	sub	r3,-8
80008e36:	c0 b8       	rjmp	80008e4c <_vfprintf_r+0x184c>
80008e38:	fa ca f9 78 	sub	r10,sp,-1672
80008e3c:	02 9b       	mov	r11,r1
80008e3e:	08 9c       	mov	r12,r4
80008e40:	fe b0 f3 d2 	rcall	800075e4 <__sprint_r>
80008e44:	e0 81 03 5d 	brne	800094fe <_vfprintf_r+0x1efe>
80008e48:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e4c:	40 2c       	lddsp	r12,sp[0x8]
80008e4e:	04 1c       	sub	r12,r2
80008e50:	50 2c       	stdsp	sp[0x8],r12
80008e52:	58 0c       	cp.w	r12,0
80008e54:	e0 89 00 20 	brgt	80008e94 <_vfprintf_r+0x1894>
80008e58:	c3 f8       	rjmp	80008ed6 <_vfprintf_r+0x18d6>
80008e5a:	2f 09       	sub	r9,-16
80008e5c:	2f f8       	sub	r8,-1
80008e5e:	fe cb c6 62 	sub	r11,pc,-14750
80008e62:	31 0a       	mov	r10,16
80008e64:	fb 49 06 90 	st.w	sp[1680],r9
80008e68:	87 0b       	st.w	r3[0x0],r11
80008e6a:	87 1a       	st.w	r3[0x4],r10
80008e6c:	fb 48 06 8c 	st.w	sp[1676],r8
80008e70:	58 78       	cp.w	r8,7
80008e72:	e0 89 00 04 	brgt	80008e7a <_vfprintf_r+0x187a>
80008e76:	2f 83       	sub	r3,-8
80008e78:	c0 b8       	rjmp	80008e8e <_vfprintf_r+0x188e>
80008e7a:	fa ca f9 78 	sub	r10,sp,-1672
80008e7e:	02 9b       	mov	r11,r1
80008e80:	08 9c       	mov	r12,r4
80008e82:	fe b0 f3 b1 	rcall	800075e4 <__sprint_r>
80008e86:	e0 81 03 3c 	brne	800094fe <_vfprintf_r+0x1efe>
80008e8a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e8e:	40 29       	lddsp	r9,sp[0x8]
80008e90:	21 09       	sub	r9,16
80008e92:	50 29       	stdsp	sp[0x8],r9
80008e94:	fa f9 06 90 	ld.w	r9,sp[1680]
80008e98:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e9c:	fe ca c6 a0 	sub	r10,pc,-14688
80008ea0:	40 2e       	lddsp	lr,sp[0x8]
80008ea2:	59 0e       	cp.w	lr,16
80008ea4:	fe 99 ff db 	brgt	80008e5a <_vfprintf_r+0x185a>
80008ea8:	1c 09       	add	r9,lr
80008eaa:	2f f8       	sub	r8,-1
80008eac:	87 0a       	st.w	r3[0x0],r10
80008eae:	fb 49 06 90 	st.w	sp[1680],r9
80008eb2:	87 1e       	st.w	r3[0x4],lr
80008eb4:	fb 48 06 8c 	st.w	sp[1676],r8
80008eb8:	58 78       	cp.w	r8,7
80008eba:	e0 89 00 04 	brgt	80008ec2 <_vfprintf_r+0x18c2>
80008ebe:	2f 83       	sub	r3,-8
80008ec0:	c0 b8       	rjmp	80008ed6 <_vfprintf_r+0x18d6>
80008ec2:	fa ca f9 78 	sub	r10,sp,-1672
80008ec6:	02 9b       	mov	r11,r1
80008ec8:	08 9c       	mov	r12,r4
80008eca:	fe b0 f3 8d 	rcall	800075e4 <__sprint_r>
80008ece:	e0 81 03 18 	brne	800094fe <_vfprintf_r+0x1efe>
80008ed2:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ed6:	ed b5 00 08 	bld	r5,0x8
80008eda:	c0 b0       	breq	80008ef0 <_vfprintf_r+0x18f0>
80008edc:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ee0:	87 12       	st.w	r3[0x4],r2
80008ee2:	87 06       	st.w	r3[0x0],r6
80008ee4:	f0 02 00 02 	add	r2,r8,r2
80008ee8:	fb 42 06 90 	st.w	sp[1680],r2
80008eec:	e0 8f 01 d4 	bral	80009294 <_vfprintf_r+0x1c94>
80008ef0:	e0 40 00 65 	cp.w	r0,101
80008ef4:	e0 8a 01 d6 	brle	800092a0 <_vfprintf_r+0x1ca0>
80008ef8:	30 08       	mov	r8,0
80008efa:	30 09       	mov	r9,0
80008efc:	40 5b       	lddsp	r11,sp[0x14]
80008efe:	40 7a       	lddsp	r10,sp[0x1c]
80008f00:	e0 a0 16 15 	rcall	8000bb2a <__avr32_f64_cmp_eq>
80008f04:	c7 90       	breq	80008ff6 <_vfprintf_r+0x19f6>
80008f06:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f0a:	fe c9 c7 22 	sub	r9,pc,-14558
80008f0e:	2f f8       	sub	r8,-1
80008f10:	87 09       	st.w	r3[0x0],r9
80008f12:	fb 48 06 90 	st.w	sp[1680],r8
80008f16:	30 19       	mov	r9,1
80008f18:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f1c:	87 19       	st.w	r3[0x4],r9
80008f1e:	2f f8       	sub	r8,-1
80008f20:	fb 48 06 8c 	st.w	sp[1676],r8
80008f24:	58 78       	cp.w	r8,7
80008f26:	e0 89 00 05 	brgt	80008f30 <_vfprintf_r+0x1930>
80008f2a:	2f 83       	sub	r3,-8
80008f2c:	c0 c8       	rjmp	80008f44 <_vfprintf_r+0x1944>
80008f2e:	d7 03       	nop
80008f30:	fa ca f9 78 	sub	r10,sp,-1672
80008f34:	02 9b       	mov	r11,r1
80008f36:	08 9c       	mov	r12,r4
80008f38:	fe b0 f3 56 	rcall	800075e4 <__sprint_r>
80008f3c:	e0 81 02 e1 	brne	800094fe <_vfprintf_r+0x1efe>
80008f40:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f44:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008f48:	40 6c       	lddsp	r12,sp[0x18]
80008f4a:	18 38       	cp.w	r8,r12
80008f4c:	c0 55       	brlt	80008f56 <_vfprintf_r+0x1956>
80008f4e:	ed b5 00 00 	bld	r5,0x0
80008f52:	e0 81 02 6b 	brne	80009428 <_vfprintf_r+0x1e28>
80008f56:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f5a:	2f f8       	sub	r8,-1
80008f5c:	40 cb       	lddsp	r11,sp[0x30]
80008f5e:	fb 48 06 90 	st.w	sp[1680],r8
80008f62:	30 19       	mov	r9,1
80008f64:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f68:	87 0b       	st.w	r3[0x0],r11
80008f6a:	2f f8       	sub	r8,-1
80008f6c:	87 19       	st.w	r3[0x4],r9
80008f6e:	fb 48 06 8c 	st.w	sp[1676],r8
80008f72:	58 78       	cp.w	r8,7
80008f74:	e0 89 00 04 	brgt	80008f7c <_vfprintf_r+0x197c>
80008f78:	2f 83       	sub	r3,-8
80008f7a:	c0 b8       	rjmp	80008f90 <_vfprintf_r+0x1990>
80008f7c:	fa ca f9 78 	sub	r10,sp,-1672
80008f80:	02 9b       	mov	r11,r1
80008f82:	08 9c       	mov	r12,r4
80008f84:	fe b0 f3 30 	rcall	800075e4 <__sprint_r>
80008f88:	e0 81 02 bb 	brne	800094fe <_vfprintf_r+0x1efe>
80008f8c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f90:	40 66       	lddsp	r6,sp[0x18]
80008f92:	20 16       	sub	r6,1
80008f94:	58 06       	cp.w	r6,0
80008f96:	e0 89 00 1d 	brgt	80008fd0 <_vfprintf_r+0x19d0>
80008f9a:	e0 8f 02 47 	bral	80009428 <_vfprintf_r+0x1e28>
80008f9e:	2f 09       	sub	r9,-16
80008fa0:	2f f8       	sub	r8,-1
80008fa2:	fb 49 06 90 	st.w	sp[1680],r9
80008fa6:	87 02       	st.w	r3[0x0],r2
80008fa8:	87 10       	st.w	r3[0x4],r0
80008faa:	fb 48 06 8c 	st.w	sp[1676],r8
80008fae:	58 78       	cp.w	r8,7
80008fb0:	e0 89 00 04 	brgt	80008fb8 <_vfprintf_r+0x19b8>
80008fb4:	2f 83       	sub	r3,-8
80008fb6:	c0 b8       	rjmp	80008fcc <_vfprintf_r+0x19cc>
80008fb8:	fa ca f9 78 	sub	r10,sp,-1672
80008fbc:	02 9b       	mov	r11,r1
80008fbe:	08 9c       	mov	r12,r4
80008fc0:	fe b0 f3 12 	rcall	800075e4 <__sprint_r>
80008fc4:	e0 81 02 9d 	brne	800094fe <_vfprintf_r+0x1efe>
80008fc8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fcc:	21 06       	sub	r6,16
80008fce:	c0 48       	rjmp	80008fd6 <_vfprintf_r+0x19d6>
80008fd0:	fe c2 c7 d4 	sub	r2,pc,-14380
80008fd4:	31 00       	mov	r0,16
80008fd6:	fa f9 06 90 	ld.w	r9,sp[1680]
80008fda:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fde:	fe ca c7 e2 	sub	r10,pc,-14366
80008fe2:	59 06       	cp.w	r6,16
80008fe4:	fe 99 ff dd 	brgt	80008f9e <_vfprintf_r+0x199e>
80008fe8:	0c 09       	add	r9,r6
80008fea:	87 0a       	st.w	r3[0x0],r10
80008fec:	fb 49 06 90 	st.w	sp[1680],r9
80008ff0:	2f f8       	sub	r8,-1
80008ff2:	87 16       	st.w	r3[0x4],r6
80008ff4:	c5 39       	rjmp	8000929a <_vfprintf_r+0x1c9a>
80008ff6:	fa fa 06 ac 	ld.w	r10,sp[1708]
80008ffa:	58 0a       	cp.w	r10,0
80008ffc:	e0 89 00 92 	brgt	80009120 <_vfprintf_r+0x1b20>
80009000:	fa f8 06 90 	ld.w	r8,sp[1680]
80009004:	fe c9 c8 1c 	sub	r9,pc,-14308
80009008:	2f f8       	sub	r8,-1
8000900a:	87 09       	st.w	r3[0x0],r9
8000900c:	fb 48 06 90 	st.w	sp[1680],r8
80009010:	30 19       	mov	r9,1
80009012:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009016:	87 19       	st.w	r3[0x4],r9
80009018:	2f f8       	sub	r8,-1
8000901a:	fb 48 06 8c 	st.w	sp[1676],r8
8000901e:	58 78       	cp.w	r8,7
80009020:	e0 89 00 04 	brgt	80009028 <_vfprintf_r+0x1a28>
80009024:	2f 83       	sub	r3,-8
80009026:	c0 b8       	rjmp	8000903c <_vfprintf_r+0x1a3c>
80009028:	fa ca f9 78 	sub	r10,sp,-1672
8000902c:	02 9b       	mov	r11,r1
8000902e:	08 9c       	mov	r12,r4
80009030:	fe b0 f2 da 	rcall	800075e4 <__sprint_r>
80009034:	e0 81 02 65 	brne	800094fe <_vfprintf_r+0x1efe>
80009038:	fa c3 f9 e0 	sub	r3,sp,-1568
8000903c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009040:	58 08       	cp.w	r8,0
80009042:	c0 81       	brne	80009052 <_vfprintf_r+0x1a52>
80009044:	40 6a       	lddsp	r10,sp[0x18]
80009046:	58 0a       	cp.w	r10,0
80009048:	c0 51       	brne	80009052 <_vfprintf_r+0x1a52>
8000904a:	ed b5 00 00 	bld	r5,0x0
8000904e:	e0 81 01 ed 	brne	80009428 <_vfprintf_r+0x1e28>
80009052:	40 c9       	lddsp	r9,sp[0x30]
80009054:	fa f8 06 90 	ld.w	r8,sp[1680]
80009058:	2f f8       	sub	r8,-1
8000905a:	87 09       	st.w	r3[0x0],r9
8000905c:	fb 48 06 90 	st.w	sp[1680],r8
80009060:	30 19       	mov	r9,1
80009062:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009066:	87 19       	st.w	r3[0x4],r9
80009068:	2f f8       	sub	r8,-1
8000906a:	fb 48 06 8c 	st.w	sp[1676],r8
8000906e:	58 78       	cp.w	r8,7
80009070:	e0 89 00 04 	brgt	80009078 <_vfprintf_r+0x1a78>
80009074:	2f 83       	sub	r3,-8
80009076:	c0 b8       	rjmp	8000908c <_vfprintf_r+0x1a8c>
80009078:	fa ca f9 78 	sub	r10,sp,-1672
8000907c:	02 9b       	mov	r11,r1
8000907e:	08 9c       	mov	r12,r4
80009080:	fe b0 f2 b2 	rcall	800075e4 <__sprint_r>
80009084:	e0 81 02 3d 	brne	800094fe <_vfprintf_r+0x1efe>
80009088:	fa c3 f9 e0 	sub	r3,sp,-1568
8000908c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009090:	5c 32       	neg	r2
80009092:	58 02       	cp.w	r2,0
80009094:	e0 89 00 1d 	brgt	800090ce <_vfprintf_r+0x1ace>
80009098:	c3 d8       	rjmp	80009112 <_vfprintf_r+0x1b12>
8000909a:	2f 09       	sub	r9,-16
8000909c:	2f f8       	sub	r8,-1
8000909e:	31 0e       	mov	lr,16
800090a0:	fb 49 06 90 	st.w	sp[1680],r9
800090a4:	87 00       	st.w	r3[0x0],r0
800090a6:	87 1e       	st.w	r3[0x4],lr
800090a8:	fb 48 06 8c 	st.w	sp[1676],r8
800090ac:	58 78       	cp.w	r8,7
800090ae:	e0 89 00 04 	brgt	800090b6 <_vfprintf_r+0x1ab6>
800090b2:	2f 83       	sub	r3,-8
800090b4:	c0 b8       	rjmp	800090ca <_vfprintf_r+0x1aca>
800090b6:	fa ca f9 78 	sub	r10,sp,-1672
800090ba:	02 9b       	mov	r11,r1
800090bc:	08 9c       	mov	r12,r4
800090be:	fe b0 f2 93 	rcall	800075e4 <__sprint_r>
800090c2:	e0 81 02 1e 	brne	800094fe <_vfprintf_r+0x1efe>
800090c6:	fa c3 f9 e0 	sub	r3,sp,-1568
800090ca:	21 02       	sub	r2,16
800090cc:	c0 38       	rjmp	800090d2 <_vfprintf_r+0x1ad2>
800090ce:	fe c0 c8 d2 	sub	r0,pc,-14126
800090d2:	fa f9 06 90 	ld.w	r9,sp[1680]
800090d6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800090da:	fe ca c8 de 	sub	r10,pc,-14114
800090de:	59 02       	cp.w	r2,16
800090e0:	fe 99 ff dd 	brgt	8000909a <_vfprintf_r+0x1a9a>
800090e4:	04 09       	add	r9,r2
800090e6:	2f f8       	sub	r8,-1
800090e8:	87 0a       	st.w	r3[0x0],r10
800090ea:	fb 49 06 90 	st.w	sp[1680],r9
800090ee:	87 12       	st.w	r3[0x4],r2
800090f0:	fb 48 06 8c 	st.w	sp[1676],r8
800090f4:	58 78       	cp.w	r8,7
800090f6:	e0 89 00 04 	brgt	800090fe <_vfprintf_r+0x1afe>
800090fa:	2f 83       	sub	r3,-8
800090fc:	c0 b8       	rjmp	80009112 <_vfprintf_r+0x1b12>
800090fe:	fa ca f9 78 	sub	r10,sp,-1672
80009102:	02 9b       	mov	r11,r1
80009104:	08 9c       	mov	r12,r4
80009106:	fe b0 f2 6f 	rcall	800075e4 <__sprint_r>
8000910a:	e0 81 01 fa 	brne	800094fe <_vfprintf_r+0x1efe>
8000910e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009112:	40 6c       	lddsp	r12,sp[0x18]
80009114:	fa f8 06 90 	ld.w	r8,sp[1680]
80009118:	87 06       	st.w	r3[0x0],r6
8000911a:	87 1c       	st.w	r3[0x4],r12
8000911c:	18 08       	add	r8,r12
8000911e:	cb 98       	rjmp	80009290 <_vfprintf_r+0x1c90>
80009120:	fa f9 06 90 	ld.w	r9,sp[1680]
80009124:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009128:	40 6b       	lddsp	r11,sp[0x18]
8000912a:	16 3a       	cp.w	r10,r11
8000912c:	c6 f5       	brlt	8000920a <_vfprintf_r+0x1c0a>
8000912e:	16 09       	add	r9,r11
80009130:	2f f8       	sub	r8,-1
80009132:	87 06       	st.w	r3[0x0],r6
80009134:	fb 49 06 90 	st.w	sp[1680],r9
80009138:	87 1b       	st.w	r3[0x4],r11
8000913a:	fb 48 06 8c 	st.w	sp[1676],r8
8000913e:	58 78       	cp.w	r8,7
80009140:	e0 89 00 04 	brgt	80009148 <_vfprintf_r+0x1b48>
80009144:	2f 83       	sub	r3,-8
80009146:	c0 b8       	rjmp	8000915c <_vfprintf_r+0x1b5c>
80009148:	fa ca f9 78 	sub	r10,sp,-1672
8000914c:	02 9b       	mov	r11,r1
8000914e:	08 9c       	mov	r12,r4
80009150:	fe b0 f2 4a 	rcall	800075e4 <__sprint_r>
80009154:	e0 81 01 d5 	brne	800094fe <_vfprintf_r+0x1efe>
80009158:	fa c3 f9 e0 	sub	r3,sp,-1568
8000915c:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009160:	40 6a       	lddsp	r10,sp[0x18]
80009162:	14 16       	sub	r6,r10
80009164:	58 06       	cp.w	r6,0
80009166:	e0 89 00 1c 	brgt	8000919e <_vfprintf_r+0x1b9e>
8000916a:	c3 d8       	rjmp	800091e4 <_vfprintf_r+0x1be4>
8000916c:	2f 09       	sub	r9,-16
8000916e:	2f f8       	sub	r8,-1
80009170:	fb 49 06 90 	st.w	sp[1680],r9
80009174:	87 02       	st.w	r3[0x0],r2
80009176:	87 10       	st.w	r3[0x4],r0
80009178:	fb 48 06 8c 	st.w	sp[1676],r8
8000917c:	58 78       	cp.w	r8,7
8000917e:	e0 89 00 04 	brgt	80009186 <_vfprintf_r+0x1b86>
80009182:	2f 83       	sub	r3,-8
80009184:	c0 b8       	rjmp	8000919a <_vfprintf_r+0x1b9a>
80009186:	fa ca f9 78 	sub	r10,sp,-1672
8000918a:	02 9b       	mov	r11,r1
8000918c:	08 9c       	mov	r12,r4
8000918e:	fe b0 f2 2b 	rcall	800075e4 <__sprint_r>
80009192:	e0 81 01 b6 	brne	800094fe <_vfprintf_r+0x1efe>
80009196:	fa c3 f9 e0 	sub	r3,sp,-1568
8000919a:	21 06       	sub	r6,16
8000919c:	c0 48       	rjmp	800091a4 <_vfprintf_r+0x1ba4>
8000919e:	fe c2 c9 a2 	sub	r2,pc,-13918
800091a2:	31 00       	mov	r0,16
800091a4:	fa f9 06 90 	ld.w	r9,sp[1680]
800091a8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091ac:	fe ca c9 b0 	sub	r10,pc,-13904
800091b0:	59 06       	cp.w	r6,16
800091b2:	fe 99 ff dd 	brgt	8000916c <_vfprintf_r+0x1b6c>
800091b6:	0c 09       	add	r9,r6
800091b8:	2f f8       	sub	r8,-1
800091ba:	87 0a       	st.w	r3[0x0],r10
800091bc:	fb 49 06 90 	st.w	sp[1680],r9
800091c0:	87 16       	st.w	r3[0x4],r6
800091c2:	fb 48 06 8c 	st.w	sp[1676],r8
800091c6:	58 78       	cp.w	r8,7
800091c8:	e0 89 00 04 	brgt	800091d0 <_vfprintf_r+0x1bd0>
800091cc:	2f 83       	sub	r3,-8
800091ce:	c0 b8       	rjmp	800091e4 <_vfprintf_r+0x1be4>
800091d0:	fa ca f9 78 	sub	r10,sp,-1672
800091d4:	02 9b       	mov	r11,r1
800091d6:	08 9c       	mov	r12,r4
800091d8:	fe b0 f2 06 	rcall	800075e4 <__sprint_r>
800091dc:	e0 81 01 91 	brne	800094fe <_vfprintf_r+0x1efe>
800091e0:	fa c3 f9 e0 	sub	r3,sp,-1568
800091e4:	ed b5 00 00 	bld	r5,0x0
800091e8:	e0 81 01 20 	brne	80009428 <_vfprintf_r+0x1e28>
800091ec:	40 c9       	lddsp	r9,sp[0x30]
800091ee:	fa f8 06 90 	ld.w	r8,sp[1680]
800091f2:	2f f8       	sub	r8,-1
800091f4:	87 09       	st.w	r3[0x0],r9
800091f6:	fb 48 06 90 	st.w	sp[1680],r8
800091fa:	30 19       	mov	r9,1
800091fc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009200:	87 19       	st.w	r3[0x4],r9
80009202:	2f f8       	sub	r8,-1
80009204:	fb 48 06 8c 	st.w	sp[1676],r8
80009208:	c0 29       	rjmp	8000940c <_vfprintf_r+0x1e0c>
8000920a:	14 09       	add	r9,r10
8000920c:	2f f8       	sub	r8,-1
8000920e:	fb 49 06 90 	st.w	sp[1680],r9
80009212:	87 06       	st.w	r3[0x0],r6
80009214:	87 1a       	st.w	r3[0x4],r10
80009216:	fb 48 06 8c 	st.w	sp[1676],r8
8000921a:	58 78       	cp.w	r8,7
8000921c:	e0 89 00 04 	brgt	80009224 <_vfprintf_r+0x1c24>
80009220:	2f 83       	sub	r3,-8
80009222:	c0 b8       	rjmp	80009238 <_vfprintf_r+0x1c38>
80009224:	fa ca f9 78 	sub	r10,sp,-1672
80009228:	02 9b       	mov	r11,r1
8000922a:	08 9c       	mov	r12,r4
8000922c:	fe b0 f1 dc 	rcall	800075e4 <__sprint_r>
80009230:	e0 81 01 67 	brne	800094fe <_vfprintf_r+0x1efe>
80009234:	fa c3 f9 e0 	sub	r3,sp,-1568
80009238:	40 c8       	lddsp	r8,sp[0x30]
8000923a:	87 08       	st.w	r3[0x0],r8
8000923c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009240:	2f f8       	sub	r8,-1
80009242:	30 19       	mov	r9,1
80009244:	fb 48 06 90 	st.w	sp[1680],r8
80009248:	87 19       	st.w	r3[0x4],r9
8000924a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000924e:	2f f8       	sub	r8,-1
80009250:	fb 48 06 8c 	st.w	sp[1676],r8
80009254:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009258:	58 78       	cp.w	r8,7
8000925a:	e0 89 00 04 	brgt	80009262 <_vfprintf_r+0x1c62>
8000925e:	2f 83       	sub	r3,-8
80009260:	c0 b8       	rjmp	80009276 <_vfprintf_r+0x1c76>
80009262:	fa ca f9 78 	sub	r10,sp,-1672
80009266:	02 9b       	mov	r11,r1
80009268:	08 9c       	mov	r12,r4
8000926a:	fe b0 f1 bd 	rcall	800075e4 <__sprint_r>
8000926e:	e0 81 01 48 	brne	800094fe <_vfprintf_r+0x1efe>
80009272:	fa c3 f9 e0 	sub	r3,sp,-1568
80009276:	04 06       	add	r6,r2
80009278:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000927c:	87 06       	st.w	r3[0x0],r6
8000927e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009282:	40 66       	lddsp	r6,sp[0x18]
80009284:	40 6e       	lddsp	lr,sp[0x18]
80009286:	10 16       	sub	r6,r8
80009288:	f2 08 01 08 	sub	r8,r9,r8
8000928c:	87 16       	st.w	r3[0x4],r6
8000928e:	1c 08       	add	r8,lr
80009290:	fb 48 06 90 	st.w	sp[1680],r8
80009294:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009298:	2f f8       	sub	r8,-1
8000929a:	fb 48 06 8c 	st.w	sp[1676],r8
8000929e:	cb 78       	rjmp	8000940c <_vfprintf_r+0x1e0c>
800092a0:	40 6c       	lddsp	r12,sp[0x18]
800092a2:	58 1c       	cp.w	r12,1
800092a4:	e0 89 00 06 	brgt	800092b0 <_vfprintf_r+0x1cb0>
800092a8:	ed b5 00 00 	bld	r5,0x0
800092ac:	e0 81 00 85 	brne	800093b6 <_vfprintf_r+0x1db6>
800092b0:	fa f8 06 90 	ld.w	r8,sp[1680]
800092b4:	2f f8       	sub	r8,-1
800092b6:	30 19       	mov	r9,1
800092b8:	fb 48 06 90 	st.w	sp[1680],r8
800092bc:	87 06       	st.w	r3[0x0],r6
800092be:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092c2:	87 19       	st.w	r3[0x4],r9
800092c4:	2f f8       	sub	r8,-1
800092c6:	fb 48 06 8c 	st.w	sp[1676],r8
800092ca:	58 78       	cp.w	r8,7
800092cc:	e0 89 00 04 	brgt	800092d4 <_vfprintf_r+0x1cd4>
800092d0:	2f 83       	sub	r3,-8
800092d2:	c0 b8       	rjmp	800092e8 <_vfprintf_r+0x1ce8>
800092d4:	fa ca f9 78 	sub	r10,sp,-1672
800092d8:	02 9b       	mov	r11,r1
800092da:	08 9c       	mov	r12,r4
800092dc:	fe b0 f1 84 	rcall	800075e4 <__sprint_r>
800092e0:	e0 81 01 0f 	brne	800094fe <_vfprintf_r+0x1efe>
800092e4:	fa c3 f9 e0 	sub	r3,sp,-1568
800092e8:	fa f8 06 90 	ld.w	r8,sp[1680]
800092ec:	2f f8       	sub	r8,-1
800092ee:	40 cb       	lddsp	r11,sp[0x30]
800092f0:	fb 48 06 90 	st.w	sp[1680],r8
800092f4:	30 19       	mov	r9,1
800092f6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092fa:	87 0b       	st.w	r3[0x0],r11
800092fc:	2f f8       	sub	r8,-1
800092fe:	87 19       	st.w	r3[0x4],r9
80009300:	fb 48 06 8c 	st.w	sp[1676],r8
80009304:	58 78       	cp.w	r8,7
80009306:	e0 89 00 05 	brgt	80009310 <_vfprintf_r+0x1d10>
8000930a:	2f 83       	sub	r3,-8
8000930c:	c0 c8       	rjmp	80009324 <_vfprintf_r+0x1d24>
8000930e:	d7 03       	nop
80009310:	fa ca f9 78 	sub	r10,sp,-1672
80009314:	02 9b       	mov	r11,r1
80009316:	08 9c       	mov	r12,r4
80009318:	fe b0 f1 66 	rcall	800075e4 <__sprint_r>
8000931c:	e0 81 00 f1 	brne	800094fe <_vfprintf_r+0x1efe>
80009320:	fa c3 f9 e0 	sub	r3,sp,-1568
80009324:	30 08       	mov	r8,0
80009326:	30 09       	mov	r9,0
80009328:	40 5b       	lddsp	r11,sp[0x14]
8000932a:	40 7a       	lddsp	r10,sp[0x1c]
8000932c:	e0 a0 13 ff 	rcall	8000bb2a <__avr32_f64_cmp_eq>
80009330:	40 68       	lddsp	r8,sp[0x18]
80009332:	20 18       	sub	r8,1
80009334:	58 0c       	cp.w	r12,0
80009336:	c0 d1       	brne	80009350 <_vfprintf_r+0x1d50>
80009338:	2f f6       	sub	r6,-1
8000933a:	87 18       	st.w	r3[0x4],r8
8000933c:	87 06       	st.w	r3[0x0],r6
8000933e:	fa f6 06 90 	ld.w	r6,sp[1680]
80009342:	10 06       	add	r6,r8
80009344:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009348:	fb 46 06 90 	st.w	sp[1680],r6
8000934c:	2f f8       	sub	r8,-1
8000934e:	c3 18       	rjmp	800093b0 <_vfprintf_r+0x1db0>
80009350:	10 96       	mov	r6,r8
80009352:	58 08       	cp.w	r8,0
80009354:	e0 89 00 1c 	brgt	8000938c <_vfprintf_r+0x1d8c>
80009358:	c4 b8       	rjmp	800093ee <_vfprintf_r+0x1dee>
8000935a:	2f 09       	sub	r9,-16
8000935c:	2f f8       	sub	r8,-1
8000935e:	fb 49 06 90 	st.w	sp[1680],r9
80009362:	87 02       	st.w	r3[0x0],r2
80009364:	87 10       	st.w	r3[0x4],r0
80009366:	fb 48 06 8c 	st.w	sp[1676],r8
8000936a:	58 78       	cp.w	r8,7
8000936c:	e0 89 00 04 	brgt	80009374 <_vfprintf_r+0x1d74>
80009370:	2f 83       	sub	r3,-8
80009372:	c0 b8       	rjmp	80009388 <_vfprintf_r+0x1d88>
80009374:	fa ca f9 78 	sub	r10,sp,-1672
80009378:	02 9b       	mov	r11,r1
8000937a:	08 9c       	mov	r12,r4
8000937c:	fe b0 f1 34 	rcall	800075e4 <__sprint_r>
80009380:	e0 81 00 bf 	brne	800094fe <_vfprintf_r+0x1efe>
80009384:	fa c3 f9 e0 	sub	r3,sp,-1568
80009388:	21 06       	sub	r6,16
8000938a:	c0 48       	rjmp	80009392 <_vfprintf_r+0x1d92>
8000938c:	fe c2 cb 90 	sub	r2,pc,-13424
80009390:	31 00       	mov	r0,16
80009392:	fa f9 06 90 	ld.w	r9,sp[1680]
80009396:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000939a:	fe ca cb 9e 	sub	r10,pc,-13410
8000939e:	59 06       	cp.w	r6,16
800093a0:	fe 99 ff dd 	brgt	8000935a <_vfprintf_r+0x1d5a>
800093a4:	0c 09       	add	r9,r6
800093a6:	87 0a       	st.w	r3[0x0],r10
800093a8:	fb 49 06 90 	st.w	sp[1680],r9
800093ac:	2f f8       	sub	r8,-1
800093ae:	87 16       	st.w	r3[0x4],r6
800093b0:	fb 48 06 8c 	st.w	sp[1676],r8
800093b4:	c0 e8       	rjmp	800093d0 <_vfprintf_r+0x1dd0>
800093b6:	fa f8 06 90 	ld.w	r8,sp[1680]
800093ba:	2f f8       	sub	r8,-1
800093bc:	30 19       	mov	r9,1
800093be:	fb 48 06 90 	st.w	sp[1680],r8
800093c2:	87 06       	st.w	r3[0x0],r6
800093c4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093c8:	87 19       	st.w	r3[0x4],r9
800093ca:	2f f8       	sub	r8,-1
800093cc:	fb 48 06 8c 	st.w	sp[1676],r8
800093d0:	58 78       	cp.w	r8,7
800093d2:	e0 89 00 04 	brgt	800093da <_vfprintf_r+0x1dda>
800093d6:	2f 83       	sub	r3,-8
800093d8:	c0 b8       	rjmp	800093ee <_vfprintf_r+0x1dee>
800093da:	fa ca f9 78 	sub	r10,sp,-1672
800093de:	02 9b       	mov	r11,r1
800093e0:	08 9c       	mov	r12,r4
800093e2:	fe b0 f1 01 	rcall	800075e4 <__sprint_r>
800093e6:	e0 81 00 8c 	brne	800094fe <_vfprintf_r+0x1efe>
800093ea:	fa c3 f9 e0 	sub	r3,sp,-1568
800093ee:	40 ea       	lddsp	r10,sp[0x38]
800093f0:	fa f8 06 90 	ld.w	r8,sp[1680]
800093f4:	14 08       	add	r8,r10
800093f6:	fa c9 f9 64 	sub	r9,sp,-1692
800093fa:	fb 48 06 90 	st.w	sp[1680],r8
800093fe:	87 1a       	st.w	r3[0x4],r10
80009400:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009404:	87 09       	st.w	r3[0x0],r9
80009406:	2f f8       	sub	r8,-1
80009408:	fb 48 06 8c 	st.w	sp[1676],r8
8000940c:	58 78       	cp.w	r8,7
8000940e:	e0 89 00 04 	brgt	80009416 <_vfprintf_r+0x1e16>
80009412:	2f 83       	sub	r3,-8
80009414:	c0 a8       	rjmp	80009428 <_vfprintf_r+0x1e28>
80009416:	fa ca f9 78 	sub	r10,sp,-1672
8000941a:	02 9b       	mov	r11,r1
8000941c:	08 9c       	mov	r12,r4
8000941e:	fe b0 f0 e3 	rcall	800075e4 <__sprint_r>
80009422:	c6 e1       	brne	800094fe <_vfprintf_r+0x1efe>
80009424:	fa c3 f9 e0 	sub	r3,sp,-1568
80009428:	e2 15 00 04 	andl	r5,0x4,COH
8000942c:	c3 f0       	breq	800094aa <_vfprintf_r+0x1eaa>
8000942e:	40 86       	lddsp	r6,sp[0x20]
80009430:	40 39       	lddsp	r9,sp[0xc]
80009432:	12 16       	sub	r6,r9
80009434:	58 06       	cp.w	r6,0
80009436:	e0 89 00 1a 	brgt	8000946a <_vfprintf_r+0x1e6a>
8000943a:	c3 88       	rjmp	800094aa <_vfprintf_r+0x1eaa>
8000943c:	2f 09       	sub	r9,-16
8000943e:	2f f8       	sub	r8,-1
80009440:	fb 49 06 90 	st.w	sp[1680],r9
80009444:	87 05       	st.w	r3[0x0],r5
80009446:	87 12       	st.w	r3[0x4],r2
80009448:	fb 48 06 8c 	st.w	sp[1676],r8
8000944c:	58 78       	cp.w	r8,7
8000944e:	e0 89 00 04 	brgt	80009456 <_vfprintf_r+0x1e56>
80009452:	2f 83       	sub	r3,-8
80009454:	c0 98       	rjmp	80009466 <_vfprintf_r+0x1e66>
80009456:	00 9a       	mov	r10,r0
80009458:	02 9b       	mov	r11,r1
8000945a:	08 9c       	mov	r12,r4
8000945c:	fe b0 f0 c4 	rcall	800075e4 <__sprint_r>
80009460:	c4 f1       	brne	800094fe <_vfprintf_r+0x1efe>
80009462:	fa c3 f9 e0 	sub	r3,sp,-1568
80009466:	21 06       	sub	r6,16
80009468:	c0 68       	rjmp	80009474 <_vfprintf_r+0x1e74>
8000946a:	fe c5 cc 7e 	sub	r5,pc,-13186
8000946e:	31 02       	mov	r2,16
80009470:	fa c0 f9 78 	sub	r0,sp,-1672
80009474:	fa f9 06 90 	ld.w	r9,sp[1680]
80009478:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000947c:	fe ca cc 90 	sub	r10,pc,-13168
80009480:	59 06       	cp.w	r6,16
80009482:	fe 99 ff dd 	brgt	8000943c <_vfprintf_r+0x1e3c>
80009486:	0c 09       	add	r9,r6
80009488:	2f f8       	sub	r8,-1
8000948a:	87 0a       	st.w	r3[0x0],r10
8000948c:	87 16       	st.w	r3[0x4],r6
8000948e:	fb 49 06 90 	st.w	sp[1680],r9
80009492:	fb 48 06 8c 	st.w	sp[1676],r8
80009496:	58 78       	cp.w	r8,7
80009498:	e0 8a 00 09 	brle	800094aa <_vfprintf_r+0x1eaa>
8000949c:	fa ca f9 78 	sub	r10,sp,-1672
800094a0:	02 9b       	mov	r11,r1
800094a2:	08 9c       	mov	r12,r4
800094a4:	fe b0 f0 a0 	rcall	800075e4 <__sprint_r>
800094a8:	c2 b1       	brne	800094fe <_vfprintf_r+0x1efe>
800094aa:	40 bc       	lddsp	r12,sp[0x2c]
800094ac:	40 36       	lddsp	r6,sp[0xc]
800094ae:	40 8e       	lddsp	lr,sp[0x20]
800094b0:	ec 0e 0c 48 	max	r8,r6,lr
800094b4:	10 0c       	add	r12,r8
800094b6:	50 bc       	stdsp	sp[0x2c],r12
800094b8:	fa f8 06 90 	ld.w	r8,sp[1680]
800094bc:	58 08       	cp.w	r8,0
800094be:	c0 80       	breq	800094ce <_vfprintf_r+0x1ece>
800094c0:	fa ca f9 78 	sub	r10,sp,-1672
800094c4:	02 9b       	mov	r11,r1
800094c6:	08 9c       	mov	r12,r4
800094c8:	fe b0 f0 8e 	rcall	800075e4 <__sprint_r>
800094cc:	c1 91       	brne	800094fe <_vfprintf_r+0x1efe>
800094ce:	30 0b       	mov	r11,0
800094d0:	fa c3 f9 e0 	sub	r3,sp,-1568
800094d4:	fb 4b 06 8c 	st.w	sp[1676],r11
800094d8:	fe 9f f1 22 	bral	8000771c <_vfprintf_r+0x11c>
800094dc:	08 95       	mov	r5,r4
800094de:	fa f8 06 90 	ld.w	r8,sp[1680]
800094e2:	58 08       	cp.w	r8,0
800094e4:	c0 80       	breq	800094f4 <_vfprintf_r+0x1ef4>
800094e6:	08 9c       	mov	r12,r4
800094e8:	fa ca f9 78 	sub	r10,sp,-1672
800094ec:	02 9b       	mov	r11,r1
800094ee:	fe b0 f0 7b 	rcall	800075e4 <__sprint_r>
800094f2:	c0 61       	brne	800094fe <_vfprintf_r+0x1efe>
800094f4:	30 08       	mov	r8,0
800094f6:	fb 48 06 8c 	st.w	sp[1676],r8
800094fa:	c0 28       	rjmp	800094fe <_vfprintf_r+0x1efe>
800094fc:	40 41       	lddsp	r1,sp[0x10]
800094fe:	82 68       	ld.sh	r8,r1[0xc]
80009500:	ed b8 00 06 	bld	r8,0x6
80009504:	c0 31       	brne	8000950a <_vfprintf_r+0x1f0a>
80009506:	3f fa       	mov	r10,-1
80009508:	50 ba       	stdsp	sp[0x2c],r10
8000950a:	40 bc       	lddsp	r12,sp[0x2c]
8000950c:	fe 3d f9 44 	sub	sp,-1724
80009510:	d8 32       	popm	r0-r7,pc
80009512:	d7 03       	nop

80009514 <_vsprintf_r>:
80009514:	d4 01       	pushm	lr
80009516:	21 7d       	sub	sp,92
80009518:	e0 68 ff ff 	mov	r8,65535
8000951c:	ea 18 7f ff 	orh	r8,0x7fff
80009520:	50 58       	stdsp	sp[0x14],r8
80009522:	50 28       	stdsp	sp[0x8],r8
80009524:	e0 68 02 08 	mov	r8,520
80009528:	ba 68       	st.h	sp[0xc],r8
8000952a:	3f f8       	mov	r8,-1
8000952c:	50 4b       	stdsp	sp[0x10],r11
8000952e:	50 0b       	stdsp	sp[0x0],r11
80009530:	ba 78       	st.h	sp[0xe],r8
80009532:	1a 9b       	mov	r11,sp
80009534:	fe b0 f0 66 	rcall	80007600 <_vfprintf_r>
80009538:	30 09       	mov	r9,0
8000953a:	40 08       	lddsp	r8,sp[0x0]
8000953c:	b0 89       	st.b	r8[0x0],r9
8000953e:	2e 9d       	sub	sp,-92
80009540:	d8 02       	popm	pc
80009542:	d7 03       	nop

80009544 <vsprintf>:
80009544:	d4 01       	pushm	lr
80009546:	e0 68 01 18 	mov	r8,280
8000954a:	14 99       	mov	r9,r10
8000954c:	16 9a       	mov	r10,r11
8000954e:	18 9b       	mov	r11,r12
80009550:	70 0c       	ld.w	r12,r8[0x0]
80009552:	ce 1f       	rcall	80009514 <_vsprintf_r>
80009554:	d8 02       	popm	pc
80009556:	d7 03       	nop

80009558 <__swsetup_r>:
80009558:	d4 21       	pushm	r4-r7,lr
8000955a:	e0 68 01 18 	mov	r8,280
8000955e:	18 96       	mov	r6,r12
80009560:	16 97       	mov	r7,r11
80009562:	70 0c       	ld.w	r12,r8[0x0]
80009564:	58 0c       	cp.w	r12,0
80009566:	c0 60       	breq	80009572 <__swsetup_r+0x1a>
80009568:	78 68       	ld.w	r8,r12[0x18]
8000956a:	58 08       	cp.w	r8,0
8000956c:	c0 31       	brne	80009572 <__swsetup_r+0x1a>
8000956e:	e0 a0 08 77 	rcall	8000a65c <__sinit>
80009572:	fe c8 cc 56 	sub	r8,pc,-13226
80009576:	10 37       	cp.w	r7,r8
80009578:	c0 61       	brne	80009584 <__swsetup_r+0x2c>
8000957a:	e0 68 01 18 	mov	r8,280
8000957e:	70 08       	ld.w	r8,r8[0x0]
80009580:	70 07       	ld.w	r7,r8[0x0]
80009582:	c1 28       	rjmp	800095a6 <__swsetup_r+0x4e>
80009584:	fe c8 cc 48 	sub	r8,pc,-13240
80009588:	10 37       	cp.w	r7,r8
8000958a:	c0 61       	brne	80009596 <__swsetup_r+0x3e>
8000958c:	e0 68 01 18 	mov	r8,280
80009590:	70 08       	ld.w	r8,r8[0x0]
80009592:	70 17       	ld.w	r7,r8[0x4]
80009594:	c0 98       	rjmp	800095a6 <__swsetup_r+0x4e>
80009596:	fe c8 cc 3a 	sub	r8,pc,-13254
8000959a:	10 37       	cp.w	r7,r8
8000959c:	c0 51       	brne	800095a6 <__swsetup_r+0x4e>
8000959e:	e0 68 01 18 	mov	r8,280
800095a2:	70 08       	ld.w	r8,r8[0x0]
800095a4:	70 27       	ld.w	r7,r8[0x8]
800095a6:	8e 68       	ld.sh	r8,r7[0xc]
800095a8:	ed b8 00 03 	bld	r8,0x3
800095ac:	c1 e0       	breq	800095e8 <__swsetup_r+0x90>
800095ae:	ed b8 00 04 	bld	r8,0x4
800095b2:	c3 e1       	brne	8000962e <__swsetup_r+0xd6>
800095b4:	ed b8 00 02 	bld	r8,0x2
800095b8:	c1 51       	brne	800095e2 <__swsetup_r+0x8a>
800095ba:	6e db       	ld.w	r11,r7[0x34]
800095bc:	58 0b       	cp.w	r11,0
800095be:	c0 a0       	breq	800095d2 <__swsetup_r+0x7a>
800095c0:	ee c8 ff bc 	sub	r8,r7,-68
800095c4:	10 3b       	cp.w	r11,r8
800095c6:	c0 40       	breq	800095ce <__swsetup_r+0x76>
800095c8:	0c 9c       	mov	r12,r6
800095ca:	e0 a0 08 e3 	rcall	8000a790 <_free_r>
800095ce:	30 08       	mov	r8,0
800095d0:	8f d8       	st.w	r7[0x34],r8
800095d2:	8e 68       	ld.sh	r8,r7[0xc]
800095d4:	e0 18 ff db 	andl	r8,0xffdb
800095d8:	ae 68       	st.h	r7[0xc],r8
800095da:	30 08       	mov	r8,0
800095dc:	8f 18       	st.w	r7[0x4],r8
800095de:	6e 48       	ld.w	r8,r7[0x10]
800095e0:	8f 08       	st.w	r7[0x0],r8
800095e2:	8e 68       	ld.sh	r8,r7[0xc]
800095e4:	a3 b8       	sbr	r8,0x3
800095e6:	ae 68       	st.h	r7[0xc],r8
800095e8:	6e 48       	ld.w	r8,r7[0x10]
800095ea:	58 08       	cp.w	r8,0
800095ec:	c0 b1       	brne	80009602 <__swsetup_r+0xaa>
800095ee:	8e 68       	ld.sh	r8,r7[0xc]
800095f0:	e2 18 02 80 	andl	r8,0x280,COH
800095f4:	e0 48 02 00 	cp.w	r8,512
800095f8:	c0 50       	breq	80009602 <__swsetup_r+0xaa>
800095fa:	0c 9c       	mov	r12,r6
800095fc:	0e 9b       	mov	r11,r7
800095fe:	e0 a0 0b 03 	rcall	8000ac04 <__smakebuf_r>
80009602:	8e 69       	ld.sh	r9,r7[0xc]
80009604:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009608:	c0 70       	breq	80009616 <__swsetup_r+0xbe>
8000960a:	30 08       	mov	r8,0
8000960c:	8f 28       	st.w	r7[0x8],r8
8000960e:	6e 58       	ld.w	r8,r7[0x14]
80009610:	5c 38       	neg	r8
80009612:	8f 68       	st.w	r7[0x18],r8
80009614:	c0 68       	rjmp	80009620 <__swsetup_r+0xc8>
80009616:	ed b9 00 01 	bld	r9,0x1
8000961a:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000961e:	8f 28       	st.w	r7[0x8],r8
80009620:	6e 48       	ld.w	r8,r7[0x10]
80009622:	58 08       	cp.w	r8,0
80009624:	c0 61       	brne	80009630 <__swsetup_r+0xd8>
80009626:	8e 68       	ld.sh	r8,r7[0xc]
80009628:	ed b8 00 07 	bld	r8,0x7
8000962c:	c0 21       	brne	80009630 <__swsetup_r+0xd8>
8000962e:	dc 2a       	popm	r4-r7,pc,r12=-1
80009630:	d8 2a       	popm	r4-r7,pc,r12=0
80009632:	d7 03       	nop

80009634 <__register_exitproc>:
80009634:	d4 31       	pushm	r0-r7,lr
80009636:	fe c8 d1 02 	sub	r8,pc,-12030
8000963a:	70 03       	ld.w	r3,r8[0x0]
8000963c:	67 24       	ld.w	r4,r3[0x48]
8000963e:	e6 c8 ff b4 	sub	r8,r3,-76
80009642:	58 04       	cp.w	r4,0
80009644:	f0 04 17 00 	moveq	r4,r8
80009648:	e7 f4 0a 12 	st.weq	r3[0x48],r4
8000964c:	18 97       	mov	r7,r12
8000964e:	16 96       	mov	r6,r11
80009650:	14 95       	mov	r5,r10
80009652:	12 92       	mov	r2,r9
80009654:	68 18       	ld.w	r8,r4[0x4]
80009656:	59 f8       	cp.w	r8,31
80009658:	e0 8a 00 0e 	brle	80009674 <__register_exitproc+0x40>
8000965c:	e0 6c 00 8c 	mov	r12,140
80009660:	fe b0 e9 56 	rcall	8000690c <malloc>
80009664:	18 94       	mov	r4,r12
80009666:	c3 80       	breq	800096d6 <__register_exitproc+0xa2>
80009668:	67 28       	ld.w	r8,r3[0x48]
8000966a:	99 08       	st.w	r12[0x0],r8
8000966c:	e7 4c 00 48 	st.w	r3[72],r12
80009670:	30 08       	mov	r8,0
80009672:	99 18       	st.w	r12[0x4],r8
80009674:	58 07       	cp.w	r7,0
80009676:	c2 70       	breq	800096c4 <__register_exitproc+0x90>
80009678:	e8 fc 00 88 	ld.w	r12,r4[136]
8000967c:	58 0c       	cp.w	r12,0
8000967e:	c0 d1       	brne	80009698 <__register_exitproc+0x64>
80009680:	e0 6c 01 08 	mov	r12,264
80009684:	fe b0 e9 44 	rcall	8000690c <malloc>
80009688:	c2 70       	breq	800096d6 <__register_exitproc+0xa2>
8000968a:	30 08       	mov	r8,0
8000968c:	e9 4c 00 88 	st.w	r4[136],r12
80009690:	f9 48 01 04 	st.w	r12[260],r8
80009694:	f9 48 01 00 	st.w	r12[256],r8
80009698:	68 18       	ld.w	r8,r4[0x4]
8000969a:	f0 c9 ff e0 	sub	r9,r8,-32
8000969e:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
800096a2:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
800096a6:	30 1a       	mov	r10,1
800096a8:	f8 f9 01 00 	ld.w	r9,r12[256]
800096ac:	f4 08 09 48 	lsl	r8,r10,r8
800096b0:	10 49       	or	r9,r8
800096b2:	f9 49 01 00 	st.w	r12[256],r9
800096b6:	58 27       	cp.w	r7,2
800096b8:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
800096bc:	f3 d8 e0 38 	oreq	r8,r9,r8
800096c0:	f9 f8 0a 41 	st.weq	r12[0x104],r8
800096c4:	68 18       	ld.w	r8,r4[0x4]
800096c6:	30 0c       	mov	r12,0
800096c8:	f0 c9 ff ff 	sub	r9,r8,-1
800096cc:	2f e8       	sub	r8,-2
800096ce:	89 19       	st.w	r4[0x4],r9
800096d0:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
800096d4:	d8 32       	popm	r0-r7,pc
800096d6:	dc 3a       	popm	r0-r7,pc,r12=-1

800096d8 <__call_exitprocs>:
800096d8:	d4 31       	pushm	r0-r7,lr
800096da:	20 3d       	sub	sp,12
800096dc:	fe c8 d1 a8 	sub	r8,pc,-11864
800096e0:	50 2c       	stdsp	sp[0x8],r12
800096e2:	70 08       	ld.w	r8,r8[0x0]
800096e4:	16 91       	mov	r1,r11
800096e6:	50 08       	stdsp	sp[0x0],r8
800096e8:	2b 88       	sub	r8,-72
800096ea:	50 18       	stdsp	sp[0x4],r8
800096ec:	40 0a       	lddsp	r10,sp[0x0]
800096ee:	40 14       	lddsp	r4,sp[0x4]
800096f0:	75 27       	ld.w	r7,r10[0x48]
800096f2:	c5 58       	rjmp	8000979c <__call_exitprocs+0xc4>
800096f4:	6e 15       	ld.w	r5,r7[0x4]
800096f6:	ee f6 00 88 	ld.w	r6,r7[136]
800096fa:	ea c2 ff ff 	sub	r2,r5,-1
800096fe:	20 15       	sub	r5,1
80009700:	ee 02 00 22 	add	r2,r7,r2<<0x2
80009704:	ec 05 00 23 	add	r3,r6,r5<<0x2
80009708:	c3 58       	rjmp	80009772 <__call_exitprocs+0x9a>
8000970a:	58 01       	cp.w	r1,0
8000970c:	c0 70       	breq	8000971a <__call_exitprocs+0x42>
8000970e:	58 06       	cp.w	r6,0
80009710:	c2 e0       	breq	8000976c <__call_exitprocs+0x94>
80009712:	e6 f8 00 80 	ld.w	r8,r3[128]
80009716:	02 38       	cp.w	r8,r1
80009718:	c2 a1       	brne	8000976c <__call_exitprocs+0x94>
8000971a:	6e 19       	ld.w	r9,r7[0x4]
8000971c:	64 08       	ld.w	r8,r2[0x0]
8000971e:	20 19       	sub	r9,1
80009720:	12 35       	cp.w	r5,r9
80009722:	ef f5 0a 01 	st.weq	r7[0x4],r5
80009726:	f9 b9 01 00 	movne	r9,0
8000972a:	e5 f9 1a 00 	st.wne	r2[0x0],r9
8000972e:	58 08       	cp.w	r8,0
80009730:	c1 e0       	breq	8000976c <__call_exitprocs+0x94>
80009732:	6e 10       	ld.w	r0,r7[0x4]
80009734:	58 06       	cp.w	r6,0
80009736:	c0 90       	breq	80009748 <__call_exitprocs+0x70>
80009738:	30 1a       	mov	r10,1
8000973a:	f4 05 09 49 	lsl	r9,r10,r5
8000973e:	ec fa 01 00 	ld.w	r10,r6[256]
80009742:	f3 ea 00 0a 	and	r10,r9,r10
80009746:	c0 31       	brne	8000974c <__call_exitprocs+0x74>
80009748:	5d 18       	icall	r8
8000974a:	c0 b8       	rjmp	80009760 <__call_exitprocs+0x88>
8000974c:	ec fa 01 04 	ld.w	r10,r6[260]
80009750:	66 0b       	ld.w	r11,r3[0x0]
80009752:	14 69       	and	r9,r10
80009754:	c0 41       	brne	8000975c <__call_exitprocs+0x84>
80009756:	40 2c       	lddsp	r12,sp[0x8]
80009758:	5d 18       	icall	r8
8000975a:	c0 38       	rjmp	80009760 <__call_exitprocs+0x88>
8000975c:	16 9c       	mov	r12,r11
8000975e:	5d 18       	icall	r8
80009760:	6e 18       	ld.w	r8,r7[0x4]
80009762:	10 30       	cp.w	r0,r8
80009764:	cc 41       	brne	800096ec <__call_exitprocs+0x14>
80009766:	68 08       	ld.w	r8,r4[0x0]
80009768:	0e 38       	cp.w	r8,r7
8000976a:	cc 11       	brne	800096ec <__call_exitprocs+0x14>
8000976c:	20 15       	sub	r5,1
8000976e:	20 43       	sub	r3,4
80009770:	20 42       	sub	r2,4
80009772:	58 05       	cp.w	r5,0
80009774:	cc b4       	brge	8000970a <__call_exitprocs+0x32>
80009776:	6e 18       	ld.w	r8,r7[0x4]
80009778:	58 08       	cp.w	r8,0
8000977a:	c0 f1       	brne	80009798 <__call_exitprocs+0xc0>
8000977c:	6e 08       	ld.w	r8,r7[0x0]
8000977e:	58 08       	cp.w	r8,0
80009780:	c0 c0       	breq	80009798 <__call_exitprocs+0xc0>
80009782:	89 08       	st.w	r4[0x0],r8
80009784:	58 06       	cp.w	r6,0
80009786:	c0 40       	breq	8000978e <__call_exitprocs+0xb6>
80009788:	0c 9c       	mov	r12,r6
8000978a:	fe b0 e8 b9 	rcall	800068fc <free>
8000978e:	0e 9c       	mov	r12,r7
80009790:	fe b0 e8 b6 	rcall	800068fc <free>
80009794:	68 07       	ld.w	r7,r4[0x0]
80009796:	c0 38       	rjmp	8000979c <__call_exitprocs+0xc4>
80009798:	0e 94       	mov	r4,r7
8000979a:	6e 07       	ld.w	r7,r7[0x0]
8000979c:	58 07       	cp.w	r7,0
8000979e:	ca b1       	brne	800096f4 <__call_exitprocs+0x1c>
800097a0:	2f dd       	sub	sp,-12
800097a2:	d8 32       	popm	r0-r7,pc

800097a4 <quorem>:
800097a4:	d4 31       	pushm	r0-r7,lr
800097a6:	20 2d       	sub	sp,8
800097a8:	18 97       	mov	r7,r12
800097aa:	78 48       	ld.w	r8,r12[0x10]
800097ac:	76 46       	ld.w	r6,r11[0x10]
800097ae:	0c 38       	cp.w	r8,r6
800097b0:	c0 34       	brge	800097b6 <quorem+0x12>
800097b2:	30 0c       	mov	r12,0
800097b4:	c8 58       	rjmp	800098be <quorem+0x11a>
800097b6:	ec c2 ff fc 	sub	r2,r6,-4
800097ba:	f6 c3 ff ec 	sub	r3,r11,-20
800097be:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
800097c2:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
800097c6:	2f f9       	sub	r9,-1
800097c8:	20 16       	sub	r6,1
800097ca:	f8 09 0d 08 	divu	r8,r12,r9
800097ce:	f6 02 00 22 	add	r2,r11,r2<<0x2
800097d2:	ee c4 ff ec 	sub	r4,r7,-20
800097d6:	10 95       	mov	r5,r8
800097d8:	58 08       	cp.w	r8,0
800097da:	c4 10       	breq	8000985c <quorem+0xb8>
800097dc:	30 09       	mov	r9,0
800097de:	06 9a       	mov	r10,r3
800097e0:	08 98       	mov	r8,r4
800097e2:	12 91       	mov	r1,r9
800097e4:	50 0b       	stdsp	sp[0x0],r11
800097e6:	70 0e       	ld.w	lr,r8[0x0]
800097e8:	b1 8e       	lsr	lr,0x10
800097ea:	50 1e       	stdsp	sp[0x4],lr
800097ec:	15 0e       	ld.w	lr,r10++
800097ee:	fc 00 16 10 	lsr	r0,lr,0x10
800097f2:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800097f6:	ea 0e 03 41 	mac	r1,r5,lr
800097fa:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
800097fe:	b1 81       	lsr	r1,0x10
80009800:	40 1b       	lddsp	r11,sp[0x4]
80009802:	ea 00 02 40 	mul	r0,r5,r0
80009806:	e2 00 00 00 	add	r0,r1,r0
8000980a:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000980e:	02 1b       	sub	r11,r1
80009810:	50 1b       	stdsp	sp[0x4],r11
80009812:	70 0b       	ld.w	r11,r8[0x0]
80009814:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009818:	02 09       	add	r9,r1
8000981a:	f2 0e 01 0e 	sub	lr,r9,lr
8000981e:	b0 1e       	st.h	r8[0x2],lr
80009820:	fc 09 14 10 	asr	r9,lr,0x10
80009824:	40 1e       	lddsp	lr,sp[0x4]
80009826:	fc 09 00 09 	add	r9,lr,r9
8000982a:	b0 09       	st.h	r8[0x0],r9
8000982c:	e0 01 16 10 	lsr	r1,r0,0x10
80009830:	2f c8       	sub	r8,-4
80009832:	b1 49       	asr	r9,0x10
80009834:	04 3a       	cp.w	r10,r2
80009836:	fe 98 ff d8 	brls	800097e6 <quorem+0x42>
8000983a:	40 0b       	lddsp	r11,sp[0x0]
8000983c:	58 0c       	cp.w	r12,0
8000983e:	c0 f1       	brne	8000985c <quorem+0xb8>
80009840:	ec c8 ff fb 	sub	r8,r6,-5
80009844:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009848:	c0 28       	rjmp	8000984c <quorem+0xa8>
8000984a:	20 16       	sub	r6,1
8000984c:	20 48       	sub	r8,4
8000984e:	08 38       	cp.w	r8,r4
80009850:	e0 88 00 05 	brls	8000985a <quorem+0xb6>
80009854:	70 09       	ld.w	r9,r8[0x0]
80009856:	58 09       	cp.w	r9,0
80009858:	cf 90       	breq	8000984a <quorem+0xa6>
8000985a:	8f 46       	st.w	r7[0x10],r6
8000985c:	0e 9c       	mov	r12,r7
8000985e:	e0 a0 0a d2 	rcall	8000ae02 <__mcmp>
80009862:	c2 d5       	brlt	800098bc <quorem+0x118>
80009864:	2f f5       	sub	r5,-1
80009866:	08 98       	mov	r8,r4
80009868:	30 09       	mov	r9,0
8000986a:	07 0b       	ld.w	r11,r3++
8000986c:	f6 0a 16 10 	lsr	r10,r11,0x10
80009870:	70 0c       	ld.w	r12,r8[0x0]
80009872:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009876:	f8 0e 16 10 	lsr	lr,r12,0x10
8000987a:	14 1e       	sub	lr,r10
8000987c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009880:	16 1a       	sub	r10,r11
80009882:	12 0a       	add	r10,r9
80009884:	b0 1a       	st.h	r8[0x2],r10
80009886:	b1 4a       	asr	r10,0x10
80009888:	fc 0a 00 09 	add	r9,lr,r10
8000988c:	b0 09       	st.h	r8[0x0],r9
8000988e:	2f c8       	sub	r8,-4
80009890:	b1 49       	asr	r9,0x10
80009892:	04 33       	cp.w	r3,r2
80009894:	fe 98 ff eb 	brls	8000986a <quorem+0xc6>
80009898:	ec c8 ff fb 	sub	r8,r6,-5
8000989c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
800098a0:	58 09       	cp.w	r9,0
800098a2:	c0 d1       	brne	800098bc <quorem+0x118>
800098a4:	ee 08 00 28 	add	r8,r7,r8<<0x2
800098a8:	c0 28       	rjmp	800098ac <quorem+0x108>
800098aa:	20 16       	sub	r6,1
800098ac:	20 48       	sub	r8,4
800098ae:	08 38       	cp.w	r8,r4
800098b0:	e0 88 00 05 	brls	800098ba <quorem+0x116>
800098b4:	70 09       	ld.w	r9,r8[0x0]
800098b6:	58 09       	cp.w	r9,0
800098b8:	cf 90       	breq	800098aa <quorem+0x106>
800098ba:	8f 46       	st.w	r7[0x10],r6
800098bc:	0a 9c       	mov	r12,r5
800098be:	2f ed       	sub	sp,-8
800098c0:	d8 32       	popm	r0-r7,pc
800098c2:	d7 03       	nop

800098c4 <_dtoa_r>:
800098c4:	d4 31       	pushm	r0-r7,lr
800098c6:	21 ad       	sub	sp,104
800098c8:	fa c4 ff 74 	sub	r4,sp,-140
800098cc:	18 97       	mov	r7,r12
800098ce:	16 95       	mov	r5,r11
800098d0:	68 2c       	ld.w	r12,r4[0x8]
800098d2:	50 c9       	stdsp	sp[0x30],r9
800098d4:	68 16       	ld.w	r6,r4[0x4]
800098d6:	68 09       	ld.w	r9,r4[0x0]
800098d8:	50 e8       	stdsp	sp[0x38],r8
800098da:	14 94       	mov	r4,r10
800098dc:	51 2c       	stdsp	sp[0x48],r12
800098de:	fa e5 00 08 	st.d	sp[8],r4
800098e2:	51 59       	stdsp	sp[0x54],r9
800098e4:	6e 95       	ld.w	r5,r7[0x24]
800098e6:	58 05       	cp.w	r5,0
800098e8:	c0 91       	brne	800098fa <_dtoa_r+0x36>
800098ea:	31 0c       	mov	r12,16
800098ec:	fe b0 e8 10 	rcall	8000690c <malloc>
800098f0:	99 35       	st.w	r12[0xc],r5
800098f2:	8f 9c       	st.w	r7[0x24],r12
800098f4:	99 15       	st.w	r12[0x4],r5
800098f6:	99 25       	st.w	r12[0x8],r5
800098f8:	99 05       	st.w	r12[0x0],r5
800098fa:	6e 99       	ld.w	r9,r7[0x24]
800098fc:	72 08       	ld.w	r8,r9[0x0]
800098fe:	58 08       	cp.w	r8,0
80009900:	c0 f0       	breq	8000991e <_dtoa_r+0x5a>
80009902:	72 1a       	ld.w	r10,r9[0x4]
80009904:	91 1a       	st.w	r8[0x4],r10
80009906:	30 1a       	mov	r10,1
80009908:	72 19       	ld.w	r9,r9[0x4]
8000990a:	f4 09 09 49 	lsl	r9,r10,r9
8000990e:	10 9b       	mov	r11,r8
80009910:	91 29       	st.w	r8[0x8],r9
80009912:	0e 9c       	mov	r12,r7
80009914:	e0 a0 0a 90 	rcall	8000ae34 <_Bfree>
80009918:	6e 98       	ld.w	r8,r7[0x24]
8000991a:	30 09       	mov	r9,0
8000991c:	91 09       	st.w	r8[0x0],r9
8000991e:	40 28       	lddsp	r8,sp[0x8]
80009920:	10 94       	mov	r4,r8
80009922:	58 08       	cp.w	r8,0
80009924:	c0 64       	brge	80009930 <_dtoa_r+0x6c>
80009926:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000992a:	50 28       	stdsp	sp[0x8],r8
8000992c:	30 18       	mov	r8,1
8000992e:	c0 28       	rjmp	80009932 <_dtoa_r+0x6e>
80009930:	30 08       	mov	r8,0
80009932:	8d 08       	st.w	r6[0x0],r8
80009934:	fc 1c 7f f0 	movh	r12,0x7ff0
80009938:	40 26       	lddsp	r6,sp[0x8]
8000993a:	0c 98       	mov	r8,r6
8000993c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009940:	18 38       	cp.w	r8,r12
80009942:	c2 01       	brne	80009982 <_dtoa_r+0xbe>
80009944:	e0 68 27 0f 	mov	r8,9999
80009948:	41 5b       	lddsp	r11,sp[0x54]
8000994a:	97 08       	st.w	r11[0x0],r8
8000994c:	40 3a       	lddsp	r10,sp[0xc]
8000994e:	58 0a       	cp.w	r10,0
80009950:	c0 71       	brne	8000995e <_dtoa_r+0x9a>
80009952:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009956:	c0 41       	brne	8000995e <_dtoa_r+0x9a>
80009958:	fe cc d0 4c 	sub	r12,pc,-12212
8000995c:	c0 38       	rjmp	80009962 <_dtoa_r+0x9e>
8000995e:	fe cc d0 46 	sub	r12,pc,-12218
80009962:	41 29       	lddsp	r9,sp[0x48]
80009964:	58 09       	cp.w	r9,0
80009966:	e0 80 05 9a 	breq	8000a49a <_dtoa_r+0xbd6>
8000996a:	f8 c8 ff fd 	sub	r8,r12,-3
8000996e:	f8 c9 ff f8 	sub	r9,r12,-8
80009972:	11 8b       	ld.ub	r11,r8[0x0]
80009974:	30 0a       	mov	r10,0
80009976:	41 25       	lddsp	r5,sp[0x48]
80009978:	f4 0b 18 00 	cp.b	r11,r10
8000997c:	f2 08 17 10 	movne	r8,r9
80009980:	c1 68       	rjmp	800099ac <_dtoa_r+0xe8>
80009982:	fa ea 00 08 	ld.d	r10,sp[8]
80009986:	30 08       	mov	r8,0
80009988:	fa eb 00 3c 	st.d	sp[60],r10
8000998c:	30 09       	mov	r9,0
8000998e:	e0 a0 10 ce 	rcall	8000bb2a <__avr32_f64_cmp_eq>
80009992:	c1 00       	breq	800099b2 <_dtoa_r+0xee>
80009994:	30 18       	mov	r8,1
80009996:	41 5a       	lddsp	r10,sp[0x54]
80009998:	95 08       	st.w	r10[0x0],r8
8000999a:	fe cc d1 b2 	sub	r12,pc,-11854
8000999e:	41 29       	lddsp	r9,sp[0x48]
800099a0:	f8 08 00 08 	add	r8,r12,r8
800099a4:	58 09       	cp.w	r9,0
800099a6:	e0 80 05 7a 	breq	8000a49a <_dtoa_r+0xbd6>
800099aa:	12 95       	mov	r5,r9
800099ac:	8b 08       	st.w	r5[0x0],r8
800099ae:	e0 8f 05 76 	bral	8000a49a <_dtoa_r+0xbd6>
800099b2:	fa c8 ff 9c 	sub	r8,sp,-100
800099b6:	fa c9 ff a0 	sub	r9,sp,-96
800099ba:	fa ea 00 3c 	ld.d	r10,sp[60]
800099be:	0e 9c       	mov	r12,r7
800099c0:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
800099c4:	e0 a0 0a 8a 	rcall	8000aed8 <__d2b>
800099c8:	18 93       	mov	r3,r12
800099ca:	58 05       	cp.w	r5,0
800099cc:	c0 d0       	breq	800099e6 <_dtoa_r+0x122>
800099ce:	fa ea 00 3c 	ld.d	r10,sp[60]
800099d2:	30 04       	mov	r4,0
800099d4:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
800099d8:	ea c5 03 ff 	sub	r5,r5,1023
800099dc:	10 9b       	mov	r11,r8
800099de:	51 74       	stdsp	sp[0x5c],r4
800099e0:	ea 1b 3f f0 	orh	r11,0x3ff0
800099e4:	c2 58       	rjmp	80009a2e <_dtoa_r+0x16a>
800099e6:	41 88       	lddsp	r8,sp[0x60]
800099e8:	41 9c       	lddsp	r12,sp[0x64]
800099ea:	10 0c       	add	r12,r8
800099ec:	f8 c5 fb ce 	sub	r5,r12,-1074
800099f0:	e0 45 00 20 	cp.w	r5,32
800099f4:	e0 8a 00 0e 	brle	80009a10 <_dtoa_r+0x14c>
800099f8:	f8 cc fb ee 	sub	r12,r12,-1042
800099fc:	40 3b       	lddsp	r11,sp[0xc]
800099fe:	ea 08 11 40 	rsub	r8,r5,64
80009a02:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009a06:	ec 08 09 46 	lsl	r6,r6,r8
80009a0a:	0c 4c       	or	r12,r6
80009a0c:	c0 78       	rjmp	80009a1a <_dtoa_r+0x156>
80009a0e:	d7 03       	nop
80009a10:	ea 0c 11 20 	rsub	r12,r5,32
80009a14:	40 3a       	lddsp	r10,sp[0xc]
80009a16:	f4 0c 09 4c 	lsl	r12,r10,r12
80009a1a:	e0 a0 10 14 	rcall	8000ba42 <__avr32_u32_to_f64>
80009a1e:	fc 18 fe 10 	movh	r8,0xfe10
80009a22:	30 19       	mov	r9,1
80009a24:	ea c5 04 33 	sub	r5,r5,1075
80009a28:	f0 0b 00 0b 	add	r11,r8,r11
80009a2c:	51 79       	stdsp	sp[0x5c],r9
80009a2e:	30 08       	mov	r8,0
80009a30:	fc 19 3f f8 	movh	r9,0x3ff8
80009a34:	e0 a0 0e 9c 	rcall	8000b76c <__avr32_f64_sub>
80009a38:	e0 68 43 61 	mov	r8,17249
80009a3c:	ea 18 63 6f 	orh	r8,0x636f
80009a40:	e0 69 87 a7 	mov	r9,34727
80009a44:	ea 19 3f d2 	orh	r9,0x3fd2
80009a48:	e0 a0 0d a6 	rcall	8000b594 <__avr32_f64_mul>
80009a4c:	e0 68 c8 b3 	mov	r8,51379
80009a50:	ea 18 8b 60 	orh	r8,0x8b60
80009a54:	e0 69 8a 28 	mov	r9,35368
80009a58:	ea 19 3f c6 	orh	r9,0x3fc6
80009a5c:	e0 a0 0f 56 	rcall	8000b908 <__avr32_f64_add>
80009a60:	0a 9c       	mov	r12,r5
80009a62:	14 90       	mov	r0,r10
80009a64:	16 91       	mov	r1,r11
80009a66:	e0 a0 0f f2 	rcall	8000ba4a <__avr32_s32_to_f64>
80009a6a:	e0 68 79 fb 	mov	r8,31227
80009a6e:	ea 18 50 9f 	orh	r8,0x509f
80009a72:	e0 69 44 13 	mov	r9,17427
80009a76:	ea 19 3f d3 	orh	r9,0x3fd3
80009a7a:	e0 a0 0d 8d 	rcall	8000b594 <__avr32_f64_mul>
80009a7e:	14 98       	mov	r8,r10
80009a80:	16 99       	mov	r9,r11
80009a82:	00 9a       	mov	r10,r0
80009a84:	02 9b       	mov	r11,r1
80009a86:	e0 a0 0f 41 	rcall	8000b908 <__avr32_f64_add>
80009a8a:	14 90       	mov	r0,r10
80009a8c:	16 91       	mov	r1,r11
80009a8e:	e0 a0 0f c7 	rcall	8000ba1c <__avr32_f64_to_s32>
80009a92:	30 08       	mov	r8,0
80009a94:	18 96       	mov	r6,r12
80009a96:	30 09       	mov	r9,0
80009a98:	00 9a       	mov	r10,r0
80009a9a:	02 9b       	mov	r11,r1
80009a9c:	e0 a0 10 8e 	rcall	8000bbb8 <__avr32_f64_cmp_lt>
80009aa0:	c0 c0       	breq	80009ab8 <_dtoa_r+0x1f4>
80009aa2:	0c 9c       	mov	r12,r6
80009aa4:	e0 a0 0f d3 	rcall	8000ba4a <__avr32_s32_to_f64>
80009aa8:	14 98       	mov	r8,r10
80009aaa:	16 99       	mov	r9,r11
80009aac:	00 9a       	mov	r10,r0
80009aae:	02 9b       	mov	r11,r1
80009ab0:	e0 a0 10 3d 	rcall	8000bb2a <__avr32_f64_cmp_eq>
80009ab4:	f7 b6 00 01 	subeq	r6,1
80009ab8:	59 66       	cp.w	r6,22
80009aba:	e0 88 00 05 	brls	80009ac4 <_dtoa_r+0x200>
80009abe:	30 18       	mov	r8,1
80009ac0:	51 48       	stdsp	sp[0x50],r8
80009ac2:	c1 38       	rjmp	80009ae8 <_dtoa_r+0x224>
80009ac4:	fe c8 d0 fc 	sub	r8,pc,-12036
80009ac8:	fa ea 00 3c 	ld.d	r10,sp[60]
80009acc:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009ad0:	e0 a0 10 74 	rcall	8000bbb8 <__avr32_f64_cmp_lt>
80009ad4:	f9 b4 00 00 	moveq	r4,0
80009ad8:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009adc:	f7 b6 01 01 	subne	r6,1
80009ae0:	f9 bc 01 00 	movne	r12,0
80009ae4:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009ae8:	41 90       	lddsp	r0,sp[0x64]
80009aea:	20 10       	sub	r0,1
80009aec:	0a 10       	sub	r0,r5
80009aee:	c0 46       	brmi	80009af6 <_dtoa_r+0x232>
80009af0:	50 40       	stdsp	sp[0x10],r0
80009af2:	30 00       	mov	r0,0
80009af4:	c0 48       	rjmp	80009afc <_dtoa_r+0x238>
80009af6:	30 0b       	mov	r11,0
80009af8:	5c 30       	neg	r0
80009afa:	50 4b       	stdsp	sp[0x10],r11
80009afc:	ec 02 11 00 	rsub	r2,r6,0
80009b00:	58 06       	cp.w	r6,0
80009b02:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009b06:	f5 d6 e4 0a 	addge	r10,r10,r6
80009b0a:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009b0e:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009b12:	f9 b2 04 00 	movge	r2,0
80009b16:	e1 d6 e5 10 	sublt	r0,r0,r6
80009b1a:	f9 b9 05 00 	movlt	r9,0
80009b1e:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009b22:	40 c8       	lddsp	r8,sp[0x30]
80009b24:	58 98       	cp.w	r8,9
80009b26:	e0 8b 00 20 	brhi	80009b66 <_dtoa_r+0x2a2>
80009b2a:	58 58       	cp.w	r8,5
80009b2c:	f9 b4 0a 01 	movle	r4,1
80009b30:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009b34:	f7 b5 09 04 	subgt	r5,4
80009b38:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009b3c:	f9 b4 09 00 	movgt	r4,0
80009b40:	40 cc       	lddsp	r12,sp[0x30]
80009b42:	58 3c       	cp.w	r12,3
80009b44:	c2 d0       	breq	80009b9e <_dtoa_r+0x2da>
80009b46:	e0 89 00 05 	brgt	80009b50 <_dtoa_r+0x28c>
80009b4a:	58 2c       	cp.w	r12,2
80009b4c:	c1 01       	brne	80009b6c <_dtoa_r+0x2a8>
80009b4e:	c1 88       	rjmp	80009b7e <_dtoa_r+0x2ba>
80009b50:	40 cb       	lddsp	r11,sp[0x30]
80009b52:	58 4b       	cp.w	r11,4
80009b54:	c0 60       	breq	80009b60 <_dtoa_r+0x29c>
80009b56:	58 5b       	cp.w	r11,5
80009b58:	c0 a1       	brne	80009b6c <_dtoa_r+0x2a8>
80009b5a:	30 1a       	mov	r10,1
80009b5c:	50 da       	stdsp	sp[0x34],r10
80009b5e:	c2 28       	rjmp	80009ba2 <_dtoa_r+0x2de>
80009b60:	30 19       	mov	r9,1
80009b62:	50 d9       	stdsp	sp[0x34],r9
80009b64:	c0 f8       	rjmp	80009b82 <_dtoa_r+0x2be>
80009b66:	30 08       	mov	r8,0
80009b68:	30 14       	mov	r4,1
80009b6a:	50 c8       	stdsp	sp[0x30],r8
80009b6c:	3f f5       	mov	r5,-1
80009b6e:	30 1c       	mov	r12,1
80009b70:	30 0b       	mov	r11,0
80009b72:	50 95       	stdsp	sp[0x24],r5
80009b74:	50 dc       	stdsp	sp[0x34],r12
80009b76:	0a 91       	mov	r1,r5
80009b78:	31 28       	mov	r8,18
80009b7a:	50 eb       	stdsp	sp[0x38],r11
80009b7c:	c2 08       	rjmp	80009bbc <_dtoa_r+0x2f8>
80009b7e:	30 0a       	mov	r10,0
80009b80:	50 da       	stdsp	sp[0x34],r10
80009b82:	40 e9       	lddsp	r9,sp[0x38]
80009b84:	58 09       	cp.w	r9,0
80009b86:	e0 89 00 07 	brgt	80009b94 <_dtoa_r+0x2d0>
80009b8a:	30 18       	mov	r8,1
80009b8c:	50 98       	stdsp	sp[0x24],r8
80009b8e:	10 91       	mov	r1,r8
80009b90:	50 e8       	stdsp	sp[0x38],r8
80009b92:	c1 58       	rjmp	80009bbc <_dtoa_r+0x2f8>
80009b94:	40 e5       	lddsp	r5,sp[0x38]
80009b96:	50 95       	stdsp	sp[0x24],r5
80009b98:	0a 91       	mov	r1,r5
80009b9a:	0a 98       	mov	r8,r5
80009b9c:	c1 08       	rjmp	80009bbc <_dtoa_r+0x2f8>
80009b9e:	30 0c       	mov	r12,0
80009ba0:	50 dc       	stdsp	sp[0x34],r12
80009ba2:	40 eb       	lddsp	r11,sp[0x38]
80009ba4:	ec 0b 00 0b 	add	r11,r6,r11
80009ba8:	50 9b       	stdsp	sp[0x24],r11
80009baa:	16 98       	mov	r8,r11
80009bac:	2f f8       	sub	r8,-1
80009bae:	58 08       	cp.w	r8,0
80009bb0:	e0 89 00 05 	brgt	80009bba <_dtoa_r+0x2f6>
80009bb4:	10 91       	mov	r1,r8
80009bb6:	30 18       	mov	r8,1
80009bb8:	c0 28       	rjmp	80009bbc <_dtoa_r+0x2f8>
80009bba:	10 91       	mov	r1,r8
80009bbc:	30 09       	mov	r9,0
80009bbe:	6e 9a       	ld.w	r10,r7[0x24]
80009bc0:	95 19       	st.w	r10[0x4],r9
80009bc2:	30 49       	mov	r9,4
80009bc4:	c0 68       	rjmp	80009bd0 <_dtoa_r+0x30c>
80009bc6:	d7 03       	nop
80009bc8:	6a 1a       	ld.w	r10,r5[0x4]
80009bca:	a1 79       	lsl	r9,0x1
80009bcc:	2f fa       	sub	r10,-1
80009bce:	8b 1a       	st.w	r5[0x4],r10
80009bd0:	6e 95       	ld.w	r5,r7[0x24]
80009bd2:	f2 ca ff ec 	sub	r10,r9,-20
80009bd6:	10 3a       	cp.w	r10,r8
80009bd8:	fe 98 ff f8 	brls	80009bc8 <_dtoa_r+0x304>
80009bdc:	6a 1b       	ld.w	r11,r5[0x4]
80009bde:	0e 9c       	mov	r12,r7
80009be0:	e0 a0 09 44 	rcall	8000ae68 <_Balloc>
80009be4:	58 e1       	cp.w	r1,14
80009be6:	5f 88       	srls	r8
80009be8:	8b 0c       	st.w	r5[0x0],r12
80009bea:	f1 e4 00 04 	and	r4,r8,r4
80009bee:	6e 98       	ld.w	r8,r7[0x24]
80009bf0:	70 08       	ld.w	r8,r8[0x0]
80009bf2:	50 88       	stdsp	sp[0x20],r8
80009bf4:	e0 80 01 82 	breq	80009ef8 <_dtoa_r+0x634>
80009bf8:	58 06       	cp.w	r6,0
80009bfa:	e0 8a 00 43 	brle	80009c80 <_dtoa_r+0x3bc>
80009bfe:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009c02:	fe c8 d2 3a 	sub	r8,pc,-11718
80009c06:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009c0a:	fa e5 00 18 	st.d	sp[24],r4
80009c0e:	ec 04 14 04 	asr	r4,r6,0x4
80009c12:	ed b4 00 04 	bld	r4,0x4
80009c16:	c0 30       	breq	80009c1c <_dtoa_r+0x358>
80009c18:	30 25       	mov	r5,2
80009c1a:	c1 08       	rjmp	80009c3a <_dtoa_r+0x376>
80009c1c:	fe c8 d1 8c 	sub	r8,pc,-11892
80009c20:	f0 e8 00 20 	ld.d	r8,r8[32]
80009c24:	fa ea 00 3c 	ld.d	r10,sp[60]
80009c28:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009c2c:	e0 a0 0f fa 	rcall	8000bc20 <__avr32_f64_div>
80009c30:	30 35       	mov	r5,3
80009c32:	14 98       	mov	r8,r10
80009c34:	16 99       	mov	r9,r11
80009c36:	fa e9 00 08 	st.d	sp[8],r8
80009c3a:	fe cc d1 aa 	sub	r12,pc,-11862
80009c3e:	50 a3       	stdsp	sp[0x28],r3
80009c40:	0c 93       	mov	r3,r6
80009c42:	18 96       	mov	r6,r12
80009c44:	c0 f8       	rjmp	80009c62 <_dtoa_r+0x39e>
80009c46:	fa ea 00 18 	ld.d	r10,sp[24]
80009c4a:	ed b4 00 00 	bld	r4,0x0
80009c4e:	c0 81       	brne	80009c5e <_dtoa_r+0x39a>
80009c50:	ec e8 00 00 	ld.d	r8,r6[0]
80009c54:	2f f5       	sub	r5,-1
80009c56:	e0 a0 0c 9f 	rcall	8000b594 <__avr32_f64_mul>
80009c5a:	fa eb 00 18 	st.d	sp[24],r10
80009c5e:	a1 54       	asr	r4,0x1
80009c60:	2f 86       	sub	r6,-8
80009c62:	58 04       	cp.w	r4,0
80009c64:	cf 11       	brne	80009c46 <_dtoa_r+0x382>
80009c66:	fa e8 00 18 	ld.d	r8,sp[24]
80009c6a:	fa ea 00 08 	ld.d	r10,sp[8]
80009c6e:	06 96       	mov	r6,r3
80009c70:	e0 a0 0f d8 	rcall	8000bc20 <__avr32_f64_div>
80009c74:	40 a3       	lddsp	r3,sp[0x28]
80009c76:	14 98       	mov	r8,r10
80009c78:	16 99       	mov	r9,r11
80009c7a:	fa e9 00 08 	st.d	sp[8],r8
80009c7e:	c2 f8       	rjmp	80009cdc <_dtoa_r+0x418>
80009c80:	ec 08 11 00 	rsub	r8,r6,0
80009c84:	c0 31       	brne	80009c8a <_dtoa_r+0x3c6>
80009c86:	30 25       	mov	r5,2
80009c88:	c2 a8       	rjmp	80009cdc <_dtoa_r+0x418>
80009c8a:	fe cc d1 fa 	sub	r12,pc,-11782
80009c8e:	f0 04 14 04 	asr	r4,r8,0x4
80009c92:	50 1c       	stdsp	sp[0x4],r12
80009c94:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009c98:	fe c9 d2 d0 	sub	r9,pc,-11568
80009c9c:	fa ea 00 3c 	ld.d	r10,sp[60]
80009ca0:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009ca4:	e0 a0 0c 78 	rcall	8000b594 <__avr32_f64_mul>
80009ca8:	40 1c       	lddsp	r12,sp[0x4]
80009caa:	50 63       	stdsp	sp[0x18],r3
80009cac:	30 25       	mov	r5,2
80009cae:	0c 93       	mov	r3,r6
80009cb0:	fa eb 00 08 	st.d	sp[8],r10
80009cb4:	18 96       	mov	r6,r12
80009cb6:	c0 f8       	rjmp	80009cd4 <_dtoa_r+0x410>
80009cb8:	fa ea 00 08 	ld.d	r10,sp[8]
80009cbc:	ed b4 00 00 	bld	r4,0x0
80009cc0:	c0 81       	brne	80009cd0 <_dtoa_r+0x40c>
80009cc2:	ec e8 00 00 	ld.d	r8,r6[0]
80009cc6:	2f f5       	sub	r5,-1
80009cc8:	e0 a0 0c 66 	rcall	8000b594 <__avr32_f64_mul>
80009ccc:	fa eb 00 08 	st.d	sp[8],r10
80009cd0:	a1 54       	asr	r4,0x1
80009cd2:	2f 86       	sub	r6,-8
80009cd4:	58 04       	cp.w	r4,0
80009cd6:	cf 11       	brne	80009cb8 <_dtoa_r+0x3f4>
80009cd8:	06 96       	mov	r6,r3
80009cda:	40 63       	lddsp	r3,sp[0x18]
80009cdc:	41 4a       	lddsp	r10,sp[0x50]
80009cde:	58 0a       	cp.w	r10,0
80009ce0:	c2 a0       	breq	80009d34 <_dtoa_r+0x470>
80009ce2:	fa e8 00 08 	ld.d	r8,sp[8]
80009ce6:	58 01       	cp.w	r1,0
80009ce8:	5f 94       	srgt	r4
80009cea:	fa e9 00 18 	st.d	sp[24],r8
80009cee:	30 08       	mov	r8,0
80009cf0:	fc 19 3f f0 	movh	r9,0x3ff0
80009cf4:	fa ea 00 18 	ld.d	r10,sp[24]
80009cf8:	e0 a0 0f 60 	rcall	8000bbb8 <__avr32_f64_cmp_lt>
80009cfc:	f9 bc 00 00 	moveq	r12,0
80009d00:	f9 bc 01 01 	movne	r12,1
80009d04:	e9 ec 00 0c 	and	r12,r4,r12
80009d08:	c1 60       	breq	80009d34 <_dtoa_r+0x470>
80009d0a:	40 98       	lddsp	r8,sp[0x24]
80009d0c:	58 08       	cp.w	r8,0
80009d0e:	e0 8a 00 f1 	brle	80009ef0 <_dtoa_r+0x62c>
80009d12:	30 08       	mov	r8,0
80009d14:	fc 19 40 24 	movh	r9,0x4024
80009d18:	ec c4 00 01 	sub	r4,r6,1
80009d1c:	fa ea 00 18 	ld.d	r10,sp[24]
80009d20:	2f f5       	sub	r5,-1
80009d22:	50 64       	stdsp	sp[0x18],r4
80009d24:	e0 a0 0c 38 	rcall	8000b594 <__avr32_f64_mul>
80009d28:	40 94       	lddsp	r4,sp[0x24]
80009d2a:	14 98       	mov	r8,r10
80009d2c:	16 99       	mov	r9,r11
80009d2e:	fa e9 00 08 	st.d	sp[8],r8
80009d32:	c0 38       	rjmp	80009d38 <_dtoa_r+0x474>
80009d34:	50 66       	stdsp	sp[0x18],r6
80009d36:	02 94       	mov	r4,r1
80009d38:	0a 9c       	mov	r12,r5
80009d3a:	e0 a0 0e 88 	rcall	8000ba4a <__avr32_s32_to_f64>
80009d3e:	fa e8 00 08 	ld.d	r8,sp[8]
80009d42:	e0 a0 0c 29 	rcall	8000b594 <__avr32_f64_mul>
80009d46:	30 08       	mov	r8,0
80009d48:	fc 19 40 1c 	movh	r9,0x401c
80009d4c:	e0 a0 0d de 	rcall	8000b908 <__avr32_f64_add>
80009d50:	14 98       	mov	r8,r10
80009d52:	16 99       	mov	r9,r11
80009d54:	fa e9 00 28 	st.d	sp[40],r8
80009d58:	fc 18 fc c0 	movh	r8,0xfcc0
80009d5c:	40 a5       	lddsp	r5,sp[0x28]
80009d5e:	10 05       	add	r5,r8
80009d60:	50 a5       	stdsp	sp[0x28],r5
80009d62:	58 04       	cp.w	r4,0
80009d64:	c2 11       	brne	80009da6 <_dtoa_r+0x4e2>
80009d66:	fa ea 00 08 	ld.d	r10,sp[8]
80009d6a:	30 08       	mov	r8,0
80009d6c:	fc 19 40 14 	movh	r9,0x4014
80009d70:	e0 a0 0c fe 	rcall	8000b76c <__avr32_f64_sub>
80009d74:	40 bc       	lddsp	r12,sp[0x2c]
80009d76:	fa eb 00 08 	st.d	sp[8],r10
80009d7a:	14 98       	mov	r8,r10
80009d7c:	16 99       	mov	r9,r11
80009d7e:	18 9a       	mov	r10,r12
80009d80:	0a 9b       	mov	r11,r5
80009d82:	e0 a0 0f 1b 	rcall	8000bbb8 <__avr32_f64_cmp_lt>
80009d86:	e0 81 02 54 	brne	8000a22e <_dtoa_r+0x96a>
80009d8a:	0a 98       	mov	r8,r5
80009d8c:	40 b9       	lddsp	r9,sp[0x2c]
80009d8e:	ee 18 80 00 	eorh	r8,0x8000
80009d92:	fa ea 00 08 	ld.d	r10,sp[8]
80009d96:	10 95       	mov	r5,r8
80009d98:	12 98       	mov	r8,r9
80009d9a:	0a 99       	mov	r9,r5
80009d9c:	e0 a0 0f 0e 	rcall	8000bbb8 <__avr32_f64_cmp_lt>
80009da0:	e0 81 02 3e 	brne	8000a21c <_dtoa_r+0x958>
80009da4:	ca 68       	rjmp	80009ef0 <_dtoa_r+0x62c>
80009da6:	fe c9 d3 de 	sub	r9,pc,-11298
80009daa:	e8 c8 00 01 	sub	r8,r4,1
80009dae:	40 d5       	lddsp	r5,sp[0x34]
80009db0:	58 05       	cp.w	r5,0
80009db2:	c4 f0       	breq	80009e50 <_dtoa_r+0x58c>
80009db4:	30 0c       	mov	r12,0
80009db6:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009dba:	51 3c       	stdsp	sp[0x4c],r12
80009dbc:	30 0a       	mov	r10,0
80009dbe:	fc 1b 3f e0 	movh	r11,0x3fe0
80009dc2:	e0 a0 0f 2f 	rcall	8000bc20 <__avr32_f64_div>
80009dc6:	fa e8 00 28 	ld.d	r8,sp[40]
80009dca:	40 85       	lddsp	r5,sp[0x20]
80009dcc:	e0 a0 0c d0 	rcall	8000b76c <__avr32_f64_sub>
80009dd0:	fa eb 00 28 	st.d	sp[40],r10
80009dd4:	fa ea 00 08 	ld.d	r10,sp[8]
80009dd8:	e0 a0 0e 22 	rcall	8000ba1c <__avr32_f64_to_s32>
80009ddc:	51 6c       	stdsp	sp[0x58],r12
80009dde:	e0 a0 0e 36 	rcall	8000ba4a <__avr32_s32_to_f64>
80009de2:	14 98       	mov	r8,r10
80009de4:	16 99       	mov	r9,r11
80009de6:	fa ea 00 08 	ld.d	r10,sp[8]
80009dea:	e0 a0 0c c1 	rcall	8000b76c <__avr32_f64_sub>
80009dee:	fa eb 00 08 	st.d	sp[8],r10
80009df2:	41 68       	lddsp	r8,sp[0x58]
80009df4:	2d 08       	sub	r8,-48
80009df6:	0a c8       	st.b	r5++,r8
80009df8:	41 39       	lddsp	r9,sp[0x4c]
80009dfa:	2f f9       	sub	r9,-1
80009dfc:	51 39       	stdsp	sp[0x4c],r9
80009dfe:	fa e8 00 28 	ld.d	r8,sp[40]
80009e02:	e0 a0 0e db 	rcall	8000bbb8 <__avr32_f64_cmp_lt>
80009e06:	e0 81 03 39 	brne	8000a478 <_dtoa_r+0xbb4>
80009e0a:	fa e8 00 08 	ld.d	r8,sp[8]
80009e0e:	30 0a       	mov	r10,0
80009e10:	fc 1b 3f f0 	movh	r11,0x3ff0
80009e14:	e0 a0 0c ac 	rcall	8000b76c <__avr32_f64_sub>
80009e18:	fa e8 00 28 	ld.d	r8,sp[40]
80009e1c:	e0 a0 0e ce 	rcall	8000bbb8 <__avr32_f64_cmp_lt>
80009e20:	fa ea 00 28 	ld.d	r10,sp[40]
80009e24:	30 08       	mov	r8,0
80009e26:	fc 19 40 24 	movh	r9,0x4024
80009e2a:	e0 81 00 da 	brne	80009fde <_dtoa_r+0x71a>
80009e2e:	41 3c       	lddsp	r12,sp[0x4c]
80009e30:	08 3c       	cp.w	r12,r4
80009e32:	c5 f4       	brge	80009ef0 <_dtoa_r+0x62c>
80009e34:	e0 a0 0b b0 	rcall	8000b594 <__avr32_f64_mul>
80009e38:	30 08       	mov	r8,0
80009e3a:	fa eb 00 28 	st.d	sp[40],r10
80009e3e:	fc 19 40 24 	movh	r9,0x4024
80009e42:	fa ea 00 08 	ld.d	r10,sp[8]
80009e46:	e0 a0 0b a7 	rcall	8000b594 <__avr32_f64_mul>
80009e4a:	fa eb 00 08 	st.d	sp[8],r10
80009e4e:	cc 3b       	rjmp	80009dd4 <_dtoa_r+0x510>
80009e50:	40 85       	lddsp	r5,sp[0x20]
80009e52:	08 05       	add	r5,r4
80009e54:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009e58:	51 35       	stdsp	sp[0x4c],r5
80009e5a:	fa e8 00 28 	ld.d	r8,sp[40]
80009e5e:	40 85       	lddsp	r5,sp[0x20]
80009e60:	e0 a0 0b 9a 	rcall	8000b594 <__avr32_f64_mul>
80009e64:	fa eb 00 28 	st.d	sp[40],r10
80009e68:	fa ea 00 08 	ld.d	r10,sp[8]
80009e6c:	e0 a0 0d d8 	rcall	8000ba1c <__avr32_f64_to_s32>
80009e70:	51 6c       	stdsp	sp[0x58],r12
80009e72:	e0 a0 0d ec 	rcall	8000ba4a <__avr32_s32_to_f64>
80009e76:	14 98       	mov	r8,r10
80009e78:	16 99       	mov	r9,r11
80009e7a:	fa ea 00 08 	ld.d	r10,sp[8]
80009e7e:	e0 a0 0c 77 	rcall	8000b76c <__avr32_f64_sub>
80009e82:	fa eb 00 08 	st.d	sp[8],r10
80009e86:	41 68       	lddsp	r8,sp[0x58]
80009e88:	2d 08       	sub	r8,-48
80009e8a:	0a c8       	st.b	r5++,r8
80009e8c:	41 3c       	lddsp	r12,sp[0x4c]
80009e8e:	18 35       	cp.w	r5,r12
80009e90:	c2 81       	brne	80009ee0 <_dtoa_r+0x61c>
80009e92:	30 08       	mov	r8,0
80009e94:	fc 19 3f e0 	movh	r9,0x3fe0
80009e98:	fa ea 00 28 	ld.d	r10,sp[40]
80009e9c:	e0 a0 0d 36 	rcall	8000b908 <__avr32_f64_add>
80009ea0:	40 85       	lddsp	r5,sp[0x20]
80009ea2:	fa e8 00 08 	ld.d	r8,sp[8]
80009ea6:	08 05       	add	r5,r4
80009ea8:	e0 a0 0e 88 	rcall	8000bbb8 <__avr32_f64_cmp_lt>
80009eac:	e0 81 00 99 	brne	80009fde <_dtoa_r+0x71a>
80009eb0:	fa e8 00 28 	ld.d	r8,sp[40]
80009eb4:	30 0a       	mov	r10,0
80009eb6:	fc 1b 3f e0 	movh	r11,0x3fe0
80009eba:	e0 a0 0c 59 	rcall	8000b76c <__avr32_f64_sub>
80009ebe:	14 98       	mov	r8,r10
80009ec0:	16 99       	mov	r9,r11
80009ec2:	fa ea 00 08 	ld.d	r10,sp[8]
80009ec6:	e0 a0 0e 79 	rcall	8000bbb8 <__avr32_f64_cmp_lt>
80009eca:	c1 30       	breq	80009ef0 <_dtoa_r+0x62c>
80009ecc:	33 09       	mov	r9,48
80009ece:	0a 98       	mov	r8,r5
80009ed0:	11 7a       	ld.ub	r10,--r8
80009ed2:	f2 0a 18 00 	cp.b	r10,r9
80009ed6:	e0 81 02 d1 	brne	8000a478 <_dtoa_r+0xbb4>
80009eda:	10 95       	mov	r5,r8
80009edc:	cf 9b       	rjmp	80009ece <_dtoa_r+0x60a>
80009ede:	d7 03       	nop
80009ee0:	30 08       	mov	r8,0
80009ee2:	fc 19 40 24 	movh	r9,0x4024
80009ee6:	e0 a0 0b 57 	rcall	8000b594 <__avr32_f64_mul>
80009eea:	fa eb 00 08 	st.d	sp[8],r10
80009eee:	cb db       	rjmp	80009e68 <_dtoa_r+0x5a4>
80009ef0:	fa ea 00 3c 	ld.d	r10,sp[60]
80009ef4:	fa eb 00 08 	st.d	sp[8],r10
80009ef8:	58 e6       	cp.w	r6,14
80009efa:	5f ab       	srle	r11
80009efc:	41 8a       	lddsp	r10,sp[0x60]
80009efe:	30 08       	mov	r8,0
80009f00:	f4 09 11 ff 	rsub	r9,r10,-1
80009f04:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80009f08:	f0 09 18 00 	cp.b	r9,r8
80009f0c:	e0 80 00 82 	breq	8000a010 <_dtoa_r+0x74c>
80009f10:	40 ea       	lddsp	r10,sp[0x38]
80009f12:	58 01       	cp.w	r1,0
80009f14:	5f a9       	srle	r9
80009f16:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80009f1a:	fe ca d5 52 	sub	r10,pc,-10926
80009f1e:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80009f22:	fa e5 00 10 	st.d	sp[16],r4
80009f26:	f0 09 18 00 	cp.b	r9,r8
80009f2a:	c1 40       	breq	80009f52 <_dtoa_r+0x68e>
80009f2c:	58 01       	cp.w	r1,0
80009f2e:	e0 81 01 77 	brne	8000a21c <_dtoa_r+0x958>
80009f32:	30 08       	mov	r8,0
80009f34:	fc 19 40 14 	movh	r9,0x4014
80009f38:	08 9a       	mov	r10,r4
80009f3a:	0a 9b       	mov	r11,r5
80009f3c:	e0 a0 0b 2c 	rcall	8000b594 <__avr32_f64_mul>
80009f40:	fa e8 00 08 	ld.d	r8,sp[8]
80009f44:	e0 a0 0e 06 	rcall	8000bb50 <__avr32_f64_cmp_ge>
80009f48:	e0 81 01 6a 	brne	8000a21c <_dtoa_r+0x958>
80009f4c:	02 92       	mov	r2,r1
80009f4e:	e0 8f 01 72 	bral	8000a232 <_dtoa_r+0x96e>
80009f52:	40 85       	lddsp	r5,sp[0x20]
80009f54:	30 14       	mov	r4,1
80009f56:	fa e8 00 10 	ld.d	r8,sp[16]
80009f5a:	fa ea 00 08 	ld.d	r10,sp[8]
80009f5e:	e0 a0 0e 61 	rcall	8000bc20 <__avr32_f64_div>
80009f62:	e0 a0 0d 5d 	rcall	8000ba1c <__avr32_f64_to_s32>
80009f66:	18 92       	mov	r2,r12
80009f68:	e0 a0 0d 71 	rcall	8000ba4a <__avr32_s32_to_f64>
80009f6c:	fa e8 00 10 	ld.d	r8,sp[16]
80009f70:	e0 a0 0b 12 	rcall	8000b594 <__avr32_f64_mul>
80009f74:	14 98       	mov	r8,r10
80009f76:	16 99       	mov	r9,r11
80009f78:	fa ea 00 08 	ld.d	r10,sp[8]
80009f7c:	e0 a0 0b f8 	rcall	8000b76c <__avr32_f64_sub>
80009f80:	fa eb 00 08 	st.d	sp[8],r10
80009f84:	e4 c8 ff d0 	sub	r8,r2,-48
80009f88:	0a c8       	st.b	r5++,r8
80009f8a:	fc 19 40 24 	movh	r9,0x4024
80009f8e:	30 08       	mov	r8,0
80009f90:	02 34       	cp.w	r4,r1
80009f92:	c3 31       	brne	80009ff8 <_dtoa_r+0x734>
80009f94:	fa e8 00 08 	ld.d	r8,sp[8]
80009f98:	e0 a0 0c b8 	rcall	8000b908 <__avr32_f64_add>
80009f9c:	16 91       	mov	r1,r11
80009f9e:	14 90       	mov	r0,r10
80009fa0:	14 98       	mov	r8,r10
80009fa2:	02 99       	mov	r9,r1
80009fa4:	fa ea 00 10 	ld.d	r10,sp[16]
80009fa8:	e0 a0 0e 08 	rcall	8000bbb8 <__avr32_f64_cmp_lt>
80009fac:	c1 a1       	brne	80009fe0 <_dtoa_r+0x71c>
80009fae:	fa e8 00 10 	ld.d	r8,sp[16]
80009fb2:	00 9a       	mov	r10,r0
80009fb4:	02 9b       	mov	r11,r1
80009fb6:	e0 a0 0d ba 	rcall	8000bb2a <__avr32_f64_cmp_eq>
80009fba:	e0 80 02 5e 	breq	8000a476 <_dtoa_r+0xbb2>
80009fbe:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80009fc2:	c0 f1       	brne	80009fe0 <_dtoa_r+0x71c>
80009fc4:	e0 8f 02 59 	bral	8000a476 <_dtoa_r+0xbb2>
80009fc8:	40 8a       	lddsp	r10,sp[0x20]
80009fca:	14 38       	cp.w	r8,r10
80009fcc:	c0 30       	breq	80009fd2 <_dtoa_r+0x70e>
80009fce:	10 95       	mov	r5,r8
80009fd0:	c0 98       	rjmp	80009fe2 <_dtoa_r+0x71e>
80009fd2:	33 08       	mov	r8,48
80009fd4:	40 89       	lddsp	r9,sp[0x20]
80009fd6:	2f f6       	sub	r6,-1
80009fd8:	b2 88       	st.b	r9[0x0],r8
80009fda:	40 88       	lddsp	r8,sp[0x20]
80009fdc:	c0 88       	rjmp	80009fec <_dtoa_r+0x728>
80009fde:	40 66       	lddsp	r6,sp[0x18]
80009fe0:	33 99       	mov	r9,57
80009fe2:	0a 98       	mov	r8,r5
80009fe4:	11 7a       	ld.ub	r10,--r8
80009fe6:	f2 0a 18 00 	cp.b	r10,r9
80009fea:	ce f0       	breq	80009fc8 <_dtoa_r+0x704>
80009fec:	50 66       	stdsp	sp[0x18],r6
80009fee:	11 89       	ld.ub	r9,r8[0x0]
80009ff0:	2f f9       	sub	r9,-1
80009ff2:	b0 89       	st.b	r8[0x0],r9
80009ff4:	e0 8f 02 42 	bral	8000a478 <_dtoa_r+0xbb4>
80009ff8:	e0 a0 0a ce 	rcall	8000b594 <__avr32_f64_mul>
80009ffc:	2f f4       	sub	r4,-1
80009ffe:	fa eb 00 08 	st.d	sp[8],r10
8000a002:	30 08       	mov	r8,0
8000a004:	30 09       	mov	r9,0
8000a006:	e0 a0 0d 92 	rcall	8000bb2a <__avr32_f64_cmp_eq>
8000a00a:	ca 60       	breq	80009f56 <_dtoa_r+0x692>
8000a00c:	e0 8f 02 35 	bral	8000a476 <_dtoa_r+0xbb2>
8000a010:	40 d8       	lddsp	r8,sp[0x34]
8000a012:	58 08       	cp.w	r8,0
8000a014:	c0 51       	brne	8000a01e <_dtoa_r+0x75a>
8000a016:	04 98       	mov	r8,r2
8000a018:	00 95       	mov	r5,r0
8000a01a:	40 d4       	lddsp	r4,sp[0x34]
8000a01c:	c3 78       	rjmp	8000a08a <_dtoa_r+0x7c6>
8000a01e:	40 c5       	lddsp	r5,sp[0x30]
8000a020:	58 15       	cp.w	r5,1
8000a022:	e0 89 00 0f 	brgt	8000a040 <_dtoa_r+0x77c>
8000a026:	41 74       	lddsp	r4,sp[0x5c]
8000a028:	58 04       	cp.w	r4,0
8000a02a:	c0 40       	breq	8000a032 <_dtoa_r+0x76e>
8000a02c:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a030:	c0 48       	rjmp	8000a038 <_dtoa_r+0x774>
8000a032:	41 99       	lddsp	r9,sp[0x64]
8000a034:	f2 09 11 36 	rsub	r9,r9,54
8000a038:	04 98       	mov	r8,r2
8000a03a:	00 95       	mov	r5,r0
8000a03c:	c1 c8       	rjmp	8000a074 <_dtoa_r+0x7b0>
8000a03e:	d7 03       	nop
8000a040:	e2 c8 00 01 	sub	r8,r1,1
8000a044:	58 01       	cp.w	r1,0
8000a046:	e0 05 17 40 	movge	r5,r0
8000a04a:	e2 09 17 40 	movge	r9,r1
8000a04e:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a052:	f9 b9 05 00 	movlt	r9,0
8000a056:	10 32       	cp.w	r2,r8
8000a058:	e5 d8 e4 18 	subge	r8,r2,r8
8000a05c:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a060:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a064:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a068:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a06c:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a070:	f9 b8 05 00 	movlt	r8,0
8000a074:	40 4b       	lddsp	r11,sp[0x10]
8000a076:	12 0b       	add	r11,r9
8000a078:	50 08       	stdsp	sp[0x0],r8
8000a07a:	50 4b       	stdsp	sp[0x10],r11
8000a07c:	12 00       	add	r0,r9
8000a07e:	30 1b       	mov	r11,1
8000a080:	0e 9c       	mov	r12,r7
8000a082:	e0 a0 08 a7 	rcall	8000b1d0 <__i2b>
8000a086:	40 08       	lddsp	r8,sp[0x0]
8000a088:	18 94       	mov	r4,r12
8000a08a:	40 4a       	lddsp	r10,sp[0x10]
8000a08c:	58 05       	cp.w	r5,0
8000a08e:	5f 99       	srgt	r9
8000a090:	58 0a       	cp.w	r10,0
8000a092:	5f 9a       	srgt	r10
8000a094:	f5 e9 00 09 	and	r9,r10,r9
8000a098:	c0 80       	breq	8000a0a8 <_dtoa_r+0x7e4>
8000a09a:	40 4c       	lddsp	r12,sp[0x10]
8000a09c:	f8 05 0d 49 	min	r9,r12,r5
8000a0a0:	12 1c       	sub	r12,r9
8000a0a2:	12 10       	sub	r0,r9
8000a0a4:	50 4c       	stdsp	sp[0x10],r12
8000a0a6:	12 15       	sub	r5,r9
8000a0a8:	58 02       	cp.w	r2,0
8000a0aa:	e0 8a 00 27 	brle	8000a0f8 <_dtoa_r+0x834>
8000a0ae:	40 db       	lddsp	r11,sp[0x34]
8000a0b0:	58 0b       	cp.w	r11,0
8000a0b2:	c1 d0       	breq	8000a0ec <_dtoa_r+0x828>
8000a0b4:	58 08       	cp.w	r8,0
8000a0b6:	e0 8a 00 17 	brle	8000a0e4 <_dtoa_r+0x820>
8000a0ba:	10 9a       	mov	r10,r8
8000a0bc:	50 08       	stdsp	sp[0x0],r8
8000a0be:	08 9b       	mov	r11,r4
8000a0c0:	0e 9c       	mov	r12,r7
8000a0c2:	e0 a0 08 cd 	rcall	8000b25c <__pow5mult>
8000a0c6:	06 9a       	mov	r10,r3
8000a0c8:	18 9b       	mov	r11,r12
8000a0ca:	18 94       	mov	r4,r12
8000a0cc:	0e 9c       	mov	r12,r7
8000a0ce:	e0 a0 08 01 	rcall	8000b0d0 <__multiply>
8000a0d2:	18 99       	mov	r9,r12
8000a0d4:	06 9b       	mov	r11,r3
8000a0d6:	50 19       	stdsp	sp[0x4],r9
8000a0d8:	0e 9c       	mov	r12,r7
8000a0da:	e0 a0 06 ad 	rcall	8000ae34 <_Bfree>
8000a0de:	40 19       	lddsp	r9,sp[0x4]
8000a0e0:	40 08       	lddsp	r8,sp[0x0]
8000a0e2:	12 93       	mov	r3,r9
8000a0e4:	e4 08 01 0a 	sub	r10,r2,r8
8000a0e8:	c0 80       	breq	8000a0f8 <_dtoa_r+0x834>
8000a0ea:	c0 28       	rjmp	8000a0ee <_dtoa_r+0x82a>
8000a0ec:	04 9a       	mov	r10,r2
8000a0ee:	06 9b       	mov	r11,r3
8000a0f0:	0e 9c       	mov	r12,r7
8000a0f2:	e0 a0 08 b5 	rcall	8000b25c <__pow5mult>
8000a0f6:	18 93       	mov	r3,r12
8000a0f8:	30 1b       	mov	r11,1
8000a0fa:	0e 9c       	mov	r12,r7
8000a0fc:	e0 a0 08 6a 	rcall	8000b1d0 <__i2b>
8000a100:	41 1a       	lddsp	r10,sp[0x44]
8000a102:	18 92       	mov	r2,r12
8000a104:	58 0a       	cp.w	r10,0
8000a106:	e0 8a 00 07 	brle	8000a114 <_dtoa_r+0x850>
8000a10a:	18 9b       	mov	r11,r12
8000a10c:	0e 9c       	mov	r12,r7
8000a10e:	e0 a0 08 a7 	rcall	8000b25c <__pow5mult>
8000a112:	18 92       	mov	r2,r12
8000a114:	40 c9       	lddsp	r9,sp[0x30]
8000a116:	58 19       	cp.w	r9,1
8000a118:	e0 89 00 14 	brgt	8000a140 <_dtoa_r+0x87c>
8000a11c:	40 38       	lddsp	r8,sp[0xc]
8000a11e:	58 08       	cp.w	r8,0
8000a120:	c1 01       	brne	8000a140 <_dtoa_r+0x87c>
8000a122:	40 29       	lddsp	r9,sp[0x8]
8000a124:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a128:	c0 c1       	brne	8000a140 <_dtoa_r+0x87c>
8000a12a:	12 98       	mov	r8,r9
8000a12c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a130:	c0 80       	breq	8000a140 <_dtoa_r+0x87c>
8000a132:	40 4c       	lddsp	r12,sp[0x10]
8000a134:	30 1b       	mov	r11,1
8000a136:	2f fc       	sub	r12,-1
8000a138:	2f f0       	sub	r0,-1
8000a13a:	50 4c       	stdsp	sp[0x10],r12
8000a13c:	50 6b       	stdsp	sp[0x18],r11
8000a13e:	c0 38       	rjmp	8000a144 <_dtoa_r+0x880>
8000a140:	30 0a       	mov	r10,0
8000a142:	50 6a       	stdsp	sp[0x18],r10
8000a144:	41 19       	lddsp	r9,sp[0x44]
8000a146:	58 09       	cp.w	r9,0
8000a148:	c0 31       	brne	8000a14e <_dtoa_r+0x88a>
8000a14a:	30 1c       	mov	r12,1
8000a14c:	c0 98       	rjmp	8000a15e <_dtoa_r+0x89a>
8000a14e:	64 48       	ld.w	r8,r2[0x10]
8000a150:	2f c8       	sub	r8,-4
8000a152:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a156:	e0 a0 05 df 	rcall	8000ad14 <__hi0bits>
8000a15a:	f8 0c 11 20 	rsub	r12,r12,32
8000a15e:	40 4b       	lddsp	r11,sp[0x10]
8000a160:	f8 0b 00 08 	add	r8,r12,r11
8000a164:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a168:	c0 c0       	breq	8000a180 <_dtoa_r+0x8bc>
8000a16a:	f0 08 11 20 	rsub	r8,r8,32
8000a16e:	58 48       	cp.w	r8,4
8000a170:	e0 8a 00 06 	brle	8000a17c <_dtoa_r+0x8b8>
8000a174:	20 48       	sub	r8,4
8000a176:	10 0b       	add	r11,r8
8000a178:	50 4b       	stdsp	sp[0x10],r11
8000a17a:	c0 78       	rjmp	8000a188 <_dtoa_r+0x8c4>
8000a17c:	58 48       	cp.w	r8,4
8000a17e:	c0 70       	breq	8000a18c <_dtoa_r+0x8c8>
8000a180:	40 4a       	lddsp	r10,sp[0x10]
8000a182:	2e 48       	sub	r8,-28
8000a184:	10 0a       	add	r10,r8
8000a186:	50 4a       	stdsp	sp[0x10],r10
8000a188:	10 00       	add	r0,r8
8000a18a:	10 05       	add	r5,r8
8000a18c:	58 00       	cp.w	r0,0
8000a18e:	e0 8a 00 08 	brle	8000a19e <_dtoa_r+0x8da>
8000a192:	06 9b       	mov	r11,r3
8000a194:	00 9a       	mov	r10,r0
8000a196:	0e 9c       	mov	r12,r7
8000a198:	e0 a0 07 58 	rcall	8000b048 <__lshift>
8000a19c:	18 93       	mov	r3,r12
8000a19e:	40 49       	lddsp	r9,sp[0x10]
8000a1a0:	58 09       	cp.w	r9,0
8000a1a2:	e0 8a 00 08 	brle	8000a1b2 <_dtoa_r+0x8ee>
8000a1a6:	04 9b       	mov	r11,r2
8000a1a8:	12 9a       	mov	r10,r9
8000a1aa:	0e 9c       	mov	r12,r7
8000a1ac:	e0 a0 07 4e 	rcall	8000b048 <__lshift>
8000a1b0:	18 92       	mov	r2,r12
8000a1b2:	41 48       	lddsp	r8,sp[0x50]
8000a1b4:	58 08       	cp.w	r8,0
8000a1b6:	c1 b0       	breq	8000a1ec <_dtoa_r+0x928>
8000a1b8:	04 9b       	mov	r11,r2
8000a1ba:	06 9c       	mov	r12,r3
8000a1bc:	e0 a0 06 23 	rcall	8000ae02 <__mcmp>
8000a1c0:	c1 64       	brge	8000a1ec <_dtoa_r+0x928>
8000a1c2:	06 9b       	mov	r11,r3
8000a1c4:	30 09       	mov	r9,0
8000a1c6:	30 aa       	mov	r10,10
8000a1c8:	0e 9c       	mov	r12,r7
8000a1ca:	e0 a0 08 0b 	rcall	8000b1e0 <__multadd>
8000a1ce:	20 16       	sub	r6,1
8000a1d0:	18 93       	mov	r3,r12
8000a1d2:	40 dc       	lddsp	r12,sp[0x34]
8000a1d4:	58 0c       	cp.w	r12,0
8000a1d6:	c0 31       	brne	8000a1dc <_dtoa_r+0x918>
8000a1d8:	40 91       	lddsp	r1,sp[0x24]
8000a1da:	c0 98       	rjmp	8000a1ec <_dtoa_r+0x928>
8000a1dc:	08 9b       	mov	r11,r4
8000a1de:	40 91       	lddsp	r1,sp[0x24]
8000a1e0:	30 09       	mov	r9,0
8000a1e2:	30 aa       	mov	r10,10
8000a1e4:	0e 9c       	mov	r12,r7
8000a1e6:	e0 a0 07 fd 	rcall	8000b1e0 <__multadd>
8000a1ea:	18 94       	mov	r4,r12
8000a1ec:	58 01       	cp.w	r1,0
8000a1ee:	5f a9       	srle	r9
8000a1f0:	40 cb       	lddsp	r11,sp[0x30]
8000a1f2:	58 2b       	cp.w	r11,2
8000a1f4:	5f 98       	srgt	r8
8000a1f6:	f3 e8 00 08 	and	r8,r9,r8
8000a1fa:	c2 50       	breq	8000a244 <_dtoa_r+0x980>
8000a1fc:	58 01       	cp.w	r1,0
8000a1fe:	c1 11       	brne	8000a220 <_dtoa_r+0x95c>
8000a200:	04 9b       	mov	r11,r2
8000a202:	02 99       	mov	r9,r1
8000a204:	30 5a       	mov	r10,5
8000a206:	0e 9c       	mov	r12,r7
8000a208:	e0 a0 07 ec 	rcall	8000b1e0 <__multadd>
8000a20c:	18 92       	mov	r2,r12
8000a20e:	18 9b       	mov	r11,r12
8000a210:	06 9c       	mov	r12,r3
8000a212:	e0 a0 05 f8 	rcall	8000ae02 <__mcmp>
8000a216:	e0 89 00 0f 	brgt	8000a234 <_dtoa_r+0x970>
8000a21a:	c0 38       	rjmp	8000a220 <_dtoa_r+0x95c>
8000a21c:	30 02       	mov	r2,0
8000a21e:	04 94       	mov	r4,r2
8000a220:	40 ea       	lddsp	r10,sp[0x38]
8000a222:	30 09       	mov	r9,0
8000a224:	5c da       	com	r10
8000a226:	40 85       	lddsp	r5,sp[0x20]
8000a228:	50 6a       	stdsp	sp[0x18],r10
8000a22a:	50 49       	stdsp	sp[0x10],r9
8000a22c:	c0 f9       	rjmp	8000a44a <_dtoa_r+0xb86>
8000a22e:	08 92       	mov	r2,r4
8000a230:	40 66       	lddsp	r6,sp[0x18]
8000a232:	04 94       	mov	r4,r2
8000a234:	2f f6       	sub	r6,-1
8000a236:	50 66       	stdsp	sp[0x18],r6
8000a238:	33 18       	mov	r8,49
8000a23a:	40 85       	lddsp	r5,sp[0x20]
8000a23c:	0a c8       	st.b	r5++,r8
8000a23e:	30 08       	mov	r8,0
8000a240:	50 48       	stdsp	sp[0x10],r8
8000a242:	c0 49       	rjmp	8000a44a <_dtoa_r+0xb86>
8000a244:	40 dc       	lddsp	r12,sp[0x34]
8000a246:	58 0c       	cp.w	r12,0
8000a248:	e0 80 00 b5 	breq	8000a3b2 <_dtoa_r+0xaee>
8000a24c:	58 05       	cp.w	r5,0
8000a24e:	e0 8a 00 08 	brle	8000a25e <_dtoa_r+0x99a>
8000a252:	08 9b       	mov	r11,r4
8000a254:	0a 9a       	mov	r10,r5
8000a256:	0e 9c       	mov	r12,r7
8000a258:	e0 a0 06 f8 	rcall	8000b048 <__lshift>
8000a25c:	18 94       	mov	r4,r12
8000a25e:	40 6b       	lddsp	r11,sp[0x18]
8000a260:	58 0b       	cp.w	r11,0
8000a262:	c0 31       	brne	8000a268 <_dtoa_r+0x9a4>
8000a264:	08 9c       	mov	r12,r4
8000a266:	c1 38       	rjmp	8000a28c <_dtoa_r+0x9c8>
8000a268:	68 1b       	ld.w	r11,r4[0x4]
8000a26a:	0e 9c       	mov	r12,r7
8000a26c:	e0 a0 05 fe 	rcall	8000ae68 <_Balloc>
8000a270:	68 4a       	ld.w	r10,r4[0x10]
8000a272:	18 95       	mov	r5,r12
8000a274:	e8 cb ff f4 	sub	r11,r4,-12
8000a278:	2f ea       	sub	r10,-2
8000a27a:	2f 4c       	sub	r12,-12
8000a27c:	a3 6a       	lsl	r10,0x2
8000a27e:	fe b0 e5 6b 	rcall	80006d54 <memcpy>
8000a282:	0a 9b       	mov	r11,r5
8000a284:	30 1a       	mov	r10,1
8000a286:	0e 9c       	mov	r12,r7
8000a288:	e0 a0 06 e0 	rcall	8000b048 <__lshift>
8000a28c:	50 44       	stdsp	sp[0x10],r4
8000a28e:	40 3a       	lddsp	r10,sp[0xc]
8000a290:	30 19       	mov	r9,1
8000a292:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a296:	18 94       	mov	r4,r12
8000a298:	50 da       	stdsp	sp[0x34],r10
8000a29a:	40 85       	lddsp	r5,sp[0x20]
8000a29c:	50 99       	stdsp	sp[0x24],r9
8000a29e:	50 26       	stdsp	sp[0x8],r6
8000a2a0:	50 e1       	stdsp	sp[0x38],r1
8000a2a2:	04 9b       	mov	r11,r2
8000a2a4:	06 9c       	mov	r12,r3
8000a2a6:	fe b0 fa 7f 	rcall	800097a4 <quorem>
8000a2aa:	40 4b       	lddsp	r11,sp[0x10]
8000a2ac:	f8 c0 ff d0 	sub	r0,r12,-48
8000a2b0:	06 9c       	mov	r12,r3
8000a2b2:	e0 a0 05 a8 	rcall	8000ae02 <__mcmp>
8000a2b6:	08 9a       	mov	r10,r4
8000a2b8:	50 6c       	stdsp	sp[0x18],r12
8000a2ba:	04 9b       	mov	r11,r2
8000a2bc:	0e 9c       	mov	r12,r7
8000a2be:	e0 a0 06 5d 	rcall	8000af78 <__mdiff>
8000a2c2:	18 91       	mov	r1,r12
8000a2c4:	78 38       	ld.w	r8,r12[0xc]
8000a2c6:	58 08       	cp.w	r8,0
8000a2c8:	c0 30       	breq	8000a2ce <_dtoa_r+0xa0a>
8000a2ca:	30 16       	mov	r6,1
8000a2cc:	c0 68       	rjmp	8000a2d8 <_dtoa_r+0xa14>
8000a2ce:	18 9b       	mov	r11,r12
8000a2d0:	06 9c       	mov	r12,r3
8000a2d2:	e0 a0 05 98 	rcall	8000ae02 <__mcmp>
8000a2d6:	18 96       	mov	r6,r12
8000a2d8:	0e 9c       	mov	r12,r7
8000a2da:	02 9b       	mov	r11,r1
8000a2dc:	e0 a0 05 ac 	rcall	8000ae34 <_Bfree>
8000a2e0:	40 cc       	lddsp	r12,sp[0x30]
8000a2e2:	ed ec 10 08 	or	r8,r6,r12
8000a2e6:	c0 d1       	brne	8000a300 <_dtoa_r+0xa3c>
8000a2e8:	40 db       	lddsp	r11,sp[0x34]
8000a2ea:	58 0b       	cp.w	r11,0
8000a2ec:	c0 a1       	brne	8000a300 <_dtoa_r+0xa3c>
8000a2ee:	40 26       	lddsp	r6,sp[0x8]
8000a2f0:	e0 40 00 39 	cp.w	r0,57
8000a2f4:	c3 00       	breq	8000a354 <_dtoa_r+0xa90>
8000a2f6:	40 6a       	lddsp	r10,sp[0x18]
8000a2f8:	58 0a       	cp.w	r10,0
8000a2fa:	e0 89 00 24 	brgt	8000a342 <_dtoa_r+0xa7e>
8000a2fe:	c2 f8       	rjmp	8000a35c <_dtoa_r+0xa98>
8000a300:	40 69       	lddsp	r9,sp[0x18]
8000a302:	58 09       	cp.w	r9,0
8000a304:	c0 85       	brlt	8000a314 <_dtoa_r+0xa50>
8000a306:	12 98       	mov	r8,r9
8000a308:	40 cc       	lddsp	r12,sp[0x30]
8000a30a:	18 48       	or	r8,r12
8000a30c:	c1 d1       	brne	8000a346 <_dtoa_r+0xa82>
8000a30e:	40 db       	lddsp	r11,sp[0x34]
8000a310:	58 0b       	cp.w	r11,0
8000a312:	c1 a1       	brne	8000a346 <_dtoa_r+0xa82>
8000a314:	0c 99       	mov	r9,r6
8000a316:	40 26       	lddsp	r6,sp[0x8]
8000a318:	58 09       	cp.w	r9,0
8000a31a:	e0 8a 00 21 	brle	8000a35c <_dtoa_r+0xa98>
8000a31e:	06 9b       	mov	r11,r3
8000a320:	30 1a       	mov	r10,1
8000a322:	0e 9c       	mov	r12,r7
8000a324:	e0 a0 06 92 	rcall	8000b048 <__lshift>
8000a328:	04 9b       	mov	r11,r2
8000a32a:	18 93       	mov	r3,r12
8000a32c:	e0 a0 05 6b 	rcall	8000ae02 <__mcmp>
8000a330:	e0 89 00 06 	brgt	8000a33c <_dtoa_r+0xa78>
8000a334:	c1 41       	brne	8000a35c <_dtoa_r+0xa98>
8000a336:	ed b0 00 00 	bld	r0,0x0
8000a33a:	c1 11       	brne	8000a35c <_dtoa_r+0xa98>
8000a33c:	e0 40 00 39 	cp.w	r0,57
8000a340:	c0 a0       	breq	8000a354 <_dtoa_r+0xa90>
8000a342:	2f f0       	sub	r0,-1
8000a344:	c0 c8       	rjmp	8000a35c <_dtoa_r+0xa98>
8000a346:	58 06       	cp.w	r6,0
8000a348:	e0 8a 00 0c 	brle	8000a360 <_dtoa_r+0xa9c>
8000a34c:	40 26       	lddsp	r6,sp[0x8]
8000a34e:	e0 40 00 39 	cp.w	r0,57
8000a352:	c0 41       	brne	8000a35a <_dtoa_r+0xa96>
8000a354:	33 98       	mov	r8,57
8000a356:	0a c8       	st.b	r5++,r8
8000a358:	c6 78       	rjmp	8000a426 <_dtoa_r+0xb62>
8000a35a:	2f f0       	sub	r0,-1
8000a35c:	0a c0       	st.b	r5++,r0
8000a35e:	c7 58       	rjmp	8000a448 <_dtoa_r+0xb84>
8000a360:	0a c0       	st.b	r5++,r0
8000a362:	40 9a       	lddsp	r10,sp[0x24]
8000a364:	40 e9       	lddsp	r9,sp[0x38]
8000a366:	12 3a       	cp.w	r10,r9
8000a368:	c4 30       	breq	8000a3ee <_dtoa_r+0xb2a>
8000a36a:	06 9b       	mov	r11,r3
8000a36c:	30 09       	mov	r9,0
8000a36e:	30 aa       	mov	r10,10
8000a370:	0e 9c       	mov	r12,r7
8000a372:	e0 a0 07 37 	rcall	8000b1e0 <__multadd>
8000a376:	40 48       	lddsp	r8,sp[0x10]
8000a378:	18 93       	mov	r3,r12
8000a37a:	08 38       	cp.w	r8,r4
8000a37c:	c0 91       	brne	8000a38e <_dtoa_r+0xaca>
8000a37e:	10 9b       	mov	r11,r8
8000a380:	30 09       	mov	r9,0
8000a382:	30 aa       	mov	r10,10
8000a384:	0e 9c       	mov	r12,r7
8000a386:	e0 a0 07 2d 	rcall	8000b1e0 <__multadd>
8000a38a:	50 4c       	stdsp	sp[0x10],r12
8000a38c:	c0 e8       	rjmp	8000a3a8 <_dtoa_r+0xae4>
8000a38e:	40 4b       	lddsp	r11,sp[0x10]
8000a390:	30 09       	mov	r9,0
8000a392:	30 aa       	mov	r10,10
8000a394:	0e 9c       	mov	r12,r7
8000a396:	e0 a0 07 25 	rcall	8000b1e0 <__multadd>
8000a39a:	08 9b       	mov	r11,r4
8000a39c:	50 4c       	stdsp	sp[0x10],r12
8000a39e:	30 09       	mov	r9,0
8000a3a0:	30 aa       	mov	r10,10
8000a3a2:	0e 9c       	mov	r12,r7
8000a3a4:	e0 a0 07 1e 	rcall	8000b1e0 <__multadd>
8000a3a8:	18 94       	mov	r4,r12
8000a3aa:	40 9c       	lddsp	r12,sp[0x24]
8000a3ac:	2f fc       	sub	r12,-1
8000a3ae:	50 9c       	stdsp	sp[0x24],r12
8000a3b0:	c7 9b       	rjmp	8000a2a2 <_dtoa_r+0x9de>
8000a3b2:	30 18       	mov	r8,1
8000a3b4:	06 90       	mov	r0,r3
8000a3b6:	40 85       	lddsp	r5,sp[0x20]
8000a3b8:	08 93       	mov	r3,r4
8000a3ba:	0c 94       	mov	r4,r6
8000a3bc:	10 96       	mov	r6,r8
8000a3be:	04 9b       	mov	r11,r2
8000a3c0:	00 9c       	mov	r12,r0
8000a3c2:	fe b0 f9 f1 	rcall	800097a4 <quorem>
8000a3c6:	2d 0c       	sub	r12,-48
8000a3c8:	0a cc       	st.b	r5++,r12
8000a3ca:	02 36       	cp.w	r6,r1
8000a3cc:	c0 a4       	brge	8000a3e0 <_dtoa_r+0xb1c>
8000a3ce:	00 9b       	mov	r11,r0
8000a3d0:	30 09       	mov	r9,0
8000a3d2:	30 aa       	mov	r10,10
8000a3d4:	0e 9c       	mov	r12,r7
8000a3d6:	2f f6       	sub	r6,-1
8000a3d8:	e0 a0 07 04 	rcall	8000b1e0 <__multadd>
8000a3dc:	18 90       	mov	r0,r12
8000a3de:	cf 0b       	rjmp	8000a3be <_dtoa_r+0xafa>
8000a3e0:	08 96       	mov	r6,r4
8000a3e2:	30 0b       	mov	r11,0
8000a3e4:	06 94       	mov	r4,r3
8000a3e6:	50 4b       	stdsp	sp[0x10],r11
8000a3e8:	00 93       	mov	r3,r0
8000a3ea:	18 90       	mov	r0,r12
8000a3ec:	c0 28       	rjmp	8000a3f0 <_dtoa_r+0xb2c>
8000a3ee:	40 26       	lddsp	r6,sp[0x8]
8000a3f0:	06 9b       	mov	r11,r3
8000a3f2:	30 1a       	mov	r10,1
8000a3f4:	0e 9c       	mov	r12,r7
8000a3f6:	e0 a0 06 29 	rcall	8000b048 <__lshift>
8000a3fa:	04 9b       	mov	r11,r2
8000a3fc:	18 93       	mov	r3,r12
8000a3fe:	e0 a0 05 02 	rcall	8000ae02 <__mcmp>
8000a402:	e0 89 00 12 	brgt	8000a426 <_dtoa_r+0xb62>
8000a406:	c1 b1       	brne	8000a43c <_dtoa_r+0xb78>
8000a408:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a40c:	c0 d1       	brne	8000a426 <_dtoa_r+0xb62>
8000a40e:	c1 78       	rjmp	8000a43c <_dtoa_r+0xb78>
8000a410:	40 89       	lddsp	r9,sp[0x20]
8000a412:	12 38       	cp.w	r8,r9
8000a414:	c0 30       	breq	8000a41a <_dtoa_r+0xb56>
8000a416:	10 95       	mov	r5,r8
8000a418:	c0 88       	rjmp	8000a428 <_dtoa_r+0xb64>
8000a41a:	2f f6       	sub	r6,-1
8000a41c:	50 66       	stdsp	sp[0x18],r6
8000a41e:	33 18       	mov	r8,49
8000a420:	40 8c       	lddsp	r12,sp[0x20]
8000a422:	b8 88       	st.b	r12[0x0],r8
8000a424:	c1 38       	rjmp	8000a44a <_dtoa_r+0xb86>
8000a426:	33 9a       	mov	r10,57
8000a428:	0a 98       	mov	r8,r5
8000a42a:	11 79       	ld.ub	r9,--r8
8000a42c:	f4 09 18 00 	cp.b	r9,r10
8000a430:	cf 00       	breq	8000a410 <_dtoa_r+0xb4c>
8000a432:	2f f9       	sub	r9,-1
8000a434:	b0 89       	st.b	r8[0x0],r9
8000a436:	c0 98       	rjmp	8000a448 <_dtoa_r+0xb84>
8000a438:	10 95       	mov	r5,r8
8000a43a:	c0 28       	rjmp	8000a43e <_dtoa_r+0xb7a>
8000a43c:	33 09       	mov	r9,48
8000a43e:	0a 98       	mov	r8,r5
8000a440:	11 7a       	ld.ub	r10,--r8
8000a442:	f2 0a 18 00 	cp.b	r10,r9
8000a446:	cf 90       	breq	8000a438 <_dtoa_r+0xb74>
8000a448:	50 66       	stdsp	sp[0x18],r6
8000a44a:	04 9b       	mov	r11,r2
8000a44c:	0e 9c       	mov	r12,r7
8000a44e:	e0 a0 04 f3 	rcall	8000ae34 <_Bfree>
8000a452:	58 04       	cp.w	r4,0
8000a454:	c1 20       	breq	8000a478 <_dtoa_r+0xbb4>
8000a456:	40 4b       	lddsp	r11,sp[0x10]
8000a458:	08 3b       	cp.w	r11,r4
8000a45a:	5f 19       	srne	r9
8000a45c:	58 0b       	cp.w	r11,0
8000a45e:	5f 18       	srne	r8
8000a460:	f3 e8 00 08 	and	r8,r9,r8
8000a464:	c0 40       	breq	8000a46c <_dtoa_r+0xba8>
8000a466:	0e 9c       	mov	r12,r7
8000a468:	e0 a0 04 e6 	rcall	8000ae34 <_Bfree>
8000a46c:	08 9b       	mov	r11,r4
8000a46e:	0e 9c       	mov	r12,r7
8000a470:	e0 a0 04 e2 	rcall	8000ae34 <_Bfree>
8000a474:	c0 28       	rjmp	8000a478 <_dtoa_r+0xbb4>
8000a476:	50 66       	stdsp	sp[0x18],r6
8000a478:	0e 9c       	mov	r12,r7
8000a47a:	06 9b       	mov	r11,r3
8000a47c:	e0 a0 04 dc 	rcall	8000ae34 <_Bfree>
8000a480:	30 08       	mov	r8,0
8000a482:	aa 88       	st.b	r5[0x0],r8
8000a484:	40 68       	lddsp	r8,sp[0x18]
8000a486:	41 5a       	lddsp	r10,sp[0x54]
8000a488:	2f f8       	sub	r8,-1
8000a48a:	41 29       	lddsp	r9,sp[0x48]
8000a48c:	95 08       	st.w	r10[0x0],r8
8000a48e:	40 8c       	lddsp	r12,sp[0x20]
8000a490:	58 09       	cp.w	r9,0
8000a492:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a496:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a49a:	2e 6d       	sub	sp,-104
8000a49c:	d8 32       	popm	r0-r7,pc
8000a49e:	d7 03       	nop

8000a4a0 <__errno>:
8000a4a0:	e0 68 01 18 	mov	r8,280
8000a4a4:	70 0c       	ld.w	r12,r8[0x0]
8000a4a6:	2f 4c       	sub	r12,-12
8000a4a8:	5e fc       	retal	r12
8000a4aa:	d7 03       	nop

8000a4ac <_fflush_r>:
8000a4ac:	d4 21       	pushm	r4-r7,lr
8000a4ae:	16 97       	mov	r7,r11
8000a4b0:	18 96       	mov	r6,r12
8000a4b2:	76 48       	ld.w	r8,r11[0x10]
8000a4b4:	58 08       	cp.w	r8,0
8000a4b6:	c7 f0       	breq	8000a5b4 <_fflush_r+0x108>
8000a4b8:	58 0c       	cp.w	r12,0
8000a4ba:	c0 50       	breq	8000a4c4 <_fflush_r+0x18>
8000a4bc:	78 68       	ld.w	r8,r12[0x18]
8000a4be:	58 08       	cp.w	r8,0
8000a4c0:	c0 21       	brne	8000a4c4 <_fflush_r+0x18>
8000a4c2:	cc dc       	rcall	8000a65c <__sinit>
8000a4c4:	fe c8 db a8 	sub	r8,pc,-9304
8000a4c8:	10 37       	cp.w	r7,r8
8000a4ca:	c0 31       	brne	8000a4d0 <_fflush_r+0x24>
8000a4cc:	6c 07       	ld.w	r7,r6[0x0]
8000a4ce:	c0 c8       	rjmp	8000a4e6 <_fflush_r+0x3a>
8000a4d0:	fe c8 db 94 	sub	r8,pc,-9324
8000a4d4:	10 37       	cp.w	r7,r8
8000a4d6:	c0 31       	brne	8000a4dc <_fflush_r+0x30>
8000a4d8:	6c 17       	ld.w	r7,r6[0x4]
8000a4da:	c0 68       	rjmp	8000a4e6 <_fflush_r+0x3a>
8000a4dc:	fe c8 db 80 	sub	r8,pc,-9344
8000a4e0:	10 37       	cp.w	r7,r8
8000a4e2:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a4e6:	8e 6a       	ld.sh	r10,r7[0xc]
8000a4e8:	14 98       	mov	r8,r10
8000a4ea:	ed ba 00 03 	bld	r10,0x3
8000a4ee:	c4 20       	breq	8000a572 <_fflush_r+0xc6>
8000a4f0:	ab ba       	sbr	r10,0xb
8000a4f2:	ae 6a       	st.h	r7[0xc],r10
8000a4f4:	6e 18       	ld.w	r8,r7[0x4]
8000a4f6:	58 08       	cp.w	r8,0
8000a4f8:	e0 89 00 06 	brgt	8000a504 <_fflush_r+0x58>
8000a4fc:	6f 08       	ld.w	r8,r7[0x40]
8000a4fe:	58 08       	cp.w	r8,0
8000a500:	e0 8a 00 5a 	brle	8000a5b4 <_fflush_r+0x108>
8000a504:	6e b8       	ld.w	r8,r7[0x2c]
8000a506:	58 08       	cp.w	r8,0
8000a508:	c5 60       	breq	8000a5b4 <_fflush_r+0x108>
8000a50a:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a50e:	c0 30       	breq	8000a514 <_fflush_r+0x68>
8000a510:	6f 55       	ld.w	r5,r7[0x54]
8000a512:	c0 f8       	rjmp	8000a530 <_fflush_r+0x84>
8000a514:	30 19       	mov	r9,1
8000a516:	6e 8b       	ld.w	r11,r7[0x20]
8000a518:	0c 9c       	mov	r12,r6
8000a51a:	5d 18       	icall	r8
8000a51c:	18 95       	mov	r5,r12
8000a51e:	5b fc       	cp.w	r12,-1
8000a520:	c0 81       	brne	8000a530 <_fflush_r+0x84>
8000a522:	6c 38       	ld.w	r8,r6[0xc]
8000a524:	59 d8       	cp.w	r8,29
8000a526:	c4 70       	breq	8000a5b4 <_fflush_r+0x108>
8000a528:	8e 68       	ld.sh	r8,r7[0xc]
8000a52a:	a7 a8       	sbr	r8,0x6
8000a52c:	ae 68       	st.h	r7[0xc],r8
8000a52e:	d8 22       	popm	r4-r7,pc
8000a530:	8e 68       	ld.sh	r8,r7[0xc]
8000a532:	ed b8 00 02 	bld	r8,0x2
8000a536:	c0 91       	brne	8000a548 <_fflush_r+0x9c>
8000a538:	6e 18       	ld.w	r8,r7[0x4]
8000a53a:	10 15       	sub	r5,r8
8000a53c:	6e d8       	ld.w	r8,r7[0x34]
8000a53e:	58 08       	cp.w	r8,0
8000a540:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a544:	eb d8 e1 15 	subne	r5,r5,r8
8000a548:	6e b8       	ld.w	r8,r7[0x2c]
8000a54a:	0c 9c       	mov	r12,r6
8000a54c:	30 09       	mov	r9,0
8000a54e:	0a 9a       	mov	r10,r5
8000a550:	6e 8b       	ld.w	r11,r7[0x20]
8000a552:	5d 18       	icall	r8
8000a554:	8e 68       	ld.sh	r8,r7[0xc]
8000a556:	0a 3c       	cp.w	r12,r5
8000a558:	c2 61       	brne	8000a5a4 <_fflush_r+0xf8>
8000a55a:	ab d8       	cbr	r8,0xb
8000a55c:	30 0c       	mov	r12,0
8000a55e:	6e 49       	ld.w	r9,r7[0x10]
8000a560:	ae 68       	st.h	r7[0xc],r8
8000a562:	8f 1c       	st.w	r7[0x4],r12
8000a564:	8f 09       	st.w	r7[0x0],r9
8000a566:	ed b8 00 0c 	bld	r8,0xc
8000a56a:	c2 51       	brne	8000a5b4 <_fflush_r+0x108>
8000a56c:	ef 45 00 54 	st.w	r7[84],r5
8000a570:	d8 22       	popm	r4-r7,pc
8000a572:	6e 45       	ld.w	r5,r7[0x10]
8000a574:	58 05       	cp.w	r5,0
8000a576:	c1 f0       	breq	8000a5b4 <_fflush_r+0x108>
8000a578:	6e 04       	ld.w	r4,r7[0x0]
8000a57a:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a57e:	8f 05       	st.w	r7[0x0],r5
8000a580:	f9 b8 01 00 	movne	r8,0
8000a584:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a588:	0a 14       	sub	r4,r5
8000a58a:	8f 28       	st.w	r7[0x8],r8
8000a58c:	c1 18       	rjmp	8000a5ae <_fflush_r+0x102>
8000a58e:	08 99       	mov	r9,r4
8000a590:	0a 9a       	mov	r10,r5
8000a592:	6e a8       	ld.w	r8,r7[0x28]
8000a594:	6e 8b       	ld.w	r11,r7[0x20]
8000a596:	0c 9c       	mov	r12,r6
8000a598:	5d 18       	icall	r8
8000a59a:	18 14       	sub	r4,r12
8000a59c:	58 0c       	cp.w	r12,0
8000a59e:	e0 89 00 07 	brgt	8000a5ac <_fflush_r+0x100>
8000a5a2:	8e 68       	ld.sh	r8,r7[0xc]
8000a5a4:	a7 a8       	sbr	r8,0x6
8000a5a6:	3f fc       	mov	r12,-1
8000a5a8:	ae 68       	st.h	r7[0xc],r8
8000a5aa:	d8 22       	popm	r4-r7,pc
8000a5ac:	18 05       	add	r5,r12
8000a5ae:	58 04       	cp.w	r4,0
8000a5b0:	fe 99 ff ef 	brgt	8000a58e <_fflush_r+0xe2>
8000a5b4:	d8 2a       	popm	r4-r7,pc,r12=0
8000a5b6:	d7 03       	nop

8000a5b8 <__sfp_lock_acquire>:
8000a5b8:	5e fc       	retal	r12

8000a5ba <__sfp_lock_release>:
8000a5ba:	5e fc       	retal	r12

8000a5bc <_cleanup_r>:
8000a5bc:	d4 01       	pushm	lr
8000a5be:	fe cb f0 ae 	sub	r11,pc,-3922
8000a5c2:	e0 a0 02 f7 	rcall	8000abb0 <_fwalk>
8000a5c6:	d8 02       	popm	pc

8000a5c8 <__sfmoreglue>:
8000a5c8:	d4 21       	pushm	r4-r7,lr
8000a5ca:	16 95       	mov	r5,r11
8000a5cc:	f6 06 10 5c 	mul	r6,r11,92
8000a5d0:	ec cb ff f4 	sub	r11,r6,-12
8000a5d4:	fe b0 e1 a4 	rcall	8000691c <_malloc_r>
8000a5d8:	18 97       	mov	r7,r12
8000a5da:	c0 90       	breq	8000a5ec <__sfmoreglue+0x24>
8000a5dc:	99 15       	st.w	r12[0x4],r5
8000a5de:	30 0b       	mov	r11,0
8000a5e0:	2f 4c       	sub	r12,-12
8000a5e2:	0c 9a       	mov	r10,r6
8000a5e4:	8f 2c       	st.w	r7[0x8],r12
8000a5e6:	8f 0b       	st.w	r7[0x0],r11
8000a5e8:	fe b0 e4 5a 	rcall	80006e9c <memset>
8000a5ec:	0e 9c       	mov	r12,r7
8000a5ee:	d8 22       	popm	r4-r7,pc

8000a5f0 <__sfp>:
8000a5f0:	d4 21       	pushm	r4-r7,lr
8000a5f2:	fe c8 e0 be 	sub	r8,pc,-8002
8000a5f6:	18 96       	mov	r6,r12
8000a5f8:	70 07       	ld.w	r7,r8[0x0]
8000a5fa:	6e 68       	ld.w	r8,r7[0x18]
8000a5fc:	58 08       	cp.w	r8,0
8000a5fe:	c0 31       	brne	8000a604 <__sfp+0x14>
8000a600:	0e 9c       	mov	r12,r7
8000a602:	c2 dc       	rcall	8000a65c <__sinit>
8000a604:	ee c7 ff 28 	sub	r7,r7,-216
8000a608:	30 05       	mov	r5,0
8000a60a:	6e 2c       	ld.w	r12,r7[0x8]
8000a60c:	6e 18       	ld.w	r8,r7[0x4]
8000a60e:	c0 68       	rjmp	8000a61a <__sfp+0x2a>
8000a610:	98 69       	ld.sh	r9,r12[0xc]
8000a612:	ea 09 19 00 	cp.h	r9,r5
8000a616:	c1 10       	breq	8000a638 <__sfp+0x48>
8000a618:	2a 4c       	sub	r12,-92
8000a61a:	20 18       	sub	r8,1
8000a61c:	cf a7       	brpl	8000a610 <__sfp+0x20>
8000a61e:	6e 08       	ld.w	r8,r7[0x0]
8000a620:	58 08       	cp.w	r8,0
8000a622:	c0 61       	brne	8000a62e <__sfp+0x3e>
8000a624:	30 4b       	mov	r11,4
8000a626:	0c 9c       	mov	r12,r6
8000a628:	cd 0f       	rcall	8000a5c8 <__sfmoreglue>
8000a62a:	8f 0c       	st.w	r7[0x0],r12
8000a62c:	c0 30       	breq	8000a632 <__sfp+0x42>
8000a62e:	6e 07       	ld.w	r7,r7[0x0]
8000a630:	ce db       	rjmp	8000a60a <__sfp+0x1a>
8000a632:	30 c8       	mov	r8,12
8000a634:	8d 38       	st.w	r6[0xc],r8
8000a636:	d8 22       	popm	r4-r7,pc
8000a638:	30 08       	mov	r8,0
8000a63a:	f9 48 00 4c 	st.w	r12[76],r8
8000a63e:	99 08       	st.w	r12[0x0],r8
8000a640:	99 28       	st.w	r12[0x8],r8
8000a642:	99 18       	st.w	r12[0x4],r8
8000a644:	99 48       	st.w	r12[0x10],r8
8000a646:	99 58       	st.w	r12[0x14],r8
8000a648:	99 68       	st.w	r12[0x18],r8
8000a64a:	99 d8       	st.w	r12[0x34],r8
8000a64c:	99 e8       	st.w	r12[0x38],r8
8000a64e:	f9 48 00 48 	st.w	r12[72],r8
8000a652:	3f f8       	mov	r8,-1
8000a654:	b8 78       	st.h	r12[0xe],r8
8000a656:	30 18       	mov	r8,1
8000a658:	b8 68       	st.h	r12[0xc],r8
8000a65a:	d8 22       	popm	r4-r7,pc

8000a65c <__sinit>:
8000a65c:	d4 21       	pushm	r4-r7,lr
8000a65e:	18 96       	mov	r6,r12
8000a660:	78 67       	ld.w	r7,r12[0x18]
8000a662:	58 07       	cp.w	r7,0
8000a664:	c4 91       	brne	8000a6f6 <__sinit+0x9a>
8000a666:	fe c8 00 aa 	sub	r8,pc,170
8000a66a:	30 15       	mov	r5,1
8000a66c:	99 a8       	st.w	r12[0x28],r8
8000a66e:	f9 47 00 d8 	st.w	r12[216],r7
8000a672:	f9 47 00 dc 	st.w	r12[220],r7
8000a676:	f9 47 00 e0 	st.w	r12[224],r7
8000a67a:	99 65       	st.w	r12[0x18],r5
8000a67c:	cb af       	rcall	8000a5f0 <__sfp>
8000a67e:	8d 0c       	st.w	r6[0x0],r12
8000a680:	0c 9c       	mov	r12,r6
8000a682:	cb 7f       	rcall	8000a5f0 <__sfp>
8000a684:	8d 1c       	st.w	r6[0x4],r12
8000a686:	0c 9c       	mov	r12,r6
8000a688:	cb 4f       	rcall	8000a5f0 <__sfp>
8000a68a:	6c 09       	ld.w	r9,r6[0x0]
8000a68c:	30 48       	mov	r8,4
8000a68e:	93 07       	st.w	r9[0x0],r7
8000a690:	b2 68       	st.h	r9[0xc],r8
8000a692:	93 17       	st.w	r9[0x4],r7
8000a694:	93 27       	st.w	r9[0x8],r7
8000a696:	6c 18       	ld.w	r8,r6[0x4]
8000a698:	b2 77       	st.h	r9[0xe],r7
8000a69a:	93 47       	st.w	r9[0x10],r7
8000a69c:	93 57       	st.w	r9[0x14],r7
8000a69e:	93 67       	st.w	r9[0x18],r7
8000a6a0:	93 89       	st.w	r9[0x20],r9
8000a6a2:	91 07       	st.w	r8[0x0],r7
8000a6a4:	91 17       	st.w	r8[0x4],r7
8000a6a6:	91 27       	st.w	r8[0x8],r7
8000a6a8:	fe ce f3 24 	sub	lr,pc,-3292
8000a6ac:	fe cb f3 54 	sub	r11,pc,-3244
8000a6b0:	93 9e       	st.w	r9[0x24],lr
8000a6b2:	93 ab       	st.w	r9[0x28],r11
8000a6b4:	fe ca f3 7c 	sub	r10,pc,-3204
8000a6b8:	fe c4 f3 88 	sub	r4,pc,-3192
8000a6bc:	93 ba       	st.w	r9[0x2c],r10
8000a6be:	93 c4       	st.w	r9[0x30],r4
8000a6c0:	30 99       	mov	r9,9
8000a6c2:	b0 69       	st.h	r8[0xc],r9
8000a6c4:	b0 75       	st.h	r8[0xe],r5
8000a6c6:	91 c4       	st.w	r8[0x30],r4
8000a6c8:	91 47       	st.w	r8[0x10],r7
8000a6ca:	91 57       	st.w	r8[0x14],r7
8000a6cc:	91 67       	st.w	r8[0x18],r7
8000a6ce:	91 88       	st.w	r8[0x20],r8
8000a6d0:	91 9e       	st.w	r8[0x24],lr
8000a6d2:	91 ab       	st.w	r8[0x28],r11
8000a6d4:	91 ba       	st.w	r8[0x2c],r10
8000a6d6:	8d 2c       	st.w	r6[0x8],r12
8000a6d8:	31 28       	mov	r8,18
8000a6da:	99 07       	st.w	r12[0x0],r7
8000a6dc:	b8 68       	st.h	r12[0xc],r8
8000a6de:	99 17       	st.w	r12[0x4],r7
8000a6e0:	99 27       	st.w	r12[0x8],r7
8000a6e2:	30 28       	mov	r8,2
8000a6e4:	b8 78       	st.h	r12[0xe],r8
8000a6e6:	99 c4       	st.w	r12[0x30],r4
8000a6e8:	99 67       	st.w	r12[0x18],r7
8000a6ea:	99 9e       	st.w	r12[0x24],lr
8000a6ec:	99 ab       	st.w	r12[0x28],r11
8000a6ee:	99 ba       	st.w	r12[0x2c],r10
8000a6f0:	99 47       	st.w	r12[0x10],r7
8000a6f2:	99 57       	st.w	r12[0x14],r7
8000a6f4:	99 8c       	st.w	r12[0x20],r12
8000a6f6:	d8 22       	popm	r4-r7,pc

8000a6f8 <_malloc_trim_r>:
8000a6f8:	d4 21       	pushm	r4-r7,lr
8000a6fa:	16 95       	mov	r5,r11
8000a6fc:	18 97       	mov	r7,r12
8000a6fe:	fe b0 d3 a7 	rcall	80004e4c <__malloc_lock>
8000a702:	e0 64 01 1c 	mov	r4,284
8000a706:	68 28       	ld.w	r8,r4[0x8]
8000a708:	70 16       	ld.w	r6,r8[0x4]
8000a70a:	e0 16 ff fc 	andl	r6,0xfffc
8000a70e:	ec c8 ff 91 	sub	r8,r6,-111
8000a712:	f0 05 01 05 	sub	r5,r8,r5
8000a716:	e0 15 ff 80 	andl	r5,0xff80
8000a71a:	ea c5 00 80 	sub	r5,r5,128
8000a71e:	e0 45 00 7f 	cp.w	r5,127
8000a722:	e0 8a 00 25 	brle	8000a76c <_malloc_trim_r+0x74>
8000a726:	30 0b       	mov	r11,0
8000a728:	0e 9c       	mov	r12,r7
8000a72a:	fe b0 e5 21 	rcall	8000716c <_sbrk_r>
8000a72e:	68 28       	ld.w	r8,r4[0x8]
8000a730:	0c 08       	add	r8,r6
8000a732:	10 3c       	cp.w	r12,r8
8000a734:	c1 c1       	brne	8000a76c <_malloc_trim_r+0x74>
8000a736:	ea 0b 11 00 	rsub	r11,r5,0
8000a73a:	0e 9c       	mov	r12,r7
8000a73c:	fe b0 e5 18 	rcall	8000716c <_sbrk_r>
8000a740:	5b fc       	cp.w	r12,-1
8000a742:	c1 91       	brne	8000a774 <_malloc_trim_r+0x7c>
8000a744:	30 0b       	mov	r11,0
8000a746:	0e 9c       	mov	r12,r7
8000a748:	fe b0 e5 12 	rcall	8000716c <_sbrk_r>
8000a74c:	68 28       	ld.w	r8,r4[0x8]
8000a74e:	f8 08 01 09 	sub	r9,r12,r8
8000a752:	58 f9       	cp.w	r9,15
8000a754:	e0 8a 00 0c 	brle	8000a76c <_malloc_trim_r+0x74>
8000a758:	a1 a9       	sbr	r9,0x0
8000a75a:	91 19       	st.w	r8[0x4],r9
8000a75c:	e0 68 05 28 	mov	r8,1320
8000a760:	70 09       	ld.w	r9,r8[0x0]
8000a762:	e0 68 07 a8 	mov	r8,1960
8000a766:	f8 09 01 09 	sub	r9,r12,r9
8000a76a:	91 09       	st.w	r8[0x0],r9
8000a76c:	0e 9c       	mov	r12,r7
8000a76e:	fe b0 d3 7d 	rcall	80004e68 <__malloc_unlock>
8000a772:	d8 2a       	popm	r4-r7,pc,r12=0
8000a774:	68 28       	ld.w	r8,r4[0x8]
8000a776:	0a 16       	sub	r6,r5
8000a778:	a1 a6       	sbr	r6,0x0
8000a77a:	91 16       	st.w	r8[0x4],r6
8000a77c:	e0 68 07 a8 	mov	r8,1960
8000a780:	70 09       	ld.w	r9,r8[0x0]
8000a782:	0a 19       	sub	r9,r5
8000a784:	0e 9c       	mov	r12,r7
8000a786:	91 09       	st.w	r8[0x0],r9
8000a788:	fe b0 d3 70 	rcall	80004e68 <__malloc_unlock>
8000a78c:	da 2a       	popm	r4-r7,pc,r12=1
8000a78e:	d7 03       	nop

8000a790 <_free_r>:
8000a790:	d4 21       	pushm	r4-r7,lr
8000a792:	16 96       	mov	r6,r11
8000a794:	18 97       	mov	r7,r12
8000a796:	58 0b       	cp.w	r11,0
8000a798:	e0 80 00 c0 	breq	8000a918 <_free_r+0x188>
8000a79c:	fe b0 d3 58 	rcall	80004e4c <__malloc_lock>
8000a7a0:	20 86       	sub	r6,8
8000a7a2:	e0 6a 01 1c 	mov	r10,284
8000a7a6:	6c 18       	ld.w	r8,r6[0x4]
8000a7a8:	74 2e       	ld.w	lr,r10[0x8]
8000a7aa:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a7ae:	a1 c8       	cbr	r8,0x0
8000a7b0:	ec 08 00 09 	add	r9,r6,r8
8000a7b4:	72 1b       	ld.w	r11,r9[0x4]
8000a7b6:	e0 1b ff fc 	andl	r11,0xfffc
8000a7ba:	1c 39       	cp.w	r9,lr
8000a7bc:	c1 e1       	brne	8000a7f8 <_free_r+0x68>
8000a7be:	f6 08 00 08 	add	r8,r11,r8
8000a7c2:	58 0c       	cp.w	r12,0
8000a7c4:	c0 81       	brne	8000a7d4 <_free_r+0x44>
8000a7c6:	6c 09       	ld.w	r9,r6[0x0]
8000a7c8:	12 16       	sub	r6,r9
8000a7ca:	12 08       	add	r8,r9
8000a7cc:	6c 3b       	ld.w	r11,r6[0xc]
8000a7ce:	6c 29       	ld.w	r9,r6[0x8]
8000a7d0:	97 29       	st.w	r11[0x8],r9
8000a7d2:	93 3b       	st.w	r9[0xc],r11
8000a7d4:	10 99       	mov	r9,r8
8000a7d6:	95 26       	st.w	r10[0x8],r6
8000a7d8:	a1 a9       	sbr	r9,0x0
8000a7da:	8d 19       	st.w	r6[0x4],r9
8000a7dc:	e0 69 05 24 	mov	r9,1316
8000a7e0:	72 09       	ld.w	r9,r9[0x0]
8000a7e2:	12 38       	cp.w	r8,r9
8000a7e4:	c0 63       	brcs	8000a7f0 <_free_r+0x60>
8000a7e6:	e0 68 07 a4 	mov	r8,1956
8000a7ea:	0e 9c       	mov	r12,r7
8000a7ec:	70 0b       	ld.w	r11,r8[0x0]
8000a7ee:	c8 5f       	rcall	8000a6f8 <_malloc_trim_r>
8000a7f0:	0e 9c       	mov	r12,r7
8000a7f2:	fe b0 d3 3b 	rcall	80004e68 <__malloc_unlock>
8000a7f6:	d8 22       	popm	r4-r7,pc
8000a7f8:	93 1b       	st.w	r9[0x4],r11
8000a7fa:	58 0c       	cp.w	r12,0
8000a7fc:	c0 30       	breq	8000a802 <_free_r+0x72>
8000a7fe:	30 0c       	mov	r12,0
8000a800:	c1 08       	rjmp	8000a820 <_free_r+0x90>
8000a802:	6c 0e       	ld.w	lr,r6[0x0]
8000a804:	f4 c5 ff f8 	sub	r5,r10,-8
8000a808:	1c 16       	sub	r6,lr
8000a80a:	1c 08       	add	r8,lr
8000a80c:	6c 2e       	ld.w	lr,r6[0x8]
8000a80e:	0a 3e       	cp.w	lr,r5
8000a810:	f9 bc 00 01 	moveq	r12,1
8000a814:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a818:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a81c:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a820:	f2 0b 00 0e 	add	lr,r9,r11
8000a824:	7c 1e       	ld.w	lr,lr[0x4]
8000a826:	ed be 00 00 	bld	lr,0x0
8000a82a:	c1 40       	breq	8000a852 <_free_r+0xc2>
8000a82c:	16 08       	add	r8,r11
8000a82e:	58 0c       	cp.w	r12,0
8000a830:	c0 d1       	brne	8000a84a <_free_r+0xba>
8000a832:	e0 6e 01 1c 	mov	lr,284
8000a836:	72 2b       	ld.w	r11,r9[0x8]
8000a838:	2f 8e       	sub	lr,-8
8000a83a:	1c 3b       	cp.w	r11,lr
8000a83c:	c0 71       	brne	8000a84a <_free_r+0xba>
8000a83e:	97 36       	st.w	r11[0xc],r6
8000a840:	97 26       	st.w	r11[0x8],r6
8000a842:	8d 2b       	st.w	r6[0x8],r11
8000a844:	8d 3b       	st.w	r6[0xc],r11
8000a846:	30 1c       	mov	r12,1
8000a848:	c0 58       	rjmp	8000a852 <_free_r+0xc2>
8000a84a:	72 2b       	ld.w	r11,r9[0x8]
8000a84c:	72 39       	ld.w	r9,r9[0xc]
8000a84e:	93 2b       	st.w	r9[0x8],r11
8000a850:	97 39       	st.w	r11[0xc],r9
8000a852:	10 99       	mov	r9,r8
8000a854:	ec 08 09 08 	st.w	r6[r8],r8
8000a858:	a1 a9       	sbr	r9,0x0
8000a85a:	8d 19       	st.w	r6[0x4],r9
8000a85c:	58 0c       	cp.w	r12,0
8000a85e:	c5 a1       	brne	8000a912 <_free_r+0x182>
8000a860:	e0 48 01 ff 	cp.w	r8,511
8000a864:	e0 8b 00 13 	brhi	8000a88a <_free_r+0xfa>
8000a868:	a3 98       	lsr	r8,0x3
8000a86a:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a86e:	72 2b       	ld.w	r11,r9[0x8]
8000a870:	8d 39       	st.w	r6[0xc],r9
8000a872:	8d 2b       	st.w	r6[0x8],r11
8000a874:	97 36       	st.w	r11[0xc],r6
8000a876:	93 26       	st.w	r9[0x8],r6
8000a878:	a3 48       	asr	r8,0x2
8000a87a:	74 19       	ld.w	r9,r10[0x4]
8000a87c:	30 1b       	mov	r11,1
8000a87e:	f6 08 09 48 	lsl	r8,r11,r8
8000a882:	f3 e8 10 08 	or	r8,r9,r8
8000a886:	95 18       	st.w	r10[0x4],r8
8000a888:	c4 58       	rjmp	8000a912 <_free_r+0x182>
8000a88a:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a88e:	58 4b       	cp.w	r11,4
8000a890:	e0 8b 00 06 	brhi	8000a89c <_free_r+0x10c>
8000a894:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a898:	2c 8b       	sub	r11,-56
8000a89a:	c2 08       	rjmp	8000a8da <_free_r+0x14a>
8000a89c:	59 4b       	cp.w	r11,20
8000a89e:	e0 8b 00 04 	brhi	8000a8a6 <_free_r+0x116>
8000a8a2:	2a 5b       	sub	r11,-91
8000a8a4:	c1 b8       	rjmp	8000a8da <_free_r+0x14a>
8000a8a6:	e0 4b 00 54 	cp.w	r11,84
8000a8aa:	e0 8b 00 06 	brhi	8000a8b6 <_free_r+0x126>
8000a8ae:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a8b2:	29 2b       	sub	r11,-110
8000a8b4:	c1 38       	rjmp	8000a8da <_free_r+0x14a>
8000a8b6:	e0 4b 01 54 	cp.w	r11,340
8000a8ba:	e0 8b 00 06 	brhi	8000a8c6 <_free_r+0x136>
8000a8be:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a8c2:	28 9b       	sub	r11,-119
8000a8c4:	c0 b8       	rjmp	8000a8da <_free_r+0x14a>
8000a8c6:	e0 4b 05 54 	cp.w	r11,1364
8000a8ca:	e0 88 00 05 	brls	8000a8d4 <_free_r+0x144>
8000a8ce:	37 eb       	mov	r11,126
8000a8d0:	c0 58       	rjmp	8000a8da <_free_r+0x14a>
8000a8d2:	d7 03       	nop
8000a8d4:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a8d8:	28 4b       	sub	r11,-124
8000a8da:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a8de:	78 29       	ld.w	r9,r12[0x8]
8000a8e0:	18 39       	cp.w	r9,r12
8000a8e2:	c0 e1       	brne	8000a8fe <_free_r+0x16e>
8000a8e4:	74 18       	ld.w	r8,r10[0x4]
8000a8e6:	a3 4b       	asr	r11,0x2
8000a8e8:	30 1c       	mov	r12,1
8000a8ea:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a8ee:	f1 eb 10 0b 	or	r11,r8,r11
8000a8f2:	12 98       	mov	r8,r9
8000a8f4:	95 1b       	st.w	r10[0x4],r11
8000a8f6:	c0 a8       	rjmp	8000a90a <_free_r+0x17a>
8000a8f8:	72 29       	ld.w	r9,r9[0x8]
8000a8fa:	18 39       	cp.w	r9,r12
8000a8fc:	c0 60       	breq	8000a908 <_free_r+0x178>
8000a8fe:	72 1a       	ld.w	r10,r9[0x4]
8000a900:	e0 1a ff fc 	andl	r10,0xfffc
8000a904:	14 38       	cp.w	r8,r10
8000a906:	cf 93       	brcs	8000a8f8 <_free_r+0x168>
8000a908:	72 38       	ld.w	r8,r9[0xc]
8000a90a:	8d 38       	st.w	r6[0xc],r8
8000a90c:	8d 29       	st.w	r6[0x8],r9
8000a90e:	93 36       	st.w	r9[0xc],r6
8000a910:	91 26       	st.w	r8[0x8],r6
8000a912:	0e 9c       	mov	r12,r7
8000a914:	fe b0 d2 aa 	rcall	80004e68 <__malloc_unlock>
8000a918:	d8 22       	popm	r4-r7,pc
8000a91a:	d7 03       	nop

8000a91c <__sfvwrite_r>:
8000a91c:	d4 31       	pushm	r0-r7,lr
8000a91e:	20 3d       	sub	sp,12
8000a920:	14 94       	mov	r4,r10
8000a922:	18 95       	mov	r5,r12
8000a924:	16 97       	mov	r7,r11
8000a926:	74 28       	ld.w	r8,r10[0x8]
8000a928:	58 08       	cp.w	r8,0
8000a92a:	e0 80 01 40 	breq	8000abaa <__sfvwrite_r+0x28e>
8000a92e:	96 68       	ld.sh	r8,r11[0xc]
8000a930:	ed b8 00 03 	bld	r8,0x3
8000a934:	c0 41       	brne	8000a93c <__sfvwrite_r+0x20>
8000a936:	76 48       	ld.w	r8,r11[0x10]
8000a938:	58 08       	cp.w	r8,0
8000a93a:	c0 c1       	brne	8000a952 <__sfvwrite_r+0x36>
8000a93c:	0e 9b       	mov	r11,r7
8000a93e:	0a 9c       	mov	r12,r5
8000a940:	fe b0 f6 0c 	rcall	80009558 <__swsetup_r>
8000a944:	c0 70       	breq	8000a952 <__sfvwrite_r+0x36>
8000a946:	8e 68       	ld.sh	r8,r7[0xc]
8000a948:	a7 a8       	sbr	r8,0x6
8000a94a:	ae 68       	st.h	r7[0xc],r8
8000a94c:	30 98       	mov	r8,9
8000a94e:	8b 38       	st.w	r5[0xc],r8
8000a950:	c2 b9       	rjmp	8000aba6 <__sfvwrite_r+0x28a>
8000a952:	8e 63       	ld.sh	r3,r7[0xc]
8000a954:	68 00       	ld.w	r0,r4[0x0]
8000a956:	06 96       	mov	r6,r3
8000a958:	e2 16 00 02 	andl	r6,0x2,COH
8000a95c:	c2 10       	breq	8000a99e <__sfvwrite_r+0x82>
8000a95e:	30 03       	mov	r3,0
8000a960:	e0 62 04 00 	mov	r2,1024
8000a964:	06 96       	mov	r6,r3
8000a966:	c0 48       	rjmp	8000a96e <__sfvwrite_r+0x52>
8000a968:	60 03       	ld.w	r3,r0[0x0]
8000a96a:	60 16       	ld.w	r6,r0[0x4]
8000a96c:	2f 80       	sub	r0,-8
8000a96e:	58 06       	cp.w	r6,0
8000a970:	cf c0       	breq	8000a968 <__sfvwrite_r+0x4c>
8000a972:	e0 46 04 00 	cp.w	r6,1024
8000a976:	ec 09 17 80 	movls	r9,r6
8000a97a:	e4 09 17 b0 	movhi	r9,r2
8000a97e:	06 9a       	mov	r10,r3
8000a980:	6e a8       	ld.w	r8,r7[0x28]
8000a982:	6e 8b       	ld.w	r11,r7[0x20]
8000a984:	0a 9c       	mov	r12,r5
8000a986:	5d 18       	icall	r8
8000a988:	18 16       	sub	r6,r12
8000a98a:	58 0c       	cp.w	r12,0
8000a98c:	e0 8a 01 0a 	brle	8000aba0 <__sfvwrite_r+0x284>
8000a990:	68 28       	ld.w	r8,r4[0x8]
8000a992:	18 18       	sub	r8,r12
8000a994:	89 28       	st.w	r4[0x8],r8
8000a996:	e0 80 01 0a 	breq	8000abaa <__sfvwrite_r+0x28e>
8000a99a:	18 03       	add	r3,r12
8000a99c:	ce 9b       	rjmp	8000a96e <__sfvwrite_r+0x52>
8000a99e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a9a2:	c0 70       	breq	8000a9b0 <__sfvwrite_r+0x94>
8000a9a4:	50 06       	stdsp	sp[0x0],r6
8000a9a6:	0c 93       	mov	r3,r6
8000a9a8:	0c 91       	mov	r1,r6
8000a9aa:	50 15       	stdsp	sp[0x4],r5
8000a9ac:	08 92       	mov	r2,r4
8000a9ae:	c9 c8       	rjmp	8000aae6 <__sfvwrite_r+0x1ca>
8000a9b0:	06 96       	mov	r6,r3
8000a9b2:	08 91       	mov	r1,r4
8000a9b4:	c0 48       	rjmp	8000a9bc <__sfvwrite_r+0xa0>
8000a9b6:	60 03       	ld.w	r3,r0[0x0]
8000a9b8:	60 16       	ld.w	r6,r0[0x4]
8000a9ba:	2f 80       	sub	r0,-8
8000a9bc:	58 06       	cp.w	r6,0
8000a9be:	cf c0       	breq	8000a9b6 <__sfvwrite_r+0x9a>
8000a9c0:	8e 68       	ld.sh	r8,r7[0xc]
8000a9c2:	6e 24       	ld.w	r4,r7[0x8]
8000a9c4:	10 99       	mov	r9,r8
8000a9c6:	e2 19 02 00 	andl	r9,0x200,COH
8000a9ca:	c5 50       	breq	8000aa74 <__sfvwrite_r+0x158>
8000a9cc:	08 36       	cp.w	r6,r4
8000a9ce:	c4 43       	brcs	8000aa56 <__sfvwrite_r+0x13a>
8000a9d0:	10 99       	mov	r9,r8
8000a9d2:	e2 19 04 80 	andl	r9,0x480,COH
8000a9d6:	c4 00       	breq	8000aa56 <__sfvwrite_r+0x13a>
8000a9d8:	6e 4b       	ld.w	r11,r7[0x10]
8000a9da:	6e 09       	ld.w	r9,r7[0x0]
8000a9dc:	16 19       	sub	r9,r11
8000a9de:	50 09       	stdsp	sp[0x0],r9
8000a9e0:	6e 59       	ld.w	r9,r7[0x14]
8000a9e2:	10 9c       	mov	r12,r8
8000a9e4:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a9e8:	30 28       	mov	r8,2
8000a9ea:	f4 08 0c 08 	divs	r8,r10,r8
8000a9ee:	fa e9 00 04 	st.d	sp[4],r8
8000a9f2:	10 94       	mov	r4,r8
8000a9f4:	40 09       	lddsp	r9,sp[0x0]
8000a9f6:	e2 1c 04 00 	andl	r12,0x400,COH
8000a9fa:	2f f9       	sub	r9,-1
8000a9fc:	0c 09       	add	r9,r6
8000a9fe:	12 38       	cp.w	r8,r9
8000aa00:	f2 04 17 30 	movlo	r4,r9
8000aa04:	58 0c       	cp.w	r12,0
8000aa06:	c1 10       	breq	8000aa28 <__sfvwrite_r+0x10c>
8000aa08:	08 9b       	mov	r11,r4
8000aa0a:	0a 9c       	mov	r12,r5
8000aa0c:	fe b0 df 88 	rcall	8000691c <_malloc_r>
8000aa10:	18 92       	mov	r2,r12
8000aa12:	c1 40       	breq	8000aa3a <__sfvwrite_r+0x11e>
8000aa14:	40 0a       	lddsp	r10,sp[0x0]
8000aa16:	6e 4b       	ld.w	r11,r7[0x10]
8000aa18:	fe b0 e1 9e 	rcall	80006d54 <memcpy>
8000aa1c:	8e 68       	ld.sh	r8,r7[0xc]
8000aa1e:	e0 18 fb 7f 	andl	r8,0xfb7f
8000aa22:	a7 b8       	sbr	r8,0x7
8000aa24:	ae 68       	st.h	r7[0xc],r8
8000aa26:	c0 d8       	rjmp	8000aa40 <__sfvwrite_r+0x124>
8000aa28:	08 9a       	mov	r10,r4
8000aa2a:	0a 9c       	mov	r12,r5
8000aa2c:	fe b0 e2 40 	rcall	80006eac <_realloc_r>
8000aa30:	18 92       	mov	r2,r12
8000aa32:	c0 71       	brne	8000aa40 <__sfvwrite_r+0x124>
8000aa34:	6e 4b       	ld.w	r11,r7[0x10]
8000aa36:	0a 9c       	mov	r12,r5
8000aa38:	ca ce       	rcall	8000a790 <_free_r>
8000aa3a:	30 c8       	mov	r8,12
8000aa3c:	8b 38       	st.w	r5[0xc],r8
8000aa3e:	cb 18       	rjmp	8000aba0 <__sfvwrite_r+0x284>
8000aa40:	40 0a       	lddsp	r10,sp[0x0]
8000aa42:	40 09       	lddsp	r9,sp[0x0]
8000aa44:	e8 0a 01 0a 	sub	r10,r4,r10
8000aa48:	e4 09 00 08 	add	r8,r2,r9
8000aa4c:	8f 54       	st.w	r7[0x14],r4
8000aa4e:	8f 2a       	st.w	r7[0x8],r10
8000aa50:	8f 08       	st.w	r7[0x0],r8
8000aa52:	8f 42       	st.w	r7[0x10],r2
8000aa54:	0c 94       	mov	r4,r6
8000aa56:	08 36       	cp.w	r6,r4
8000aa58:	ec 04 17 30 	movlo	r4,r6
8000aa5c:	06 9b       	mov	r11,r3
8000aa5e:	08 9a       	mov	r10,r4
8000aa60:	6e 0c       	ld.w	r12,r7[0x0]
8000aa62:	c3 ad       	rcall	8000acd6 <memmove>
8000aa64:	6e 08       	ld.w	r8,r7[0x0]
8000aa66:	08 08       	add	r8,r4
8000aa68:	8f 08       	st.w	r7[0x0],r8
8000aa6a:	6e 28       	ld.w	r8,r7[0x8]
8000aa6c:	08 18       	sub	r8,r4
8000aa6e:	0c 94       	mov	r4,r6
8000aa70:	8f 28       	st.w	r7[0x8],r8
8000aa72:	c2 e8       	rjmp	8000aace <__sfvwrite_r+0x1b2>
8000aa74:	08 36       	cp.w	r6,r4
8000aa76:	5f ba       	srhi	r10
8000aa78:	6e 0c       	ld.w	r12,r7[0x0]
8000aa7a:	6e 48       	ld.w	r8,r7[0x10]
8000aa7c:	10 3c       	cp.w	r12,r8
8000aa7e:	5f b8       	srhi	r8
8000aa80:	f5 e8 00 08 	and	r8,r10,r8
8000aa84:	f2 08 18 00 	cp.b	r8,r9
8000aa88:	c0 d0       	breq	8000aaa2 <__sfvwrite_r+0x186>
8000aa8a:	06 9b       	mov	r11,r3
8000aa8c:	08 9a       	mov	r10,r4
8000aa8e:	c2 4d       	rcall	8000acd6 <memmove>
8000aa90:	6e 08       	ld.w	r8,r7[0x0]
8000aa92:	08 08       	add	r8,r4
8000aa94:	0e 9b       	mov	r11,r7
8000aa96:	8f 08       	st.w	r7[0x0],r8
8000aa98:	0a 9c       	mov	r12,r5
8000aa9a:	fe b0 fd 09 	rcall	8000a4ac <_fflush_r>
8000aa9e:	c1 80       	breq	8000aace <__sfvwrite_r+0x1b2>
8000aaa0:	c8 08       	rjmp	8000aba0 <__sfvwrite_r+0x284>
8000aaa2:	6e 59       	ld.w	r9,r7[0x14]
8000aaa4:	12 36       	cp.w	r6,r9
8000aaa6:	c0 a3       	brcs	8000aaba <__sfvwrite_r+0x19e>
8000aaa8:	6e a8       	ld.w	r8,r7[0x28]
8000aaaa:	06 9a       	mov	r10,r3
8000aaac:	6e 8b       	ld.w	r11,r7[0x20]
8000aaae:	0a 9c       	mov	r12,r5
8000aab0:	5d 18       	icall	r8
8000aab2:	18 94       	mov	r4,r12
8000aab4:	e0 89 00 0d 	brgt	8000aace <__sfvwrite_r+0x1b2>
8000aab8:	c7 48       	rjmp	8000aba0 <__sfvwrite_r+0x284>
8000aaba:	0c 9a       	mov	r10,r6
8000aabc:	06 9b       	mov	r11,r3
8000aabe:	c0 cd       	rcall	8000acd6 <memmove>
8000aac0:	6e 08       	ld.w	r8,r7[0x0]
8000aac2:	0c 08       	add	r8,r6
8000aac4:	0c 94       	mov	r4,r6
8000aac6:	8f 08       	st.w	r7[0x0],r8
8000aac8:	6e 28       	ld.w	r8,r7[0x8]
8000aaca:	0c 18       	sub	r8,r6
8000aacc:	8f 28       	st.w	r7[0x8],r8
8000aace:	62 28       	ld.w	r8,r1[0x8]
8000aad0:	08 18       	sub	r8,r4
8000aad2:	83 28       	st.w	r1[0x8],r8
8000aad4:	c6 b0       	breq	8000abaa <__sfvwrite_r+0x28e>
8000aad6:	08 16       	sub	r6,r4
8000aad8:	08 03       	add	r3,r4
8000aada:	c7 1b       	rjmp	8000a9bc <__sfvwrite_r+0xa0>
8000aadc:	60 03       	ld.w	r3,r0[0x0]
8000aade:	60 11       	ld.w	r1,r0[0x4]
8000aae0:	30 08       	mov	r8,0
8000aae2:	2f 80       	sub	r0,-8
8000aae4:	50 08       	stdsp	sp[0x0],r8
8000aae6:	58 01       	cp.w	r1,0
8000aae8:	cf a0       	breq	8000aadc <__sfvwrite_r+0x1c0>
8000aaea:	40 0a       	lddsp	r10,sp[0x0]
8000aaec:	58 0a       	cp.w	r10,0
8000aaee:	c1 41       	brne	8000ab16 <__sfvwrite_r+0x1fa>
8000aaf0:	e2 c6 ff ff 	sub	r6,r1,-1
8000aaf4:	02 9a       	mov	r10,r1
8000aaf6:	30 ab       	mov	r11,10
8000aaf8:	06 9c       	mov	r12,r3
8000aafa:	ce 3c       	rcall	8000acc0 <memchr>
8000aafc:	f8 c8 ff ff 	sub	r8,r12,-1
8000ab00:	58 0c       	cp.w	r12,0
8000ab02:	f1 d3 e1 16 	subne	r6,r8,r3
8000ab06:	f9 b9 01 01 	movne	r9,1
8000ab0a:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ab0e:	f9 b8 00 01 	moveq	r8,1
8000ab12:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000ab16:	02 36       	cp.w	r6,r1
8000ab18:	ec 04 17 80 	movls	r4,r6
8000ab1c:	e2 04 17 b0 	movhi	r4,r1
8000ab20:	6e 59       	ld.w	r9,r7[0x14]
8000ab22:	6e 25       	ld.w	r5,r7[0x8]
8000ab24:	f2 05 00 05 	add	r5,r9,r5
8000ab28:	0a 34       	cp.w	r4,r5
8000ab2a:	5f 9a       	srgt	r10
8000ab2c:	6e 0c       	ld.w	r12,r7[0x0]
8000ab2e:	6e 48       	ld.w	r8,r7[0x10]
8000ab30:	10 3c       	cp.w	r12,r8
8000ab32:	5f b8       	srhi	r8
8000ab34:	f5 e8 00 08 	and	r8,r10,r8
8000ab38:	30 0a       	mov	r10,0
8000ab3a:	f4 08 18 00 	cp.b	r8,r10
8000ab3e:	c0 d0       	breq	8000ab58 <__sfvwrite_r+0x23c>
8000ab40:	06 9b       	mov	r11,r3
8000ab42:	0a 9a       	mov	r10,r5
8000ab44:	cc 9c       	rcall	8000acd6 <memmove>
8000ab46:	6e 08       	ld.w	r8,r7[0x0]
8000ab48:	0a 08       	add	r8,r5
8000ab4a:	0e 9b       	mov	r11,r7
8000ab4c:	8f 08       	st.w	r7[0x0],r8
8000ab4e:	40 1c       	lddsp	r12,sp[0x4]
8000ab50:	fe b0 fc ae 	rcall	8000a4ac <_fflush_r>
8000ab54:	c1 70       	breq	8000ab82 <__sfvwrite_r+0x266>
8000ab56:	c2 58       	rjmp	8000aba0 <__sfvwrite_r+0x284>
8000ab58:	12 34       	cp.w	r4,r9
8000ab5a:	c0 a5       	brlt	8000ab6e <__sfvwrite_r+0x252>
8000ab5c:	6e a8       	ld.w	r8,r7[0x28]
8000ab5e:	06 9a       	mov	r10,r3
8000ab60:	6e 8b       	ld.w	r11,r7[0x20]
8000ab62:	40 1c       	lddsp	r12,sp[0x4]
8000ab64:	5d 18       	icall	r8
8000ab66:	18 95       	mov	r5,r12
8000ab68:	e0 89 00 0d 	brgt	8000ab82 <__sfvwrite_r+0x266>
8000ab6c:	c1 a8       	rjmp	8000aba0 <__sfvwrite_r+0x284>
8000ab6e:	08 9a       	mov	r10,r4
8000ab70:	06 9b       	mov	r11,r3
8000ab72:	cb 2c       	rcall	8000acd6 <memmove>
8000ab74:	6e 08       	ld.w	r8,r7[0x0]
8000ab76:	08 08       	add	r8,r4
8000ab78:	08 95       	mov	r5,r4
8000ab7a:	8f 08       	st.w	r7[0x0],r8
8000ab7c:	6e 28       	ld.w	r8,r7[0x8]
8000ab7e:	08 18       	sub	r8,r4
8000ab80:	8f 28       	st.w	r7[0x8],r8
8000ab82:	0a 16       	sub	r6,r5
8000ab84:	c0 71       	brne	8000ab92 <__sfvwrite_r+0x276>
8000ab86:	0e 9b       	mov	r11,r7
8000ab88:	40 1c       	lddsp	r12,sp[0x4]
8000ab8a:	fe b0 fc 91 	rcall	8000a4ac <_fflush_r>
8000ab8e:	c0 91       	brne	8000aba0 <__sfvwrite_r+0x284>
8000ab90:	50 06       	stdsp	sp[0x0],r6
8000ab92:	64 28       	ld.w	r8,r2[0x8]
8000ab94:	0a 18       	sub	r8,r5
8000ab96:	85 28       	st.w	r2[0x8],r8
8000ab98:	c0 90       	breq	8000abaa <__sfvwrite_r+0x28e>
8000ab9a:	0a 11       	sub	r1,r5
8000ab9c:	0a 03       	add	r3,r5
8000ab9e:	ca 4b       	rjmp	8000aae6 <__sfvwrite_r+0x1ca>
8000aba0:	8e 68       	ld.sh	r8,r7[0xc]
8000aba2:	a7 a8       	sbr	r8,0x6
8000aba4:	ae 68       	st.h	r7[0xc],r8
8000aba6:	3f fc       	mov	r12,-1
8000aba8:	c0 28       	rjmp	8000abac <__sfvwrite_r+0x290>
8000abaa:	30 0c       	mov	r12,0
8000abac:	2f dd       	sub	sp,-12
8000abae:	d8 32       	popm	r0-r7,pc

8000abb0 <_fwalk>:
8000abb0:	d4 31       	pushm	r0-r7,lr
8000abb2:	30 05       	mov	r5,0
8000abb4:	16 91       	mov	r1,r11
8000abb6:	f8 c7 ff 28 	sub	r7,r12,-216
8000abba:	0a 92       	mov	r2,r5
8000abbc:	fe b0 fc fe 	rcall	8000a5b8 <__sfp_lock_acquire>
8000abc0:	3f f3       	mov	r3,-1
8000abc2:	c1 68       	rjmp	8000abee <_fwalk+0x3e>
8000abc4:	6e 26       	ld.w	r6,r7[0x8]
8000abc6:	6e 14       	ld.w	r4,r7[0x4]
8000abc8:	2f 46       	sub	r6,-12
8000abca:	c0 c8       	rjmp	8000abe2 <_fwalk+0x32>
8000abcc:	8c 08       	ld.sh	r8,r6[0x0]
8000abce:	e4 08 19 00 	cp.h	r8,r2
8000abd2:	c0 70       	breq	8000abe0 <_fwalk+0x30>
8000abd4:	8c 18       	ld.sh	r8,r6[0x2]
8000abd6:	e6 08 19 00 	cp.h	r8,r3
8000abda:	c0 30       	breq	8000abe0 <_fwalk+0x30>
8000abdc:	5d 11       	icall	r1
8000abde:	18 45       	or	r5,r12
8000abe0:	2a 46       	sub	r6,-92
8000abe2:	20 14       	sub	r4,1
8000abe4:	ec cc 00 0c 	sub	r12,r6,12
8000abe8:	58 04       	cp.w	r4,0
8000abea:	cf 14       	brge	8000abcc <_fwalk+0x1c>
8000abec:	6e 07       	ld.w	r7,r7[0x0]
8000abee:	58 07       	cp.w	r7,0
8000abf0:	ce a1       	brne	8000abc4 <_fwalk+0x14>
8000abf2:	fe b0 fc e4 	rcall	8000a5ba <__sfp_lock_release>
8000abf6:	0a 9c       	mov	r12,r5
8000abf8:	d8 32       	popm	r0-r7,pc
8000abfa:	d7 03       	nop

8000abfc <_localeconv_r>:
8000abfc:	fe cc e2 80 	sub	r12,pc,-7552
8000ac00:	5e fc       	retal	r12
8000ac02:	d7 03       	nop

8000ac04 <__smakebuf_r>:
8000ac04:	d4 21       	pushm	r4-r7,lr
8000ac06:	20 fd       	sub	sp,60
8000ac08:	96 68       	ld.sh	r8,r11[0xc]
8000ac0a:	16 97       	mov	r7,r11
8000ac0c:	18 96       	mov	r6,r12
8000ac0e:	e2 18 00 02 	andl	r8,0x2,COH
8000ac12:	c3 d1       	brne	8000ac8c <__smakebuf_r+0x88>
8000ac14:	96 7b       	ld.sh	r11,r11[0xe]
8000ac16:	f0 0b 19 00 	cp.h	r11,r8
8000ac1a:	c0 55       	brlt	8000ac24 <__smakebuf_r+0x20>
8000ac1c:	1a 9a       	mov	r10,sp
8000ac1e:	e0 a0 04 81 	rcall	8000b520 <_fstat_r>
8000ac22:	c0 f4       	brge	8000ac40 <__smakebuf_r+0x3c>
8000ac24:	8e 65       	ld.sh	r5,r7[0xc]
8000ac26:	0a 98       	mov	r8,r5
8000ac28:	ab b8       	sbr	r8,0xb
8000ac2a:	e2 15 00 80 	andl	r5,0x80,COH
8000ac2e:	ae 68       	st.h	r7[0xc],r8
8000ac30:	30 04       	mov	r4,0
8000ac32:	e0 68 04 00 	mov	r8,1024
8000ac36:	f9 b5 01 40 	movne	r5,64
8000ac3a:	f0 05 17 00 	moveq	r5,r8
8000ac3e:	c1 c8       	rjmp	8000ac76 <__smakebuf_r+0x72>
8000ac40:	40 18       	lddsp	r8,sp[0x4]
8000ac42:	e2 18 f0 00 	andl	r8,0xf000,COH
8000ac46:	e0 48 20 00 	cp.w	r8,8192
8000ac4a:	5f 04       	sreq	r4
8000ac4c:	e0 48 80 00 	cp.w	r8,32768
8000ac50:	c0 e1       	brne	8000ac6c <__smakebuf_r+0x68>
8000ac52:	6e b9       	ld.w	r9,r7[0x2c]
8000ac54:	fe c8 f9 1c 	sub	r8,pc,-1764
8000ac58:	10 39       	cp.w	r9,r8
8000ac5a:	c0 91       	brne	8000ac6c <__smakebuf_r+0x68>
8000ac5c:	8e 68       	ld.sh	r8,r7[0xc]
8000ac5e:	e0 65 04 00 	mov	r5,1024
8000ac62:	ab a8       	sbr	r8,0xa
8000ac64:	ef 45 00 50 	st.w	r7[80],r5
8000ac68:	ae 68       	st.h	r7[0xc],r8
8000ac6a:	c0 68       	rjmp	8000ac76 <__smakebuf_r+0x72>
8000ac6c:	8e 68       	ld.sh	r8,r7[0xc]
8000ac6e:	e0 65 04 00 	mov	r5,1024
8000ac72:	ab b8       	sbr	r8,0xb
8000ac74:	ae 68       	st.h	r7[0xc],r8
8000ac76:	0a 9b       	mov	r11,r5
8000ac78:	0c 9c       	mov	r12,r6
8000ac7a:	fe b0 de 51 	rcall	8000691c <_malloc_r>
8000ac7e:	8e 68       	ld.sh	r8,r7[0xc]
8000ac80:	c0 d1       	brne	8000ac9a <__smakebuf_r+0x96>
8000ac82:	ed b8 00 09 	bld	r8,0x9
8000ac86:	c1 b0       	breq	8000acbc <__smakebuf_r+0xb8>
8000ac88:	a1 b8       	sbr	r8,0x1
8000ac8a:	ae 68       	st.h	r7[0xc],r8
8000ac8c:	ee c8 ff b9 	sub	r8,r7,-71
8000ac90:	8f 48       	st.w	r7[0x10],r8
8000ac92:	8f 08       	st.w	r7[0x0],r8
8000ac94:	30 18       	mov	r8,1
8000ac96:	8f 58       	st.w	r7[0x14],r8
8000ac98:	c1 28       	rjmp	8000acbc <__smakebuf_r+0xb8>
8000ac9a:	a7 b8       	sbr	r8,0x7
8000ac9c:	8f 4c       	st.w	r7[0x10],r12
8000ac9e:	ae 68       	st.h	r7[0xc],r8
8000aca0:	8f 55       	st.w	r7[0x14],r5
8000aca2:	fe c8 06 e6 	sub	r8,pc,1766
8000aca6:	8f 0c       	st.w	r7[0x0],r12
8000aca8:	8d a8       	st.w	r6[0x28],r8
8000acaa:	58 04       	cp.w	r4,0
8000acac:	c0 80       	breq	8000acbc <__smakebuf_r+0xb8>
8000acae:	8e 7c       	ld.sh	r12,r7[0xe]
8000acb0:	fe b0 e2 ba 	rcall	80007224 <isatty>
8000acb4:	c0 40       	breq	8000acbc <__smakebuf_r+0xb8>
8000acb6:	8e 68       	ld.sh	r8,r7[0xc]
8000acb8:	a1 a8       	sbr	r8,0x0
8000acba:	ae 68       	st.h	r7[0xc],r8
8000acbc:	2f 1d       	sub	sp,-60
8000acbe:	d8 22       	popm	r4-r7,pc

8000acc0 <memchr>:
8000acc0:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000acc4:	c0 68       	rjmp	8000acd0 <memchr+0x10>
8000acc6:	20 1a       	sub	r10,1
8000acc8:	19 88       	ld.ub	r8,r12[0x0]
8000acca:	16 38       	cp.w	r8,r11
8000accc:	5e 0c       	reteq	r12
8000acce:	2f fc       	sub	r12,-1
8000acd0:	58 0a       	cp.w	r10,0
8000acd2:	cf a1       	brne	8000acc6 <memchr+0x6>
8000acd4:	5e fa       	retal	r10

8000acd6 <memmove>:
8000acd6:	d4 01       	pushm	lr
8000acd8:	18 3b       	cp.w	r11,r12
8000acda:	c1 92       	brcc	8000ad0c <memmove+0x36>
8000acdc:	f6 0a 00 09 	add	r9,r11,r10
8000ace0:	12 3c       	cp.w	r12,r9
8000ace2:	c1 52       	brcc	8000ad0c <memmove+0x36>
8000ace4:	f8 0a 00 0b 	add	r11,r12,r10
8000ace8:	30 08       	mov	r8,0
8000acea:	c0 68       	rjmp	8000acf6 <memmove+0x20>
8000acec:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000acf0:	20 1a       	sub	r10,1
8000acf2:	f6 08 0b 0e 	st.b	r11[r8],lr
8000acf6:	20 18       	sub	r8,1
8000acf8:	58 0a       	cp.w	r10,0
8000acfa:	cf 91       	brne	8000acec <memmove+0x16>
8000acfc:	d8 02       	popm	pc
8000acfe:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000ad02:	20 1a       	sub	r10,1
8000ad04:	f8 08 0b 09 	st.b	r12[r8],r9
8000ad08:	2f f8       	sub	r8,-1
8000ad0a:	c0 28       	rjmp	8000ad0e <memmove+0x38>
8000ad0c:	30 08       	mov	r8,0
8000ad0e:	58 0a       	cp.w	r10,0
8000ad10:	cf 71       	brne	8000acfe <memmove+0x28>
8000ad12:	d8 02       	popm	pc

8000ad14 <__hi0bits>:
8000ad14:	18 98       	mov	r8,r12
8000ad16:	e0 1c 00 00 	andl	r12,0x0
8000ad1a:	f0 09 15 10 	lsl	r9,r8,0x10
8000ad1e:	58 0c       	cp.w	r12,0
8000ad20:	f2 08 17 00 	moveq	r8,r9
8000ad24:	f9 bc 00 10 	moveq	r12,16
8000ad28:	f9 bc 01 00 	movne	r12,0
8000ad2c:	10 9a       	mov	r10,r8
8000ad2e:	f0 09 15 08 	lsl	r9,r8,0x8
8000ad32:	e6 1a ff 00 	andh	r10,0xff00,COH
8000ad36:	f7 bc 00 f8 	subeq	r12,-8
8000ad3a:	f2 08 17 00 	moveq	r8,r9
8000ad3e:	10 9a       	mov	r10,r8
8000ad40:	f0 09 15 04 	lsl	r9,r8,0x4
8000ad44:	e6 1a f0 00 	andh	r10,0xf000,COH
8000ad48:	f7 bc 00 fc 	subeq	r12,-4
8000ad4c:	f2 08 17 00 	moveq	r8,r9
8000ad50:	10 9a       	mov	r10,r8
8000ad52:	f0 09 15 02 	lsl	r9,r8,0x2
8000ad56:	e6 1a c0 00 	andh	r10,0xc000,COH
8000ad5a:	f7 bc 00 fe 	subeq	r12,-2
8000ad5e:	f2 08 17 00 	moveq	r8,r9
8000ad62:	58 08       	cp.w	r8,0
8000ad64:	5e 5c       	retlt	r12
8000ad66:	ed b8 00 1e 	bld	r8,0x1e
8000ad6a:	f9 bc 01 20 	movne	r12,32
8000ad6e:	f7 bc 00 ff 	subeq	r12,-1
8000ad72:	5e fc       	retal	r12

8000ad74 <__lo0bits>:
8000ad74:	18 99       	mov	r9,r12
8000ad76:	78 08       	ld.w	r8,r12[0x0]
8000ad78:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000ad7c:	c1 50       	breq	8000ada6 <__lo0bits+0x32>
8000ad7e:	ed b8 00 00 	bld	r8,0x0
8000ad82:	c0 21       	brne	8000ad86 <__lo0bits+0x12>
8000ad84:	5e fd       	retal	0
8000ad86:	10 9b       	mov	r11,r8
8000ad88:	f0 0a 16 01 	lsr	r10,r8,0x1
8000ad8c:	e2 1b 00 02 	andl	r11,0x2,COH
8000ad90:	a3 88       	lsr	r8,0x2
8000ad92:	58 0b       	cp.w	r11,0
8000ad94:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000ad98:	f9 bc 01 01 	movne	r12,1
8000ad9c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000ada0:	f9 bc 00 02 	moveq	r12,2
8000ada4:	5e fc       	retal	r12
8000ada6:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000adaa:	f0 0b 16 10 	lsr	r11,r8,0x10
8000adae:	58 0a       	cp.w	r10,0
8000adb0:	f6 08 17 00 	moveq	r8,r11
8000adb4:	f9 bc 00 10 	moveq	r12,16
8000adb8:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000adbc:	f0 0a 16 08 	lsr	r10,r8,0x8
8000adc0:	58 0b       	cp.w	r11,0
8000adc2:	f7 bc 00 f8 	subeq	r12,-8
8000adc6:	f4 08 17 00 	moveq	r8,r10
8000adca:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000adce:	f0 0a 16 04 	lsr	r10,r8,0x4
8000add2:	58 0b       	cp.w	r11,0
8000add4:	f7 bc 00 fc 	subeq	r12,-4
8000add8:	f4 08 17 00 	moveq	r8,r10
8000addc:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000ade0:	f0 0a 16 02 	lsr	r10,r8,0x2
8000ade4:	58 0b       	cp.w	r11,0
8000ade6:	f7 bc 00 fe 	subeq	r12,-2
8000adea:	f4 08 17 00 	moveq	r8,r10
8000adee:	ed b8 00 00 	bld	r8,0x0
8000adf2:	c0 60       	breq	8000adfe <__lo0bits+0x8a>
8000adf4:	a1 98       	lsr	r8,0x1
8000adf6:	c0 31       	brne	8000adfc <__lo0bits+0x88>
8000adf8:	32 0c       	mov	r12,32
8000adfa:	5e fc       	retal	r12
8000adfc:	2f fc       	sub	r12,-1
8000adfe:	93 08       	st.w	r9[0x0],r8
8000ae00:	5e fc       	retal	r12

8000ae02 <__mcmp>:
8000ae02:	d4 01       	pushm	lr
8000ae04:	18 98       	mov	r8,r12
8000ae06:	76 49       	ld.w	r9,r11[0x10]
8000ae08:	78 4c       	ld.w	r12,r12[0x10]
8000ae0a:	12 1c       	sub	r12,r9
8000ae0c:	c1 31       	brne	8000ae32 <__mcmp+0x30>
8000ae0e:	2f b9       	sub	r9,-5
8000ae10:	a3 69       	lsl	r9,0x2
8000ae12:	12 0b       	add	r11,r9
8000ae14:	f0 09 00 09 	add	r9,r8,r9
8000ae18:	2e c8       	sub	r8,-20
8000ae1a:	13 4e       	ld.w	lr,--r9
8000ae1c:	17 4a       	ld.w	r10,--r11
8000ae1e:	14 3e       	cp.w	lr,r10
8000ae20:	c0 60       	breq	8000ae2c <__mcmp+0x2a>
8000ae22:	f9 bc 03 ff 	movlo	r12,-1
8000ae26:	f9 bc 02 01 	movhs	r12,1
8000ae2a:	d8 02       	popm	pc
8000ae2c:	10 39       	cp.w	r9,r8
8000ae2e:	fe 9b ff f6 	brhi	8000ae1a <__mcmp+0x18>
8000ae32:	d8 02       	popm	pc

8000ae34 <_Bfree>:
8000ae34:	d4 21       	pushm	r4-r7,lr
8000ae36:	18 97       	mov	r7,r12
8000ae38:	16 95       	mov	r5,r11
8000ae3a:	78 96       	ld.w	r6,r12[0x24]
8000ae3c:	58 06       	cp.w	r6,0
8000ae3e:	c0 91       	brne	8000ae50 <_Bfree+0x1c>
8000ae40:	31 0c       	mov	r12,16
8000ae42:	fe b0 dd 65 	rcall	8000690c <malloc>
8000ae46:	99 36       	st.w	r12[0xc],r6
8000ae48:	8f 9c       	st.w	r7[0x24],r12
8000ae4a:	99 16       	st.w	r12[0x4],r6
8000ae4c:	99 26       	st.w	r12[0x8],r6
8000ae4e:	99 06       	st.w	r12[0x0],r6
8000ae50:	58 05       	cp.w	r5,0
8000ae52:	c0 90       	breq	8000ae64 <_Bfree+0x30>
8000ae54:	6a 19       	ld.w	r9,r5[0x4]
8000ae56:	6e 98       	ld.w	r8,r7[0x24]
8000ae58:	70 38       	ld.w	r8,r8[0xc]
8000ae5a:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000ae5e:	8b 0a       	st.w	r5[0x0],r10
8000ae60:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000ae64:	d8 22       	popm	r4-r7,pc
8000ae66:	d7 03       	nop

8000ae68 <_Balloc>:
8000ae68:	d4 21       	pushm	r4-r7,lr
8000ae6a:	18 97       	mov	r7,r12
8000ae6c:	16 96       	mov	r6,r11
8000ae6e:	78 95       	ld.w	r5,r12[0x24]
8000ae70:	58 05       	cp.w	r5,0
8000ae72:	c0 91       	brne	8000ae84 <_Balloc+0x1c>
8000ae74:	31 0c       	mov	r12,16
8000ae76:	fe b0 dd 4b 	rcall	8000690c <malloc>
8000ae7a:	99 35       	st.w	r12[0xc],r5
8000ae7c:	8f 9c       	st.w	r7[0x24],r12
8000ae7e:	99 15       	st.w	r12[0x4],r5
8000ae80:	99 25       	st.w	r12[0x8],r5
8000ae82:	99 05       	st.w	r12[0x0],r5
8000ae84:	6e 95       	ld.w	r5,r7[0x24]
8000ae86:	6a 38       	ld.w	r8,r5[0xc]
8000ae88:	58 08       	cp.w	r8,0
8000ae8a:	c0 b1       	brne	8000aea0 <_Balloc+0x38>
8000ae8c:	31 0a       	mov	r10,16
8000ae8e:	30 4b       	mov	r11,4
8000ae90:	0e 9c       	mov	r12,r7
8000ae92:	e0 a0 02 a7 	rcall	8000b3e0 <_calloc_r>
8000ae96:	8b 3c       	st.w	r5[0xc],r12
8000ae98:	6e 98       	ld.w	r8,r7[0x24]
8000ae9a:	70 3c       	ld.w	r12,r8[0xc]
8000ae9c:	58 0c       	cp.w	r12,0
8000ae9e:	c1 b0       	breq	8000aed4 <_Balloc+0x6c>
8000aea0:	6e 98       	ld.w	r8,r7[0x24]
8000aea2:	70 38       	ld.w	r8,r8[0xc]
8000aea4:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000aea8:	70 0c       	ld.w	r12,r8[0x0]
8000aeaa:	58 0c       	cp.w	r12,0
8000aeac:	c0 40       	breq	8000aeb4 <_Balloc+0x4c>
8000aeae:	78 09       	ld.w	r9,r12[0x0]
8000aeb0:	91 09       	st.w	r8[0x0],r9
8000aeb2:	c0 e8       	rjmp	8000aece <_Balloc+0x66>
8000aeb4:	0e 9c       	mov	r12,r7
8000aeb6:	30 17       	mov	r7,1
8000aeb8:	0e 9b       	mov	r11,r7
8000aeba:	ee 06 09 47 	lsl	r7,r7,r6
8000aebe:	ee ca ff fb 	sub	r10,r7,-5
8000aec2:	a3 6a       	lsl	r10,0x2
8000aec4:	e0 a0 02 8e 	rcall	8000b3e0 <_calloc_r>
8000aec8:	c0 60       	breq	8000aed4 <_Balloc+0x6c>
8000aeca:	99 16       	st.w	r12[0x4],r6
8000aecc:	99 27       	st.w	r12[0x8],r7
8000aece:	30 08       	mov	r8,0
8000aed0:	99 38       	st.w	r12[0xc],r8
8000aed2:	99 48       	st.w	r12[0x10],r8
8000aed4:	d8 22       	popm	r4-r7,pc
8000aed6:	d7 03       	nop

8000aed8 <__d2b>:
8000aed8:	d4 31       	pushm	r0-r7,lr
8000aeda:	20 2d       	sub	sp,8
8000aedc:	16 93       	mov	r3,r11
8000aede:	12 96       	mov	r6,r9
8000aee0:	10 95       	mov	r5,r8
8000aee2:	14 92       	mov	r2,r10
8000aee4:	30 1b       	mov	r11,1
8000aee6:	cc 1f       	rcall	8000ae68 <_Balloc>
8000aee8:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000aeec:	50 09       	stdsp	sp[0x0],r9
8000aeee:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000aef2:	b5 a9       	sbr	r9,0x14
8000aef4:	f0 01 16 14 	lsr	r1,r8,0x14
8000aef8:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000aefc:	18 94       	mov	r4,r12
8000aefe:	58 02       	cp.w	r2,0
8000af00:	c1 d0       	breq	8000af3a <__d2b+0x62>
8000af02:	fa cc ff f8 	sub	r12,sp,-8
8000af06:	18 d2       	st.w	--r12,r2
8000af08:	c3 6f       	rcall	8000ad74 <__lo0bits>
8000af0a:	40 18       	lddsp	r8,sp[0x4]
8000af0c:	c0 d0       	breq	8000af26 <__d2b+0x4e>
8000af0e:	40 09       	lddsp	r9,sp[0x0]
8000af10:	f8 0a 11 20 	rsub	r10,r12,32
8000af14:	f2 0a 09 4a 	lsl	r10,r9,r10
8000af18:	f5 e8 10 08 	or	r8,r10,r8
8000af1c:	89 58       	st.w	r4[0x14],r8
8000af1e:	f2 0c 0a 49 	lsr	r9,r9,r12
8000af22:	50 09       	stdsp	sp[0x0],r9
8000af24:	c0 28       	rjmp	8000af28 <__d2b+0x50>
8000af26:	89 58       	st.w	r4[0x14],r8
8000af28:	40 08       	lddsp	r8,sp[0x0]
8000af2a:	58 08       	cp.w	r8,0
8000af2c:	f9 b3 01 02 	movne	r3,2
8000af30:	f9 b3 00 01 	moveq	r3,1
8000af34:	89 68       	st.w	r4[0x18],r8
8000af36:	89 43       	st.w	r4[0x10],r3
8000af38:	c0 88       	rjmp	8000af48 <__d2b+0x70>
8000af3a:	1a 9c       	mov	r12,sp
8000af3c:	c1 cf       	rcall	8000ad74 <__lo0bits>
8000af3e:	30 13       	mov	r3,1
8000af40:	40 08       	lddsp	r8,sp[0x0]
8000af42:	2e 0c       	sub	r12,-32
8000af44:	89 43       	st.w	r4[0x10],r3
8000af46:	89 58       	st.w	r4[0x14],r8
8000af48:	58 01       	cp.w	r1,0
8000af4a:	c0 90       	breq	8000af5c <__d2b+0x84>
8000af4c:	e2 c1 04 33 	sub	r1,r1,1075
8000af50:	18 01       	add	r1,r12
8000af52:	8d 01       	st.w	r6[0x0],r1
8000af54:	f8 0c 11 35 	rsub	r12,r12,53
8000af58:	8b 0c       	st.w	r5[0x0],r12
8000af5a:	c0 c8       	rjmp	8000af72 <__d2b+0x9a>
8000af5c:	e6 c8 ff fc 	sub	r8,r3,-4
8000af60:	f8 cc 04 32 	sub	r12,r12,1074
8000af64:	a5 73       	lsl	r3,0x5
8000af66:	8d 0c       	st.w	r6[0x0],r12
8000af68:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000af6c:	cd 4e       	rcall	8000ad14 <__hi0bits>
8000af6e:	18 13       	sub	r3,r12
8000af70:	8b 03       	st.w	r5[0x0],r3
8000af72:	08 9c       	mov	r12,r4
8000af74:	2f ed       	sub	sp,-8
8000af76:	d8 32       	popm	r0-r7,pc

8000af78 <__mdiff>:
8000af78:	d4 31       	pushm	r0-r7,lr
8000af7a:	74 48       	ld.w	r8,r10[0x10]
8000af7c:	76 45       	ld.w	r5,r11[0x10]
8000af7e:	16 97       	mov	r7,r11
8000af80:	14 96       	mov	r6,r10
8000af82:	10 15       	sub	r5,r8
8000af84:	c1 31       	brne	8000afaa <__mdiff+0x32>
8000af86:	2f b8       	sub	r8,-5
8000af88:	ee ce ff ec 	sub	lr,r7,-20
8000af8c:	a3 68       	lsl	r8,0x2
8000af8e:	f4 08 00 0b 	add	r11,r10,r8
8000af92:	ee 08 00 08 	add	r8,r7,r8
8000af96:	11 4a       	ld.w	r10,--r8
8000af98:	17 49       	ld.w	r9,--r11
8000af9a:	12 3a       	cp.w	r10,r9
8000af9c:	c0 30       	breq	8000afa2 <__mdiff+0x2a>
8000af9e:	c0 e2       	brcc	8000afba <__mdiff+0x42>
8000afa0:	c0 78       	rjmp	8000afae <__mdiff+0x36>
8000afa2:	1c 38       	cp.w	r8,lr
8000afa4:	fe 9b ff f9 	brhi	8000af96 <__mdiff+0x1e>
8000afa8:	c4 98       	rjmp	8000b03a <__mdiff+0xc2>
8000afaa:	58 05       	cp.w	r5,0
8000afac:	c0 64       	brge	8000afb8 <__mdiff+0x40>
8000afae:	0e 98       	mov	r8,r7
8000afb0:	30 15       	mov	r5,1
8000afb2:	0c 97       	mov	r7,r6
8000afb4:	10 96       	mov	r6,r8
8000afb6:	c0 28       	rjmp	8000afba <__mdiff+0x42>
8000afb8:	30 05       	mov	r5,0
8000afba:	6e 1b       	ld.w	r11,r7[0x4]
8000afbc:	c5 6f       	rcall	8000ae68 <_Balloc>
8000afbe:	6e 49       	ld.w	r9,r7[0x10]
8000afc0:	6c 44       	ld.w	r4,r6[0x10]
8000afc2:	99 35       	st.w	r12[0xc],r5
8000afc4:	2f b4       	sub	r4,-5
8000afc6:	f2 c5 ff fb 	sub	r5,r9,-5
8000afca:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000afce:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000afd2:	2e c6       	sub	r6,-20
8000afd4:	2e c7       	sub	r7,-20
8000afd6:	f8 c8 ff ec 	sub	r8,r12,-20
8000afda:	30 0a       	mov	r10,0
8000afdc:	0f 0e       	ld.w	lr,r7++
8000afde:	0d 0b       	ld.w	r11,r6++
8000afe0:	fc 02 16 10 	lsr	r2,lr,0x10
8000afe4:	f6 03 16 10 	lsr	r3,r11,0x10
8000afe8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000afec:	e4 03 01 03 	sub	r3,r2,r3
8000aff0:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aff4:	fc 0b 01 0b 	sub	r11,lr,r11
8000aff8:	f6 0a 00 0a 	add	r10,r11,r10
8000affc:	b0 1a       	st.h	r8[0x2],r10
8000affe:	b1 4a       	asr	r10,0x10
8000b000:	e6 0a 00 0a 	add	r10,r3,r10
8000b004:	b0 0a       	st.h	r8[0x0],r10
8000b006:	2f c8       	sub	r8,-4
8000b008:	b1 4a       	asr	r10,0x10
8000b00a:	08 36       	cp.w	r6,r4
8000b00c:	ce 83       	brcs	8000afdc <__mdiff+0x64>
8000b00e:	c0 d8       	rjmp	8000b028 <__mdiff+0xb0>
8000b010:	0f 0b       	ld.w	r11,r7++
8000b012:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b016:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b01a:	16 0a       	add	r10,r11
8000b01c:	b0 1a       	st.h	r8[0x2],r10
8000b01e:	b1 4a       	asr	r10,0x10
8000b020:	1c 0a       	add	r10,lr
8000b022:	b0 0a       	st.h	r8[0x0],r10
8000b024:	2f c8       	sub	r8,-4
8000b026:	b1 4a       	asr	r10,0x10
8000b028:	0a 37       	cp.w	r7,r5
8000b02a:	cf 33       	brcs	8000b010 <__mdiff+0x98>
8000b02c:	c0 28       	rjmp	8000b030 <__mdiff+0xb8>
8000b02e:	20 19       	sub	r9,1
8000b030:	11 4a       	ld.w	r10,--r8
8000b032:	58 0a       	cp.w	r10,0
8000b034:	cf d0       	breq	8000b02e <__mdiff+0xb6>
8000b036:	99 49       	st.w	r12[0x10],r9
8000b038:	d8 32       	popm	r0-r7,pc
8000b03a:	30 0b       	mov	r11,0
8000b03c:	c1 6f       	rcall	8000ae68 <_Balloc>
8000b03e:	30 18       	mov	r8,1
8000b040:	99 48       	st.w	r12[0x10],r8
8000b042:	30 08       	mov	r8,0
8000b044:	99 58       	st.w	r12[0x14],r8
8000b046:	d8 32       	popm	r0-r7,pc

8000b048 <__lshift>:
8000b048:	d4 31       	pushm	r0-r7,lr
8000b04a:	16 97       	mov	r7,r11
8000b04c:	76 46       	ld.w	r6,r11[0x10]
8000b04e:	f4 02 14 05 	asr	r2,r10,0x5
8000b052:	2f f6       	sub	r6,-1
8000b054:	14 93       	mov	r3,r10
8000b056:	18 94       	mov	r4,r12
8000b058:	04 06       	add	r6,r2
8000b05a:	76 1b       	ld.w	r11,r11[0x4]
8000b05c:	6e 28       	ld.w	r8,r7[0x8]
8000b05e:	c0 38       	rjmp	8000b064 <__lshift+0x1c>
8000b060:	2f fb       	sub	r11,-1
8000b062:	a1 78       	lsl	r8,0x1
8000b064:	10 36       	cp.w	r6,r8
8000b066:	fe 99 ff fd 	brgt	8000b060 <__lshift+0x18>
8000b06a:	08 9c       	mov	r12,r4
8000b06c:	cf ee       	rcall	8000ae68 <_Balloc>
8000b06e:	30 09       	mov	r9,0
8000b070:	18 95       	mov	r5,r12
8000b072:	f8 c8 ff ec 	sub	r8,r12,-20
8000b076:	12 9a       	mov	r10,r9
8000b078:	c0 38       	rjmp	8000b07e <__lshift+0x36>
8000b07a:	10 aa       	st.w	r8++,r10
8000b07c:	2f f9       	sub	r9,-1
8000b07e:	04 39       	cp.w	r9,r2
8000b080:	cf d5       	brlt	8000b07a <__lshift+0x32>
8000b082:	6e 4b       	ld.w	r11,r7[0x10]
8000b084:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b088:	2f bb       	sub	r11,-5
8000b08a:	ee c9 ff ec 	sub	r9,r7,-20
8000b08e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b092:	58 03       	cp.w	r3,0
8000b094:	c1 30       	breq	8000b0ba <__lshift+0x72>
8000b096:	e6 0c 11 20 	rsub	r12,r3,32
8000b09a:	30 0a       	mov	r10,0
8000b09c:	72 02       	ld.w	r2,r9[0x0]
8000b09e:	e4 03 09 42 	lsl	r2,r2,r3
8000b0a2:	04 4a       	or	r10,r2
8000b0a4:	10 aa       	st.w	r8++,r10
8000b0a6:	13 0a       	ld.w	r10,r9++
8000b0a8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b0ac:	16 39       	cp.w	r9,r11
8000b0ae:	cf 73       	brcs	8000b09c <__lshift+0x54>
8000b0b0:	91 0a       	st.w	r8[0x0],r10
8000b0b2:	58 0a       	cp.w	r10,0
8000b0b4:	c0 70       	breq	8000b0c2 <__lshift+0x7a>
8000b0b6:	2f f6       	sub	r6,-1
8000b0b8:	c0 58       	rjmp	8000b0c2 <__lshift+0x7a>
8000b0ba:	13 0a       	ld.w	r10,r9++
8000b0bc:	10 aa       	st.w	r8++,r10
8000b0be:	16 39       	cp.w	r9,r11
8000b0c0:	cf d3       	brcs	8000b0ba <__lshift+0x72>
8000b0c2:	08 9c       	mov	r12,r4
8000b0c4:	20 16       	sub	r6,1
8000b0c6:	0e 9b       	mov	r11,r7
8000b0c8:	8b 46       	st.w	r5[0x10],r6
8000b0ca:	cb 5e       	rcall	8000ae34 <_Bfree>
8000b0cc:	0a 9c       	mov	r12,r5
8000b0ce:	d8 32       	popm	r0-r7,pc

8000b0d0 <__multiply>:
8000b0d0:	d4 31       	pushm	r0-r7,lr
8000b0d2:	20 2d       	sub	sp,8
8000b0d4:	76 49       	ld.w	r9,r11[0x10]
8000b0d6:	74 48       	ld.w	r8,r10[0x10]
8000b0d8:	16 96       	mov	r6,r11
8000b0da:	14 95       	mov	r5,r10
8000b0dc:	10 39       	cp.w	r9,r8
8000b0de:	ec 08 17 50 	movlt	r8,r6
8000b0e2:	ea 06 17 50 	movlt	r6,r5
8000b0e6:	f0 05 17 50 	movlt	r5,r8
8000b0ea:	6c 28       	ld.w	r8,r6[0x8]
8000b0ec:	76 43       	ld.w	r3,r11[0x10]
8000b0ee:	74 42       	ld.w	r2,r10[0x10]
8000b0f0:	76 1b       	ld.w	r11,r11[0x4]
8000b0f2:	e4 03 00 07 	add	r7,r2,r3
8000b0f6:	10 37       	cp.w	r7,r8
8000b0f8:	f7 bb 09 ff 	subgt	r11,-1
8000b0fc:	cb 6e       	rcall	8000ae68 <_Balloc>
8000b0fe:	ee c4 ff fb 	sub	r4,r7,-5
8000b102:	f8 c9 ff ec 	sub	r9,r12,-20
8000b106:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b10a:	30 0a       	mov	r10,0
8000b10c:	12 98       	mov	r8,r9
8000b10e:	c0 28       	rjmp	8000b112 <__multiply+0x42>
8000b110:	10 aa       	st.w	r8++,r10
8000b112:	08 38       	cp.w	r8,r4
8000b114:	cf e3       	brcs	8000b110 <__multiply+0x40>
8000b116:	2f b3       	sub	r3,-5
8000b118:	2f b2       	sub	r2,-5
8000b11a:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b11e:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b122:	ec cb ff ec 	sub	r11,r6,-20
8000b126:	50 12       	stdsp	sp[0x4],r2
8000b128:	ea ca ff ec 	sub	r10,r5,-20
8000b12c:	c4 48       	rjmp	8000b1b4 <__multiply+0xe4>
8000b12e:	94 95       	ld.uh	r5,r10[0x2]
8000b130:	58 05       	cp.w	r5,0
8000b132:	c2 00       	breq	8000b172 <__multiply+0xa2>
8000b134:	12 98       	mov	r8,r9
8000b136:	16 96       	mov	r6,r11
8000b138:	30 0e       	mov	lr,0
8000b13a:	50 09       	stdsp	sp[0x0],r9
8000b13c:	0d 02       	ld.w	r2,r6++
8000b13e:	e4 00 16 10 	lsr	r0,r2,0x10
8000b142:	70 01       	ld.w	r1,r8[0x0]
8000b144:	70 09       	ld.w	r9,r8[0x0]
8000b146:	b1 81       	lsr	r1,0x10
8000b148:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b14c:	e0 05 03 41 	mac	r1,r0,r5
8000b150:	ab 32       	mul	r2,r5
8000b152:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b156:	00 02       	add	r2,r0
8000b158:	e4 0e 00 0e 	add	lr,r2,lr
8000b15c:	b0 1e       	st.h	r8[0x2],lr
8000b15e:	b1 8e       	lsr	lr,0x10
8000b160:	1c 01       	add	r1,lr
8000b162:	b0 01       	st.h	r8[0x0],r1
8000b164:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b168:	2f c8       	sub	r8,-4
8000b16a:	06 36       	cp.w	r6,r3
8000b16c:	ce 83       	brcs	8000b13c <__multiply+0x6c>
8000b16e:	40 09       	lddsp	r9,sp[0x0]
8000b170:	91 0e       	st.w	r8[0x0],lr
8000b172:	94 86       	ld.uh	r6,r10[0x0]
8000b174:	58 06       	cp.w	r6,0
8000b176:	c1 d0       	breq	8000b1b0 <__multiply+0xe0>
8000b178:	72 02       	ld.w	r2,r9[0x0]
8000b17a:	12 98       	mov	r8,r9
8000b17c:	16 9e       	mov	lr,r11
8000b17e:	30 05       	mov	r5,0
8000b180:	b0 12       	st.h	r8[0x2],r2
8000b182:	1d 01       	ld.w	r1,lr++
8000b184:	90 82       	ld.uh	r2,r8[0x0]
8000b186:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b18a:	ad 30       	mul	r0,r6
8000b18c:	e0 02 00 02 	add	r2,r0,r2
8000b190:	e4 05 00 05 	add	r5,r2,r5
8000b194:	b0 05       	st.h	r8[0x0],r5
8000b196:	b1 85       	lsr	r5,0x10
8000b198:	b1 81       	lsr	r1,0x10
8000b19a:	2f c8       	sub	r8,-4
8000b19c:	ad 31       	mul	r1,r6
8000b19e:	90 92       	ld.uh	r2,r8[0x2]
8000b1a0:	e2 02 00 02 	add	r2,r1,r2
8000b1a4:	0a 02       	add	r2,r5
8000b1a6:	e4 05 16 10 	lsr	r5,r2,0x10
8000b1aa:	06 3e       	cp.w	lr,r3
8000b1ac:	ce a3       	brcs	8000b180 <__multiply+0xb0>
8000b1ae:	91 02       	st.w	r8[0x0],r2
8000b1b0:	2f ca       	sub	r10,-4
8000b1b2:	2f c9       	sub	r9,-4
8000b1b4:	40 18       	lddsp	r8,sp[0x4]
8000b1b6:	10 3a       	cp.w	r10,r8
8000b1b8:	cb b3       	brcs	8000b12e <__multiply+0x5e>
8000b1ba:	c0 28       	rjmp	8000b1be <__multiply+0xee>
8000b1bc:	20 17       	sub	r7,1
8000b1be:	58 07       	cp.w	r7,0
8000b1c0:	e0 8a 00 05 	brle	8000b1ca <__multiply+0xfa>
8000b1c4:	09 48       	ld.w	r8,--r4
8000b1c6:	58 08       	cp.w	r8,0
8000b1c8:	cf a0       	breq	8000b1bc <__multiply+0xec>
8000b1ca:	99 47       	st.w	r12[0x10],r7
8000b1cc:	2f ed       	sub	sp,-8
8000b1ce:	d8 32       	popm	r0-r7,pc

8000b1d0 <__i2b>:
8000b1d0:	d4 21       	pushm	r4-r7,lr
8000b1d2:	16 97       	mov	r7,r11
8000b1d4:	30 1b       	mov	r11,1
8000b1d6:	c4 9e       	rcall	8000ae68 <_Balloc>
8000b1d8:	30 19       	mov	r9,1
8000b1da:	99 57       	st.w	r12[0x14],r7
8000b1dc:	99 49       	st.w	r12[0x10],r9
8000b1de:	d8 22       	popm	r4-r7,pc

8000b1e0 <__multadd>:
8000b1e0:	d4 31       	pushm	r0-r7,lr
8000b1e2:	30 08       	mov	r8,0
8000b1e4:	12 95       	mov	r5,r9
8000b1e6:	16 97       	mov	r7,r11
8000b1e8:	18 96       	mov	r6,r12
8000b1ea:	76 44       	ld.w	r4,r11[0x10]
8000b1ec:	f6 c9 ff ec 	sub	r9,r11,-20
8000b1f0:	72 0b       	ld.w	r11,r9[0x0]
8000b1f2:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b1f6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b1fa:	f4 0c 02 4c 	mul	r12,r10,r12
8000b1fe:	f4 0b 03 45 	mac	r5,r10,r11
8000b202:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b206:	b1 85       	lsr	r5,0x10
8000b208:	18 05       	add	r5,r12
8000b20a:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b20e:	f8 0b 00 0b 	add	r11,r12,r11
8000b212:	12 ab       	st.w	r9++,r11
8000b214:	2f f8       	sub	r8,-1
8000b216:	b1 85       	lsr	r5,0x10
8000b218:	08 38       	cp.w	r8,r4
8000b21a:	ce b5       	brlt	8000b1f0 <__multadd+0x10>
8000b21c:	58 05       	cp.w	r5,0
8000b21e:	c1 c0       	breq	8000b256 <__multadd+0x76>
8000b220:	6e 28       	ld.w	r8,r7[0x8]
8000b222:	10 34       	cp.w	r4,r8
8000b224:	c1 35       	brlt	8000b24a <__multadd+0x6a>
8000b226:	6e 1b       	ld.w	r11,r7[0x4]
8000b228:	0c 9c       	mov	r12,r6
8000b22a:	2f fb       	sub	r11,-1
8000b22c:	c1 ee       	rcall	8000ae68 <_Balloc>
8000b22e:	6e 4a       	ld.w	r10,r7[0x10]
8000b230:	ee cb ff f4 	sub	r11,r7,-12
8000b234:	18 93       	mov	r3,r12
8000b236:	2f ea       	sub	r10,-2
8000b238:	2f 4c       	sub	r12,-12
8000b23a:	a3 6a       	lsl	r10,0x2
8000b23c:	fe b0 dd 8c 	rcall	80006d54 <memcpy>
8000b240:	0e 9b       	mov	r11,r7
8000b242:	0c 9c       	mov	r12,r6
8000b244:	fe b0 fd f8 	rcall	8000ae34 <_Bfree>
8000b248:	06 97       	mov	r7,r3
8000b24a:	e8 c8 ff ff 	sub	r8,r4,-1
8000b24e:	2f b4       	sub	r4,-5
8000b250:	8f 48       	st.w	r7[0x10],r8
8000b252:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b256:	0e 9c       	mov	r12,r7
8000b258:	d8 32       	popm	r0-r7,pc
8000b25a:	d7 03       	nop

8000b25c <__pow5mult>:
8000b25c:	d4 31       	pushm	r0-r7,lr
8000b25e:	14 96       	mov	r6,r10
8000b260:	18 97       	mov	r7,r12
8000b262:	16 94       	mov	r4,r11
8000b264:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b268:	c0 90       	breq	8000b27a <__pow5mult+0x1e>
8000b26a:	20 18       	sub	r8,1
8000b26c:	fe c9 e8 b0 	sub	r9,pc,-5968
8000b270:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b274:	30 09       	mov	r9,0
8000b276:	cb 5f       	rcall	8000b1e0 <__multadd>
8000b278:	18 94       	mov	r4,r12
8000b27a:	a3 46       	asr	r6,0x2
8000b27c:	c3 40       	breq	8000b2e4 <__pow5mult+0x88>
8000b27e:	6e 95       	ld.w	r5,r7[0x24]
8000b280:	58 05       	cp.w	r5,0
8000b282:	c0 91       	brne	8000b294 <__pow5mult+0x38>
8000b284:	31 0c       	mov	r12,16
8000b286:	fe b0 db 43 	rcall	8000690c <malloc>
8000b28a:	99 35       	st.w	r12[0xc],r5
8000b28c:	8f 9c       	st.w	r7[0x24],r12
8000b28e:	99 15       	st.w	r12[0x4],r5
8000b290:	99 25       	st.w	r12[0x8],r5
8000b292:	99 05       	st.w	r12[0x0],r5
8000b294:	6e 93       	ld.w	r3,r7[0x24]
8000b296:	66 25       	ld.w	r5,r3[0x8]
8000b298:	58 05       	cp.w	r5,0
8000b29a:	c0 c1       	brne	8000b2b2 <__pow5mult+0x56>
8000b29c:	e0 6b 02 71 	mov	r11,625
8000b2a0:	0e 9c       	mov	r12,r7
8000b2a2:	c9 7f       	rcall	8000b1d0 <__i2b>
8000b2a4:	87 2c       	st.w	r3[0x8],r12
8000b2a6:	30 08       	mov	r8,0
8000b2a8:	18 95       	mov	r5,r12
8000b2aa:	99 08       	st.w	r12[0x0],r8
8000b2ac:	c0 38       	rjmp	8000b2b2 <__pow5mult+0x56>
8000b2ae:	06 9c       	mov	r12,r3
8000b2b0:	18 95       	mov	r5,r12
8000b2b2:	ed b6 00 00 	bld	r6,0x0
8000b2b6:	c0 b1       	brne	8000b2cc <__pow5mult+0x70>
8000b2b8:	08 9b       	mov	r11,r4
8000b2ba:	0a 9a       	mov	r10,r5
8000b2bc:	0e 9c       	mov	r12,r7
8000b2be:	c0 9f       	rcall	8000b0d0 <__multiply>
8000b2c0:	08 9b       	mov	r11,r4
8000b2c2:	18 93       	mov	r3,r12
8000b2c4:	0e 9c       	mov	r12,r7
8000b2c6:	06 94       	mov	r4,r3
8000b2c8:	fe b0 fd b6 	rcall	8000ae34 <_Bfree>
8000b2cc:	a1 56       	asr	r6,0x1
8000b2ce:	c0 b0       	breq	8000b2e4 <__pow5mult+0x88>
8000b2d0:	6a 03       	ld.w	r3,r5[0x0]
8000b2d2:	58 03       	cp.w	r3,0
8000b2d4:	ce d1       	brne	8000b2ae <__pow5mult+0x52>
8000b2d6:	0a 9a       	mov	r10,r5
8000b2d8:	0a 9b       	mov	r11,r5
8000b2da:	0e 9c       	mov	r12,r7
8000b2dc:	cf ae       	rcall	8000b0d0 <__multiply>
8000b2de:	8b 0c       	st.w	r5[0x0],r12
8000b2e0:	99 03       	st.w	r12[0x0],r3
8000b2e2:	ce 7b       	rjmp	8000b2b0 <__pow5mult+0x54>
8000b2e4:	08 9c       	mov	r12,r4
8000b2e6:	d8 32       	popm	r0-r7,pc

8000b2e8 <__isinfd>:
8000b2e8:	14 98       	mov	r8,r10
8000b2ea:	fc 19 7f f0 	movh	r9,0x7ff0
8000b2ee:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b2f2:	f0 0b 11 00 	rsub	r11,r8,0
8000b2f6:	f7 e8 10 08 	or	r8,r11,r8
8000b2fa:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b2fe:	f2 08 01 08 	sub	r8,r9,r8
8000b302:	f0 0c 11 00 	rsub	r12,r8,0
8000b306:	f9 e8 10 08 	or	r8,r12,r8
8000b30a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b30e:	2f fc       	sub	r12,-1
8000b310:	5e fc       	retal	r12

8000b312 <__isnand>:
8000b312:	14 98       	mov	r8,r10
8000b314:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b318:	f0 0c 11 00 	rsub	r12,r8,0
8000b31c:	10 4c       	or	r12,r8
8000b31e:	fc 18 7f f0 	movh	r8,0x7ff0
8000b322:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b326:	f0 0c 01 0c 	sub	r12,r8,r12
8000b32a:	bf 9c       	lsr	r12,0x1f
8000b32c:	5e fc       	retal	r12
8000b32e:	d7 03       	nop

8000b330 <__sclose>:
8000b330:	d4 01       	pushm	lr
8000b332:	96 7b       	ld.sh	r11,r11[0xe]
8000b334:	c8 2c       	rcall	8000b438 <_close_r>
8000b336:	d8 02       	popm	pc

8000b338 <__sseek>:
8000b338:	d4 21       	pushm	r4-r7,lr
8000b33a:	16 97       	mov	r7,r11
8000b33c:	96 7b       	ld.sh	r11,r11[0xe]
8000b33e:	c0 3d       	rcall	8000b544 <_lseek_r>
8000b340:	8e 68       	ld.sh	r8,r7[0xc]
8000b342:	10 99       	mov	r9,r8
8000b344:	ad c8       	cbr	r8,0xc
8000b346:	ad a9       	sbr	r9,0xc
8000b348:	5b fc       	cp.w	r12,-1
8000b34a:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b34e:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b352:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b356:	d8 22       	popm	r4-r7,pc

8000b358 <__swrite>:
8000b358:	d4 21       	pushm	r4-r7,lr
8000b35a:	96 68       	ld.sh	r8,r11[0xc]
8000b35c:	16 97       	mov	r7,r11
8000b35e:	14 95       	mov	r5,r10
8000b360:	12 94       	mov	r4,r9
8000b362:	e2 18 01 00 	andl	r8,0x100,COH
8000b366:	18 96       	mov	r6,r12
8000b368:	c0 50       	breq	8000b372 <__swrite+0x1a>
8000b36a:	30 29       	mov	r9,2
8000b36c:	30 0a       	mov	r10,0
8000b36e:	96 7b       	ld.sh	r11,r11[0xe]
8000b370:	ce ac       	rcall	8000b544 <_lseek_r>
8000b372:	8e 68       	ld.sh	r8,r7[0xc]
8000b374:	ad c8       	cbr	r8,0xc
8000b376:	08 99       	mov	r9,r4
8000b378:	0a 9a       	mov	r10,r5
8000b37a:	8e 7b       	ld.sh	r11,r7[0xe]
8000b37c:	0c 9c       	mov	r12,r6
8000b37e:	ae 68       	st.h	r7[0xc],r8
8000b380:	c1 cc       	rcall	8000b3b8 <_write_r>
8000b382:	d8 22       	popm	r4-r7,pc

8000b384 <__sread>:
8000b384:	d4 21       	pushm	r4-r7,lr
8000b386:	16 97       	mov	r7,r11
8000b388:	96 7b       	ld.sh	r11,r11[0xe]
8000b38a:	cf 1c       	rcall	8000b56c <_read_r>
8000b38c:	c0 65       	brlt	8000b398 <__sread+0x14>
8000b38e:	6f 58       	ld.w	r8,r7[0x54]
8000b390:	18 08       	add	r8,r12
8000b392:	ef 48 00 54 	st.w	r7[84],r8
8000b396:	d8 22       	popm	r4-r7,pc
8000b398:	8e 68       	ld.sh	r8,r7[0xc]
8000b39a:	ad c8       	cbr	r8,0xc
8000b39c:	ae 68       	st.h	r7[0xc],r8
8000b39e:	d8 22       	popm	r4-r7,pc

8000b3a0 <strlen>:
8000b3a0:	30 09       	mov	r9,0
8000b3a2:	18 98       	mov	r8,r12
8000b3a4:	c0 28       	rjmp	8000b3a8 <strlen+0x8>
8000b3a6:	2f f8       	sub	r8,-1
8000b3a8:	11 8a       	ld.ub	r10,r8[0x0]
8000b3aa:	f2 0a 18 00 	cp.b	r10,r9
8000b3ae:	cf c1       	brne	8000b3a6 <strlen+0x6>
8000b3b0:	f0 0c 01 0c 	sub	r12,r8,r12
8000b3b4:	5e fc       	retal	r12
8000b3b6:	d7 03       	nop

8000b3b8 <_write_r>:
8000b3b8:	d4 21       	pushm	r4-r7,lr
8000b3ba:	16 98       	mov	r8,r11
8000b3bc:	18 97       	mov	r7,r12
8000b3be:	10 9c       	mov	r12,r8
8000b3c0:	30 08       	mov	r8,0
8000b3c2:	14 9b       	mov	r11,r10
8000b3c4:	e0 66 08 10 	mov	r6,2064
8000b3c8:	12 9a       	mov	r10,r9
8000b3ca:	8d 08       	st.w	r6[0x0],r8
8000b3cc:	fe b0 cf 76 	rcall	800052b8 <_write>
8000b3d0:	5b fc       	cp.w	r12,-1
8000b3d2:	c0 51       	brne	8000b3dc <_write_r+0x24>
8000b3d4:	6c 08       	ld.w	r8,r6[0x0]
8000b3d6:	58 08       	cp.w	r8,0
8000b3d8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b3dc:	d8 22       	popm	r4-r7,pc
8000b3de:	d7 03       	nop

8000b3e0 <_calloc_r>:
8000b3e0:	d4 21       	pushm	r4-r7,lr
8000b3e2:	f4 0b 02 4b 	mul	r11,r10,r11
8000b3e6:	fe b0 da 9b 	rcall	8000691c <_malloc_r>
8000b3ea:	18 97       	mov	r7,r12
8000b3ec:	c2 30       	breq	8000b432 <_calloc_r+0x52>
8000b3ee:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b3f2:	e0 1a ff fc 	andl	r10,0xfffc
8000b3f6:	20 4a       	sub	r10,4
8000b3f8:	e0 4a 00 24 	cp.w	r10,36
8000b3fc:	e0 8b 00 18 	brhi	8000b42c <_calloc_r+0x4c>
8000b400:	18 98       	mov	r8,r12
8000b402:	59 3a       	cp.w	r10,19
8000b404:	e0 88 00 0f 	brls	8000b422 <_calloc_r+0x42>
8000b408:	30 09       	mov	r9,0
8000b40a:	10 a9       	st.w	r8++,r9
8000b40c:	10 a9       	st.w	r8++,r9
8000b40e:	59 ba       	cp.w	r10,27
8000b410:	e0 88 00 09 	brls	8000b422 <_calloc_r+0x42>
8000b414:	10 a9       	st.w	r8++,r9
8000b416:	10 a9       	st.w	r8++,r9
8000b418:	e0 4a 00 24 	cp.w	r10,36
8000b41c:	c0 31       	brne	8000b422 <_calloc_r+0x42>
8000b41e:	10 a9       	st.w	r8++,r9
8000b420:	10 a9       	st.w	r8++,r9
8000b422:	30 09       	mov	r9,0
8000b424:	10 a9       	st.w	r8++,r9
8000b426:	91 19       	st.w	r8[0x4],r9
8000b428:	91 09       	st.w	r8[0x0],r9
8000b42a:	c0 48       	rjmp	8000b432 <_calloc_r+0x52>
8000b42c:	30 0b       	mov	r11,0
8000b42e:	fe b0 dd 37 	rcall	80006e9c <memset>
8000b432:	0e 9c       	mov	r12,r7
8000b434:	d8 22       	popm	r4-r7,pc
8000b436:	d7 03       	nop

8000b438 <_close_r>:
8000b438:	d4 21       	pushm	r4-r7,lr
8000b43a:	30 08       	mov	r8,0
8000b43c:	18 97       	mov	r7,r12
8000b43e:	e0 66 08 10 	mov	r6,2064
8000b442:	16 9c       	mov	r12,r11
8000b444:	8d 08       	st.w	r6[0x0],r8
8000b446:	fe b0 de db 	rcall	800071fc <_close>
8000b44a:	5b fc       	cp.w	r12,-1
8000b44c:	c0 51       	brne	8000b456 <_close_r+0x1e>
8000b44e:	6c 08       	ld.w	r8,r6[0x0]
8000b450:	58 08       	cp.w	r8,0
8000b452:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b456:	d8 22       	popm	r4-r7,pc

8000b458 <_fclose_r>:
8000b458:	d4 21       	pushm	r4-r7,lr
8000b45a:	18 96       	mov	r6,r12
8000b45c:	16 97       	mov	r7,r11
8000b45e:	58 0b       	cp.w	r11,0
8000b460:	c0 31       	brne	8000b466 <_fclose_r+0xe>
8000b462:	16 95       	mov	r5,r11
8000b464:	c5 38       	rjmp	8000b50a <_fclose_r+0xb2>
8000b466:	fe b0 f8 a9 	rcall	8000a5b8 <__sfp_lock_acquire>
8000b46a:	58 06       	cp.w	r6,0
8000b46c:	c0 70       	breq	8000b47a <_fclose_r+0x22>
8000b46e:	6c 68       	ld.w	r8,r6[0x18]
8000b470:	58 08       	cp.w	r8,0
8000b472:	c0 41       	brne	8000b47a <_fclose_r+0x22>
8000b474:	0c 9c       	mov	r12,r6
8000b476:	fe b0 f8 f3 	rcall	8000a65c <__sinit>
8000b47a:	fe c8 eb 5e 	sub	r8,pc,-5282
8000b47e:	10 37       	cp.w	r7,r8
8000b480:	c0 31       	brne	8000b486 <_fclose_r+0x2e>
8000b482:	6c 07       	ld.w	r7,r6[0x0]
8000b484:	c0 c8       	rjmp	8000b49c <_fclose_r+0x44>
8000b486:	fe c8 eb 4a 	sub	r8,pc,-5302
8000b48a:	10 37       	cp.w	r7,r8
8000b48c:	c0 31       	brne	8000b492 <_fclose_r+0x3a>
8000b48e:	6c 17       	ld.w	r7,r6[0x4]
8000b490:	c0 68       	rjmp	8000b49c <_fclose_r+0x44>
8000b492:	fe c8 eb 36 	sub	r8,pc,-5322
8000b496:	10 37       	cp.w	r7,r8
8000b498:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b49c:	8e 69       	ld.sh	r9,r7[0xc]
8000b49e:	30 08       	mov	r8,0
8000b4a0:	f0 09 19 00 	cp.h	r9,r8
8000b4a4:	c0 51       	brne	8000b4ae <_fclose_r+0x56>
8000b4a6:	fe b0 f8 8a 	rcall	8000a5ba <__sfp_lock_release>
8000b4aa:	30 05       	mov	r5,0
8000b4ac:	c2 f8       	rjmp	8000b50a <_fclose_r+0xb2>
8000b4ae:	0e 9b       	mov	r11,r7
8000b4b0:	0c 9c       	mov	r12,r6
8000b4b2:	fe b0 f7 fd 	rcall	8000a4ac <_fflush_r>
8000b4b6:	6e c8       	ld.w	r8,r7[0x30]
8000b4b8:	18 95       	mov	r5,r12
8000b4ba:	58 08       	cp.w	r8,0
8000b4bc:	c0 60       	breq	8000b4c8 <_fclose_r+0x70>
8000b4be:	6e 8b       	ld.w	r11,r7[0x20]
8000b4c0:	0c 9c       	mov	r12,r6
8000b4c2:	5d 18       	icall	r8
8000b4c4:	f9 b5 05 ff 	movlt	r5,-1
8000b4c8:	8e 68       	ld.sh	r8,r7[0xc]
8000b4ca:	ed b8 00 07 	bld	r8,0x7
8000b4ce:	c0 51       	brne	8000b4d8 <_fclose_r+0x80>
8000b4d0:	6e 4b       	ld.w	r11,r7[0x10]
8000b4d2:	0c 9c       	mov	r12,r6
8000b4d4:	fe b0 f9 5e 	rcall	8000a790 <_free_r>
8000b4d8:	6e db       	ld.w	r11,r7[0x34]
8000b4da:	58 0b       	cp.w	r11,0
8000b4dc:	c0 a0       	breq	8000b4f0 <_fclose_r+0x98>
8000b4de:	ee c8 ff bc 	sub	r8,r7,-68
8000b4e2:	10 3b       	cp.w	r11,r8
8000b4e4:	c0 40       	breq	8000b4ec <_fclose_r+0x94>
8000b4e6:	0c 9c       	mov	r12,r6
8000b4e8:	fe b0 f9 54 	rcall	8000a790 <_free_r>
8000b4ec:	30 08       	mov	r8,0
8000b4ee:	8f d8       	st.w	r7[0x34],r8
8000b4f0:	6f 2b       	ld.w	r11,r7[0x48]
8000b4f2:	58 0b       	cp.w	r11,0
8000b4f4:	c0 70       	breq	8000b502 <_fclose_r+0xaa>
8000b4f6:	0c 9c       	mov	r12,r6
8000b4f8:	fe b0 f9 4c 	rcall	8000a790 <_free_r>
8000b4fc:	30 08       	mov	r8,0
8000b4fe:	ef 48 00 48 	st.w	r7[72],r8
8000b502:	30 08       	mov	r8,0
8000b504:	ae 68       	st.h	r7[0xc],r8
8000b506:	fe b0 f8 5a 	rcall	8000a5ba <__sfp_lock_release>
8000b50a:	0a 9c       	mov	r12,r5
8000b50c:	d8 22       	popm	r4-r7,pc
8000b50e:	d7 03       	nop

8000b510 <fclose>:
8000b510:	d4 01       	pushm	lr
8000b512:	e0 68 01 18 	mov	r8,280
8000b516:	18 9b       	mov	r11,r12
8000b518:	70 0c       	ld.w	r12,r8[0x0]
8000b51a:	c9 ff       	rcall	8000b458 <_fclose_r>
8000b51c:	d8 02       	popm	pc
8000b51e:	d7 03       	nop

8000b520 <_fstat_r>:
8000b520:	d4 21       	pushm	r4-r7,lr
8000b522:	16 98       	mov	r8,r11
8000b524:	18 97       	mov	r7,r12
8000b526:	10 9c       	mov	r12,r8
8000b528:	30 08       	mov	r8,0
8000b52a:	e0 66 08 10 	mov	r6,2064
8000b52e:	14 9b       	mov	r11,r10
8000b530:	8d 08       	st.w	r6[0x0],r8
8000b532:	fe b0 de 8d 	rcall	8000724c <_fstat>
8000b536:	5b fc       	cp.w	r12,-1
8000b538:	c0 51       	brne	8000b542 <_fstat_r+0x22>
8000b53a:	6c 08       	ld.w	r8,r6[0x0]
8000b53c:	58 08       	cp.w	r8,0
8000b53e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b542:	d8 22       	popm	r4-r7,pc

8000b544 <_lseek_r>:
8000b544:	d4 21       	pushm	r4-r7,lr
8000b546:	16 98       	mov	r8,r11
8000b548:	18 97       	mov	r7,r12
8000b54a:	10 9c       	mov	r12,r8
8000b54c:	30 08       	mov	r8,0
8000b54e:	14 9b       	mov	r11,r10
8000b550:	e0 66 08 10 	mov	r6,2064
8000b554:	12 9a       	mov	r10,r9
8000b556:	8d 08       	st.w	r6[0x0],r8
8000b558:	fe b0 de 5c 	rcall	80007210 <_lseek>
8000b55c:	5b fc       	cp.w	r12,-1
8000b55e:	c0 51       	brne	8000b568 <_lseek_r+0x24>
8000b560:	6c 08       	ld.w	r8,r6[0x0]
8000b562:	58 08       	cp.w	r8,0
8000b564:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b568:	d8 22       	popm	r4-r7,pc
8000b56a:	d7 03       	nop

8000b56c <_read_r>:
8000b56c:	d4 21       	pushm	r4-r7,lr
8000b56e:	16 98       	mov	r8,r11
8000b570:	18 97       	mov	r7,r12
8000b572:	10 9c       	mov	r12,r8
8000b574:	30 08       	mov	r8,0
8000b576:	14 9b       	mov	r11,r10
8000b578:	e0 66 08 10 	mov	r6,2064
8000b57c:	12 9a       	mov	r10,r9
8000b57e:	8d 08       	st.w	r6[0x0],r8
8000b580:	fe b0 ce 56 	rcall	8000522c <_read>
8000b584:	5b fc       	cp.w	r12,-1
8000b586:	c0 51       	brne	8000b590 <_read_r+0x24>
8000b588:	6c 08       	ld.w	r8,r6[0x0]
8000b58a:	58 08       	cp.w	r8,0
8000b58c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b590:	d8 22       	popm	r4-r7,pc
8000b592:	d7 03       	nop

8000b594 <__avr32_f64_mul>:
8000b594:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b598:	e0 80 00 dc 	breq	8000b750 <__avr32_f64_mul_op1_zero>
8000b59c:	d4 21       	pushm	r4-r7,lr
8000b59e:	f7 e9 20 0e 	eor	lr,r11,r9
8000b5a2:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b5a6:	30 15       	mov	r5,1
8000b5a8:	c4 30       	breq	8000b62e <__avr32_f64_mul_op1_subnormal>
8000b5aa:	ab 6b       	lsl	r11,0xa
8000b5ac:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b5b0:	ab 6a       	lsl	r10,0xa
8000b5b2:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b5b6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b5ba:	c5 c0       	breq	8000b672 <__avr32_f64_mul_op2_subnormal>
8000b5bc:	a1 78       	lsl	r8,0x1
8000b5be:	5c f9       	rol	r9
8000b5c0:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b5c4:	e0 47 07 ff 	cp.w	r7,2047
8000b5c8:	c7 70       	breq	8000b6b6 <__avr32_f64_mul_op_nan_or_inf>
8000b5ca:	e0 46 07 ff 	cp.w	r6,2047
8000b5ce:	c7 40       	breq	8000b6b6 <__avr32_f64_mul_op_nan_or_inf>
8000b5d0:	ee 06 00 0c 	add	r12,r7,r6
8000b5d4:	e0 2c 03 fe 	sub	r12,1022
8000b5d8:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b5dc:	f4 09 07 44 	macu.d	r4,r10,r9
8000b5e0:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b5e4:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b5e8:	08 07       	add	r7,r4
8000b5ea:	f4 05 00 4a 	adc	r10,r10,r5
8000b5ee:	5c 0b       	acr	r11
8000b5f0:	ed bb 00 14 	bld	r11,0x14
8000b5f4:	c0 50       	breq	8000b5fe <__avr32_f64_mul+0x6a>
8000b5f6:	a1 77       	lsl	r7,0x1
8000b5f8:	5c fa       	rol	r10
8000b5fa:	5c fb       	rol	r11
8000b5fc:	20 1c       	sub	r12,1
8000b5fe:	58 0c       	cp.w	r12,0
8000b600:	e0 8a 00 6f 	brle	8000b6de <__avr32_f64_mul_res_subnormal>
8000b604:	e0 4c 07 ff 	cp.w	r12,2047
8000b608:	e0 84 00 9c 	brge	8000b740 <__avr32_f64_mul_res_inf>
8000b60c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b610:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b614:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b618:	ee 17 80 00 	eorh	r7,0x8000
8000b61c:	f1 b7 04 20 	satu	r7,0x1
8000b620:	0e 0a       	add	r10,r7
8000b622:	5c 0b       	acr	r11
8000b624:	ed be 00 1f 	bld	lr,0x1f
8000b628:	ef bb 00 1f 	bst	r11,0x1f
8000b62c:	d8 22       	popm	r4-r7,pc

8000b62e <__avr32_f64_mul_op1_subnormal>:
8000b62e:	e4 1b 00 0f 	andh	r11,0xf
8000b632:	f4 0c 12 00 	clz	r12,r10
8000b636:	f6 06 12 00 	clz	r6,r11
8000b63a:	f7 bc 03 e1 	sublo	r12,-31
8000b63e:	f8 06 17 30 	movlo	r6,r12
8000b642:	f7 b6 02 01 	subhs	r6,1
8000b646:	e0 46 00 20 	cp.w	r6,32
8000b64a:	c0 d4       	brge	8000b664 <__avr32_f64_mul_op1_subnormal+0x36>
8000b64c:	ec 0c 11 20 	rsub	r12,r6,32
8000b650:	f6 06 09 4b 	lsl	r11,r11,r6
8000b654:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b658:	18 4b       	or	r11,r12
8000b65a:	f4 06 09 4a 	lsl	r10,r10,r6
8000b65e:	20 b6       	sub	r6,11
8000b660:	0c 17       	sub	r7,r6
8000b662:	ca ab       	rjmp	8000b5b6 <__avr32_f64_mul+0x22>
8000b664:	f4 06 09 4b 	lsl	r11,r10,r6
8000b668:	c6 40       	breq	8000b730 <__avr32_f64_mul_res_zero>
8000b66a:	30 0a       	mov	r10,0
8000b66c:	20 b6       	sub	r6,11
8000b66e:	0c 17       	sub	r7,r6
8000b670:	ca 3b       	rjmp	8000b5b6 <__avr32_f64_mul+0x22>

8000b672 <__avr32_f64_mul_op2_subnormal>:
8000b672:	e4 19 00 0f 	andh	r9,0xf
8000b676:	f0 0c 12 00 	clz	r12,r8
8000b67a:	f2 05 12 00 	clz	r5,r9
8000b67e:	f7 bc 03 ea 	sublo	r12,-22
8000b682:	f8 05 17 30 	movlo	r5,r12
8000b686:	f7 b5 02 0a 	subhs	r5,10
8000b68a:	e0 45 00 20 	cp.w	r5,32
8000b68e:	c0 d4       	brge	8000b6a8 <__avr32_f64_mul_op2_subnormal+0x36>
8000b690:	ea 0c 11 20 	rsub	r12,r5,32
8000b694:	f2 05 09 49 	lsl	r9,r9,r5
8000b698:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b69c:	18 49       	or	r9,r12
8000b69e:	f0 05 09 48 	lsl	r8,r8,r5
8000b6a2:	20 25       	sub	r5,2
8000b6a4:	0a 16       	sub	r6,r5
8000b6a6:	c8 fb       	rjmp	8000b5c4 <__avr32_f64_mul+0x30>
8000b6a8:	f0 05 09 49 	lsl	r9,r8,r5
8000b6ac:	c4 20       	breq	8000b730 <__avr32_f64_mul_res_zero>
8000b6ae:	30 08       	mov	r8,0
8000b6b0:	20 25       	sub	r5,2
8000b6b2:	0a 16       	sub	r6,r5
8000b6b4:	c8 8b       	rjmp	8000b5c4 <__avr32_f64_mul+0x30>

8000b6b6 <__avr32_f64_mul_op_nan_or_inf>:
8000b6b6:	e4 19 00 0f 	andh	r9,0xf
8000b6ba:	e4 1b 00 0f 	andh	r11,0xf
8000b6be:	14 4b       	or	r11,r10
8000b6c0:	10 49       	or	r9,r8
8000b6c2:	e0 47 07 ff 	cp.w	r7,2047
8000b6c6:	c0 91       	brne	8000b6d8 <__avr32_f64_mul_op1_not_naninf>
8000b6c8:	58 0b       	cp.w	r11,0
8000b6ca:	c3 81       	brne	8000b73a <__avr32_f64_mul_res_nan>
8000b6cc:	e0 46 07 ff 	cp.w	r6,2047
8000b6d0:	c3 81       	brne	8000b740 <__avr32_f64_mul_res_inf>
8000b6d2:	58 09       	cp.w	r9,0
8000b6d4:	c3 60       	breq	8000b740 <__avr32_f64_mul_res_inf>
8000b6d6:	c3 28       	rjmp	8000b73a <__avr32_f64_mul_res_nan>

8000b6d8 <__avr32_f64_mul_op1_not_naninf>:
8000b6d8:	58 09       	cp.w	r9,0
8000b6da:	c3 30       	breq	8000b740 <__avr32_f64_mul_res_inf>
8000b6dc:	c2 f8       	rjmp	8000b73a <__avr32_f64_mul_res_nan>

8000b6de <__avr32_f64_mul_res_subnormal>:
8000b6de:	5c 3c       	neg	r12
8000b6e0:	2f fc       	sub	r12,-1
8000b6e2:	f1 bc 04 c0 	satu	r12,0x6
8000b6e6:	e0 4c 00 20 	cp.w	r12,32
8000b6ea:	c1 14       	brge	8000b70c <__avr32_f64_mul_res_subnormal+0x2e>
8000b6ec:	f8 08 11 20 	rsub	r8,r12,32
8000b6f0:	0e 46       	or	r6,r7
8000b6f2:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b6f6:	f4 08 09 49 	lsl	r9,r10,r8
8000b6fa:	12 47       	or	r7,r9
8000b6fc:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b700:	f6 08 09 49 	lsl	r9,r11,r8
8000b704:	12 4a       	or	r10,r9
8000b706:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b70a:	c8 3b       	rjmp	8000b610 <__avr32_f64_mul+0x7c>
8000b70c:	f8 08 11 20 	rsub	r8,r12,32
8000b710:	f9 b9 00 00 	moveq	r9,0
8000b714:	c0 30       	breq	8000b71a <__avr32_f64_mul_res_subnormal+0x3c>
8000b716:	f6 08 09 49 	lsl	r9,r11,r8
8000b71a:	0e 46       	or	r6,r7
8000b71c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b720:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b724:	f3 ea 10 07 	or	r7,r9,r10
8000b728:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b72c:	30 0b       	mov	r11,0
8000b72e:	c7 1b       	rjmp	8000b610 <__avr32_f64_mul+0x7c>

8000b730 <__avr32_f64_mul_res_zero>:
8000b730:	1c 9b       	mov	r11,lr
8000b732:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b736:	30 0a       	mov	r10,0
8000b738:	d8 22       	popm	r4-r7,pc

8000b73a <__avr32_f64_mul_res_nan>:
8000b73a:	3f fb       	mov	r11,-1
8000b73c:	3f fa       	mov	r10,-1
8000b73e:	d8 22       	popm	r4-r7,pc

8000b740 <__avr32_f64_mul_res_inf>:
8000b740:	f0 6b 00 00 	mov	r11,-1048576
8000b744:	ed be 00 1f 	bld	lr,0x1f
8000b748:	ef bb 00 1f 	bst	r11,0x1f
8000b74c:	30 0a       	mov	r10,0
8000b74e:	d8 22       	popm	r4-r7,pc

8000b750 <__avr32_f64_mul_op1_zero>:
8000b750:	f7 e9 20 0b 	eor	r11,r11,r9
8000b754:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b758:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b75c:	e0 4c 07 ff 	cp.w	r12,2047
8000b760:	5e 1c       	retne	r12
8000b762:	3f fa       	mov	r10,-1
8000b764:	3f fb       	mov	r11,-1
8000b766:	5e fc       	retal	r12

8000b768 <__avr32_f64_sub_from_add>:
8000b768:	ee 19 80 00 	eorh	r9,0x8000

8000b76c <__avr32_f64_sub>:
8000b76c:	f7 e9 20 0c 	eor	r12,r11,r9
8000b770:	e0 86 00 ca 	brmi	8000b904 <__avr32_f64_add_from_sub>
8000b774:	eb cd 40 e0 	pushm	r5-r7,lr
8000b778:	16 9c       	mov	r12,r11
8000b77a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b77e:	bf db       	cbr	r11,0x1f
8000b780:	bf d9       	cbr	r9,0x1f
8000b782:	10 3a       	cp.w	r10,r8
8000b784:	f2 0b 13 00 	cpc	r11,r9
8000b788:	c0 92       	brcc	8000b79a <__avr32_f64_sub+0x2e>
8000b78a:	16 97       	mov	r7,r11
8000b78c:	12 9b       	mov	r11,r9
8000b78e:	0e 99       	mov	r9,r7
8000b790:	14 97       	mov	r7,r10
8000b792:	10 9a       	mov	r10,r8
8000b794:	0e 98       	mov	r8,r7
8000b796:	ee 1c 80 00 	eorh	r12,0x8000
8000b79a:	f6 07 16 14 	lsr	r7,r11,0x14
8000b79e:	ab 7b       	lsl	r11,0xb
8000b7a0:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b7a4:	ab 7a       	lsl	r10,0xb
8000b7a6:	bf bb       	sbr	r11,0x1f
8000b7a8:	f2 06 16 14 	lsr	r6,r9,0x14
8000b7ac:	c4 40       	breq	8000b834 <__avr32_f64_sub_opL_subnormal>
8000b7ae:	ab 79       	lsl	r9,0xb
8000b7b0:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b7b4:	ab 78       	lsl	r8,0xb
8000b7b6:	bf b9       	sbr	r9,0x1f

8000b7b8 <__avr32_f64_sub_opL_subnormal_done>:
8000b7b8:	e0 47 07 ff 	cp.w	r7,2047
8000b7bc:	c4 f0       	breq	8000b85a <__avr32_f64_sub_opH_nan_or_inf>
8000b7be:	0e 26       	rsub	r6,r7
8000b7c0:	c1 20       	breq	8000b7e4 <__avr32_f64_sub_shift_done>
8000b7c2:	ec 05 11 20 	rsub	r5,r6,32
8000b7c6:	e0 46 00 20 	cp.w	r6,32
8000b7ca:	c7 c2       	brcc	8000b8c2 <__avr32_f64_sub_longshift>
8000b7cc:	f0 05 09 4e 	lsl	lr,r8,r5
8000b7d0:	f2 05 09 45 	lsl	r5,r9,r5
8000b7d4:	f0 06 0a 48 	lsr	r8,r8,r6
8000b7d8:	f2 06 0a 49 	lsr	r9,r9,r6
8000b7dc:	0a 48       	or	r8,r5
8000b7de:	58 0e       	cp.w	lr,0
8000b7e0:	5f 1e       	srne	lr
8000b7e2:	1c 48       	or	r8,lr

8000b7e4 <__avr32_f64_sub_shift_done>:
8000b7e4:	10 1a       	sub	r10,r8
8000b7e6:	f6 09 01 4b 	sbc	r11,r11,r9
8000b7ea:	f6 06 12 00 	clz	r6,r11
8000b7ee:	c0 e0       	breq	8000b80a <__avr32_f64_sub_longnormalize_done>
8000b7f0:	c7 83       	brcs	8000b8e0 <__avr32_f64_sub_longnormalize>
8000b7f2:	ec 0e 11 20 	rsub	lr,r6,32
8000b7f6:	f6 06 09 4b 	lsl	r11,r11,r6
8000b7fa:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b7fe:	1c 4b       	or	r11,lr
8000b800:	f4 06 09 4a 	lsl	r10,r10,r6
8000b804:	0c 17       	sub	r7,r6
8000b806:	e0 8a 00 39 	brle	8000b878 <__avr32_f64_sub_subnormal_result>

8000b80a <__avr32_f64_sub_longnormalize_done>:
8000b80a:	f4 09 15 15 	lsl	r9,r10,0x15
8000b80e:	ab 9a       	lsr	r10,0xb
8000b810:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b814:	ab 9b       	lsr	r11,0xb
8000b816:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b81a:	18 4b       	or	r11,r12

8000b81c <__avr32_f64_sub_round>:
8000b81c:	fc 17 80 00 	movh	r7,0x8000
8000b820:	ed ba 00 00 	bld	r10,0x0
8000b824:	f7 b7 01 ff 	subne	r7,-1
8000b828:	0e 39       	cp.w	r9,r7
8000b82a:	5f 29       	srhs	r9
8000b82c:	12 0a       	add	r10,r9
8000b82e:	5c 0b       	acr	r11
8000b830:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b834 <__avr32_f64_sub_opL_subnormal>:
8000b834:	ab 79       	lsl	r9,0xb
8000b836:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b83a:	ab 78       	lsl	r8,0xb
8000b83c:	f3 e8 10 0e 	or	lr,r9,r8
8000b840:	f9 b6 01 01 	movne	r6,1
8000b844:	ee 0e 11 00 	rsub	lr,r7,0
8000b848:	f9 b7 00 01 	moveq	r7,1
8000b84c:	ef bb 00 1f 	bst	r11,0x1f
8000b850:	f7 ea 10 0e 	or	lr,r11,r10
8000b854:	f9 b7 00 00 	moveq	r7,0
8000b858:	cb 0b       	rjmp	8000b7b8 <__avr32_f64_sub_opL_subnormal_done>

8000b85a <__avr32_f64_sub_opH_nan_or_inf>:
8000b85a:	bf db       	cbr	r11,0x1f
8000b85c:	f7 ea 10 0e 	or	lr,r11,r10
8000b860:	c0 81       	brne	8000b870 <__avr32_f64_sub_return_nan>
8000b862:	e0 46 07 ff 	cp.w	r6,2047
8000b866:	c0 50       	breq	8000b870 <__avr32_f64_sub_return_nan>
8000b868:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b86c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b870 <__avr32_f64_sub_return_nan>:
8000b870:	3f fa       	mov	r10,-1
8000b872:	3f fb       	mov	r11,-1
8000b874:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b878 <__avr32_f64_sub_subnormal_result>:
8000b878:	5c 37       	neg	r7
8000b87a:	2f f7       	sub	r7,-1
8000b87c:	f1 b7 04 c0 	satu	r7,0x6
8000b880:	e0 47 00 20 	cp.w	r7,32
8000b884:	c1 14       	brge	8000b8a6 <__avr32_f64_sub_subnormal_result+0x2e>
8000b886:	ee 08 11 20 	rsub	r8,r7,32
8000b88a:	f4 08 09 49 	lsl	r9,r10,r8
8000b88e:	5f 16       	srne	r6
8000b890:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b894:	0c 4a       	or	r10,r6
8000b896:	f6 08 09 49 	lsl	r9,r11,r8
8000b89a:	f5 e9 10 0a 	or	r10,r10,r9
8000b89e:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b8a2:	30 07       	mov	r7,0
8000b8a4:	cb 3b       	rjmp	8000b80a <__avr32_f64_sub_longnormalize_done>
8000b8a6:	ee 08 11 40 	rsub	r8,r7,64
8000b8aa:	f6 08 09 49 	lsl	r9,r11,r8
8000b8ae:	14 49       	or	r9,r10
8000b8b0:	5f 16       	srne	r6
8000b8b2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b8b6:	0c 4a       	or	r10,r6
8000b8b8:	30 0b       	mov	r11,0
8000b8ba:	30 07       	mov	r7,0
8000b8bc:	ca 7b       	rjmp	8000b80a <__avr32_f64_sub_longnormalize_done>
8000b8be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b8c2 <__avr32_f64_sub_longshift>:
8000b8c2:	f1 b6 04 c0 	satu	r6,0x6
8000b8c6:	f0 0e 17 00 	moveq	lr,r8
8000b8ca:	c0 40       	breq	8000b8d2 <__avr32_f64_sub_longshift+0x10>
8000b8cc:	f2 05 09 4e 	lsl	lr,r9,r5
8000b8d0:	10 4e       	or	lr,r8
8000b8d2:	f2 06 0a 48 	lsr	r8,r9,r6
8000b8d6:	30 09       	mov	r9,0
8000b8d8:	58 0e       	cp.w	lr,0
8000b8da:	5f 1e       	srne	lr
8000b8dc:	1c 48       	or	r8,lr
8000b8de:	c8 3b       	rjmp	8000b7e4 <__avr32_f64_sub_shift_done>

8000b8e0 <__avr32_f64_sub_longnormalize>:
8000b8e0:	f4 06 12 00 	clz	r6,r10
8000b8e4:	f9 b7 03 00 	movlo	r7,0
8000b8e8:	f9 b6 03 00 	movlo	r6,0
8000b8ec:	f9 bc 03 00 	movlo	r12,0
8000b8f0:	f7 b6 02 e0 	subhs	r6,-32
8000b8f4:	f4 06 09 4b 	lsl	r11,r10,r6
8000b8f8:	30 0a       	mov	r10,0
8000b8fa:	0c 17       	sub	r7,r6
8000b8fc:	fe 9a ff be 	brle	8000b878 <__avr32_f64_sub_subnormal_result>
8000b900:	c8 5b       	rjmp	8000b80a <__avr32_f64_sub_longnormalize_done>
8000b902:	d7 03       	nop

8000b904 <__avr32_f64_add_from_sub>:
8000b904:	ee 19 80 00 	eorh	r9,0x8000

8000b908 <__avr32_f64_add>:
8000b908:	f7 e9 20 0c 	eor	r12,r11,r9
8000b90c:	fe 96 ff 2e 	brmi	8000b768 <__avr32_f64_sub_from_add>
8000b910:	eb cd 40 e0 	pushm	r5-r7,lr
8000b914:	16 9c       	mov	r12,r11
8000b916:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b91a:	bf db       	cbr	r11,0x1f
8000b91c:	bf d9       	cbr	r9,0x1f
8000b91e:	12 3b       	cp.w	r11,r9
8000b920:	c0 72       	brcc	8000b92e <__avr32_f64_add+0x26>
8000b922:	16 97       	mov	r7,r11
8000b924:	12 9b       	mov	r11,r9
8000b926:	0e 99       	mov	r9,r7
8000b928:	14 97       	mov	r7,r10
8000b92a:	10 9a       	mov	r10,r8
8000b92c:	0e 98       	mov	r8,r7
8000b92e:	30 0e       	mov	lr,0
8000b930:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b934:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b938:	b5 ab       	sbr	r11,0x14
8000b93a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b93e:	c6 20       	breq	8000ba02 <__avr32_f64_add_op2_subnormal>
8000b940:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b944:	b5 a9       	sbr	r9,0x14
8000b946:	e0 47 07 ff 	cp.w	r7,2047
8000b94a:	c2 80       	breq	8000b99a <__avr32_f64_add_opH_nan_or_inf>
8000b94c:	0e 26       	rsub	r6,r7
8000b94e:	c1 20       	breq	8000b972 <__avr32_f64_add_shift_done>
8000b950:	e0 46 00 36 	cp.w	r6,54
8000b954:	c1 52       	brcc	8000b97e <__avr32_f64_add_res_of_done>
8000b956:	ec 05 11 20 	rsub	r5,r6,32
8000b95a:	e0 46 00 20 	cp.w	r6,32
8000b95e:	c3 52       	brcc	8000b9c8 <__avr32_f64_add_longshift>
8000b960:	f0 05 09 4e 	lsl	lr,r8,r5
8000b964:	f2 05 09 45 	lsl	r5,r9,r5
8000b968:	f0 06 0a 48 	lsr	r8,r8,r6
8000b96c:	f2 06 0a 49 	lsr	r9,r9,r6
8000b970:	0a 48       	or	r8,r5

8000b972 <__avr32_f64_add_shift_done>:
8000b972:	10 0a       	add	r10,r8
8000b974:	f6 09 00 4b 	adc	r11,r11,r9
8000b978:	ed bb 00 15 	bld	r11,0x15
8000b97c:	c3 40       	breq	8000b9e4 <__avr32_f64_add_res_of>

8000b97e <__avr32_f64_add_res_of_done>:
8000b97e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b982:	18 4b       	or	r11,r12

8000b984 <__avr32_f64_add_round>:
8000b984:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b988:	18 4e       	or	lr,r12
8000b98a:	ee 1e 80 00 	eorh	lr,0x8000
8000b98e:	f1 be 04 20 	satu	lr,0x1
8000b992:	1c 0a       	add	r10,lr
8000b994:	5c 0b       	acr	r11
8000b996:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b99a <__avr32_f64_add_opH_nan_or_inf>:
8000b99a:	b5 cb       	cbr	r11,0x14
8000b99c:	f7 ea 10 0e 	or	lr,r11,r10
8000b9a0:	c1 01       	brne	8000b9c0 <__avr32_f64_add_return_nan>
8000b9a2:	e0 46 07 ff 	cp.w	r6,2047
8000b9a6:	c0 30       	breq	8000b9ac <__avr32_f64_add_opL_nan_or_inf>
8000b9a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b9ac <__avr32_f64_add_opL_nan_or_inf>:
8000b9ac:	b5 c9       	cbr	r9,0x14
8000b9ae:	f3 e8 10 0e 	or	lr,r9,r8
8000b9b2:	c0 71       	brne	8000b9c0 <__avr32_f64_add_return_nan>
8000b9b4:	30 0a       	mov	r10,0
8000b9b6:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b9ba:	18 4b       	or	r11,r12
8000b9bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b9c0 <__avr32_f64_add_return_nan>:
8000b9c0:	3f fa       	mov	r10,-1
8000b9c2:	3f fb       	mov	r11,-1
8000b9c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b9c8 <__avr32_f64_add_longshift>:
8000b9c8:	f1 b6 04 c0 	satu	r6,0x6
8000b9cc:	f0 0e 17 00 	moveq	lr,r8
8000b9d0:	c0 60       	breq	8000b9dc <__avr32_f64_add_longshift+0x14>
8000b9d2:	f2 05 09 4e 	lsl	lr,r9,r5
8000b9d6:	58 08       	cp.w	r8,0
8000b9d8:	5f 18       	srne	r8
8000b9da:	10 4e       	or	lr,r8
8000b9dc:	f2 06 0a 48 	lsr	r8,r9,r6
8000b9e0:	30 09       	mov	r9,0
8000b9e2:	cc 8b       	rjmp	8000b972 <__avr32_f64_add_shift_done>

8000b9e4 <__avr32_f64_add_res_of>:
8000b9e4:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b9e8:	a1 9b       	lsr	r11,0x1
8000b9ea:	5d 0a       	ror	r10
8000b9ec:	5d 0e       	ror	lr
8000b9ee:	2f f7       	sub	r7,-1
8000b9f0:	e0 47 07 ff 	cp.w	r7,2047
8000b9f4:	f9 ba 00 00 	moveq	r10,0
8000b9f8:	f9 bb 00 00 	moveq	r11,0
8000b9fc:	f9 be 00 00 	moveq	lr,0
8000ba00:	cb fb       	rjmp	8000b97e <__avr32_f64_add_res_of_done>

8000ba02 <__avr32_f64_add_op2_subnormal>:
8000ba02:	30 16       	mov	r6,1
8000ba04:	58 07       	cp.w	r7,0
8000ba06:	ca 01       	brne	8000b946 <__avr32_f64_add+0x3e>
8000ba08:	b5 cb       	cbr	r11,0x14
8000ba0a:	10 0a       	add	r10,r8
8000ba0c:	f6 09 00 4b 	adc	r11,r11,r9
8000ba10:	18 4b       	or	r11,r12
8000ba12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000ba16:	d7 03       	nop

8000ba18 <__avr32_f64_to_u32>:
8000ba18:	58 0b       	cp.w	r11,0
8000ba1a:	5e 6d       	retmi	0

8000ba1c <__avr32_f64_to_s32>:
8000ba1c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000ba20:	b5 9c       	lsr	r12,0x15
8000ba22:	e0 2c 03 ff 	sub	r12,1023
8000ba26:	5e 3d       	retlo	0
8000ba28:	f8 0c 11 1f 	rsub	r12,r12,31
8000ba2c:	16 99       	mov	r9,r11
8000ba2e:	ab 7b       	lsl	r11,0xb
8000ba30:	bf bb       	sbr	r11,0x1f
8000ba32:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000ba36:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ba3a:	a1 79       	lsl	r9,0x1
8000ba3c:	5e 2b       	reths	r11
8000ba3e:	5c 3b       	neg	r11
8000ba40:	5e fb       	retal	r11

8000ba42 <__avr32_u32_to_f64>:
8000ba42:	f8 cb 00 00 	sub	r11,r12,0
8000ba46:	30 0c       	mov	r12,0
8000ba48:	c0 38       	rjmp	8000ba4e <__avr32_s32_to_f64+0x4>

8000ba4a <__avr32_s32_to_f64>:
8000ba4a:	18 9b       	mov	r11,r12
8000ba4c:	5c 4b       	abs	r11
8000ba4e:	30 0a       	mov	r10,0
8000ba50:	5e 0b       	reteq	r11
8000ba52:	d4 01       	pushm	lr
8000ba54:	e0 69 04 1e 	mov	r9,1054
8000ba58:	f6 08 12 00 	clz	r8,r11
8000ba5c:	c1 70       	breq	8000ba8a <__avr32_s32_to_f64+0x40>
8000ba5e:	c0 c3       	brcs	8000ba76 <__avr32_s32_to_f64+0x2c>
8000ba60:	f0 0e 11 20 	rsub	lr,r8,32
8000ba64:	f6 08 09 4b 	lsl	r11,r11,r8
8000ba68:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000ba6c:	1c 4b       	or	r11,lr
8000ba6e:	f4 08 09 4a 	lsl	r10,r10,r8
8000ba72:	10 19       	sub	r9,r8
8000ba74:	c0 b8       	rjmp	8000ba8a <__avr32_s32_to_f64+0x40>
8000ba76:	f4 08 12 00 	clz	r8,r10
8000ba7a:	f9 b8 03 00 	movlo	r8,0
8000ba7e:	f7 b8 02 e0 	subhs	r8,-32
8000ba82:	f4 08 09 4b 	lsl	r11,r10,r8
8000ba86:	30 0a       	mov	r10,0
8000ba88:	10 19       	sub	r9,r8
8000ba8a:	58 09       	cp.w	r9,0
8000ba8c:	e0 89 00 30 	brgt	8000baec <__avr32_s32_to_f64+0xa2>
8000ba90:	5c 39       	neg	r9
8000ba92:	2f f9       	sub	r9,-1
8000ba94:	e0 49 00 36 	cp.w	r9,54
8000ba98:	c0 43       	brcs	8000baa0 <__avr32_s32_to_f64+0x56>
8000ba9a:	30 0b       	mov	r11,0
8000ba9c:	30 0a       	mov	r10,0
8000ba9e:	c2 68       	rjmp	8000baea <__avr32_s32_to_f64+0xa0>
8000baa0:	2f 69       	sub	r9,-10
8000baa2:	f2 08 11 20 	rsub	r8,r9,32
8000baa6:	e0 49 00 20 	cp.w	r9,32
8000baaa:	c0 b2       	brcc	8000bac0 <__avr32_s32_to_f64+0x76>
8000baac:	f4 08 09 4e 	lsl	lr,r10,r8
8000bab0:	f6 08 09 48 	lsl	r8,r11,r8
8000bab4:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bab8:	f6 09 0a 4b 	lsr	r11,r11,r9
8000babc:	10 4b       	or	r11,r8
8000babe:	c0 88       	rjmp	8000bace <__avr32_s32_to_f64+0x84>
8000bac0:	f6 08 09 4e 	lsl	lr,r11,r8
8000bac4:	14 4e       	or	lr,r10
8000bac6:	16 9a       	mov	r10,r11
8000bac8:	30 0b       	mov	r11,0
8000baca:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bace:	ed ba 00 00 	bld	r10,0x0
8000bad2:	c0 92       	brcc	8000bae4 <__avr32_s32_to_f64+0x9a>
8000bad4:	1c 7e       	tst	lr,lr
8000bad6:	c0 41       	brne	8000bade <__avr32_s32_to_f64+0x94>
8000bad8:	ed ba 00 01 	bld	r10,0x1
8000badc:	c0 42       	brcc	8000bae4 <__avr32_s32_to_f64+0x9a>
8000bade:	2f fa       	sub	r10,-1
8000bae0:	f7 bb 02 ff 	subhs	r11,-1
8000bae4:	5c fc       	rol	r12
8000bae6:	5d 0b       	ror	r11
8000bae8:	5d 0a       	ror	r10
8000baea:	d8 02       	popm	pc
8000baec:	e0 68 03 ff 	mov	r8,1023
8000baf0:	ed ba 00 0b 	bld	r10,0xb
8000baf4:	f7 b8 00 ff 	subeq	r8,-1
8000baf8:	10 0a       	add	r10,r8
8000bafa:	5c 0b       	acr	r11
8000bafc:	f7 b9 03 fe 	sublo	r9,-2
8000bb00:	e0 49 07 ff 	cp.w	r9,2047
8000bb04:	c0 55       	brlt	8000bb0e <__avr32_s32_to_f64+0xc4>
8000bb06:	30 0a       	mov	r10,0
8000bb08:	fc 1b ff e0 	movh	r11,0xffe0
8000bb0c:	c0 c8       	rjmp	8000bb24 <__floatsidf_return_op1>
8000bb0e:	ed bb 00 1f 	bld	r11,0x1f
8000bb12:	f7 b9 01 01 	subne	r9,1
8000bb16:	ab 9a       	lsr	r10,0xb
8000bb18:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bb1c:	a1 7b       	lsl	r11,0x1
8000bb1e:	ab 9b       	lsr	r11,0xb
8000bb20:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000bb24 <__floatsidf_return_op1>:
8000bb24:	a1 7c       	lsl	r12,0x1
8000bb26:	5d 0b       	ror	r11
8000bb28:	d8 02       	popm	pc

8000bb2a <__avr32_f64_cmp_eq>:
8000bb2a:	10 3a       	cp.w	r10,r8
8000bb2c:	f2 0b 13 00 	cpc	r11,r9
8000bb30:	c0 80       	breq	8000bb40 <__avr32_f64_cmp_eq+0x16>
8000bb32:	a1 7b       	lsl	r11,0x1
8000bb34:	a1 79       	lsl	r9,0x1
8000bb36:	14 4b       	or	r11,r10
8000bb38:	12 4b       	or	r11,r9
8000bb3a:	10 4b       	or	r11,r8
8000bb3c:	5e 0f       	reteq	1
8000bb3e:	5e fd       	retal	0
8000bb40:	a1 7b       	lsl	r11,0x1
8000bb42:	fc 1c ff e0 	movh	r12,0xffe0
8000bb46:	58 0a       	cp.w	r10,0
8000bb48:	f8 0b 13 00 	cpc	r11,r12
8000bb4c:	5e 8f       	retls	1
8000bb4e:	5e fd       	retal	0

8000bb50 <__avr32_f64_cmp_ge>:
8000bb50:	1a de       	st.w	--sp,lr
8000bb52:	1a d7       	st.w	--sp,r7
8000bb54:	a1 7b       	lsl	r11,0x1
8000bb56:	5f 3c       	srlo	r12
8000bb58:	a1 79       	lsl	r9,0x1
8000bb5a:	5f 37       	srlo	r7
8000bb5c:	5c fc       	rol	r12
8000bb5e:	fc 1e ff e0 	movh	lr,0xffe0
8000bb62:	58 0a       	cp.w	r10,0
8000bb64:	fc 0b 13 00 	cpc	r11,lr
8000bb68:	e0 8b 00 1d 	brhi	8000bba2 <__avr32_f64_cmp_ge+0x52>
8000bb6c:	58 08       	cp.w	r8,0
8000bb6e:	fc 09 13 00 	cpc	r9,lr
8000bb72:	e0 8b 00 18 	brhi	8000bba2 <__avr32_f64_cmp_ge+0x52>
8000bb76:	58 0b       	cp.w	r11,0
8000bb78:	f5 ba 00 00 	subfeq	r10,0
8000bb7c:	c1 50       	breq	8000bba6 <__avr32_f64_cmp_ge+0x56>
8000bb7e:	1b 07       	ld.w	r7,sp++
8000bb80:	1b 0e       	ld.w	lr,sp++
8000bb82:	58 3c       	cp.w	r12,3
8000bb84:	c0 a0       	breq	8000bb98 <__avr32_f64_cmp_ge+0x48>
8000bb86:	58 1c       	cp.w	r12,1
8000bb88:	c0 33       	brcs	8000bb8e <__avr32_f64_cmp_ge+0x3e>
8000bb8a:	5e 0f       	reteq	1
8000bb8c:	5e 1d       	retne	0
8000bb8e:	10 3a       	cp.w	r10,r8
8000bb90:	f2 0b 13 00 	cpc	r11,r9
8000bb94:	5e 2f       	reths	1
8000bb96:	5e 3d       	retlo	0
8000bb98:	14 38       	cp.w	r8,r10
8000bb9a:	f6 09 13 00 	cpc	r9,r11
8000bb9e:	5e 2f       	reths	1
8000bba0:	5e 3d       	retlo	0
8000bba2:	1b 07       	ld.w	r7,sp++
8000bba4:	d8 0a       	popm	pc,r12=0
8000bba6:	58 17       	cp.w	r7,1
8000bba8:	5f 0c       	sreq	r12
8000bbaa:	58 09       	cp.w	r9,0
8000bbac:	f5 b8 00 00 	subfeq	r8,0
8000bbb0:	1b 07       	ld.w	r7,sp++
8000bbb2:	1b 0e       	ld.w	lr,sp++
8000bbb4:	5e 0f       	reteq	1
8000bbb6:	5e fc       	retal	r12

8000bbb8 <__avr32_f64_cmp_lt>:
8000bbb8:	1a de       	st.w	--sp,lr
8000bbba:	1a d7       	st.w	--sp,r7
8000bbbc:	a1 7b       	lsl	r11,0x1
8000bbbe:	5f 3c       	srlo	r12
8000bbc0:	a1 79       	lsl	r9,0x1
8000bbc2:	5f 37       	srlo	r7
8000bbc4:	5c fc       	rol	r12
8000bbc6:	fc 1e ff e0 	movh	lr,0xffe0
8000bbca:	58 0a       	cp.w	r10,0
8000bbcc:	fc 0b 13 00 	cpc	r11,lr
8000bbd0:	e0 8b 00 1d 	brhi	8000bc0a <__avr32_f64_cmp_lt+0x52>
8000bbd4:	58 08       	cp.w	r8,0
8000bbd6:	fc 09 13 00 	cpc	r9,lr
8000bbda:	e0 8b 00 18 	brhi	8000bc0a <__avr32_f64_cmp_lt+0x52>
8000bbde:	58 0b       	cp.w	r11,0
8000bbe0:	f5 ba 00 00 	subfeq	r10,0
8000bbe4:	c1 50       	breq	8000bc0e <__avr32_f64_cmp_lt+0x56>
8000bbe6:	1b 07       	ld.w	r7,sp++
8000bbe8:	1b 0e       	ld.w	lr,sp++
8000bbea:	58 3c       	cp.w	r12,3
8000bbec:	c0 a0       	breq	8000bc00 <__avr32_f64_cmp_lt+0x48>
8000bbee:	58 1c       	cp.w	r12,1
8000bbf0:	c0 33       	brcs	8000bbf6 <__avr32_f64_cmp_lt+0x3e>
8000bbf2:	5e 0d       	reteq	0
8000bbf4:	5e 1f       	retne	1
8000bbf6:	10 3a       	cp.w	r10,r8
8000bbf8:	f2 0b 13 00 	cpc	r11,r9
8000bbfc:	5e 2d       	reths	0
8000bbfe:	5e 3f       	retlo	1
8000bc00:	14 38       	cp.w	r8,r10
8000bc02:	f6 09 13 00 	cpc	r9,r11
8000bc06:	5e 2d       	reths	0
8000bc08:	5e 3f       	retlo	1
8000bc0a:	1b 07       	ld.w	r7,sp++
8000bc0c:	d8 0a       	popm	pc,r12=0
8000bc0e:	58 17       	cp.w	r7,1
8000bc10:	5f 1c       	srne	r12
8000bc12:	58 09       	cp.w	r9,0
8000bc14:	f5 b8 00 00 	subfeq	r8,0
8000bc18:	1b 07       	ld.w	r7,sp++
8000bc1a:	1b 0e       	ld.w	lr,sp++
8000bc1c:	5e 0d       	reteq	0
8000bc1e:	5e fc       	retal	r12

8000bc20 <__avr32_f64_div>:
8000bc20:	eb cd 40 ff 	pushm	r0-r7,lr
8000bc24:	f7 e9 20 0e 	eor	lr,r11,r9
8000bc28:	f6 07 16 14 	lsr	r7,r11,0x14
8000bc2c:	a9 7b       	lsl	r11,0x9
8000bc2e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000bc32:	a9 7a       	lsl	r10,0x9
8000bc34:	bd bb       	sbr	r11,0x1d
8000bc36:	e4 1b 3f ff 	andh	r11,0x3fff
8000bc3a:	ab d7       	cbr	r7,0xb
8000bc3c:	e0 80 00 cc 	breq	8000bdd4 <__avr32_f64_div_round_subnormal+0x54>
8000bc40:	e0 47 07 ff 	cp.w	r7,2047
8000bc44:	e0 84 00 b5 	brge	8000bdae <__avr32_f64_div_round_subnormal+0x2e>
8000bc48:	f2 06 16 14 	lsr	r6,r9,0x14
8000bc4c:	a9 79       	lsl	r9,0x9
8000bc4e:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000bc52:	a9 78       	lsl	r8,0x9
8000bc54:	bd b9       	sbr	r9,0x1d
8000bc56:	e4 19 3f ff 	andh	r9,0x3fff
8000bc5a:	ab d6       	cbr	r6,0xb
8000bc5c:	e0 80 00 e2 	breq	8000be20 <__avr32_f64_div_round_subnormal+0xa0>
8000bc60:	e0 46 07 ff 	cp.w	r6,2047
8000bc64:	e0 84 00 b2 	brge	8000bdc8 <__avr32_f64_div_round_subnormal+0x48>
8000bc68:	0c 17       	sub	r7,r6
8000bc6a:	fe 37 fc 01 	sub	r7,-1023
8000bc6e:	fc 1c 80 00 	movh	r12,0x8000
8000bc72:	f8 03 16 01 	lsr	r3,r12,0x1
8000bc76:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000bc7a:	5c d4       	com	r4
8000bc7c:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000bc80:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bc84:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bc88:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bc8c:	ea 03 15 02 	lsl	r3,r5,0x2
8000bc90:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bc94:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bc98:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bc9c:	ea 03 15 02 	lsl	r3,r5,0x2
8000bca0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bca4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bca8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bcac:	ea 03 15 02 	lsl	r3,r5,0x2
8000bcb0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bcb4:	e4 09 07 40 	macu.d	r0,r2,r9
8000bcb8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bcbc:	02 04       	add	r4,r1
8000bcbe:	5c 05       	acr	r5
8000bcc0:	a3 65       	lsl	r5,0x2
8000bcc2:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bcc6:	a3 64       	lsl	r4,0x2
8000bcc8:	5c 34       	neg	r4
8000bcca:	f8 05 01 45 	sbc	r5,r12,r5
8000bcce:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bcd2:	e4 05 07 40 	macu.d	r0,r2,r5
8000bcd6:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bcda:	02 04       	add	r4,r1
8000bcdc:	5c 05       	acr	r5
8000bcde:	ea 03 15 02 	lsl	r3,r5,0x2
8000bce2:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bce6:	e8 02 15 02 	lsl	r2,r4,0x2
8000bcea:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bcee:	e4 09 07 40 	macu.d	r0,r2,r9
8000bcf2:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bcf6:	02 04       	add	r4,r1
8000bcf8:	5c 05       	acr	r5
8000bcfa:	a3 65       	lsl	r5,0x2
8000bcfc:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bd00:	a3 64       	lsl	r4,0x2
8000bd02:	5c 34       	neg	r4
8000bd04:	f8 05 01 45 	sbc	r5,r12,r5
8000bd08:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bd0c:	e4 05 07 40 	macu.d	r0,r2,r5
8000bd10:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bd14:	02 04       	add	r4,r1
8000bd16:	5c 05       	acr	r5
8000bd18:	ea 03 15 02 	lsl	r3,r5,0x2
8000bd1c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bd20:	e8 02 15 02 	lsl	r2,r4,0x2
8000bd24:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000bd28:	e4 0b 07 40 	macu.d	r0,r2,r11
8000bd2c:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000bd30:	02 02       	add	r2,r1
8000bd32:	5c 03       	acr	r3
8000bd34:	ed b3 00 1c 	bld	r3,0x1c
8000bd38:	c0 90       	breq	8000bd4a <__avr32_f64_div+0x12a>
8000bd3a:	a1 72       	lsl	r2,0x1
8000bd3c:	5c f3       	rol	r3
8000bd3e:	20 17       	sub	r7,1
8000bd40:	a3 9a       	lsr	r10,0x3
8000bd42:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000bd46:	a3 9b       	lsr	r11,0x3
8000bd48:	c0 58       	rjmp	8000bd52 <__avr32_f64_div+0x132>
8000bd4a:	a5 8a       	lsr	r10,0x4
8000bd4c:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000bd50:	a5 8b       	lsr	r11,0x4
8000bd52:	58 07       	cp.w	r7,0
8000bd54:	e0 8a 00 8b 	brle	8000be6a <__avr32_f64_div_res_subnormal>
8000bd58:	e0 12 ff 00 	andl	r2,0xff00
8000bd5c:	e8 12 00 80 	orl	r2,0x80
8000bd60:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bd64:	e4 09 07 40 	macu.d	r0,r2,r9
8000bd68:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bd6c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bd70:	00 05       	add	r5,r0
8000bd72:	f0 01 00 48 	adc	r8,r8,r1
8000bd76:	5c 09       	acr	r9
8000bd78:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bd7c:	58 04       	cp.w	r4,0
8000bd7e:	5c 25       	cpc	r5

8000bd80 <__avr32_f64_div_round_subnormal>:
8000bd80:	f4 08 13 00 	cpc	r8,r10
8000bd84:	f6 09 13 00 	cpc	r9,r11
8000bd88:	5f 36       	srlo	r6
8000bd8a:	f8 06 17 00 	moveq	r6,r12
8000bd8e:	e4 0a 16 08 	lsr	r10,r2,0x8
8000bd92:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000bd96:	e6 0b 16 08 	lsr	r11,r3,0x8
8000bd9a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bd9e:	ed be 00 1f 	bld	lr,0x1f
8000bda2:	ef bb 00 1f 	bst	r11,0x1f
8000bda6:	0c 0a       	add	r10,r6
8000bda8:	5c 0b       	acr	r11
8000bdaa:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bdae:	e4 1b 00 0f 	andh	r11,0xf
8000bdb2:	14 4b       	or	r11,r10
8000bdb4:	e0 81 00 a7 	brne	8000bf02 <__avr32_f64_div_res_subnormal+0x98>
8000bdb8:	f2 06 16 14 	lsr	r6,r9,0x14
8000bdbc:	ab d6       	cbr	r6,0xb
8000bdbe:	e0 46 07 ff 	cp.w	r6,2047
8000bdc2:	e0 81 00 a4 	brne	8000bf0a <__avr32_f64_div_res_subnormal+0xa0>
8000bdc6:	c9 e8       	rjmp	8000bf02 <__avr32_f64_div_res_subnormal+0x98>
8000bdc8:	e4 19 00 0f 	andh	r9,0xf
8000bdcc:	10 49       	or	r9,r8
8000bdce:	e0 81 00 9a 	brne	8000bf02 <__avr32_f64_div_res_subnormal+0x98>
8000bdd2:	c9 28       	rjmp	8000bef6 <__avr32_f64_div_res_subnormal+0x8c>
8000bdd4:	a3 7b       	lsl	r11,0x3
8000bdd6:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000bdda:	a3 7a       	lsl	r10,0x3
8000bddc:	f5 eb 10 04 	or	r4,r10,r11
8000bde0:	e0 80 00 a0 	breq	8000bf20 <__avr32_f64_div_op1_zero>
8000bde4:	f6 04 12 00 	clz	r4,r11
8000bde8:	c1 70       	breq	8000be16 <__avr32_f64_div_round_subnormal+0x96>
8000bdea:	c0 c3       	brcs	8000be02 <__avr32_f64_div_round_subnormal+0x82>
8000bdec:	e8 05 11 20 	rsub	r5,r4,32
8000bdf0:	f6 04 09 4b 	lsl	r11,r11,r4
8000bdf4:	f4 05 0a 45 	lsr	r5,r10,r5
8000bdf8:	0a 4b       	or	r11,r5
8000bdfa:	f4 04 09 4a 	lsl	r10,r10,r4
8000bdfe:	08 17       	sub	r7,r4
8000be00:	c0 b8       	rjmp	8000be16 <__avr32_f64_div_round_subnormal+0x96>
8000be02:	f4 04 12 00 	clz	r4,r10
8000be06:	f9 b4 03 00 	movlo	r4,0
8000be0a:	f7 b4 02 e0 	subhs	r4,-32
8000be0e:	f4 04 09 4b 	lsl	r11,r10,r4
8000be12:	30 0a       	mov	r10,0
8000be14:	08 17       	sub	r7,r4
8000be16:	a3 8a       	lsr	r10,0x2
8000be18:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000be1c:	a3 8b       	lsr	r11,0x2
8000be1e:	c1 1b       	rjmp	8000bc40 <__avr32_f64_div+0x20>
8000be20:	a3 79       	lsl	r9,0x3
8000be22:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000be26:	a3 78       	lsl	r8,0x3
8000be28:	f3 e8 10 04 	or	r4,r9,r8
8000be2c:	c6 f0       	breq	8000bf0a <__avr32_f64_div_res_subnormal+0xa0>
8000be2e:	f2 04 12 00 	clz	r4,r9
8000be32:	c1 70       	breq	8000be60 <__avr32_f64_div_round_subnormal+0xe0>
8000be34:	c0 c3       	brcs	8000be4c <__avr32_f64_div_round_subnormal+0xcc>
8000be36:	e8 05 11 20 	rsub	r5,r4,32
8000be3a:	f2 04 09 49 	lsl	r9,r9,r4
8000be3e:	f0 05 0a 45 	lsr	r5,r8,r5
8000be42:	0a 49       	or	r9,r5
8000be44:	f0 04 09 48 	lsl	r8,r8,r4
8000be48:	08 16       	sub	r6,r4
8000be4a:	c0 b8       	rjmp	8000be60 <__avr32_f64_div_round_subnormal+0xe0>
8000be4c:	f0 04 12 00 	clz	r4,r8
8000be50:	f9 b4 03 00 	movlo	r4,0
8000be54:	f7 b4 02 e0 	subhs	r4,-32
8000be58:	f0 04 09 49 	lsl	r9,r8,r4
8000be5c:	30 08       	mov	r8,0
8000be5e:	08 16       	sub	r6,r4
8000be60:	a3 88       	lsr	r8,0x2
8000be62:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000be66:	a3 89       	lsr	r9,0x2
8000be68:	cf ca       	rjmp	8000bc60 <__avr32_f64_div+0x40>

8000be6a <__avr32_f64_div_res_subnormal>:
8000be6a:	5c 37       	neg	r7
8000be6c:	2f f7       	sub	r7,-1
8000be6e:	f1 b7 04 c0 	satu	r7,0x6
8000be72:	e0 47 00 20 	cp.w	r7,32
8000be76:	c1 54       	brge	8000bea0 <__avr32_f64_div_res_subnormal+0x36>
8000be78:	ee 06 11 20 	rsub	r6,r7,32
8000be7c:	e4 07 0a 42 	lsr	r2,r2,r7
8000be80:	e6 06 09 4c 	lsl	r12,r3,r6
8000be84:	18 42       	or	r2,r12
8000be86:	e6 07 0a 43 	lsr	r3,r3,r7
8000be8a:	f4 06 09 41 	lsl	r1,r10,r6
8000be8e:	f4 07 0a 4a 	lsr	r10,r10,r7
8000be92:	f6 06 09 4c 	lsl	r12,r11,r6
8000be96:	18 4a       	or	r10,r12
8000be98:	f6 07 0a 4b 	lsr	r11,r11,r7
8000be9c:	30 00       	mov	r0,0
8000be9e:	c1 58       	rjmp	8000bec8 <__avr32_f64_div_res_subnormal+0x5e>
8000bea0:	ee 06 11 20 	rsub	r6,r7,32
8000bea4:	f9 b0 00 00 	moveq	r0,0
8000bea8:	f9 bc 00 00 	moveq	r12,0
8000beac:	c0 50       	breq	8000beb6 <__avr32_f64_div_res_subnormal+0x4c>
8000beae:	f4 06 09 40 	lsl	r0,r10,r6
8000beb2:	f6 06 09 4c 	lsl	r12,r11,r6
8000beb6:	e6 07 0a 42 	lsr	r2,r3,r7
8000beba:	30 03       	mov	r3,0
8000bebc:	f4 07 0a 41 	lsr	r1,r10,r7
8000bec0:	18 41       	or	r1,r12
8000bec2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bec6:	30 0b       	mov	r11,0
8000bec8:	e0 12 ff 00 	andl	r2,0xff00
8000becc:	e8 12 00 80 	orl	r2,0x80
8000bed0:	e6 08 06 46 	mulu.d	r6,r3,r8
8000bed4:	e4 09 07 46 	macu.d	r6,r2,r9
8000bed8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bedc:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bee0:	0c 05       	add	r5,r6
8000bee2:	f0 07 00 48 	adc	r8,r8,r7
8000bee6:	5c 09       	acr	r9
8000bee8:	30 07       	mov	r7,0
8000beea:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000beee:	00 34       	cp.w	r4,r0
8000bef0:	e2 05 13 00 	cpc	r5,r1
8000bef4:	c4 6b       	rjmp	8000bd80 <__avr32_f64_div_round_subnormal>
8000bef6:	1c 9b       	mov	r11,lr
8000bef8:	e6 1b 80 00 	andh	r11,0x8000,COH
8000befc:	30 0a       	mov	r10,0
8000befe:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bf02:	3f fb       	mov	r11,-1
8000bf04:	30 0a       	mov	r10,0
8000bf06:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bf0a:	f5 eb 10 04 	or	r4,r10,r11
8000bf0e:	c0 90       	breq	8000bf20 <__avr32_f64_div_op1_zero>
8000bf10:	1c 9b       	mov	r11,lr
8000bf12:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bf16:	ea 1b 7f f0 	orh	r11,0x7ff0
8000bf1a:	30 0a       	mov	r10,0
8000bf1c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000bf20 <__avr32_f64_div_op1_zero>:
8000bf20:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000bf24:	ce f0       	breq	8000bf02 <__avr32_f64_div_res_subnormal+0x98>
8000bf26:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000bf2a:	e0 44 07 ff 	cp.w	r4,2047
8000bf2e:	ce 41       	brne	8000bef6 <__avr32_f64_div_res_subnormal+0x8c>
8000bf30:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000bf34:	ce 10       	breq	8000bef6 <__avr32_f64_div_res_subnormal+0x8c>
8000bf36:	ce 6b       	rjmp	8000bf02 <__avr32_f64_div_res_subnormal+0x98>

8000bf38 <__avr32_umod64>:
8000bf38:	d4 31       	pushm	r0-r7,lr
8000bf3a:	1a 97       	mov	r7,sp
8000bf3c:	20 3d       	sub	sp,12
8000bf3e:	10 9c       	mov	r12,r8
8000bf40:	12 95       	mov	r5,r9
8000bf42:	14 9e       	mov	lr,r10
8000bf44:	16 91       	mov	r1,r11
8000bf46:	16 96       	mov	r6,r11
8000bf48:	58 09       	cp.w	r9,0
8000bf4a:	e0 81 00 81 	brne	8000c04c <__avr32_umod64+0x114>
8000bf4e:	16 38       	cp.w	r8,r11
8000bf50:	e0 88 00 12 	brls	8000bf74 <__avr32_umod64+0x3c>
8000bf54:	f0 08 12 00 	clz	r8,r8
8000bf58:	c4 e0       	breq	8000bff4 <__avr32_umod64+0xbc>
8000bf5a:	f6 08 09 46 	lsl	r6,r11,r8
8000bf5e:	f8 08 09 4c 	lsl	r12,r12,r8
8000bf62:	f0 0b 11 20 	rsub	r11,r8,32
8000bf66:	f4 08 09 4e 	lsl	lr,r10,r8
8000bf6a:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000bf6e:	f7 e6 10 06 	or	r6,r11,r6
8000bf72:	c4 18       	rjmp	8000bff4 <__avr32_umod64+0xbc>
8000bf74:	58 08       	cp.w	r8,0
8000bf76:	c0 51       	brne	8000bf80 <__avr32_umod64+0x48>
8000bf78:	30 19       	mov	r9,1
8000bf7a:	f2 08 0d 08 	divu	r8,r9,r8
8000bf7e:	10 9c       	mov	r12,r8
8000bf80:	f8 08 12 00 	clz	r8,r12
8000bf84:	c0 31       	brne	8000bf8a <__avr32_umod64+0x52>
8000bf86:	18 16       	sub	r6,r12
8000bf88:	c3 68       	rjmp	8000bff4 <__avr32_umod64+0xbc>
8000bf8a:	f0 03 11 20 	rsub	r3,r8,32
8000bf8e:	f4 03 0a 4b 	lsr	r11,r10,r3
8000bf92:	f8 08 09 4c 	lsl	r12,r12,r8
8000bf96:	ec 08 09 49 	lsl	r9,r6,r8
8000bf9a:	ec 03 0a 43 	lsr	r3,r6,r3
8000bf9e:	f7 e9 10 09 	or	r9,r11,r9
8000bfa2:	f8 05 16 10 	lsr	r5,r12,0x10
8000bfa6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bfaa:	e6 05 0d 02 	divu	r2,r3,r5
8000bfae:	f2 0e 16 10 	lsr	lr,r9,0x10
8000bfb2:	ec 02 02 4b 	mul	r11,r6,r2
8000bfb6:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000bfba:	16 3e       	cp.w	lr,r11
8000bfbc:	c0 72       	brcc	8000bfca <__avr32_umod64+0x92>
8000bfbe:	18 0e       	add	lr,r12
8000bfc0:	18 3e       	cp.w	lr,r12
8000bfc2:	c0 43       	brcs	8000bfca <__avr32_umod64+0x92>
8000bfc4:	16 3e       	cp.w	lr,r11
8000bfc6:	fd dc e3 0e 	addcs	lr,lr,r12
8000bfca:	fc 0b 01 03 	sub	r3,lr,r11
8000bfce:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000bfd2:	e6 05 0d 02 	divu	r2,r3,r5
8000bfd6:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bfda:	a5 36       	mul	r6,r2
8000bfdc:	0c 39       	cp.w	r9,r6
8000bfde:	c0 72       	brcc	8000bfec <__avr32_umod64+0xb4>
8000bfe0:	18 09       	add	r9,r12
8000bfe2:	18 39       	cp.w	r9,r12
8000bfe4:	c0 43       	brcs	8000bfec <__avr32_umod64+0xb4>
8000bfe6:	0c 39       	cp.w	r9,r6
8000bfe8:	f3 dc e3 09 	addcs	r9,r9,r12
8000bfec:	f2 06 01 06 	sub	r6,r9,r6
8000bff0:	f4 08 09 4e 	lsl	lr,r10,r8
8000bff4:	f8 0a 16 10 	lsr	r10,r12,0x10
8000bff8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bffc:	ec 0a 0d 02 	divu	r2,r6,r10
8000c000:	fc 09 16 10 	lsr	r9,lr,0x10
8000c004:	ea 02 02 4b 	mul	r11,r5,r2
8000c008:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c00c:	16 39       	cp.w	r9,r11
8000c00e:	c0 72       	brcc	8000c01c <__avr32_umod64+0xe4>
8000c010:	18 09       	add	r9,r12
8000c012:	18 39       	cp.w	r9,r12
8000c014:	c0 43       	brcs	8000c01c <__avr32_umod64+0xe4>
8000c016:	16 39       	cp.w	r9,r11
8000c018:	f3 dc e3 09 	addcs	r9,r9,r12
8000c01c:	f2 0b 01 0b 	sub	r11,r9,r11
8000c020:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c024:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c028:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c02c:	ea 0a 02 4a 	mul	r10,r5,r10
8000c030:	14 3e       	cp.w	lr,r10
8000c032:	c0 72       	brcc	8000c040 <__avr32_umod64+0x108>
8000c034:	18 0e       	add	lr,r12
8000c036:	18 3e       	cp.w	lr,r12
8000c038:	c0 43       	brcs	8000c040 <__avr32_umod64+0x108>
8000c03a:	14 3e       	cp.w	lr,r10
8000c03c:	fd dc e3 0e 	addcs	lr,lr,r12
8000c040:	fc 0a 01 0a 	sub	r10,lr,r10
8000c044:	30 0b       	mov	r11,0
8000c046:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c04a:	c7 b8       	rjmp	8000c140 <__avr32_umod64+0x208>
8000c04c:	16 39       	cp.w	r9,r11
8000c04e:	e0 8b 00 79 	brhi	8000c140 <__avr32_umod64+0x208>
8000c052:	f2 09 12 00 	clz	r9,r9
8000c056:	c1 21       	brne	8000c07a <__avr32_umod64+0x142>
8000c058:	10 3a       	cp.w	r10,r8
8000c05a:	5f 2b       	srhs	r11
8000c05c:	0a 31       	cp.w	r1,r5
8000c05e:	5f ba       	srhi	r10
8000c060:	f7 ea 10 0a 	or	r10,r11,r10
8000c064:	f2 0a 18 00 	cp.b	r10,r9
8000c068:	c0 60       	breq	8000c074 <__avr32_umod64+0x13c>
8000c06a:	fc 08 01 0c 	sub	r12,lr,r8
8000c06e:	e2 05 01 46 	sbc	r6,r1,r5
8000c072:	18 9e       	mov	lr,r12
8000c074:	0c 9b       	mov	r11,r6
8000c076:	1c 9a       	mov	r10,lr
8000c078:	c6 48       	rjmp	8000c140 <__avr32_umod64+0x208>
8000c07a:	ea 09 09 4c 	lsl	r12,r5,r9
8000c07e:	f2 06 11 20 	rsub	r6,r9,32
8000c082:	f6 09 09 4b 	lsl	r11,r11,r9
8000c086:	f0 09 09 42 	lsl	r2,r8,r9
8000c08a:	ef 46 ff f4 	st.w	r7[-12],r6
8000c08e:	f0 06 0a 48 	lsr	r8,r8,r6
8000c092:	18 48       	or	r8,r12
8000c094:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c098:	f4 09 09 43 	lsl	r3,r10,r9
8000c09c:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c0a0:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c0a4:	16 4a       	or	r10,r11
8000c0a6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c0aa:	f8 0b 0d 04 	divu	r4,r12,r11
8000c0ae:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c0b2:	08 91       	mov	r1,r4
8000c0b4:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c0b8:	e8 0e 02 46 	mul	r6,r4,lr
8000c0bc:	0c 3c       	cp.w	r12,r6
8000c0be:	c0 a2       	brcc	8000c0d2 <__avr32_umod64+0x19a>
8000c0c0:	20 11       	sub	r1,1
8000c0c2:	10 0c       	add	r12,r8
8000c0c4:	10 3c       	cp.w	r12,r8
8000c0c6:	c0 63       	brcs	8000c0d2 <__avr32_umod64+0x19a>
8000c0c8:	0c 3c       	cp.w	r12,r6
8000c0ca:	f7 b1 03 01 	sublo	r1,1
8000c0ce:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c0d2:	0c 1c       	sub	r12,r6
8000c0d4:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c0d8:	f8 0b 0d 04 	divu	r4,r12,r11
8000c0dc:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c0e0:	08 96       	mov	r6,r4
8000c0e2:	e8 0e 02 4e 	mul	lr,r4,lr
8000c0e6:	1c 3b       	cp.w	r11,lr
8000c0e8:	c0 a2       	brcc	8000c0fc <__avr32_umod64+0x1c4>
8000c0ea:	20 16       	sub	r6,1
8000c0ec:	10 0b       	add	r11,r8
8000c0ee:	10 3b       	cp.w	r11,r8
8000c0f0:	c0 63       	brcs	8000c0fc <__avr32_umod64+0x1c4>
8000c0f2:	1c 3b       	cp.w	r11,lr
8000c0f4:	f7 b6 03 01 	sublo	r6,1
8000c0f8:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c0fc:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c100:	1c 1b       	sub	r11,lr
8000c102:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c106:	00 9e       	mov	lr,r0
8000c108:	02 9c       	mov	r12,r1
8000c10a:	16 3c       	cp.w	r12,r11
8000c10c:	e0 8b 00 08 	brhi	8000c11c <__avr32_umod64+0x1e4>
8000c110:	5f 06       	sreq	r6
8000c112:	06 30       	cp.w	r0,r3
8000c114:	5f ba       	srhi	r10
8000c116:	ed ea 00 0a 	and	r10,r6,r10
8000c11a:	c0 60       	breq	8000c126 <__avr32_umod64+0x1ee>
8000c11c:	fc 02 01 04 	sub	r4,lr,r2
8000c120:	f8 08 01 4c 	sbc	r12,r12,r8
8000c124:	08 9e       	mov	lr,r4
8000c126:	e6 0e 01 0a 	sub	r10,r3,lr
8000c12a:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c12e:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c132:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c136:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c13a:	f8 01 09 4c 	lsl	r12,r12,r1
8000c13e:	18 4a       	or	r10,r12
8000c140:	2f dd       	sub	sp,-12
8000c142:	d8 32       	popm	r0-r7,pc

8000c144 <__do_global_ctors_aux>:
8000c144:	d4 21       	pushm	r4-r7,lr
8000c146:	30 c7       	mov	r7,12
8000c148:	c0 28       	rjmp	8000c14c <__do_global_ctors_aux+0x8>
8000c14a:	5d 18       	icall	r8
8000c14c:	20 47       	sub	r7,4
8000c14e:	6e 08       	ld.w	r8,r7[0x0]
8000c150:	5b f8       	cp.w	r8,-1
8000c152:	cf c1       	brne	8000c14a <__do_global_ctors_aux+0x6>
8000c154:	d8 22       	popm	r4-r7,pc
8000c156:	d7 03       	nop

Disassembly of section .exception:

8000c200 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
8000c200:	c0 08       	rjmp	8000c200 <_evba>
	...

8000c204 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
8000c204:	c0 08       	rjmp	8000c204 <_handle_TLB_Multiple_Hit>
	...

8000c208 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
8000c208:	c0 08       	rjmp	8000c208 <_handle_Bus_Error_Data_Fetch>
	...

8000c20c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000c20c:	c0 08       	rjmp	8000c20c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c210 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
8000c210:	c0 08       	rjmp	8000c210 <_handle_NMI>
	...

8000c214 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
8000c214:	c0 08       	rjmp	8000c214 <_handle_Instruction_Address>
	...

8000c218 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
8000c218:	c0 08       	rjmp	8000c218 <_handle_ITLB_Protection>
	...

8000c21c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000c21c:	c0 08       	rjmp	8000c21c <_handle_Breakpoint>
	...

8000c220 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
8000c220:	c0 08       	rjmp	8000c220 <_handle_Illegal_Opcode>
	...

8000c224 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
8000c224:	c0 08       	rjmp	8000c224 <_handle_Unimplemented_Instruction>
	...

8000c228 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
8000c228:	c0 08       	rjmp	8000c228 <_handle_Privilege_Violation>
	...

8000c22c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000c22c:	c0 08       	rjmp	8000c22c <_handle_Floating_Point>
	...

8000c230 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
8000c230:	c0 08       	rjmp	8000c230 <_handle_Coprocessor_Absent>
	...

8000c234 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
8000c234:	c0 08       	rjmp	8000c234 <_handle_Data_Address_Read>
	...

8000c238 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
8000c238:	c0 08       	rjmp	8000c238 <_handle_Data_Address_Write>
	...

8000c23c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000c23c:	c0 08       	rjmp	8000c23c <_handle_DTLB_Protection_Read>
	...

8000c240 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
8000c240:	c0 08       	rjmp	8000c240 <_handle_DTLB_Protection_Write>
	...

8000c244 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
8000c244:	c0 08       	rjmp	8000c244 <_handle_DTLB_Modified>
	...

8000c250 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
8000c250:	c0 08       	rjmp	8000c250 <_handle_ITLB_Miss>
	...

8000c260 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
8000c260:	c0 08       	rjmp	8000c260 <_handle_DTLB_Miss_Read>
	...

8000c270 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
8000c270:	c0 08       	rjmp	8000c270 <_handle_DTLB_Miss_Write>
	...

8000c300 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c300:	fe cf 73 f8 	sub	pc,pc,29688

8000c304 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c304:	30 0c       	mov	r12,0
8000c306:	fe b0 c0 71 	rcall	800043e8 <_get_interrupt_handler>
8000c30a:	58 0c       	cp.w	r12,0
8000c30c:	f8 0f 17 10 	movne	pc,r12
8000c310:	d6 03       	rete

8000c312 <_int1>:
8000c312:	30 1c       	mov	r12,1
8000c314:	fe b0 c0 6a 	rcall	800043e8 <_get_interrupt_handler>
8000c318:	58 0c       	cp.w	r12,0
8000c31a:	f8 0f 17 10 	movne	pc,r12
8000c31e:	d6 03       	rete

8000c320 <_int2>:
8000c320:	30 2c       	mov	r12,2
8000c322:	fe b0 c0 63 	rcall	800043e8 <_get_interrupt_handler>
8000c326:	58 0c       	cp.w	r12,0
8000c328:	f8 0f 17 10 	movne	pc,r12
8000c32c:	d6 03       	rete

8000c32e <_int3>:
8000c32e:	30 3c       	mov	r12,3
8000c330:	fe b0 c0 5c 	rcall	800043e8 <_get_interrupt_handler>
8000c334:	58 0c       	cp.w	r12,0
8000c336:	f8 0f 17 10 	movne	pc,r12
8000c33a:	d6 03       	rete
8000c33c:	d7 03       	nop
8000c33e:	d7 03       	nop
8000c340:	d7 03       	nop
8000c342:	d7 03       	nop
8000c344:	d7 03       	nop
8000c346:	d7 03       	nop
8000c348:	d7 03       	nop
8000c34a:	d7 03       	nop
8000c34c:	d7 03       	nop
8000c34e:	d7 03       	nop
8000c350:	d7 03       	nop
8000c352:	d7 03       	nop
8000c354:	d7 03       	nop
8000c356:	d7 03       	nop
8000c358:	d7 03       	nop
8000c35a:	d7 03       	nop
8000c35c:	d7 03       	nop
8000c35e:	d7 03       	nop
8000c360:	d7 03       	nop
8000c362:	d7 03       	nop
8000c364:	d7 03       	nop
8000c366:	d7 03       	nop
8000c368:	d7 03       	nop
8000c36a:	d7 03       	nop
8000c36c:	d7 03       	nop
8000c36e:	d7 03       	nop
8000c370:	d7 03       	nop
8000c372:	d7 03       	nop
8000c374:	d7 03       	nop
8000c376:	d7 03       	nop
8000c378:	d7 03       	nop
8000c37a:	d7 03       	nop
8000c37c:	d7 03       	nop
8000c37e:	d7 03       	nop
8000c380:	d7 03       	nop
8000c382:	d7 03       	nop
8000c384:	d7 03       	nop
8000c386:	d7 03       	nop
8000c388:	d7 03       	nop
8000c38a:	d7 03       	nop
8000c38c:	d7 03       	nop
8000c38e:	d7 03       	nop
8000c390:	d7 03       	nop
8000c392:	d7 03       	nop
8000c394:	d7 03       	nop
8000c396:	d7 03       	nop
8000c398:	d7 03       	nop
8000c39a:	d7 03       	nop
8000c39c:	d7 03       	nop
8000c39e:	d7 03       	nop
8000c3a0:	d7 03       	nop
8000c3a2:	d7 03       	nop
8000c3a4:	d7 03       	nop
8000c3a6:	d7 03       	nop
8000c3a8:	d7 03       	nop
8000c3aa:	d7 03       	nop
8000c3ac:	d7 03       	nop
8000c3ae:	d7 03       	nop
8000c3b0:	d7 03       	nop
8000c3b2:	d7 03       	nop
8000c3b4:	d7 03       	nop
8000c3b6:	d7 03       	nop
8000c3b8:	d7 03       	nop
8000c3ba:	d7 03       	nop
8000c3bc:	d7 03       	nop
8000c3be:	d7 03       	nop
8000c3c0:	d7 03       	nop
8000c3c2:	d7 03       	nop
8000c3c4:	d7 03       	nop
8000c3c6:	d7 03       	nop
8000c3c8:	d7 03       	nop
8000c3ca:	d7 03       	nop
8000c3cc:	d7 03       	nop
8000c3ce:	d7 03       	nop
8000c3d0:	d7 03       	nop
8000c3d2:	d7 03       	nop
8000c3d4:	d7 03       	nop
8000c3d6:	d7 03       	nop
8000c3d8:	d7 03       	nop
8000c3da:	d7 03       	nop
8000c3dc:	d7 03       	nop
8000c3de:	d7 03       	nop
8000c3e0:	d7 03       	nop
8000c3e2:	d7 03       	nop
8000c3e4:	d7 03       	nop
8000c3e6:	d7 03       	nop
8000c3e8:	d7 03       	nop
8000c3ea:	d7 03       	nop
8000c3ec:	d7 03       	nop
8000c3ee:	d7 03       	nop
8000c3f0:	d7 03       	nop
8000c3f2:	d7 03       	nop
8000c3f4:	d7 03       	nop
8000c3f6:	d7 03       	nop
8000c3f8:	d7 03       	nop
8000c3fa:	d7 03       	nop
8000c3fc:	d7 03       	nop
8000c3fe:	d7 03       	nop

Disassembly of section .fini:

8000c400 <_fini>:
8000c400:	eb cd 40 40 	pushm	r6,lr
8000c404:	48 26       	lddpc	r6,8000c40c <_fini+0xc>
8000c406:	1e 26       	rsub	r6,pc
8000c408:	c0 48       	rjmp	8000c410 <_fini+0x10>
8000c40a:	d7 03       	nop
8000c40c:	80 00       	ld.sh	r0,r0[0x0]
8000c40e:	c3 ea       	rjmp	8000c08a <__avr32_umod64+0x152>
8000c410:	fe b0 ae 3e 	rcall	8000208c <__do_global_dtors_aux>
8000c414:	e3 cd 80 40 	ldm	sp++,r6,pc
