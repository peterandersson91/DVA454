
Lab63_Rasmus.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         0000a540  80002028  80002028  00002428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  8000c600  8000c600  0000ca00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  8000c800  8000c800  0000cc00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       00000720  8000c818  8000c818  0000cc18  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  8 .ctors        00000008  00000008  8000cf38  0000d408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .dtors        00000008  00000010  8000cf40  0000d410  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .jcr          00000004  00000018  8000cf48  0000d418  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got          00000000  0000001c  8000cf4c  0000d41c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         00000510  0000001c  8000cf4c  0000d41c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .bss          000002b8  00000548  00000548  00000000  2**2
                  ALLOC
 14 .heap         0000e800  00000800  00000800  00000000  2**0
                  ALLOC
 15 .comment      00000030  00000000  00000000  0000d92c  2**0
                  CONTENTS, READONLY
 16 .debug_aranges 000011b8  00000000  00000000  0000d960  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_pubnames 00002057  00000000  00000000  0000eb18  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_info   0002adad  00000000  00000000  00010b6f  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_abbrev 000060c7  00000000  00000000  0003b91c  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_line   00013342  00000000  00000000  000419e3  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_frame  00003070  00000000  00000000  00054d28  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_str    00005797  00000000  00000000  00057d98  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_loc    0000abc7  00000000  00000000  0005d52f  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_macinfo 011bead6  00000000  00000000  000680f6  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 26 .debug_ranges 00001208  00000000  00000000  01226bcc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	20 28       	sub	r8,2

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

8000200c <_init>:
8000200c:	eb cd 40 40 	pushm	r6,lr
80002010:	48 26       	lddpc	r6,80002018 <_init+0xc>
80002012:	1e 26       	rsub	r6,pc
80002014:	c0 48       	rjmp	8000201c <_init+0x10>
80002016:	d7 03       	nop
80002018:	80 00       	ld.sh	r0,r0[0x0]
8000201a:	1f f6       	ld.ub	r6,pc[0x7]
8000201c:	c5 6c       	rcall	800020c8 <frame_dummy>
8000201e:	e0 a0 52 9b 	rcall	8000c554 <__do_global_ctors_aux>
80002022:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002028 <_stext>:
80002028:	30 07       	mov	r7,0
8000202a:	e0 7a 00 00 	mov	r10,65536
8000202e:	5b fa       	cp.w	r10,-1
80002030:	f4 0d 17 10 	movne	sp,r10
80002034:	49 4b       	lddpc	r11,80002084 <_stext+0x5c>
80002036:	30 8c       	mov	r12,8
80002038:	18 3b       	cp.w	r11,r12
8000203a:	c0 70       	breq	80002048 <_stext+0x20>
8000203c:	e0 6a 05 30 	mov	r10,1328
80002040:	b7 09       	ld.d	r8,r11++
80002042:	b9 28       	st.d	r12++,r8
80002044:	14 3c       	cp.w	r12,r10
80002046:	cf d5       	brlt	80002040 <_stext+0x18>
80002048:	e0 6a 08 00 	mov	r10,2048
8000204c:	e0 6c 05 30 	mov	r12,1328
80002050:	30 08       	mov	r8,0
80002052:	30 09       	mov	r9,0
80002054:	b9 28       	st.d	r12++,r8
80002056:	14 3c       	cp.w	r12,r10
80002058:	cf e5       	brlt	80002054 <_stext+0x2c>
8000205a:	e0 a0 17 91 	rcall	80004f7c <_init_startup>
8000205e:	48 bc       	lddpc	r12,80002088 <_stext+0x60>
80002060:	e0 a0 26 3e 	rcall	80006cdc <atexit>
80002064:	cd 4f       	rcall	8000200c <_init>
80002066:	1a 9c       	mov	r12,sp
80002068:	30 0b       	mov	r11,0
8000206a:	e0 a0 2a c7 	rcall	800075f8 <_init_argv>
8000206e:	5b fc       	cp.w	r12,-1
80002070:	f9 bc 00 00 	moveq	r12,0
80002074:	f9 ba 00 00 	moveq	r10,0
80002078:	14 1d       	sub	sp,r10
8000207a:	e0 a0 0f d7 	rcall	80004028 <main>
8000207e:	e0 a0 26 37 	rcall	80006cec <exit>
80002082:	d7 03       	nop
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	cf 38       	rjmp	8000226c <dip204_init+0x164>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	c8 00       	breq	80001f8a <_trampoline+0x1f82>

8000208c <__do_global_dtors_aux>:
8000208c:	d4 21       	pushm	r4-r7,lr
8000208e:	e0 68 05 48 	mov	r8,1352
80002092:	11 89       	ld.ub	r9,r8[0x0]
80002094:	30 08       	mov	r8,0
80002096:	f0 09 18 00 	cp.b	r9,r8
8000209a:	c1 61       	brne	800020c6 <__do_global_dtors_aux+0x3a>
8000209c:	31 08       	mov	r8,16
8000209e:	31 46       	mov	r6,20
800020a0:	10 95       	mov	r5,r8
800020a2:	10 16       	sub	r6,r8
800020a4:	e0 67 05 4c 	mov	r7,1356
800020a8:	a3 46       	asr	r6,0x2
800020aa:	20 16       	sub	r6,1
800020ac:	c0 68       	rjmp	800020b8 <__do_global_dtors_aux+0x2c>
800020ae:	2f f8       	sub	r8,-1
800020b0:	8f 08       	st.w	r7[0x0],r8
800020b2:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020b6:	5d 18       	icall	r8
800020b8:	6e 08       	ld.w	r8,r7[0x0]
800020ba:	0c 38       	cp.w	r8,r6
800020bc:	cf 93       	brcs	800020ae <__do_global_dtors_aux+0x22>
800020be:	30 19       	mov	r9,1
800020c0:	e0 68 05 48 	mov	r8,1352
800020c4:	b0 89       	st.b	r8[0x0],r9
800020c6:	d8 22       	popm	r4-r7,pc

800020c8 <frame_dummy>:
800020c8:	d4 01       	pushm	lr
800020ca:	31 8c       	mov	r12,24
800020cc:	78 08       	ld.w	r8,r12[0x0]
800020ce:	58 08       	cp.w	r8,0
800020d0:	c0 50       	breq	800020da <frame_dummy+0x12>
800020d2:	48 38       	lddpc	r8,800020dc <frame_dummy+0x14>
800020d4:	58 08       	cp.w	r8,0
800020d6:	c0 20       	breq	800020da <frame_dummy+0x12>
800020d8:	5d 18       	icall	r8
800020da:	d8 02       	popm	pc
800020dc:	00 00       	add	r0,r0
	...

800020e0 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern bool sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
800020e0:	eb cd 40 80 	pushm	r7,lr
800020e4:	1a 97       	mov	r7,sp
	}
#endif

	switch (CONFIG_SYSCLK_SOURCE) {
	case SYSCLK_SRC_RCSYS:
		return OSC_SLOW_NOMINAL_HZ;
800020e6:	e0 78 c2 00 	mov	r8,115200

	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
800020ea:	10 9c       	mov	r12,r8
800020ec:	e3 cd 80 80 	ldm	sp++,r7,pc

800020f0 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
800020f0:	eb cd 40 80 	pushm	r7,lr
800020f4:	1a 97       	mov	r7,sp
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_CPU_DIV;
800020f6:	f0 1f 00 04 	mcall	80002104 <sysclk_get_cpu_hz+0x14>
800020fa:	18 98       	mov	r8,r12
}
800020fc:	10 9c       	mov	r12,r8
800020fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002102:	00 00       	add	r0,r0
80002104:	80 00       	ld.sh	r0,r0[0x0]
80002106:	20 e0       	sub	r0,14

80002108 <dip204_init>:


/****************************** global functions *****************************/

void dip204_init(backlight_options option, bool backlight_on)
{
80002108:	eb cd 40 8f 	pushm	r0-r3,r7,lr
8000210c:	1a 97       	mov	r7,sp
8000210e:	fa cd 01 ac 	sub	sp,sp,428
80002112:	ef 4c fe b8 	st.w	r7[-328],r12
80002116:	16 98       	mov	r8,r11
80002118:	ef 68 fe b4 	st.b	r7[-332],r8
  pwm_opt_t pwm_opt;  // pwm option config

  if (option == backlight_PWM)
8000211c:	ee f8 fe b8 	ld.w	r8,r7[-328]
80002120:	58 18       	cp.w	r8,1
80002122:	c6 41       	brne	800021ea <dip204_init+0xe2>
  {
    channel_id = DIP204_PWM_CHANNEL;
80002124:	fe f9 0a 84 	ld.w	r9,pc[2692]
80002128:	30 68       	mov	r8,6
8000212a:	93 08       	st.w	r9[0x0],r8
    gpio_enable_module_pin(DIP204_PWM_PIN, DIP204_PWM_FUNCTION);
8000212c:	30 2b       	mov	r11,2
8000212e:	33 2c       	mov	r12,50
80002130:	f0 1f 02 9f 	mcall	80002bac <dip204_init+0xaa4>

    // PWM controller configuration
    pwm_opt.diva=0;
80002134:	30 08       	mov	r8,0
80002136:	ef 48 ff 14 	st.w	r7[-236],r8
    pwm_opt.divb=0;
8000213a:	30 08       	mov	r8,0
8000213c:	ef 48 ff 10 	st.w	r7[-240],r8
    pwm_opt.prea=0;
80002140:	30 08       	mov	r8,0
80002142:	ef 48 ff 1c 	st.w	r7[-228],r8
    pwm_opt.preb=0;
80002146:	30 08       	mov	r8,0
80002148:	ef 48 ff 18 	st.w	r7[-232],r8

    pwm_init(&pwm_opt);
8000214c:	ee c8 00 f0 	sub	r8,r7,240
80002150:	10 9c       	mov	r12,r8
80002152:	f0 1f 02 98 	mcall	80002bb0 <dip204_init+0xaa8>
    pwm_duty = (backlight_on) ? DIP204_PERIOD_MAX - 1 : 1;
80002156:	ef 39 fe b4 	ld.ub	r9,r7[-332]
8000215a:	30 08       	mov	r8,0
8000215c:	f0 09 18 00 	cp.b	r9,r8
80002160:	c0 30       	breq	80002166 <dip204_init+0x5e>
80002162:	33 18       	mov	r8,49
80002164:	c0 28       	rjmp	80002168 <dip204_init+0x60>
80002166:	30 18       	mov	r8,1
80002168:	fe f9 0a 4c 	ld.w	r9,pc[2636]
8000216c:	b2 08       	st.h	r9[0x0],r8
    pwm_channel.CMR.calg = PWM_MODE_LEFT_ALIGNED;   // channel mode
8000216e:	fe fa 0a 4a 	ld.w	r10,pc[2634]
80002172:	74 08       	ld.w	r8,r10[0x0]
80002174:	30 09       	mov	r9,0
80002176:	f1 d9 d1 01 	bfins	r8,r9,0x8,0x1
8000217a:	95 08       	st.w	r10[0x0],r8
    pwm_channel.CMR.cpol = PWM_POLARITY_LOW;   // channel polarity
8000217c:	fe fa 0a 3c 	ld.w	r10,pc[2620]
80002180:	74 08       	ld.w	r8,r10[0x0]
80002182:	30 09       	mov	r9,0
80002184:	f1 d9 d1 21 	bfins	r8,r9,0x9,0x1
80002188:	95 08       	st.w	r10[0x0],r8
    pwm_channel.CMR.cpd = PWM_UPDATE_PERIOD;   // not used the first time
8000218a:	fe fa 0a 2e 	ld.w	r10,pc[2606]
8000218e:	74 08       	ld.w	r8,r10[0x0]
80002190:	30 19       	mov	r9,1
80002192:	f1 d9 d1 41 	bfins	r8,r9,0xa,0x1
80002196:	95 08       	st.w	r10[0x0],r8
    pwm_channel.CMR.cpre = AVR32_PWM_CPRE_MCK_DIV_256;   // channel prescaler
80002198:	fe fa 0a 20 	ld.w	r10,pc[2592]
8000219c:	74 08       	ld.w	r8,r10[0x0]
8000219e:	30 89       	mov	r9,8
800021a0:	f1 d9 d0 04 	bfins	r8,r9,0x0,0x4
800021a4:	95 08       	st.w	r10[0x0],r8
    pwm_channel.cdty = pwm_duty;  // channel duty cycle, should be < CPRD
800021a6:	fe f8 0a 0e 	ld.w	r8,pc[2574]
800021aa:	90 08       	ld.sh	r8,r8[0x0]
800021ac:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800021b0:	fe f8 0a 08 	ld.w	r8,pc[2568]
800021b4:	91 19       	st.w	r8[0x4],r9
    pwm_channel.cprd = DIP204_PERIOD_MAX;  // channel period
800021b6:	fe f9 0a 02 	ld.w	r9,pc[2562]
800021ba:	33 28       	mov	r8,50
800021bc:	93 28       	st.w	r9[0x8],r8
    pwm_channel.cupd = 0;  // channel update is not used here.
800021be:	fe f9 09 fa 	ld.w	r9,pc[2554]
800021c2:	30 08       	mov	r8,0
800021c4:	93 48       	st.w	r9[0x10],r8

    pwm_channel_init(channel_id, &pwm_channel);
800021c6:	fe f8 09 e2 	ld.w	r8,pc[2530]
800021ca:	70 08       	ld.w	r8,r8[0x0]
800021cc:	fe fb 09 ec 	ld.w	r11,pc[2540]
800021d0:	10 9c       	mov	r12,r8
800021d2:	f0 1f 02 7b 	mcall	80002bbc <dip204_init+0xab4>
    // start PWM
    pwm_start_channels(1 << channel_id);
800021d6:	fe f8 09 d2 	ld.w	r8,pc[2514]
800021da:	70 09       	ld.w	r9,r8[0x0]
800021dc:	30 18       	mov	r8,1
800021de:	f0 09 09 48 	lsl	r8,r8,r9
800021e2:	10 9c       	mov	r12,r8
800021e4:	f0 1f 02 77 	mcall	80002bc0 <dip204_init+0xab8>
800021e8:	c0 e8       	rjmp	80002204 <dip204_init+0xfc>
  }
  else
  {
    if (backlight_on)
800021ea:	ef 39 fe b4 	ld.ub	r9,r7[-332]
800021ee:	30 08       	mov	r8,0
800021f0:	f0 09 18 00 	cp.b	r9,r8
800021f4:	c0 50       	breq	800021fe <dip204_init+0xf6>
    {
      gpio_clr_gpio_pin(DIP204_BACKLIGHT_PIN);
800021f6:	33 2c       	mov	r12,50
800021f8:	f0 1f 02 73 	mcall	80002bc4 <dip204_init+0xabc>
800021fc:	c0 48       	rjmp	80002204 <dip204_init+0xfc>
    }
    else
    {
      gpio_set_gpio_pin(DIP204_BACKLIGHT_PIN);
800021fe:	33 2c       	mov	r12,50
80002200:	f0 1f 02 72 	mcall	80002bc8 <dip204_init+0xac0>
    }
  }
  // delay for power on
  delay_ms(20);
80002204:	f0 1f 02 72 	mcall	80002bcc <dip204_init+0xac4>
80002208:	18 99       	mov	r9,r12
8000220a:	31 48       	mov	r8,20
8000220c:	ef 48 ff 24 	st.w	r7[-220],r8
80002210:	ef 49 ff 20 	st.w	r7[-224],r9
80002214:	ee f8 ff 24 	ld.w	r8,r7[-220]
80002218:	ef 48 ff 2c 	st.w	r7[-212],r8
8000221c:	ee f8 ff 20 	ld.w	r8,r7[-224]
80002220:	ef 48 ff 28 	st.w	r7[-216],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002224:	ee f0 ff 2c 	ld.w	r0,r7[-212]
80002228:	30 01       	mov	r1,0
8000222a:	ee f2 ff 28 	ld.w	r2,r7[-216]
8000222e:	30 03       	mov	r3,0
80002230:	e2 02 02 49 	mul	r9,r1,r2
80002234:	e6 00 02 48 	mul	r8,r3,r0
80002238:	10 09       	add	r9,r8
8000223a:	e0 02 06 4a 	mulu.d	r10,r0,r2
8000223e:	16 09       	add	r9,r11
80002240:	12 9b       	mov	r11,r9
80002242:	e0 68 03 e7 	mov	r8,999
80002246:	30 09       	mov	r9,0
80002248:	10 0a       	add	r10,r8
8000224a:	f6 09 00 4b 	adc	r11,r11,r9
8000224e:	e0 68 03 e8 	mov	r8,1000
80002252:	30 09       	mov	r9,0
80002254:	f0 1f 02 5f 	mcall	80002bd0 <dip204_init+0xac8>
80002258:	14 98       	mov	r8,r10
8000225a:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000225c:	ef 48 ff 34 	st.w	r7[-204],r8
80002260:	ee c8 01 44 	sub	r8,r7,324
80002264:	ef 48 ff 30 	st.w	r7[-208],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002268:	e1 b8 00 42 	mfsr	r8,0x108
8000226c:	10 99       	mov	r9,r8
8000226e:	ee f8 ff 30 	ld.w	r8,r7[-208]
80002272:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002274:	ee f8 ff 30 	ld.w	r8,r7[-208]
80002278:	70 09       	ld.w	r9,r8[0x0]
8000227a:	ee f8 ff 34 	ld.w	r8,r7[-204]
8000227e:	10 09       	add	r9,r8
80002280:	ee f8 ff 30 	ld.w	r8,r7[-208]
80002284:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002286:	ee f9 ff 30 	ld.w	r9,r7[-208]
8000228a:	30 08       	mov	r8,0
8000228c:	f3 68 00 08 	st.b	r9[8],r8
80002290:	ee c8 01 44 	sub	r8,r7,324
80002294:	ef 48 ff 38 	st.w	r7[-200],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002298:	e1 b8 00 42 	mfsr	r8,0x108
8000229c:	ef 48 ff 3c 	st.w	r7[-196],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800022a0:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022a4:	f1 39 00 08 	ld.ub	r9,r8[8]
800022a8:	30 28       	mov	r8,2
800022aa:	f0 09 18 00 	cp.b	r9,r8
800022ae:	c0 31       	brne	800022b4 <dip204_init+0x1ac>
    return false;
800022b0:	30 08       	mov	r8,0
800022b2:	c4 38       	rjmp	80002338 <dip204_init+0x230>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800022b4:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022b8:	f1 39 00 08 	ld.ub	r9,r8[8]
800022bc:	30 18       	mov	r8,1
800022be:	f0 09 18 00 	cp.b	r9,r8
800022c2:	c0 31       	brne	800022c8 <dip204_init+0x1c0>
    return true;
800022c4:	30 18       	mov	r8,1
800022c6:	c3 98       	rjmp	80002338 <dip204_init+0x230>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800022c8:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022cc:	70 09       	ld.w	r9,r8[0x0]
800022ce:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022d2:	70 18       	ld.w	r8,r8[0x4]
800022d4:	10 39       	cp.w	r9,r8
800022d6:	e0 88 00 1a 	brls	8000230a <dip204_init+0x202>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800022da:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022de:	70 09       	ld.w	r9,r8[0x0]
800022e0:	ee f8 ff 3c 	ld.w	r8,r7[-196]
800022e4:	12 38       	cp.w	r8,r9
800022e6:	c1 02       	brcc	80002306 <dip204_init+0x1fe>
800022e8:	ee f8 ff 38 	ld.w	r8,r7[-200]
800022ec:	70 19       	ld.w	r9,r8[0x4]
800022ee:	ee f8 ff 3c 	ld.w	r8,r7[-196]
800022f2:	12 38       	cp.w	r8,r9
800022f4:	e0 88 00 09 	brls	80002306 <dip204_init+0x1fe>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800022f8:	ee f9 ff 38 	ld.w	r9,r7[-200]
800022fc:	30 18       	mov	r8,1
800022fe:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002302:	30 18       	mov	r8,1
80002304:	c1 a8       	rjmp	80002338 <dip204_init+0x230>
    }
    return false;
80002306:	30 08       	mov	r8,0
80002308:	c1 88       	rjmp	80002338 <dip204_init+0x230>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000230a:	ee f8 ff 38 	ld.w	r8,r7[-200]
8000230e:	70 09       	ld.w	r9,r8[0x0]
80002310:	ee f8 ff 3c 	ld.w	r8,r7[-196]
80002314:	12 38       	cp.w	r8,r9
80002316:	c0 93       	brcs	80002328 <dip204_init+0x220>
80002318:	ee f8 ff 38 	ld.w	r8,r7[-200]
8000231c:	70 19       	ld.w	r9,r8[0x4]
8000231e:	ee f8 ff 3c 	ld.w	r8,r7[-196]
80002322:	12 38       	cp.w	r8,r9
80002324:	e0 88 00 09 	brls	80002336 <dip204_init+0x22e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002328:	ee f9 ff 38 	ld.w	r9,r7[-200]
8000232c:	30 18       	mov	r8,1
8000232e:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002332:	30 18       	mov	r8,1
80002334:	c0 28       	rjmp	80002338 <dip204_init+0x230>
    }
    return false;
80002336:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002338:	58 08       	cp.w	r8,0
8000233a:	ca b0       	breq	80002290 <dip204_init+0x188>
  // select the LCD chip
  dip204_select();
8000233c:	f0 1f 02 26 	mcall	80002bd4 <dip204_init+0xacc>
  // Send Command Start Byte
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002340:	e0 6c 00 f8 	mov	r12,248
80002344:	f0 1f 02 25 	mcall	80002bd8 <dip204_init+0xad0>
  // Send "extended Function Set" Command  (RE=1)
  dip204_write_byte(0x34);
80002348:	33 4c       	mov	r12,52
8000234a:	f0 1f 02 24 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
8000234e:	f0 1f 02 20 	mcall	80002bcc <dip204_init+0xac4>
80002352:	18 99       	mov	r9,r12
80002354:	30 18       	mov	r8,1
80002356:	ef 48 ff 44 	st.w	r7[-188],r8
8000235a:	ef 49 ff 40 	st.w	r7[-192],r9
8000235e:	ee f8 ff 44 	ld.w	r8,r7[-188]
80002362:	ef 48 ff 4c 	st.w	r7[-180],r8
80002366:	ee f8 ff 40 	ld.w	r8,r7[-192]
8000236a:	ef 48 ff 48 	st.w	r7[-184],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000236e:	ee fc ff 4c 	ld.w	r12,r7[-180]
80002372:	ef 4c fe 60 	st.w	r7[-416],r12
80002376:	30 0b       	mov	r11,0
80002378:	ef 4b fe 5c 	st.w	r7[-420],r11
8000237c:	ee fa ff 48 	ld.w	r10,r7[-184]
80002380:	ef 4a fe 58 	st.w	r7[-424],r10
80002384:	30 09       	mov	r9,0
80002386:	ef 49 fe 54 	st.w	r7[-428],r9
8000238a:	ee f9 fe 5c 	ld.w	r9,r7[-420]
8000238e:	ee f8 fe 58 	ld.w	r8,r7[-424]
80002392:	b1 39       	mul	r9,r8
80002394:	ee f8 fe 54 	ld.w	r8,r7[-428]
80002398:	ee fc fe 60 	ld.w	r12,r7[-416]
8000239c:	b9 38       	mul	r8,r12
8000239e:	10 09       	add	r9,r8
800023a0:	ee f8 fe 60 	ld.w	r8,r7[-416]
800023a4:	ee fc fe 58 	ld.w	r12,r7[-424]
800023a8:	f0 0c 06 4a 	mulu.d	r10,r8,r12
800023ac:	16 09       	add	r9,r11
800023ae:	12 9b       	mov	r11,r9
800023b0:	e0 68 03 e7 	mov	r8,999
800023b4:	30 09       	mov	r9,0
800023b6:	10 0a       	add	r10,r8
800023b8:	f6 09 00 4b 	adc	r11,r11,r9
800023bc:	e0 68 03 e8 	mov	r8,1000
800023c0:	30 09       	mov	r9,0
800023c2:	f0 1f 02 04 	mcall	80002bd0 <dip204_init+0xac8>
800023c6:	14 98       	mov	r8,r10
800023c8:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
800023ca:	ef 48 ff 54 	st.w	r7[-172],r8
800023ce:	ee c8 01 38 	sub	r8,r7,312
800023d2:	ef 48 ff 50 	st.w	r7[-176],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800023d6:	e1 b8 00 42 	mfsr	r8,0x108
800023da:	10 99       	mov	r9,r8
800023dc:	ee f8 ff 50 	ld.w	r8,r7[-176]
800023e0:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800023e2:	ee f8 ff 50 	ld.w	r8,r7[-176]
800023e6:	70 09       	ld.w	r9,r8[0x0]
800023e8:	ee f8 ff 54 	ld.w	r8,r7[-172]
800023ec:	10 09       	add	r9,r8
800023ee:	ee f8 ff 50 	ld.w	r8,r7[-176]
800023f2:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800023f4:	ee f9 ff 50 	ld.w	r9,r7[-176]
800023f8:	30 08       	mov	r8,0
800023fa:	f3 68 00 08 	st.b	r9[8],r8
800023fe:	ee c8 01 38 	sub	r8,r7,312
80002402:	ef 48 ff 58 	st.w	r7[-168],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002406:	e1 b8 00 42 	mfsr	r8,0x108
8000240a:	ef 48 ff 5c 	st.w	r7[-164],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000240e:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002412:	f1 39 00 08 	ld.ub	r9,r8[8]
80002416:	30 28       	mov	r8,2
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c0 31       	brne	80002422 <dip204_init+0x31a>
    return false;
8000241e:	30 08       	mov	r8,0
80002420:	c4 38       	rjmp	800024a6 <dip204_init+0x39e>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002422:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002426:	f1 39 00 08 	ld.ub	r9,r8[8]
8000242a:	30 18       	mov	r8,1
8000242c:	f0 09 18 00 	cp.b	r9,r8
80002430:	c0 31       	brne	80002436 <dip204_init+0x32e>
    return true;
80002432:	30 18       	mov	r8,1
80002434:	c3 98       	rjmp	800024a6 <dip204_init+0x39e>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002436:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000243a:	70 09       	ld.w	r9,r8[0x0]
8000243c:	ee f8 ff 58 	ld.w	r8,r7[-168]
80002440:	70 18       	ld.w	r8,r8[0x4]
80002442:	10 39       	cp.w	r9,r8
80002444:	e0 88 00 1a 	brls	80002478 <dip204_init+0x370>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002448:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000244c:	70 09       	ld.w	r9,r8[0x0]
8000244e:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002452:	12 38       	cp.w	r8,r9
80002454:	c1 02       	brcc	80002474 <dip204_init+0x36c>
80002456:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000245a:	70 19       	ld.w	r9,r8[0x4]
8000245c:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002460:	12 38       	cp.w	r8,r9
80002462:	e0 88 00 09 	brls	80002474 <dip204_init+0x36c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002466:	ee f9 ff 58 	ld.w	r9,r7[-168]
8000246a:	30 18       	mov	r8,1
8000246c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002470:	30 18       	mov	r8,1
80002472:	c1 a8       	rjmp	800024a6 <dip204_init+0x39e>
    }
    return false;
80002474:	30 08       	mov	r8,0
80002476:	c1 88       	rjmp	800024a6 <dip204_init+0x39e>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002478:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000247c:	70 09       	ld.w	r9,r8[0x0]
8000247e:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002482:	12 38       	cp.w	r8,r9
80002484:	c0 93       	brcs	80002496 <dip204_init+0x38e>
80002486:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000248a:	70 19       	ld.w	r9,r8[0x4]
8000248c:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80002490:	12 38       	cp.w	r8,r9
80002492:	e0 88 00 09 	brls	800024a4 <dip204_init+0x39c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002496:	ee f9 ff 58 	ld.w	r9,r7[-168]
8000249a:	30 18       	mov	r8,1
8000249c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800024a0:	30 18       	mov	r8,1
800024a2:	c0 28       	rjmp	800024a6 <dip204_init+0x39e>
    }
    return false;
800024a4:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800024a6:	58 08       	cp.w	r8,0
800024a8:	ca b0       	breq	800023fe <dip204_init+0x2f6>
  // Send "Enter 4-Line Mode" Command
  dip204_write_byte(0x09);
800024aa:	30 9c       	mov	r12,9
800024ac:	f0 1f 01 cb 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
800024b0:	f0 1f 01 c7 	mcall	80002bcc <dip204_init+0xac4>
800024b4:	18 99       	mov	r9,r12
800024b6:	30 18       	mov	r8,1
800024b8:	ef 48 ff 64 	st.w	r7[-156],r8
800024bc:	ef 49 ff 60 	st.w	r7[-160],r9
800024c0:	ee f8 ff 64 	ld.w	r8,r7[-156]
800024c4:	ef 48 ff 6c 	st.w	r7[-148],r8
800024c8:	ee f8 ff 60 	ld.w	r8,r7[-160]
800024cc:	ef 48 ff 68 	st.w	r7[-152],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800024d0:	ee fb ff 6c 	ld.w	r11,r7[-148]
800024d4:	ef 4b fe 70 	st.w	r7[-400],r11
800024d8:	30 0a       	mov	r10,0
800024da:	ef 4a fe 6c 	st.w	r7[-404],r10
800024de:	ee f9 ff 68 	ld.w	r9,r7[-152]
800024e2:	ef 49 fe 68 	st.w	r7[-408],r9
800024e6:	30 08       	mov	r8,0
800024e8:	ef 48 fe 64 	st.w	r7[-412],r8
800024ec:	ee f9 fe 6c 	ld.w	r9,r7[-404]
800024f0:	ee fc fe 68 	ld.w	r12,r7[-408]
800024f4:	b9 39       	mul	r9,r12
800024f6:	ee f8 fe 64 	ld.w	r8,r7[-412]
800024fa:	ee fb fe 70 	ld.w	r11,r7[-400]
800024fe:	b7 38       	mul	r8,r11
80002500:	10 09       	add	r9,r8
80002502:	ee f8 fe 70 	ld.w	r8,r7[-400]
80002506:	ee fc fe 68 	ld.w	r12,r7[-408]
8000250a:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000250e:	16 09       	add	r9,r11
80002510:	12 9b       	mov	r11,r9
80002512:	e0 68 03 e7 	mov	r8,999
80002516:	30 09       	mov	r9,0
80002518:	10 0a       	add	r10,r8
8000251a:	f6 09 00 4b 	adc	r11,r11,r9
8000251e:	e0 68 03 e8 	mov	r8,1000
80002522:	30 09       	mov	r9,0
80002524:	f0 1f 01 ab 	mcall	80002bd0 <dip204_init+0xac8>
80002528:	14 98       	mov	r8,r10
8000252a:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000252c:	ef 48 ff 74 	st.w	r7[-140],r8
80002530:	ee c8 01 2c 	sub	r8,r7,300
80002534:	ef 48 ff 70 	st.w	r7[-144],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002538:	e1 b8 00 42 	mfsr	r8,0x108
8000253c:	10 99       	mov	r9,r8
8000253e:	ee f8 ff 70 	ld.w	r8,r7[-144]
80002542:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002544:	ee f8 ff 70 	ld.w	r8,r7[-144]
80002548:	70 09       	ld.w	r9,r8[0x0]
8000254a:	ee f8 ff 74 	ld.w	r8,r7[-140]
8000254e:	10 09       	add	r9,r8
80002550:	ee f8 ff 70 	ld.w	r8,r7[-144]
80002554:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002556:	ee f9 ff 70 	ld.w	r9,r7[-144]
8000255a:	30 08       	mov	r8,0
8000255c:	f3 68 00 08 	st.b	r9[8],r8
80002560:	ee c8 01 2c 	sub	r8,r7,300
80002564:	ef 48 ff 78 	st.w	r7[-136],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002568:	e1 b8 00 42 	mfsr	r8,0x108
8000256c:	ef 48 ff 7c 	st.w	r7[-132],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002570:	ee f8 ff 78 	ld.w	r8,r7[-136]
80002574:	f1 39 00 08 	ld.ub	r9,r8[8]
80002578:	30 28       	mov	r8,2
8000257a:	f0 09 18 00 	cp.b	r9,r8
8000257e:	c0 31       	brne	80002584 <dip204_init+0x47c>
    return false;
80002580:	30 08       	mov	r8,0
80002582:	c4 38       	rjmp	80002608 <dip204_init+0x500>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002584:	ee f8 ff 78 	ld.w	r8,r7[-136]
80002588:	f1 39 00 08 	ld.ub	r9,r8[8]
8000258c:	30 18       	mov	r8,1
8000258e:	f0 09 18 00 	cp.b	r9,r8
80002592:	c0 31       	brne	80002598 <dip204_init+0x490>
    return true;
80002594:	30 18       	mov	r8,1
80002596:	c3 98       	rjmp	80002608 <dip204_init+0x500>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002598:	ee f8 ff 78 	ld.w	r8,r7[-136]
8000259c:	70 09       	ld.w	r9,r8[0x0]
8000259e:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025a2:	70 18       	ld.w	r8,r8[0x4]
800025a4:	10 39       	cp.w	r9,r8
800025a6:	e0 88 00 1a 	brls	800025da <dip204_init+0x4d2>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800025aa:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025ae:	70 09       	ld.w	r9,r8[0x0]
800025b0:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025b4:	12 38       	cp.w	r8,r9
800025b6:	c1 02       	brcc	800025d6 <dip204_init+0x4ce>
800025b8:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025bc:	70 19       	ld.w	r9,r8[0x4]
800025be:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025c2:	12 38       	cp.w	r8,r9
800025c4:	e0 88 00 09 	brls	800025d6 <dip204_init+0x4ce>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800025c8:	ee f9 ff 78 	ld.w	r9,r7[-136]
800025cc:	30 18       	mov	r8,1
800025ce:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800025d2:	30 18       	mov	r8,1
800025d4:	c1 a8       	rjmp	80002608 <dip204_init+0x500>
    }
    return false;
800025d6:	30 08       	mov	r8,0
800025d8:	c1 88       	rjmp	80002608 <dip204_init+0x500>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800025da:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025de:	70 09       	ld.w	r9,r8[0x0]
800025e0:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025e4:	12 38       	cp.w	r8,r9
800025e6:	c0 93       	brcs	800025f8 <dip204_init+0x4f0>
800025e8:	ee f8 ff 78 	ld.w	r8,r7[-136]
800025ec:	70 19       	ld.w	r9,r8[0x4]
800025ee:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800025f2:	12 38       	cp.w	r8,r9
800025f4:	e0 88 00 09 	brls	80002606 <dip204_init+0x4fe>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800025f8:	ee f9 ff 78 	ld.w	r9,r7[-136]
800025fc:	30 18       	mov	r8,1
800025fe:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002602:	30 18       	mov	r8,1
80002604:	c0 28       	rjmp	80002608 <dip204_init+0x500>
    }
    return false;
80002606:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002608:	58 08       	cp.w	r8,0
8000260a:	ca b0       	breq	80002560 <dip204_init+0x458>
  // Send "Function Set" Command (RE=0)
  dip204_write_byte(0x30);
8000260c:	33 0c       	mov	r12,48
8000260e:	f0 1f 01 73 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
80002612:	f0 1f 01 6f 	mcall	80002bcc <dip204_init+0xac4>
80002616:	18 99       	mov	r9,r12
80002618:	30 18       	mov	r8,1
8000261a:	ef 48 ff 84 	st.w	r7[-124],r8
8000261e:	ef 49 ff 80 	st.w	r7[-128],r9
80002622:	ee f8 ff 84 	ld.w	r8,r7[-124]
80002626:	ef 48 ff 8c 	st.w	r7[-116],r8
8000262a:	ee f8 ff 80 	ld.w	r8,r7[-128]
8000262e:	ef 48 ff 88 	st.w	r7[-120],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002632:	ee fb ff 8c 	ld.w	r11,r7[-116]
80002636:	ef 4b fe 80 	st.w	r7[-384],r11
8000263a:	30 0a       	mov	r10,0
8000263c:	ef 4a fe 7c 	st.w	r7[-388],r10
80002640:	ee f9 ff 88 	ld.w	r9,r7[-120]
80002644:	ef 49 fe 78 	st.w	r7[-392],r9
80002648:	30 08       	mov	r8,0
8000264a:	ef 48 fe 74 	st.w	r7[-396],r8
8000264e:	ee f9 fe 7c 	ld.w	r9,r7[-388]
80002652:	ee fc fe 78 	ld.w	r12,r7[-392]
80002656:	b9 39       	mul	r9,r12
80002658:	ee f8 fe 74 	ld.w	r8,r7[-396]
8000265c:	ee fb fe 80 	ld.w	r11,r7[-384]
80002660:	b7 38       	mul	r8,r11
80002662:	10 09       	add	r9,r8
80002664:	ee f8 fe 80 	ld.w	r8,r7[-384]
80002668:	ee fc fe 78 	ld.w	r12,r7[-392]
8000266c:	f0 0c 06 4a 	mulu.d	r10,r8,r12
80002670:	16 09       	add	r9,r11
80002672:	12 9b       	mov	r11,r9
80002674:	e0 68 03 e7 	mov	r8,999
80002678:	30 09       	mov	r9,0
8000267a:	10 0a       	add	r10,r8
8000267c:	f6 09 00 4b 	adc	r11,r11,r9
80002680:	e0 68 03 e8 	mov	r8,1000
80002684:	30 09       	mov	r9,0
80002686:	f0 1f 01 53 	mcall	80002bd0 <dip204_init+0xac8>
8000268a:	14 98       	mov	r8,r10
8000268c:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000268e:	ef 48 ff 94 	st.w	r7[-108],r8
80002692:	ee c8 01 20 	sub	r8,r7,288
80002696:	ef 48 ff 90 	st.w	r7[-112],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000269a:	e1 b8 00 42 	mfsr	r8,0x108
8000269e:	10 99       	mov	r9,r8
800026a0:	ee f8 ff 90 	ld.w	r8,r7[-112]
800026a4:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800026a6:	ee f8 ff 90 	ld.w	r8,r7[-112]
800026aa:	70 09       	ld.w	r9,r8[0x0]
800026ac:	ee f8 ff 94 	ld.w	r8,r7[-108]
800026b0:	10 09       	add	r9,r8
800026b2:	ee f8 ff 90 	ld.w	r8,r7[-112]
800026b6:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800026b8:	ee f9 ff 90 	ld.w	r9,r7[-112]
800026bc:	30 08       	mov	r8,0
800026be:	f3 68 00 08 	st.b	r9[8],r8
800026c2:	ee c8 01 20 	sub	r8,r7,288
800026c6:	ef 48 ff 98 	st.w	r7[-104],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800026ca:	e1 b8 00 42 	mfsr	r8,0x108
800026ce:	ef 48 ff 9c 	st.w	r7[-100],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800026d2:	ee f8 ff 98 	ld.w	r8,r7[-104]
800026d6:	f1 39 00 08 	ld.ub	r9,r8[8]
800026da:	30 28       	mov	r8,2
800026dc:	f0 09 18 00 	cp.b	r9,r8
800026e0:	c0 31       	brne	800026e6 <dip204_init+0x5de>
    return false;
800026e2:	30 08       	mov	r8,0
800026e4:	c4 38       	rjmp	8000276a <dip204_init+0x662>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800026e6:	ee f8 ff 98 	ld.w	r8,r7[-104]
800026ea:	f1 39 00 08 	ld.ub	r9,r8[8]
800026ee:	30 18       	mov	r8,1
800026f0:	f0 09 18 00 	cp.b	r9,r8
800026f4:	c0 31       	brne	800026fa <dip204_init+0x5f2>
    return true;
800026f6:	30 18       	mov	r8,1
800026f8:	c3 98       	rjmp	8000276a <dip204_init+0x662>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800026fa:	ee f8 ff 98 	ld.w	r8,r7[-104]
800026fe:	70 09       	ld.w	r9,r8[0x0]
80002700:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002704:	70 18       	ld.w	r8,r8[0x4]
80002706:	10 39       	cp.w	r9,r8
80002708:	e0 88 00 1a 	brls	8000273c <dip204_init+0x634>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000270c:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002710:	70 08       	ld.w	r8,r8[0x0]
80002712:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002716:	10 39       	cp.w	r9,r8
80002718:	c1 02       	brcc	80002738 <dip204_init+0x630>
8000271a:	ee f8 ff 98 	ld.w	r8,r7[-104]
8000271e:	70 18       	ld.w	r8,r8[0x4]
80002720:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002724:	10 39       	cp.w	r9,r8
80002726:	e0 88 00 09 	brls	80002738 <dip204_init+0x630>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000272a:	ee f9 ff 98 	ld.w	r9,r7[-104]
8000272e:	30 18       	mov	r8,1
80002730:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002734:	30 18       	mov	r8,1
80002736:	c1 a8       	rjmp	8000276a <dip204_init+0x662>
    }
    return false;
80002738:	30 08       	mov	r8,0
8000273a:	c1 88       	rjmp	8000276a <dip204_init+0x662>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000273c:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002740:	70 08       	ld.w	r8,r8[0x0]
80002742:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002746:	10 39       	cp.w	r9,r8
80002748:	c0 93       	brcs	8000275a <dip204_init+0x652>
8000274a:	ee f8 ff 98 	ld.w	r8,r7[-104]
8000274e:	70 18       	ld.w	r8,r8[0x4]
80002750:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002754:	10 39       	cp.w	r9,r8
80002756:	e0 88 00 09 	brls	80002768 <dip204_init+0x660>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000275a:	ee f9 ff 98 	ld.w	r9,r7[-104]
8000275e:	30 18       	mov	r8,1
80002760:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002764:	30 18       	mov	r8,1
80002766:	c0 28       	rjmp	8000276a <dip204_init+0x662>
    }
    return false;
80002768:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
8000276a:	58 08       	cp.w	r8,0
8000276c:	ca b0       	breq	800026c2 <dip204_init+0x5ba>
  // Send "Display On Command: Display On, Cursor On, Blink On"
  dip204_write_byte(0x0F);
8000276e:	30 fc       	mov	r12,15
80002770:	f0 1f 01 1a 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
80002774:	f0 1f 01 16 	mcall	80002bcc <dip204_init+0xac4>
80002778:	18 98       	mov	r8,r12
8000277a:	30 19       	mov	r9,1
8000277c:	ef 49 ff a4 	st.w	r7[-92],r9
80002780:	ef 48 ff a0 	st.w	r7[-96],r8
80002784:	ee f8 ff a4 	ld.w	r8,r7[-92]
80002788:	ef 48 ff ac 	st.w	r7[-84],r8
8000278c:	ee f8 ff a0 	ld.w	r8,r7[-96]
80002790:	ef 48 ff a8 	st.w	r7[-88],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002794:	ee fb ff ac 	ld.w	r11,r7[-84]
80002798:	ef 4b fe 90 	st.w	r7[-368],r11
8000279c:	30 0a       	mov	r10,0
8000279e:	ef 4a fe 8c 	st.w	r7[-372],r10
800027a2:	ee f9 ff a8 	ld.w	r9,r7[-88]
800027a6:	ef 49 fe 88 	st.w	r7[-376],r9
800027aa:	30 08       	mov	r8,0
800027ac:	ef 48 fe 84 	st.w	r7[-380],r8
800027b0:	ee fa fe 8c 	ld.w	r10,r7[-372]
800027b4:	ee fc fe 88 	ld.w	r12,r7[-376]
800027b8:	b9 3a       	mul	r10,r12
800027ba:	ee f8 fe 84 	ld.w	r8,r7[-380]
800027be:	ee fb fe 90 	ld.w	r11,r7[-368]
800027c2:	b7 38       	mul	r8,r11
800027c4:	10 0a       	add	r10,r8
800027c6:	ee fc fe 90 	ld.w	r12,r7[-368]
800027ca:	ee fb fe 88 	ld.w	r11,r7[-376]
800027ce:	f8 0b 06 48 	mulu.d	r8,r12,r11
800027d2:	12 0a       	add	r10,r9
800027d4:	14 99       	mov	r9,r10
800027d6:	e0 6a 03 e7 	mov	r10,999
800027da:	30 0b       	mov	r11,0
800027dc:	f0 0a 00 0a 	add	r10,r8,r10
800027e0:	f2 0b 00 4b 	adc	r11,r9,r11
800027e4:	e0 68 03 e8 	mov	r8,1000
800027e8:	30 09       	mov	r9,0
800027ea:	f0 1f 00 fa 	mcall	80002bd0 <dip204_init+0xac8>
800027ee:	14 98       	mov	r8,r10
800027f0:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
800027f2:	ef 48 ff b4 	st.w	r7[-76],r8
800027f6:	ee c8 01 14 	sub	r8,r7,276
800027fa:	ef 48 ff b0 	st.w	r7[-80],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800027fe:	e1 b8 00 42 	mfsr	r8,0x108
80002802:	10 99       	mov	r9,r8
80002804:	ee f8 ff b0 	ld.w	r8,r7[-80]
80002808:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000280a:	ee f8 ff b0 	ld.w	r8,r7[-80]
8000280e:	70 09       	ld.w	r9,r8[0x0]
80002810:	ee f8 ff b4 	ld.w	r8,r7[-76]
80002814:	10 09       	add	r9,r8
80002816:	ee f8 ff b0 	ld.w	r8,r7[-80]
8000281a:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000281c:	ee f9 ff b0 	ld.w	r9,r7[-80]
80002820:	30 08       	mov	r8,0
80002822:	f3 68 00 08 	st.b	r9[8],r8
80002826:	ee c8 01 14 	sub	r8,r7,276
8000282a:	ef 48 ff b8 	st.w	r7[-72],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000282e:	e1 b8 00 42 	mfsr	r8,0x108
80002832:	ef 48 ff bc 	st.w	r7[-68],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002836:	ee f8 ff b8 	ld.w	r8,r7[-72]
8000283a:	f1 39 00 08 	ld.ub	r9,r8[8]
8000283e:	30 28       	mov	r8,2
80002840:	f0 09 18 00 	cp.b	r9,r8
80002844:	c0 31       	brne	8000284a <dip204_init+0x742>
    return false;
80002846:	30 08       	mov	r8,0
80002848:	c4 38       	rjmp	800028ce <dip204_init+0x7c6>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
8000284a:	ee f8 ff b8 	ld.w	r8,r7[-72]
8000284e:	f1 39 00 08 	ld.ub	r9,r8[8]
80002852:	30 18       	mov	r8,1
80002854:	f0 09 18 00 	cp.b	r9,r8
80002858:	c0 31       	brne	8000285e <dip204_init+0x756>
    return true;
8000285a:	30 18       	mov	r8,1
8000285c:	c3 98       	rjmp	800028ce <dip204_init+0x7c6>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000285e:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002862:	70 09       	ld.w	r9,r8[0x0]
80002864:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002868:	70 18       	ld.w	r8,r8[0x4]
8000286a:	10 39       	cp.w	r9,r8
8000286c:	e0 88 00 1a 	brls	800028a0 <dip204_init+0x798>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002870:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002874:	70 08       	ld.w	r8,r8[0x0]
80002876:	ee f9 ff bc 	ld.w	r9,r7[-68]
8000287a:	10 39       	cp.w	r9,r8
8000287c:	c1 02       	brcc	8000289c <dip204_init+0x794>
8000287e:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002882:	70 18       	ld.w	r8,r8[0x4]
80002884:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002888:	10 39       	cp.w	r9,r8
8000288a:	e0 88 00 09 	brls	8000289c <dip204_init+0x794>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000288e:	ee f9 ff b8 	ld.w	r9,r7[-72]
80002892:	30 18       	mov	r8,1
80002894:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002898:	30 18       	mov	r8,1
8000289a:	c1 a8       	rjmp	800028ce <dip204_init+0x7c6>
    }
    return false;
8000289c:	30 08       	mov	r8,0
8000289e:	c1 88       	rjmp	800028ce <dip204_init+0x7c6>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800028a0:	ee f8 ff b8 	ld.w	r8,r7[-72]
800028a4:	70 08       	ld.w	r8,r8[0x0]
800028a6:	ee f9 ff bc 	ld.w	r9,r7[-68]
800028aa:	10 39       	cp.w	r9,r8
800028ac:	c0 93       	brcs	800028be <dip204_init+0x7b6>
800028ae:	ee f8 ff b8 	ld.w	r8,r7[-72]
800028b2:	70 18       	ld.w	r8,r8[0x4]
800028b4:	ee f9 ff bc 	ld.w	r9,r7[-68]
800028b8:	10 39       	cp.w	r9,r8
800028ba:	e0 88 00 09 	brls	800028cc <dip204_init+0x7c4>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800028be:	ee f9 ff b8 	ld.w	r9,r7[-72]
800028c2:	30 18       	mov	r8,1
800028c4:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800028c8:	30 18       	mov	r8,1
800028ca:	c0 28       	rjmp	800028ce <dip204_init+0x7c6>
    }
    return false;
800028cc:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800028ce:	58 08       	cp.w	r8,0
800028d0:	ca b0       	breq	80002826 <dip204_init+0x71e>
  // Send "Display Clear" Command
  dip204_write_byte(0x01);
800028d2:	30 1c       	mov	r12,1
800028d4:	f0 1f 00 c1 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(5);
800028d8:	f0 1f 00 bd 	mcall	80002bcc <dip204_init+0xac4>
800028dc:	18 98       	mov	r8,r12
800028de:	30 59       	mov	r9,5
800028e0:	ef 49 ff c4 	st.w	r7[-60],r9
800028e4:	ef 48 ff c0 	st.w	r7[-64],r8
800028e8:	ee f8 ff c4 	ld.w	r8,r7[-60]
800028ec:	ef 48 ff cc 	st.w	r7[-52],r8
800028f0:	ee f8 ff c0 	ld.w	r8,r7[-64]
800028f4:	ef 48 ff c8 	st.w	r7[-56],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800028f8:	ee fa ff cc 	ld.w	r10,r7[-52]
800028fc:	ef 4a fe a0 	st.w	r7[-352],r10
80002900:	30 09       	mov	r9,0
80002902:	ef 49 fe 9c 	st.w	r7[-356],r9
80002906:	ee f8 ff c8 	ld.w	r8,r7[-56]
8000290a:	ef 48 fe 98 	st.w	r7[-360],r8
8000290e:	30 0c       	mov	r12,0
80002910:	ef 4c fe 94 	st.w	r7[-364],r12
80002914:	ee fa fe 9c 	ld.w	r10,r7[-356]
80002918:	ee fb fe 98 	ld.w	r11,r7[-360]
8000291c:	b7 3a       	mul	r10,r11
8000291e:	ee f8 fe 94 	ld.w	r8,r7[-364]
80002922:	ee f9 fe a0 	ld.w	r9,r7[-352]
80002926:	b3 38       	mul	r8,r9
80002928:	10 0a       	add	r10,r8
8000292a:	ee fc fe a0 	ld.w	r12,r7[-352]
8000292e:	ee fb fe 98 	ld.w	r11,r7[-360]
80002932:	f8 0b 06 48 	mulu.d	r8,r12,r11
80002936:	12 0a       	add	r10,r9
80002938:	14 99       	mov	r9,r10
8000293a:	e0 6a 03 e7 	mov	r10,999
8000293e:	30 0b       	mov	r11,0
80002940:	f0 0a 00 0a 	add	r10,r8,r10
80002944:	f2 0b 00 4b 	adc	r11,r9,r11
80002948:	e0 68 03 e8 	mov	r8,1000
8000294c:	30 09       	mov	r9,0
8000294e:	f0 1f 00 a1 	mcall	80002bd0 <dip204_init+0xac8>
80002952:	14 98       	mov	r8,r10
80002954:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002956:	ef 48 ff d4 	st.w	r7[-44],r8
8000295a:	ee c8 01 08 	sub	r8,r7,264
8000295e:	ef 48 ff d0 	st.w	r7[-48],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002962:	e1 b8 00 42 	mfsr	r8,0x108
80002966:	10 99       	mov	r9,r8
80002968:	ee f8 ff d0 	ld.w	r8,r7[-48]
8000296c:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000296e:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002972:	70 09       	ld.w	r9,r8[0x0]
80002974:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002978:	10 09       	add	r9,r8
8000297a:	ee f8 ff d0 	ld.w	r8,r7[-48]
8000297e:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002980:	ee f9 ff d0 	ld.w	r9,r7[-48]
80002984:	30 08       	mov	r8,0
80002986:	f3 68 00 08 	st.b	r9[8],r8
8000298a:	ee c8 01 08 	sub	r8,r7,264
8000298e:	ef 48 ff d8 	st.w	r7[-40],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002992:	e1 b8 00 42 	mfsr	r8,0x108
80002996:	ef 48 ff dc 	st.w	r7[-36],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000299a:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000299e:	f1 39 00 08 	ld.ub	r9,r8[8]
800029a2:	30 28       	mov	r8,2
800029a4:	f0 09 18 00 	cp.b	r9,r8
800029a8:	c0 31       	brne	800029ae <dip204_init+0x8a6>
    return false;
800029aa:	30 08       	mov	r8,0
800029ac:	c4 38       	rjmp	80002a32 <dip204_init+0x92a>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800029ae:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029b2:	f1 39 00 08 	ld.ub	r9,r8[8]
800029b6:	30 18       	mov	r8,1
800029b8:	f0 09 18 00 	cp.b	r9,r8
800029bc:	c0 31       	brne	800029c2 <dip204_init+0x8ba>
    return true;
800029be:	30 18       	mov	r8,1
800029c0:	c3 98       	rjmp	80002a32 <dip204_init+0x92a>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800029c2:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029c6:	70 09       	ld.w	r9,r8[0x0]
800029c8:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029cc:	70 18       	ld.w	r8,r8[0x4]
800029ce:	10 39       	cp.w	r9,r8
800029d0:	e0 88 00 1a 	brls	80002a04 <dip204_init+0x8fc>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800029d4:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029d8:	70 08       	ld.w	r8,r8[0x0]
800029da:	ee f9 ff dc 	ld.w	r9,r7[-36]
800029de:	10 39       	cp.w	r9,r8
800029e0:	c1 02       	brcc	80002a00 <dip204_init+0x8f8>
800029e2:	ee f8 ff d8 	ld.w	r8,r7[-40]
800029e6:	70 18       	ld.w	r8,r8[0x4]
800029e8:	ee f9 ff dc 	ld.w	r9,r7[-36]
800029ec:	10 39       	cp.w	r9,r8
800029ee:	e0 88 00 09 	brls	80002a00 <dip204_init+0x8f8>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800029f2:	ee f9 ff d8 	ld.w	r9,r7[-40]
800029f6:	30 18       	mov	r8,1
800029f8:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800029fc:	30 18       	mov	r8,1
800029fe:	c1 a8       	rjmp	80002a32 <dip204_init+0x92a>
    }
    return false;
80002a00:	30 08       	mov	r8,0
80002a02:	c1 88       	rjmp	80002a32 <dip204_init+0x92a>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002a04:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002a08:	70 08       	ld.w	r8,r8[0x0]
80002a0a:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002a0e:	10 39       	cp.w	r9,r8
80002a10:	c0 93       	brcs	80002a22 <dip204_init+0x91a>
80002a12:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002a16:	70 18       	ld.w	r8,r8[0x4]
80002a18:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002a1c:	10 39       	cp.w	r9,r8
80002a1e:	e0 88 00 09 	brls	80002a30 <dip204_init+0x928>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002a22:	ee f9 ff d8 	ld.w	r9,r7[-40]
80002a26:	30 18       	mov	r8,1
80002a28:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002a2c:	30 18       	mov	r8,1
80002a2e:	c0 28       	rjmp	80002a32 <dip204_init+0x92a>
    }
    return false;
80002a30:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002a32:	58 08       	cp.w	r8,0
80002a34:	ca b0       	breq	8000298a <dip204_init+0x882>
  // Send "Entry Mode Set Command: Increment Mode, Entire Shift off"
  dip204_write_byte(0x06);
80002a36:	30 6c       	mov	r12,6
80002a38:	f0 1f 00 68 	mcall	80002bd8 <dip204_init+0xad0>
  // Wait for command execution
  delay_ms(1);
80002a3c:	f0 1f 00 64 	mcall	80002bcc <dip204_init+0xac4>
80002a40:	18 98       	mov	r8,r12
80002a42:	30 19       	mov	r9,1
80002a44:	ef 49 ff e4 	st.w	r7[-28],r9
80002a48:	ef 48 ff e0 	st.w	r7[-32],r8
80002a4c:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002a50:	ef 48 ff ec 	st.w	r7[-20],r8
80002a54:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002a58:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002a5c:	ee fa ff ec 	ld.w	r10,r7[-20]
80002a60:	ef 4a fe b0 	st.w	r7[-336],r10
80002a64:	30 09       	mov	r9,0
80002a66:	ef 49 fe ac 	st.w	r7[-340],r9
80002a6a:	ee f8 ff e8 	ld.w	r8,r7[-24]
80002a6e:	ef 48 fe a8 	st.w	r7[-344],r8
80002a72:	30 0c       	mov	r12,0
80002a74:	ef 4c fe a4 	st.w	r7[-348],r12
80002a78:	ee fa fe ac 	ld.w	r10,r7[-340]
80002a7c:	ee fb fe a8 	ld.w	r11,r7[-344]
80002a80:	b7 3a       	mul	r10,r11
80002a82:	ee f8 fe a4 	ld.w	r8,r7[-348]
80002a86:	ee f9 fe b0 	ld.w	r9,r7[-336]
80002a8a:	b3 38       	mul	r8,r9
80002a8c:	10 0a       	add	r10,r8
80002a8e:	ee fc fe b0 	ld.w	r12,r7[-336]
80002a92:	ee fb fe a8 	ld.w	r11,r7[-344]
80002a96:	f8 0b 06 48 	mulu.d	r8,r12,r11
80002a9a:	12 0a       	add	r10,r9
80002a9c:	14 99       	mov	r9,r10
80002a9e:	e0 6a 03 e7 	mov	r10,999
80002aa2:	30 0b       	mov	r11,0
80002aa4:	f0 0a 00 0a 	add	r10,r8,r10
80002aa8:	f2 0b 00 4b 	adc	r11,r9,r11
80002aac:	e0 68 03 e8 	mov	r8,1000
80002ab0:	30 09       	mov	r9,0
80002ab2:	f0 1f 00 48 	mcall	80002bd0 <dip204_init+0xac8>
80002ab6:	14 98       	mov	r8,r10
80002ab8:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002aba:	ef 48 ff f4 	st.w	r7[-12],r8
80002abe:	ee c8 00 fc 	sub	r8,r7,252
80002ac2:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002ac6:	e1 b8 00 42 	mfsr	r8,0x108
80002aca:	10 99       	mov	r9,r8
80002acc:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ad0:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002ad2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ad6:	70 09       	ld.w	r9,r8[0x0]
80002ad8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002adc:	10 09       	add	r9,r8
80002ade:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ae2:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002ae4:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002ae8:	30 08       	mov	r8,0
80002aea:	f3 68 00 08 	st.b	r9[8],r8
80002aee:	ee c8 00 fc 	sub	r8,r7,252
80002af2:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002af6:	e1 b8 00 42 	mfsr	r8,0x108
80002afa:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002afe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b02:	f1 39 00 08 	ld.ub	r9,r8[8]
80002b06:	30 28       	mov	r8,2
80002b08:	f0 09 18 00 	cp.b	r9,r8
80002b0c:	c0 31       	brne	80002b12 <dip204_init+0xa0a>
    return false;
80002b0e:	30 08       	mov	r8,0
80002b10:	c4 38       	rjmp	80002b96 <dip204_init+0xa8e>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002b12:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b16:	f1 39 00 08 	ld.ub	r9,r8[8]
80002b1a:	30 18       	mov	r8,1
80002b1c:	f0 09 18 00 	cp.b	r9,r8
80002b20:	c0 31       	brne	80002b26 <dip204_init+0xa1e>
    return true;
80002b22:	30 18       	mov	r8,1
80002b24:	c3 98       	rjmp	80002b96 <dip204_init+0xa8e>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002b26:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b2a:	70 09       	ld.w	r9,r8[0x0]
80002b2c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b30:	70 18       	ld.w	r8,r8[0x4]
80002b32:	10 39       	cp.w	r9,r8
80002b34:	e0 88 00 1a 	brls	80002b68 <dip204_init+0xa60>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002b38:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b3c:	70 08       	ld.w	r8,r8[0x0]
80002b3e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b42:	10 39       	cp.w	r9,r8
80002b44:	c1 02       	brcc	80002b64 <dip204_init+0xa5c>
80002b46:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b4a:	70 18       	ld.w	r8,r8[0x4]
80002b4c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b50:	10 39       	cp.w	r9,r8
80002b52:	e0 88 00 09 	brls	80002b64 <dip204_init+0xa5c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002b56:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002b5a:	30 18       	mov	r8,1
80002b5c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002b60:	30 18       	mov	r8,1
80002b62:	c1 a8       	rjmp	80002b96 <dip204_init+0xa8e>
    }
    return false;
80002b64:	30 08       	mov	r8,0
80002b66:	c1 88       	rjmp	80002b96 <dip204_init+0xa8e>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002b68:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b6c:	70 08       	ld.w	r8,r8[0x0]
80002b6e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b72:	10 39       	cp.w	r9,r8
80002b74:	c0 93       	brcs	80002b86 <dip204_init+0xa7e>
80002b76:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b7a:	70 18       	ld.w	r8,r8[0x4]
80002b7c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002b80:	10 39       	cp.w	r9,r8
80002b82:	e0 88 00 09 	brls	80002b94 <dip204_init+0xa8c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002b86:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002b8a:	30 18       	mov	r8,1
80002b8c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002b90:	30 18       	mov	r8,1
80002b92:	c0 28       	rjmp	80002b96 <dip204_init+0xa8e>
    }
    return false;
80002b94:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002b96:	58 08       	cp.w	r8,0
80002b98:	ca b0       	breq	80002aee <dip204_init+0x9e6>
  dip204_wait_busy();
80002b9a:	f0 1f 00 11 	mcall	80002bdc <dip204_init+0xad4>
  // unselect chip
  dip204_unselect();
80002b9e:	f0 1f 00 11 	mcall	80002be0 <dip204_init+0xad8>
}
80002ba2:	29 5d       	sub	sp,-428
80002ba4:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
80002ba8:	00 00       	add	r0,r0
80002baa:	00 1c       	sub	r12,r0
80002bac:	80 00       	ld.sh	r0,r0[0x0]
80002bae:	43 88       	lddsp	r8,sp[0xe0]
80002bb0:	80 00       	ld.sh	r0,r0[0x0]
80002bb2:	31 48       	mov	r8,20
80002bb4:	00 00       	add	r0,r0
80002bb6:	05 50       	ld.sh	r0,--r2
80002bb8:	00 00       	add	r0,r0
80002bba:	05 54       	ld.sh	r4,--r2
80002bbc:	80 00       	ld.sh	r0,r0[0x0]
80002bbe:	31 dc       	mov	r12,29
80002bc0:	80 00       	ld.sh	r0,r0[0x0]
80002bc2:	32 64       	mov	r4,38
80002bc4:	80 00       	ld.sh	r0,r0[0x0]
80002bc6:	45 00       	lddsp	r0,sp[0x140]
80002bc8:	80 00       	ld.sh	r0,r0[0x0]
80002bca:	44 98       	lddsp	r8,sp[0x124]
80002bcc:	80 00       	ld.sh	r0,r0[0x0]
80002bce:	20 f0       	sub	r0,15
80002bd0:	80 00       	ld.sh	r0,r0[0x0]
80002bd2:	6a 78       	ld.w	r8,r5[0x1c]
80002bd4:	80 00       	ld.sh	r0,r0[0x0]
80002bd6:	2e e0       	sub	r0,-18
80002bd8:	80 00       	ld.sh	r0,r0[0x0]
80002bda:	2f 10       	sub	r0,-15
80002bdc:	80 00       	ld.sh	r0,r0[0x0]
80002bde:	2f f4       	sub	r4,-1
80002be0:	80 00       	ld.sh	r0,r0[0x0]
80002be2:	2e f8       	sub	r8,-17

80002be4 <dip204_hide_cursor>:
  dip204_unselect();
}


void dip204_hide_cursor(void)
{
80002be4:	eb cd 40 80 	pushm	r7,lr
80002be8:	1a 97       	mov	r7,sp
  /* select the LCD chip */
  dip204_select();
80002bea:	f0 1f 00 08 	mcall	80002c08 <dip204_hide_cursor+0x24>
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002bee:	e0 6c 00 f8 	mov	r12,248
80002bf2:	f0 1f 00 07 	mcall	80002c0c <dip204_hide_cursor+0x28>
  /* Send "Display On Command: Display On, Cursor On, Blink On" */
  dip204_write_byte(0x0C);
80002bf6:	30 cc       	mov	r12,12
80002bf8:	f0 1f 00 05 	mcall	80002c0c <dip204_hide_cursor+0x28>
  dip204_wait_busy();
80002bfc:	f0 1f 00 05 	mcall	80002c10 <dip204_hide_cursor+0x2c>
  /* unselect chip */
  dip204_unselect();
80002c00:	f0 1f 00 05 	mcall	80002c14 <dip204_hide_cursor+0x30>
}
80002c04:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c08:	80 00       	ld.sh	r0,r0[0x0]
80002c0a:	2e e0       	sub	r0,-18
80002c0c:	80 00       	ld.sh	r0,r0[0x0]
80002c0e:	2f 10       	sub	r0,-15
80002c10:	80 00       	ld.sh	r0,r0[0x0]
80002c12:	2f f4       	sub	r4,-1
80002c14:	80 00       	ld.sh	r0,r0[0x0]
80002c16:	2e f8       	sub	r8,-17

80002c18 <dip204_set_cursor_position>:
  dip204_set_cursor_position(column, line);
}


void dip204_set_cursor_position(unsigned char column, unsigned char line)
{
80002c18:	eb cd 40 80 	pushm	r7,lr
80002c1c:	1a 97       	mov	r7,sp
80002c1e:	20 3d       	sub	sp,12
80002c20:	18 99       	mov	r9,r12
80002c22:	16 98       	mov	r8,r11
80002c24:	ef 69 ff f8 	st.b	r7[-8],r9
80002c28:	ef 68 ff f4 	st.b	r7[-12],r8
  unsigned char address = 0;
80002c2c:	30 08       	mov	r8,0
80002c2e:	ef 68 ff ff 	st.b	r7[-1],r8

  dip204_select();
80002c32:	f0 1f 00 18 	mcall	80002c90 <dip204_set_cursor_position+0x78>
  if ((column <= 20) && (line <= 4))
80002c36:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80002c3a:	31 48       	mov	r8,20
80002c3c:	f0 09 18 00 	cp.b	r9,r8
80002c40:	e0 8b 00 17 	brhi	80002c6e <dip204_set_cursor_position+0x56>
80002c44:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80002c48:	30 48       	mov	r8,4
80002c4a:	f0 09 18 00 	cp.b	r9,r8
80002c4e:	e0 8b 00 10 	brhi	80002c6e <dip204_set_cursor_position+0x56>
  {
    /* Calculate DDRAM address from line and row values */
    address = ( (line-1) * 32 ) + ( column-1 ) + 128;
80002c52:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002c56:	20 18       	sub	r8,1
80002c58:	5c 58       	castu.b	r8
80002c5a:	a5 78       	lsl	r8,0x5
80002c5c:	5c 58       	castu.b	r8
80002c5e:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80002c62:	f2 08 00 08 	add	r8,r9,r8
80002c66:	5c 58       	castu.b	r8
80002c68:	28 18       	sub	r8,-127
80002c6a:	ef 68 ff ff 	st.b	r7[-1],r8
  }
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002c6e:	e0 6c 00 f8 	mov	r12,248
80002c72:	f0 1f 00 09 	mcall	80002c94 <dip204_set_cursor_position+0x7c>
  /* Send Address lower Nibble */
  dip204_write_byte(address);
80002c76:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002c7a:	10 9c       	mov	r12,r8
80002c7c:	f0 1f 00 06 	mcall	80002c94 <dip204_set_cursor_position+0x7c>
  dip204_wait_busy();
80002c80:	f0 1f 00 06 	mcall	80002c98 <dip204_set_cursor_position+0x80>
  dip204_unselect();
80002c84:	f0 1f 00 06 	mcall	80002c9c <dip204_set_cursor_position+0x84>
}
80002c88:	2f dd       	sub	sp,-12
80002c8a:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c8e:	00 00       	add	r0,r0
80002c90:	80 00       	ld.sh	r0,r0[0x0]
80002c92:	2e e0       	sub	r0,-18
80002c94:	80 00       	ld.sh	r0,r0[0x0]
80002c96:	2f 10       	sub	r0,-15
80002c98:	80 00       	ld.sh	r0,r0[0x0]
80002c9a:	2f f4       	sub	r4,-1
80002c9c:	80 00       	ld.sh	r0,r0[0x0]
80002c9e:	2e f8       	sub	r8,-17

80002ca0 <dip204_clear_display>:


void dip204_clear_display(void)
{
80002ca0:	eb cd 40 8f 	pushm	r0-r3,r7,lr
80002ca4:	1a 97       	mov	r7,sp
80002ca6:	20 bd       	sub	sp,44
  dip204_select();
80002ca8:	f0 1f 00 57 	mcall	80002e04 <dip204_clear_display+0x164>
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002cac:	e0 6c 00 f8 	mov	r12,248
80002cb0:	f0 1f 00 56 	mcall	80002e08 <dip204_clear_display+0x168>
  /* Send Display Clear Command */
  dip204_write_byte(0x01);
80002cb4:	30 1c       	mov	r12,1
80002cb6:	f0 1f 00 55 	mcall	80002e08 <dip204_clear_display+0x168>
  /* Wait for command execution */
  delay_ms(4);
80002cba:	f0 1f 00 55 	mcall	80002e0c <dip204_clear_display+0x16c>
80002cbe:	18 98       	mov	r8,r12
80002cc0:	30 49       	mov	r9,4
80002cc2:	ef 49 ff e4 	st.w	r7[-28],r9
80002cc6:	ef 48 ff e0 	st.w	r7[-32],r8
80002cca:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002cce:	ef 48 ff ec 	st.w	r7[-20],r8
80002cd2:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002cd6:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002cda:	ee f0 ff ec 	ld.w	r0,r7[-20]
80002cde:	30 01       	mov	r1,0
80002ce0:	ee f2 ff e8 	ld.w	r2,r7[-24]
80002ce4:	30 03       	mov	r3,0
80002ce6:	e2 02 02 4a 	mul	r10,r1,r2
80002cea:	e6 00 02 48 	mul	r8,r3,r0
80002cee:	10 0a       	add	r10,r8
80002cf0:	e0 02 06 48 	mulu.d	r8,r0,r2
80002cf4:	12 0a       	add	r10,r9
80002cf6:	14 99       	mov	r9,r10
80002cf8:	e0 6a 03 e7 	mov	r10,999
80002cfc:	30 0b       	mov	r11,0
80002cfe:	f0 0a 00 0a 	add	r10,r8,r10
80002d02:	f2 0b 00 4b 	adc	r11,r9,r11
80002d06:	e0 68 03 e8 	mov	r8,1000
80002d0a:	30 09       	mov	r9,0
80002d0c:	f0 1f 00 41 	mcall	80002e10 <dip204_clear_display+0x170>
80002d10:	14 98       	mov	r8,r10
80002d12:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80002d14:	ef 48 ff f4 	st.w	r7[-12],r8
80002d18:	ee c8 00 2c 	sub	r8,r7,44
80002d1c:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002d20:	e1 b8 00 42 	mfsr	r8,0x108
80002d24:	10 99       	mov	r9,r8
80002d26:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d2a:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002d2c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d30:	70 09       	ld.w	r9,r8[0x0]
80002d32:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002d36:	10 09       	add	r9,r8
80002d38:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d3c:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002d3e:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002d42:	30 08       	mov	r8,0
80002d44:	f3 68 00 08 	st.b	r9[8],r8
80002d48:	ee c8 00 2c 	sub	r8,r7,44
80002d4c:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002d50:	e1 b8 00 42 	mfsr	r8,0x108
80002d54:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002d58:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d5c:	f1 39 00 08 	ld.ub	r9,r8[8]
80002d60:	30 28       	mov	r8,2
80002d62:	f0 09 18 00 	cp.b	r9,r8
80002d66:	c0 31       	brne	80002d6c <dip204_clear_display+0xcc>
    return false;
80002d68:	30 08       	mov	r8,0
80002d6a:	c4 38       	rjmp	80002df0 <dip204_clear_display+0x150>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002d6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d70:	f1 39 00 08 	ld.ub	r9,r8[8]
80002d74:	30 18       	mov	r8,1
80002d76:	f0 09 18 00 	cp.b	r9,r8
80002d7a:	c0 31       	brne	80002d80 <dip204_clear_display+0xe0>
    return true;
80002d7c:	30 18       	mov	r8,1
80002d7e:	c3 98       	rjmp	80002df0 <dip204_clear_display+0x150>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002d80:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d84:	70 09       	ld.w	r9,r8[0x0]
80002d86:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d8a:	70 18       	ld.w	r8,r8[0x4]
80002d8c:	10 39       	cp.w	r9,r8
80002d8e:	e0 88 00 1a 	brls	80002dc2 <dip204_clear_display+0x122>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002d92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d96:	70 08       	ld.w	r8,r8[0x0]
80002d98:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002d9c:	10 39       	cp.w	r9,r8
80002d9e:	c1 02       	brcc	80002dbe <dip204_clear_display+0x11e>
80002da0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002da4:	70 18       	ld.w	r8,r8[0x4]
80002da6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002daa:	10 39       	cp.w	r9,r8
80002dac:	e0 88 00 09 	brls	80002dbe <dip204_clear_display+0x11e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002db0:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002db4:	30 18       	mov	r8,1
80002db6:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002dba:	30 18       	mov	r8,1
80002dbc:	c1 a8       	rjmp	80002df0 <dip204_clear_display+0x150>
    }
    return false;
80002dbe:	30 08       	mov	r8,0
80002dc0:	c1 88       	rjmp	80002df0 <dip204_clear_display+0x150>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002dc2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dc6:	70 08       	ld.w	r8,r8[0x0]
80002dc8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002dcc:	10 39       	cp.w	r9,r8
80002dce:	c0 93       	brcs	80002de0 <dip204_clear_display+0x140>
80002dd0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dd4:	70 18       	ld.w	r8,r8[0x4]
80002dd6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002dda:	10 39       	cp.w	r9,r8
80002ddc:	e0 88 00 09 	brls	80002dee <dip204_clear_display+0x14e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002de0:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002de4:	30 18       	mov	r8,1
80002de6:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002dea:	30 18       	mov	r8,1
80002dec:	c0 28       	rjmp	80002df0 <dip204_clear_display+0x150>
    }
    return false;
80002dee:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002df0:	58 08       	cp.w	r8,0
80002df2:	ca b0       	breq	80002d48 <dip204_clear_display+0xa8>
  dip204_wait_busy();
80002df4:	f0 1f 00 08 	mcall	80002e14 <dip204_clear_display+0x174>
  dip204_unselect();
80002df8:	f0 1f 00 08 	mcall	80002e18 <dip204_clear_display+0x178>
}
80002dfc:	2f 5d       	sub	sp,-44
80002dfe:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
80002e02:	00 00       	add	r0,r0
80002e04:	80 00       	ld.sh	r0,r0[0x0]
80002e06:	2e e0       	sub	r0,-18
80002e08:	80 00       	ld.sh	r0,r0[0x0]
80002e0a:	2f 10       	sub	r0,-15
80002e0c:	80 00       	ld.sh	r0,r0[0x0]
80002e0e:	20 f0       	sub	r0,15
80002e10:	80 00       	ld.sh	r0,r0[0x0]
80002e12:	6a 78       	ld.w	r8,r5[0x1c]
80002e14:	80 00       	ld.sh	r0,r0[0x0]
80002e16:	2f f4       	sub	r4,-1
80002e18:	80 00       	ld.sh	r0,r0[0x0]
80002e1a:	2e f8       	sub	r8,-17

80002e1c <dip204_printf_string>:
  dip204_unselect();
}


void dip204_printf_string(const char *format, ...)
{
80002e1c:	eb cd 40 80 	pushm	r7,lr
80002e20:	1a 97       	mov	r7,sp
80002e22:	20 9d       	sub	sp,36
80002e24:	ee c9 ff f8 	sub	r9,r7,-8
80002e28:	ef 4c ff dc 	st.w	r7[-36],r12
  va_list arg;
  char string[21];
  unsigned char i=0;
80002e2c:	30 08       	mov	r8,0
80002e2e:	ef 68 ff ff 	st.b	r7[-1],r8

  va_start(arg, format);
80002e32:	f2 c8 00 00 	sub	r8,r9,0
80002e36:	ef 48 ff f8 	st.w	r7[-8],r8
  i = vsprintf(string, format, arg);
80002e3a:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002e3e:	ee c8 00 20 	sub	r8,r7,32
80002e42:	12 9a       	mov	r10,r9
80002e44:	ee fb ff dc 	ld.w	r11,r7[-36]
80002e48:	10 9c       	mov	r12,r8
80002e4a:	f0 1f 00 21 	mcall	80002ecc <dip204_printf_string+0xb0>
80002e4e:	18 98       	mov	r8,r12
80002e50:	ef 68 ff ff 	st.b	r7[-1],r8
  while (i < sizeof(string) - 1) string[i++] = '\0';
80002e54:	c0 d8       	rjmp	80002e6e <dip204_printf_string+0x52>
80002e56:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002e5a:	ee 08 00 09 	add	r9,r7,r8
80002e5e:	30 08       	mov	r8,0
80002e60:	f3 68 ff e0 	st.b	r9[-32],r8
80002e64:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002e68:	2f f8       	sub	r8,-1
80002e6a:	ef 68 ff ff 	st.b	r7[-1],r8
80002e6e:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80002e72:	31 38       	mov	r8,19
80002e74:	f0 09 18 00 	cp.b	r9,r8
80002e78:	fe 98 ff ef 	brls	80002e56 <dip204_printf_string+0x3a>
  va_end(arg);
  dip204_select();
80002e7c:	f0 1f 00 15 	mcall	80002ed0 <dip204_printf_string+0xb4>
  /* for all chars in string */
  i = 0;
80002e80:	30 08       	mov	r8,0
80002e82:	ef 68 ff ff 	st.b	r7[-1],r8
  while(string[i]!='\0')
80002e86:	c1 58       	rjmp	80002eb0 <dip204_printf_string+0x94>
  {
    /* Send Write Data Start Byte */
    dip204_write_byte(DIP204_WRITE_DATA);
80002e88:	e0 6c 00 fa 	mov	r12,250
80002e8c:	f0 1f 00 12 	mcall	80002ed4 <dip204_printf_string+0xb8>
    /* Send byte */
    dip204_write_byte(string[i]);
80002e90:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002e94:	ee 08 00 08 	add	r8,r7,r8
80002e98:	f1 38 ff e0 	ld.ub	r8,r8[-32]
80002e9c:	10 9c       	mov	r12,r8
80002e9e:	f0 1f 00 0e 	mcall	80002ed4 <dip204_printf_string+0xb8>
    /* go to next char */
    i++;
80002ea2:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002ea6:	2f f8       	sub	r8,-1
80002ea8:	ef 68 ff ff 	st.b	r7[-1],r8
    dip204_wait_busy();
80002eac:	f0 1f 00 0b 	mcall	80002ed8 <dip204_printf_string+0xbc>
  while (i < sizeof(string) - 1) string[i++] = '\0';
  va_end(arg);
  dip204_select();
  /* for all chars in string */
  i = 0;
  while(string[i]!='\0')
80002eb0:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002eb4:	ee 08 00 08 	add	r8,r7,r8
80002eb8:	f1 38 ff e0 	ld.ub	r8,r8[-32]
80002ebc:	58 08       	cp.w	r8,0
80002ebe:	ce 51       	brne	80002e88 <dip204_printf_string+0x6c>
    dip204_write_byte(string[i]);
    /* go to next char */
    i++;
    dip204_wait_busy();
  }
  dip204_unselect();
80002ec0:	f0 1f 00 07 	mcall	80002edc <dip204_printf_string+0xc0>
}
80002ec4:	2f 7d       	sub	sp,-36
80002ec6:	e3 cd 80 80 	ldm	sp++,r7,pc
80002eca:	00 00       	add	r0,r0
80002ecc:	80 00       	ld.sh	r0,r0[0x0]
80002ece:	99 54       	st.w	r12[0x14],r4
80002ed0:	80 00       	ld.sh	r0,r0[0x0]
80002ed2:	2e e0       	sub	r0,-18
80002ed4:	80 00       	ld.sh	r0,r0[0x0]
80002ed6:	2f 10       	sub	r0,-15
80002ed8:	80 00       	ld.sh	r0,r0[0x0]
80002eda:	2f f4       	sub	r4,-1
80002edc:	80 00       	ld.sh	r0,r0[0x0]
80002ede:	2e f8       	sub	r8,-17

80002ee0 <dip204_select>:

/*! \brief function to select the LCD
 *
 */
static void dip204_select(void)
{
80002ee0:	eb cd 40 80 	pushm	r7,lr
80002ee4:	1a 97       	mov	r7,sp
  spi_selectChip(DIP204_SPI, DIP204_SPI_NPCS);
80002ee6:	30 2b       	mov	r11,2
80002ee8:	fe 7c 28 00 	mov	r12,-55296
80002eec:	f0 1f 00 02 	mcall	80002ef4 <dip204_select+0x14>
}
80002ef0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ef4:	80 00       	ld.sh	r0,r0[0x0]
80002ef6:	34 0a       	mov	r10,64

80002ef8 <dip204_unselect>:

/*! \brief function to unselect the LCD
 *
 */
static void dip204_unselect(void)
{
80002ef8:	eb cd 40 80 	pushm	r7,lr
80002efc:	1a 97       	mov	r7,sp
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_unselectChip(DIP204_SPI, DIP204_SPI_NPCS);
80002efe:	30 2b       	mov	r11,2
80002f00:	fe 7c 28 00 	mov	r12,-55296
80002f04:	f0 1f 00 02 	mcall	80002f0c <dip204_unselect+0x14>
  Assert( SPI_OK==spi_status );
}
80002f08:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f0c:	80 00       	ld.sh	r0,r0[0x0]
80002f0e:	34 a2       	mov	r2,74

80002f10 <dip204_write_byte>:
 *
 *  \param  byte  Input. byte to write to the LCD (D7 .. D0)
 *
 */
static void dip204_write_byte(unsigned char byte)
{
80002f10:	eb cd 40 80 	pushm	r7,lr
80002f14:	1a 97       	mov	r7,sp
80002f16:	20 3d       	sub	sp,12
80002f18:	18 98       	mov	r8,r12
80002f1a:	ef 68 ff f4 	st.b	r7[-12],r8
  unsigned char reverse;

  switch (byte)
80002f1e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002f22:	f0 c8 00 f8 	sub	r8,r8,248
80002f26:	58 68       	cp.w	r8,6
80002f28:	e0 8b 00 10 	brhi	80002f48 <dip204_write_byte+0x38>
80002f2c:	30 19       	mov	r9,1
80002f2e:	f2 08 09 48 	lsl	r8,r9,r8
80002f32:	e2 18 00 55 	andl	r8,0x55,COH
80002f36:	c0 90       	breq	80002f48 <dip204_write_byte+0x38>
    {
      /* send D7 to D0 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, byte);
80002f38:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002f3c:	10 9b       	mov	r11,r8
80002f3e:	fe 7c 28 00 	mov	r12,-55296
80002f42:	f0 1f 00 15 	mcall	80002f94 <dip204_write_byte+0x84>
      Assert( SPI_OK==spi_status );
      break;
80002f46:	c2 48       	rjmp	80002f8e <dip204_write_byte+0x7e>
    }
    /* LSB first for all other data */
    default:
    {
      /* reverse byte */
      reverse = bit_reverse8(byte);
80002f48:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002f4c:	ef 48 ff fc 	st.w	r7[-4],r8
80002f50:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002f54:	5c 98       	brev	r8
80002f56:	ef 48 ff fc 	st.w	r7[-4],r8
80002f5a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002f5e:	b9 88       	lsr	r8,0x18
80002f60:	ef 68 ff fb 	st.b	r7[-5],r8
      /* send D0 to D3 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, (reverse & 0xF0));
80002f64:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002f68:	e2 18 00 f0 	andl	r8,0xf0,COH
80002f6c:	10 9b       	mov	r11,r8
80002f6e:	fe 7c 28 00 	mov	r12,-55296
80002f72:	f0 1f 00 09 	mcall	80002f94 <dip204_write_byte+0x84>
      Assert( SPI_OK==spi_status );
      /* send D4 to D7 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, ((reverse << 4) & 0xF0));
80002f76:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002f7a:	a5 68       	lsl	r8,0x4
80002f7c:	5c 88       	casts.h	r8
80002f7e:	5c 78       	castu.h	r8
80002f80:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002f84:	10 9b       	mov	r11,r8
80002f86:	fe 7c 28 00 	mov	r12,-55296
80002f8a:	f0 1f 00 03 	mcall	80002f94 <dip204_write_byte+0x84>
      Assert( SPI_OK==spi_status );
      break;
    }
  }
}
80002f8e:	2f dd       	sub	sp,-12
80002f90:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f94:	80 00       	ld.sh	r0,r0[0x0]
80002f96:	36 aa       	mov	r10,106

80002f98 <dip204_read_byte>:
 *
 *  \param  byte  Input. byte read from the LCD (D7 .. D0)
 *
 */
static void dip204_read_byte(unsigned char *byte)
{
80002f98:	eb cd 40 80 	pushm	r7,lr
80002f9c:	1a 97       	mov	r7,sp
80002f9e:	20 3d       	sub	sp,12
80002fa0:	ef 4c ff f4 	st.w	r7[-12],r12
  unsigned short reverse = 0x00;
80002fa4:	30 08       	mov	r8,0
80002fa6:	ef 58 ff fa 	st.h	r7[-6],r8

  /* dummy write */
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_write(DIP204_SPI, 0x00);
80002faa:	30 0b       	mov	r11,0
80002fac:	fe 7c 28 00 	mov	r12,-55296
80002fb0:	f0 1f 00 0f 	mcall	80002fec <dip204_read_byte+0x54>
  Assert( SPI_OK==spi_status );
  /* read RSR register */
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_read(DIP204_SPI, &reverse);
80002fb4:	ee c8 00 06 	sub	r8,r7,6
80002fb8:	10 9b       	mov	r11,r8
80002fba:	fe 7c 28 00 	mov	r12,-55296
80002fbe:	f0 1f 00 0d 	mcall	80002ff0 <dip204_read_byte+0x58>
  Assert( SPI_OK==spi_status );
  /* Revert received byte (issued LSB first by the LCD) */
  *byte = bit_reverse8(reverse);
80002fc2:	ef 08 ff fa 	ld.sh	r8,r7[-6]
80002fc6:	5c 58       	castu.b	r8
80002fc8:	ef 48 ff fc 	st.w	r7[-4],r8
80002fcc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fd0:	5c 98       	brev	r8
80002fd2:	ef 48 ff fc 	st.w	r7[-4],r8
80002fd6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fda:	b9 88       	lsr	r8,0x18
80002fdc:	5c 58       	castu.b	r8
80002fde:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002fe2:	b2 88       	st.b	r9[0x0],r8
}
80002fe4:	2f dd       	sub	sp,-12
80002fe6:	e3 cd 80 80 	ldm	sp++,r7,pc
80002fea:	00 00       	add	r0,r0
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	36 aa       	mov	r10,106
80002ff0:	80 00       	ld.sh	r0,r0[0x0]
80002ff2:	37 02       	mov	r2,112

80002ff4 <dip204_wait_busy>:

/*! \brief function to wait for LCD becomes not busy
 *
 */
static void dip204_wait_busy(void)
{
80002ff4:	eb cd 40 80 	pushm	r7,lr
80002ff8:	1a 97       	mov	r7,sp
80002ffa:	20 1d       	sub	sp,4
  unsigned char status = 0x00;
80002ffc:	30 08       	mov	r8,0
80002ffe:	ef 68 ff ff 	st.b	r7[-1],r8

  /* send read command to LCD */
  dip204_write_byte(DIP204_READ_COMMAND);
80003002:	e0 6c 00 fc 	mov	r12,252
80003006:	f0 1f 00 09 	mcall	80003028 <dip204_wait_busy+0x34>
  /* read next byte */
  do {
  dip204_read_byte(&status);
8000300a:	ee c8 00 01 	sub	r8,r7,1
8000300e:	10 9c       	mov	r12,r8
80003010:	f0 1f 00 07 	mcall	8000302c <dip204_wait_busy+0x38>
  /* keep D7 to know status */
  }while (status & 0x80);
80003014:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003018:	10 99       	mov	r9,r8
8000301a:	30 08       	mov	r8,0
8000301c:	f0 09 18 00 	cp.b	r9,r8
80003020:	cf 55       	brlt	8000300a <dip204_wait_busy+0x16>
}
80003022:	2f fd       	sub	sp,-4
80003024:	e3 cd 80 80 	ldm	sp++,r7,pc
80003028:	80 00       	ld.sh	r0,r0[0x0]
8000302a:	2f 10       	sub	r0,-15
8000302c:	80 00       	ld.sh	r0,r0[0x0]
8000302e:	2f 98       	sub	r8,-7

80003030 <adc_configure>:
 * If not called, ADC channels will have side effects
 *
 * \param *adc Base address of the ADC
 */
void adc_configure(volatile avr32_adc_t *adc)
{
80003030:	eb cd 40 80 	pushm	r7,lr
80003034:	1a 97       	mov	r7,sp
80003036:	20 1d       	sub	sp,4
80003038:	ef 4c ff fc 	st.w	r7[-4],r12
	adc->mr |= 1 << AVR32_ADC_LOWRES_OFFSET;
#endif

	/* Set Sample/Hold time to max so that the ADC capacitor should be
	 * loaded entirely */
	adc->mr |= 0xF << AVR32_ADC_SHTIM_OFFSET;
8000303c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003040:	70 18       	ld.w	r8,r8[0x4]
80003042:	10 99       	mov	r9,r8
80003044:	ea 19 0f 00 	orh	r9,0xf00
80003048:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000304c:	91 19       	st.w	r8[0x4],r9

	/* Set Startup to max so that the ADC capacitor should be loaded
	 * entirely */
	adc->mr |= 0x1F << AVR32_ADC_STARTUP_OFFSET;
8000304e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003052:	70 18       	ld.w	r8,r8[0x4]
80003054:	10 99       	mov	r9,r8
80003056:	ea 19 00 1f 	orh	r9,0x1f
8000305a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000305e:	91 19       	st.w	r8[0x4],r9
}
80003060:	2f fd       	sub	sp,-4
80003062:	e3 cd 80 80 	ldm	sp++,r7,pc

80003066 <adc_start>:

/** \brief Start analog to digital conversion
 * \param *adc Base address of the ADC
 */
void adc_start(volatile avr32_adc_t *adc)
{
80003066:	eb cd 40 80 	pushm	r7,lr
8000306a:	1a 97       	mov	r7,sp
8000306c:	20 1d       	sub	sp,4
8000306e:	ef 4c ff fc 	st.w	r7[-4],r12
	Assert( adc != NULL );

	/* start conversion */
	adc->cr = AVR32_ADC_START_MASK;
80003072:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003076:	30 29       	mov	r9,2
80003078:	91 09       	st.w	r8[0x0],r9
}
8000307a:	2f fd       	sub	sp,-4
8000307c:	e3 cd 80 80 	ldm	sp++,r7,pc

80003080 <adc_enable>:
 *
 * \param *adc Base address of the ADC
 * \param  channel   channel to enable (0 to 7)
 */
void adc_enable(volatile avr32_adc_t *adc, uint16_t channel)
{
80003080:	eb cd 40 80 	pushm	r7,lr
80003084:	1a 97       	mov	r7,sp
80003086:	20 2d       	sub	sp,8
80003088:	ef 4c ff fc 	st.w	r7[-4],r12
8000308c:	16 98       	mov	r8,r11
8000308e:	ef 58 ff f8 	st.h	r7[-8],r8
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB ); /* check if channel exist
	                                              **/

	/* enable channel */
	adc->cher = (1 << channel);
80003092:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003096:	30 19       	mov	r9,1
80003098:	f2 08 09 48 	lsl	r8,r9,r8
8000309c:	10 99       	mov	r9,r8
8000309e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030a2:	91 49       	st.w	r8[0x10],r9
}
800030a4:	2f ed       	sub	sp,-8
800030a6:	e3 cd 80 80 	ldm	sp++,r7,pc

800030aa <adc_check_eoc>:
 * \param  channel   channel to check (0 to 7)
 * \return bool      true if conversion not running
 *                   false if conversion running
 */
bool adc_check_eoc(volatile avr32_adc_t *adc, uint16_t channel)
{
800030aa:	eb cd 40 80 	pushm	r7,lr
800030ae:	1a 97       	mov	r7,sp
800030b0:	20 2d       	sub	sp,8
800030b2:	ef 4c ff fc 	st.w	r7[-4],r12
800030b6:	16 98       	mov	r8,r11
800030b8:	ef 58 ff f8 	st.h	r7[-8],r8
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB ); /* check if channel exist
	                                              **/

	/* get SR register : EOC bit for channel */
	return ((adc->sr & (1 << channel)) ? true : false);
800030bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030c0:	70 79       	ld.w	r9,r8[0x1c]
800030c2:	ef 18 ff f8 	ld.uh	r8,r7[-8]
800030c6:	30 1a       	mov	r10,1
800030c8:	f4 08 09 48 	lsl	r8,r10,r8
800030cc:	f3 e8 00 08 	and	r8,r9,r8
800030d0:	5f 18       	srne	r8
800030d2:	5c 58       	castu.b	r8
}
800030d4:	10 9c       	mov	r12,r8
800030d6:	2f ed       	sub	sp,-8
800030d8:	e3 cd 80 80 	ldm	sp++,r7,pc

800030dc <adc_get_value>:
 * \param *adc Base address of the ADC
 * \param  channel   channel to handle (0 to 7)
 * \return The value acquired (unsigned long)
 */
uint32_t adc_get_value(volatile avr32_adc_t *adc, uint16_t channel)
{
800030dc:	eb cd 40 80 	pushm	r7,lr
800030e0:	1a 97       	mov	r7,sp
800030e2:	20 2d       	sub	sp,8
800030e4:	ef 4c ff fc 	st.w	r7[-4],r12
800030e8:	16 98       	mov	r8,r11
800030ea:	ef 58 ff f8 	st.h	r7[-8],r8
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB );

	/* wait for end of conversion */
	while (adc_check_eoc(adc, channel) != true) {
800030ee:	ef 18 ff f8 	ld.uh	r8,r7[-8]
800030f2:	10 9b       	mov	r11,r8
800030f4:	ee fc ff fc 	ld.w	r12,r7[-4]
800030f8:	f0 1f 00 0b 	mcall	80003124 <adc_get_value+0x48>
800030fc:	18 98       	mov	r8,r12
800030fe:	ec 18 00 01 	eorl	r8,0x1
80003102:	5c 58       	castu.b	r8
80003104:	cf 51       	brne	800030ee <adc_get_value+0x12>
	}

	return *((uint32_t *)((&(adc->cdr0)) + channel));
80003106:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000310a:	f0 c9 ff d0 	sub	r9,r8,-48
8000310e:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003112:	a3 68       	lsl	r8,0x2
80003114:	f2 08 00 08 	add	r8,r9,r8
80003118:	70 08       	ld.w	r8,r8[0x0]
}
8000311a:	10 9c       	mov	r12,r8
8000311c:	2f ed       	sub	sp,-8
8000311e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003122:	00 00       	add	r0,r0
80003124:	80 00       	ld.sh	r0,r0[0x0]
80003126:	30 aa       	mov	r10,10

80003128 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80003128:	eb cd 40 80 	pushm	r7,lr
8000312c:	1a 97       	mov	r7,sp
8000312e:	20 1d       	sub	sp,4
80003130:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80003134:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003138:	e6 18 00 01 	andh	r8,0x1,COH
8000313c:	5f 08       	sreq	r8
8000313e:	5c 58       	castu.b	r8
}
80003140:	10 9c       	mov	r12,r8
80003142:	2f fd       	sub	sp,-4
80003144:	e3 cd 80 80 	ldm	sp++,r7,pc

80003148 <pwm_init>:
#include "compiler.h"
#include "pwm.h"


int pwm_init(const pwm_opt_t *opt)
{
80003148:	eb cd 40 80 	pushm	r7,lr
8000314c:	1a 97       	mov	r7,sp
8000314e:	20 3d       	sub	sp,12
80003150:	ef 4c ff f4 	st.w	r7[-12],r12
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
80003154:	fe 78 30 00 	mov	r8,-53248
80003158:	ef 48 ff f8 	st.w	r7[-8],r8
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
8000315c:	e1 b8 00 00 	mfsr	r8,0x0
80003160:	10 9c       	mov	r12,r8
80003162:	f0 1f 00 1e 	mcall	800031d8 <pwm_init+0x90>
80003166:	18 98       	mov	r8,r12
80003168:	ef 68 ff ff 	st.b	r7[-1],r8

  if (opt == 0 ) // Null pointer.
8000316c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003170:	58 08       	cp.w	r8,0
80003172:	c0 31       	brne	80003178 <pwm_init+0x30>
    return PWM_INVALID_INPUT;
80003174:	30 18       	mov	r8,1
80003176:	c2 c8       	rjmp	800031ce <pwm_init+0x86>

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
80003178:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000317c:	30 08       	mov	r8,0
8000317e:	f0 09 18 00 	cp.b	r9,r8
80003182:	c0 20       	breq	80003186 <pwm_init+0x3e>
80003184:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
80003186:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000318a:	37 f9       	mov	r9,127
8000318c:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
8000318e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003192:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
80003194:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003198:	30 08       	mov	r8,0
8000319a:	f0 09 18 00 	cp.b	r9,r8
8000319e:	c0 20       	breq	800031a2 <pwm_init+0x5a>
800031a0:	d5 03       	csrf	0x10

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
800031a2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800031a6:	70 19       	ld.w	r9,r8[0x4]
    ((opt->divb)<<AVR32_PWM_DIVB_OFFSET) |
800031a8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800031ac:	70 08       	ld.w	r8,r8[0x0]
800031ae:	b1 68       	lsl	r8,0x10
800031b0:	10 49       	or	r9,r8
    ((opt->prea)<<AVR32_PWM_PREA_OFFSET) |
800031b2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800031b6:	70 38       	ld.w	r8,r8[0xc]
800031b8:	a9 68       	lsl	r8,0x8
800031ba:	10 49       	or	r9,r8
    ((opt->preb)<<AVR32_PWM_PREB_OFFSET)
800031bc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800031c0:	70 28       	ld.w	r8,r8[0x8]
800031c2:	b9 68       	lsl	r8,0x18
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
800031c4:	10 49       	or	r9,r8
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
800031c6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800031ca:	91 09       	st.w	r8[0x0],r9
    ((opt->divb)<<AVR32_PWM_DIVB_OFFSET) |
    ((opt->prea)<<AVR32_PWM_PREA_OFFSET) |
    ((opt->preb)<<AVR32_PWM_PREB_OFFSET)
    ;

  return PWM_SUCCESS;
800031cc:	30 08       	mov	r8,0
}
800031ce:	10 9c       	mov	r12,r8
800031d0:	2f dd       	sub	sp,-12
800031d2:	e3 cd 80 80 	ldm	sp++,r7,pc
800031d6:	00 00       	add	r0,r0
800031d8:	80 00       	ld.sh	r0,r0[0x0]
800031da:	31 28       	mov	r8,18

800031dc <pwm_channel_init>:


int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
800031dc:	eb cd 40 80 	pushm	r7,lr
800031e0:	1a 97       	mov	r7,sp
800031e2:	20 3d       	sub	sp,12
800031e4:	ef 4c ff f8 	st.w	r7[-8],r12
800031e8:	ef 4b ff f4 	st.w	r7[-12],r11
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
800031ec:	fe 78 30 00 	mov	r8,-53248
800031f0:	ef 48 ff fc 	st.w	r7[-4],r8

  if (pwm_channel == 0) // Null pointer.
800031f4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800031f8:	58 08       	cp.w	r8,0
800031fa:	c0 31       	brne	80003200 <pwm_channel_init+0x24>
    return PWM_INVALID_ARGUMENT;
800031fc:	30 18       	mov	r8,1
800031fe:	c2 f8       	rjmp	8000325c <pwm_channel_init+0x80>
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
80003200:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003204:	58 68       	cp.w	r8,6
80003206:	e0 88 00 04 	brls	8000320e <pwm_channel_init+0x32>
    return PWM_INVALID_INPUT;
8000320a:	30 18       	mov	r8,1
8000320c:	c2 88       	rjmp	8000325c <pwm_channel_init+0x80>

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
8000320e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003212:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003216:	72 09       	ld.w	r9,r9[0x0]
80003218:	ee fa ff fc 	ld.w	r10,r7[-4]
8000321c:	2f 08       	sub	r8,-16
8000321e:	a5 78       	lsl	r8,0x5
80003220:	f4 08 00 08 	add	r8,r10,r8
80003224:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
80003226:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000322a:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000322e:	72 19       	ld.w	r9,r9[0x4]
80003230:	ee fa ff fc 	ld.w	r10,r7[-4]
80003234:	a5 78       	lsl	r8,0x5
80003236:	f4 08 00 08 	add	r8,r10,r8
8000323a:	f0 c8 fd fc 	sub	r8,r8,-516
8000323e:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
80003240:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003244:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003248:	72 29       	ld.w	r9,r9[0x8]
8000324a:	ee fa ff fc 	ld.w	r10,r7[-4]
8000324e:	a5 78       	lsl	r8,0x5
80003250:	f4 08 00 08 	add	r8,r10,r8
80003254:	f0 c8 fd f8 	sub	r8,r8,-520
80003258:	91 09       	st.w	r8[0x0],r9

  return PWM_SUCCESS;
8000325a:	30 08       	mov	r8,0
}
8000325c:	10 9c       	mov	r12,r8
8000325e:	2f dd       	sub	sp,-12
80003260:	e3 cd 80 80 	ldm	sp++,r7,pc

80003264 <pwm_start_channels>:


int pwm_start_channels(unsigned long channels_bitmask)
{
80003264:	eb cd 40 80 	pushm	r7,lr
80003268:	1a 97       	mov	r7,sp
8000326a:	20 1d       	sub	sp,4
8000326c:	ef 4c ff fc 	st.w	r7[-4],r12
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
80003270:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003274:	e0 18 ff 80 	andl	r8,0xff80
80003278:	c0 30       	breq	8000327e <pwm_start_channels+0x1a>
    return PWM_INVALID_INPUT;
8000327a:	30 18       	mov	r8,1
8000327c:	c0 78       	rjmp	8000328a <pwm_start_channels+0x26>

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
8000327e:	fe 78 30 00 	mov	r8,-53248
80003282:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003286:	91 19       	st.w	r8[0x4],r9

  return PWM_SUCCESS;
80003288:	30 08       	mov	r8,0
}
8000328a:	10 9c       	mov	r12,r8
8000328c:	2f fd       	sub	sp,-4
8000328e:	e3 cd 80 80 	ldm	sp++,r7,pc

80003292 <getBaudDiv>:
/** The SPI mutex. */
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
80003292:	eb cd 40 80 	pushm	r7,lr
80003296:	1a 97       	mov	r7,sp
80003298:	20 3d       	sub	sp,12
8000329a:	ef 4c ff f8 	st.w	r7[-8],r12
8000329e:	ef 4b ff f4 	st.w	r7[-12],r11
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800032a2:	ee f9 ff f4 	ld.w	r9,r7[-12]
800032a6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800032aa:	f2 08 00 08 	add	r8,r9,r8
800032ae:	20 18       	sub	r8,1
800032b0:	ee f9 ff f8 	ld.w	r9,r7[-8]
800032b4:	f0 09 0d 08 	divu	r8,r8,r9
800032b8:	ef 48 ff fc 	st.w	r7[-4],r8

	if (baudDiv <= 0 || baudDiv > 255) {
800032bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032c0:	58 08       	cp.w	r8,0
800032c2:	c0 70       	breq	800032d0 <getBaudDiv+0x3e>
800032c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032c8:	e0 48 00 ff 	cp.w	r8,255
800032cc:	e0 88 00 04 	brls	800032d4 <getBaudDiv+0x42>
		return -1;
800032d0:	3f f8       	mov	r8,-1
800032d2:	c0 48       	rjmp	800032da <getBaudDiv+0x48>
	}

	return baudDiv;
800032d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800032d8:	5c 88       	casts.h	r8
}
800032da:	10 9c       	mov	r12,r8
800032dc:	2f dd       	sub	sp,-12
800032de:	e3 cd 80 80 	ldm	sp++,r7,pc

800032e2 <spi_initMaster>:
	return SPI_OK;
}

spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
800032e2:	eb cd 40 80 	pushm	r7,lr
800032e6:	1a 97       	mov	r7,sp
800032e8:	20 3d       	sub	sp,12
800032ea:	ef 4c ff f8 	st.w	r7[-8],r12
800032ee:	ef 4b ff f4 	st.w	r7[-12],r11
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800032f2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800032f6:	f1 39 00 0d 	ld.ub	r9,r8[13]
800032fa:	30 18       	mov	r8,1
800032fc:	f0 09 18 00 	cp.b	r9,r8
80003300:	e0 88 00 04 	brls	80003308 <spi_initMaster+0x26>
		return SPI_ERROR_ARGUMENT;
80003304:	30 28       	mov	r8,2
80003306:	c3 48       	rjmp	8000336e <spi_initMaster+0x8c>
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80003308:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000330c:	e0 69 00 80 	mov	r9,128
80003310:	91 09       	st.w	r8[0x0],r9

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80003312:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003316:	70 18       	ld.w	r8,r8[0x4]
80003318:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.mstr = 1;
8000331c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003320:	30 19       	mov	r9,1
80003322:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
80003326:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
8000332a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000332e:	f1 38 00 0d 	ld.ub	r8,r8[13]
80003332:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003336:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000333a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000333e:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
80003342:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.llb = 0;
80003346:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000334a:	30 09       	mov	r9,0
8000334c:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
80003350:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80003354:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003358:	30 f9       	mov	r9,15
8000335a:	f1 d9 d2 04 	bfins	r8,r9,0x10,0x4
8000335e:	ef 48 ff fc 	st.w	r7[-4],r8
	spi->mr = u_avr32_spi_mr.mr;
80003362:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003366:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000336a:	91 19       	st.w	r8[0x4],r9

	return SPI_OK;
8000336c:	30 08       	mov	r8,0
}
8000336e:	10 9c       	mov	r12,r8
80003370:	2f dd       	sub	sp,-12
80003372:	e3 cd 80 80 	ldm	sp++,r7,pc

80003376 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80003376:	eb cd 40 80 	pushm	r7,lr
8000337a:	1a 97       	mov	r7,sp
8000337c:	20 5d       	sub	sp,20
8000337e:	ef 4c ff f8 	st.w	r7[-8],r12
80003382:	12 98       	mov	r8,r9
80003384:	16 99       	mov	r9,r11
80003386:	ef 69 ff f4 	st.b	r7[-12],r9
8000338a:	14 99       	mov	r9,r10
8000338c:	ef 69 ff f0 	st.b	r7[-16],r9
80003390:	ef 68 ff ec 	st.b	r7[-20],r8
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80003394:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80003398:	30 18       	mov	r8,1
8000339a:	f0 09 18 00 	cp.b	r9,r8
8000339e:	e0 8b 00 09 	brhi	800033b0 <spi_selectionMode+0x3a>
800033a2:	ef 39 ff f0 	ld.ub	r9,r7[-16]
800033a6:	30 18       	mov	r8,1
800033a8:	f0 09 18 00 	cp.b	r9,r8
800033ac:	e0 88 00 04 	brls	800033b4 <spi_selectionMode+0x3e>
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
800033b0:	30 28       	mov	r8,2
800033b2:	c2 88       	rjmp	80003402 <spi_selectionMode+0x8c>
	}

	u_avr32_spi_mr.mr = spi->mr;
800033b4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800033b8:	70 18       	ld.w	r8,r8[0x4]
800033ba:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.ps = variable_ps;
800033be:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800033c2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800033c6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800033ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033ce:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
800033d2:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
800033d6:	ef 38 ff f0 	ld.ub	r8,r7[-16]
800033da:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800033de:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800033e2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800033e6:	f1 d9 d0 41 	bfins	r8,r9,0x2,0x1
800033ea:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.dlybcs = delay;
800033ee:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800033f2:	ef 68 ff fc 	st.b	r7[-4],r8
	spi->mr = u_avr32_spi_mr.mr;
800033f6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800033fa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800033fe:	91 19       	st.w	r8[0x4],r9

	return SPI_OK;
80003400:	30 08       	mov	r8,0
}
80003402:	10 9c       	mov	r12,r8
80003404:	2f bd       	sub	sp,-20
80003406:	e3 cd 80 80 	ldm	sp++,r7,pc

8000340a <spi_selectChip>:

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000340a:	eb cd 40 80 	pushm	r7,lr
8000340e:	1a 97       	mov	r7,sp
80003410:	20 2d       	sub	sp,8
80003412:	ef 4c ff fc 	st.w	r7[-4],r12
80003416:	16 98       	mov	r8,r11
80003418:	ef 68 ff f8 	st.b	r7[-8],r8
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000341c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003420:	70 18       	ld.w	r8,r8[0x4]
80003422:	10 99       	mov	r9,r8
80003424:	ea 19 00 0f 	orh	r9,0xf
80003428:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000342c:	91 19       	st.w	r8[0x4],r9

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
8000342e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003432:	70 18       	ld.w	r8,r8[0x4]
80003434:	e2 18 00 04 	andl	r8,0x4,COH
80003438:	c1 90       	breq	8000346a <spi_selectChip+0x60>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
8000343a:	ef 39 ff f8 	ld.ub	r9,r7[-8]
8000343e:	30 e8       	mov	r8,14
80003440:	f0 09 18 00 	cp.b	r9,r8
80003444:	e0 88 00 04 	brls	8000344c <spi_selectChip+0x42>
			return SPI_ERROR_ARGUMENT;
80003448:	30 28       	mov	r8,2
8000344a:	c2 88       	rjmp	8000349a <spi_selectChip+0x90>
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
8000344c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003450:	70 19       	ld.w	r9,r8[0x4]
				(chip << AVR32_SPI_MR_PCS_OFFSET);
80003452:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80003456:	b1 68       	lsl	r8,0x10
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80003458:	ea 18 ff f0 	orh	r8,0xfff0
8000345c:	e8 18 ff ff 	orl	r8,0xffff
80003460:	10 69       	and	r9,r8
80003462:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003466:	91 19       	st.w	r8[0x4],r9
80003468:	c1 88       	rjmp	80003498 <spi_selectChip+0x8e>
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
8000346a:	ef 39 ff f8 	ld.ub	r9,r7[-8]
8000346e:	30 38       	mov	r8,3
80003470:	f0 09 18 00 	cp.b	r9,r8
80003474:	e0 88 00 04 	brls	8000347c <spi_selectChip+0x72>
			return SPI_ERROR_ARGUMENT;
80003478:	30 28       	mov	r8,2
8000347a:	c1 08       	rjmp	8000349a <spi_selectChip+0x90>
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
8000347c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003480:	70 19       	ld.w	r9,r8[0x4]
80003482:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80003486:	2f 08       	sub	r8,-16
80003488:	30 1a       	mov	r10,1
8000348a:	f4 08 09 48 	lsl	r8,r10,r8
8000348e:	5c d8       	com	r8
80003490:	10 69       	and	r9,r8
80003492:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003496:	91 19       	st.w	r8[0x4],r9
	}

	return SPI_OK;
80003498:	30 08       	mov	r8,0
}
8000349a:	10 9c       	mov	r12,r8
8000349c:	2f ed       	sub	sp,-8
8000349e:	e3 cd 80 80 	ldm	sp++,r7,pc

800034a2 <spi_unselectChip>:

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800034a2:	eb cd 40 80 	pushm	r7,lr
800034a6:	1a 97       	mov	r7,sp
800034a8:	20 3d       	sub	sp,12
800034aa:	ef 4c ff f8 	st.w	r7[-8],r12
800034ae:	16 98       	mov	r8,r11
800034b0:	ef 68 ff f4 	st.b	r7[-12],r8
	uint32_t timeout = SPI_TIMEOUT;
800034b4:	e0 68 3a 98 	mov	r8,15000
800034b8:	ef 48 ff fc 	st.w	r7[-4],r8

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800034bc:	c0 f8       	rjmp	800034da <spi_unselectChip+0x38>
		if (!timeout--) {
800034be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034c2:	58 08       	cp.w	r8,0
800034c4:	5f 08       	sreq	r8
800034c6:	5c 58       	castu.b	r8
800034c8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800034cc:	20 19       	sub	r9,1
800034ce:	ef 49 ff fc 	st.w	r7[-4],r9
800034d2:	58 08       	cp.w	r8,0
800034d4:	c0 30       	breq	800034da <spi_unselectChip+0x38>
			return SPI_ERROR_TIMEOUT;
800034d6:	30 18       	mov	r8,1
800034d8:	c1 68       	rjmp	80003504 <spi_unselectChip+0x62>

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800034da:	ee f8 ff f8 	ld.w	r8,r7[-8]
800034de:	70 48       	ld.w	r8,r8[0x10]
800034e0:	e2 18 02 00 	andl	r8,0x200,COH
800034e4:	ce d0       	breq	800034be <spi_unselectChip+0x1c>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800034e6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800034ea:	70 18       	ld.w	r8,r8[0x4]
800034ec:	10 99       	mov	r9,r8
800034ee:	ea 19 00 0f 	orh	r9,0xf
800034f2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800034f6:	91 19       	st.w	r8[0x4],r9

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
800034f8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800034fc:	fc 19 01 00 	movh	r9,0x100
80003500:	91 09       	st.w	r8[0x0],r9

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
#endif

	return SPI_OK;
80003502:	30 08       	mov	r8,0
}
80003504:	10 9c       	mov	r12,r8
80003506:	2f dd       	sub	sp,-12
80003508:	e3 cd 80 80 	ldm	sp++,r7,pc

8000350c <spi_setupChipReg>:

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
8000350c:	eb cd 40 80 	pushm	r7,lr
80003510:	1a 97       	mov	r7,sp
80003512:	20 5d       	sub	sp,20
80003514:	ef 4c ff f4 	st.w	r7[-12],r12
80003518:	ef 4b ff f0 	st.w	r7[-16],r11
8000351c:	ef 4a ff ec 	st.w	r7[-20],r10
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80003520:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003524:	f1 39 00 0c 	ld.ub	r9,r8[12]
80003528:	30 38       	mov	r8,3
8000352a:	f0 09 18 00 	cp.b	r9,r8
8000352e:	e0 8b 00 1d 	brhi	80003568 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
80003532:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003536:	f1 39 00 0b 	ld.ub	r9,r8[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000353a:	30 18       	mov	r8,1
8000353c:	f0 09 18 00 	cp.b	r9,r8
80003540:	e0 8b 00 14 	brhi	80003568 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80003544:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003548:	f1 39 00 08 	ld.ub	r9,r8[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000354c:	30 78       	mov	r8,7
8000354e:	f0 09 18 00 	cp.b	r9,r8
80003552:	e0 88 00 0b 	brls	80003568 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80003556:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000355a:	f1 39 00 08 	ld.ub	r9,r8[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000355e:	31 08       	mov	r8,16
80003560:	f0 09 18 00 	cp.b	r9,r8
80003564:	e0 88 00 04 	brls	8000356c <spi_setupChipReg+0x60>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
80003568:	30 28       	mov	r8,2
8000356a:	c8 d8       	rjmp	80003684 <spi_setupChipReg+0x178>
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
8000356c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003570:	70 18       	ld.w	r8,r8[0x4]
80003572:	ee fb ff ec 	ld.w	r11,r7[-20]
80003576:	10 9c       	mov	r12,r8
80003578:	f0 1f 00 45 	mcall	8000368c <spi_setupChipReg+0x180>
8000357c:	18 98       	mov	r8,r12
8000357e:	ef 48 ff fc 	st.w	r7[-4],r8

	if (baudDiv < 0) {
80003582:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003586:	58 08       	cp.w	r8,0
80003588:	c0 34       	brge	8000358e <spi_setupChipReg+0x82>
		return SPI_ERROR_ARGUMENT;
8000358a:	30 28       	mov	r8,2
8000358c:	c7 c8       	rjmp	80003684 <spi_setupChipReg+0x178>
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
8000358e:	30 08       	mov	r8,0
80003590:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80003594:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003598:	f1 38 00 0c 	ld.ub	r8,r8[12]
8000359c:	a1 98       	lsr	r8,0x1
8000359e:	5c 58       	castu.b	r8
800035a0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800035a4:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800035a8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800035ac:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
800035b0:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800035b4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035b8:	f1 38 00 0c 	ld.ub	r8,r8[12]
800035bc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800035c0:	5f 08       	sreq	r8
800035c2:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800035c6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800035ca:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
800035ce:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800035d2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035d6:	f1 38 00 0b 	ld.ub	r8,r8[11]
800035da:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800035de:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800035e2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800035e6:	f1 d9 d0 61 	bfins	r8,r9,0x3,0x1
800035ea:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800035ee:	ee f8 ff f0 	ld.w	r8,r7[-16]
800035f2:	f1 38 00 08 	ld.ub	r8,r8[8]
800035f6:	20 88       	sub	r8,8
800035f8:	5c 58       	castu.b	r8
800035fa:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800035fe:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003602:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003606:	f1 d9 d0 84 	bfins	r8,r9,0x4,0x4
8000360a:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
8000360e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003612:	5c 58       	castu.b	r8
80003614:	ef 68 ff fa 	st.b	r7[-6],r8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80003618:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000361c:	f1 38 00 09 	ld.ub	r8,r8[9]
80003620:	ef 68 ff f9 	st.b	r7[-7],r8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80003624:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003628:	f1 38 00 0a 	ld.ub	r8,r8[10]
8000362c:	ef 68 ff f8 	st.b	r7[-8],r8

	switch (options->reg) {
80003630:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003634:	11 88       	ld.ub	r8,r8[0x0]
80003636:	58 18       	cp.w	r8,1
80003638:	c1 10       	breq	8000365a <spi_setupChipReg+0x14e>
8000363a:	e0 89 00 05 	brgt	80003644 <spi_setupChipReg+0x138>
8000363e:	58 08       	cp.w	r8,0
80003640:	c0 70       	breq	8000364e <spi_setupChipReg+0x142>
80003642:	c1 e8       	rjmp	8000367e <spi_setupChipReg+0x172>
80003644:	58 28       	cp.w	r8,2
80003646:	c1 00       	breq	80003666 <spi_setupChipReg+0x15a>
80003648:	58 38       	cp.w	r8,3
8000364a:	c1 40       	breq	80003672 <spi_setupChipReg+0x166>
8000364c:	c1 98       	rjmp	8000367e <spi_setupChipReg+0x172>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
8000364e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003652:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003656:	91 c9       	st.w	r8[0x30],r9
		break;
80003658:	c1 58       	rjmp	80003682 <spi_setupChipReg+0x176>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
8000365a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000365e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003662:	91 d9       	st.w	r8[0x34],r9
		break;
80003664:	c0 f8       	rjmp	80003682 <spi_setupChipReg+0x176>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80003666:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000366a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000366e:	91 e9       	st.w	r8[0x38],r9
		break;
80003670:	c0 98       	rjmp	80003682 <spi_setupChipReg+0x176>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80003672:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003676:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000367a:	91 f9       	st.w	r8[0x3c],r9
		break;
8000367c:	c0 38       	rjmp	80003682 <spi_setupChipReg+0x176>

	default:
		return SPI_ERROR_ARGUMENT;
8000367e:	30 28       	mov	r8,2
80003680:	c0 28       	rjmp	80003684 <spi_setupChipReg+0x178>
			}
		}
	}
#endif

	return SPI_OK;
80003682:	30 08       	mov	r8,0
}
80003684:	10 9c       	mov	r12,r8
80003686:	2f bd       	sub	sp,-20
80003688:	e3 cd 80 80 	ldm	sp++,r7,pc
8000368c:	80 00       	ld.sh	r0,r0[0x0]
8000368e:	32 92       	mov	r2,41

80003690 <spi_enable>:

void spi_enable(volatile avr32_spi_t *spi)
{
80003690:	eb cd 40 80 	pushm	r7,lr
80003694:	1a 97       	mov	r7,sp
80003696:	20 1d       	sub	sp,4
80003698:	ef 4c ff fc 	st.w	r7[-4],r12
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000369c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800036a0:	30 19       	mov	r9,1
800036a2:	91 09       	st.w	r8[0x0],r9
}
800036a4:	2f fd       	sub	sp,-4
800036a6:	e3 cd 80 80 	ldm	sp++,r7,pc

800036aa <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
800036aa:	eb cd 40 80 	pushm	r7,lr
800036ae:	1a 97       	mov	r7,sp
800036b0:	20 3d       	sub	sp,12
800036b2:	ef 4c ff f8 	st.w	r7[-8],r12
800036b6:	16 98       	mov	r8,r11
800036b8:	ef 58 ff f4 	st.h	r7[-12],r8
	uint32_t timeout = SPI_TIMEOUT;
800036bc:	e0 68 3a 98 	mov	r8,15000
800036c0:	ef 48 ff fc 	st.w	r7[-4],r8

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800036c4:	c0 f8       	rjmp	800036e2 <spi_write+0x38>
		if (!timeout--) {
800036c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800036ca:	58 08       	cp.w	r8,0
800036cc:	5f 08       	sreq	r8
800036ce:	5c 58       	castu.b	r8
800036d0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800036d4:	20 19       	sub	r9,1
800036d6:	ef 49 ff fc 	st.w	r7[-4],r9
800036da:	58 08       	cp.w	r8,0
800036dc:	c0 30       	breq	800036e2 <spi_write+0x38>
			return SPI_ERROR_TIMEOUT;
800036de:	30 18       	mov	r8,1
800036e0:	c0 d8       	rjmp	800036fa <spi_write+0x50>

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800036e2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800036e6:	70 48       	ld.w	r8,r8[0x10]
800036e8:	e2 18 00 02 	andl	r8,0x2,COH
800036ec:	ce d0       	breq	800036c6 <spi_write+0x1c>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800036ee:	ef 19 ff f4 	ld.uh	r9,r7[-12]
800036f2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800036f6:	91 39       	st.w	r8[0xc],r9

	return SPI_OK;
800036f8:	30 08       	mov	r8,0
}
800036fa:	10 9c       	mov	r12,r8
800036fc:	2f dd       	sub	sp,-12
800036fe:	e3 cd 80 80 	ldm	sp++,r7,pc

80003702 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80003702:	eb cd 40 80 	pushm	r7,lr
80003706:	1a 97       	mov	r7,sp
80003708:	20 3d       	sub	sp,12
8000370a:	ef 4c ff f8 	st.w	r7[-8],r12
8000370e:	ef 4b ff f4 	st.w	r7[-12],r11
	unsigned int timeout = SPI_TIMEOUT;
80003712:	e0 68 3a 98 	mov	r8,15000
80003716:	ef 48 ff fc 	st.w	r7[-4],r8

	while ((spi->sr &
8000371a:	c0 f8       	rjmp	80003738 <spi_read+0x36>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
8000371c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003720:	58 08       	cp.w	r8,0
80003722:	5f 08       	sreq	r8
80003724:	5c 58       	castu.b	r8
80003726:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000372a:	20 19       	sub	r9,1
8000372c:	ef 49 ff fc 	st.w	r7[-4],r9
80003730:	58 08       	cp.w	r8,0
80003732:	c0 30       	breq	80003738 <spi_read+0x36>
			return SPI_ERROR_TIMEOUT;
80003734:	30 18       	mov	r8,1
80003736:	c1 18       	rjmp	80003758 <spi_read+0x56>

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80003738:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000373c:	70 48       	ld.w	r8,r8[0x10]
8000373e:	e2 18 02 01 	andl	r8,0x201,COH
80003742:	e0 48 02 01 	cp.w	r8,513
80003746:	ce b1       	brne	8000371c <spi_read+0x1a>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80003748:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000374c:	70 28       	ld.w	r8,r8[0x8]
8000374e:	5c 88       	casts.h	r8
80003750:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003754:	b2 08       	st.h	r9[0x0],r8

	return SPI_OK;
80003756:	30 08       	mov	r8,0
}
80003758:	10 9c       	mov	r12,r8
8000375a:	2f dd       	sub	sp,-12
8000375c:	e3 cd 80 80 	ldm	sp++,r7,pc

80003760 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern bool sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
80003760:	eb cd 40 80 	pushm	r7,lr
80003764:	1a 97       	mov	r7,sp
	}
#endif

	switch (CONFIG_SYSCLK_SOURCE) {
	case SYSCLK_SRC_RCSYS:
		return OSC_SLOW_NOMINAL_HZ;
80003766:	e0 78 c2 00 	mov	r8,115200

	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
8000376a:	10 9c       	mov	r12,r8
8000376c:	e3 cd 80 80 	ldm	sp++,r7,pc

80003770 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
80003770:	eb cd 40 80 	pushm	r7,lr
80003774:	1a 97       	mov	r7,sp
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_CPU_DIV;
80003776:	f0 1f 00 04 	mcall	80003784 <sysclk_get_cpu_hz+0x14>
8000377a:	18 98       	mov	r8,r12
}
8000377c:	10 9c       	mov	r12,r8
8000377e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003782:	00 00       	add	r0,r0
80003784:	80 00       	ld.sh	r0,r0[0x0]
80003786:	37 60       	mov	r0,118

80003788 <display_init>:

// Include Files
#include "display_init.h"

void display_init(void)
{
80003788:	eb cd 40 8f 	pushm	r0-r3,r7,lr
8000378c:	1a 97       	mov	r7,sp
8000378e:	21 0d       	sub	sp,64
	volatile avr32_pm_t* pm = &AVR32_PM;
80003790:	fe 78 0c 00 	mov	r8,-62464
80003794:	ef 48 ff dc 	st.w	r7[-36],r8
	   .spck_delay           = 0,
	   .trans_delay  		 = 8,
	   .stay_act             = 1,
	   .spi_mode             = 0,
	   .modfdis              = 1
	};
80003798:	4f 68       	lddpc	r8,80003970 <display_init+0x1e8>
8000379a:	ee ca 00 34 	sub	r10,r7,52
8000379e:	10 9b       	mov	r11,r8
800037a0:	f6 e8 00 00 	ld.d	r8,r11[0]
800037a4:	f4 e9 00 00 	st.d	r10[0],r8
800037a8:	f6 e8 00 08 	ld.d	r8,r11[8]
800037ac:	f4 e9 00 08 	st.d	r10[8],r8

	// Switch clock to external 12 MHz crystal
	// 1) Configure OSC0 in crystal mode, external crystal with a FOSC0 Hz frequency.
	pm_enable_osc0_crystal(pm, FOSC0);
800037b0:	e0 6b 1b 00 	mov	r11,6912
800037b4:	ea 1b 00 b7 	orh	r11,0xb7
800037b8:	ee fc ff dc 	ld.w	r12,r7[-36]
800037bc:	f0 1f 00 6e 	mcall	80003974 <display_init+0x1ec>

	// 2) Enable the OSC0
	pm_enable_clk0(pm, OSC0_STARTUP);
800037c0:	30 3b       	mov	r11,3
800037c2:	ee fc ff dc 	ld.w	r12,r7[-36]
800037c6:	f0 1f 00 6d 	mcall	80003978 <display_init+0x1f0>

	// 3) Set the main clock source as being OSC0.
	pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
800037ca:	30 1b       	mov	r11,1
800037cc:	ee fc ff dc 	ld.w	r12,r7[-36]
800037d0:	f0 1f 00 6b 	mcall	8000397c <display_init+0x1f4>

	// Initialize the delay function
	delay_init(12000000);
	// Delay for a ms, to allow the display to power up properly
	delay_ms(1);
800037d4:	f0 1f 00 6b 	mcall	80003980 <display_init+0x1f8>
800037d8:	18 98       	mov	r8,r12
800037da:	30 19       	mov	r9,1
800037dc:	ef 49 ff e4 	st.w	r7[-28],r9
800037e0:	ef 48 ff e0 	st.w	r7[-32],r8
800037e4:	ee f8 ff e4 	ld.w	r8,r7[-28]
800037e8:	ef 48 ff ec 	st.w	r7[-20],r8
800037ec:	ee f8 ff e0 	ld.w	r8,r7[-32]
800037f0:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800037f4:	ee f0 ff ec 	ld.w	r0,r7[-20]
800037f8:	30 01       	mov	r1,0
800037fa:	ee f2 ff e8 	ld.w	r2,r7[-24]
800037fe:	30 03       	mov	r3,0
80003800:	e2 02 02 4a 	mul	r10,r1,r2
80003804:	e6 00 02 48 	mul	r8,r3,r0
80003808:	10 0a       	add	r10,r8
8000380a:	e0 02 06 48 	mulu.d	r8,r0,r2
8000380e:	12 0a       	add	r10,r9
80003810:	14 99       	mov	r9,r10
80003812:	e0 6a 03 e7 	mov	r10,999
80003816:	30 0b       	mov	r11,0
80003818:	f0 0a 00 0a 	add	r10,r8,r10
8000381c:	f2 0b 00 4b 	adc	r11,r9,r11
80003820:	e0 68 03 e8 	mov	r8,1000
80003824:	30 09       	mov	r9,0
80003826:	f0 1f 00 58 	mcall	80003984 <display_init+0x1fc>
8000382a:	14 98       	mov	r8,r10
8000382c:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
8000382e:	ef 48 ff f4 	st.w	r7[-12],r8
80003832:	ee c8 00 40 	sub	r8,r7,64
80003836:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000383a:	e1 b8 00 42 	mfsr	r8,0x108
8000383e:	10 99       	mov	r9,r8
80003840:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003844:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003846:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000384a:	70 09       	ld.w	r9,r8[0x0]
8000384c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003850:	10 09       	add	r9,r8
80003852:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003856:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80003858:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000385c:	30 08       	mov	r8,0
8000385e:	f3 68 00 08 	st.b	r9[8],r8
80003862:	ee c8 00 40 	sub	r8,r7,64
80003866:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000386a:	e1 b8 00 42 	mfsr	r8,0x108
8000386e:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80003872:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003876:	f1 39 00 08 	ld.ub	r9,r8[8]
8000387a:	30 28       	mov	r8,2
8000387c:	f0 09 18 00 	cp.b	r9,r8
80003880:	c0 31       	brne	80003886 <display_init+0xfe>
    return false;
80003882:	30 08       	mov	r8,0
80003884:	c4 38       	rjmp	8000390a <display_init+0x182>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80003886:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000388a:	f1 39 00 08 	ld.ub	r9,r8[8]
8000388e:	30 18       	mov	r8,1
80003890:	f0 09 18 00 	cp.b	r9,r8
80003894:	c0 31       	brne	8000389a <display_init+0x112>
    return true;
80003896:	30 18       	mov	r8,1
80003898:	c3 98       	rjmp	8000390a <display_init+0x182>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000389a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000389e:	70 09       	ld.w	r9,r8[0x0]
800038a0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800038a4:	70 18       	ld.w	r8,r8[0x4]
800038a6:	10 39       	cp.w	r9,r8
800038a8:	e0 88 00 1a 	brls	800038dc <display_init+0x154>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800038ac:	ee f8 ff f8 	ld.w	r8,r7[-8]
800038b0:	70 08       	ld.w	r8,r8[0x0]
800038b2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800038b6:	10 39       	cp.w	r9,r8
800038b8:	c1 02       	brcc	800038d8 <display_init+0x150>
800038ba:	ee f8 ff f8 	ld.w	r8,r7[-8]
800038be:	70 18       	ld.w	r8,r8[0x4]
800038c0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800038c4:	10 39       	cp.w	r9,r8
800038c6:	e0 88 00 09 	brls	800038d8 <display_init+0x150>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800038ca:	ee f9 ff f8 	ld.w	r9,r7[-8]
800038ce:	30 18       	mov	r8,1
800038d0:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800038d4:	30 18       	mov	r8,1
800038d6:	c1 a8       	rjmp	8000390a <display_init+0x182>
    }
    return false;
800038d8:	30 08       	mov	r8,0
800038da:	c1 88       	rjmp	8000390a <display_init+0x182>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800038dc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800038e0:	70 08       	ld.w	r8,r8[0x0]
800038e2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800038e6:	10 39       	cp.w	r9,r8
800038e8:	c0 93       	brcs	800038fa <display_init+0x172>
800038ea:	ee f8 ff f8 	ld.w	r8,r7[-8]
800038ee:	70 18       	ld.w	r8,r8[0x4]
800038f0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800038f4:	10 39       	cp.w	r9,r8
800038f6:	e0 88 00 09 	brls	80003908 <display_init+0x180>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800038fa:	ee f9 ff f8 	ld.w	r9,r7[-8]
800038fe:	30 18       	mov	r8,1
80003900:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80003904:	30 18       	mov	r8,1
80003906:	c0 28       	rjmp	8000390a <display_init+0x182>
    }
    return false;
80003908:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
8000390a:	58 08       	cp.w	r8,0
8000390c:	ca b0       	breq	80003862 <display_init+0xda>

	// Enable the SPI peripheral on GPIO pins
	gpio_enable_module(DIP204_SPI_GPIO_MAP,
8000390e:	30 4b       	mov	r11,4
80003910:	49 ec       	lddpc	r12,80003988 <display_init+0x200>
80003912:	f0 1f 00 1f 	mcall	8000398c <display_init+0x204>
						sizeof(DIP204_SPI_GPIO_MAP) / 	sizeof(DIP204_SPI_GPIO_MAP[0]));

	// Initialize as SPI master
	spi_initMaster(DIP204_SPI, &spiOptions);
80003916:	ee c8 00 34 	sub	r8,r7,52
8000391a:	10 9b       	mov	r11,r8
8000391c:	fe 7c 28 00 	mov	r12,-55296
80003920:	f0 1f 00 1c 	mcall	80003990 <display_init+0x208>
	spi_selectionMode(DIP204_SPI, 0, 0, 0);
80003924:	30 09       	mov	r9,0
80003926:	30 0a       	mov	r10,0
80003928:	30 0b       	mov	r11,0
8000392a:	fe 7c 28 00 	mov	r12,-55296
8000392e:	f0 1f 00 1a 	mcall	80003994 <display_init+0x20c>
	spi_enable(DIP204_SPI);
80003932:	fe 7c 28 00 	mov	r12,-55296
80003936:	f0 1f 00 19 	mcall	80003998 <display_init+0x210>
	spi_setupChipReg(DIP204_SPI, &spiOptions, FOSC0);
8000393a:	ee c8 00 34 	sub	r8,r7,52
8000393e:	e0 6a 1b 00 	mov	r10,6912
80003942:	ea 1a 00 b7 	orh	r10,0xb7
80003946:	10 9b       	mov	r11,r8
80003948:	fe 7c 28 00 	mov	r12,-55296
8000394c:	f0 1f 00 14 	mcall	8000399c <display_init+0x214>

	dip204_init(backlight_IO, ON);
80003950:	30 1b       	mov	r11,1
80003952:	30 0c       	mov	r12,0
80003954:	f0 1f 00 13 	mcall	800039a0 <display_init+0x218>
	dip204_clear_display();
80003958:	f0 1f 00 13 	mcall	800039a4 <display_init+0x21c>
	dip204_hide_cursor();
8000395c:	f0 1f 00 13 	mcall	800039a8 <display_init+0x220>
	dip204_set_cursor_position(1,1);
80003960:	30 1b       	mov	r11,1
80003962:	30 1c       	mov	r12,1
80003964:	f0 1f 00 12 	mcall	800039ac <display_init+0x224>
}
80003968:	2f 0d       	sub	sp,-64
8000396a:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
8000396e:	00 00       	add	r0,r0
80003970:	80 00       	ld.sh	r0,r0[0x0]
80003972:	c8 18       	rjmp	80003a74 <initLED+0xc4>
80003974:	80 00       	ld.sh	r0,r0[0x0]
80003976:	47 ac       	lddsp	r12,sp[0x1e8]
80003978:	80 00       	ld.sh	r0,r0[0x0]
8000397a:	48 10       	lddpc	r0,8000397c <display_init+0x1f4>
8000397c:	80 00       	ld.sh	r0,r0[0x0]
8000397e:	48 bc       	lddpc	r12,800039a8 <display_init+0x220>
80003980:	80 00       	ld.sh	r0,r0[0x0]
80003982:	37 70       	mov	r0,119
80003984:	80 00       	ld.sh	r0,r0[0x0]
80003986:	6a 78       	ld.w	r8,r5[0x1c]
80003988:	80 00       	ld.sh	r0,r0[0x0]
8000398a:	c8 28       	rjmp	80003a8e <initLED+0xde>
8000398c:	80 00       	ld.sh	r0,r0[0x0]
8000398e:	43 18       	lddsp	r8,sp[0xc4]
80003990:	80 00       	ld.sh	r0,r0[0x0]
80003992:	32 e2       	mov	r2,46
80003994:	80 00       	ld.sh	r0,r0[0x0]
80003996:	33 76       	mov	r6,55
80003998:	80 00       	ld.sh	r0,r0[0x0]
8000399a:	36 90       	mov	r0,105
8000399c:	80 00       	ld.sh	r0,r0[0x0]
8000399e:	35 0c       	mov	r12,80
800039a0:	80 00       	ld.sh	r0,r0[0x0]
800039a2:	21 08       	sub	r8,16
800039a4:	80 00       	ld.sh	r0,r0[0x0]
800039a6:	2c a0       	sub	r0,-54
800039a8:	80 00       	ld.sh	r0,r0[0x0]
800039aa:	2b e4       	sub	r4,-66
800039ac:	80 00       	ld.sh	r0,r0[0x0]
800039ae:	2c 18       	sub	r8,-63

800039b0 <initLED>:
#include "LED.h"

void initLED (void)
{
800039b0:	eb cd 40 80 	pushm	r7,lr
800039b4:	1a 97       	mov	r7,sp
800039b6:	20 1d       	sub	sp,4
	/*
	* First make access to the GPIO port registers
	* shorter to type , just for our convenience
	*/
	volatile avr32_gpio_port_t * led0_port;
	led0_port = &AVR32_GPIO.port[LED0_PORT];
800039b8:	fe 78 11 00 	mov	r8,-61184
800039bc:	ef 48 ff fc 	st.w	r7[-4],r8
	/*
	* Choose GPIO peripheral function ,
	* by writing a 1 to gpers , GPIO Enable Register Set
	*/
	led0_port->gpers = LED0_BIT_VALUE;
800039c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039c4:	fc 19 08 00 	movh	r9,0x800
800039c8:	91 19       	st.w	r8[0x4],r9
	led0_port->gpers = LED1_BIT_VALUE;
800039ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039ce:	fc 19 10 00 	movh	r9,0x1000
800039d2:	91 19       	st.w	r8[0x4],r9
	led0_port->gpers = LED2_BIT_VALUE;
800039d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039d8:	fc 19 20 00 	movh	r9,0x2000
800039dc:	91 19       	st.w	r8[0x4],r9
	/*
	* Set the output value register to 1 in order to
	* turn the LED off (1= off , 0= on in this case ) ,
	* by writing a 1 to ovrs , Output Value Register Set
	*/
	led0_port->ovrs = LED0_BIT_VALUE;
800039de:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039e2:	fc 19 08 00 	movh	r9,0x800
800039e6:	f1 49 00 54 	st.w	r8[84],r9
	led0_port->ovrs = LED1_BIT_VALUE;
800039ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039ee:	fc 19 10 00 	movh	r9,0x1000
800039f2:	f1 49 00 54 	st.w	r8[84],r9
	led0_port->ovrs = LED2_BIT_VALUE;
800039f6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039fa:	fc 19 20 00 	movh	r9,0x2000
800039fe:	f1 49 00 54 	st.w	r8[84],r9
	/*
	* Set the output enable register ,
	* by writing a 1 to oders , Output Drive Enable
	* Register Set
	*/
	led0_port->oders = LED0_BIT_VALUE;
80003a02:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a06:	fc 19 08 00 	movh	r9,0x800
80003a0a:	f1 49 00 44 	st.w	r8[68],r9
	led0_port->oders = LED1_BIT_VALUE;
80003a0e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a12:	fc 19 10 00 	movh	r9,0x1000
80003a16:	f1 49 00 44 	st.w	r8[68],r9
	led0_port->oders = LED2_BIT_VALUE;
80003a1a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a1e:	fc 19 20 00 	movh	r9,0x2000
80003a22:	f1 49 00 44 	st.w	r8[68],r9
}
80003a26:	2f fd       	sub	sp,-4
80003a28:	e3 cd 80 80 	ldm	sp++,r7,pc
80003a2c:	50 6f       	stdsp	sp[0x18],pc
80003a2e:	74 20       	ld.w	r0,r10[0x8]
80003a30:	74 61       	ld.w	r1,r10[0x18]
80003a32:	72 20       	ld.w	r0,r9[0x8]
80003a34:	6d 75       	ld.w	r5,r6[0x5c]
80003a36:	74 65       	ld.w	r5,r10[0x18]
80003a38:	78 00       	ld.w	r0,r12[0x0]
80003a3a:	00 00       	add	r0,r0
80003a3c:	70 6f       	ld.w	pc,r8[0x18]
80003a3e:	74 20       	ld.w	r0,r10[0x8]
80003a40:	6c e4       	ld.w	r4,r6[0x38]
80003a42:	6d 6e       	ld.w	lr,r6[0x58]
80003a44:	61 72       	ld.w	r2,r0[0x5c]
80003a46:	20 6d       	sub	sp,24
80003a48:	75 74       	ld.w	r4,r10[0x5c]
80003a4a:	65 78       	ld.w	r8,r2[0x5c]
80003a4c:	00 00       	add	r0,r0
80003a4e:	00 00       	add	r0,r0
80003a50:	74 65       	ld.w	r5,r10[0x18]
80003a52:	6d 70       	ld.w	r0,r6[0x5c]
80003a54:	20 74       	sub	r4,7
80003a56:	61 72       	ld.w	r2,r0[0x5c]
80003a58:	20 6d       	sub	sp,24
80003a5a:	75 74       	ld.w	r4,r10[0x5c]
80003a5c:	65 78       	ld.w	r8,r2[0x5c]
80003a5e:	00 00       	add	r0,r0
80003a60:	74 65       	ld.w	r5,r10[0x18]
80003a62:	6d 70       	ld.w	r0,r6[0x5c]
80003a64:	20 6c       	sub	r12,6
80003a66:	e4 6d 6e 61 	mov	sp,290401
80003a6a:	72 20       	ld.w	r0,r9[0x8]
80003a6c:	6d 75       	ld.w	r5,r6[0x5c]
80003a6e:	74 65       	ld.w	r5,r10[0x18]
80003a70:	78 00       	ld.w	r0,r12[0x0]
80003a72:	00 00       	add	r0,r0
80003a74:	4c 69       	lddpc	r9,80003b8c <init_usart+0x28>
80003a76:	67 68       	ld.w	r8,r3[0x58]
80003a78:	74 20       	ld.w	r0,r10[0x8]
80003a7a:	74 61       	ld.w	r1,r10[0x18]
80003a7c:	72 20       	ld.w	r0,r9[0x8]
80003a7e:	6d 75       	ld.w	r5,r6[0x5c]
80003a80:	74 65       	ld.w	r5,r10[0x18]
80003a82:	78 00       	ld.w	r0,r12[0x0]
80003a84:	4c 69       	lddpc	r9,80003b9c <init_usart+0x38>
80003a86:	67 68       	ld.w	r8,r3[0x58]
80003a88:	74 20       	ld.w	r0,r10[0x8]
80003a8a:	6c e4       	ld.w	r4,r6[0x38]
80003a8c:	6d 6e       	ld.w	lr,r6[0x58]
80003a8e:	61 72       	ld.w	r2,r0[0x5c]
80003a90:	20 6d       	sub	sp,24
80003a92:	75 74       	ld.w	r4,r10[0x5c]
80003a94:	65 78       	ld.w	r8,r2[0x5c]
80003a96:	00 00       	add	r0,r0
80003a98:	4c 43       	lddpc	r3,80003ba8 <init_usart+0x44>
80003a9a:	44 20       	lddsp	r0,sp[0x108]
80003a9c:	74 61       	ld.w	r1,r10[0x18]
80003a9e:	72 20       	ld.w	r0,r9[0x8]
80003aa0:	6d 75       	ld.w	r5,r6[0x5c]
80003aa2:	74 65       	ld.w	r5,r10[0x18]
80003aa4:	78 00       	ld.w	r0,r12[0x0]
80003aa6:	00 00       	add	r0,r0
80003aa8:	50 6f       	stdsp	sp[0x18],pc
80003aaa:	74 65       	ld.w	r5,r10[0x18]
80003aac:	6e 74       	ld.w	r4,r7[0x1c]
80003aae:	69 6f       	ld.w	pc,r4[0x58]
80003ab0:	6d 65       	ld.w	r5,r6[0x58]
80003ab2:	74 65       	ld.w	r5,r10[0x18]
80003ab4:	72 3a       	ld.w	r10,r9[0xc]
80003ab6:	20 25       	sub	r5,2
80003ab8:	30 33       	mov	r3,3
80003aba:	64 00       	ld.w	r0,r2[0x0]
80003abc:	50 6f       	stdsp	sp[0x18],pc
80003abe:	74 65       	ld.w	r5,r10[0x18]
80003ac0:	6e 74       	ld.w	r4,r7[0x1c]
80003ac2:	69 6f       	ld.w	pc,r4[0x58]
80003ac4:	6d 65       	ld.w	r5,r6[0x58]
80003ac6:	74 65       	ld.w	r5,r10[0x18]
80003ac8:	72 3a       	ld.w	r10,r9[0xc]
80003aca:	20 25       	sub	r5,2
80003acc:	64 2c       	ld.w	r12,r2[0x8]
80003ace:	20 00       	sub	r0,0
80003ad0:	54 65       	stdsp	sp[0x118],r5
80003ad2:	6d 70       	ld.w	r0,r6[0x5c]
80003ad4:	65 72       	ld.w	r2,r2[0x5c]
80003ad6:	61 74       	ld.w	r4,r0[0x5c]
80003ad8:	75 72       	ld.w	r2,r10[0x5c]
80003ada:	65 3a       	ld.w	r10,r2[0x4c]
80003adc:	20 25       	sub	r5,2
80003ade:	30 33       	mov	r3,3
80003ae0:	64 00       	ld.w	r0,r2[0x0]
80003ae2:	00 00       	add	r0,r0
80003ae4:	54 65       	stdsp	sp[0x118],r5
80003ae6:	6d 70       	ld.w	r0,r6[0x5c]
80003ae8:	65 72       	ld.w	r2,r2[0x5c]
80003aea:	61 74       	ld.w	r4,r0[0x5c]
80003aec:	75 72       	ld.w	r2,r10[0x5c]
80003aee:	65 3a       	ld.w	r10,r2[0x4c]
80003af0:	20 25       	sub	r5,2
80003af2:	64 2c       	ld.w	r12,r2[0x8]
80003af4:	20 00       	sub	r0,0
80003af6:	00 00       	add	r0,r0
80003af8:	4c 69       	lddpc	r9,80003c10 <vPotentiometer+0x44>
80003afa:	67 68       	ld.w	r8,r3[0x58]
80003afc:	74 3a       	ld.w	r10,r10[0xc]
80003afe:	20 25       	sub	r5,2
80003b00:	30 34       	mov	r4,3
80003b02:	64 00       	ld.w	r0,r2[0x0]
80003b04:	4c 69       	lddpc	r9,80003c1c <vPotentiometer+0x50>
80003b06:	67 68       	ld.w	r8,r3[0x58]
80003b08:	74 3a       	ld.w	r10,r10[0xc]
80003b0a:	20 25       	sub	r5,2
80003b0c:	64 00       	ld.w	r0,r2[0x0]
80003b0e:	00 00       	add	r0,r0
80003b10:	0d 00       	ld.w	r0,r6++
80003b12:	00 00       	add	r0,r0
80003b14:	1b 5b       	ld.sh	r11,--sp
80003b16:	32 4a       	mov	r10,36
80003b18:	00 00       	add	r0,r0
80003b1a:	00 00       	add	r0,r0
80003b1c:	4c 43       	lddpc	r3,80003c2c <vPotentiometer+0x60>
80003b1e:	44 20       	lddsp	r0,sp[0x108]
80003b20:	6c e4       	ld.w	r4,r6[0x38]
80003b22:	6d 6e       	ld.w	lr,r6[0x58]
80003b24:	61 72       	ld.w	r2,r0[0x5c]
80003b26:	20 6d       	sub	sp,24
80003b28:	75 74       	ld.w	r4,r10[0x5c]
80003b2a:	65 78       	ld.w	r8,r2[0x5c]
80003b2c:	00 00       	add	r0,r0
80003b2e:	00 00       	add	r0,r0
80003b30:	76 50       	ld.w	r0,r11[0x14]
80003b32:	6f 74       	ld.w	r4,r7[0x5c]
80003b34:	65 6e       	ld.w	lr,r2[0x58]
80003b36:	74 69       	ld.w	r9,r10[0x18]
80003b38:	6f 6d       	ld.w	sp,r7[0x58]
80003b3a:	65 74       	ld.w	r4,r2[0x5c]
80003b3c:	65 72       	ld.w	r2,r2[0x5c]
80003b3e:	00 00       	add	r0,r0
80003b40:	76 54       	ld.w	r4,r11[0x14]
80003b42:	65 6d       	ld.w	sp,r2[0x58]
80003b44:	70 65       	ld.w	r5,r8[0x18]
80003b46:	72 61       	ld.w	r1,r9[0x18]
80003b48:	74 75       	ld.w	r5,r10[0x1c]
80003b4a:	72 65       	ld.w	r5,r9[0x18]
80003b4c:	00 00       	add	r0,r0
80003b4e:	00 00       	add	r0,r0
80003b50:	76 4c       	ld.w	r12,r11[0x10]
80003b52:	69 67       	ld.w	r7,r4[0x58]
80003b54:	68 74       	ld.w	r4,r4[0x1c]
80003b56:	00 00       	add	r0,r0
80003b58:	76 4c       	ld.w	r12,r11[0x10]
80003b5a:	43 44       	lddsp	r4,sp[0xd0]
80003b5c:	57 72       	stdsp	sp[0x1dc],r2
80003b5e:	69 74       	ld.w	r4,r4[0x5c]
80003b60:	65 00       	ld.w	r0,r2[0x40]
	...

80003b64 <init_usart>:
		volatile int sensor_value;
		volatile int ID;
		};

void init_usart ( void )
{
80003b64:	eb cd 40 80 	pushm	r7,lr
80003b68:	1a 97       	mov	r7,sp
		. charlength = 8,
		. paritytype = USART_NO_PARITY ,
		. stopbits = USART_1_STOPBIT ,
		. channelmode = USART_NORMAL_CHMODE
	};
	pm_switch_to_osc0 (& AVR32_PM , FOSC0 , OSC0_STARTUP );				// Switch to 12 MHz clock
80003b6a:	30 3a       	mov	r10,3
80003b6c:	e0 6b 1b 00 	mov	r11,6912
80003b70:	ea 1b 00 b7 	orh	r11,0xb7
80003b74:	fe 7c 0c 00 	mov	r12,-62464
80003b78:	f0 1f 00 0f 	mcall	80003bb4 <init_usart+0x50>
	gpio_enable_module ( USART_SERIAL_GPIO_MAP , 2);					// Enable usart
80003b7c:	30 2b       	mov	r11,2
80003b7e:	48 fc       	lddpc	r12,80003bb8 <init_usart+0x54>
80003b80:	f0 1f 00 0f 	mcall	80003bbc <init_usart+0x58>
	gpio_enable_module ( USART_DEBUG_GPIO_MAP , 2);
80003b84:	30 2b       	mov	r11,2
80003b86:	48 fc       	lddpc	r12,80003bc0 <init_usart+0x5c>
80003b88:	f0 1f 00 0d 	mcall	80003bbc <init_usart+0x58>
	usart_init_rs232 ( serialPORT_USART , & USART_OPTIONS , FOSC0 );	// Usart options
80003b8c:	e0 6a 1b 00 	mov	r10,6912
80003b90:	ea 1a 00 b7 	orh	r10,0xb7
80003b94:	48 cb       	lddpc	r11,80003bc4 <init_usart+0x60>
80003b96:	fe 7c 18 00 	mov	r12,-59392
80003b9a:	f0 1f 00 0c 	mcall	80003bc8 <init_usart+0x64>
	usart_init_rs232 ( configDBG_USART , & USART_OPTIONS , FOSC0 );
80003b9e:	e0 6a 1b 00 	mov	r10,6912
80003ba2:	ea 1a 00 b7 	orh	r10,0xb7
80003ba6:	48 8b       	lddpc	r11,80003bc4 <init_usart+0x60>
80003ba8:	fe 7c 18 00 	mov	r12,-59392
80003bac:	f0 1f 00 07 	mcall	80003bc8 <init_usart+0x64>
}
80003bb0:	e3 cd 80 80 	ldm	sp++,r7,pc
80003bb4:	80 00       	ld.sh	r0,r0[0x0]
80003bb6:	49 08       	lddpc	r8,80003bf4 <vPotentiometer+0x28>
80003bb8:	80 00       	ld.sh	r0,r0[0x0]
80003bba:	c8 48       	rjmp	80003cc2 <vPotentiometer+0xf6>
80003bbc:	80 00       	ld.sh	r0,r0[0x0]
80003bbe:	43 18       	lddsp	r8,sp[0xc4]
80003bc0:	80 00       	ld.sh	r0,r0[0x0]
80003bc2:	c8 58       	rjmp	80003ccc <vTemperature>
80003bc4:	80 00       	ld.sh	r0,r0[0x0]
80003bc6:	c8 68       	rjmp	80003cd2 <vTemperature+0x6>
80003bc8:	80 00       	ld.sh	r0,r0[0x0]
80003bca:	4a b8       	lddpc	r8,80003c74 <vPotentiometer+0xa8>

80003bcc <vPotentiometer>:

// Potentiometer task which acts as a producer
void vPotentiometer( void *pvParameters )
{
80003bcc:	eb cd 40 80 	pushm	r7,lr
80003bd0:	1a 97       	mov	r7,sp
80003bd2:	20 3d       	sub	sp,12
80003bd4:	ef 4c ff f4 	st.w	r7[-12],r12
	volatile struct sensor_struct pot_struct;
	while(1)
	{
		// Start a ADC sampling of all active channels
		adc_start(&AVR32_ADC);		
80003bd8:	fe 7c 3c 00 	mov	r12,-50176
80003bdc:	f0 1f 00 2f 	mcall	80003c98 <vPotentiometer+0xcc>
		
		// Polling for semaphore EmptyCount before getting access to queue (removes value from semaphore) 
		if(xSemaphoreTake(xEmptyCount, (portTickType)portMAX_DELAY) == pdTRUE)
80003be0:	4a f8       	lddpc	r8,80003c9c <vPotentiometer+0xd0>
80003be2:	70 08       	ld.w	r8,r8[0x0]
80003be4:	30 09       	mov	r9,0
80003be6:	3f fa       	mov	r10,-1
80003be8:	30 0b       	mov	r11,0
80003bea:	10 9c       	mov	r12,r8
80003bec:	f0 1f 00 2d 	mcall	80003ca0 <vPotentiometer+0xd4>
		{
			// Semaphore taken
		}
		if(xSemaphoreTake(xMutex,(portTickType)portMAX_DELAY) == pdTRUE)
80003bf0:	4a d8       	lddpc	r8,80003ca4 <vPotentiometer+0xd8>
80003bf2:	70 08       	ld.w	r8,r8[0x0]
80003bf4:	30 09       	mov	r9,0
80003bf6:	3f fa       	mov	r10,-1
80003bf8:	30 0b       	mov	r11,0
80003bfa:	10 9c       	mov	r12,r8
80003bfc:	f0 1f 00 29 	mcall	80003ca0 <vPotentiometer+0xd4>
80003c00:	18 98       	mov	r8,r12
80003c02:	58 18       	cp.w	r8,1
80003c04:	c0 61       	brne	80003c10 <vPotentiometer+0x44>
		{
			usart_write_line(serialPORT_USART, "Pot tar mutex");
80003c06:	4a 9b       	lddpc	r11,80003ca8 <vPotentiometer+0xdc>
80003c08:	fe 7c 18 00 	mov	r12,-59392
80003c0c:	f0 1f 00 28 	mcall	80003cac <vPotentiometer+0xe0>
		}
		// Get the potentiometer value
		pot_struct.sensor_value = adc_get_value(&AVR32_ADC, ADC_POTENTIOMETER_CHANNEL);
80003c10:	30 1b       	mov	r11,1
80003c12:	fe 7c 3c 00 	mov	r12,-50176
80003c16:	f0 1f 00 27 	mcall	80003cb0 <vPotentiometer+0xe4>
80003c1a:	18 98       	mov	r8,r12
80003c1c:	ef 48 ff f8 	st.w	r7[-8],r8
		// Convert the potentiometer value to a value btwn 0-255
		pot_struct.sensor_value = pot_struct.sensor_value * 255 / 1024;
80003c20:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003c24:	12 98       	mov	r8,r9
80003c26:	a9 68       	lsl	r8,0x8
80003c28:	12 18       	sub	r8,r9
80003c2a:	f0 c9 fc 01 	sub	r9,r8,-1023
80003c2e:	58 08       	cp.w	r8,0
80003c30:	f2 08 17 50 	movlt	r8,r9
80003c34:	ab 48       	asr	r8,0xa
80003c36:	ef 48 ff f8 	st.w	r7[-8],r8
		pot_struct.ID = 0;
80003c3a:	30 08       	mov	r8,0
80003c3c:	ef 48 ff fc 	st.w	r7[-4],r8
		
		LED_Set_Intensity(LED5, pot_struct.sensor_value); //Green light
80003c40:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003c44:	5c 58       	castu.b	r8
80003c46:	10 9b       	mov	r11,r8
80003c48:	32 0c       	mov	r12,32
80003c4a:	f0 1f 00 1b 	mcall	80003cb4 <vPotentiometer+0xe8>
		
		// Put the value on the queue
		xQueueSendToBack(xQHandle, &pot_struct, (portTickType)10);
80003c4e:	49 b8       	lddpc	r8,80003cb8 <vPotentiometer+0xec>
80003c50:	70 08       	ld.w	r8,r8[0x0]
80003c52:	ee cb 00 08 	sub	r11,r7,8
80003c56:	30 09       	mov	r9,0
80003c58:	30 aa       	mov	r10,10
80003c5a:	10 9c       	mov	r12,r8
80003c5c:	f0 1f 00 18 	mcall	80003cbc <vPotentiometer+0xf0>
		
		if(xSemaphoreGive(xMutex) == pdTRUE)
80003c60:	49 18       	lddpc	r8,80003ca4 <vPotentiometer+0xd8>
80003c62:	70 08       	ld.w	r8,r8[0x0]
80003c64:	30 09       	mov	r9,0
80003c66:	30 0a       	mov	r10,0
80003c68:	30 0b       	mov	r11,0
80003c6a:	10 9c       	mov	r12,r8
80003c6c:	f0 1f 00 14 	mcall	80003cbc <vPotentiometer+0xf0>
80003c70:	18 98       	mov	r8,r12
80003c72:	58 18       	cp.w	r8,1
80003c74:	c0 61       	brne	80003c80 <vPotentiometer+0xb4>
		{
			usart_write_line(serialPORT_USART, "pot lmnar mutex");
80003c76:	49 3b       	lddpc	r11,80003cc0 <vPotentiometer+0xf4>
80003c78:	fe 7c 18 00 	mov	r12,-59392
80003c7c:	f0 1f 00 0c 	mcall	80003cac <vPotentiometer+0xe0>
		}
		// Give the semaphore FillCount (adds value to semaphore) 
		if(xSemaphoreGive(xFillCount) == pdTRUE)
80003c80:	49 18       	lddpc	r8,80003cc4 <vPotentiometer+0xf8>
80003c82:	70 08       	ld.w	r8,r8[0x0]
80003c84:	30 09       	mov	r9,0
80003c86:	30 0a       	mov	r10,0
80003c88:	30 0b       	mov	r11,0
80003c8a:	10 9c       	mov	r12,r8
80003c8c:	f0 1f 00 0c 	mcall	80003cbc <vPotentiometer+0xf0>
		{
			// Semaphore given
		}
		// Delay
		vTaskDelay(TASK_DELAY_MS(50));
80003c90:	33 2c       	mov	r12,50
80003c92:	f0 1f 00 0e 	mcall	80003cc8 <vPotentiometer+0xfc>
	}
80003c96:	ca 1b       	rjmp	80003bd8 <vPotentiometer+0xc>
80003c98:	80 00       	ld.sh	r0,r0[0x0]
80003c9a:	30 66       	mov	r6,6
80003c9c:	00 00       	add	r0,r0
80003c9e:	07 e4       	ld.ub	r4,r3[0x6]
80003ca0:	80 00       	ld.sh	r0,r0[0x0]
80003ca2:	58 b0       	cp.w	r0,11
80003ca4:	00 00       	add	r0,r0
80003ca6:	07 e8       	ld.ub	r8,r3[0x6]
80003ca8:	80 00       	ld.sh	r0,r0[0x0]
80003caa:	3a 2c       	mov	r12,-94
80003cac:	80 00       	ld.sh	r0,r0[0x0]
80003cae:	4d 58       	lddpc	r8,80003e00 <vLight+0x60>
80003cb0:	80 00       	ld.sh	r0,r0[0x0]
80003cb2:	30 dc       	mov	r12,13
80003cb4:	80 00       	ld.sh	r0,r0[0x0]
80003cb6:	41 b0       	lddsp	r0,sp[0x6c]
80003cb8:	00 00       	add	r0,r0
80003cba:	07 e0       	ld.ub	r0,r3[0x6]
80003cbc:	80 00       	ld.sh	r0,r0[0x0]
80003cbe:	57 48       	stdsp	sp[0x1d0],r8
80003cc0:	80 00       	ld.sh	r0,r0[0x0]
80003cc2:	3a 3c       	mov	r12,-93
80003cc4:	00 00       	add	r0,r0
80003cc6:	07 dc       	ld.ub	r12,r3[0x5]
80003cc8:	80 00       	ld.sh	r0,r0[0x0]
80003cca:	5f 20       	srhs	r0

80003ccc <vTemperature>:
}

// Temperature task which acts as a producer
void vTemperature( void *pvParameters )
{
80003ccc:	eb cd 40 80 	pushm	r7,lr
80003cd0:	1a 97       	mov	r7,sp
80003cd2:	20 3d       	sub	sp,12
80003cd4:	ef 4c ff f4 	st.w	r7[-12],r12
	volatile struct sensor_struct temp_struct;
	while (1)
	{
		// Start a ADC sampling of all active channels
		adc_start(&AVR32_ADC);
80003cd8:	fe 7c 3c 00 	mov	r12,-50176
80003cdc:	f0 1f 00 25 	mcall	80003d70 <vTemperature+0xa4>
		
		// Polling for semaphore EmptyCount before getting access to queue (removes value from semaphore)
		if(xSemaphoreTake(xEmptyCount, (portTickType)portMAX_DELAY) == pdTRUE)
80003ce0:	4a 58       	lddpc	r8,80003d74 <vTemperature+0xa8>
80003ce2:	70 08       	ld.w	r8,r8[0x0]
80003ce4:	30 09       	mov	r9,0
80003ce6:	3f fa       	mov	r10,-1
80003ce8:	30 0b       	mov	r11,0
80003cea:	10 9c       	mov	r12,r8
80003cec:	f0 1f 00 23 	mcall	80003d78 <vTemperature+0xac>
		{
			// Semaphore taken
		}
		if(xSemaphoreTake(xMutex,(portTickType)portMAX_DELAY) == pdTRUE)
80003cf0:	4a 38       	lddpc	r8,80003d7c <vTemperature+0xb0>
80003cf2:	70 08       	ld.w	r8,r8[0x0]
80003cf4:	30 09       	mov	r9,0
80003cf6:	3f fa       	mov	r10,-1
80003cf8:	30 0b       	mov	r11,0
80003cfa:	10 9c       	mov	r12,r8
80003cfc:	f0 1f 00 1f 	mcall	80003d78 <vTemperature+0xac>
80003d00:	18 98       	mov	r8,r12
80003d02:	58 18       	cp.w	r8,1
80003d04:	c0 61       	brne	80003d10 <vTemperature+0x44>
		{
			usart_write_line(serialPORT_USART, "temp tar mutex");
80003d06:	49 fb       	lddpc	r11,80003d80 <vTemperature+0xb4>
80003d08:	fe 7c 18 00 	mov	r12,-59392
80003d0c:	f0 1f 00 1e 	mcall	80003d84 <vTemperature+0xb8>
		}

		//Get the temperature value
		temp_struct.sensor_value = adc_get_value(&AVR32_ADC, ADC_TEMPERATURE_CHANNEL);
80003d10:	30 0b       	mov	r11,0
80003d12:	fe 7c 3c 00 	mov	r12,-50176
80003d16:	f0 1f 00 1d 	mcall	80003d88 <vTemperature+0xbc>
80003d1a:	18 98       	mov	r8,r12
80003d1c:	ef 48 ff f8 	st.w	r7[-8],r8
		temp_struct.ID = 1;
80003d20:	30 18       	mov	r8,1
80003d22:	ef 48 ff fc 	st.w	r7[-4],r8

		// Put the value on the queue
		xQueueSendToBack(xQHandle, &temp_struct, (portTickType)10);
80003d26:	49 a8       	lddpc	r8,80003d8c <vTemperature+0xc0>
80003d28:	70 08       	ld.w	r8,r8[0x0]
80003d2a:	ee cb 00 08 	sub	r11,r7,8
80003d2e:	30 09       	mov	r9,0
80003d30:	30 aa       	mov	r10,10
80003d32:	10 9c       	mov	r12,r8
80003d34:	f0 1f 00 17 	mcall	80003d90 <vTemperature+0xc4>
		
		if(xSemaphoreGive(xMutex) == pdTRUE)
80003d38:	49 18       	lddpc	r8,80003d7c <vTemperature+0xb0>
80003d3a:	70 08       	ld.w	r8,r8[0x0]
80003d3c:	30 09       	mov	r9,0
80003d3e:	30 0a       	mov	r10,0
80003d40:	30 0b       	mov	r11,0
80003d42:	10 9c       	mov	r12,r8
80003d44:	f0 1f 00 13 	mcall	80003d90 <vTemperature+0xc4>
80003d48:	18 98       	mov	r8,r12
80003d4a:	58 18       	cp.w	r8,1
80003d4c:	c0 61       	brne	80003d58 <vTemperature+0x8c>
		{
			usart_write_line(serialPORT_USART, "temp lmnar mutex");
80003d4e:	49 2b       	lddpc	r11,80003d94 <vTemperature+0xc8>
80003d50:	fe 7c 18 00 	mov	r12,-59392
80003d54:	f0 1f 00 0c 	mcall	80003d84 <vTemperature+0xb8>
		}
		// Give the semaphore FillCount (adds value to semaphore)
		if(xSemaphoreGive(xFillCount) == pdTRUE)
80003d58:	49 08       	lddpc	r8,80003d98 <vTemperature+0xcc>
80003d5a:	70 08       	ld.w	r8,r8[0x0]
80003d5c:	30 09       	mov	r9,0
80003d5e:	30 0a       	mov	r10,0
80003d60:	30 0b       	mov	r11,0
80003d62:	10 9c       	mov	r12,r8
80003d64:	f0 1f 00 0b 	mcall	80003d90 <vTemperature+0xc4>
		{
			// Semaphore given
		}
		// Delay
		vTaskDelay(TASK_DELAY_MS(50));
80003d68:	33 2c       	mov	r12,50
80003d6a:	f0 1f 00 0d 	mcall	80003d9c <vTemperature+0xd0>
	}
80003d6e:	cb 5b       	rjmp	80003cd8 <vTemperature+0xc>
80003d70:	80 00       	ld.sh	r0,r0[0x0]
80003d72:	30 66       	mov	r6,6
80003d74:	00 00       	add	r0,r0
80003d76:	07 e4       	ld.ub	r4,r3[0x6]
80003d78:	80 00       	ld.sh	r0,r0[0x0]
80003d7a:	58 b0       	cp.w	r0,11
80003d7c:	00 00       	add	r0,r0
80003d7e:	07 e8       	ld.ub	r8,r3[0x6]
80003d80:	80 00       	ld.sh	r0,r0[0x0]
80003d82:	3a 50       	mov	r0,-91
80003d84:	80 00       	ld.sh	r0,r0[0x0]
80003d86:	4d 58       	lddpc	r8,80003ed8 <vLCDWrite+0x64>
80003d88:	80 00       	ld.sh	r0,r0[0x0]
80003d8a:	30 dc       	mov	r12,13
80003d8c:	00 00       	add	r0,r0
80003d8e:	07 e0       	ld.ub	r0,r3[0x6]
80003d90:	80 00       	ld.sh	r0,r0[0x0]
80003d92:	57 48       	stdsp	sp[0x1d0],r8
80003d94:	80 00       	ld.sh	r0,r0[0x0]
80003d96:	3a 60       	mov	r0,-90
80003d98:	00 00       	add	r0,r0
80003d9a:	07 dc       	ld.ub	r12,r3[0x5]
80003d9c:	80 00       	ld.sh	r0,r0[0x0]
80003d9e:	5f 20       	srhs	r0

80003da0 <vLight>:
	
}

// Light sensor task which acts as a producer
void vLight( void *pvParameters )
{
80003da0:	eb cd 40 80 	pushm	r7,lr
80003da4:	1a 97       	mov	r7,sp
80003da6:	20 3d       	sub	sp,12
80003da8:	ef 4c ff f4 	st.w	r7[-12],r12
	volatile struct sensor_struct light_struct;
	while (1)
	{
		// Start a ADC sampling of all active channels
		adc_start(&AVR32_ADC);
80003dac:	fe 7c 3c 00 	mov	r12,-50176
80003db0:	f0 1f 00 25 	mcall	80003e44 <vLight+0xa4>
		
		// Polling for semaphore EmptyCount before getting access to queue (removes value from semaphore)
		if(xSemaphoreTake(xEmptyCount, (portTickType)portMAX_DELAY) == pdTRUE)
80003db4:	4a 58       	lddpc	r8,80003e48 <vLight+0xa8>
80003db6:	70 08       	ld.w	r8,r8[0x0]
80003db8:	30 09       	mov	r9,0
80003dba:	3f fa       	mov	r10,-1
80003dbc:	30 0b       	mov	r11,0
80003dbe:	10 9c       	mov	r12,r8
80003dc0:	f0 1f 00 23 	mcall	80003e4c <vLight+0xac>
		{
			// Semaphore taken
		}
		if(xSemaphoreTake(xMutex,(portTickType)portMAX_DELAY) == pdTRUE)
80003dc4:	4a 38       	lddpc	r8,80003e50 <vLight+0xb0>
80003dc6:	70 08       	ld.w	r8,r8[0x0]
80003dc8:	30 09       	mov	r9,0
80003dca:	3f fa       	mov	r10,-1
80003dcc:	30 0b       	mov	r11,0
80003dce:	10 9c       	mov	r12,r8
80003dd0:	f0 1f 00 1f 	mcall	80003e4c <vLight+0xac>
80003dd4:	18 98       	mov	r8,r12
80003dd6:	58 18       	cp.w	r8,1
80003dd8:	c0 61       	brne	80003de4 <vLight+0x44>
		{
			usart_write_line(serialPORT_USART, "Light tar mutex");
80003dda:	49 fb       	lddpc	r11,80003e54 <vLight+0xb4>
80003ddc:	fe 7c 18 00 	mov	r12,-59392
80003de0:	f0 1f 00 1e 	mcall	80003e58 <vLight+0xb8>
		}
		
		//Get the light sensor value
		light_struct.sensor_value = adc_get_value(&AVR32_ADC, ADC_LIGHT_CHANNEL);
80003de4:	30 2b       	mov	r11,2
80003de6:	fe 7c 3c 00 	mov	r12,-50176
80003dea:	f0 1f 00 1d 	mcall	80003e5c <vLight+0xbc>
80003dee:	18 98       	mov	r8,r12
80003df0:	ef 48 ff f8 	st.w	r7[-8],r8
		light_struct.ID = 2;
80003df4:	30 28       	mov	r8,2
80003df6:	ef 48 ff fc 	st.w	r7[-4],r8
		
		// Put the value on the queue
		xQueueSendToBack(xQHandle, &light_struct, (portTickType)10);
80003dfa:	49 a8       	lddpc	r8,80003e60 <vLight+0xc0>
80003dfc:	70 08       	ld.w	r8,r8[0x0]
80003dfe:	ee cb 00 08 	sub	r11,r7,8
80003e02:	30 09       	mov	r9,0
80003e04:	30 aa       	mov	r10,10
80003e06:	10 9c       	mov	r12,r8
80003e08:	f0 1f 00 17 	mcall	80003e64 <vLight+0xc4>
		
		if(xSemaphoreGive(xMutex) == pdTRUE)
80003e0c:	49 18       	lddpc	r8,80003e50 <vLight+0xb0>
80003e0e:	70 08       	ld.w	r8,r8[0x0]
80003e10:	30 09       	mov	r9,0
80003e12:	30 0a       	mov	r10,0
80003e14:	30 0b       	mov	r11,0
80003e16:	10 9c       	mov	r12,r8
80003e18:	f0 1f 00 13 	mcall	80003e64 <vLight+0xc4>
80003e1c:	18 98       	mov	r8,r12
80003e1e:	58 18       	cp.w	r8,1
80003e20:	c0 61       	brne	80003e2c <vLight+0x8c>
		{
			usart_write_line(serialPORT_USART, "Light lmnar mutex");
80003e22:	49 2b       	lddpc	r11,80003e68 <vLight+0xc8>
80003e24:	fe 7c 18 00 	mov	r12,-59392
80003e28:	f0 1f 00 0c 	mcall	80003e58 <vLight+0xb8>
		}
		// Give the semaphore FillCount (adds value to semaphore)
		if(xSemaphoreGive(xFillCount) == pdTRUE)
80003e2c:	49 08       	lddpc	r8,80003e6c <vLight+0xcc>
80003e2e:	70 08       	ld.w	r8,r8[0x0]
80003e30:	30 09       	mov	r9,0
80003e32:	30 0a       	mov	r10,0
80003e34:	30 0b       	mov	r11,0
80003e36:	10 9c       	mov	r12,r8
80003e38:	f0 1f 00 0b 	mcall	80003e64 <vLight+0xc4>
		{
			// Semaphore given
		}
		// Delay
		vTaskDelay(TASK_DELAY_MS(50));
80003e3c:	33 2c       	mov	r12,50
80003e3e:	f0 1f 00 0d 	mcall	80003e70 <vLight+0xd0>
	}
80003e42:	cb 5b       	rjmp	80003dac <vLight+0xc>
80003e44:	80 00       	ld.sh	r0,r0[0x0]
80003e46:	30 66       	mov	r6,6
80003e48:	00 00       	add	r0,r0
80003e4a:	07 e4       	ld.ub	r4,r3[0x6]
80003e4c:	80 00       	ld.sh	r0,r0[0x0]
80003e4e:	58 b0       	cp.w	r0,11
80003e50:	00 00       	add	r0,r0
80003e52:	07 e8       	ld.ub	r8,r3[0x6]
80003e54:	80 00       	ld.sh	r0,r0[0x0]
80003e56:	3a 74       	mov	r4,-89
80003e58:	80 00       	ld.sh	r0,r0[0x0]
80003e5a:	4d 58       	lddpc	r8,80003fac <vLCDWrite+0x138>
80003e5c:	80 00       	ld.sh	r0,r0[0x0]
80003e5e:	30 dc       	mov	r12,13
80003e60:	00 00       	add	r0,r0
80003e62:	07 e0       	ld.ub	r0,r3[0x6]
80003e64:	80 00       	ld.sh	r0,r0[0x0]
80003e66:	57 48       	stdsp	sp[0x1d0],r8
80003e68:	80 00       	ld.sh	r0,r0[0x0]
80003e6a:	3a 84       	mov	r4,-88
80003e6c:	00 00       	add	r0,r0
80003e6e:	07 dc       	ld.ub	r12,r3[0x5]
80003e70:	80 00       	ld.sh	r0,r0[0x0]
80003e72:	5f 20       	srhs	r0

80003e74 <vLCDWrite>:
}

// Task which reads from queue and writes to LCD display. It acts as a consumer.
void vLCDWrite( void *pvParameters )
{
80003e74:	eb cd 40 80 	pushm	r7,lr
80003e78:	1a 97       	mov	r7,sp
80003e7a:	21 2d       	sub	sp,72
80003e7c:	ef 4c ff b8 	st.w	r7[-72],r12
	volatile char str_temp[20];
	volatile char str_light[20];
	while (1)
	{
		// Polling for semaphore FillCount before getting access to queue (removes value from semaphore)
		if(xSemaphoreTake(xFillCount, (portTickType)portMAX_DELAY) == pdTRUE)
80003e80:	4d 58       	lddpc	r8,80003fd4 <vLCDWrite+0x160>
80003e82:	70 08       	ld.w	r8,r8[0x0]
80003e84:	30 09       	mov	r9,0
80003e86:	3f fa       	mov	r10,-1
80003e88:	30 0b       	mov	r11,0
80003e8a:	10 9c       	mov	r12,r8
80003e8c:	f0 1f 00 53 	mcall	80003fd8 <vLCDWrite+0x164>
		{
			// Semaphore taken
		}
		
		if(xSemaphoreTake(xMutex, (portTickType)portMAX_DELAY) == pdTRUE)
80003e90:	4d 38       	lddpc	r8,80003fdc <vLCDWrite+0x168>
80003e92:	70 08       	ld.w	r8,r8[0x0]
80003e94:	30 09       	mov	r9,0
80003e96:	3f fa       	mov	r10,-1
80003e98:	30 0b       	mov	r11,0
80003e9a:	10 9c       	mov	r12,r8
80003e9c:	f0 1f 00 4f 	mcall	80003fd8 <vLCDWrite+0x164>
80003ea0:	18 98       	mov	r8,r12
80003ea2:	58 18       	cp.w	r8,1
80003ea4:	c0 61       	brne	80003eb0 <vLCDWrite+0x3c>
		{
			usart_write_line(serialPORT_USART, "LCD tar mutex");
80003ea6:	4c fb       	lddpc	r11,80003fe0 <vLCDWrite+0x16c>
80003ea8:	fe 7c 18 00 	mov	r12,-59392
80003eac:	f0 1f 00 4e 	mcall	80003fe4 <vLCDWrite+0x170>
		}
		// Read value from queue
		xQueueReceive(xQHandle, &sensor_struct1, (portTickType)10);
80003eb0:	4c e8       	lddpc	r8,80003fe8 <vLCDWrite+0x174>
80003eb2:	70 08       	ld.w	r8,r8[0x0]
80003eb4:	ee cb 00 08 	sub	r11,r7,8
80003eb8:	30 09       	mov	r9,0
80003eba:	30 aa       	mov	r10,10
80003ebc:	10 9c       	mov	r12,r8
80003ebe:	f0 1f 00 47 	mcall	80003fd8 <vLCDWrite+0x164>
		if (sensor_struct1.ID == 0)	// Potentiometer sensor
80003ec2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ec6:	58 08       	cp.w	r8,0
80003ec8:	c1 71       	brne	80003ef6 <vLCDWrite+0x82>
		{
			dip204_set_cursor_position(1, 1);
80003eca:	30 1b       	mov	r11,1
80003ecc:	30 1c       	mov	r12,1
80003ece:	f0 1f 00 48 	mcall	80003fec <vLCDWrite+0x178>
			dip204_printf_string("Potentiometer: %03d", sensor_struct1.sensor_value); //print value
80003ed2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003ed6:	1a d8       	st.w	--sp,r8
80003ed8:	4c 6c       	lddpc	r12,80003ff0 <vLCDWrite+0x17c>
80003eda:	f0 1f 00 47 	mcall	80003ff4 <vLCDWrite+0x180>
80003ede:	2f fd       	sub	sp,-4
			sprintf(str_pot, "Potentiometer: %d, ", sensor_struct1.sensor_value);
80003ee0:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003ee4:	ee c8 00 1c 	sub	r8,r7,28
80003ee8:	1a d9       	st.w	--sp,r9
80003eea:	4c 4b       	lddpc	r11,80003ff8 <vLCDWrite+0x184>
80003eec:	10 9c       	mov	r12,r8
80003eee:	f0 1f 00 44 	mcall	80003ffc <vLCDWrite+0x188>
80003ef2:	2f fd       	sub	sp,-4
80003ef4:	c3 48       	rjmp	80003f5c <vLCDWrite+0xe8>
			
		}
		else if (sensor_struct1.ID == 1)	//Temperature sensor	
80003ef6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003efa:	58 18       	cp.w	r8,1
80003efc:	c1 71       	brne	80003f2a <vLCDWrite+0xb6>
		{
			dip204_set_cursor_position(1, 2);
80003efe:	30 2b       	mov	r11,2
80003f00:	30 1c       	mov	r12,1
80003f02:	f0 1f 00 3b 	mcall	80003fec <vLCDWrite+0x178>
			dip204_printf_string("Temperature: %03d", sensor_struct1.sensor_value); //print value
80003f06:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f0a:	1a d8       	st.w	--sp,r8
80003f0c:	4b dc       	lddpc	r12,80004000 <vLCDWrite+0x18c>
80003f0e:	f0 1f 00 3a 	mcall	80003ff4 <vLCDWrite+0x180>
80003f12:	2f fd       	sub	sp,-4
			sprintf(str_temp, "Temperature: %d, ", sensor_struct1.sensor_value);
80003f14:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003f18:	ee c8 00 30 	sub	r8,r7,48
80003f1c:	1a d9       	st.w	--sp,r9
80003f1e:	4b ab       	lddpc	r11,80004004 <vLCDWrite+0x190>
80003f20:	10 9c       	mov	r12,r8
80003f22:	f0 1f 00 37 	mcall	80003ffc <vLCDWrite+0x188>
80003f26:	2f fd       	sub	sp,-4
80003f28:	c1 a8       	rjmp	80003f5c <vLCDWrite+0xe8>
		}
		else if (sensor_struct1.ID == 2)	// Light sensor
80003f2a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f2e:	58 28       	cp.w	r8,2
80003f30:	c1 61       	brne	80003f5c <vLCDWrite+0xe8>
		{
			dip204_set_cursor_position(1, 3);
80003f32:	30 3b       	mov	r11,3
80003f34:	30 1c       	mov	r12,1
80003f36:	f0 1f 00 2e 	mcall	80003fec <vLCDWrite+0x178>
			dip204_printf_string("Light: %04d", sensor_struct1.sensor_value); //print value
80003f3a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f3e:	1a d8       	st.w	--sp,r8
80003f40:	4b 2c       	lddpc	r12,80004008 <vLCDWrite+0x194>
80003f42:	f0 1f 00 2d 	mcall	80003ff4 <vLCDWrite+0x180>
80003f46:	2f fd       	sub	sp,-4
			sprintf(str_light, "Light: %d", sensor_struct1.sensor_value);
80003f48:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003f4c:	ee c8 00 44 	sub	r8,r7,68
80003f50:	1a d9       	st.w	--sp,r9
80003f52:	4a fb       	lddpc	r11,8000400c <vLCDWrite+0x198>
80003f54:	10 9c       	mov	r12,r8
80003f56:	f0 1f 00 2a 	mcall	80003ffc <vLCDWrite+0x188>
80003f5a:	2f fd       	sub	sp,-4
		}
		usart_write_line(serialPORT_USART, "\r");
80003f5c:	4a db       	lddpc	r11,80004010 <vLCDWrite+0x19c>
80003f5e:	fe 7c 18 00 	mov	r12,-59392
80003f62:	f0 1f 00 21 	mcall	80003fe4 <vLCDWrite+0x170>
		usart_write_line(serialPORT_USART, "\033[2J");
80003f66:	4a cb       	lddpc	r11,80004014 <vLCDWrite+0x1a0>
80003f68:	fe 7c 18 00 	mov	r12,-59392
80003f6c:	f0 1f 00 1e 	mcall	80003fe4 <vLCDWrite+0x170>
		usart_write_line(serialPORT_USART, str_pot);
80003f70:	ee c8 00 1c 	sub	r8,r7,28
80003f74:	10 9b       	mov	r11,r8
80003f76:	fe 7c 18 00 	mov	r12,-59392
80003f7a:	f0 1f 00 1b 	mcall	80003fe4 <vLCDWrite+0x170>
		usart_write_line(serialPORT_USART, str_temp);
80003f7e:	ee c8 00 30 	sub	r8,r7,48
80003f82:	10 9b       	mov	r11,r8
80003f84:	fe 7c 18 00 	mov	r12,-59392
80003f88:	f0 1f 00 17 	mcall	80003fe4 <vLCDWrite+0x170>
		usart_write_line(serialPORT_USART, str_light);
80003f8c:	ee c8 00 44 	sub	r8,r7,68
80003f90:	10 9b       	mov	r11,r8
80003f92:	fe 7c 18 00 	mov	r12,-59392
80003f96:	f0 1f 00 14 	mcall	80003fe4 <vLCDWrite+0x170>
		
		if(xSemaphoreGive(xMutex) == pdTRUE)
80003f9a:	49 18       	lddpc	r8,80003fdc <vLCDWrite+0x168>
80003f9c:	70 08       	ld.w	r8,r8[0x0]
80003f9e:	30 09       	mov	r9,0
80003fa0:	30 0a       	mov	r10,0
80003fa2:	30 0b       	mov	r11,0
80003fa4:	10 9c       	mov	r12,r8
80003fa6:	f0 1f 00 1d 	mcall	80004018 <vLCDWrite+0x1a4>
80003faa:	18 98       	mov	r8,r12
80003fac:	58 18       	cp.w	r8,1
80003fae:	c0 61       	brne	80003fba <vLCDWrite+0x146>
		{
			usart_write_line(serialPORT_USART, "LCD lmnar mutex");
80003fb0:	49 bb       	lddpc	r11,8000401c <vLCDWrite+0x1a8>
80003fb2:	fe 7c 18 00 	mov	r12,-59392
80003fb6:	f0 1f 00 0c 	mcall	80003fe4 <vLCDWrite+0x170>
		}
		// Give the semaphore EmptyCount (adds value to semaphore)
		if(xSemaphoreGive(xEmptyCount) == pdTRUE)
80003fba:	49 a8       	lddpc	r8,80004020 <vLCDWrite+0x1ac>
80003fbc:	70 08       	ld.w	r8,r8[0x0]
80003fbe:	30 09       	mov	r9,0
80003fc0:	30 0a       	mov	r10,0
80003fc2:	30 0b       	mov	r11,0
80003fc4:	10 9c       	mov	r12,r8
80003fc6:	f0 1f 00 15 	mcall	80004018 <vLCDWrite+0x1a4>
		{
			// Semaphore given
		}
		vTaskDelay(TASK_DELAY_MS(20));
80003fca:	31 4c       	mov	r12,20
80003fcc:	f0 1f 00 16 	mcall	80004024 <vLCDWrite+0x1b0>
	}
80003fd0:	c5 8b       	rjmp	80003e80 <vLCDWrite+0xc>
80003fd2:	00 00       	add	r0,r0
80003fd4:	00 00       	add	r0,r0
80003fd6:	07 dc       	ld.ub	r12,r3[0x5]
80003fd8:	80 00       	ld.sh	r0,r0[0x0]
80003fda:	58 b0       	cp.w	r0,11
80003fdc:	00 00       	add	r0,r0
80003fde:	07 e8       	ld.ub	r8,r3[0x6]
80003fe0:	80 00       	ld.sh	r0,r0[0x0]
80003fe2:	3a 98       	mov	r8,-87
80003fe4:	80 00       	ld.sh	r0,r0[0x0]
80003fe6:	4d 58       	lddpc	r8,80004138 <main+0x110>
80003fe8:	00 00       	add	r0,r0
80003fea:	07 e0       	ld.ub	r0,r3[0x6]
80003fec:	80 00       	ld.sh	r0,r0[0x0]
80003fee:	2c 18       	sub	r8,-63
80003ff0:	80 00       	ld.sh	r0,r0[0x0]
80003ff2:	3a a8       	mov	r8,-86
80003ff4:	80 00       	ld.sh	r0,r0[0x0]
80003ff6:	2e 1c       	sub	r12,-31
80003ff8:	80 00       	ld.sh	r0,r0[0x0]
80003ffa:	3a bc       	mov	r12,-85
80003ffc:	80 00       	ld.sh	r0,r0[0x0]
80003ffe:	75 9c       	ld.w	r12,r10[0x64]
80004000:	80 00       	ld.sh	r0,r0[0x0]
80004002:	3a d0       	mov	r0,-83
80004004:	80 00       	ld.sh	r0,r0[0x0]
80004006:	3a e4       	mov	r4,-82
80004008:	80 00       	ld.sh	r0,r0[0x0]
8000400a:	3a f8       	mov	r8,-81
8000400c:	80 00       	ld.sh	r0,r0[0x0]
8000400e:	3b 04       	mov	r4,-80
80004010:	80 00       	ld.sh	r0,r0[0x0]
80004012:	3b 10       	mov	r0,-79
80004014:	80 00       	ld.sh	r0,r0[0x0]
80004016:	3b 14       	mov	r4,-79
80004018:	80 00       	ld.sh	r0,r0[0x0]
8000401a:	57 48       	stdsp	sp[0x1d0],r8
8000401c:	80 00       	ld.sh	r0,r0[0x0]
8000401e:	3b 1c       	mov	r12,-79
80004020:	00 00       	add	r0,r0
80004022:	07 e4       	ld.ub	r4,r3[0x6]
80004024:	80 00       	ld.sh	r0,r0[0x0]
80004026:	5f 20       	srhs	r0

80004028 <main>:
}
int main(void)
{
80004028:	eb cd 40 80 	pushm	r7,lr
8000402c:	1a 97       	mov	r7,sp
	initLED();
8000402e:	f0 1f 00 44 	mcall	8000413c <main+0x114>
	init_usart();
80004032:	f0 1f 00 44 	mcall	80004140 <main+0x118>
	display_init();
80004036:	f0 1f 00 44 	mcall	80004144 <main+0x11c>
	dip204_clear_display();
8000403a:	f0 1f 00 44 	mcall	80004148 <main+0x120>
	
	// Configure the ADC module and enable the potentiometer, temperature and light channel
	adc_configure(&AVR32_ADC);
8000403e:	fe 7c 3c 00 	mov	r12,-50176
80004042:	f0 1f 00 43 	mcall	8000414c <main+0x124>
	adc_enable(&AVR32_ADC, ADC_POTENTIOMETER_CHANNEL);
80004046:	30 1b       	mov	r11,1
80004048:	fe 7c 3c 00 	mov	r12,-50176
8000404c:	f0 1f 00 41 	mcall	80004150 <main+0x128>
	adc_enable(&AVR32_ADC, ADC_TEMPERATURE_CHANNEL);
80004050:	30 0b       	mov	r11,0
80004052:	fe 7c 3c 00 	mov	r12,-50176
80004056:	f0 1f 00 3f 	mcall	80004150 <main+0x128>
	adc_enable(&AVR32_ADC, ADC_LIGHT_CHANNEL);
8000405a:	30 2b       	mov	r11,2
8000405c:	fe 7c 3c 00 	mov	r12,-50176
80004060:	f0 1f 00 3c 	mcall	80004150 <main+0x128>
	
	vSemaphoreCreateBinary(xLCDSemaphore);	// Semaphore - Display
80004064:	30 0b       	mov	r11,0
80004066:	30 1c       	mov	r12,1
80004068:	f0 1f 00 3b 	mcall	80004154 <main+0x12c>
8000406c:	18 99       	mov	r9,r12
8000406e:	4b b8       	lddpc	r8,80004158 <main+0x130>
80004070:	91 09       	st.w	r8[0x0],r9
80004072:	4b a8       	lddpc	r8,80004158 <main+0x130>
80004074:	70 08       	ld.w	r8,r8[0x0]
80004076:	58 08       	cp.w	r8,0
80004078:	c0 90       	breq	8000408a <main+0x62>
8000407a:	4b 88       	lddpc	r8,80004158 <main+0x130>
8000407c:	70 08       	ld.w	r8,r8[0x0]
8000407e:	30 09       	mov	r9,0
80004080:	30 0a       	mov	r10,0
80004082:	30 0b       	mov	r11,0
80004084:	10 9c       	mov	r12,r8
80004086:	f0 1f 00 36 	mcall	8000415c <main+0x134>
	xFillCount = xSemaphoreCreateCounting(BUFFER_SIZE, 0);
8000408a:	30 0b       	mov	r11,0
8000408c:	30 ac       	mov	r12,10
8000408e:	f0 1f 00 35 	mcall	80004160 <main+0x138>
80004092:	18 99       	mov	r9,r12
80004094:	4b 48       	lddpc	r8,80004164 <main+0x13c>
80004096:	91 09       	st.w	r8[0x0],r9
	xEmptyCount = xSemaphoreCreateCounting(BUFFER_SIZE, BUFFER_SIZE);
80004098:	30 ab       	mov	r11,10
8000409a:	30 ac       	mov	r12,10
8000409c:	f0 1f 00 31 	mcall	80004160 <main+0x138>
800040a0:	18 99       	mov	r9,r12
800040a2:	4b 28       	lddpc	r8,80004168 <main+0x140>
800040a4:	91 09       	st.w	r8[0x0],r9
	xMutex = xSemaphoreCreateMutex();
800040a6:	f0 1f 00 32 	mcall	8000416c <main+0x144>
800040aa:	18 99       	mov	r9,r12
800040ac:	4b 18       	lddpc	r8,80004170 <main+0x148>
800040ae:	91 09       	st.w	r8[0x0],r9
	
	xQHandle = xQueueCreate(1, sizeof(struct sensor_struct));		// Queue - 10 spots of char-pointer size
800040b0:	30 8b       	mov	r11,8
800040b2:	30 1c       	mov	r12,1
800040b4:	f0 1f 00 28 	mcall	80004154 <main+0x12c>
800040b8:	18 99       	mov	r9,r12
800040ba:	4a f8       	lddpc	r8,80004174 <main+0x14c>
800040bc:	91 09       	st.w	r8[0x0],r9
		//ERROR!
	}
	
	
	// Create the task , store the handle .
	xTaskCreate(	vPotentiometer,
800040be:	4a fb       	lddpc	r11,80004178 <main+0x150>
800040c0:	30 08       	mov	r8,0
800040c2:	1a d8       	st.w	--sp,r8
800040c4:	30 08       	mov	r8,0
800040c6:	1a d8       	st.w	--sp,r8
800040c8:	4a d8       	lddpc	r8,8000417c <main+0x154>
800040ca:	1a d8       	st.w	--sp,r8
800040cc:	30 18       	mov	r8,1
800040ce:	30 09       	mov	r9,0
800040d0:	e0 6a 01 00 	mov	r10,256
800040d4:	4a bc       	lddpc	r12,80004180 <main+0x158>
800040d6:	f0 1f 00 2c 	mcall	80004184 <main+0x15c>
800040da:	2f dd       	sub	sp,-12
					"vPotentiometer",
					configMINIMAL_STACK_SIZE,
					NULL,
					1,
					&xHandlePotentiometer);
	xTaskCreate(	vTemperature, "vTemperature", configMINIMAL_STACK_SIZE, NULL, 1, &xHandleTemperature);
800040dc:	4a bb       	lddpc	r11,80004188 <main+0x160>
800040de:	30 08       	mov	r8,0
800040e0:	1a d8       	st.w	--sp,r8
800040e2:	30 08       	mov	r8,0
800040e4:	1a d8       	st.w	--sp,r8
800040e6:	4a a8       	lddpc	r8,8000418c <main+0x164>
800040e8:	1a d8       	st.w	--sp,r8
800040ea:	30 18       	mov	r8,1
800040ec:	30 09       	mov	r9,0
800040ee:	e0 6a 01 00 	mov	r10,256
800040f2:	4a 8c       	lddpc	r12,80004190 <main+0x168>
800040f4:	f0 1f 00 24 	mcall	80004184 <main+0x15c>
800040f8:	2f dd       	sub	sp,-12
	
	xTaskCreate(	vLight, "vLight", configMINIMAL_STACK_SIZE, NULL, 1, &xHandleLight);
800040fa:	4a 7b       	lddpc	r11,80004194 <main+0x16c>
800040fc:	30 08       	mov	r8,0
800040fe:	1a d8       	st.w	--sp,r8
80004100:	30 08       	mov	r8,0
80004102:	1a d8       	st.w	--sp,r8
80004104:	4a 58       	lddpc	r8,80004198 <main+0x170>
80004106:	1a d8       	st.w	--sp,r8
80004108:	30 18       	mov	r8,1
8000410a:	30 09       	mov	r9,0
8000410c:	e0 6a 01 00 	mov	r10,256
80004110:	4a 3c       	lddpc	r12,8000419c <main+0x174>
80004112:	f0 1f 00 1d 	mcall	80004184 <main+0x15c>
80004116:	2f dd       	sub	sp,-12
	
	xTaskCreate(	vLCDWrite, "vLCDWrite", configMINIMAL_STACK_SIZE, NULL, 1, &xHandleLCDWrite);
80004118:	4a 2b       	lddpc	r11,800041a0 <main+0x178>
8000411a:	30 08       	mov	r8,0
8000411c:	1a d8       	st.w	--sp,r8
8000411e:	30 08       	mov	r8,0
80004120:	1a d8       	st.w	--sp,r8
80004122:	4a 18       	lddpc	r8,800041a4 <main+0x17c>
80004124:	1a d8       	st.w	--sp,r8
80004126:	30 18       	mov	r8,1
80004128:	30 09       	mov	r9,0
8000412a:	e0 6a 01 00 	mov	r10,256
8000412e:	49 fc       	lddpc	r12,800041a8 <main+0x180>
80004130:	f0 1f 00 15 	mcall	80004184 <main+0x15c>
80004134:	2f dd       	sub	sp,-12
	
	vTaskStartScheduler();		// Starts the scheduling
80004136:	f0 1f 00 1e 	mcall	800041ac <main+0x184>

	
	for( ;; )
	{
		
	}
8000413a:	c0 08       	rjmp	8000413a <main+0x112>
8000413c:	80 00       	ld.sh	r0,r0[0x0]
8000413e:	39 b0       	mov	r0,-101
80004140:	80 00       	ld.sh	r0,r0[0x0]
80004142:	3b 64       	mov	r4,-74
80004144:	80 00       	ld.sh	r0,r0[0x0]
80004146:	37 88       	mov	r8,120
80004148:	80 00       	ld.sh	r0,r0[0x0]
8000414a:	2c a0       	sub	r0,-54
8000414c:	80 00       	ld.sh	r0,r0[0x0]
8000414e:	30 30       	mov	r0,3
80004150:	80 00       	ld.sh	r0,r0[0x0]
80004152:	30 80       	mov	r0,8
80004154:	80 00       	ld.sh	r0,r0[0x0]
80004156:	55 44       	stdsp	sp[0x150],r4
80004158:	00 00       	add	r0,r0
8000415a:	07 d8       	ld.ub	r8,r3[0x5]
8000415c:	80 00       	ld.sh	r0,r0[0x0]
8000415e:	57 48       	stdsp	sp[0x1d0],r8
80004160:	80 00       	ld.sh	r0,r0[0x0]
80004162:	57 04       	stdsp	sp[0x1c0],r4
80004164:	00 00       	add	r0,r0
80004166:	07 dc       	ld.ub	r12,r3[0x5]
80004168:	00 00       	add	r0,r0
8000416a:	07 e4       	ld.ub	r4,r3[0x6]
8000416c:	80 00       	ld.sh	r0,r0[0x0]
8000416e:	56 5c       	stdsp	sp[0x194],r12
80004170:	00 00       	add	r0,r0
80004172:	07 e8       	ld.ub	r8,r3[0x6]
80004174:	00 00       	add	r0,r0
80004176:	07 e0       	ld.ub	r0,r3[0x6]
80004178:	80 00       	ld.sh	r0,r0[0x0]
8000417a:	3b 30       	mov	r0,-77
8000417c:	00 00       	add	r0,r0
8000417e:	07 f0       	ld.ub	r0,r3[0x7]
80004180:	80 00       	ld.sh	r0,r0[0x0]
80004182:	3b cc       	mov	r12,-68
80004184:	80 00       	ld.sh	r0,r0[0x0]
80004186:	5d 58       	*unknown*
80004188:	80 00       	ld.sh	r0,r0[0x0]
8000418a:	3b 40       	mov	r0,-76
8000418c:	00 00       	add	r0,r0
8000418e:	07 d4       	ld.ub	r4,r3[0x5]
80004190:	80 00       	ld.sh	r0,r0[0x0]
80004192:	3c cc       	mov	r12,-52
80004194:	80 00       	ld.sh	r0,r0[0x0]
80004196:	3b 50       	mov	r0,-75
80004198:	00 00       	add	r0,r0
8000419a:	07 ec       	ld.ub	r12,r3[0x6]
8000419c:	80 00       	ld.sh	r0,r0[0x0]
8000419e:	3d a0       	mov	r0,-38
800041a0:	80 00       	ld.sh	r0,r0[0x0]
800041a2:	3b 58       	mov	r8,-75
800041a4:	00 00       	add	r0,r0
800041a6:	07 f4       	ld.ub	r4,r3[0x7]
800041a8:	80 00       	ld.sh	r0,r0[0x0]
800041aa:	3e 74       	mov	r4,-25
800041ac:	80 00       	ld.sh	r0,r0[0x0]
800041ae:	5f 94       	srgt	r4

800041b0 <LED_Set_Intensity>:
           AVR32_PWM.channel[led_descriptor->PWM.CHANNEL].cdty : 0;
}


void LED_Set_Intensity(U32 leds, U8 intensity)
{
800041b0:	eb cd 40 80 	pushm	r7,lr
800041b4:	1a 97       	mov	r7,sp
800041b6:	20 6d       	sub	sp,24
800041b8:	ef 4c ff ec 	st.w	r7[-20],r12
800041bc:	16 98       	mov	r8,r11
800041be:	ef 68 ff e8 	st.b	r7[-24],r8
  tLED_DESCRIPTOR *led_descriptor = &LED_DESCRIPTOR[0] - 1;
800041c2:	4d 58       	lddpc	r8,80004314 <LED_Set_Intensity+0x164>
800041c4:	21 08       	sub	r8,16
800041c6:	ef 48 ff f0 	st.w	r7[-16],r8
  volatile avr32_pwm_channel_t *led_pwm_channel;
  volatile avr32_gpio_port_t *led_gpio_port;
  U8 led_shift;

  // For each specified LED...
  for (leds &= (1 << LED_COUNT) - 1; leds; leds >>= led_shift)
800041ca:	ee f8 ff ec 	ld.w	r8,r7[-20]
800041ce:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800041d2:	ef 48 ff ec 	st.w	r7[-20],r8
800041d6:	c9 78       	rjmp	80004304 <LED_Set_Intensity+0x154>
  {
    // Select the next specified LED and check that it has a PWM channel.
    led_shift = 1 + ctz(leds);
800041d8:	ee f8 ff ec 	ld.w	r8,r7[-20]
800041dc:	5c 98       	brev	r8
800041de:	f0 08 12 00 	clz	r8,r8
800041e2:	5c 58       	castu.b	r8
800041e4:	2f f8       	sub	r8,-1
800041e6:	ef 68 ff ff 	st.b	r7[-1],r8
    led_descriptor += led_shift;
800041ea:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800041ee:	a5 68       	lsl	r8,0x4
800041f0:	ee f9 ff f0 	ld.w	r9,r7[-16]
800041f4:	f2 08 00 08 	add	r8,r9,r8
800041f8:	ef 48 ff f0 	st.w	r7[-16],r8
    if (led_descriptor->PWM.CHANNEL < 0) continue;
800041fc:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004200:	70 28       	ld.w	r8,r8[0x8]
80004202:	58 08       	cp.w	r8,0
80004204:	c7 75       	brlt	800042f2 <LED_Set_Intensity+0x142>

    // Initialize or update the LED PWM channel.
    led_pwm_channel = &AVR32_PWM.channel[led_descriptor->PWM.CHANNEL];
80004206:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000420a:	70 28       	ld.w	r8,r8[0x8]
8000420c:	a5 78       	lsl	r8,0x5
8000420e:	e0 28 ce 00 	sub	r8,52736
80004212:	ef 48 ff f4 	st.w	r7[-12],r8
    if (!(AVR32_PWM.sr & (1 << led_descriptor->PWM.CHANNEL)))
80004216:	fe 78 30 00 	mov	r8,-53248
8000421a:	70 39       	ld.w	r9,r8[0xc]
8000421c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004220:	70 28       	ld.w	r8,r8[0x8]
80004222:	30 1a       	mov	r10,1
80004224:	f4 08 09 48 	lsl	r8,r10,r8
80004228:	f3 e8 00 08 	and	r8,r9,r8
8000422c:	c1 91       	brne	8000425e <LED_Set_Intensity+0xae>
    {
      led_pwm_channel->cmr = (AVR32_PWM_CPRE_MCK << AVR32_PWM_CPRE_OFFSET) &
8000422e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004232:	30 09       	mov	r9,0
80004234:	91 09       	st.w	r8[0x0],r9
                             ~(AVR32_PWM_CALG_MASK |
                               AVR32_PWM_CPOL_MASK |
                               AVR32_PWM_CPD_MASK);
      led_pwm_channel->cprd = 0x000000FF;
80004236:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000423a:	e0 69 00 ff 	mov	r9,255
8000423e:	91 29       	st.w	r8[0x8],r9
      led_pwm_channel->cdty = intensity;
80004240:	ef 39 ff e8 	ld.ub	r9,r7[-24]
80004244:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004248:	91 19       	st.w	r8[0x4],r9
      AVR32_PWM.ena = 1 << led_descriptor->PWM.CHANNEL;
8000424a:	fe 78 30 00 	mov	r8,-53248
8000424e:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004252:	72 29       	ld.w	r9,r9[0x8]
80004254:	30 1a       	mov	r10,1
80004256:	f4 09 09 49 	lsl	r9,r10,r9
8000425a:	91 19       	st.w	r8[0x4],r9
8000425c:	c1 58       	rjmp	80004286 <LED_Set_Intensity+0xd6>
    }
    else
    {
      AVR32_PWM.isr;
8000425e:	fe 78 30 00 	mov	r8,-53248
80004262:	70 78       	ld.w	r8,r8[0x1c]
      while (!(AVR32_PWM.isr & (1 << led_descriptor->PWM.CHANNEL)));
80004264:	fe 78 30 00 	mov	r8,-53248
80004268:	70 79       	ld.w	r9,r8[0x1c]
8000426a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000426e:	70 28       	ld.w	r8,r8[0x8]
80004270:	30 1a       	mov	r10,1
80004272:	f4 08 09 48 	lsl	r8,r10,r8
80004276:	f3 e8 00 08 	and	r8,r9,r8
8000427a:	cf 50       	breq	80004264 <LED_Set_Intensity+0xb4>
      led_pwm_channel->cupd = intensity;
8000427c:	ef 39 ff e8 	ld.ub	r9,r7[-24]
80004280:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004284:	91 49       	st.w	r8[0x10],r9
    }

    // Switch the LED pin to its PWM function.
    led_gpio_port = &AVR32_GPIO.port[led_descriptor->GPIO.PORT];
80004286:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000428a:	70 08       	ld.w	r8,r8[0x0]
8000428c:	a9 68       	lsl	r8,0x8
8000428e:	e0 28 f0 00 	sub	r8,61440
80004292:	ef 48 ff f8 	st.w	r7[-8],r8
    if (led_descriptor->PWM.FUNCTION & 0x1)
80004296:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000429a:	70 38       	ld.w	r8,r8[0xc]
8000429c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800042a0:	5c 58       	castu.b	r8
800042a2:	c0 80       	breq	800042b2 <LED_Set_Intensity+0x102>
    {
      led_gpio_port->pmr0s = led_descriptor->GPIO.PIN_MASK;
800042a4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800042a8:	70 19       	ld.w	r9,r8[0x4]
800042aa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042ae:	91 59       	st.w	r8[0x14],r9
800042b0:	c0 78       	rjmp	800042be <LED_Set_Intensity+0x10e>
    }
    else
    {
      led_gpio_port->pmr0c = led_descriptor->GPIO.PIN_MASK;
800042b2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800042b6:	70 19       	ld.w	r9,r8[0x4]
800042b8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042bc:	91 69       	st.w	r8[0x18],r9
    }
    if (led_descriptor->PWM.FUNCTION & 0x2)
800042be:	ee f8 ff f0 	ld.w	r8,r7[-16]
800042c2:	70 38       	ld.w	r8,r8[0xc]
800042c4:	e2 18 00 02 	andl	r8,0x2,COH
800042c8:	c0 80       	breq	800042d8 <LED_Set_Intensity+0x128>
    {
      led_gpio_port->pmr1s = led_descriptor->GPIO.PIN_MASK;
800042ca:	ee f8 ff f0 	ld.w	r8,r7[-16]
800042ce:	70 19       	ld.w	r9,r8[0x4]
800042d0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042d4:	91 99       	st.w	r8[0x24],r9
800042d6:	c0 78       	rjmp	800042e4 <LED_Set_Intensity+0x134>
    }
    else
    {
      led_gpio_port->pmr1c = led_descriptor->GPIO.PIN_MASK;
800042d8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800042dc:	70 19       	ld.w	r9,r8[0x4]
800042de:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042e2:	91 a9       	st.w	r8[0x28],r9
    }
    led_gpio_port->gperc = led_descriptor->GPIO.PIN_MASK;
800042e4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800042e8:	70 19       	ld.w	r9,r8[0x4]
800042ea:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042ee:	91 29       	st.w	r8[0x8],r9
800042f0:	c0 28       	rjmp	800042f4 <LED_Set_Intensity+0x144>
  for (leds &= (1 << LED_COUNT) - 1; leds; leds >>= led_shift)
  {
    // Select the next specified LED and check that it has a PWM channel.
    led_shift = 1 + ctz(leds);
    led_descriptor += led_shift;
    if (led_descriptor->PWM.CHANNEL < 0) continue;
800042f2:	d7 03       	nop
  volatile avr32_pwm_channel_t *led_pwm_channel;
  volatile avr32_gpio_port_t *led_gpio_port;
  U8 led_shift;

  // For each specified LED...
  for (leds &= (1 << LED_COUNT) - 1; leds; leds >>= led_shift)
800042f4:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800042f8:	ee f9 ff ec 	ld.w	r9,r7[-20]
800042fc:	f2 08 0a 48 	lsr	r8,r9,r8
80004300:	ef 48 ff ec 	st.w	r7[-20],r8
80004304:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004308:	58 08       	cp.w	r8,0
8000430a:	fe 91 ff 67 	brne	800041d8 <LED_Set_Intensity+0x28>
    {
      led_gpio_port->pmr1c = led_descriptor->GPIO.PIN_MASK;
    }
    led_gpio_port->gperc = led_descriptor->GPIO.PIN_MASK;
  }
}
8000430e:	2f ad       	sub	sp,-24
80004310:	e3 cd 80 80 	ldm	sp++,r7,pc
80004314:	80 00       	ld.sh	r0,r0[0x0]
80004316:	c8 74       	brge	80004224 <LED_Set_Intensity+0x74>

80004318 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80004318:	eb cd 40 80 	pushm	r7,lr
8000431c:	1a 97       	mov	r7,sp
8000431e:	20 4d       	sub	sp,16
80004320:	ef 4c ff f4 	st.w	r7[-12],r12
80004324:	ef 4b ff f0 	st.w	r7[-16],r11
	uint32_t status = GPIO_SUCCESS;
80004328:	30 08       	mov	r8,0
8000432a:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t i;

	for (i = 0; i < size; i++) {
8000432e:	30 08       	mov	r8,0
80004330:	ef 48 ff fc 	st.w	r7[-4],r8
80004334:	c1 c8       	rjmp	8000436c <gpio_enable_module+0x54>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80004336:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000433a:	70 19       	ld.w	r9,r8[0x4]
8000433c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004340:	70 08       	ld.w	r8,r8[0x0]
80004342:	12 9b       	mov	r11,r9
80004344:	10 9c       	mov	r12,r8
80004346:	f0 1f 00 10 	mcall	80004384 <gpio_enable_module+0x6c>
8000434a:	18 98       	mov	r8,r12
8000434c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004350:	f3 e8 10 08 	or	r8,r9,r8
80004354:	ef 48 ff f8 	st.w	r7[-8],r8
		gpiomap++;
80004358:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000435c:	2f 88       	sub	r8,-8
8000435e:	ef 48 ff f4 	st.w	r7[-12],r8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80004362:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004366:	2f f8       	sub	r8,-1
80004368:	ef 48 ff fc 	st.w	r7[-4],r8
8000436c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004370:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004374:	10 39       	cp.w	r9,r8
80004376:	ce 03       	brcs	80004336 <gpio_enable_module+0x1e>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
80004378:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
8000437c:	10 9c       	mov	r12,r8
8000437e:	2f cd       	sub	sp,-16
80004380:	e3 cd 80 80 	ldm	sp++,r7,pc
80004384:	80 00       	ld.sh	r0,r0[0x0]
80004386:	43 88       	lddsp	r8,sp[0xe0]

80004388 <gpio_enable_module_pin>:
 * \param function The pin function.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
80004388:	eb cd 40 80 	pushm	r7,lr
8000438c:	1a 97       	mov	r7,sp
8000438e:	20 3d       	sub	sp,12
80004390:	ef 4c ff f8 	st.w	r7[-8],r12
80004394:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004398:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000439c:	a5 98       	lsr	r8,0x5
8000439e:	a9 68       	lsl	r8,0x8
800043a0:	e0 28 f0 00 	sub	r8,61440
800043a4:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Enable the correct function. */
	switch (function) {
800043a8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800043ac:	58 18       	cp.w	r8,1
800043ae:	c1 e0       	breq	800043ea <gpio_enable_module_pin+0x62>
800043b0:	c0 63       	brcs	800043bc <gpio_enable_module_pin+0x34>
800043b2:	58 28       	cp.w	r8,2
800043b4:	c3 20       	breq	80004418 <gpio_enable_module_pin+0x90>
800043b6:	58 38       	cp.w	r8,3
800043b8:	c4 70       	breq	80004446 <gpio_enable_module_pin+0xbe>
800043ba:	c5 d8       	rjmp	80004474 <gpio_enable_module_pin+0xec>
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800043bc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800043c0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800043c4:	30 19       	mov	r9,1
800043c6:	f2 08 09 48 	lsl	r8,r9,r8
800043ca:	10 99       	mov	r9,r8
800043cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043d0:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800043d2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800043d6:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800043da:	30 19       	mov	r9,1
800043dc:	f2 08 09 48 	lsl	r8,r9,r8
800043e0:	10 99       	mov	r9,r8
800043e2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043e6:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800043e8:	c4 88       	rjmp	80004478 <gpio_enable_module_pin+0xf0>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800043ea:	ee f8 ff f8 	ld.w	r8,r7[-8]
800043ee:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800043f2:	30 19       	mov	r9,1
800043f4:	f2 08 09 48 	lsl	r8,r9,r8
800043f8:	10 99       	mov	r9,r8
800043fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043fe:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004400:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004404:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004408:	30 19       	mov	r9,1
8000440a:	f2 08 09 48 	lsl	r8,r9,r8
8000440e:	10 99       	mov	r9,r8
80004410:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004414:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004416:	c3 18       	rjmp	80004478 <gpio_enable_module_pin+0xf0>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004418:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000441c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004420:	30 19       	mov	r9,1
80004422:	f2 08 09 48 	lsl	r8,r9,r8
80004426:	10 99       	mov	r9,r8
80004428:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000442c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000442e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004432:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004436:	30 19       	mov	r9,1
80004438:	f2 08 09 48 	lsl	r8,r9,r8
8000443c:	10 99       	mov	r9,r8
8000443e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004442:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004444:	c1 a8       	rjmp	80004478 <gpio_enable_module_pin+0xf0>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004446:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000444a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000444e:	30 19       	mov	r9,1
80004450:	f2 08 09 48 	lsl	r8,r9,r8
80004454:	10 99       	mov	r9,r8
80004456:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000445a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000445c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004460:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004464:	30 19       	mov	r9,1
80004466:	f2 08 09 48 	lsl	r8,r9,r8
8000446a:	10 99       	mov	r9,r8
8000446c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004470:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004472:	c0 38       	rjmp	80004478 <gpio_enable_module_pin+0xf0>
		gpio_port->pmr2s = 1 << (pin & 0x1F);
		break;
#endif

	default:
		return GPIO_INVALID_ARGUMENT;
80004474:	30 18       	mov	r8,1
80004476:	c0 d8       	rjmp	80004490 <gpio_enable_module_pin+0x108>
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80004478:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000447c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004480:	30 19       	mov	r9,1
80004482:	f2 08 09 48 	lsl	r8,r9,r8
80004486:	10 99       	mov	r9,r8
80004488:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000448c:	91 29       	st.w	r8[0x8],r9

	return GPIO_SUCCESS;
8000448e:	30 08       	mov	r8,0
}
80004490:	10 9c       	mov	r12,r8
80004492:	2f dd       	sub	sp,-12
80004494:	e3 cd 80 80 	ldm	sp++,r7,pc

80004498 <gpio_set_gpio_pin>:
/** \brief Drives a GPIO pin to 1.
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
80004498:	eb cd 40 80 	pushm	r7,lr
8000449c:	1a 97       	mov	r7,sp
8000449e:	20 2d       	sub	sp,8
800044a0:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800044a4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044a8:	a5 98       	lsr	r8,0x5
800044aa:	a9 68       	lsl	r8,0x8
800044ac:	e0 28 f0 00 	sub	r8,61440
800044b0:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
800044b4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044b8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800044bc:	30 19       	mov	r9,1
800044be:	f2 08 09 48 	lsl	r8,r9,r8
800044c2:	10 99       	mov	r9,r8
800044c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800044c8:	f1 49 00 54 	st.w	r8[84],r9
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
800044cc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044d0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800044d4:	30 19       	mov	r9,1
800044d6:	f2 08 09 48 	lsl	r8,r9,r8
800044da:	10 99       	mov	r9,r8
800044dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800044e0:	f1 49 00 44 	st.w	r8[68],r9
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800044e4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044e8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800044ec:	30 19       	mov	r9,1
800044ee:	f2 08 09 48 	lsl	r8,r9,r8
800044f2:	10 99       	mov	r9,r8
800044f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800044f8:	91 19       	st.w	r8[0x4],r9
}
800044fa:	2f ed       	sub	sp,-8
800044fc:	e3 cd 80 80 	ldm	sp++,r7,pc

80004500 <gpio_clr_gpio_pin>:
/** \brief Drives a GPIO pin to 0.
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
80004500:	eb cd 40 80 	pushm	r7,lr
80004504:	1a 97       	mov	r7,sp
80004506:	20 2d       	sub	sp,8
80004508:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000450c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004510:	a5 98       	lsr	r8,0x5
80004512:	a9 68       	lsl	r8,0x8
80004514:	e0 28 f0 00 	sub	r8,61440
80004518:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000451c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004520:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004524:	30 19       	mov	r9,1
80004526:	f2 08 09 48 	lsl	r8,r9,r8
8000452a:	10 99       	mov	r9,r8
8000452c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004530:	f1 49 00 58 	st.w	r8[88],r9
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80004534:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004538:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000453c:	30 19       	mov	r9,1
8000453e:	f2 08 09 48 	lsl	r8,r9,r8
80004542:	10 99       	mov	r9,r8
80004544:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004548:	f1 49 00 44 	st.w	r8[68],r9
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000454c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004550:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004554:	30 19       	mov	r9,1
80004556:	f2 08 09 48 	lsl	r8,r9,r8
8000455a:	10 99       	mov	r9,r8
8000455c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004560:	91 19       	st.w	r8[0x4],r9
}
80004562:	2f ed       	sub	sp,-8
80004564:	e3 cd 80 80 	ldm	sp++,r7,pc

80004568 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004568:	eb cd 40 80 	pushm	r7,lr
8000456c:	1a 97       	mov	r7,sp
	// Catch unregistered interrupts.
	while (true);
8000456e:	c0 08       	rjmp	8000456e <_unhandled_interrupt+0x6>

80004570 <_get_interrupt_handler>:
 *
 * \return Interrupt handler to execute.
 */
__int_handler _get_interrupt_handler(uint32_t int_level);
__int_handler _get_interrupt_handler(uint32_t int_level)
{
80004570:	eb cd 40 80 	pushm	r7,lr
80004574:	1a 97       	mov	r7,sp
80004576:	20 3d       	sub	sp,12
80004578:	ef 4c ff f4 	st.w	r7[-12],r12
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
8000457c:	fe 78 08 00 	mov	r8,-63488
80004580:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004584:	f2 09 11 03 	rsub	r9,r9,3
80004588:	28 09       	sub	r9,-128
8000458a:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
8000458e:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004592:	fe 78 08 00 	mov	r8,-63488
80004596:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000459a:	2c 09       	sub	r9,-64
8000459c:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800045a0:	ef 48 ff fc 	st.w	r7[-4],r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800045a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800045a8:	58 08       	cp.w	r8,0
800045aa:	c1 30       	breq	800045d0 <_get_interrupt_handler+0x60>
		? _int_handler_table[int_grp]._int_line_handler_table[32
800045ac:	ee f9 ff f8 	ld.w	r9,r7[-8]
800045b0:	48 b8       	lddpc	r8,800045dc <_get_interrupt_handler+0x6c>
800045b2:	a1 79       	lsl	r9,0x1
800045b4:	2f f9       	sub	r9,-1
800045b6:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
800045ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800045be:	f0 08 12 00 	clz	r8,r8
800045c2:	f0 08 11 1f 	rsub	r8,r8,31
			- clz(int_req) - 1]
800045c6:	a3 68       	lsl	r8,0x2
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
800045c8:	f2 08 00 08 	add	r8,r9,r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800045cc:	70 08       	ld.w	r8,r8[0x0]
800045ce:	c0 28       	rjmp	800045d2 <_get_interrupt_handler+0x62>
800045d0:	30 08       	mov	r8,0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800045d2:	10 9c       	mov	r12,r8
800045d4:	2f dd       	sub	sp,-12
800045d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800045da:	00 00       	add	r0,r0
800045dc:	80 00       	ld.sh	r0,r0[0x0]
800045de:	c8 f4       	brge	800044fc <gpio_set_gpio_pin+0x64>

800045e0 <INTC_init_evba>:
 * \internal
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
800045e0:	eb cd 40 80 	pushm	r7,lr
800045e4:	1a 97       	mov	r7,sp
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800045e6:	48 38       	lddpc	r8,800045f0 <INTC_init_evba+0x10>
800045e8:	e3 b8 00 01 	mtsr	0x4,r8
}
800045ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800045f0:	80 00       	ld.sh	r0,r0[0x0]
800045f2:	c6 00       	breq	800046b2 <INTC_register_interrupt+0x26>

800045f4 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800045f4:	eb cd 40 80 	pushm	r7,lr
800045f8:	1a 97       	mov	r7,sp
800045fa:	20 2d       	sub	sp,8
	uint32_t int_grp, int_req;

	INTC_init_evba();
800045fc:	f0 1f 00 1f 	mcall	80004678 <INTC_init_interrupts+0x84>

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004600:	30 08       	mov	r8,0
80004602:	ef 48 ff f8 	st.w	r7[-8],r8
80004606:	c3 18       	rjmp	80004668 <INTC_init_interrupts+0x74>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004608:	30 08       	mov	r8,0
8000460a:	ef 48 ff fc 	st.w	r7[-4],r8
8000460e:	c1 48       	rjmp	80004636 <INTC_init_interrupts+0x42>
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004610:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004614:	49 a8       	lddpc	r8,8000467c <INTC_init_interrupts+0x88>
80004616:	a1 79       	lsl	r9,0x1
80004618:	2f f9       	sub	r9,-1
8000461a:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
8000461e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004622:	a3 68       	lsl	r8,0x2
80004624:	f2 08 00 08 	add	r8,r9,r8
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004628:	49 69       	lddpc	r9,80004680 <INTC_init_interrupts+0x8c>
8000462a:	91 09       	st.w	r8[0x0],r9
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
8000462c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004630:	2f f8       	sub	r8,-1
80004632:	ef 48 ff fc 	st.w	r7[-4],r8
	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
80004636:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000463a:	49 18       	lddpc	r8,8000467c <INTC_init_interrupts+0x88>
8000463c:	f0 09 03 39 	ld.w	r9,r8[r9<<0x3]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004640:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004644:	10 39       	cp.w	r9,r8
80004646:	fe 9b ff e5 	brhi	80004610 <INTC_init_interrupts+0x1c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000464a:	fe 78 08 00 	mov	r8,-63488
8000464e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004652:	48 db       	lddpc	r11,80004684 <INTC_init_interrupts+0x90>
80004654:	48 da       	lddpc	r10,80004688 <INTC_init_interrupts+0x94>
80004656:	f6 0a 01 0a 	sub	r10,r11,r10
8000465a:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
8000465e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004662:	2f f8       	sub	r8,-1
80004664:	ef 48 ff f8 	st.w	r7[-8],r8
80004668:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000466c:	59 38       	cp.w	r8,19
8000466e:	fe 98 ff cd 	brls	80004608 <INTC_init_interrupts+0x14>
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	}
}
80004672:	2f ed       	sub	sp,-8
80004674:	e3 cd 80 80 	ldm	sp++,r7,pc
80004678:	80 00       	ld.sh	r0,r0[0x0]
8000467a:	45 e0       	lddsp	r0,sp[0x178]
8000467c:	80 00       	ld.sh	r0,r0[0x0]
8000467e:	c8 f4       	brge	8000459c <_get_interrupt_handler+0x2c>
80004680:	80 00       	ld.sh	r0,r0[0x0]
80004682:	45 68       	lddsp	r8,sp[0x158]
80004684:	80 00       	ld.sh	r0,r0[0x0]
80004686:	c7 04       	brge	80004766 <pm_set_osc0_mode+0x6>
80004688:	80 00       	ld.sh	r0,r0[0x0]
8000468a:	c6 00       	breq	8000474a <INTC_register_interrupt+0xbe>

8000468c <INTC_register_interrupt>:
 *          be effective.
 *
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
8000468c:	eb cd 40 80 	pushm	r7,lr
80004690:	1a 97       	mov	r7,sp
80004692:	20 4d       	sub	sp,16
80004694:	ef 4c ff f8 	st.w	r7[-8],r12
80004698:	ef 4b ff f4 	st.w	r7[-12],r11
8000469c:	ef 4a ff f0 	st.w	r7[-16],r10
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800046a0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800046a4:	a5 98       	lsr	r8,0x5
800046a6:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800046aa:	ee f9 ff fc 	ld.w	r9,r7[-4]
800046ae:	4a 78       	lddpc	r8,80004748 <INTC_register_interrupt+0xbc>
800046b0:	a1 79       	lsl	r9,0x1
800046b2:	2f f9       	sub	r9,-1
800046b4:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
800046b8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800046bc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800046c0:	a3 68       	lsl	r8,0x2
800046c2:	f2 08 00 08 	add	r8,r9,r8
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800046c6:	ee f9 ff f8 	ld.w	r9,r7[-8]
800046ca:	91 09       	st.w	r8[0x0],r9
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800046cc:	ee f8 ff f0 	ld.w	r8,r7[-16]
800046d0:	58 08       	cp.w	r8,0
800046d2:	c0 c1       	brne	800046ea <INTC_register_interrupt+0x5e>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800046d4:	fe 78 08 00 	mov	r8,-63488
800046d8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800046dc:	49 cb       	lddpc	r11,8000474c <INTC_register_interrupt+0xc0>
800046de:	49 da       	lddpc	r10,80004750 <INTC_register_interrupt+0xc4>
800046e0:	f6 0a 01 0a 	sub	r10,r11,r10
800046e4:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
800046e8:	c2 d8       	rjmp	80004742 <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT1) {
800046ea:	ee f8 ff f0 	ld.w	r8,r7[-16]
800046ee:	58 18       	cp.w	r8,1
800046f0:	c0 d1       	brne	8000470a <INTC_register_interrupt+0x7e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800046f2:	fe 78 08 00 	mov	r8,-63488
800046f6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800046fa:	49 7b       	lddpc	r11,80004754 <INTC_register_interrupt+0xc8>
800046fc:	49 5a       	lddpc	r10,80004750 <INTC_register_interrupt+0xc4>
800046fe:	f6 0a 01 0a 	sub	r10,r11,r10
80004702:	bf aa       	sbr	r10,0x1e
80004704:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004708:	c1 d8       	rjmp	80004742 <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT2) {
8000470a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000470e:	58 28       	cp.w	r8,2
80004710:	c0 d1       	brne	8000472a <INTC_register_interrupt+0x9e>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004712:	fe 78 08 00 	mov	r8,-63488
80004716:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000471a:	49 0b       	lddpc	r11,80004758 <INTC_register_interrupt+0xcc>
8000471c:	48 da       	lddpc	r10,80004750 <INTC_register_interrupt+0xc4>
8000471e:	f6 0a 01 0a 	sub	r10,r11,r10
80004722:	bf ba       	sbr	r10,0x1f
80004724:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004728:	c0 d8       	rjmp	80004742 <INTC_register_interrupt+0xb6>
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
8000472a:	fe 78 08 00 	mov	r8,-63488
8000472e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004732:	48 bb       	lddpc	r11,8000475c <INTC_register_interrupt+0xd0>
80004734:	48 7a       	lddpc	r10,80004750 <INTC_register_interrupt+0xc4>
80004736:	f6 0a 01 0a 	sub	r10,r11,r10
8000473a:	ea 1a c0 00 	orh	r10,0xc000
8000473e:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	}
}
80004742:	2f cd       	sub	sp,-16
80004744:	e3 cd 80 80 	ldm	sp++,r7,pc
80004748:	80 00       	ld.sh	r0,r0[0x0]
8000474a:	c8 f4       	brge	80004668 <INTC_init_interrupts+0x74>
8000474c:	80 00       	ld.sh	r0,r0[0x0]
8000474e:	c7 04       	brge	8000482e <pm_enable_clk0+0x1e>
80004750:	80 00       	ld.sh	r0,r0[0x0]
80004752:	c6 00       	breq	80004812 <pm_enable_clk0+0x2>
80004754:	80 00       	ld.sh	r0,r0[0x0]
80004756:	c7 12       	brcc	80004838 <pm_enable_clk0+0x28>
80004758:	80 00       	ld.sh	r0,r0[0x0]
8000475a:	c7 20       	breq	8000483e <pm_enable_clk0+0x2e>
8000475c:	80 00       	ld.sh	r0,r0[0x0]
8000475e:	c7 2e       	rcall	80004442 <gpio_enable_module_pin+0xba>

80004760 <pm_set_osc0_mode>:
 *
 * \param pm Base address of the Power Manager (i.e. &AVR32_PM).
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
80004760:	eb cd 40 80 	pushm	r7,lr
80004764:	1a 97       	mov	r7,sp
80004766:	20 3d       	sub	sp,12
80004768:	ef 4c ff f8 	st.w	r7[-8],r12
8000476c:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80004770:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004774:	70 a8       	ld.w	r8,r8[0x28]
80004776:	30 09       	mov	r9,0
80004778:	ef 49 ff fc 	st.w	r7[-4],r9
8000477c:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80004780:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004784:	5c 58       	castu.b	r8
80004786:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000478a:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000478e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004792:	f1 d9 d0 03 	bfins	r8,r9,0x0,0x3
80004796:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000479a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000479e:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047a2:	91 a9       	st.w	r8[0x28],r9
}
800047a4:	2f dd       	sub	sp,-12
800047a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800047aa:	d7 03       	nop

800047ac <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
800047ac:	eb cd 40 80 	pushm	r7,lr
800047b0:	1a 97       	mov	r7,sp
800047b2:	20 2d       	sub	sp,8
800047b4:	ef 4c ff fc 	st.w	r7[-4],r12
800047b8:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
800047bc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047c0:	ec 58 bb 9f 	cp.w	r8,899999
800047c4:	e0 88 00 1a 	brls	800047f8 <pm_enable_osc0_crystal+0x4c>
800047c8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047cc:	e0 69 c6 bf 	mov	r9,50879
800047d0:	ea 19 00 2d 	orh	r9,0x2d
800047d4:	12 38       	cp.w	r8,r9
800047d6:	e0 88 00 0f 	brls	800047f4 <pm_enable_osc0_crystal+0x48>
800047da:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047de:	e0 69 11 ff 	mov	r9,4607
800047e2:	ea 19 00 7a 	orh	r9,0x7a
800047e6:	12 38       	cp.w	r8,r9
800047e8:	e0 8b 00 04 	brhi	800047f0 <pm_enable_osc0_crystal+0x44>
800047ec:	30 68       	mov	r8,6
800047ee:	c0 28       	rjmp	800047f2 <pm_enable_osc0_crystal+0x46>
800047f0:	30 78       	mov	r8,7
800047f2:	c0 28       	rjmp	800047f6 <pm_enable_osc0_crystal+0x4a>
800047f4:	30 58       	mov	r8,5
800047f6:	c0 28       	rjmp	800047fa <pm_enable_osc0_crystal+0x4e>
800047f8:	30 48       	mov	r8,4
800047fa:	10 9b       	mov	r11,r8
800047fc:	ee fc ff fc 	ld.w	r12,r7[-4]
80004800:	f0 1f 00 03 	mcall	8000480c <pm_enable_osc0_crystal+0x60>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80004804:	2f ed       	sub	sp,-8
80004806:	e3 cd 80 80 	ldm	sp++,r7,pc
8000480a:	00 00       	add	r0,r0
8000480c:	80 00       	ld.sh	r0,r0[0x0]
8000480e:	47 60       	lddsp	r0,sp[0x1d8]

80004810 <pm_enable_clk0>:


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80004810:	eb cd 40 80 	pushm	r7,lr
80004814:	1a 97       	mov	r7,sp
80004816:	20 2d       	sub	sp,8
80004818:	ef 4c ff fc 	st.w	r7[-4],r12
8000481c:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_enable_clk0_no_wait(pm, startup);
80004820:	ee fb ff f8 	ld.w	r11,r7[-8]
80004824:	ee fc ff fc 	ld.w	r12,r7[-4]
80004828:	f0 1f 00 05 	mcall	8000483c <pm_enable_clk0+0x2c>
  pm_wait_for_clk0_ready(pm);
8000482c:	ee fc ff fc 	ld.w	r12,r7[-4]
80004830:	f0 1f 00 04 	mcall	80004840 <pm_enable_clk0+0x30>
}
80004834:	2f ed       	sub	sp,-8
80004836:	e3 cd 80 80 	ldm	sp++,r7,pc
8000483a:	00 00       	add	r0,r0
8000483c:	80 00       	ld.sh	r0,r0[0x0]
8000483e:	48 44       	lddpc	r4,8000484c <pm_enable_clk0_no_wait+0x8>
80004840:	80 00       	ld.sh	r0,r0[0x0]
80004842:	48 9e       	lddpc	lr,80004864 <pm_enable_clk0_no_wait+0x20>

80004844 <pm_enable_clk0_no_wait>:
  pm->mcctrl &= ~AVR32_PM_MCCTRL_OSC0EN_MASK;
}


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
80004844:	eb cd 40 80 	pushm	r7,lr
80004848:	1a 97       	mov	r7,sp
8000484a:	20 3d       	sub	sp,12
8000484c:	ef 4c ff f8 	st.w	r7[-8],r12
80004850:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80004854:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004858:	70 a8       	ld.w	r8,r8[0x28]
8000485a:	30 09       	mov	r9,0
8000485c:	ef 49 ff fc 	st.w	r7[-4],r9
80004860:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80004864:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004868:	5c 58       	castu.b	r8
8000486a:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000486e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80004872:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004876:	f1 d9 d1 03 	bfins	r8,r9,0x8,0x3
8000487a:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000487e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004882:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004886:	91 a9       	st.w	r8[0x28],r9

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80004888:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000488c:	70 08       	ld.w	r8,r8[0x0]
8000488e:	10 99       	mov	r9,r8
80004890:	a3 a9       	sbr	r9,0x2
80004892:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004896:	91 09       	st.w	r8[0x0],r9
}
80004898:	2f dd       	sub	sp,-12
8000489a:	e3 cd 80 80 	ldm	sp++,r7,pc

8000489e <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
8000489e:	eb cd 40 80 	pushm	r7,lr
800048a2:	1a 97       	mov	r7,sp
800048a4:	20 1d       	sub	sp,4
800048a6:	ef 4c ff fc 	st.w	r7[-4],r12
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800048aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800048ae:	71 58       	ld.w	r8,r8[0x54]
800048b0:	e2 18 00 80 	andl	r8,0x80,COH
800048b4:	cf b0       	breq	800048aa <pm_wait_for_clk0_ready+0xc>
}
800048b6:	2f fd       	sub	sp,-4
800048b8:	e3 cd 80 80 	ldm	sp++,r7,pc

800048bc <pm_switch_to_clock>:
  return u_avr32_pm_mcctrl.MCCTRL.mcsel;
}


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
800048bc:	eb cd 40 80 	pushm	r7,lr
800048c0:	1a 97       	mov	r7,sp
800048c2:	20 3d       	sub	sp,12
800048c4:	ef 4c ff f8 	st.w	r7[-8],r12
800048c8:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800048cc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048d0:	70 08       	ld.w	r8,r8[0x0]
800048d2:	30 09       	mov	r9,0
800048d4:	ef 49 ff fc 	st.w	r7[-4],r9
800048d8:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800048dc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800048e0:	5c 58       	castu.b	r8
800048e2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800048e6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800048ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800048ee:	f1 d9 d0 02 	bfins	r8,r9,0x0,0x2
800048f2:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800048f6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800048fa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048fe:	91 09       	st.w	r8[0x0],r9
}
80004900:	2f dd       	sub	sp,-12
80004902:	e3 cd 80 80 	ldm	sp++,r7,pc
80004906:	d7 03       	nop

80004908 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80004908:	eb cd 40 80 	pushm	r7,lr
8000490c:	1a 97       	mov	r7,sp
8000490e:	20 3d       	sub	sp,12
80004910:	ef 4c ff fc 	st.w	r7[-4],r12
80004914:	ef 4b ff f8 	st.w	r7[-8],r11
80004918:	ef 4a ff f4 	st.w	r7[-12],r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
8000491c:	ee fb ff f8 	ld.w	r11,r7[-8]
80004920:	ee fc ff fc 	ld.w	r12,r7[-4]
80004924:	f0 1f 00 08 	mcall	80004944 <pm_switch_to_osc0+0x3c>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80004928:	ee fb ff f4 	ld.w	r11,r7[-12]
8000492c:	ee fc ff fc 	ld.w	r12,r7[-4]
80004930:	f0 1f 00 06 	mcall	80004948 <pm_switch_to_osc0+0x40>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80004934:	30 1b       	mov	r11,1
80004936:	ee fc ff fc 	ld.w	r12,r7[-4]
8000493a:	f0 1f 00 05 	mcall	8000494c <pm_switch_to_osc0+0x44>
}
8000493e:	2f dd       	sub	sp,-12
80004940:	e3 cd 80 80 	ldm	sp++,r7,pc
80004944:	80 00       	ld.sh	r0,r0[0x0]
80004946:	47 ac       	lddsp	r12,sp[0x1e8]
80004948:	80 00       	ld.sh	r0,r0[0x0]
8000494a:	48 10       	lddpc	r0,8000494c <pm_switch_to_osc0+0x44>
8000494c:	80 00       	ld.sh	r0,r0[0x0]
8000494e:	48 bc       	lddpc	r12,80004978 <usart_set_async_baudrate+0x8>

80004950 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80004950:	eb cd 40 80 	pushm	r7,lr
80004954:	1a 97       	mov	r7,sp
80004956:	20 1d       	sub	sp,4
80004958:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
8000495c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004960:	e6 18 00 01 	andh	r8,0x1,COH
80004964:	5f 08       	sreq	r8
80004966:	5c 58       	castu.b	r8
}
80004968:	10 9c       	mov	r12,r8
8000496a:	2f fd       	sub	sp,-4
8000496c:	e3 cd 80 80 	ldm	sp++,r7,pc

80004970 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004970:	eb cd 40 80 	pushm	r7,lr
80004974:	1a 97       	mov	r7,sp
80004976:	20 7d       	sub	sp,28
80004978:	ef 4c ff ec 	st.w	r7[-20],r12
8000497c:	ef 4b ff e8 	st.w	r7[-24],r11
80004980:	ef 4a ff e4 	st.w	r7[-28],r10
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004984:	ee f8 ff e8 	ld.w	r8,r7[-24]
80004988:	f0 09 15 04 	lsl	r9,r8,0x4
8000498c:	ee f8 ff e4 	ld.w	r8,r7[-28]
80004990:	10 39       	cp.w	r9,r8
80004992:	e0 8b 00 04 	brhi	8000499a <usart_set_async_baudrate+0x2a>
80004996:	31 08       	mov	r8,16
80004998:	c0 28       	rjmp	8000499c <usart_set_async_baudrate+0x2c>
8000499a:	30 88       	mov	r8,8
8000499c:	ef 48 ff f0 	st.w	r7[-16],r8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800049a0:	ee f8 ff e4 	ld.w	r8,r7[-28]
800049a4:	f0 09 15 03 	lsl	r9,r8,0x3
800049a8:	ee fa ff f0 	ld.w	r10,r7[-16]
800049ac:	ee f8 ff e8 	ld.w	r8,r7[-24]
800049b0:	f4 08 02 48 	mul	r8,r10,r8
800049b4:	a1 98       	lsr	r8,0x1
800049b6:	f2 08 00 08 	add	r8,r9,r8
800049ba:	ee fa ff f0 	ld.w	r10,r7[-16]
800049be:	ee f9 ff e8 	ld.w	r9,r7[-24]
800049c2:	f4 09 02 49 	mul	r9,r10,r9
800049c6:	f0 09 0d 08 	divu	r8,r8,r9
800049ca:	ef 48 ff f4 	st.w	r7[-12],r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800049ce:	ee f8 ff f4 	ld.w	r8,r7[-12]
800049d2:	a3 98       	lsr	r8,0x3
800049d4:	ef 48 ff f8 	st.w	r7[-8],r8
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);
800049d8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800049dc:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800049e0:	ef 48 ff fc 	st.w	r7[-4],r8

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
800049e4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049e8:	58 08       	cp.w	r8,0
800049ea:	c0 70       	breq	800049f8 <usart_set_async_baudrate+0x88>
800049ec:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049f0:	e0 48 ff ff 	cp.w	r8,65535
800049f4:	e0 88 00 04 	brls	800049fc <usart_set_async_baudrate+0x8c>
    return USART_INVALID_INPUT;
800049f8:	30 18       	mov	r8,1
800049fa:	c2 08       	rjmp	80004a3a <usart_set_async_baudrate+0xca>

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
800049fc:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004a00:	70 18       	ld.w	r8,r8[0x4]
80004a02:	10 99       	mov	r9,r8
80004a04:	e4 19 ff f7 	andh	r9,0xfff7
80004a08:	e0 19 fe cf 	andl	r9,0xfecf
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004a0c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004a10:	59 08       	cp.w	r8,16
80004a12:	c0 40       	breq	80004a1a <usart_set_async_baudrate+0xaa>
80004a14:	e8 68 00 00 	mov	r8,524288
80004a18:	c0 28       	rjmp	80004a1c <usart_set_async_baudrate+0xac>
80004a1a:	30 08       	mov	r8,0
80004a1c:	10 49       	or	r9,r8
80004a1e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004a22:	91 19       	st.w	r8[0x4],r9
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
                fp << AVR32_USART_BRGR_FP_OFFSET;
80004a24:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a28:	f0 09 15 10 	lsl	r9,r8,0x10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004a2c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a30:	10 49       	or	r9,r8
80004a32:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004a36:	91 89       	st.w	r8[0x20],r9
                fp << AVR32_USART_BRGR_FP_OFFSET;

  return USART_SUCCESS;
80004a38:	30 08       	mov	r8,0
}
80004a3a:	10 9c       	mov	r12,r8
80004a3c:	2f 9d       	sub	sp,-28
80004a3e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a42:	d7 03       	nop

80004a44 <usart_reset>:
 */
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
80004a44:	eb cd 40 80 	pushm	r7,lr
80004a48:	1a 97       	mov	r7,sp
80004a4a:	20 2d       	sub	sp,8
80004a4c:	ef 4c ff f8 	st.w	r7[-8],r12
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004a50:	e1 b8 00 00 	mfsr	r8,0x0
80004a54:	10 9c       	mov	r12,r8
80004a56:	f0 1f 00 18 	mcall	80004ab4 <usart_reset+0x70>
80004a5a:	18 98       	mov	r8,r12
80004a5c:	ef 68 ff ff 	st.b	r7[-1],r8

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80004a60:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80004a64:	30 08       	mov	r8,0
80004a66:	f0 09 18 00 	cp.b	r9,r8
80004a6a:	c0 20       	breq	80004a6e <usart_reset+0x2a>
80004a6c:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004a6e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a72:	3f f9       	mov	r9,-1
80004a74:	91 39       	st.w	r8[0xc],r9
  usart->csr;
80004a76:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a7a:	70 58       	ld.w	r8,r8[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80004a7c:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80004a80:	30 08       	mov	r8,0
80004a82:	f0 09 18 00 	cp.b	r9,r8
80004a86:	c0 20       	breq	80004a8a <usart_reset+0x46>
80004a88:	d5 03       	csrf	0x10

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004a8a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a8e:	30 09       	mov	r9,0
80004a90:	91 19       	st.w	r8[0x4],r9
  usart->rtor = 0;
80004a92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a96:	30 09       	mov	r9,0
80004a98:	91 99       	st.w	r8[0x24],r9
  usart->ttgr = 0;
80004a9a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a9e:	30 09       	mov	r9,0
80004aa0:	91 a9       	st.w	r8[0x28],r9

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004aa2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004aa6:	ea 69 61 0c 	mov	r9,680204
80004aaa:	91 09       	st.w	r8[0x0],r9
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004aac:	2f ed       	sub	sp,-8
80004aae:	e3 cd 80 80 	ldm	sp++,r7,pc
80004ab2:	00 00       	add	r0,r0
80004ab4:	80 00       	ld.sh	r0,r0[0x0]
80004ab6:	49 50       	lddpc	r0,80004b08 <usart_init_rs232+0x50>

80004ab8 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004ab8:	eb cd 40 80 	pushm	r7,lr
80004abc:	1a 97       	mov	r7,sp
80004abe:	20 3d       	sub	sp,12
80004ac0:	ef 4c ff fc 	st.w	r7[-4],r12
80004ac4:	ef 4b ff f8 	st.w	r7[-8],r11
80004ac8:	ef 4a ff f4 	st.w	r7[-12],r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004acc:	ee fc ff fc 	ld.w	r12,r7[-4]
80004ad0:	f0 1f 00 54 	mcall	80004c20 <usart_init_rs232+0x168>

  // Check input values.
  if (!opt || // Null pointer.
80004ad4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ad8:	58 08       	cp.w	r8,0
80004ada:	c3 90       	breq	80004b4c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80004adc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ae0:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004ae2:	30 48       	mov	r8,4
80004ae4:	f0 09 18 00 	cp.b	r9,r8
80004ae8:	e0 88 00 32 	brls	80004b4c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80004aec:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004af0:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004af2:	30 98       	mov	r8,9
80004af4:	f0 09 18 00 	cp.b	r9,r8
80004af8:	e0 8b 00 2a 	brhi	80004b4c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004afc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b00:	11 d9       	ld.ub	r9,r8[0x5]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004b02:	30 78       	mov	r8,7
80004b04:	f0 09 18 00 	cp.b	r9,r8
80004b08:	e0 8b 00 22 	brhi	80004b4c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
80004b0c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b10:	90 39       	ld.sh	r9,r8[0x6]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004b12:	e0 68 01 01 	mov	r8,257
80004b16:	f0 09 19 00 	cp.h	r9,r8
80004b1a:	e0 8b 00 19 	brhi	80004b4c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
80004b1e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b22:	f1 39 00 08 	ld.ub	r9,r8[8]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004b26:	30 38       	mov	r8,3
80004b28:	f0 09 18 00 	cp.b	r9,r8
80004b2c:	e0 8b 00 10 	brhi	80004b4c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004b30:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004b34:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b38:	70 08       	ld.w	r8,r8[0x0]
80004b3a:	12 9a       	mov	r10,r9
80004b3c:	10 9b       	mov	r11,r8
80004b3e:	ee fc ff fc 	ld.w	r12,r7[-4]
80004b42:	f0 1f 00 39 	mcall	80004c24 <usart_init_rs232+0x16c>
80004b46:	18 98       	mov	r8,r12
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004b48:	58 18       	cp.w	r8,1
80004b4a:	c0 31       	brne	80004b50 <usart_init_rs232+0x98>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;
80004b4c:	30 18       	mov	r8,1
80004b4e:	c6 48       	rjmp	80004c16 <usart_init_rs232+0x15e>

  if (opt->charlength == 9)
80004b50:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b54:	11 c9       	ld.ub	r9,r8[0x4]
80004b56:	30 98       	mov	r8,9
80004b58:	f0 09 18 00 	cp.b	r9,r8
80004b5c:	c0 a1       	brne	80004b70 <usart_init_rs232+0xb8>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004b5e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b62:	70 18       	ld.w	r8,r8[0x4]
80004b64:	10 99       	mov	r9,r8
80004b66:	b1 b9       	sbr	r9,0x11
80004b68:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b6c:	91 19       	st.w	r8[0x4],r9
80004b6e:	c0 d8       	rjmp	80004b88 <usart_init_rs232+0xd0>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004b70:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b74:	70 19       	ld.w	r9,r8[0x4]
80004b76:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b7a:	11 c8       	ld.ub	r8,r8[0x4]
80004b7c:	20 58       	sub	r8,5
80004b7e:	a7 68       	lsl	r8,0x6
80004b80:	10 49       	or	r9,r8
80004b82:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b86:	91 19       	st.w	r8[0x4],r9
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004b88:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b8c:	70 19       	ld.w	r9,r8[0x4]
80004b8e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b92:	11 d8       	ld.ub	r8,r8[0x5]
80004b94:	f0 0a 15 09 	lsl	r10,r8,0x9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;
80004b98:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b9c:	f1 38 00 08 	ld.ub	r8,r8[8]
80004ba0:	af 68       	lsl	r8,0xe
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004ba2:	f5 e8 10 08 	or	r8,r10,r8
80004ba6:	10 49       	or	r9,r8
80004ba8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bac:	91 19       	st.w	r8[0x4],r9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004bae:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004bb2:	90 39       	ld.sh	r9,r8[0x6]
80004bb4:	30 28       	mov	r8,2
80004bb6:	f0 09 19 00 	cp.h	r9,r8
80004bba:	e0 88 00 14 	brls	80004be2 <usart_init_rs232+0x12a>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004bbe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bc2:	70 18       	ld.w	r8,r8[0x4]
80004bc4:	10 99       	mov	r9,r8
80004bc6:	ad b9       	sbr	r9,0xd
80004bc8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bcc:	91 19       	st.w	r8[0x4],r9
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004bce:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004bd2:	90 38       	ld.sh	r8,r8[0x6]
80004bd4:	5c 78       	castu.h	r8
80004bd6:	20 28       	sub	r8,2
80004bd8:	10 99       	mov	r9,r8
80004bda:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bde:	91 a9       	st.w	r8[0x28],r9
80004be0:	c0 d8       	rjmp	80004bfa <usart_init_rs232+0x142>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004be2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004be6:	70 19       	ld.w	r9,r8[0x4]
80004be8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004bec:	90 38       	ld.sh	r8,r8[0x6]
80004bee:	5c 78       	castu.h	r8
80004bf0:	ad 68       	lsl	r8,0xc
80004bf2:	10 49       	or	r9,r8
80004bf4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bf8:	91 19       	st.w	r8[0x4],r9

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004bfa:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bfe:	70 18       	ld.w	r8,r8[0x4]
80004c00:	10 99       	mov	r9,r8
80004c02:	e0 19 ff f0 	andl	r9,0xfff0
80004c06:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c0a:	91 19       	st.w	r8[0x4],r9
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004c0c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c10:	35 09       	mov	r9,80
80004c12:	91 09       	st.w	r8[0x0],r9
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004c14:	30 08       	mov	r8,0
}
80004c16:	10 9c       	mov	r12,r8
80004c18:	2f dd       	sub	sp,-12
80004c1a:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c1e:	00 00       	add	r0,r0
80004c20:	80 00       	ld.sh	r0,r0[0x0]
80004c22:	4a 44       	lddpc	r4,80004cb0 <usart_putchar+0x44>
80004c24:	80 00       	ld.sh	r0,r0[0x0]
80004c26:	49 70       	lddpc	r0,80004c80 <usart_putchar+0x14>

80004c28 <usart_write_char>:
  return USART_SUCCESS;
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
80004c28:	eb cd 40 80 	pushm	r7,lr
80004c2c:	1a 97       	mov	r7,sp
80004c2e:	20 3d       	sub	sp,12
80004c30:	ef 4c ff f8 	st.w	r7[-8],r12
80004c34:	ef 4b ff f4 	st.w	r7[-12],r11
80004c38:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c3c:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004c40:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c44:	70 58       	ld.w	r8,r8[0x14]
80004c46:	e2 18 00 02 	andl	r8,0x2,COH
80004c4a:	5f 18       	srne	r8
  if (usart_tx_ready(usart))
80004c4c:	58 08       	cp.w	r8,0
80004c4e:	c0 a0       	breq	80004c62 <usart_write_char+0x3a>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004c50:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004c54:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80004c58:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c5c:	91 79       	st.w	r8[0x1c],r9
    return USART_SUCCESS;
80004c5e:	30 08       	mov	r8,0
80004c60:	c0 28       	rjmp	80004c64 <usart_write_char+0x3c>
  }
  else
    return USART_TX_BUSY;
80004c62:	30 28       	mov	r8,2
}
80004c64:	10 9c       	mov	r12,r8
80004c66:	2f dd       	sub	sp,-12
80004c68:	e3 cd 80 80 	ldm	sp++,r7,pc

80004c6c <usart_putchar>:


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004c6c:	eb cd 40 80 	pushm	r7,lr
80004c70:	1a 97       	mov	r7,sp
80004c72:	20 3d       	sub	sp,12
80004c74:	ef 4c ff f8 	st.w	r7[-8],r12
80004c78:	ef 4b ff f4 	st.w	r7[-12],r11
  int timeout = USART_DEFAULT_TIMEOUT;
80004c7c:	e0 68 27 10 	mov	r8,10000
80004c80:	ef 48 ff fc 	st.w	r7[-4],r8

  do
  {
    if (!timeout--) return USART_FAILURE;
80004c84:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c88:	58 08       	cp.w	r8,0
80004c8a:	5f 08       	sreq	r8
80004c8c:	5c 58       	castu.b	r8
80004c8e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004c92:	20 19       	sub	r9,1
80004c94:	ef 49 ff fc 	st.w	r7[-4],r9
80004c98:	58 08       	cp.w	r8,0
80004c9a:	c0 30       	breq	80004ca0 <usart_putchar+0x34>
80004c9c:	3f f8       	mov	r8,-1
80004c9e:	c0 b8       	rjmp	80004cb4 <usart_putchar+0x48>
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004ca0:	ee fb ff f4 	ld.w	r11,r7[-12]
80004ca4:	ee fc ff f8 	ld.w	r12,r7[-8]
80004ca8:	f0 1f 00 05 	mcall	80004cbc <usart_putchar+0x50>
80004cac:	18 98       	mov	r8,r12
80004cae:	58 08       	cp.w	r8,0
80004cb0:	ce a1       	brne	80004c84 <usart_putchar+0x18>

  return USART_SUCCESS;
80004cb2:	30 08       	mov	r8,0
}
80004cb4:	10 9c       	mov	r12,r8
80004cb6:	2f dd       	sub	sp,-12
80004cb8:	e3 cd 80 80 	ldm	sp++,r7,pc
80004cbc:	80 00       	ld.sh	r0,r0[0x0]
80004cbe:	4c 28       	lddpc	r8,80004dc4 <vListInitialise+0x2c>

80004cc0 <usart_read_char>:


int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
80004cc0:	eb cd 40 80 	pushm	r7,lr
80004cc4:	1a 97       	mov	r7,sp
80004cc6:	20 3d       	sub	sp,12
80004cc8:	ef 4c ff f8 	st.w	r7[-8],r12
80004ccc:	ef 4b ff f4 	st.w	r7[-12],r11
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004cd0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004cd4:	70 58       	ld.w	r8,r8[0x14]
80004cd6:	e2 18 00 e0 	andl	r8,0xe0,COH
80004cda:	c0 30       	breq	80004ce0 <usart_read_char+0x20>
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;
80004cdc:	30 48       	mov	r8,4
80004cde:	c1 68       	rjmp	80004d0a <usart_read_char+0x4a>
80004ce0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ce4:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004ce8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004cec:	70 58       	ld.w	r8,r8[0x14]
80004cee:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004cf2:	c0 b0       	breq	80004d08 <usart_read_char+0x48>
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004cf4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004cf8:	70 68       	ld.w	r8,r8[0x18]
80004cfa:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80004cfe:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d02:	91 09       	st.w	r8[0x0],r9
    return USART_SUCCESS;
80004d04:	30 08       	mov	r8,0
80004d06:	c0 28       	rjmp	80004d0a <usart_read_char+0x4a>
  }
  else
    return USART_RX_EMPTY;
80004d08:	30 38       	mov	r8,3
}
80004d0a:	10 9c       	mov	r12,r8
80004d0c:	2f dd       	sub	sp,-12
80004d0e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d12:	d7 03       	nop

80004d14 <usart_getchar>:


int usart_getchar(volatile avr32_usart_t *usart)
{
80004d14:	eb cd 40 80 	pushm	r7,lr
80004d18:	1a 97       	mov	r7,sp
80004d1a:	20 3d       	sub	sp,12
80004d1c:	ef 4c ff f4 	st.w	r7[-12],r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004d20:	ee c8 00 08 	sub	r8,r7,8
80004d24:	10 9b       	mov	r11,r8
80004d26:	ee fc ff f4 	ld.w	r12,r7[-12]
80004d2a:	f0 1f 00 0b 	mcall	80004d54 <usart_getchar+0x40>
80004d2e:	18 98       	mov	r8,r12
80004d30:	ef 48 ff fc 	st.w	r7[-4],r8
80004d34:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d38:	58 38       	cp.w	r8,3
80004d3a:	cf 30       	breq	80004d20 <usart_getchar+0xc>

  if (ret == USART_RX_ERROR)
80004d3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d40:	58 48       	cp.w	r8,4
80004d42:	c0 31       	brne	80004d48 <usart_getchar+0x34>
    return USART_FAILURE;
80004d44:	3f f8       	mov	r8,-1
80004d46:	c0 38       	rjmp	80004d4c <usart_getchar+0x38>

  return c;
80004d48:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80004d4c:	10 9c       	mov	r12,r8
80004d4e:	2f dd       	sub	sp,-12
80004d50:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d54:	80 00       	ld.sh	r0,r0[0x0]
80004d56:	4c c0       	lddpc	r0,80004e84 <vListInsert+0x14>

80004d58 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004d58:	eb cd 40 80 	pushm	r7,lr
80004d5c:	1a 97       	mov	r7,sp
80004d5e:	20 2d       	sub	sp,8
80004d60:	ef 4c ff fc 	st.w	r7[-4],r12
80004d64:	ef 4b ff f8 	st.w	r7[-8],r11
  while (*string != '\0')
80004d68:	c0 e8       	rjmp	80004d84 <usart_write_line+0x2c>
    usart_putchar(usart, *string++);
80004d6a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d6e:	11 88       	ld.ub	r8,r8[0x0]
80004d70:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004d74:	2f f9       	sub	r9,-1
80004d76:	ef 49 ff f8 	st.w	r7[-8],r9
80004d7a:	10 9b       	mov	r11,r8
80004d7c:	ee fc ff fc 	ld.w	r12,r7[-4]
80004d80:	f0 1f 00 05 	mcall	80004d94 <usart_write_line+0x3c>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80004d84:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d88:	11 88       	ld.ub	r8,r8[0x0]
80004d8a:	58 08       	cp.w	r8,0
80004d8c:	ce f1       	brne	80004d6a <usart_write_line+0x12>
    usart_putchar(usart, *string++);
}
80004d8e:	2f ed       	sub	sp,-8
80004d90:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d94:	80 00       	ld.sh	r0,r0[0x0]
80004d96:	4c 6c       	lddpc	r12,80004eac <vListInsert+0x3c>

80004d98 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
80004d98:	eb cd 40 80 	pushm	r7,lr
80004d9c:	1a 97       	mov	r7,sp
80004d9e:	20 1d       	sub	sp,4
80004da0:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004da4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004da8:	2f 88       	sub	r8,-8
80004daa:	10 99       	mov	r9,r8
80004dac:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004db0:	91 19       	st.w	r8[0x4],r9

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004db2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004db6:	3f f9       	mov	r9,-1
80004db8:	91 29       	st.w	r8[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004dba:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004dbe:	2f 88       	sub	r8,-8
80004dc0:	10 99       	mov	r9,r8
80004dc2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004dc6:	91 39       	st.w	r8[0xc],r9
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004dc8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004dcc:	2f 88       	sub	r8,-8
80004dce:	10 99       	mov	r9,r8
80004dd0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004dd4:	91 49       	st.w	r8[0x10],r9

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004dd6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004dda:	30 09       	mov	r9,0
80004ddc:	91 09       	st.w	r8[0x0],r9
}
80004dde:	2f fd       	sub	sp,-4
80004de0:	e3 cd 80 80 	ldm	sp++,r7,pc

80004de4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
80004de4:	eb cd 40 80 	pushm	r7,lr
80004de8:	1a 97       	mov	r7,sp
80004dea:	20 1d       	sub	sp,4
80004dec:	ef 4c ff fc 	st.w	r7[-4],r12
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004df0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004df4:	30 09       	mov	r9,0
80004df6:	91 49       	st.w	r8[0x10],r9
}
80004df8:	2f fd       	sub	sp,-4
80004dfa:	e3 cd 80 80 	ldm	sp++,r7,pc

80004dfe <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
80004dfe:	eb cd 40 80 	pushm	r7,lr
80004e02:	1a 97       	mov	r7,sp
80004e04:	20 3d       	sub	sp,12
80004e06:	ef 4c ff f8 	st.w	r7[-8],r12
80004e0a:	ef 4b ff f4 	st.w	r7[-12],r11

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004e0e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004e12:	70 18       	ld.w	r8,r8[0x4]
80004e14:	ef 48 ff fc 	st.w	r7[-4],r8

	pxNewListItem->pxNext = pxIndex->pxNext;
80004e18:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e1c:	70 19       	ld.w	r9,r8[0x4]
80004e1e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004e22:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004e24:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004e28:	70 19       	ld.w	r9,r8[0x4]
80004e2a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004e2e:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004e30:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e34:	70 18       	ld.w	r8,r8[0x4]
80004e36:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004e3a:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004e3c:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004e40:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e44:	91 19       	st.w	r8[0x4],r9
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004e46:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004e4a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004e4e:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004e50:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004e54:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004e58:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80004e5a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004e5e:	70 08       	ld.w	r8,r8[0x0]
80004e60:	f0 c9 ff ff 	sub	r9,r8,-1
80004e64:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004e68:	91 09       	st.w	r8[0x0],r9
}
80004e6a:	2f dd       	sub	sp,-12
80004e6c:	e3 cd 80 80 	ldm	sp++,r7,pc

80004e70 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
80004e70:	eb cd 40 80 	pushm	r7,lr
80004e74:	1a 97       	mov	r7,sp
80004e76:	20 4d       	sub	sp,16
80004e78:	ef 4c ff f4 	st.w	r7[-12],r12
80004e7c:	ef 4b ff f0 	st.w	r7[-16],r11
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004e80:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004e84:	70 08       	ld.w	r8,r8[0x0]
80004e86:	ef 48 ff fc 	st.w	r7[-4],r8
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004e8a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e8e:	5b f8       	cp.w	r8,-1
80004e90:	c0 71       	brne	80004e9e <vListInsert+0x2e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004e92:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004e96:	70 48       	ld.w	r8,r8[0x10]
80004e98:	ef 48 ff f8 	st.w	r7[-8],r8
80004e9c:	c1 58       	rjmp	80004ec6 <vListInsert+0x56>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004e9e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004ea2:	2f 88       	sub	r8,-8
80004ea4:	ef 48 ff f8 	st.w	r7[-8],r8
80004ea8:	c0 68       	rjmp	80004eb4 <vListInsert+0x44>
80004eaa:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004eae:	70 18       	ld.w	r8,r8[0x4]
80004eb0:	ef 48 ff f8 	st.w	r7[-8],r8
80004eb4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004eb8:	70 18       	ld.w	r8,r8[0x4]
80004eba:	70 09       	ld.w	r9,r8[0x0]
80004ebc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ec0:	10 39       	cp.w	r9,r8
80004ec2:	fe 98 ff f4 	brls	80004eaa <vListInsert+0x3a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004ec6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004eca:	70 19       	ld.w	r9,r8[0x4]
80004ecc:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004ed0:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004ed2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004ed6:	70 18       	ld.w	r8,r8[0x4]
80004ed8:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004edc:	91 29       	st.w	r8[0x8],r9
	pxNewListItem->pxPrevious = pxIterator;
80004ede:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004ee2:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004ee6:	91 29       	st.w	r8[0x8],r9
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004ee8:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004eec:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ef0:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004ef2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004ef6:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004efa:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80004efc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004f00:	70 08       	ld.w	r8,r8[0x0]
80004f02:	f0 c9 ff ff 	sub	r9,r8,-1
80004f06:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004f0a:	91 09       	st.w	r8[0x0],r9
}
80004f0c:	2f cd       	sub	sp,-16
80004f0e:	e3 cd 80 80 	ldm	sp++,r7,pc

80004f12 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
80004f12:	eb cd 40 80 	pushm	r7,lr
80004f16:	1a 97       	mov	r7,sp
80004f18:	20 2d       	sub	sp,8
80004f1a:	ef 4c ff f8 	st.w	r7[-8],r12
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004f1e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f22:	70 18       	ld.w	r8,r8[0x4]
80004f24:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004f28:	72 29       	ld.w	r9,r9[0x8]
80004f2a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004f2c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f30:	70 28       	ld.w	r8,r8[0x8]
80004f32:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004f36:	72 19       	ld.w	r9,r9[0x4]
80004f38:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004f3a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f3e:	70 48       	ld.w	r8,r8[0x10]
80004f40:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004f44:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f48:	70 19       	ld.w	r9,r8[0x4]
80004f4a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f4e:	10 39       	cp.w	r9,r8
80004f50:	c0 71       	brne	80004f5e <vListRemove+0x4c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004f52:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f56:	70 29       	ld.w	r9,r8[0x8]
80004f58:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f5c:	91 19       	st.w	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004f5e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f62:	30 09       	mov	r9,0
80004f64:	91 49       	st.w	r8[0x10],r9
	( pxList->uxNumberOfItems )--;
80004f66:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f6a:	70 08       	ld.w	r8,r8[0x0]
80004f6c:	f0 c9 00 01 	sub	r9,r8,1
80004f70:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f74:	91 09       	st.w	r8[0x0],r9
}
80004f76:	2f ed       	sub	sp,-8
80004f78:	e3 cd 80 80 	ldm	sp++,r7,pc

80004f7c <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80004f7c:	eb cd 40 80 	pushm	r7,lr
80004f80:	1a 97       	mov	r7,sp
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
80004f82:	48 e8       	lddpc	r8,80004fb8 <_init_startup+0x3c>
80004f84:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
80004f88:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
80004f8a:	f0 1f 00 0d 	mcall	80004fbc <_init_startup+0x40>
			.channelmode = USART_NORMAL_CHMODE
		};

		/* Initialize the USART used for the debug trace with the configured parameters. */
		extern volatile avr32_usart_t *volatile stdio_usart_base;
		stdio_usart_base = configDBG_USART;
80004f8e:	48 d8       	lddpc	r8,80004fc0 <_init_startup+0x44>
80004f90:	fe 79 18 00 	mov	r9,-59392
80004f94:	91 09       	st.w	r8[0x0],r9
		gpio_enable_module( DBG_USART_GPIO_MAP,
80004f96:	30 2b       	mov	r11,2
80004f98:	48 bc       	lddpc	r12,80004fc4 <_init_startup+0x48>
80004f9a:	f0 1f 00 0c 	mcall	80004fc8 <_init_startup+0x4c>
		                    sizeof( DBG_USART_GPIO_MAP ) / sizeof( DBG_USART_GPIO_MAP[0] ) );
		usart_init_rs232(configDBG_USART, &DBG_USART_OPTIONS, configPBA_CLOCK_HZ);
80004f9e:	e0 6a 1b 00 	mov	r10,6912
80004fa2:	ea 1a 00 b7 	orh	r10,0xb7
80004fa6:	48 ab       	lddpc	r11,80004fcc <_init_startup+0x50>
80004fa8:	fe 7c 18 00 	mov	r12,-59392
80004fac:	f0 1f 00 09 	mcall	80004fd0 <_init_startup+0x54>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
80004fb0:	30 18       	mov	r8,1
}
80004fb2:	10 9c       	mov	r12,r8
80004fb4:	e3 cd 80 80 	ldm	sp++,r7,pc
80004fb8:	80 00       	ld.sh	r0,r0[0x0]
80004fba:	c6 00       	breq	8000507a <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x12>
80004fbc:	80 00       	ld.sh	r0,r0[0x0]
80004fbe:	45 f4       	lddsp	r4,sp[0x17c]
80004fc0:	00 00       	add	r0,r0
80004fc2:	07 f8       	ld.ub	r8,r3[0x7]
80004fc4:	80 00       	ld.sh	r0,r0[0x0]
80004fc6:	c9 94       	brge	80004ef8 <vListInsert+0x88>
80004fc8:	80 00       	ld.sh	r0,r0[0x0]
80004fca:	43 18       	lddsp	r8,sp[0xc4]
80004fcc:	80 00       	ld.sh	r0,r0[0x0]
80004fce:	c9 a4       	brge	80004f02 <vListInsert+0x92>
80004fd0:	80 00       	ld.sh	r0,r0[0x0]
80004fd2:	4a b8       	lddpc	r8,8000507c <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x14>

80004fd4 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80004fd4:	eb cd 40 80 	pushm	r7,lr
80004fd8:	1a 97       	mov	r7,sp
80004fda:	20 1d       	sub	sp,4
80004fdc:	ef 4c ff fc 	st.w	r7[-4],r12
	vTaskSuspendAll();
80004fe0:	f0 1f 00 03 	mcall	80004fec <__malloc_lock+0x18>
}
80004fe4:	2f fd       	sub	sp,-4
80004fe6:	e3 cd 80 80 	ldm	sp++,r7,pc
80004fea:	00 00       	add	r0,r0
80004fec:	80 00       	ld.sh	r0,r0[0x0]
80004fee:	5f f8       	sral	r8

80004ff0 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80004ff0:	eb cd 40 80 	pushm	r7,lr
80004ff4:	1a 97       	mov	r7,sp
80004ff6:	20 1d       	sub	sp,4
80004ff8:	ef 4c ff fc 	st.w	r7[-4],r12
	xTaskResumeAll();
80004ffc:	f0 1f 00 03 	mcall	80005008 <__malloc_unlock+0x18>
}
80005000:	2f fd       	sub	sp,-4
80005002:	e3 cd 80 80 	ldm	sp++,r7,pc
80005006:	00 00       	add	r0,r0
80005008:	80 00       	ld.sh	r0,r0[0x0]
8000500a:	60 14       	ld.w	r4,r0[0x4]

8000500c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
8000500c:	eb cd 00 ff 	pushm	r0-r7
80005010:	e0 68 00 20 	mov	r8,32
80005014:	ea 18 00 00 	orh	r8,0x0
80005018:	70 00       	ld.w	r0,r8[0x0]
8000501a:	1a d0       	st.w	--sp,r0
8000501c:	7a 90       	ld.w	r0,sp[0x24]
8000501e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005022:	58 10       	cp.w	r0,1
80005024:	e0 8b 00 08 	brhi	80005034 <LABEL_INT_SKIP_SAVE_CONTEXT_234>
80005028:	e0 68 06 60 	mov	r8,1632
8000502c:	ea 18 00 00 	orh	r8,0x0
80005030:	70 00       	ld.w	r0,r8[0x0]
80005032:	81 0d       	st.w	r0[0x0],sp

80005034 <LABEL_INT_SKIP_SAVE_CONTEXT_234>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005034:	f0 1f 00 12 	mcall	8000507c <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005038:	f0 1f 00 12 	mcall	80005080 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
		vTaskIncrementTick();
8000503c:	f0 1f 00 12 	mcall	80005084 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x1c>
	portEXIT_CRITICAL();
80005040:	f0 1f 00 12 	mcall	80005088 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005044:	7a 90       	ld.w	r0,sp[0x24]
80005046:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000504a:	58 10       	cp.w	r0,1
8000504c:	e0 8b 00 0e 	brhi	80005068 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
80005050:	f0 1f 00 0c 	mcall	80005080 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
80005054:	f0 1f 00 0e 	mcall	8000508c <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x24>
80005058:	f0 1f 00 0c 	mcall	80005088 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>
8000505c:	e0 68 06 60 	mov	r8,1632
80005060:	ea 18 00 00 	orh	r8,0x0
80005064:	70 00       	ld.w	r0,r8[0x0]
80005066:	60 0d       	ld.w	sp,r0[0x0]

80005068 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>:
80005068:	1b 00       	ld.w	r0,sp++
8000506a:	e0 68 00 20 	mov	r8,32
8000506e:	ea 18 00 00 	orh	r8,0x0
80005072:	91 00       	st.w	r8[0x0],r0
80005074:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005078:	d6 03       	rete
8000507a:	00 00       	add	r0,r0
8000507c:	80 00       	ld.sh	r0,r0[0x0]
8000507e:	53 78       	stdsp	sp[0xdc],r8
80005080:	80 00       	ld.sh	r0,r0[0x0]
80005082:	51 28       	stdsp	sp[0x48],r8
80005084:	80 00       	ld.sh	r0,r0[0x0]
80005086:	61 3c       	ld.w	r12,r0[0x4c]
80005088:	80 00       	ld.sh	r0,r0[0x0]
8000508a:	51 44       	stdsp	sp[0x50],r4
8000508c:	80 00       	ld.sh	r0,r0[0x0]
8000508e:	62 9c       	ld.w	r12,r1[0x24]

80005090 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005090:	20 6d       	sub	sp,24
80005092:	eb cd 00 ff 	pushm	r0-r7
80005096:	fa c7 ff c0 	sub	r7,sp,-64
8000509a:	ee f0 ff f8 	ld.w	r0,r7[-8]
8000509e:	ef 40 ff e0 	st.w	r7[-32],r0
800050a2:	ee f0 ff fc 	ld.w	r0,r7[-4]
800050a6:	ef 40 ff e4 	st.w	r7[-28],r0
800050aa:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800050ae:	e0 68 00 20 	mov	r8,32
800050b2:	ea 18 00 00 	orh	r8,0x0
800050b6:	70 00       	ld.w	r0,r8[0x0]
800050b8:	1a d0       	st.w	--sp,r0
800050ba:	f0 1f 00 1a 	mcall	80005120 <LABEL_RET_SCALL_260+0x14>
800050be:	e0 68 06 60 	mov	r8,1632
800050c2:	ea 18 00 00 	orh	r8,0x0
800050c6:	70 00       	ld.w	r0,r8[0x0]
800050c8:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800050ca:	f0 1f 00 17 	mcall	80005124 <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
800050ce:	e0 68 06 60 	mov	r8,1632
800050d2:	ea 18 00 00 	orh	r8,0x0
800050d6:	70 00       	ld.w	r0,r8[0x0]
800050d8:	60 0d       	ld.w	sp,r0[0x0]
800050da:	1b 00       	ld.w	r0,sp++
800050dc:	e0 68 00 20 	mov	r8,32
800050e0:	ea 18 00 00 	orh	r8,0x0
800050e4:	91 00       	st.w	r8[0x0],r0
800050e6:	fa c7 ff d8 	sub	r7,sp,-40
800050ea:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800050ee:	ee f0 ff e0 	ld.w	r0,r7[-32]
800050f2:	e0 61 00 20 	mov	r1,32
800050f6:	ea 11 00 00 	orh	r1,0x0
800050fa:	62 02       	ld.w	r2,r1[0x0]
800050fc:	58 02       	cp.w	r2,0
800050fe:	c0 70       	breq	8000510c <LABEL_RET_SCALL_260>
80005100:	e4 c2 00 01 	sub	r2,r2,1
80005104:	83 02       	st.w	r1[0x0],r2
80005106:	58 02       	cp.w	r2,0
80005108:	c0 21       	brne	8000510c <LABEL_RET_SCALL_260>
8000510a:	b1 c0       	cbr	r0,0x10

8000510c <LABEL_RET_SCALL_260>:
8000510c:	ef 40 ff f8 	st.w	r7[-8],r0
80005110:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005114:	ef 40 ff fc 	st.w	r7[-4],r0
80005118:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000511c:	2f ad       	sub	sp,-24
8000511e:	d6 13       	rets
80005120:	80 00       	ld.sh	r0,r0[0x0]
80005122:	51 28       	stdsp	sp[0x48],r8
80005124:	80 00       	ld.sh	r0,r0[0x0]
80005126:	62 9c       	ld.w	r12,r1[0x24]

80005128 <vPortEnterCritical>:
/* The code generated by the GCC compiler uses the stack in different ways at
different optimisation levels.  The interrupt flags can therefore not always
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
80005128:	eb cd 40 80 	pushm	r7,lr
8000512c:	1a 97       	mov	r7,sp
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
8000512e:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005130:	48 48       	lddpc	r8,80005140 <vPortEnterCritical+0x18>
80005132:	70 08       	ld.w	r8,r8[0x0]
80005134:	f0 c9 ff ff 	sub	r9,r8,-1
80005138:	48 28       	lddpc	r8,80005140 <vPortEnterCritical+0x18>
8000513a:	91 09       	st.w	r8[0x0],r9
}
8000513c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005140:	00 00       	add	r0,r0
80005142:	00 20       	rsub	r0,r0

80005144 <vPortExitCritical>:
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
80005144:	eb cd 40 80 	pushm	r7,lr
80005148:	1a 97       	mov	r7,sp
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
8000514a:	48 98       	lddpc	r8,8000516c <vPortExitCritical+0x28>
8000514c:	70 08       	ld.w	r8,r8[0x0]
8000514e:	58 08       	cp.w	r8,0
80005150:	c0 c0       	breq	80005168 <vPortExitCritical+0x24>
	{
		ulCriticalNesting--;
80005152:	48 78       	lddpc	r8,8000516c <vPortExitCritical+0x28>
80005154:	70 08       	ld.w	r8,r8[0x0]
80005156:	f0 c9 00 01 	sub	r9,r8,1
8000515a:	48 58       	lddpc	r8,8000516c <vPortExitCritical+0x28>
8000515c:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
8000515e:	48 48       	lddpc	r8,8000516c <vPortExitCritical+0x28>
80005160:	70 08       	ld.w	r8,r8[0x0]
80005162:	58 08       	cp.w	r8,0
80005164:	c0 21       	brne	80005168 <vPortExitCritical+0x24>
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005166:	d5 03       	csrf	0x10
		}
	}
}
80005168:	e3 cd 80 80 	ldm	sp++,r7,pc
8000516c:	00 00       	add	r0,r0
8000516e:	00 20       	rsub	r0,r0

80005170 <pxPortInitialiseStack>:
 * portSAVE_CONTEXT had been called.
 *
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
80005170:	eb cd 40 80 	pushm	r7,lr
80005174:	1a 97       	mov	r7,sp
80005176:	20 3d       	sub	sp,12
80005178:	ef 4c ff fc 	st.w	r7[-4],r12
8000517c:	ef 4b ff f8 	st.w	r7[-8],r11
80005180:	ef 4a ff f4 	st.w	r7[-12],r10
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
80005184:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005188:	20 48       	sub	r8,4
8000518a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
8000518e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005192:	e0 69 08 08 	mov	r9,2056
80005196:	ea 19 08 08 	orh	r9,0x808
8000519a:	91 09       	st.w	r8[0x0],r9
8000519c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051a0:	20 48       	sub	r8,4
800051a2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
800051a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051aa:	e0 69 09 09 	mov	r9,2313
800051ae:	ea 19 09 09 	orh	r9,0x909
800051b2:	91 09       	st.w	r8[0x0],r9
800051b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051b8:	20 48       	sub	r8,4
800051ba:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800051be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051c2:	e0 69 0a 0a 	mov	r9,2570
800051c6:	ea 19 0a 0a 	orh	r9,0xa0a
800051ca:	91 09       	st.w	r8[0x0],r9
800051cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051d0:	20 48       	sub	r8,4
800051d2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800051d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051da:	e0 69 0b 0b 	mov	r9,2827
800051de:	ea 19 0b 0b 	orh	r9,0xb0b
800051e2:	91 09       	st.w	r8[0x0],r9
800051e4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051e8:	20 48       	sub	r8,4
800051ea:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800051ee:	ee f9 ff f4 	ld.w	r9,r7[-12]
800051f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051f6:	91 09       	st.w	r8[0x0],r9
800051f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051fc:	20 48       	sub	r8,4
800051fe:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005202:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005206:	e0 69 be ef 	mov	r9,48879
8000520a:	ea 19 de ad 	orh	r9,0xdead
8000520e:	91 09       	st.w	r8[0x0],r9
80005210:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005214:	20 48       	sub	r8,4
80005216:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
8000521a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000521e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005222:	91 09       	st.w	r8[0x0],r9
80005224:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005228:	20 48       	sub	r8,4
8000522a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
8000522e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005232:	fc 19 00 40 	movh	r9,0x40
80005236:	91 09       	st.w	r8[0x0],r9
80005238:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000523c:	20 48       	sub	r8,4
8000523e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005242:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005246:	e0 69 00 ff 	mov	r9,255
8000524a:	ea 19 ff 00 	orh	r9,0xff00
8000524e:	91 09       	st.w	r8[0x0],r9
80005250:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005254:	20 48       	sub	r8,4
80005256:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
8000525a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000525e:	e0 69 01 01 	mov	r9,257
80005262:	ea 19 01 01 	orh	r9,0x101
80005266:	91 09       	st.w	r8[0x0],r9
80005268:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000526c:	20 48       	sub	r8,4
8000526e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005272:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005276:	e0 69 02 02 	mov	r9,514
8000527a:	ea 19 02 02 	orh	r9,0x202
8000527e:	91 09       	st.w	r8[0x0],r9
80005280:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005284:	20 48       	sub	r8,4
80005286:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
8000528a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000528e:	e0 69 03 03 	mov	r9,771
80005292:	ea 19 03 03 	orh	r9,0x303
80005296:	91 09       	st.w	r8[0x0],r9
80005298:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000529c:	20 48       	sub	r8,4
8000529e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
800052a2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052a6:	e0 69 04 04 	mov	r9,1028
800052aa:	ea 19 04 04 	orh	r9,0x404
800052ae:	91 09       	st.w	r8[0x0],r9
800052b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052b4:	20 48       	sub	r8,4
800052b6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800052ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052be:	e0 69 05 05 	mov	r9,1285
800052c2:	ea 19 05 05 	orh	r9,0x505
800052c6:	91 09       	st.w	r8[0x0],r9
800052c8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052cc:	20 48       	sub	r8,4
800052ce:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800052d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052d6:	e0 69 06 06 	mov	r9,1542
800052da:	ea 19 06 06 	orh	r9,0x606
800052de:	91 09       	st.w	r8[0x0],r9
800052e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052e4:	20 48       	sub	r8,4
800052e6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800052ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052ee:	e0 69 07 07 	mov	r9,1799
800052f2:	ea 19 07 07 	orh	r9,0x707
800052f6:	91 09       	st.w	r8[0x0],r9
800052f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052fc:	20 48       	sub	r8,4
800052fe:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005302:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005306:	30 09       	mov	r9,0
80005308:	91 09       	st.w	r8[0x0],r9

	return pxTopOfStack;
8000530a:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000530e:	10 9c       	mov	r12,r8
80005310:	2f dd       	sub	sp,-12
80005312:	e3 cd 80 80 	ldm	sp++,r7,pc
80005316:	d7 03       	nop

80005318 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005318:	eb cd 40 80 	pushm	r7,lr
8000531c:	1a 97       	mov	r7,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
8000531e:	f0 1f 00 10 	mcall	8000535c <xPortStartScheduler+0x44>

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005322:	e0 68 06 60 	mov	r8,1632
80005326:	ea 18 00 00 	orh	r8,0x0
8000532a:	70 00       	ld.w	r0,r8[0x0]
8000532c:	60 0d       	ld.w	sp,r0[0x0]
8000532e:	1b 00       	ld.w	r0,sp++
80005330:	e0 68 00 20 	mov	r8,32
80005334:	ea 18 00 00 	orh	r8,0x0
80005338:	91 00       	st.w	r8[0x0],r0
8000533a:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000533e:	2f ed       	sub	sp,-8
80005340:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005344:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005348:	e3 b0 00 00 	mtsr	0x0,r0
8000534c:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005350:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
80005354:	30 08       	mov	r8,0
}
80005356:	10 9c       	mov	r12,r8
80005358:	e3 cd 80 80 	ldm	sp++,r7,pc
8000535c:	80 00       	ld.sh	r0,r0[0x0]
8000535e:	53 8c       	stdsp	sp[0xe0],r12

80005360 <prvScheduleFirstTick>:

/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
80005360:	eb cd 40 80 	pushm	r7,lr
80005364:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
80005366:	e0 68 2e e0 	mov	r8,12000
8000536a:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
8000536e:	30 08       	mov	r8,0
80005370:	e3 b8 00 42 	mtsr	0x108,r8
	}
80005374:	e3 cd 80 80 	ldm	sp++,r7,pc

80005378 <prvClearCcInt>:

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
80005378:	eb cd 40 80 	pushm	r7,lr
8000537c:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
8000537e:	e1 b8 00 43 	mfsr	r8,0x10c
80005382:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005386:	e3 cd 80 80 	ldm	sp++,r7,pc
8000538a:	d7 03       	nop

8000538c <prvSetupTimerInterrupt>:
#endif
/*-----------------------------------------------------------*/

/* Setup the timer to generate the tick interrupts. */
static void prvSetupTimerInterrupt(void)
{
8000538c:	eb cd 40 80 	pushm	r7,lr
80005390:	1a 97       	mov	r7,sp
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005392:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005394:	30 0a       	mov	r10,0
80005396:	30 0b       	mov	r11,0
80005398:	48 4c       	lddpc	r12,800053a8 <prvSetupTimerInterrupt+0x1c>
8000539a:	f0 1f 00 05 	mcall	800053ac <prvSetupTimerInterrupt+0x20>
		prvScheduleFirstTick();
8000539e:	f0 1f 00 05 	mcall	800053b0 <prvSetupTimerInterrupt+0x24>
	}
	#endif
}
800053a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800053a6:	00 00       	add	r0,r0
800053a8:	80 00       	ld.sh	r0,r0[0x0]
800053aa:	50 0c       	stdsp	sp[0x0],r12
800053ac:	80 00       	ld.sh	r0,r0[0x0]
800053ae:	46 8c       	lddsp	r12,sp[0x1a0]
800053b0:	80 00       	ld.sh	r0,r0[0x0]
800053b2:	53 60       	stdsp	sp[0xd8],r0

800053b4 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
800053b4:	eb cd 40 80 	pushm	r7,lr
800053b8:	1a 97       	mov	r7,sp
800053ba:	20 5d       	sub	sp,20
800053bc:	ef 4c ff f4 	st.w	r7[-12],r12
800053c0:	ef 4b ff f0 	st.w	r7[-16],r11
800053c4:	ef 4a ff ec 	st.w	r7[-20],r10
  int nChars = 0;
800053c8:	30 08       	mov	r8,0
800053ca:	ef 48 ff f8 	st.w	r7[-8],r8

  if (file != 0)
800053ce:	ee f8 ff f4 	ld.w	r8,r7[-12]
800053d2:	58 08       	cp.w	r8,0
800053d4:	c2 40       	breq	8000541c <_read+0x68>
    return -1;
800053d6:	3f f8       	mov	r8,-1
800053d8:	c2 b8       	rjmp	8000542e <_read+0x7a>

  for (; len > 0; --len)
  {
    int c = usart_getchar(stdio_usart_base);
800053da:	49 88       	lddpc	r8,80005438 <_read+0x84>
800053dc:	70 08       	ld.w	r8,r8[0x0]
800053de:	10 9c       	mov	r12,r8
800053e0:	f0 1f 00 17 	mcall	8000543c <_read+0x88>
800053e4:	18 98       	mov	r8,r12
800053e6:	ef 48 ff fc 	st.w	r7[-4],r8
    if (c < 0)
800053ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800053ee:	58 08       	cp.w	r8,0
800053f0:	c1 c5       	brlt	80005428 <_read+0x74>
      break;

    *ptr++ = c;
800053f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800053f6:	5c 58       	castu.b	r8
800053f8:	ee f9 ff f0 	ld.w	r9,r7[-16]
800053fc:	b2 88       	st.b	r9[0x0],r8
800053fe:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005402:	2f f8       	sub	r8,-1
80005404:	ef 48 ff f0 	st.w	r7[-16],r8
    ++nChars;
80005408:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000540c:	2f f8       	sub	r8,-1
8000540e:	ef 48 ff f8 	st.w	r7[-8],r8
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005412:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005416:	20 18       	sub	r8,1
80005418:	ef 48 ff ec 	st.w	r7[-20],r8
8000541c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005420:	58 08       	cp.w	r8,0
80005422:	fe 99 ff dc 	brgt	800053da <_read+0x26>
80005426:	c0 28       	rjmp	8000542a <_read+0x76>
  {
    int c = usart_getchar(stdio_usart_base);
    if (c < 0)
      break;
80005428:	d7 03       	nop

    *ptr++ = c;
    ++nChars;
  }

  return nChars;
8000542a:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
8000542e:	10 9c       	mov	r12,r8
80005430:	2f bd       	sub	sp,-20
80005432:	e3 cd 80 80 	ldm	sp++,r7,pc
80005436:	00 00       	add	r0,r0
80005438:	00 00       	add	r0,r0
8000543a:	07 f8       	ld.ub	r8,r3[0x7]
8000543c:	80 00       	ld.sh	r0,r0[0x0]
8000543e:	4d 14       	lddpc	r4,80005580 <xQueueCreate+0x3c>

80005440 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005440:	eb cd 40 80 	pushm	r7,lr
80005444:	1a 97       	mov	r7,sp
80005446:	20 4d       	sub	sp,16
80005448:	ef 4c ff f8 	st.w	r7[-8],r12
8000544c:	ef 4b ff f4 	st.w	r7[-12],r11
80005450:	ef 4a ff f0 	st.w	r7[-16],r10
  int nChars = 0;
80005454:	30 08       	mov	r8,0
80005456:	ef 48 ff fc 	st.w	r7[-4],r8

  if ( (file != 1)
8000545a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000545e:	58 18       	cp.w	r8,1
80005460:	c2 90       	breq	800054b2 <_write+0x72>
80005462:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005466:	58 28       	cp.w	r8,2
80005468:	c2 50       	breq	800054b2 <_write+0x72>
8000546a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000546e:	58 38       	cp.w	r8,3
80005470:	c2 10       	breq	800054b2 <_write+0x72>
       && (file != 2) && (file!=3))
    return -1;
80005472:	3f f8       	mov	r8,-1
80005474:	c2 58       	rjmp	800054be <_write+0x7e>

  for (; len != 0; --len)
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005476:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000547a:	11 88       	ld.ub	r8,r8[0x0]
8000547c:	10 99       	mov	r9,r8
8000547e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005482:	2f f8       	sub	r8,-1
80005484:	ef 48 ff f4 	st.w	r7[-12],r8
80005488:	49 08       	lddpc	r8,800054c8 <_write+0x88>
8000548a:	70 08       	ld.w	r8,r8[0x0]
8000548c:	12 9b       	mov	r11,r9
8000548e:	10 9c       	mov	r12,r8
80005490:	f0 1f 00 0f 	mcall	800054cc <_write+0x8c>
80005494:	18 98       	mov	r8,r12
80005496:	58 08       	cp.w	r8,0
80005498:	c0 34       	brge	8000549e <_write+0x5e>
    {
      return -1;
8000549a:	3f f8       	mov	r8,-1
8000549c:	c1 18       	rjmp	800054be <_write+0x7e>
    }

    ++nChars;
8000549e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800054a2:	2f f8       	sub	r8,-1
800054a4:	ef 48 ff fc 	st.w	r7[-4],r8

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800054a8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800054ac:	20 18       	sub	r8,1
800054ae:	ef 48 ff f0 	st.w	r7[-16],r8
800054b2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800054b6:	58 08       	cp.w	r8,0
800054b8:	cd f1       	brne	80005476 <_write+0x36>
    }

    ++nChars;
  }

  return nChars;
800054ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800054be:	10 9c       	mov	r12,r8
800054c0:	2f cd       	sub	sp,-16
800054c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800054c6:	00 00       	add	r0,r0
800054c8:	00 00       	add	r0,r0
800054ca:	07 f8       	ld.ub	r8,r3[0x7]
800054cc:	80 00       	ld.sh	r0,r0[0x0]
800054ce:	4c 6c       	lddpc	r12,800055e4 <xQueueCreate+0xa0>

800054d0 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800054d0:	eb cd 40 80 	pushm	r7,lr
800054d4:	1a 97       	mov	r7,sp
800054d6:	20 2d       	sub	sp,8
800054d8:	ef 4c ff f8 	st.w	r7[-8],r12
void *pvReturn;

	vTaskSuspendAll();
800054dc:	f0 1f 00 09 	mcall	80005500 <pvPortMalloc+0x30>
	{
		pvReturn = malloc( xWantedSize );
800054e0:	ee fc ff f8 	ld.w	r12,r7[-8]
800054e4:	f0 1f 00 08 	mcall	80005504 <pvPortMalloc+0x34>
800054e8:	18 98       	mov	r8,r12
800054ea:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	xTaskResumeAll();
800054ee:	f0 1f 00 07 	mcall	80005508 <pvPortMalloc+0x38>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
800054f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800054f6:	10 9c       	mov	r12,r8
800054f8:	2f ed       	sub	sp,-8
800054fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800054fe:	00 00       	add	r0,r0
80005500:	80 00       	ld.sh	r0,r0[0x0]
80005502:	5f f8       	sral	r8
80005504:	80 00       	ld.sh	r0,r0[0x0]
80005506:	6d 1c       	ld.w	r12,r6[0x44]
80005508:	80 00       	ld.sh	r0,r0[0x0]
8000550a:	60 14       	ld.w	r4,r0[0x4]

8000550c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
8000550c:	eb cd 40 80 	pushm	r7,lr
80005510:	1a 97       	mov	r7,sp
80005512:	20 1d       	sub	sp,4
80005514:	ef 4c ff fc 	st.w	r7[-4],r12
	if( pv )
80005518:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000551c:	58 08       	cp.w	r8,0
8000551e:	c0 90       	breq	80005530 <vPortFree+0x24>
	{
		vTaskSuspendAll();
80005520:	f0 1f 00 06 	mcall	80005538 <vPortFree+0x2c>
		{
			free( pv );
80005524:	ee fc ff fc 	ld.w	r12,r7[-4]
80005528:	f0 1f 00 05 	mcall	8000553c <vPortFree+0x30>
		}
		xTaskResumeAll();
8000552c:	f0 1f 00 05 	mcall	80005540 <vPortFree+0x34>
	}
}
80005530:	2f fd       	sub	sp,-4
80005532:	e3 cd 80 80 	ldm	sp++,r7,pc
80005536:	00 00       	add	r0,r0
80005538:	80 00       	ld.sh	r0,r0[0x0]
8000553a:	5f f8       	sral	r8
8000553c:	80 00       	ld.sh	r0,r0[0x0]
8000553e:	6d 0c       	ld.w	r12,r6[0x40]
80005540:	80 00       	ld.sh	r0,r0[0x0]
80005542:	60 14       	ld.w	r4,r0[0x4]

80005544 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005544:	eb cd 40 80 	pushm	r7,lr
80005548:	1a 97       	mov	r7,sp
8000554a:	20 5d       	sub	sp,20
8000554c:	ef 4c ff f0 	st.w	r7[-16],r12
80005550:	ef 4b ff ec 	st.w	r7[-20],r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
80005554:	30 08       	mov	r8,0
80005556:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000555a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000555e:	58 08       	cp.w	r8,0
80005560:	c7 20       	breq	80005644 <xQueueCreate+0x100>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005562:	34 cc       	mov	r12,76
80005564:	f0 1f 00 3b 	mcall	80005650 <xQueueCreate+0x10c>
80005568:	18 98       	mov	r8,r12
8000556a:	ef 48 ff f4 	st.w	r7[-12],r8
		if( pxNewQueue != NULL )
8000556e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005572:	58 08       	cp.w	r8,0
80005574:	c6 80       	breq	80005644 <xQueueCreate+0x100>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005576:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000557a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000557e:	f2 08 02 48 	mul	r8,r9,r8
80005582:	2f f8       	sub	r8,-1
80005584:	ef 48 ff f8 	st.w	r7[-8],r8

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005588:	ee fc ff f8 	ld.w	r12,r7[-8]
8000558c:	f0 1f 00 31 	mcall	80005650 <xQueueCreate+0x10c>
80005590:	18 98       	mov	r8,r12
80005592:	10 99       	mov	r9,r8
80005594:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005598:	91 09       	st.w	r8[0x0],r9
			if( pxNewQueue->pcHead != NULL )
8000559a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000559e:	70 08       	ld.w	r8,r8[0x0]
800055a0:	58 08       	cp.w	r8,0
800055a2:	c4 d0       	breq	8000563c <xQueueCreate+0xf8>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800055a4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800055a8:	70 09       	ld.w	r9,r8[0x0]
800055aa:	ee fa ff f0 	ld.w	r10,r7[-16]
800055ae:	ee f8 ff ec 	ld.w	r8,r7[-20]
800055b2:	f4 08 02 48 	mul	r8,r10,r8
800055b6:	10 09       	add	r9,r8
800055b8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800055bc:	91 19       	st.w	r8[0x4],r9
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800055be:	ee f8 ff f4 	ld.w	r8,r7[-12]
800055c2:	30 09       	mov	r9,0
800055c4:	91 e9       	st.w	r8[0x38],r9
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800055c6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800055ca:	70 09       	ld.w	r9,r8[0x0]
800055cc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800055d0:	91 29       	st.w	r8[0x8],r9
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800055d2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800055d6:	70 09       	ld.w	r9,r8[0x0]
800055d8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800055dc:	f0 ca 00 01 	sub	r10,r8,1
800055e0:	ee f8 ff ec 	ld.w	r8,r7[-20]
800055e4:	f4 08 02 48 	mul	r8,r10,r8
800055e8:	10 09       	add	r9,r8
800055ea:	ee f8 ff f4 	ld.w	r8,r7[-12]
800055ee:	91 39       	st.w	r8[0xc],r9
				pxNewQueue->uxLength = uxQueueLength;
800055f0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800055f4:	ee f9 ff f0 	ld.w	r9,r7[-16]
800055f8:	91 f9       	st.w	r8[0x3c],r9
				pxNewQueue->uxItemSize = uxItemSize;
800055fa:	ee f8 ff f4 	ld.w	r8,r7[-12]
800055fe:	ee f9 ff ec 	ld.w	r9,r7[-20]
80005602:	f1 49 00 40 	st.w	r8[64],r9
				pxNewQueue->xRxLock = queueUNLOCKED;
80005606:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000560a:	3f f9       	mov	r9,-1
8000560c:	f1 49 00 44 	st.w	r8[68],r9
				pxNewQueue->xTxLock = queueUNLOCKED;
80005610:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005614:	3f f9       	mov	r9,-1
80005616:	f1 49 00 48 	st.w	r8[72],r9

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000561a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000561e:	2f 08       	sub	r8,-16
80005620:	10 9c       	mov	r12,r8
80005622:	f0 1f 00 0d 	mcall	80005654 <xQueueCreate+0x110>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005626:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000562a:	2d c8       	sub	r8,-36
8000562c:	10 9c       	mov	r12,r8
8000562e:	f0 1f 00 0a 	mcall	80005654 <xQueueCreate+0x110>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
80005632:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005636:	ef 48 ff fc 	st.w	r7[-4],r8
8000563a:	c0 58       	rjmp	80005644 <xQueueCreate+0x100>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000563c:	ee fc ff f4 	ld.w	r12,r7[-12]
80005640:	f0 1f 00 06 	mcall	80005658 <xQueueCreate+0x114>
		}
	}

	configASSERT( xReturn );

	return xReturn;
80005644:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005648:	10 9c       	mov	r12,r8
8000564a:	2f bd       	sub	sp,-20
8000564c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005650:	80 00       	ld.sh	r0,r0[0x0]
80005652:	54 d0       	stdsp	sp[0x134],r0
80005654:	80 00       	ld.sh	r0,r0[0x0]
80005656:	4d 98       	lddpc	r8,800057b8 <xQueueGenericSend+0x70>
80005658:	80 00       	ld.sh	r0,r0[0x0]
8000565a:	55 0c       	stdsp	sp[0x140],r12

8000565c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
8000565c:	eb cd 40 80 	pushm	r7,lr
80005660:	1a 97       	mov	r7,sp
80005662:	20 1d       	sub	sp,4
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005664:	34 cc       	mov	r12,76
80005666:	f0 1f 00 25 	mcall	800056f8 <xQueueCreateMutex+0x9c>
8000566a:	18 98       	mov	r8,r12
8000566c:	ef 48 ff fc 	st.w	r7[-4],r8
		if( pxNewQueue != NULL )
80005670:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005674:	58 08       	cp.w	r8,0
80005676:	c3 b0       	breq	800056ec <xQueueCreateMutex+0x90>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80005678:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000567c:	30 09       	mov	r9,0
8000567e:	91 19       	st.w	r8[0x4],r9
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80005680:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005684:	30 09       	mov	r9,0
80005686:	91 09       	st.w	r8[0x0],r9

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80005688:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000568c:	30 09       	mov	r9,0
8000568e:	91 29       	st.w	r8[0x8],r9
			pxNewQueue->pcReadFrom = NULL;
80005690:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005694:	30 09       	mov	r9,0
80005696:	91 39       	st.w	r8[0xc],r9

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005698:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000569c:	30 09       	mov	r9,0
8000569e:	91 e9       	st.w	r8[0x38],r9
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800056a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056a4:	30 19       	mov	r9,1
800056a6:	91 f9       	st.w	r8[0x3c],r9
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800056a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056ac:	30 09       	mov	r9,0
800056ae:	f1 49 00 40 	st.w	r8[64],r9
			pxNewQueue->xRxLock = queueUNLOCKED;
800056b2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056b6:	3f f9       	mov	r9,-1
800056b8:	f1 49 00 44 	st.w	r8[68],r9
			pxNewQueue->xTxLock = queueUNLOCKED;
800056bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056c0:	3f f9       	mov	r9,-1
800056c2:	f1 49 00 48 	st.w	r8[72],r9

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800056c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056ca:	2f 08       	sub	r8,-16
800056cc:	10 9c       	mov	r12,r8
800056ce:	f0 1f 00 0c 	mcall	800056fc <xQueueCreateMutex+0xa0>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800056d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056d6:	2d c8       	sub	r8,-36
800056d8:	10 9c       	mov	r12,r8
800056da:	f0 1f 00 09 	mcall	800056fc <xQueueCreateMutex+0xa0>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800056de:	30 09       	mov	r9,0
800056e0:	30 0a       	mov	r10,0
800056e2:	30 0b       	mov	r11,0
800056e4:	ee fc ff fc 	ld.w	r12,r7[-4]
800056e8:	f0 1f 00 06 	mcall	80005700 <xQueueCreateMutex+0xa4>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
800056ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
	}
800056f0:	10 9c       	mov	r12,r8
800056f2:	2f fd       	sub	sp,-4
800056f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800056f8:	80 00       	ld.sh	r0,r0[0x0]
800056fa:	54 d0       	stdsp	sp[0x134],r0
800056fc:	80 00       	ld.sh	r0,r0[0x0]
800056fe:	4d 98       	lddpc	r8,80005860 <xQueueGenericSend+0x118>
80005700:	80 00       	ld.sh	r0,r0[0x0]
80005702:	57 48       	stdsp	sp[0x1d0],r8

80005704 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
80005704:	eb cd 40 80 	pushm	r7,lr
80005708:	1a 97       	mov	r7,sp
8000570a:	20 3d       	sub	sp,12
8000570c:	ef 4c ff f8 	st.w	r7[-8],r12
80005710:	ef 4b ff f4 	st.w	r7[-12],r11
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
80005714:	30 0b       	mov	r11,0
80005716:	ee fc ff f8 	ld.w	r12,r7[-8]
8000571a:	f0 1f 00 0b 	mcall	80005744 <xQueueCreateCountingSemaphore+0x40>
8000571e:	18 98       	mov	r8,r12
80005720:	ef 48 ff fc 	st.w	r7[-4],r8

		if( pxHandle != NULL )
80005724:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005728:	58 08       	cp.w	r8,0
8000572a:	c0 60       	breq	80005736 <xQueueCreateCountingSemaphore+0x32>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
8000572c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005730:	ee f9 ff f4 	ld.w	r9,r7[-12]
80005734:	91 e9       	st.w	r8[0x38],r9
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
80005736:	ee f8 ff fc 	ld.w	r8,r7[-4]
	}
8000573a:	10 9c       	mov	r12,r8
8000573c:	2f dd       	sub	sp,-12
8000573e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005742:	00 00       	add	r0,r0
80005744:	80 00       	ld.sh	r0,r0[0x0]
80005746:	55 44       	stdsp	sp[0x150],r4

80005748 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005748:	eb cd 40 80 	pushm	r7,lr
8000574c:	1a 97       	mov	r7,sp
8000574e:	20 7d       	sub	sp,28
80005750:	ef 4c ff f0 	st.w	r7[-16],r12
80005754:	ef 4b ff ec 	st.w	r7[-20],r11
80005758:	ef 4a ff e8 	st.w	r7[-24],r10
8000575c:	ef 49 ff e4 	st.w	r7[-28],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
80005760:	30 08       	mov	r8,0
80005762:	ef 48 ff fc 	st.w	r7[-4],r8
80005766:	c0 28       	rjmp	8000576a <xQueueGenericSend+0x22>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80005768:	d7 03       	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000576a:	f0 1f 00 47 	mcall	80005884 <xQueueGenericSend+0x13c>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000576e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005772:	70 e9       	ld.w	r9,r8[0x38]
80005774:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005778:	70 f8       	ld.w	r8,r8[0x3c]
8000577a:	10 39       	cp.w	r9,r8
8000577c:	c1 c2       	brcc	800057b4 <xQueueGenericSend+0x6c>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000577e:	ee fa ff e4 	ld.w	r10,r7[-28]
80005782:	ee fb ff ec 	ld.w	r11,r7[-20]
80005786:	ee fc ff f0 	ld.w	r12,r7[-16]
8000578a:	f0 1f 00 40 	mcall	80005888 <xQueueGenericSend+0x140>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000578e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005792:	70 98       	ld.w	r8,r8[0x24]
80005794:	58 08       	cp.w	r8,0
80005796:	c0 b0       	breq	800057ac <xQueueGenericSend+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005798:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000579c:	2d c8       	sub	r8,-36
8000579e:	10 9c       	mov	r12,r8
800057a0:	f0 1f 00 3b 	mcall	8000588c <xQueueGenericSend+0x144>
800057a4:	18 98       	mov	r8,r12
800057a6:	58 18       	cp.w	r8,1
800057a8:	c0 21       	brne	800057ac <xQueueGenericSend+0x64>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800057aa:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800057ac:	f0 1f 00 39 	mcall	80005890 <xQueueGenericSend+0x148>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800057b0:	30 18       	mov	r8,1
800057b2:	c6 58       	rjmp	8000587c <xQueueGenericSend+0x134>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800057b4:	ee f8 ff e8 	ld.w	r8,r7[-24]
800057b8:	58 08       	cp.w	r8,0
800057ba:	c0 51       	brne	800057c4 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800057bc:	f0 1f 00 35 	mcall	80005890 <xQueueGenericSend+0x148>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800057c0:	30 08       	mov	r8,0
800057c2:	c5 d8       	rjmp	8000587c <xQueueGenericSend+0x134>
				}
				else if( xEntryTimeSet == pdFALSE )
800057c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800057c8:	58 08       	cp.w	r8,0
800057ca:	c0 91       	brne	800057dc <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800057cc:	ee c8 00 0c 	sub	r8,r7,12
800057d0:	10 9c       	mov	r12,r8
800057d2:	f0 1f 00 31 	mcall	80005894 <xQueueGenericSend+0x14c>
					xEntryTimeSet = pdTRUE;
800057d6:	30 18       	mov	r8,1
800057d8:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}
		}
		taskEXIT_CRITICAL();
800057dc:	f0 1f 00 2d 	mcall	80005890 <xQueueGenericSend+0x148>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800057e0:	f0 1f 00 2e 	mcall	80005898 <xQueueGenericSend+0x150>
		prvLockQueue( pxQueue );
800057e4:	f0 1f 00 28 	mcall	80005884 <xQueueGenericSend+0x13c>
800057e8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800057ec:	71 18       	ld.w	r8,r8[0x44]
800057ee:	5b f8       	cp.w	r8,-1
800057f0:	c0 61       	brne	800057fc <xQueueGenericSend+0xb4>
800057f2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800057f6:	30 09       	mov	r9,0
800057f8:	f1 49 00 44 	st.w	r8[68],r9
800057fc:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005800:	71 28       	ld.w	r8,r8[0x48]
80005802:	5b f8       	cp.w	r8,-1
80005804:	c0 61       	brne	80005810 <xQueueGenericSend+0xc8>
80005806:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000580a:	30 09       	mov	r9,0
8000580c:	f1 49 00 48 	st.w	r8[72],r9
80005810:	f0 1f 00 20 	mcall	80005890 <xQueueGenericSend+0x148>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005814:	ee c9 00 18 	sub	r9,r7,24
80005818:	ee c8 00 0c 	sub	r8,r7,12
8000581c:	12 9b       	mov	r11,r9
8000581e:	10 9c       	mov	r12,r8
80005820:	f0 1f 00 1f 	mcall	8000589c <xQueueGenericSend+0x154>
80005824:	18 98       	mov	r8,r12
80005826:	58 08       	cp.w	r8,0
80005828:	c2 31       	brne	8000586e <xQueueGenericSend+0x126>
		{
			if( prvIsQueueFull( pxQueue ) )
8000582a:	ee fc ff f0 	ld.w	r12,r7[-16]
8000582e:	f0 1f 00 1d 	mcall	800058a0 <xQueueGenericSend+0x158>
80005832:	18 98       	mov	r8,r12
80005834:	58 08       	cp.w	r8,0
80005836:	c1 50       	breq	80005860 <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005838:	ee f9 ff e8 	ld.w	r9,r7[-24]
8000583c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005840:	2f 08       	sub	r8,-16
80005842:	12 9b       	mov	r11,r9
80005844:	10 9c       	mov	r12,r8
80005846:	f0 1f 00 18 	mcall	800058a4 <xQueueGenericSend+0x15c>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000584a:	ee fc ff f0 	ld.w	r12,r7[-16]
8000584e:	f0 1f 00 17 	mcall	800058a8 <xQueueGenericSend+0x160>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005852:	f0 1f 00 17 	mcall	800058ac <xQueueGenericSend+0x164>
80005856:	18 98       	mov	r8,r12
80005858:	58 08       	cp.w	r8,0
8000585a:	c8 71       	brne	80005768 <xQueueGenericSend+0x20>
				{
					portYIELD_WITHIN_API();
8000585c:	d7 33       	scall
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
8000585e:	c8 6b       	rjmp	8000576a <xQueueGenericSend+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005860:	ee fc ff f0 	ld.w	r12,r7[-16]
80005864:	f0 1f 00 11 	mcall	800058a8 <xQueueGenericSend+0x160>
				( void ) xTaskResumeAll();
80005868:	f0 1f 00 11 	mcall	800058ac <xQueueGenericSend+0x164>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
8000586c:	c7 fb       	rjmp	8000576a <xQueueGenericSend+0x22>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000586e:	ee fc ff f0 	ld.w	r12,r7[-16]
80005872:	f0 1f 00 0e 	mcall	800058a8 <xQueueGenericSend+0x160>
			( void ) xTaskResumeAll();
80005876:	f0 1f 00 0e 	mcall	800058ac <xQueueGenericSend+0x164>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
8000587a:	30 08       	mov	r8,0
		}
	}
}
8000587c:	10 9c       	mov	r12,r8
8000587e:	2f 9d       	sub	sp,-28
80005880:	e3 cd 80 80 	ldm	sp++,r7,pc
80005884:	80 00       	ld.sh	r0,r0[0x0]
80005886:	51 28       	stdsp	sp[0x48],r8
80005888:	80 00       	ld.sh	r0,r0[0x0]
8000588a:	5a 9c       	cp.w	r12,-23
8000588c:	80 00       	ld.sh	r0,r0[0x0]
8000588e:	63 cc       	ld.w	r12,r1[0x70]
80005890:	80 00       	ld.sh	r0,r0[0x0]
80005892:	51 44       	stdsp	sp[0x50],r4
80005894:	80 00       	ld.sh	r0,r0[0x0]
80005896:	64 9c       	ld.w	r12,r2[0x24]
80005898:	80 00       	ld.sh	r0,r0[0x0]
8000589a:	5f f8       	sral	r8
8000589c:	80 00       	ld.sh	r0,r0[0x0]
8000589e:	64 cc       	ld.w	r12,r2[0x30]
800058a0:	80 00       	ld.sh	r0,r0[0x0]
800058a2:	5d 14       	icall	r4
800058a4:	80 00       	ld.sh	r0,r0[0x0]
800058a6:	63 4c       	ld.w	r12,r1[0x50]
800058a8:	80 00       	ld.sh	r0,r0[0x0]
800058aa:	5c 0c       	acr	r12
800058ac:	80 00       	ld.sh	r0,r0[0x0]
800058ae:	60 14       	ld.w	r4,r0[0x4]

800058b0 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800058b0:	eb cd 40 80 	pushm	r7,lr
800058b4:	1a 97       	mov	r7,sp
800058b6:	20 8d       	sub	sp,32
800058b8:	ef 4c ff ec 	st.w	r7[-20],r12
800058bc:	ef 4b ff e8 	st.w	r7[-24],r11
800058c0:	ef 4a ff e4 	st.w	r7[-28],r10
800058c4:	ef 49 ff e0 	st.w	r7[-32],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
800058c8:	30 08       	mov	r8,0
800058ca:	ef 48 ff f8 	st.w	r7[-8],r8
800058ce:	c0 28       	rjmp	800058d2 <xQueueGenericReceive+0x22>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800058d0:	d7 03       	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800058d2:	f0 1f 00 66 	mcall	80005a68 <xQueueGenericReceive+0x1b8>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800058d6:	ee f8 ff ec 	ld.w	r8,r7[-20]
800058da:	70 e8       	ld.w	r8,r8[0x38]
800058dc:	58 08       	cp.w	r8,0
800058de:	c4 c0       	breq	80005976 <xQueueGenericReceive+0xc6>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800058e0:	ee f8 ff ec 	ld.w	r8,r7[-20]
800058e4:	70 38       	ld.w	r8,r8[0xc]
800058e6:	ef 48 ff fc 	st.w	r7[-4],r8

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800058ea:	ee fb ff e8 	ld.w	r11,r7[-24]
800058ee:	ee fc ff ec 	ld.w	r12,r7[-20]
800058f2:	f0 1f 00 5f 	mcall	80005a6c <xQueueGenericReceive+0x1bc>

				if( xJustPeeking == pdFALSE )
800058f6:	ee f8 ff e0 	ld.w	r8,r7[-32]
800058fa:	58 08       	cp.w	r8,0
800058fc:	c2 51       	brne	80005946 <xQueueGenericReceive+0x96>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800058fe:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005902:	70 e8       	ld.w	r8,r8[0x38]
80005904:	f0 c9 00 01 	sub	r9,r8,1
80005908:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000590c:	91 e9       	st.w	r8[0x38],r9

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000590e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005912:	70 08       	ld.w	r8,r8[0x0]
80005914:	58 08       	cp.w	r8,0
80005916:	c0 81       	brne	80005926 <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005918:	f0 1f 00 56 	mcall	80005a70 <xQueueGenericReceive+0x1c0>
8000591c:	18 98       	mov	r8,r12
8000591e:	10 99       	mov	r9,r8
80005920:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005924:	91 19       	st.w	r8[0x4],r9
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005926:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000592a:	70 48       	ld.w	r8,r8[0x10]
8000592c:	58 08       	cp.w	r8,0
8000592e:	c2 00       	breq	8000596e <xQueueGenericReceive+0xbe>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005930:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005934:	2f 08       	sub	r8,-16
80005936:	10 9c       	mov	r12,r8
80005938:	f0 1f 00 4f 	mcall	80005a74 <xQueueGenericReceive+0x1c4>
8000593c:	18 98       	mov	r8,r12
8000593e:	58 18       	cp.w	r8,1
80005940:	c1 71       	brne	8000596e <xQueueGenericReceive+0xbe>
						{
							portYIELD_WITHIN_API();
80005942:	d7 33       	scall
80005944:	c1 58       	rjmp	8000596e <xQueueGenericReceive+0xbe>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005946:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000594a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000594e:	91 39       	st.w	r8[0xc],r9

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005950:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005954:	70 98       	ld.w	r8,r8[0x24]
80005956:	58 08       	cp.w	r8,0
80005958:	c0 b0       	breq	8000596e <xQueueGenericReceive+0xbe>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000595a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000595e:	2d c8       	sub	r8,-36
80005960:	10 9c       	mov	r12,r8
80005962:	f0 1f 00 45 	mcall	80005a74 <xQueueGenericReceive+0x1c4>
80005966:	18 98       	mov	r8,r12
80005968:	58 08       	cp.w	r8,0
8000596a:	c0 20       	breq	8000596e <xQueueGenericReceive+0xbe>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
8000596c:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
8000596e:	f0 1f 00 43 	mcall	80005a78 <xQueueGenericReceive+0x1c8>
				return pdPASS;
80005972:	30 18       	mov	r8,1
80005974:	c7 58       	rjmp	80005a5e <xQueueGenericReceive+0x1ae>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005976:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000597a:	58 08       	cp.w	r8,0
8000597c:	c0 51       	brne	80005986 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000597e:	f0 1f 00 3f 	mcall	80005a78 <xQueueGenericReceive+0x1c8>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005982:	30 08       	mov	r8,0
80005984:	c6 d8       	rjmp	80005a5e <xQueueGenericReceive+0x1ae>
				}
				else if( xEntryTimeSet == pdFALSE )
80005986:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000598a:	58 08       	cp.w	r8,0
8000598c:	c0 91       	brne	8000599e <xQueueGenericReceive+0xee>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000598e:	ee c8 00 10 	sub	r8,r7,16
80005992:	10 9c       	mov	r12,r8
80005994:	f0 1f 00 3a 	mcall	80005a7c <xQueueGenericReceive+0x1cc>
					xEntryTimeSet = pdTRUE;
80005998:	30 18       	mov	r8,1
8000599a:	ef 48 ff f8 	st.w	r7[-8],r8
				}
			}
		}
		taskEXIT_CRITICAL();
8000599e:	f0 1f 00 37 	mcall	80005a78 <xQueueGenericReceive+0x1c8>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800059a2:	f0 1f 00 38 	mcall	80005a80 <xQueueGenericReceive+0x1d0>
		prvLockQueue( pxQueue );
800059a6:	f0 1f 00 31 	mcall	80005a68 <xQueueGenericReceive+0x1b8>
800059aa:	ee f8 ff ec 	ld.w	r8,r7[-20]
800059ae:	71 18       	ld.w	r8,r8[0x44]
800059b0:	5b f8       	cp.w	r8,-1
800059b2:	c0 61       	brne	800059be <xQueueGenericReceive+0x10e>
800059b4:	ee f8 ff ec 	ld.w	r8,r7[-20]
800059b8:	30 09       	mov	r9,0
800059ba:	f1 49 00 44 	st.w	r8[68],r9
800059be:	ee f8 ff ec 	ld.w	r8,r7[-20]
800059c2:	71 28       	ld.w	r8,r8[0x48]
800059c4:	5b f8       	cp.w	r8,-1
800059c6:	c0 61       	brne	800059d2 <xQueueGenericReceive+0x122>
800059c8:	ee f8 ff ec 	ld.w	r8,r7[-20]
800059cc:	30 09       	mov	r9,0
800059ce:	f1 49 00 48 	st.w	r8[72],r9
800059d2:	f0 1f 00 2a 	mcall	80005a78 <xQueueGenericReceive+0x1c8>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800059d6:	ee c9 00 1c 	sub	r9,r7,28
800059da:	ee c8 00 10 	sub	r8,r7,16
800059de:	12 9b       	mov	r11,r9
800059e0:	10 9c       	mov	r12,r8
800059e2:	f0 1f 00 29 	mcall	80005a84 <xQueueGenericReceive+0x1d4>
800059e6:	18 98       	mov	r8,r12
800059e8:	58 08       	cp.w	r8,0
800059ea:	c3 31       	brne	80005a50 <xQueueGenericReceive+0x1a0>
		{
			if( prvIsQueueEmpty( pxQueue ) )
800059ec:	ee fc ff ec 	ld.w	r12,r7[-20]
800059f0:	f0 1f 00 26 	mcall	80005a88 <xQueueGenericReceive+0x1d8>
800059f4:	18 98       	mov	r8,r12
800059f6:	58 08       	cp.w	r8,0
800059f8:	c2 50       	breq	80005a42 <xQueueGenericReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800059fa:	ee f8 ff ec 	ld.w	r8,r7[-20]
800059fe:	70 08       	ld.w	r8,r8[0x0]
80005a00:	58 08       	cp.w	r8,0
80005a02:	c0 b1       	brne	80005a18 <xQueueGenericReceive+0x168>
					{
						portENTER_CRITICAL();
80005a04:	f0 1f 00 19 	mcall	80005a68 <xQueueGenericReceive+0x1b8>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005a08:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005a0c:	70 18       	ld.w	r8,r8[0x4]
80005a0e:	10 9c       	mov	r12,r8
80005a10:	f0 1f 00 1f 	mcall	80005a8c <xQueueGenericReceive+0x1dc>
						}
						portEXIT_CRITICAL();
80005a14:	f0 1f 00 19 	mcall	80005a78 <xQueueGenericReceive+0x1c8>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005a18:	ee f9 ff e4 	ld.w	r9,r7[-28]
80005a1c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005a20:	2d c8       	sub	r8,-36
80005a22:	12 9b       	mov	r11,r9
80005a24:	10 9c       	mov	r12,r8
80005a26:	f0 1f 00 1b 	mcall	80005a90 <xQueueGenericReceive+0x1e0>
				prvUnlockQueue( pxQueue );
80005a2a:	ee fc ff ec 	ld.w	r12,r7[-20]
80005a2e:	f0 1f 00 1a 	mcall	80005a94 <xQueueGenericReceive+0x1e4>
				if( !xTaskResumeAll() )
80005a32:	f0 1f 00 1a 	mcall	80005a98 <xQueueGenericReceive+0x1e8>
80005a36:	18 98       	mov	r8,r12
80005a38:	58 08       	cp.w	r8,0
80005a3a:	fe 91 ff 4b 	brne	800058d0 <xQueueGenericReceive+0x20>
				{
					portYIELD_WITHIN_API();
80005a3e:	d7 33       	scall
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
80005a40:	c4 9b       	rjmp	800058d2 <xQueueGenericReceive+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005a42:	ee fc ff ec 	ld.w	r12,r7[-20]
80005a46:	f0 1f 00 14 	mcall	80005a94 <xQueueGenericReceive+0x1e4>
				( void ) xTaskResumeAll();
80005a4a:	f0 1f 00 14 	mcall	80005a98 <xQueueGenericReceive+0x1e8>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
80005a4e:	c4 2b       	rjmp	800058d2 <xQueueGenericReceive+0x22>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005a50:	ee fc ff ec 	ld.w	r12,r7[-20]
80005a54:	f0 1f 00 10 	mcall	80005a94 <xQueueGenericReceive+0x1e4>
			( void ) xTaskResumeAll();
80005a58:	f0 1f 00 10 	mcall	80005a98 <xQueueGenericReceive+0x1e8>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
80005a5c:	30 08       	mov	r8,0
		}
	}
}
80005a5e:	10 9c       	mov	r12,r8
80005a60:	2f 8d       	sub	sp,-32
80005a62:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a66:	00 00       	add	r0,r0
80005a68:	80 00       	ld.sh	r0,r0[0x0]
80005a6a:	51 28       	stdsp	sp[0x48],r8
80005a6c:	80 00       	ld.sh	r0,r0[0x0]
80005a6e:	5b a0       	cp.w	r0,-6
80005a70:	80 00       	ld.sh	r0,r0[0x0]
80005a72:	68 d8       	ld.w	r8,r4[0x34]
80005a74:	80 00       	ld.sh	r0,r0[0x0]
80005a76:	63 cc       	ld.w	r12,r1[0x70]
80005a78:	80 00       	ld.sh	r0,r0[0x0]
80005a7a:	51 44       	stdsp	sp[0x50],r4
80005a7c:	80 00       	ld.sh	r0,r0[0x0]
80005a7e:	64 9c       	ld.w	r12,r2[0x24]
80005a80:	80 00       	ld.sh	r0,r0[0x0]
80005a82:	5f f8       	sral	r8
80005a84:	80 00       	ld.sh	r0,r0[0x0]
80005a86:	64 cc       	ld.w	r12,r2[0x30]
80005a88:	80 00       	ld.sh	r0,r0[0x0]
80005a8a:	5c dc       	com	r12
80005a8c:	80 00       	ld.sh	r0,r0[0x0]
80005a8e:	68 f8       	ld.w	r8,r4[0x3c]
80005a90:	80 00       	ld.sh	r0,r0[0x0]
80005a92:	63 4c       	ld.w	r12,r1[0x50]
80005a94:	80 00       	ld.sh	r0,r0[0x0]
80005a96:	5c 0c       	acr	r12
80005a98:	80 00       	ld.sh	r0,r0[0x0]
80005a9a:	60 14       	ld.w	r4,r0[0x4]

80005a9c <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005a9c:	eb cd 40 80 	pushm	r7,lr
80005aa0:	1a 97       	mov	r7,sp
80005aa2:	20 3d       	sub	sp,12
80005aa4:	ef 4c ff fc 	st.w	r7[-4],r12
80005aa8:	ef 4b ff f8 	st.w	r7[-8],r11
80005aac:	ef 4a ff f4 	st.w	r7[-12],r10
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005ab0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005ab4:	71 08       	ld.w	r8,r8[0x40]
80005ab6:	58 08       	cp.w	r8,0
80005ab8:	c1 11       	brne	80005ada <prvCopyDataToQueue+0x3e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005aba:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005abe:	70 08       	ld.w	r8,r8[0x0]
80005ac0:	58 08       	cp.w	r8,0
80005ac2:	c5 f1       	brne	80005b80 <prvCopyDataToQueue+0xe4>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80005ac4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005ac8:	70 18       	ld.w	r8,r8[0x4]
80005aca:	10 9c       	mov	r12,r8
80005acc:	f0 1f 00 33 	mcall	80005b98 <prvCopyDataToQueue+0xfc>
				pxQueue->pxMutexHolder = NULL;
80005ad0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005ad4:	30 09       	mov	r9,0
80005ad6:	91 19       	st.w	r8[0x4],r9
80005ad8:	c5 48       	rjmp	80005b80 <prvCopyDataToQueue+0xe4>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005ada:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005ade:	58 08       	cp.w	r8,0
80005ae0:	c2 61       	brne	80005b2c <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005ae2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005ae6:	71 09       	ld.w	r9,r8[0x40]
80005ae8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005aec:	70 28       	ld.w	r8,r8[0x8]
80005aee:	12 9a       	mov	r10,r9
80005af0:	ee fb ff f8 	ld.w	r11,r7[-8]
80005af4:	10 9c       	mov	r12,r8
80005af6:	f0 1f 00 2a 	mcall	80005b9c <prvCopyDataToQueue+0x100>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005afa:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005afe:	70 29       	ld.w	r9,r8[0x8]
80005b00:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b04:	71 08       	ld.w	r8,r8[0x40]
80005b06:	10 09       	add	r9,r8
80005b08:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b0c:	91 29       	st.w	r8[0x8],r9
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005b0e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b12:	70 29       	ld.w	r9,r8[0x8]
80005b14:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b18:	70 18       	ld.w	r8,r8[0x4]
80005b1a:	10 39       	cp.w	r9,r8
80005b1c:	c3 23       	brcs	80005b80 <prvCopyDataToQueue+0xe4>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005b1e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b22:	70 09       	ld.w	r9,r8[0x0]
80005b24:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b28:	91 29       	st.w	r8[0x8],r9
80005b2a:	c2 b8       	rjmp	80005b80 <prvCopyDataToQueue+0xe4>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005b2c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b30:	71 09       	ld.w	r9,r8[0x40]
80005b32:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b36:	70 38       	ld.w	r8,r8[0xc]
80005b38:	12 9a       	mov	r10,r9
80005b3a:	ee fb ff f8 	ld.w	r11,r7[-8]
80005b3e:	10 9c       	mov	r12,r8
80005b40:	f0 1f 00 17 	mcall	80005b9c <prvCopyDataToQueue+0x100>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005b44:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b48:	70 39       	ld.w	r9,r8[0xc]
80005b4a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b4e:	71 08       	ld.w	r8,r8[0x40]
80005b50:	5c 38       	neg	r8
80005b52:	10 09       	add	r9,r8
80005b54:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b58:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005b5a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b5e:	70 39       	ld.w	r9,r8[0xc]
80005b60:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b64:	70 08       	ld.w	r8,r8[0x0]
80005b66:	10 39       	cp.w	r9,r8
80005b68:	c0 c2       	brcc	80005b80 <prvCopyDataToQueue+0xe4>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005b6a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b6e:	70 19       	ld.w	r9,r8[0x4]
80005b70:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b74:	71 08       	ld.w	r8,r8[0x40]
80005b76:	5c 38       	neg	r8
80005b78:	10 09       	add	r9,r8
80005b7a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b7e:	91 39       	st.w	r8[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80005b80:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b84:	70 e8       	ld.w	r8,r8[0x38]
80005b86:	f0 c9 ff ff 	sub	r9,r8,-1
80005b8a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b8e:	91 e9       	st.w	r8[0x38],r9
}
80005b90:	2f dd       	sub	sp,-12
80005b92:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b96:	00 00       	add	r0,r0
80005b98:	80 00       	ld.sh	r0,r0[0x0]
80005b9a:	69 cc       	ld.w	r12,r4[0x70]
80005b9c:	80 00       	ld.sh	r0,r0[0x0]
80005b9e:	71 64       	ld.w	r4,r8[0x58]

80005ba0 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005ba0:	eb cd 40 80 	pushm	r7,lr
80005ba4:	1a 97       	mov	r7,sp
80005ba6:	20 2d       	sub	sp,8
80005ba8:	ef 4c ff fc 	st.w	r7[-4],r12
80005bac:	ef 4b ff f8 	st.w	r7[-8],r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005bb0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005bb4:	70 08       	ld.w	r8,r8[0x0]
80005bb6:	58 08       	cp.w	r8,0
80005bb8:	c2 50       	breq	80005c02 <prvCopyDataFromQueue+0x62>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005bba:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005bbe:	70 39       	ld.w	r9,r8[0xc]
80005bc0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005bc4:	71 08       	ld.w	r8,r8[0x40]
80005bc6:	10 09       	add	r9,r8
80005bc8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005bcc:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005bce:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005bd2:	70 39       	ld.w	r9,r8[0xc]
80005bd4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005bd8:	70 18       	ld.w	r8,r8[0x4]
80005bda:	10 39       	cp.w	r9,r8
80005bdc:	c0 73       	brcs	80005bea <prvCopyDataFromQueue+0x4a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005bde:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005be2:	70 09       	ld.w	r9,r8[0x0]
80005be4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005be8:	91 39       	st.w	r8[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005bea:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005bee:	71 09       	ld.w	r9,r8[0x40]
80005bf0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005bf4:	70 38       	ld.w	r8,r8[0xc]
80005bf6:	12 9a       	mov	r10,r9
80005bf8:	10 9b       	mov	r11,r8
80005bfa:	ee fc ff f8 	ld.w	r12,r7[-8]
80005bfe:	f0 1f 00 03 	mcall	80005c08 <prvCopyDataFromQueue+0x68>
	}
}
80005c02:	2f ed       	sub	sp,-8
80005c04:	e3 cd 80 80 	ldm	sp++,r7,pc
80005c08:	80 00       	ld.sh	r0,r0[0x0]
80005c0a:	71 64       	ld.w	r4,r8[0x58]

80005c0c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005c0c:	eb cd 40 80 	pushm	r7,lr
80005c10:	1a 97       	mov	r7,sp
80005c12:	20 1d       	sub	sp,4
80005c14:	ef 4c ff fc 	st.w	r7[-4],r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005c18:	f0 1f 00 2d 	mcall	80005ccc <prvUnlockQueue+0xc0>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005c1c:	c1 a8       	rjmp	80005c50 <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005c1e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c22:	70 98       	ld.w	r8,r8[0x24]
80005c24:	58 08       	cp.w	r8,0
80005c26:	c1 c0       	breq	80005c5e <prvUnlockQueue+0x52>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005c28:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c2c:	2d c8       	sub	r8,-36
80005c2e:	10 9c       	mov	r12,r8
80005c30:	f0 1f 00 28 	mcall	80005cd0 <prvUnlockQueue+0xc4>
80005c34:	18 98       	mov	r8,r12
80005c36:	58 08       	cp.w	r8,0
80005c38:	c0 30       	breq	80005c3e <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005c3a:	f0 1f 00 27 	mcall	80005cd4 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xTxLock );
80005c3e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c42:	71 28       	ld.w	r8,r8[0x48]
80005c44:	f0 c9 00 01 	sub	r9,r8,1
80005c48:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c4c:	f1 49 00 48 	st.w	r8[72],r9
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005c50:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c54:	71 28       	ld.w	r8,r8[0x48]
80005c56:	58 08       	cp.w	r8,0
80005c58:	fe 99 ff e3 	brgt	80005c1e <prvUnlockQueue+0x12>
80005c5c:	c0 28       	rjmp	80005c60 <prvUnlockQueue+0x54>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
80005c5e:	d7 03       	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005c60:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c64:	3f f9       	mov	r9,-1
80005c66:	f1 49 00 48 	st.w	r8[72],r9
	}
	taskEXIT_CRITICAL();
80005c6a:	f0 1f 00 1c 	mcall	80005cd8 <prvUnlockQueue+0xcc>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005c6e:	f0 1f 00 18 	mcall	80005ccc <prvUnlockQueue+0xc0>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005c72:	c1 a8       	rjmp	80005ca6 <prvUnlockQueue+0x9a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005c74:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c78:	70 48       	ld.w	r8,r8[0x10]
80005c7a:	58 08       	cp.w	r8,0
80005c7c:	c1 c0       	breq	80005cb4 <prvUnlockQueue+0xa8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005c7e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c82:	2f 08       	sub	r8,-16
80005c84:	10 9c       	mov	r12,r8
80005c86:	f0 1f 00 13 	mcall	80005cd0 <prvUnlockQueue+0xc4>
80005c8a:	18 98       	mov	r8,r12
80005c8c:	58 08       	cp.w	r8,0
80005c8e:	c0 30       	breq	80005c94 <prvUnlockQueue+0x88>
				{
					vTaskMissedYield();
80005c90:	f0 1f 00 11 	mcall	80005cd4 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xRxLock );
80005c94:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c98:	71 18       	ld.w	r8,r8[0x44]
80005c9a:	f0 c9 00 01 	sub	r9,r8,1
80005c9e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005ca2:	f1 49 00 44 	st.w	r8[68],r9
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005ca6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005caa:	71 18       	ld.w	r8,r8[0x44]
80005cac:	58 08       	cp.w	r8,0
80005cae:	fe 99 ff e3 	brgt	80005c74 <prvUnlockQueue+0x68>
80005cb2:	c0 28       	rjmp	80005cb6 <prvUnlockQueue+0xaa>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
80005cb4:	d7 03       	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005cb6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005cba:	3f f9       	mov	r9,-1
80005cbc:	f1 49 00 44 	st.w	r8[68],r9
	}
	taskEXIT_CRITICAL();
80005cc0:	f0 1f 00 06 	mcall	80005cd8 <prvUnlockQueue+0xcc>
}
80005cc4:	2f fd       	sub	sp,-4
80005cc6:	e3 cd 80 80 	ldm	sp++,r7,pc
80005cca:	00 00       	add	r0,r0
80005ccc:	80 00       	ld.sh	r0,r0[0x0]
80005cce:	51 28       	stdsp	sp[0x48],r8
80005cd0:	80 00       	ld.sh	r0,r0[0x0]
80005cd2:	63 cc       	ld.w	r12,r1[0x70]
80005cd4:	80 00       	ld.sh	r0,r0[0x0]
80005cd6:	65 84       	ld.w	r4,r2[0x60]
80005cd8:	80 00       	ld.sh	r0,r0[0x0]
80005cda:	51 44       	stdsp	sp[0x50],r4

80005cdc <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
80005cdc:	eb cd 40 80 	pushm	r7,lr
80005ce0:	1a 97       	mov	r7,sp
80005ce2:	20 2d       	sub	sp,8
80005ce4:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005ce8:	f0 1f 00 09 	mcall	80005d0c <prvIsQueueEmpty+0x30>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005cec:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005cf0:	70 e8       	ld.w	r8,r8[0x38]
80005cf2:	58 08       	cp.w	r8,0
80005cf4:	5f 08       	sreq	r8
80005cf6:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80005cfa:	f0 1f 00 06 	mcall	80005d10 <prvIsQueueEmpty+0x34>

	return xReturn;
80005cfe:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005d02:	10 9c       	mov	r12,r8
80005d04:	2f ed       	sub	sp,-8
80005d06:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d0a:	00 00       	add	r0,r0
80005d0c:	80 00       	ld.sh	r0,r0[0x0]
80005d0e:	51 28       	stdsp	sp[0x48],r8
80005d10:	80 00       	ld.sh	r0,r0[0x0]
80005d12:	51 44       	stdsp	sp[0x50],r4

80005d14 <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
80005d14:	eb cd 40 80 	pushm	r7,lr
80005d18:	1a 97       	mov	r7,sp
80005d1a:	20 2d       	sub	sp,8
80005d1c:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005d20:	f0 1f 00 0a 	mcall	80005d48 <prvIsQueueFull+0x34>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005d24:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d28:	70 e9       	ld.w	r9,r8[0x38]
80005d2a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d2e:	70 f8       	ld.w	r8,r8[0x3c]
80005d30:	10 39       	cp.w	r9,r8
80005d32:	5f 08       	sreq	r8
80005d34:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80005d38:	f0 1f 00 05 	mcall	80005d4c <prvIsQueueFull+0x38>

	return xReturn;
80005d3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005d40:	10 9c       	mov	r12,r8
80005d42:	2f ed       	sub	sp,-8
80005d44:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d48:	80 00       	ld.sh	r0,r0[0x0]
80005d4a:	51 28       	stdsp	sp[0x48],r8
80005d4c:	80 00       	ld.sh	r0,r0[0x0]
80005d4e:	51 44       	stdsp	sp[0x50],r4
80005d50:	49 44       	lddpc	r4,80005da0 <xTaskGenericCreate+0x48>
80005d52:	4c 45       	lddpc	r5,80005e60 <xTaskGenericCreate+0x108>
80005d54:	00 00       	add	r0,r0
	...

80005d58 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005d58:	eb cd 40 c0 	pushm	r6-r7,lr
80005d5c:	1a 97       	mov	r7,sp
80005d5e:	20 8d       	sub	sp,32
80005d60:	ee c6 ff f4 	sub	r6,r7,-12
80005d64:	ef 4c ff f0 	st.w	r7[-16],r12
80005d68:	ef 4b ff ec 	st.w	r7[-20],r11
80005d6c:	ef 49 ff e4 	st.w	r7[-28],r9
80005d70:	ef 48 ff e0 	st.w	r7[-32],r8
80005d74:	14 98       	mov	r8,r10
80005d76:	ef 58 ff e8 	st.h	r7[-24],r8
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
80005d7a:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80005d7e:	6c 1b       	ld.w	r11,r6[0x4]
80005d80:	10 9c       	mov	r12,r8
80005d82:	f0 1f 00 5a 	mcall	80005ee8 <xTaskGenericCreate+0x190>
80005d86:	18 98       	mov	r8,r12
80005d88:	ef 48 ff f8 	st.w	r7[-8],r8

	if( pxNewTCB != NULL )
80005d8c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d90:	58 08       	cp.w	r8,0
80005d92:	e0 80 00 92 	breq	80005eb6 <xTaskGenericCreate+0x15e>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
80005d96:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d9a:	70 c9       	ld.w	r9,r8[0x30]
80005d9c:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80005da0:	20 18       	sub	r8,1
80005da2:	a3 68       	lsl	r8,0x2
80005da4:	f2 08 00 08 	add	r8,r9,r8
80005da8:	ef 48 ff fc 	st.w	r7[-4],r8
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005dac:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005db0:	e0 18 ff fc 	andl	r8,0xfffc
80005db4:	ef 48 ff fc 	st.w	r7[-4],r8
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
80005db8:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80005dbc:	6c 29       	ld.w	r9,r6[0x8]
80005dbe:	ee fa ff e0 	ld.w	r10,r7[-32]
80005dc2:	ee fb ff ec 	ld.w	r11,r7[-20]
80005dc6:	ee fc ff f8 	ld.w	r12,r7[-8]
80005dca:	f0 1f 00 49 	mcall	80005eec <xTaskGenericCreate+0x194>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005dce:	ee fa ff e4 	ld.w	r10,r7[-28]
80005dd2:	ee fb ff f0 	ld.w	r11,r7[-16]
80005dd6:	ee fc ff fc 	ld.w	r12,r7[-4]
80005dda:	f0 1f 00 46 	mcall	80005ef0 <xTaskGenericCreate+0x198>
80005dde:	18 98       	mov	r8,r12
80005de0:	10 99       	mov	r9,r8
80005de2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005de6:	91 09       	st.w	r8[0x0],r9
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
80005de8:	6c 08       	ld.w	r8,r6[0x0]
80005dea:	58 08       	cp.w	r8,0
80005dec:	c0 50       	breq	80005df6 <xTaskGenericCreate+0x9e>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005dee:	6c 08       	ld.w	r8,r6[0x0]
80005df0:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005df4:	91 09       	st.w	r8[0x0],r9
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005df6:	f0 1f 00 40 	mcall	80005ef4 <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
80005dfa:	4c 08       	lddpc	r8,80005ef8 <xTaskGenericCreate+0x1a0>
80005dfc:	70 08       	ld.w	r8,r8[0x0]
80005dfe:	f0 c9 ff ff 	sub	r9,r8,-1
80005e02:	4b e8       	lddpc	r8,80005ef8 <xTaskGenericCreate+0x1a0>
80005e04:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005e06:	4b e8       	lddpc	r8,80005efc <xTaskGenericCreate+0x1a4>
80005e08:	70 08       	ld.w	r8,r8[0x0]
80005e0a:	58 08       	cp.w	r8,0
80005e0c:	c0 c1       	brne	80005e24 <xTaskGenericCreate+0xcc>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005e0e:	4b c8       	lddpc	r8,80005efc <xTaskGenericCreate+0x1a4>
80005e10:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005e14:	91 09       	st.w	r8[0x0],r9

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005e16:	4b 98       	lddpc	r8,80005ef8 <xTaskGenericCreate+0x1a0>
80005e18:	70 08       	ld.w	r8,r8[0x0]
80005e1a:	58 18       	cp.w	r8,1
80005e1c:	c1 41       	brne	80005e44 <xTaskGenericCreate+0xec>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
80005e1e:	f0 1f 00 39 	mcall	80005f00 <xTaskGenericCreate+0x1a8>
80005e22:	c1 18       	rjmp	80005e44 <xTaskGenericCreate+0xec>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005e24:	4b 88       	lddpc	r8,80005f04 <xTaskGenericCreate+0x1ac>
80005e26:	70 08       	ld.w	r8,r8[0x0]
80005e28:	58 08       	cp.w	r8,0
80005e2a:	c0 d1       	brne	80005e44 <xTaskGenericCreate+0xec>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005e2c:	4b 48       	lddpc	r8,80005efc <xTaskGenericCreate+0x1a4>
80005e2e:	70 08       	ld.w	r8,r8[0x0]
80005e30:	70 b9       	ld.w	r9,r8[0x2c]
80005e32:	ee f8 ff e0 	ld.w	r8,r7[-32]
80005e36:	10 39       	cp.w	r9,r8
80005e38:	e0 8b 00 06 	brhi	80005e44 <xTaskGenericCreate+0xec>
					{
						pxCurrentTCB = pxNewTCB;
80005e3c:	4b 08       	lddpc	r8,80005efc <xTaskGenericCreate+0x1a4>
80005e3e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005e42:	91 09       	st.w	r8[0x0],r9
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005e44:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e48:	70 b9       	ld.w	r9,r8[0x2c]
80005e4a:	4b 08       	lddpc	r8,80005f08 <xTaskGenericCreate+0x1b0>
80005e4c:	70 08       	ld.w	r8,r8[0x0]
80005e4e:	10 39       	cp.w	r9,r8
80005e50:	e0 88 00 07 	brls	80005e5e <xTaskGenericCreate+0x106>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005e54:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e58:	70 b9       	ld.w	r9,r8[0x2c]
80005e5a:	4a c8       	lddpc	r8,80005f08 <xTaskGenericCreate+0x1b0>
80005e5c:	91 09       	st.w	r8[0x0],r9
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005e5e:	4a c8       	lddpc	r8,80005f0c <xTaskGenericCreate+0x1b4>
80005e60:	70 08       	ld.w	r8,r8[0x0]
80005e62:	f0 c9 ff ff 	sub	r9,r8,-1
80005e66:	4a a8       	lddpc	r8,80005f0c <xTaskGenericCreate+0x1b4>
80005e68:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005e6a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e6e:	70 b9       	ld.w	r9,r8[0x2c]
80005e70:	4a 88       	lddpc	r8,80005f10 <xTaskGenericCreate+0x1b8>
80005e72:	70 08       	ld.w	r8,r8[0x0]
80005e74:	10 39       	cp.w	r9,r8
80005e76:	e0 88 00 07 	brls	80005e84 <xTaskGenericCreate+0x12c>
80005e7a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e7e:	70 b9       	ld.w	r9,r8[0x2c]
80005e80:	4a 48       	lddpc	r8,80005f10 <xTaskGenericCreate+0x1b8>
80005e82:	91 09       	st.w	r8[0x0],r9
80005e84:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e88:	f0 ca ff fc 	sub	r10,r8,-4
80005e8c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e90:	70 b9       	ld.w	r9,r8[0x2c]
80005e92:	12 98       	mov	r8,r9
80005e94:	a3 68       	lsl	r8,0x2
80005e96:	12 08       	add	r8,r9
80005e98:	a3 68       	lsl	r8,0x2
80005e9a:	10 99       	mov	r9,r8
80005e9c:	49 e8       	lddpc	r8,80005f14 <xTaskGenericCreate+0x1bc>
80005e9e:	f2 08 00 08 	add	r8,r9,r8
80005ea2:	14 9b       	mov	r11,r10
80005ea4:	10 9c       	mov	r12,r8
80005ea6:	f0 1f 00 1d 	mcall	80005f18 <xTaskGenericCreate+0x1c0>

			xReturn = pdPASS;
80005eaa:	30 18       	mov	r8,1
80005eac:	ef 48 ff f4 	st.w	r7[-12],r8
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80005eb0:	f0 1f 00 1b 	mcall	80005f1c <xTaskGenericCreate+0x1c4>
80005eb4:	c0 48       	rjmp	80005ebc <xTaskGenericCreate+0x164>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
80005eb6:	3f f8       	mov	r8,-1
80005eb8:	ef 48 ff f4 	st.w	r7[-12],r8
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
80005ebc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005ec0:	58 18       	cp.w	r8,1
80005ec2:	c0 d1       	brne	80005edc <xTaskGenericCreate+0x184>
	{
		if( xSchedulerRunning != pdFALSE )
80005ec4:	49 08       	lddpc	r8,80005f04 <xTaskGenericCreate+0x1ac>
80005ec6:	70 08       	ld.w	r8,r8[0x0]
80005ec8:	58 08       	cp.w	r8,0
80005eca:	c0 90       	breq	80005edc <xTaskGenericCreate+0x184>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005ecc:	48 c8       	lddpc	r8,80005efc <xTaskGenericCreate+0x1a4>
80005ece:	70 08       	ld.w	r8,r8[0x0]
80005ed0:	70 b9       	ld.w	r9,r8[0x2c]
80005ed2:	ee f8 ff e0 	ld.w	r8,r7[-32]
80005ed6:	10 39       	cp.w	r9,r8
80005ed8:	c0 22       	brcc	80005edc <xTaskGenericCreate+0x184>
			{
				portYIELD_WITHIN_API();
80005eda:	d7 33       	scall
			}
		}
	}

	return xReturn;
80005edc:	ee f8 ff f4 	ld.w	r8,r7[-12]
}
80005ee0:	10 9c       	mov	r12,r8
80005ee2:	2f 8d       	sub	sp,-32
80005ee4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005ee8:	80 00       	ld.sh	r0,r0[0x0]
80005eea:	68 18       	ld.w	r8,r4[0x4]
80005eec:	80 00       	ld.sh	r0,r0[0x0]
80005eee:	65 c4       	ld.w	r4,r2[0x70]
80005ef0:	80 00       	ld.sh	r0,r0[0x0]
80005ef2:	51 70       	stdsp	sp[0x5c],r0
80005ef4:	80 00       	ld.sh	r0,r0[0x0]
80005ef6:	51 28       	stdsp	sp[0x48],r8
80005ef8:	00 00       	add	r0,r0
80005efa:	07 74       	ld.ub	r4,--r3
80005efc:	00 00       	add	r0,r0
80005efe:	06 60       	and	r0,r3
80005f00:	80 00       	ld.sh	r0,r0[0x0]
80005f02:	66 6c       	ld.w	r12,r3[0x18]
80005f04:	00 00       	add	r0,r0
80005f06:	07 84       	ld.ub	r4,r3[0x0]
80005f08:	00 00       	add	r0,r0
80005f0a:	07 7c       	ld.ub	r12,--r3
80005f0c:	00 00       	add	r0,r0
80005f0e:	07 98       	ld.ub	r8,r3[0x1]
80005f10:	00 00       	add	r0,r0
80005f12:	07 80       	ld.ub	r0,r3[0x0]
80005f14:	00 00       	add	r0,r0
80005f16:	06 64       	and	r4,r3
80005f18:	80 00       	ld.sh	r0,r0[0x0]
80005f1a:	4d fe       	lddpc	lr,80006094 <xTaskResumeAll+0x80>
80005f1c:	80 00       	ld.sh	r0,r0[0x0]
80005f1e:	51 44       	stdsp	sp[0x50],r4

80005f20 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80005f20:	eb cd 40 80 	pushm	r7,lr
80005f24:	1a 97       	mov	r7,sp
80005f26:	20 3d       	sub	sp,12
80005f28:	ef 4c ff f4 	st.w	r7[-12],r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
80005f2c:	30 08       	mov	r8,0
80005f2e:	ef 48 ff fc 	st.w	r7[-4],r8

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80005f32:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005f36:	58 08       	cp.w	r8,0
80005f38:	c1 a0       	breq	80005f6c <vTaskDelay+0x4c>
		{
			vTaskSuspendAll();
80005f3a:	f0 1f 00 11 	mcall	80005f7c <vTaskDelay+0x5c>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80005f3e:	49 18       	lddpc	r8,80005f80 <vTaskDelay+0x60>
80005f40:	70 09       	ld.w	r9,r8[0x0]
80005f42:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005f46:	f2 08 00 08 	add	r8,r9,r8
80005f4a:	ef 48 ff f8 	st.w	r7[-8],r8

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005f4e:	48 e8       	lddpc	r8,80005f84 <vTaskDelay+0x64>
80005f50:	70 08       	ld.w	r8,r8[0x0]
80005f52:	2f c8       	sub	r8,-4
80005f54:	10 9c       	mov	r12,r8
80005f56:	f0 1f 00 0d 	mcall	80005f88 <vTaskDelay+0x68>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005f5a:	ee fc ff f8 	ld.w	r12,r7[-8]
80005f5e:	f0 1f 00 0c 	mcall	80005f8c <vTaskDelay+0x6c>
			}
			xAlreadyYielded = xTaskResumeAll();
80005f62:	f0 1f 00 0c 	mcall	80005f90 <vTaskDelay+0x70>
80005f66:	18 98       	mov	r8,r12
80005f68:	ef 48 ff fc 	st.w	r7[-4],r8
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005f6c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005f70:	58 08       	cp.w	r8,0
80005f72:	c0 21       	brne	80005f76 <vTaskDelay+0x56>
		{
			portYIELD_WITHIN_API();
80005f74:	d7 33       	scall
		}
	}
80005f76:	2f dd       	sub	sp,-12
80005f78:	e3 cd 80 80 	ldm	sp++,r7,pc
80005f7c:	80 00       	ld.sh	r0,r0[0x0]
80005f7e:	5f f8       	sral	r8
80005f80:	00 00       	add	r0,r0
80005f82:	07 78       	ld.ub	r8,--r3
80005f84:	00 00       	add	r0,r0
80005f86:	06 60       	and	r0,r3
80005f88:	80 00       	ld.sh	r0,r0[0x0]
80005f8a:	4f 12       	lddpc	r2,8000614c <vTaskIncrementTick+0x10>
80005f8c:	80 00       	ld.sh	r0,r0[0x0]
80005f8e:	67 98       	ld.w	r8,r3[0x64]
80005f90:	80 00       	ld.sh	r0,r0[0x0]
80005f92:	60 14       	ld.w	r4,r0[0x4]

80005f94 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005f94:	eb cd 40 80 	pushm	r7,lr
80005f98:	1a 97       	mov	r7,sp
80005f9a:	20 1d       	sub	sp,4
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005f9c:	49 1b       	lddpc	r11,80005fe0 <vTaskStartScheduler+0x4c>
80005f9e:	30 08       	mov	r8,0
80005fa0:	1a d8       	st.w	--sp,r8
80005fa2:	30 08       	mov	r8,0
80005fa4:	1a d8       	st.w	--sp,r8
80005fa6:	30 08       	mov	r8,0
80005fa8:	1a d8       	st.w	--sp,r8
80005faa:	30 08       	mov	r8,0
80005fac:	30 09       	mov	r9,0
80005fae:	e0 6a 01 00 	mov	r10,256
80005fb2:	48 dc       	lddpc	r12,80005fe4 <vTaskStartScheduler+0x50>
80005fb4:	f0 1f 00 0d 	mcall	80005fe8 <vTaskStartScheduler+0x54>
80005fb8:	2f dd       	sub	sp,-12
80005fba:	18 98       	mov	r8,r12
80005fbc:	ef 48 ff fc 	st.w	r7[-4],r8
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005fc0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005fc4:	58 18       	cp.w	r8,1
80005fc6:	c0 a1       	brne	80005fda <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005fc8:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005fca:	48 98       	lddpc	r8,80005fec <vTaskStartScheduler+0x58>
80005fcc:	30 19       	mov	r9,1
80005fce:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005fd0:	48 88       	lddpc	r8,80005ff0 <vTaskStartScheduler+0x5c>
80005fd2:	30 09       	mov	r9,0
80005fd4:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005fd6:	f0 1f 00 08 	mcall	80005ff4 <vTaskStartScheduler+0x60>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
80005fda:	2f fd       	sub	sp,-4
80005fdc:	e3 cd 80 80 	ldm	sp++,r7,pc
80005fe0:	80 00       	ld.sh	r0,r0[0x0]
80005fe2:	5d 50       	*unknown*
80005fe4:	80 00       	ld.sh	r0,r0[0x0]
80005fe6:	65 98       	ld.w	r8,r2[0x64]
80005fe8:	80 00       	ld.sh	r0,r0[0x0]
80005fea:	5d 58       	*unknown*
80005fec:	00 00       	add	r0,r0
80005fee:	07 84       	ld.ub	r4,r3[0x0]
80005ff0:	00 00       	add	r0,r0
80005ff2:	07 78       	ld.ub	r8,--r3
80005ff4:	80 00       	ld.sh	r0,r0[0x0]
80005ff6:	53 18       	stdsp	sp[0xc4],r8

80005ff8 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
80005ff8:	eb cd 40 80 	pushm	r7,lr
80005ffc:	1a 97       	mov	r7,sp
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005ffe:	48 58       	lddpc	r8,80006010 <vTaskSuspendAll+0x18>
80006000:	70 08       	ld.w	r8,r8[0x0]
80006002:	f0 c9 ff ff 	sub	r9,r8,-1
80006006:	48 38       	lddpc	r8,80006010 <vTaskSuspendAll+0x18>
80006008:	91 09       	st.w	r8[0x0],r9
}
8000600a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000600e:	00 00       	add	r0,r0
80006010:	00 00       	add	r0,r0
80006012:	07 88       	ld.ub	r8,r3[0x0]

80006014 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006014:	eb cd 40 c0 	pushm	r6-r7,lr
80006018:	1a 97       	mov	r7,sp
8000601a:	20 2d       	sub	sp,8
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
8000601c:	30 08       	mov	r8,0
8000601e:	ef 48 ff f8 	st.w	r7[-8],r8
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006022:	f0 1f 00 3a 	mcall	80006108 <xTaskResumeAll+0xf4>
	{
		--uxSchedulerSuspended;
80006026:	4b a8       	lddpc	r8,8000610c <xTaskResumeAll+0xf8>
80006028:	70 08       	ld.w	r8,r8[0x0]
8000602a:	f0 c9 00 01 	sub	r9,r8,1
8000602e:	4b 88       	lddpc	r8,8000610c <xTaskResumeAll+0xf8>
80006030:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006032:	4b 78       	lddpc	r8,8000610c <xTaskResumeAll+0xf8>
80006034:	70 08       	ld.w	r8,r8[0x0]
80006036:	58 08       	cp.w	r8,0
80006038:	c5 f1       	brne	800060f6 <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000603a:	4b 68       	lddpc	r8,80006110 <xTaskResumeAll+0xfc>
8000603c:	70 08       	ld.w	r8,r8[0x0]
8000603e:	58 08       	cp.w	r8,0
80006040:	c5 b0       	breq	800060f6 <xTaskResumeAll+0xe2>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
80006042:	30 08       	mov	r8,0
80006044:	ef 48 ff fc 	st.w	r7[-4],r8

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006048:	c3 08       	rjmp	800060a8 <xTaskResumeAll+0x94>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000604a:	4b 38       	lddpc	r8,80006114 <xTaskResumeAll+0x100>
8000604c:	70 38       	ld.w	r8,r8[0xc]
8000604e:	70 38       	ld.w	r8,r8[0xc]
80006050:	10 96       	mov	r6,r8
					vListRemove( &( pxTCB->xEventListItem ) );
80006052:	ec c8 ff e8 	sub	r8,r6,-24
80006056:	10 9c       	mov	r12,r8
80006058:	f0 1f 00 30 	mcall	80006118 <xTaskResumeAll+0x104>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000605c:	ec c8 ff fc 	sub	r8,r6,-4
80006060:	10 9c       	mov	r12,r8
80006062:	f0 1f 00 2e 	mcall	80006118 <xTaskResumeAll+0x104>
					prvAddTaskToReadyQueue( pxTCB );
80006066:	6c b9       	ld.w	r9,r6[0x2c]
80006068:	4a d8       	lddpc	r8,8000611c <xTaskResumeAll+0x108>
8000606a:	70 08       	ld.w	r8,r8[0x0]
8000606c:	10 39       	cp.w	r9,r8
8000606e:	e0 88 00 05 	brls	80006078 <xTaskResumeAll+0x64>
80006072:	6c b9       	ld.w	r9,r6[0x2c]
80006074:	4a a8       	lddpc	r8,8000611c <xTaskResumeAll+0x108>
80006076:	91 09       	st.w	r8[0x0],r9
80006078:	ec ca ff fc 	sub	r10,r6,-4
8000607c:	6c b9       	ld.w	r9,r6[0x2c]
8000607e:	12 98       	mov	r8,r9
80006080:	a3 68       	lsl	r8,0x2
80006082:	12 08       	add	r8,r9
80006084:	a3 68       	lsl	r8,0x2
80006086:	10 99       	mov	r9,r8
80006088:	4a 68       	lddpc	r8,80006120 <xTaskResumeAll+0x10c>
8000608a:	f2 08 00 08 	add	r8,r9,r8
8000608e:	14 9b       	mov	r11,r10
80006090:	10 9c       	mov	r12,r8
80006092:	f0 1f 00 25 	mcall	80006124 <xTaskResumeAll+0x110>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006096:	6c b9       	ld.w	r9,r6[0x2c]
80006098:	4a 48       	lddpc	r8,80006128 <xTaskResumeAll+0x114>
8000609a:	70 08       	ld.w	r8,r8[0x0]
8000609c:	70 b8       	ld.w	r8,r8[0x2c]
8000609e:	10 39       	cp.w	r9,r8
800060a0:	c0 43       	brcs	800060a8 <xTaskResumeAll+0x94>
					{
						xYieldRequired = pdTRUE;
800060a2:	30 18       	mov	r8,1
800060a4:	ef 48 ff fc 	st.w	r7[-4],r8
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800060a8:	49 b8       	lddpc	r8,80006114 <xTaskResumeAll+0x100>
800060aa:	70 08       	ld.w	r8,r8[0x0]
800060ac:	58 08       	cp.w	r8,0
800060ae:	cc e1       	brne	8000604a <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800060b0:	49 f8       	lddpc	r8,8000612c <xTaskResumeAll+0x118>
800060b2:	70 08       	ld.w	r8,r8[0x0]
800060b4:	58 08       	cp.w	r8,0
800060b6:	c1 10       	breq	800060d8 <xTaskResumeAll+0xc4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800060b8:	c0 98       	rjmp	800060ca <xTaskResumeAll+0xb6>
					{
						vTaskIncrementTick();
800060ba:	f0 1f 00 1e 	mcall	80006130 <xTaskResumeAll+0x11c>
						--uxMissedTicks;
800060be:	49 c8       	lddpc	r8,8000612c <xTaskResumeAll+0x118>
800060c0:	70 08       	ld.w	r8,r8[0x0]
800060c2:	f0 c9 00 01 	sub	r9,r8,1
800060c6:	49 a8       	lddpc	r8,8000612c <xTaskResumeAll+0x118>
800060c8:	91 09       	st.w	r8[0x0],r9
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800060ca:	49 98       	lddpc	r8,8000612c <xTaskResumeAll+0x118>
800060cc:	70 08       	ld.w	r8,r8[0x0]
800060ce:	58 08       	cp.w	r8,0
800060d0:	cf 51       	brne	800060ba <xTaskResumeAll+0xa6>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
800060d2:	30 18       	mov	r8,1
800060d4:	ef 48 ff fc 	st.w	r7[-4],r8
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800060d8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800060dc:	58 18       	cp.w	r8,1
800060de:	c0 50       	breq	800060e8 <xTaskResumeAll+0xd4>
800060e0:	49 58       	lddpc	r8,80006134 <xTaskResumeAll+0x120>
800060e2:	70 08       	ld.w	r8,r8[0x0]
800060e4:	58 18       	cp.w	r8,1
800060e6:	c0 81       	brne	800060f6 <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
800060e8:	30 18       	mov	r8,1
800060ea:	ef 48 ff f8 	st.w	r7[-8],r8
					xMissedYield = pdFALSE;
800060ee:	49 28       	lddpc	r8,80006134 <xTaskResumeAll+0x120>
800060f0:	30 09       	mov	r9,0
800060f2:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800060f4:	d7 33       	scall
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800060f6:	f0 1f 00 11 	mcall	80006138 <xTaskResumeAll+0x124>

	return xAlreadyYielded;
800060fa:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800060fe:	10 9c       	mov	r12,r8
80006100:	2f ed       	sub	sp,-8
80006102:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006106:	00 00       	add	r0,r0
80006108:	80 00       	ld.sh	r0,r0[0x0]
8000610a:	51 28       	stdsp	sp[0x48],r8
8000610c:	00 00       	add	r0,r0
8000610e:	07 88       	ld.ub	r8,r3[0x0]
80006110:	00 00       	add	r0,r0
80006112:	07 74       	ld.ub	r4,--r3
80006114:	00 00       	add	r0,r0
80006116:	07 34       	ld.ub	r4,r3++
80006118:	80 00       	ld.sh	r0,r0[0x0]
8000611a:	4f 12       	lddpc	r2,800062dc <vTaskSwitchContext+0x40>
8000611c:	00 00       	add	r0,r0
8000611e:	07 80       	ld.ub	r0,r3[0x0]
80006120:	00 00       	add	r0,r0
80006122:	06 64       	and	r4,r3
80006124:	80 00       	ld.sh	r0,r0[0x0]
80006126:	4d fe       	lddpc	lr,800062a0 <vTaskSwitchContext+0x4>
80006128:	00 00       	add	r0,r0
8000612a:	06 60       	and	r0,r3
8000612c:	00 00       	add	r0,r0
8000612e:	07 8c       	ld.ub	r12,r3[0x0]
80006130:	80 00       	ld.sh	r0,r0[0x0]
80006132:	61 3c       	ld.w	r12,r0[0x4c]
80006134:	00 00       	add	r0,r0
80006136:	07 90       	ld.ub	r0,r3[0x1]
80006138:	80 00       	ld.sh	r0,r0[0x0]
8000613a:	51 44       	stdsp	sp[0x50],r4

8000613c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
8000613c:	eb cd 40 80 	pushm	r7,lr
80006140:	1a 97       	mov	r7,sp
80006142:	20 3d       	sub	sp,12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006144:	4c b8       	lddpc	r8,80006270 <vTaskIncrementTick+0x134>
80006146:	70 08       	ld.w	r8,r8[0x0]
80006148:	58 08       	cp.w	r8,0
8000614a:	e0 81 00 89 	brne	8000625c <vTaskIncrementTick+0x120>
	{
		++xTickCount;
8000614e:	4c a8       	lddpc	r8,80006274 <vTaskIncrementTick+0x138>
80006150:	70 08       	ld.w	r8,r8[0x0]
80006152:	f0 c9 ff ff 	sub	r9,r8,-1
80006156:	4c 88       	lddpc	r8,80006274 <vTaskIncrementTick+0x138>
80006158:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000615a:	4c 78       	lddpc	r8,80006274 <vTaskIncrementTick+0x138>
8000615c:	70 08       	ld.w	r8,r8[0x0]
8000615e:	58 08       	cp.w	r8,0
80006160:	c2 71       	brne	800061ae <vTaskIncrementTick+0x72>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80006162:	4c 68       	lddpc	r8,80006278 <vTaskIncrementTick+0x13c>
80006164:	70 08       	ld.w	r8,r8[0x0]
80006166:	ef 48 ff f8 	st.w	r7[-8],r8
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000616a:	4c 58       	lddpc	r8,8000627c <vTaskIncrementTick+0x140>
8000616c:	70 09       	ld.w	r9,r8[0x0]
8000616e:	4c 38       	lddpc	r8,80006278 <vTaskIncrementTick+0x13c>
80006170:	91 09       	st.w	r8[0x0],r9
			pxOverflowDelayedTaskList = pxTemp;
80006172:	4c 38       	lddpc	r8,8000627c <vTaskIncrementTick+0x140>
80006174:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006178:	91 09       	st.w	r8[0x0],r9
			xNumOfOverflows++;
8000617a:	4c 28       	lddpc	r8,80006280 <vTaskIncrementTick+0x144>
8000617c:	70 08       	ld.w	r8,r8[0x0]
8000617e:	f0 c9 ff ff 	sub	r9,r8,-1
80006182:	4c 08       	lddpc	r8,80006280 <vTaskIncrementTick+0x144>
80006184:	91 09       	st.w	r8[0x0],r9

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80006186:	4b d8       	lddpc	r8,80006278 <vTaskIncrementTick+0x13c>
80006188:	70 08       	ld.w	r8,r8[0x0]
8000618a:	70 08       	ld.w	r8,r8[0x0]
8000618c:	58 08       	cp.w	r8,0
8000618e:	c0 51       	brne	80006198 <vTaskIncrementTick+0x5c>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80006190:	4b d8       	lddpc	r8,80006284 <vTaskIncrementTick+0x148>
80006192:	3f f9       	mov	r9,-1
80006194:	91 09       	st.w	r8[0x0],r9
80006196:	c0 c8       	rjmp	800061ae <vTaskIncrementTick+0x72>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80006198:	4b 88       	lddpc	r8,80006278 <vTaskIncrementTick+0x13c>
8000619a:	70 08       	ld.w	r8,r8[0x0]
8000619c:	70 38       	ld.w	r8,r8[0xc]
8000619e:	70 38       	ld.w	r8,r8[0xc]
800061a0:	ef 48 ff f4 	st.w	r7[-12],r8
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800061a4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800061a8:	70 19       	ld.w	r9,r8[0x4]
800061aa:	4b 78       	lddpc	r8,80006284 <vTaskIncrementTick+0x148>
800061ac:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800061ae:	4b 28       	lddpc	r8,80006274 <vTaskIncrementTick+0x138>
800061b0:	70 09       	ld.w	r9,r8[0x0]
800061b2:	4b 58       	lddpc	r8,80006284 <vTaskIncrementTick+0x148>
800061b4:	70 08       	ld.w	r8,r8[0x0]
800061b6:	10 39       	cp.w	r9,r8
800061b8:	c5 83       	brcs	80006268 <vTaskIncrementTick+0x12c>
800061ba:	4b 08       	lddpc	r8,80006278 <vTaskIncrementTick+0x13c>
800061bc:	70 08       	ld.w	r8,r8[0x0]
800061be:	70 08       	ld.w	r8,r8[0x0]
800061c0:	58 08       	cp.w	r8,0
800061c2:	c0 51       	brne	800061cc <vTaskIncrementTick+0x90>
800061c4:	4b 08       	lddpc	r8,80006284 <vTaskIncrementTick+0x148>
800061c6:	3f f9       	mov	r9,-1
800061c8:	91 09       	st.w	r8[0x0],r9
800061ca:	c4 f8       	rjmp	80006268 <vTaskIncrementTick+0x12c>
800061cc:	4a b8       	lddpc	r8,80006278 <vTaskIncrementTick+0x13c>
800061ce:	70 08       	ld.w	r8,r8[0x0]
800061d0:	70 38       	ld.w	r8,r8[0xc]
800061d2:	70 38       	ld.w	r8,r8[0xc]
800061d4:	ef 48 ff f4 	st.w	r7[-12],r8
800061d8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800061dc:	70 18       	ld.w	r8,r8[0x4]
800061de:	ef 48 ff fc 	st.w	r7[-4],r8
800061e2:	4a 58       	lddpc	r8,80006274 <vTaskIncrementTick+0x138>
800061e4:	70 09       	ld.w	r9,r8[0x0]
800061e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800061ea:	10 39       	cp.w	r9,r8
800061ec:	c0 62       	brcc	800061f8 <vTaskIncrementTick+0xbc>
800061ee:	4a 68       	lddpc	r8,80006284 <vTaskIncrementTick+0x148>
800061f0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800061f4:	91 09       	st.w	r8[0x0],r9
800061f6:	c3 98       	rjmp	80006268 <vTaskIncrementTick+0x12c>
800061f8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800061fc:	2f c8       	sub	r8,-4
800061fe:	10 9c       	mov	r12,r8
80006200:	f0 1f 00 22 	mcall	80006288 <vTaskIncrementTick+0x14c>
80006204:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006208:	70 a8       	ld.w	r8,r8[0x28]
8000620a:	58 08       	cp.w	r8,0
8000620c:	c0 70       	breq	8000621a <vTaskIncrementTick+0xde>
8000620e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006212:	2e 88       	sub	r8,-24
80006214:	10 9c       	mov	r12,r8
80006216:	f0 1f 00 1d 	mcall	80006288 <vTaskIncrementTick+0x14c>
8000621a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000621e:	70 b9       	ld.w	r9,r8[0x2c]
80006220:	49 b8       	lddpc	r8,8000628c <vTaskIncrementTick+0x150>
80006222:	70 08       	ld.w	r8,r8[0x0]
80006224:	10 39       	cp.w	r9,r8
80006226:	e0 88 00 07 	brls	80006234 <vTaskIncrementTick+0xf8>
8000622a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000622e:	70 b9       	ld.w	r9,r8[0x2c]
80006230:	49 78       	lddpc	r8,8000628c <vTaskIncrementTick+0x150>
80006232:	91 09       	st.w	r8[0x0],r9
80006234:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006238:	f0 ca ff fc 	sub	r10,r8,-4
8000623c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006240:	70 b9       	ld.w	r9,r8[0x2c]
80006242:	12 98       	mov	r8,r9
80006244:	a3 68       	lsl	r8,0x2
80006246:	12 08       	add	r8,r9
80006248:	a3 68       	lsl	r8,0x2
8000624a:	10 99       	mov	r9,r8
8000624c:	49 18       	lddpc	r8,80006290 <vTaskIncrementTick+0x154>
8000624e:	f2 08 00 08 	add	r8,r9,r8
80006252:	14 9b       	mov	r11,r10
80006254:	10 9c       	mov	r12,r8
80006256:	f0 1f 00 10 	mcall	80006294 <vTaskIncrementTick+0x158>
8000625a:	cb 0b       	rjmp	800061ba <vTaskIncrementTick+0x7e>
	}
	else
	{
		++uxMissedTicks;
8000625c:	48 f8       	lddpc	r8,80006298 <vTaskIncrementTick+0x15c>
8000625e:	70 08       	ld.w	r8,r8[0x0]
80006260:	f0 c9 ff ff 	sub	r9,r8,-1
80006264:	48 d8       	lddpc	r8,80006298 <vTaskIncrementTick+0x15c>
80006266:	91 09       	st.w	r8[0x0],r9
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
80006268:	2f dd       	sub	sp,-12
8000626a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000626e:	00 00       	add	r0,r0
80006270:	00 00       	add	r0,r0
80006272:	07 88       	ld.ub	r8,r3[0x0]
80006274:	00 00       	add	r0,r0
80006276:	07 78       	ld.ub	r8,--r3
80006278:	00 00       	add	r0,r0
8000627a:	07 2c       	ld.uh	r12,r3++
8000627c:	00 00       	add	r0,r0
8000627e:	07 30       	ld.ub	r0,r3++
80006280:	00 00       	add	r0,r0
80006282:	07 94       	ld.ub	r4,r3[0x1]
80006284:	00 00       	add	r0,r0
80006286:	00 24       	rsub	r4,r0
80006288:	80 00       	ld.sh	r0,r0[0x0]
8000628a:	4f 12       	lddpc	r2,8000644c <xTaskRemoveFromEventList+0x80>
8000628c:	00 00       	add	r0,r0
8000628e:	07 80       	ld.ub	r0,r3[0x0]
80006290:	00 00       	add	r0,r0
80006292:	06 64       	and	r4,r3
80006294:	80 00       	ld.sh	r0,r0[0x0]
80006296:	4d fe       	lddpc	lr,80006410 <xTaskRemoveFromEventList+0x44>
80006298:	00 00       	add	r0,r0
8000629a:	07 8c       	ld.ub	r12,r3[0x0]

8000629c <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
8000629c:	eb cd 40 80 	pushm	r7,lr
800062a0:	1a 97       	mov	r7,sp
800062a2:	20 1d       	sub	sp,4
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800062a4:	4a 58       	lddpc	r8,80006338 <vTaskSwitchContext+0x9c>
800062a6:	70 08       	ld.w	r8,r8[0x0]
800062a8:	58 08       	cp.w	r8,0
800062aa:	c0 c0       	breq	800062c2 <vTaskSwitchContext+0x26>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800062ac:	4a 48       	lddpc	r8,8000633c <vTaskSwitchContext+0xa0>
800062ae:	30 19       	mov	r9,1
800062b0:	91 09       	st.w	r8[0x0],r9
800062b2:	c3 f8       	rjmp	80006330 <vTaskSwitchContext+0x94>

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800062b4:	4a 38       	lddpc	r8,80006340 <vTaskSwitchContext+0xa4>
800062b6:	70 08       	ld.w	r8,r8[0x0]
800062b8:	f0 c9 00 01 	sub	r9,r8,1
800062bc:	4a 18       	lddpc	r8,80006340 <vTaskSwitchContext+0xa4>
800062be:	91 09       	st.w	r8[0x0],r9
800062c0:	c0 28       	rjmp	800062c4 <vTaskSwitchContext+0x28>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800062c2:	d7 03       	nop
800062c4:	49 f8       	lddpc	r8,80006340 <vTaskSwitchContext+0xa4>
800062c6:	70 09       	ld.w	r9,r8[0x0]
800062c8:	12 98       	mov	r8,r9
800062ca:	a3 68       	lsl	r8,0x2
800062cc:	12 08       	add	r8,r9
800062ce:	a3 68       	lsl	r8,0x2
800062d0:	10 99       	mov	r9,r8
800062d2:	49 d8       	lddpc	r8,80006344 <vTaskSwitchContext+0xa8>
800062d4:	f2 08 00 08 	add	r8,r9,r8
800062d8:	70 08       	ld.w	r8,r8[0x0]
800062da:	58 08       	cp.w	r8,0
800062dc:	ce c0       	breq	800062b4 <vTaskSwitchContext+0x18>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800062de:	49 98       	lddpc	r8,80006340 <vTaskSwitchContext+0xa4>
800062e0:	70 09       	ld.w	r9,r8[0x0]
800062e2:	12 98       	mov	r8,r9
800062e4:	a3 68       	lsl	r8,0x2
800062e6:	12 08       	add	r8,r9
800062e8:	a3 68       	lsl	r8,0x2
800062ea:	10 99       	mov	r9,r8
800062ec:	49 68       	lddpc	r8,80006344 <vTaskSwitchContext+0xa8>
800062ee:	f2 08 00 08 	add	r8,r9,r8
800062f2:	ef 48 ff fc 	st.w	r7[-4],r8
800062f6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800062fa:	70 18       	ld.w	r8,r8[0x4]
800062fc:	70 19       	ld.w	r9,r8[0x4]
800062fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006302:	91 19       	st.w	r8[0x4],r9
80006304:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006308:	70 19       	ld.w	r9,r8[0x4]
8000630a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000630e:	2f 88       	sub	r8,-8
80006310:	10 39       	cp.w	r9,r8
80006312:	c0 81       	brne	80006322 <vTaskSwitchContext+0x86>
80006314:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006318:	70 18       	ld.w	r8,r8[0x4]
8000631a:	70 19       	ld.w	r9,r8[0x4]
8000631c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006320:	91 19       	st.w	r8[0x4],r9
80006322:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006326:	70 18       	ld.w	r8,r8[0x4]
80006328:	70 38       	ld.w	r8,r8[0xc]
8000632a:	10 99       	mov	r9,r8
8000632c:	48 78       	lddpc	r8,80006348 <vTaskSwitchContext+0xac>
8000632e:	91 09       	st.w	r8[0x0],r9

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
80006330:	2f fd       	sub	sp,-4
80006332:	e3 cd 80 80 	ldm	sp++,r7,pc
80006336:	00 00       	add	r0,r0
80006338:	00 00       	add	r0,r0
8000633a:	07 88       	ld.ub	r8,r3[0x0]
8000633c:	00 00       	add	r0,r0
8000633e:	07 90       	ld.ub	r0,r3[0x1]
80006340:	00 00       	add	r0,r0
80006342:	07 80       	ld.ub	r0,r3[0x0]
80006344:	00 00       	add	r0,r0
80006346:	06 64       	and	r4,r3
80006348:	00 00       	add	r0,r0
8000634a:	06 60       	and	r0,r3

8000634c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
8000634c:	eb cd 40 80 	pushm	r7,lr
80006350:	1a 97       	mov	r7,sp
80006352:	20 3d       	sub	sp,12
80006354:	ef 4c ff f8 	st.w	r7[-8],r12
80006358:	ef 4b ff f4 	st.w	r7[-12],r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
8000635c:	49 58       	lddpc	r8,800063b0 <vTaskPlaceOnEventList+0x64>
8000635e:	70 08       	ld.w	r8,r8[0x0]
80006360:	2e 88       	sub	r8,-24
80006362:	10 9b       	mov	r11,r8
80006364:	ee fc ff f8 	ld.w	r12,r7[-8]
80006368:	f0 1f 00 13 	mcall	800063b4 <vTaskPlaceOnEventList+0x68>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000636c:	49 18       	lddpc	r8,800063b0 <vTaskPlaceOnEventList+0x64>
8000636e:	70 08       	ld.w	r8,r8[0x0]
80006370:	2f c8       	sub	r8,-4
80006372:	10 9c       	mov	r12,r8
80006374:	f0 1f 00 11 	mcall	800063b8 <vTaskPlaceOnEventList+0x6c>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006378:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000637c:	5b f8       	cp.w	r8,-1
8000637e:	c0 91       	brne	80006390 <vTaskPlaceOnEventList+0x44>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006380:	48 c8       	lddpc	r8,800063b0 <vTaskPlaceOnEventList+0x64>
80006382:	70 08       	ld.w	r8,r8[0x0]
80006384:	2f c8       	sub	r8,-4
80006386:	10 9b       	mov	r11,r8
80006388:	48 dc       	lddpc	r12,800063bc <vTaskPlaceOnEventList+0x70>
8000638a:	f0 1f 00 0e 	mcall	800063c0 <vTaskPlaceOnEventList+0x74>
8000638e:	c0 d8       	rjmp	800063a8 <vTaskPlaceOnEventList+0x5c>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006390:	48 d8       	lddpc	r8,800063c4 <vTaskPlaceOnEventList+0x78>
80006392:	70 09       	ld.w	r9,r8[0x0]
80006394:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006398:	f2 08 00 08 	add	r8,r9,r8
8000639c:	ef 48 ff fc 	st.w	r7[-4],r8
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800063a0:	ee fc ff fc 	ld.w	r12,r7[-4]
800063a4:	f0 1f 00 09 	mcall	800063c8 <vTaskPlaceOnEventList+0x7c>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
800063a8:	2f dd       	sub	sp,-12
800063aa:	e3 cd 80 80 	ldm	sp++,r7,pc
800063ae:	00 00       	add	r0,r0
800063b0:	00 00       	add	r0,r0
800063b2:	06 60       	and	r0,r3
800063b4:	80 00       	ld.sh	r0,r0[0x0]
800063b6:	4e 70       	lddpc	r0,80006550 <xTaskCheckForTimeOut+0x84>
800063b8:	80 00       	ld.sh	r0,r0[0x0]
800063ba:	4f 12       	lddpc	r2,8000657c <xTaskCheckForTimeOut+0xb0>
800063bc:	00 00       	add	r0,r0
800063be:	07 60       	ld.uh	r0,--r3
800063c0:	80 00       	ld.sh	r0,r0[0x0]
800063c2:	4d fe       	lddpc	lr,8000653c <xTaskCheckForTimeOut+0x70>
800063c4:	00 00       	add	r0,r0
800063c6:	07 78       	ld.ub	r8,--r3
800063c8:	80 00       	ld.sh	r0,r0[0x0]
800063ca:	67 98       	ld.w	r8,r3[0x64]

800063cc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800063cc:	eb cd 40 80 	pushm	r7,lr
800063d0:	1a 97       	mov	r7,sp
800063d2:	20 3d       	sub	sp,12
800063d4:	ef 4c ff f4 	st.w	r7[-12],r12
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800063d8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800063dc:	70 38       	ld.w	r8,r8[0xc]
800063de:	70 38       	ld.w	r8,r8[0xc]
800063e0:	ef 48 ff f8 	st.w	r7[-8],r8
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800063e4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800063e8:	2e 88       	sub	r8,-24
800063ea:	10 9c       	mov	r12,r8
800063ec:	f0 1f 00 25 	mcall	80006480 <xTaskRemoveFromEventList+0xb4>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800063f0:	4a 58       	lddpc	r8,80006484 <xTaskRemoveFromEventList+0xb8>
800063f2:	70 08       	ld.w	r8,r8[0x0]
800063f4:	58 08       	cp.w	r8,0
800063f6:	c2 81       	brne	80006446 <xTaskRemoveFromEventList+0x7a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800063f8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800063fc:	2f c8       	sub	r8,-4
800063fe:	10 9c       	mov	r12,r8
80006400:	f0 1f 00 20 	mcall	80006480 <xTaskRemoveFromEventList+0xb4>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006404:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006408:	70 b9       	ld.w	r9,r8[0x2c]
8000640a:	4a 08       	lddpc	r8,80006488 <xTaskRemoveFromEventList+0xbc>
8000640c:	70 08       	ld.w	r8,r8[0x0]
8000640e:	10 39       	cp.w	r9,r8
80006410:	e0 88 00 07 	brls	8000641e <xTaskRemoveFromEventList+0x52>
80006414:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006418:	70 b9       	ld.w	r9,r8[0x2c]
8000641a:	49 c8       	lddpc	r8,80006488 <xTaskRemoveFromEventList+0xbc>
8000641c:	91 09       	st.w	r8[0x0],r9
8000641e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006422:	f0 ca ff fc 	sub	r10,r8,-4
80006426:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000642a:	70 b9       	ld.w	r9,r8[0x2c]
8000642c:	12 98       	mov	r8,r9
8000642e:	a3 68       	lsl	r8,0x2
80006430:	12 08       	add	r8,r9
80006432:	a3 68       	lsl	r8,0x2
80006434:	10 99       	mov	r9,r8
80006436:	49 68       	lddpc	r8,8000648c <xTaskRemoveFromEventList+0xc0>
80006438:	f2 08 00 08 	add	r8,r9,r8
8000643c:	14 9b       	mov	r11,r10
8000643e:	10 9c       	mov	r12,r8
80006440:	f0 1f 00 14 	mcall	80006490 <xTaskRemoveFromEventList+0xc4>
80006444:	c0 88       	rjmp	80006454 <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80006446:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000644a:	2e 88       	sub	r8,-24
8000644c:	10 9b       	mov	r11,r8
8000644e:	49 2c       	lddpc	r12,80006494 <xTaskRemoveFromEventList+0xc8>
80006450:	f0 1f 00 10 	mcall	80006490 <xTaskRemoveFromEventList+0xc4>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006454:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006458:	70 b9       	ld.w	r9,r8[0x2c]
8000645a:	49 08       	lddpc	r8,80006498 <xTaskRemoveFromEventList+0xcc>
8000645c:	70 08       	ld.w	r8,r8[0x0]
8000645e:	70 b8       	ld.w	r8,r8[0x2c]
80006460:	10 39       	cp.w	r9,r8
80006462:	c0 53       	brcs	8000646c <xTaskRemoveFromEventList+0xa0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
80006464:	30 18       	mov	r8,1
80006466:	ef 48 ff fc 	st.w	r7[-4],r8
8000646a:	c0 48       	rjmp	80006472 <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		xReturn = pdFALSE;
8000646c:	30 08       	mov	r8,0
8000646e:	ef 48 ff fc 	st.w	r7[-4],r8
	}

	return xReturn;
80006472:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80006476:	10 9c       	mov	r12,r8
80006478:	2f dd       	sub	sp,-12
8000647a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000647e:	00 00       	add	r0,r0
80006480:	80 00       	ld.sh	r0,r0[0x0]
80006482:	4f 12       	lddpc	r2,80006644 <prvInitialiseTCBVariables+0x80>
80006484:	00 00       	add	r0,r0
80006486:	07 88       	ld.ub	r8,r3[0x0]
80006488:	00 00       	add	r0,r0
8000648a:	07 80       	ld.ub	r0,r3[0x0]
8000648c:	00 00       	add	r0,r0
8000648e:	06 64       	and	r4,r3
80006490:	80 00       	ld.sh	r0,r0[0x0]
80006492:	4d fe       	lddpc	lr,8000660c <prvInitialiseTCBVariables+0x48>
80006494:	00 00       	add	r0,r0
80006496:	07 34       	ld.ub	r4,r3++
80006498:	00 00       	add	r0,r0
8000649a:	06 60       	and	r0,r3

8000649c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
8000649c:	eb cd 40 80 	pushm	r7,lr
800064a0:	1a 97       	mov	r7,sp
800064a2:	20 1d       	sub	sp,4
800064a4:	ef 4c ff fc 	st.w	r7[-4],r12
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800064a8:	48 78       	lddpc	r8,800064c4 <vTaskSetTimeOutState+0x28>
800064aa:	70 09       	ld.w	r9,r8[0x0]
800064ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800064b0:	91 09       	st.w	r8[0x0],r9
	pxTimeOut->xTimeOnEntering = xTickCount;
800064b2:	48 68       	lddpc	r8,800064c8 <vTaskSetTimeOutState+0x2c>
800064b4:	70 09       	ld.w	r9,r8[0x0]
800064b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800064ba:	91 19       	st.w	r8[0x4],r9
}
800064bc:	2f fd       	sub	sp,-4
800064be:	e3 cd 80 80 	ldm	sp++,r7,pc
800064c2:	00 00       	add	r0,r0
800064c4:	00 00       	add	r0,r0
800064c6:	07 94       	ld.ub	r4,r3[0x1]
800064c8:	00 00       	add	r0,r0
800064ca:	07 78       	ld.ub	r8,--r3

800064cc <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800064cc:	eb cd 40 80 	pushm	r7,lr
800064d0:	1a 97       	mov	r7,sp
800064d2:	20 3d       	sub	sp,12
800064d4:	ef 4c ff f8 	st.w	r7[-8],r12
800064d8:	ef 4b ff f4 	st.w	r7[-12],r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800064dc:	f0 1f 00 25 	mcall	80006570 <xTaskCheckForTimeOut+0xa4>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800064e0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800064e4:	70 08       	ld.w	r8,r8[0x0]
800064e6:	5b f8       	cp.w	r8,-1
800064e8:	c0 51       	brne	800064f2 <xTaskCheckForTimeOut+0x26>
			{
				xReturn = pdFALSE;
800064ea:	30 08       	mov	r8,0
800064ec:	ef 48 ff fc 	st.w	r7[-4],r8
800064f0:	c3 88       	rjmp	80006560 <xTaskCheckForTimeOut+0x94>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800064f2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800064f6:	70 09       	ld.w	r9,r8[0x0]
800064f8:	49 f8       	lddpc	r8,80006574 <xTaskCheckForTimeOut+0xa8>
800064fa:	70 08       	ld.w	r8,r8[0x0]
800064fc:	10 39       	cp.w	r9,r8
800064fe:	c0 d0       	breq	80006518 <xTaskCheckForTimeOut+0x4c>
80006500:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006504:	70 19       	ld.w	r9,r8[0x4]
80006506:	49 d8       	lddpc	r8,80006578 <xTaskCheckForTimeOut+0xac>
80006508:	70 08       	ld.w	r8,r8[0x0]
8000650a:	10 39       	cp.w	r9,r8
8000650c:	e0 8b 00 06 	brhi	80006518 <xTaskCheckForTimeOut+0x4c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
80006510:	30 18       	mov	r8,1
80006512:	ef 48 ff fc 	st.w	r7[-4],r8
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80006516:	c2 58       	rjmp	80006560 <xTaskCheckForTimeOut+0x94>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006518:	49 88       	lddpc	r8,80006578 <xTaskCheckForTimeOut+0xac>
8000651a:	70 09       	ld.w	r9,r8[0x0]
8000651c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006520:	70 18       	ld.w	r8,r8[0x4]
80006522:	10 19       	sub	r9,r8
80006524:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006528:	70 08       	ld.w	r8,r8[0x0]
8000652a:	10 39       	cp.w	r9,r8
8000652c:	c1 72       	brcc	8000655a <xTaskCheckForTimeOut+0x8e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000652e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006532:	70 09       	ld.w	r9,r8[0x0]
80006534:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006538:	70 1a       	ld.w	r10,r8[0x4]
8000653a:	49 08       	lddpc	r8,80006578 <xTaskCheckForTimeOut+0xac>
8000653c:	70 08       	ld.w	r8,r8[0x0]
8000653e:	f4 08 01 08 	sub	r8,r10,r8
80006542:	10 09       	add	r9,r8
80006544:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006548:	91 09       	st.w	r8[0x0],r9
			vTaskSetTimeOutState( pxTimeOut );
8000654a:	ee fc ff f8 	ld.w	r12,r7[-8]
8000654e:	f0 1f 00 0c 	mcall	8000657c <xTaskCheckForTimeOut+0xb0>
			xReturn = pdFALSE;
80006552:	30 08       	mov	r8,0
80006554:	ef 48 ff fc 	st.w	r7[-4],r8
80006558:	c0 48       	rjmp	80006560 <xTaskCheckForTimeOut+0x94>
		}
		else
		{
			xReturn = pdTRUE;
8000655a:	30 18       	mov	r8,1
8000655c:	ef 48 ff fc 	st.w	r7[-4],r8
		}
	}
	taskEXIT_CRITICAL();
80006560:	f0 1f 00 08 	mcall	80006580 <xTaskCheckForTimeOut+0xb4>

	return xReturn;
80006564:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80006568:	10 9c       	mov	r12,r8
8000656a:	2f dd       	sub	sp,-12
8000656c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006570:	80 00       	ld.sh	r0,r0[0x0]
80006572:	51 28       	stdsp	sp[0x48],r8
80006574:	00 00       	add	r0,r0
80006576:	07 94       	ld.ub	r4,r3[0x1]
80006578:	00 00       	add	r0,r0
8000657a:	07 78       	ld.ub	r8,--r3
8000657c:	80 00       	ld.sh	r0,r0[0x0]
8000657e:	64 9c       	ld.w	r12,r2[0x24]
80006580:	80 00       	ld.sh	r0,r0[0x0]
80006582:	51 44       	stdsp	sp[0x50],r4

80006584 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
80006584:	eb cd 40 80 	pushm	r7,lr
80006588:	1a 97       	mov	r7,sp
	xMissedYield = pdTRUE;
8000658a:	48 38       	lddpc	r8,80006594 <vTaskMissedYield+0x10>
8000658c:	30 19       	mov	r9,1
8000658e:	91 09       	st.w	r8[0x0],r9
}
80006590:	e3 cd 80 80 	ldm	sp++,r7,pc
80006594:	00 00       	add	r0,r0
80006596:	07 90       	ld.ub	r0,r3[0x1]

80006598 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006598:	eb cd 40 80 	pushm	r7,lr
8000659c:	1a 97       	mov	r7,sp
8000659e:	20 1d       	sub	sp,4
800065a0:	ef 4c ff fc 	st.w	r7[-4],r12
800065a4:	c0 28       	rjmp	800065a8 <prvIdleTask+0x10>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
800065a6:	d7 03       	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
800065a8:	f0 1f 00 05 	mcall	800065bc <prvIdleTask+0x24>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800065ac:	48 58       	lddpc	r8,800065c0 <prvIdleTask+0x28>
800065ae:	70 08       	ld.w	r8,r8[0x0]
800065b0:	58 18       	cp.w	r8,1
800065b2:	fe 98 ff fa 	brls	800065a6 <prvIdleTask+0xe>
			{
				taskYIELD();
800065b6:	d7 33       	scall
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
800065b8:	cf 8b       	rjmp	800065a8 <prvIdleTask+0x10>
800065ba:	00 00       	add	r0,r0
800065bc:	80 00       	ld.sh	r0,r0[0x0]
800065be:	67 00       	ld.w	r0,r3[0x40]
800065c0:	00 00       	add	r0,r0
800065c2:	06 64       	and	r4,r3

800065c4 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
800065c4:	eb cd 40 80 	pushm	r7,lr
800065c8:	1a 97       	mov	r7,sp
800065ca:	20 5d       	sub	sp,20
800065cc:	ef 4c ff fc 	st.w	r7[-4],r12
800065d0:	ef 4b ff f8 	st.w	r7[-8],r11
800065d4:	ef 4a ff f4 	st.w	r7[-12],r10
800065d8:	ef 49 ff f0 	st.w	r7[-16],r9
800065dc:	ef 58 ff ec 	st.h	r7[-20],r8
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800065e0:	ee f9 ff f8 	ld.w	r9,r7[-8]
800065e4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800065e8:	2c c8       	sub	r8,-52
800065ea:	31 0a       	mov	r10,16
800065ec:	12 9b       	mov	r11,r9
800065ee:	10 9c       	mov	r12,r8
800065f0:	f0 1f 00 1d 	mcall	80006664 <prvInitialiseTCBVariables+0xa0>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800065f4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800065f8:	30 08       	mov	r8,0
800065fa:	f3 68 00 43 	st.b	r9[67],r8

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
800065fe:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006602:	58 78       	cp.w	r8,7
80006604:	e0 88 00 05 	brls	8000660e <prvInitialiseTCBVariables+0x4a>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
80006608:	30 78       	mov	r8,7
8000660a:	ef 48 ff f4 	st.w	r7[-12],r8
	}

	pxTCB->uxPriority = uxPriority;
8000660e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006612:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006616:	91 b9       	st.w	r8[0x2c],r9
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006618:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000661c:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006620:	f1 49 00 44 	st.w	r8[68],r9
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006624:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006628:	2f c8       	sub	r8,-4
8000662a:	10 9c       	mov	r12,r8
8000662c:	f0 1f 00 0f 	mcall	80006668 <prvInitialiseTCBVariables+0xa4>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006630:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006634:	2e 88       	sub	r8,-24
80006636:	10 9c       	mov	r12,r8
80006638:	f0 1f 00 0c 	mcall	80006668 <prvInitialiseTCBVariables+0xa4>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
8000663c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006640:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006644:	91 49       	st.w	r8[0x10],r9

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006646:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000664a:	f0 09 11 08 	rsub	r9,r8,8
8000664e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006652:	91 69       	st.w	r8[0x18],r9
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006654:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006658:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000665c:	91 99       	st.w	r8[0x24],r9
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
8000665e:	2f bd       	sub	sp,-20
80006660:	e3 cd 80 80 	ldm	sp++,r7,pc
80006664:	80 00       	ld.sh	r0,r0[0x0]
80006666:	75 d8       	ld.w	r8,r10[0x74]
80006668:	80 00       	ld.sh	r0,r0[0x0]
8000666a:	4d e4       	lddpc	r4,800067e0 <prvAddCurrentTaskToDelayedList+0x48>

8000666c <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
8000666c:	eb cd 40 80 	pushm	r7,lr
80006670:	1a 97       	mov	r7,sp
80006672:	20 1d       	sub	sp,4
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006674:	30 08       	mov	r8,0
80006676:	ef 48 ff fc 	st.w	r7[-4],r8
8000667a:	c1 38       	rjmp	800066a0 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
8000667c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006680:	12 98       	mov	r8,r9
80006682:	a3 68       	lsl	r8,0x2
80006684:	12 08       	add	r8,r9
80006686:	a3 68       	lsl	r8,0x2
80006688:	10 99       	mov	r9,r8
8000668a:	49 58       	lddpc	r8,800066dc <prvInitialiseTaskLists+0x70>
8000668c:	f2 08 00 08 	add	r8,r9,r8
80006690:	10 9c       	mov	r12,r8
80006692:	f0 1f 00 14 	mcall	800066e0 <prvInitialiseTaskLists+0x74>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006696:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000669a:	2f f8       	sub	r8,-1
8000669c:	ef 48 ff fc 	st.w	r7[-4],r8
800066a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800066a4:	58 78       	cp.w	r8,7
800066a6:	fe 98 ff eb 	brls	8000667c <prvInitialiseTaskLists+0x10>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
800066aa:	48 fc       	lddpc	r12,800066e4 <prvInitialiseTaskLists+0x78>
800066ac:	f0 1f 00 0d 	mcall	800066e0 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800066b0:	48 ec       	lddpc	r12,800066e8 <prvInitialiseTaskLists+0x7c>
800066b2:	f0 1f 00 0c 	mcall	800066e0 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xPendingReadyList );
800066b6:	48 ec       	lddpc	r12,800066ec <prvInitialiseTaskLists+0x80>
800066b8:	f0 1f 00 0a 	mcall	800066e0 <prvInitialiseTaskLists+0x74>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800066bc:	48 dc       	lddpc	r12,800066f0 <prvInitialiseTaskLists+0x84>
800066be:	f0 1f 00 09 	mcall	800066e0 <prvInitialiseTaskLists+0x74>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800066c2:	48 dc       	lddpc	r12,800066f4 <prvInitialiseTaskLists+0x88>
800066c4:	f0 1f 00 07 	mcall	800066e0 <prvInitialiseTaskLists+0x74>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800066c8:	48 c8       	lddpc	r8,800066f8 <prvInitialiseTaskLists+0x8c>
800066ca:	48 79       	lddpc	r9,800066e4 <prvInitialiseTaskLists+0x78>
800066cc:	91 09       	st.w	r8[0x0],r9
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800066ce:	48 c8       	lddpc	r8,800066fc <prvInitialiseTaskLists+0x90>
800066d0:	48 69       	lddpc	r9,800066e8 <prvInitialiseTaskLists+0x7c>
800066d2:	91 09       	st.w	r8[0x0],r9
}
800066d4:	2f fd       	sub	sp,-4
800066d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800066da:	00 00       	add	r0,r0
800066dc:	00 00       	add	r0,r0
800066de:	06 64       	and	r4,r3
800066e0:	80 00       	ld.sh	r0,r0[0x0]
800066e2:	4d 98       	lddpc	r8,80006844 <prvAllocateTCBAndStack+0x2c>
800066e4:	00 00       	add	r0,r0
800066e6:	07 04       	ld.w	r4,r3++
800066e8:	00 00       	add	r0,r0
800066ea:	07 18       	ld.sh	r8,r3++
800066ec:	00 00       	add	r0,r0
800066ee:	07 34       	ld.ub	r4,r3++
800066f0:	00 00       	add	r0,r0
800066f2:	07 48       	ld.w	r8,--r3
800066f4:	00 00       	add	r0,r0
800066f6:	07 60       	ld.uh	r0,--r3
800066f8:	00 00       	add	r0,r0
800066fa:	07 2c       	ld.uh	r12,r3++
800066fc:	00 00       	add	r0,r0
800066fe:	07 30       	ld.ub	r0,r3++

80006700 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
80006700:	eb cd 40 80 	pushm	r7,lr
80006704:	1a 97       	mov	r7,sp
80006706:	20 2d       	sub	sp,8
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006708:	49 b8       	lddpc	r8,80006774 <prvCheckTasksWaitingTermination+0x74>
8000670a:	70 08       	ld.w	r8,r8[0x0]
8000670c:	58 08       	cp.w	r8,0
8000670e:	c2 f0       	breq	8000676c <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
80006710:	f0 1f 00 1a 	mcall	80006778 <prvCheckTasksWaitingTermination+0x78>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006714:	49 a8       	lddpc	r8,8000677c <prvCheckTasksWaitingTermination+0x7c>
80006716:	70 08       	ld.w	r8,r8[0x0]
80006718:	58 08       	cp.w	r8,0
8000671a:	5f 08       	sreq	r8
8000671c:	ef 48 ff f8 	st.w	r7[-8],r8
			xTaskResumeAll();
80006720:	f0 1f 00 18 	mcall	80006780 <prvCheckTasksWaitingTermination+0x80>

			if( xListIsEmpty == pdFALSE )
80006724:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006728:	58 08       	cp.w	r8,0
8000672a:	c2 11       	brne	8000676c <prvCheckTasksWaitingTermination+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
8000672c:	f0 1f 00 16 	mcall	80006784 <prvCheckTasksWaitingTermination+0x84>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006730:	49 38       	lddpc	r8,8000677c <prvCheckTasksWaitingTermination+0x7c>
80006732:	2f 88       	sub	r8,-8
80006734:	70 18       	ld.w	r8,r8[0x4]
80006736:	70 38       	ld.w	r8,r8[0xc]
80006738:	ef 48 ff fc 	st.w	r7[-4],r8
					vListRemove( &( pxTCB->xGenericListItem ) );
8000673c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006740:	2f c8       	sub	r8,-4
80006742:	10 9c       	mov	r12,r8
80006744:	f0 1f 00 11 	mcall	80006788 <prvCheckTasksWaitingTermination+0x88>
					--uxCurrentNumberOfTasks;
80006748:	49 18       	lddpc	r8,8000678c <prvCheckTasksWaitingTermination+0x8c>
8000674a:	70 08       	ld.w	r8,r8[0x0]
8000674c:	f0 c9 00 01 	sub	r9,r8,1
80006750:	48 f8       	lddpc	r8,8000678c <prvCheckTasksWaitingTermination+0x8c>
80006752:	91 09       	st.w	r8[0x0],r9
					--uxTasksDeleted;
80006754:	48 88       	lddpc	r8,80006774 <prvCheckTasksWaitingTermination+0x74>
80006756:	70 08       	ld.w	r8,r8[0x0]
80006758:	f0 c9 00 01 	sub	r9,r8,1
8000675c:	48 68       	lddpc	r8,80006774 <prvCheckTasksWaitingTermination+0x74>
8000675e:	91 09       	st.w	r8[0x0],r9
				}
				taskEXIT_CRITICAL();
80006760:	f0 1f 00 0c 	mcall	80006790 <prvCheckTasksWaitingTermination+0x90>

				prvDeleteTCB( pxTCB );
80006764:	ee fc ff fc 	ld.w	r12,r7[-4]
80006768:	f0 1f 00 0b 	mcall	80006794 <prvCheckTasksWaitingTermination+0x94>
			}
		}
	}
	#endif
}
8000676c:	2f ed       	sub	sp,-8
8000676e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006772:	00 00       	add	r0,r0
80006774:	00 00       	add	r0,r0
80006776:	07 5c       	ld.sh	r12,--r3
80006778:	80 00       	ld.sh	r0,r0[0x0]
8000677a:	5f f8       	sral	r8
8000677c:	00 00       	add	r0,r0
8000677e:	07 48       	ld.w	r8,--r3
80006780:	80 00       	ld.sh	r0,r0[0x0]
80006782:	60 14       	ld.w	r4,r0[0x4]
80006784:	80 00       	ld.sh	r0,r0[0x0]
80006786:	51 28       	stdsp	sp[0x48],r8
80006788:	80 00       	ld.sh	r0,r0[0x0]
8000678a:	4f 12       	lddpc	r2,8000694c <vTaskPriorityInherit+0x54>
8000678c:	00 00       	add	r0,r0
8000678e:	07 74       	ld.ub	r4,--r3
80006790:	80 00       	ld.sh	r0,r0[0x0]
80006792:	51 44       	stdsp	sp[0x50],r4
80006794:	80 00       	ld.sh	r0,r0[0x0]
80006796:	68 ac       	ld.w	r12,r4[0x28]

80006798 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006798:	eb cd 40 80 	pushm	r7,lr
8000679c:	1a 97       	mov	r7,sp
8000679e:	20 1d       	sub	sp,4
800067a0:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800067a4:	49 78       	lddpc	r8,80006800 <prvAddCurrentTaskToDelayedList+0x68>
800067a6:	70 08       	ld.w	r8,r8[0x0]
800067a8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800067ac:	91 19       	st.w	r8[0x4],r9

	if( xTimeToWake < xTickCount )
800067ae:	49 68       	lddpc	r8,80006804 <prvAddCurrentTaskToDelayedList+0x6c>
800067b0:	70 08       	ld.w	r8,r8[0x0]
800067b2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800067b6:	10 39       	cp.w	r9,r8
800067b8:	c0 c2       	brcc	800067d0 <prvAddCurrentTaskToDelayedList+0x38>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800067ba:	49 28       	lddpc	r8,80006800 <prvAddCurrentTaskToDelayedList+0x68>
800067bc:	70 08       	ld.w	r8,r8[0x0]
800067be:	f0 c9 ff fc 	sub	r9,r8,-4
800067c2:	49 28       	lddpc	r8,80006808 <prvAddCurrentTaskToDelayedList+0x70>
800067c4:	70 08       	ld.w	r8,r8[0x0]
800067c6:	12 9b       	mov	r11,r9
800067c8:	10 9c       	mov	r12,r8
800067ca:	f0 1f 00 11 	mcall	8000680c <prvAddCurrentTaskToDelayedList+0x74>
800067ce:	c1 58       	rjmp	800067f8 <prvAddCurrentTaskToDelayedList+0x60>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800067d0:	48 c8       	lddpc	r8,80006800 <prvAddCurrentTaskToDelayedList+0x68>
800067d2:	70 08       	ld.w	r8,r8[0x0]
800067d4:	f0 c9 ff fc 	sub	r9,r8,-4
800067d8:	48 e8       	lddpc	r8,80006810 <prvAddCurrentTaskToDelayedList+0x78>
800067da:	70 08       	ld.w	r8,r8[0x0]
800067dc:	12 9b       	mov	r11,r9
800067de:	10 9c       	mov	r12,r8
800067e0:	f0 1f 00 0b 	mcall	8000680c <prvAddCurrentTaskToDelayedList+0x74>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800067e4:	48 c8       	lddpc	r8,80006814 <prvAddCurrentTaskToDelayedList+0x7c>
800067e6:	70 08       	ld.w	r8,r8[0x0]
800067e8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800067ec:	10 39       	cp.w	r9,r8
800067ee:	c0 52       	brcc	800067f8 <prvAddCurrentTaskToDelayedList+0x60>
		{
			xNextTaskUnblockTime = xTimeToWake;
800067f0:	48 98       	lddpc	r8,80006814 <prvAddCurrentTaskToDelayedList+0x7c>
800067f2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800067f6:	91 09       	st.w	r8[0x0],r9
		}
	}
}
800067f8:	2f fd       	sub	sp,-4
800067fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800067fe:	00 00       	add	r0,r0
80006800:	00 00       	add	r0,r0
80006802:	06 60       	and	r0,r3
80006804:	00 00       	add	r0,r0
80006806:	07 78       	ld.ub	r8,--r3
80006808:	00 00       	add	r0,r0
8000680a:	07 30       	ld.ub	r0,r3++
8000680c:	80 00       	ld.sh	r0,r0[0x0]
8000680e:	4e 70       	lddpc	r0,800069a8 <vTaskPriorityInherit+0xb0>
80006810:	00 00       	add	r0,r0
80006812:	07 2c       	ld.uh	r12,r3++
80006814:	00 00       	add	r0,r0
80006816:	00 24       	rsub	r4,r0

80006818 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
80006818:	eb cd 40 80 	pushm	r7,lr
8000681c:	1a 97       	mov	r7,sp
8000681e:	20 3d       	sub	sp,12
80006820:	18 98       	mov	r8,r12
80006822:	ef 4b ff f4 	st.w	r7[-12],r11
80006826:	ef 58 ff f8 	st.h	r7[-8],r8
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
8000682a:	34 8c       	mov	r12,72
8000682c:	f0 1f 00 1d 	mcall	800068a0 <prvAllocateTCBAndStack+0x88>
80006830:	18 98       	mov	r8,r12
80006832:	ef 48 ff fc 	st.w	r7[-4],r8

	if( pxNewTCB != NULL )
80006836:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000683a:	58 08       	cp.w	r8,0
8000683c:	c2 c0       	breq	80006894 <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
8000683e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006842:	58 08       	cp.w	r8,0
80006844:	c0 91       	brne	80006856 <prvAllocateTCBAndStack+0x3e>
80006846:	ef 18 ff f8 	ld.uh	r8,r7[-8]
8000684a:	a3 68       	lsl	r8,0x2
8000684c:	10 9c       	mov	r12,r8
8000684e:	f0 1f 00 15 	mcall	800068a0 <prvAllocateTCBAndStack+0x88>
80006852:	18 98       	mov	r8,r12
80006854:	c0 38       	rjmp	8000685a <prvAllocateTCBAndStack+0x42>
80006856:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000685a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000685e:	93 c8       	st.w	r9[0x30],r8

		if( pxNewTCB->pxStack == NULL )
80006860:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006864:	70 c8       	ld.w	r8,r8[0x30]
80006866:	58 08       	cp.w	r8,0
80006868:	c0 91       	brne	8000687a <prvAllocateTCBAndStack+0x62>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
8000686a:	ee fc ff fc 	ld.w	r12,r7[-4]
8000686e:	f0 1f 00 0e 	mcall	800068a4 <prvAllocateTCBAndStack+0x8c>
			pxNewTCB = NULL;
80006872:	30 08       	mov	r8,0
80006874:	ef 48 ff fc 	st.w	r7[-4],r8
80006878:	c0 e8       	rjmp	80006894 <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
8000687a:	ef 18 ff f8 	ld.uh	r8,r7[-8]
8000687e:	f0 09 15 02 	lsl	r9,r8,0x2
80006882:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006886:	70 c8       	ld.w	r8,r8[0x30]
80006888:	12 9a       	mov	r10,r9
8000688a:	e0 6b 00 a5 	mov	r11,165
8000688e:	10 9c       	mov	r12,r8
80006890:	f0 1f 00 06 	mcall	800068a8 <prvAllocateTCBAndStack+0x90>
		}
	}

	return pxNewTCB;
80006894:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80006898:	10 9c       	mov	r12,r8
8000689a:	2f dd       	sub	sp,-12
8000689c:	e3 cd 80 80 	ldm	sp++,r7,pc
800068a0:	80 00       	ld.sh	r0,r0[0x0]
800068a2:	54 d0       	stdsp	sp[0x134],r0
800068a4:	80 00       	ld.sh	r0,r0[0x0]
800068a6:	55 0c       	stdsp	sp[0x140],r12
800068a8:	80 00       	ld.sh	r0,r0[0x0]
800068aa:	72 ac       	ld.w	r12,r9[0x28]

800068ac <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
800068ac:	eb cd 40 80 	pushm	r7,lr
800068b0:	1a 97       	mov	r7,sp
800068b2:	20 1d       	sub	sp,4
800068b4:	ef 4c ff fc 	st.w	r7[-4],r12
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800068b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800068bc:	70 c8       	ld.w	r8,r8[0x30]
800068be:	10 9c       	mov	r12,r8
800068c0:	f0 1f 00 05 	mcall	800068d4 <prvDeleteTCB+0x28>
		vPortFree( pxTCB );
800068c4:	ee fc ff fc 	ld.w	r12,r7[-4]
800068c8:	f0 1f 00 03 	mcall	800068d4 <prvDeleteTCB+0x28>
	}
800068cc:	2f fd       	sub	sp,-4
800068ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800068d2:	00 00       	add	r0,r0
800068d4:	80 00       	ld.sh	r0,r0[0x0]
800068d6:	55 0c       	stdsp	sp[0x140],r12

800068d8 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
800068d8:	eb cd 40 80 	pushm	r7,lr
800068dc:	1a 97       	mov	r7,sp
800068de:	20 1d       	sub	sp,4
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800068e0:	48 58       	lddpc	r8,800068f4 <xTaskGetCurrentTaskHandle+0x1c>
800068e2:	70 08       	ld.w	r8,r8[0x0]
800068e4:	ef 48 ff fc 	st.w	r7[-4],r8

		return xReturn;
800068e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
	}
800068ec:	10 9c       	mov	r12,r8
800068ee:	2f fd       	sub	sp,-4
800068f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800068f4:	00 00       	add	r0,r0
800068f6:	06 60       	and	r0,r3

800068f8 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800068f8:	eb cd 40 80 	pushm	r7,lr
800068fc:	1a 97       	mov	r7,sp
800068fe:	20 2d       	sub	sp,8
80006900:	ef 4c ff f8 	st.w	r7[-8],r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006904:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006908:	ef 48 ff fc 	st.w	r7[-4],r8

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000690c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006910:	70 b9       	ld.w	r9,r8[0x2c]
80006912:	4a a8       	lddpc	r8,800069b8 <vTaskPriorityInherit+0xc0>
80006914:	70 08       	ld.w	r8,r8[0x0]
80006916:	70 b8       	ld.w	r8,r8[0x2c]
80006918:	10 39       	cp.w	r9,r8
8000691a:	c4 c2       	brcc	800069b2 <vTaskPriorityInherit+0xba>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000691c:	4a 78       	lddpc	r8,800069b8 <vTaskPriorityInherit+0xc0>
8000691e:	70 08       	ld.w	r8,r8[0x0]
80006920:	70 b8       	ld.w	r8,r8[0x2c]
80006922:	f0 09 11 08 	rsub	r9,r8,8
80006926:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000692a:	91 69       	st.w	r8[0x18],r9

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000692c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006930:	70 5a       	ld.w	r10,r8[0x14]
80006932:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006936:	70 b9       	ld.w	r9,r8[0x2c]
80006938:	12 98       	mov	r8,r9
8000693a:	a3 68       	lsl	r8,0x2
8000693c:	12 08       	add	r8,r9
8000693e:	a3 68       	lsl	r8,0x2
80006940:	10 99       	mov	r9,r8
80006942:	49 f8       	lddpc	r8,800069bc <vTaskPriorityInherit+0xc4>
80006944:	f2 08 00 08 	add	r8,r9,r8
80006948:	10 3a       	cp.w	r10,r8
8000694a:	c2 e1       	brne	800069a6 <vTaskPriorityInherit+0xae>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000694c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006950:	2f c8       	sub	r8,-4
80006952:	10 9c       	mov	r12,r8
80006954:	f0 1f 00 1b 	mcall	800069c0 <vTaskPriorityInherit+0xc8>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006958:	49 88       	lddpc	r8,800069b8 <vTaskPriorityInherit+0xc0>
8000695a:	70 08       	ld.w	r8,r8[0x0]
8000695c:	70 b9       	ld.w	r9,r8[0x2c]
8000695e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006962:	91 b9       	st.w	r8[0x2c],r9
				prvAddTaskToReadyQueue( pxTCB );
80006964:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006968:	70 b9       	ld.w	r9,r8[0x2c]
8000696a:	49 78       	lddpc	r8,800069c4 <vTaskPriorityInherit+0xcc>
8000696c:	70 08       	ld.w	r8,r8[0x0]
8000696e:	10 39       	cp.w	r9,r8
80006970:	e0 88 00 07 	brls	8000697e <vTaskPriorityInherit+0x86>
80006974:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006978:	70 b9       	ld.w	r9,r8[0x2c]
8000697a:	49 38       	lddpc	r8,800069c4 <vTaskPriorityInherit+0xcc>
8000697c:	91 09       	st.w	r8[0x0],r9
8000697e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006982:	f0 ca ff fc 	sub	r10,r8,-4
80006986:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000698a:	70 b9       	ld.w	r9,r8[0x2c]
8000698c:	12 98       	mov	r8,r9
8000698e:	a3 68       	lsl	r8,0x2
80006990:	12 08       	add	r8,r9
80006992:	a3 68       	lsl	r8,0x2
80006994:	10 99       	mov	r9,r8
80006996:	48 a8       	lddpc	r8,800069bc <vTaskPriorityInherit+0xc4>
80006998:	f2 08 00 08 	add	r8,r9,r8
8000699c:	14 9b       	mov	r11,r10
8000699e:	10 9c       	mov	r12,r8
800069a0:	f0 1f 00 0a 	mcall	800069c8 <vTaskPriorityInherit+0xd0>
800069a4:	c0 78       	rjmp	800069b2 <vTaskPriorityInherit+0xba>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800069a6:	48 58       	lddpc	r8,800069b8 <vTaskPriorityInherit+0xc0>
800069a8:	70 08       	ld.w	r8,r8[0x0]
800069aa:	70 b9       	ld.w	r9,r8[0x2c]
800069ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800069b0:	91 b9       	st.w	r8[0x2c],r9
			}
		}
	}
800069b2:	2f ed       	sub	sp,-8
800069b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800069b8:	00 00       	add	r0,r0
800069ba:	06 60       	and	r0,r3
800069bc:	00 00       	add	r0,r0
800069be:	06 64       	and	r4,r3
800069c0:	80 00       	ld.sh	r0,r0[0x0]
800069c2:	4f 12       	lddpc	r2,80006b84 <__avr32_udiv64+0x10c>
800069c4:	00 00       	add	r0,r0
800069c6:	07 80       	ld.ub	r0,r3[0x0]
800069c8:	80 00       	ld.sh	r0,r0[0x0]
800069ca:	4d fe       	lddpc	lr,80006b44 <__avr32_udiv64+0xcc>

800069cc <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800069cc:	eb cd 40 80 	pushm	r7,lr
800069d0:	1a 97       	mov	r7,sp
800069d2:	20 2d       	sub	sp,8
800069d4:	ef 4c ff f8 	st.w	r7[-8],r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800069d8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800069dc:	ef 48 ff fc 	st.w	r7[-4],r8

		if( pxMutexHolder != NULL )
800069e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800069e4:	58 08       	cp.w	r8,0
800069e6:	c3 d0       	breq	80006a60 <vTaskPriorityDisinherit+0x94>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800069e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800069ec:	70 b9       	ld.w	r9,r8[0x2c]
800069ee:	ee f8 ff fc 	ld.w	r8,r7[-4]
800069f2:	71 18       	ld.w	r8,r8[0x44]
800069f4:	10 39       	cp.w	r9,r8
800069f6:	c3 50       	breq	80006a60 <vTaskPriorityDisinherit+0x94>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800069f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800069fc:	2f c8       	sub	r8,-4
800069fe:	10 9c       	mov	r12,r8
80006a00:	f0 1f 00 1a 	mcall	80006a68 <vTaskPriorityDisinherit+0x9c>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006a04:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006a08:	71 19       	ld.w	r9,r8[0x44]
80006a0a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006a0e:	91 b9       	st.w	r8[0x2c],r9
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006a10:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006a14:	70 b8       	ld.w	r8,r8[0x2c]
80006a16:	f0 09 11 08 	rsub	r9,r8,8
80006a1a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006a1e:	91 69       	st.w	r8[0x18],r9
				prvAddTaskToReadyQueue( pxTCB );
80006a20:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006a24:	70 b9       	ld.w	r9,r8[0x2c]
80006a26:	49 28       	lddpc	r8,80006a6c <vTaskPriorityDisinherit+0xa0>
80006a28:	70 08       	ld.w	r8,r8[0x0]
80006a2a:	10 39       	cp.w	r9,r8
80006a2c:	e0 88 00 07 	brls	80006a3a <vTaskPriorityDisinherit+0x6e>
80006a30:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006a34:	70 b9       	ld.w	r9,r8[0x2c]
80006a36:	48 e8       	lddpc	r8,80006a6c <vTaskPriorityDisinherit+0xa0>
80006a38:	91 09       	st.w	r8[0x0],r9
80006a3a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006a3e:	f0 ca ff fc 	sub	r10,r8,-4
80006a42:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006a46:	70 b9       	ld.w	r9,r8[0x2c]
80006a48:	12 98       	mov	r8,r9
80006a4a:	a3 68       	lsl	r8,0x2
80006a4c:	12 08       	add	r8,r9
80006a4e:	a3 68       	lsl	r8,0x2
80006a50:	10 99       	mov	r9,r8
80006a52:	48 88       	lddpc	r8,80006a70 <vTaskPriorityDisinherit+0xa4>
80006a54:	f2 08 00 08 	add	r8,r9,r8
80006a58:	14 9b       	mov	r11,r10
80006a5a:	10 9c       	mov	r12,r8
80006a5c:	f0 1f 00 06 	mcall	80006a74 <vTaskPriorityDisinherit+0xa8>
			}
		}
	}
80006a60:	2f ed       	sub	sp,-8
80006a62:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a66:	00 00       	add	r0,r0
80006a68:	80 00       	ld.sh	r0,r0[0x0]
80006a6a:	4f 12       	lddpc	r2,80006c2c <__avr32_udiv64+0x1b4>
80006a6c:	00 00       	add	r0,r0
80006a6e:	07 80       	ld.ub	r0,r3[0x0]
80006a70:	00 00       	add	r0,r0
80006a72:	06 64       	and	r4,r3
80006a74:	80 00       	ld.sh	r0,r0[0x0]
80006a76:	4d fe       	lddpc	lr,80006bf0 <__avr32_udiv64+0x178>

80006a78 <__avr32_udiv64>:
80006a78:	d4 31       	pushm	r0-r7,lr
80006a7a:	1a 97       	mov	r7,sp
80006a7c:	20 3d       	sub	sp,12
80006a7e:	10 9c       	mov	r12,r8
80006a80:	12 9e       	mov	lr,r9
80006a82:	14 93       	mov	r3,r10
80006a84:	58 09       	cp.w	r9,0
80006a86:	e0 81 00 bd 	brne	80006c00 <__avr32_udiv64+0x188>
80006a8a:	16 38       	cp.w	r8,r11
80006a8c:	e0 88 00 40 	brls	80006b0c <__avr32_udiv64+0x94>
80006a90:	f0 08 12 00 	clz	r8,r8
80006a94:	c0 d0       	breq	80006aae <__avr32_udiv64+0x36>
80006a96:	f6 08 09 4b 	lsl	r11,r11,r8
80006a9a:	f0 09 11 20 	rsub	r9,r8,32
80006a9e:	f8 08 09 4c 	lsl	r12,r12,r8
80006aa2:	f4 09 0a 49 	lsr	r9,r10,r9
80006aa6:	f4 08 09 43 	lsl	r3,r10,r8
80006aaa:	f3 eb 10 0b 	or	r11,r9,r11
80006aae:	f8 0e 16 10 	lsr	lr,r12,0x10
80006ab2:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80006ab6:	f6 0e 0d 00 	divu	r0,r11,lr
80006aba:	e6 0b 16 10 	lsr	r11,r3,0x10
80006abe:	00 99       	mov	r9,r0
80006ac0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80006ac4:	e0 0a 02 48 	mul	r8,r0,r10
80006ac8:	10 3b       	cp.w	r11,r8
80006aca:	c0 a2       	brcc	80006ade <__avr32_udiv64+0x66>
80006acc:	20 19       	sub	r9,1
80006ace:	18 0b       	add	r11,r12
80006ad0:	18 3b       	cp.w	r11,r12
80006ad2:	c0 63       	brcs	80006ade <__avr32_udiv64+0x66>
80006ad4:	10 3b       	cp.w	r11,r8
80006ad6:	f7 b9 03 01 	sublo	r9,1
80006ada:	f7 dc e3 0b 	addcs	r11,r11,r12
80006ade:	f6 08 01 01 	sub	r1,r11,r8
80006ae2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80006ae6:	e2 0e 0d 00 	divu	r0,r1,lr
80006aea:	e7 e1 11 03 	or	r3,r3,r1<<0x10
80006aee:	00 98       	mov	r8,r0
80006af0:	e0 0a 02 4a 	mul	r10,r0,r10
80006af4:	14 33       	cp.w	r3,r10
80006af6:	c0 82       	brcc	80006b06 <__avr32_udiv64+0x8e>
80006af8:	20 18       	sub	r8,1
80006afa:	18 03       	add	r3,r12
80006afc:	18 33       	cp.w	r3,r12
80006afe:	c0 43       	brcs	80006b06 <__avr32_udiv64+0x8e>
80006b00:	14 33       	cp.w	r3,r10
80006b02:	f7 b8 03 01 	sublo	r8,1
80006b06:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80006b0a:	cd f8       	rjmp	80006cc8 <__avr32_udiv64+0x250>
80006b0c:	58 08       	cp.w	r8,0
80006b0e:	c0 51       	brne	80006b18 <__avr32_udiv64+0xa0>
80006b10:	30 19       	mov	r9,1
80006b12:	f2 08 0d 08 	divu	r8,r9,r8
80006b16:	10 9c       	mov	r12,r8
80006b18:	f8 06 12 00 	clz	r6,r12
80006b1c:	c0 41       	brne	80006b24 <__avr32_udiv64+0xac>
80006b1e:	18 1b       	sub	r11,r12
80006b20:	30 19       	mov	r9,1
80006b22:	c4 08       	rjmp	80006ba2 <__avr32_udiv64+0x12a>
80006b24:	ec 01 11 20 	rsub	r1,r6,32
80006b28:	f4 01 0a 49 	lsr	r9,r10,r1
80006b2c:	f8 06 09 4c 	lsl	r12,r12,r6
80006b30:	f6 06 09 48 	lsl	r8,r11,r6
80006b34:	f6 01 0a 41 	lsr	r1,r11,r1
80006b38:	f3 e8 10 08 	or	r8,r9,r8
80006b3c:	f8 03 16 10 	lsr	r3,r12,0x10
80006b40:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
80006b44:	e2 03 0d 00 	divu	r0,r1,r3
80006b48:	f0 0b 16 10 	lsr	r11,r8,0x10
80006b4c:	00 9e       	mov	lr,r0
80006b4e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80006b52:	e0 05 02 49 	mul	r9,r0,r5
80006b56:	12 3b       	cp.w	r11,r9
80006b58:	c0 a2       	brcc	80006b6c <__avr32_udiv64+0xf4>
80006b5a:	20 1e       	sub	lr,1
80006b5c:	18 0b       	add	r11,r12
80006b5e:	18 3b       	cp.w	r11,r12
80006b60:	c0 63       	brcs	80006b6c <__avr32_udiv64+0xf4>
80006b62:	12 3b       	cp.w	r11,r9
80006b64:	f7 be 03 01 	sublo	lr,1
80006b68:	f7 dc e3 0b 	addcs	r11,r11,r12
80006b6c:	12 1b       	sub	r11,r9
80006b6e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80006b72:	f6 03 0d 02 	divu	r2,r11,r3
80006b76:	f1 e3 11 08 	or	r8,r8,r3<<0x10
80006b7a:	04 99       	mov	r9,r2
80006b7c:	e4 05 02 4b 	mul	r11,r2,r5
80006b80:	16 38       	cp.w	r8,r11
80006b82:	c0 a2       	brcc	80006b96 <__avr32_udiv64+0x11e>
80006b84:	20 19       	sub	r9,1
80006b86:	18 08       	add	r8,r12
80006b88:	18 38       	cp.w	r8,r12
80006b8a:	c0 63       	brcs	80006b96 <__avr32_udiv64+0x11e>
80006b8c:	16 38       	cp.w	r8,r11
80006b8e:	f7 b9 03 01 	sublo	r9,1
80006b92:	f1 dc e3 08 	addcs	r8,r8,r12
80006b96:	f4 06 09 43 	lsl	r3,r10,r6
80006b9a:	f0 0b 01 0b 	sub	r11,r8,r11
80006b9e:	f3 ee 11 09 	or	r9,r9,lr<<0x10
80006ba2:	f8 06 16 10 	lsr	r6,r12,0x10
80006ba6:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
80006baa:	f6 06 0d 00 	divu	r0,r11,r6
80006bae:	e6 0b 16 10 	lsr	r11,r3,0x10
80006bb2:	00 9a       	mov	r10,r0
80006bb4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80006bb8:	e0 0e 02 48 	mul	r8,r0,lr
80006bbc:	10 3b       	cp.w	r11,r8
80006bbe:	c0 a2       	brcc	80006bd2 <__avr32_udiv64+0x15a>
80006bc0:	20 1a       	sub	r10,1
80006bc2:	18 0b       	add	r11,r12
80006bc4:	18 3b       	cp.w	r11,r12
80006bc6:	c0 63       	brcs	80006bd2 <__avr32_udiv64+0x15a>
80006bc8:	10 3b       	cp.w	r11,r8
80006bca:	f7 ba 03 01 	sublo	r10,1
80006bce:	f7 dc e3 0b 	addcs	r11,r11,r12
80006bd2:	f6 08 01 01 	sub	r1,r11,r8
80006bd6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80006bda:	e2 06 0d 00 	divu	r0,r1,r6
80006bde:	e7 e1 11 03 	or	r3,r3,r1<<0x10
80006be2:	00 98       	mov	r8,r0
80006be4:	e0 0e 02 4b 	mul	r11,r0,lr
80006be8:	16 33       	cp.w	r3,r11
80006bea:	c0 82       	brcc	80006bfa <__avr32_udiv64+0x182>
80006bec:	20 18       	sub	r8,1
80006bee:	18 03       	add	r3,r12
80006bf0:	18 33       	cp.w	r3,r12
80006bf2:	c0 43       	brcs	80006bfa <__avr32_udiv64+0x182>
80006bf4:	16 33       	cp.w	r3,r11
80006bf6:	f7 b8 03 01 	sublo	r8,1
80006bfa:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80006bfe:	c6 98       	rjmp	80006cd0 <__avr32_udiv64+0x258>
80006c00:	16 39       	cp.w	r9,r11
80006c02:	e0 8b 00 65 	brhi	80006ccc <__avr32_udiv64+0x254>
80006c06:	f2 09 12 00 	clz	r9,r9
80006c0a:	c0 b1       	brne	80006c20 <__avr32_udiv64+0x1a8>
80006c0c:	10 3a       	cp.w	r10,r8
80006c0e:	5f 2a       	srhs	r10
80006c10:	1c 3b       	cp.w	r11,lr
80006c12:	5f b8       	srhi	r8
80006c14:	10 4a       	or	r10,r8
80006c16:	f2 0a 18 00 	cp.b	r10,r9
80006c1a:	c5 90       	breq	80006ccc <__avr32_udiv64+0x254>
80006c1c:	30 18       	mov	r8,1
80006c1e:	c5 98       	rjmp	80006cd0 <__avr32_udiv64+0x258>
80006c20:	f0 09 09 46 	lsl	r6,r8,r9
80006c24:	f2 03 11 20 	rsub	r3,r9,32
80006c28:	fc 09 09 4e 	lsl	lr,lr,r9
80006c2c:	f0 03 0a 48 	lsr	r8,r8,r3
80006c30:	f6 09 09 4c 	lsl	r12,r11,r9
80006c34:	f4 03 0a 42 	lsr	r2,r10,r3
80006c38:	ef 46 ff f4 	st.w	r7[-12],r6
80006c3c:	f6 03 0a 43 	lsr	r3,r11,r3
80006c40:	18 42       	or	r2,r12
80006c42:	f1 ee 10 0c 	or	r12,r8,lr
80006c46:	f8 01 16 10 	lsr	r1,r12,0x10
80006c4a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80006c4e:	e6 01 0d 04 	divu	r4,r3,r1
80006c52:	e4 03 16 10 	lsr	r3,r2,0x10
80006c56:	08 9e       	mov	lr,r4
80006c58:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80006c5c:	e8 06 02 48 	mul	r8,r4,r6
80006c60:	10 33       	cp.w	r3,r8
80006c62:	c0 a2       	brcc	80006c76 <__avr32_udiv64+0x1fe>
80006c64:	20 1e       	sub	lr,1
80006c66:	18 03       	add	r3,r12
80006c68:	18 33       	cp.w	r3,r12
80006c6a:	c0 63       	brcs	80006c76 <__avr32_udiv64+0x1fe>
80006c6c:	10 33       	cp.w	r3,r8
80006c6e:	f7 be 03 01 	sublo	lr,1
80006c72:	e7 dc e3 03 	addcs	r3,r3,r12
80006c76:	10 13       	sub	r3,r8
80006c78:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
80006c7c:	e6 01 0d 00 	divu	r0,r3,r1
80006c80:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80006c84:	00 98       	mov	r8,r0
80006c86:	e0 06 02 46 	mul	r6,r0,r6
80006c8a:	0c 3b       	cp.w	r11,r6
80006c8c:	c0 a2       	brcc	80006ca0 <__avr32_udiv64+0x228>
80006c8e:	20 18       	sub	r8,1
80006c90:	18 0b       	add	r11,r12
80006c92:	18 3b       	cp.w	r11,r12
80006c94:	c0 63       	brcs	80006ca0 <__avr32_udiv64+0x228>
80006c96:	0c 3b       	cp.w	r11,r6
80006c98:	f7 dc e3 0b 	addcs	r11,r11,r12
80006c9c:	f7 b8 03 01 	sublo	r8,1
80006ca0:	f1 ee 11 08 	or	r8,r8,lr<<0x10
80006ca4:	ee f4 ff f4 	ld.w	r4,r7[-12]
80006ca8:	0c 1b       	sub	r11,r6
80006caa:	f0 04 06 42 	mulu.d	r2,r8,r4
80006cae:	06 95       	mov	r5,r3
80006cb0:	16 35       	cp.w	r5,r11
80006cb2:	e0 8b 00 0a 	brhi	80006cc6 <__avr32_udiv64+0x24e>
80006cb6:	5f 0b       	sreq	r11
80006cb8:	f4 09 09 49 	lsl	r9,r10,r9
80006cbc:	12 32       	cp.w	r2,r9
80006cbe:	5f b9       	srhi	r9
80006cc0:	f7 e9 00 09 	and	r9,r11,r9
80006cc4:	c0 60       	breq	80006cd0 <__avr32_udiv64+0x258>
80006cc6:	20 18       	sub	r8,1
80006cc8:	30 09       	mov	r9,0
80006cca:	c0 38       	rjmp	80006cd0 <__avr32_udiv64+0x258>
80006ccc:	30 09       	mov	r9,0
80006cce:	12 98       	mov	r8,r9
80006cd0:	10 9a       	mov	r10,r8
80006cd2:	12 93       	mov	r3,r9
80006cd4:	10 92       	mov	r2,r8
80006cd6:	12 9b       	mov	r11,r9
80006cd8:	2f dd       	sub	sp,-12
80006cda:	d8 32       	popm	r0-r7,pc

80006cdc <atexit>:
80006cdc:	d4 01       	pushm	lr
80006cde:	30 09       	mov	r9,0
80006ce0:	18 9b       	mov	r11,r12
80006ce2:	12 9a       	mov	r10,r9
80006ce4:	12 9c       	mov	r12,r9
80006ce6:	e0 a0 16 af 	rcall	80009a44 <__register_exitproc>
80006cea:	d8 02       	popm	pc

80006cec <exit>:
80006cec:	d4 21       	pushm	r4-r7,lr
80006cee:	30 0b       	mov	r11,0
80006cf0:	18 97       	mov	r7,r12
80006cf2:	e0 a0 16 fb 	rcall	80009ae8 <__call_exitprocs>
80006cf6:	fe c8 a3 42 	sub	r8,pc,-23742
80006cfa:	70 0c       	ld.w	r12,r8[0x0]
80006cfc:	78 a8       	ld.w	r8,r12[0x28]
80006cfe:	58 08       	cp.w	r8,0
80006d00:	c0 20       	breq	80006d04 <exit+0x18>
80006d02:	5d 18       	icall	r8
80006d04:	0e 9c       	mov	r12,r7
80006d06:	e0 a0 04 7e 	rcall	80007602 <_exit>
80006d0a:	d7 03       	nop

80006d0c <free>:
80006d0c:	d4 01       	pushm	lr
80006d0e:	e0 68 01 18 	mov	r8,280
80006d12:	18 9b       	mov	r11,r12
80006d14:	70 0c       	ld.w	r12,r8[0x0]
80006d16:	e0 a0 1f 45 	rcall	8000aba0 <_free_r>
80006d1a:	d8 02       	popm	pc

80006d1c <malloc>:
80006d1c:	d4 01       	pushm	lr
80006d1e:	e0 68 01 18 	mov	r8,280
80006d22:	18 9b       	mov	r11,r12
80006d24:	70 0c       	ld.w	r12,r8[0x0]
80006d26:	c0 3c       	rcall	80006d2c <_malloc_r>
80006d28:	d8 02       	popm	pc
80006d2a:	d7 03       	nop

80006d2c <_malloc_r>:
80006d2c:	d4 31       	pushm	r0-r7,lr
80006d2e:	f6 c8 ff f5 	sub	r8,r11,-11
80006d32:	18 95       	mov	r5,r12
80006d34:	10 97       	mov	r7,r8
80006d36:	e0 17 ff f8 	andl	r7,0xfff8
80006d3a:	59 68       	cp.w	r8,22
80006d3c:	f9 b7 08 10 	movls	r7,16
80006d40:	16 37       	cp.w	r7,r11
80006d42:	5f 38       	srlo	r8
80006d44:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006d48:	c0 50       	breq	80006d52 <_malloc_r+0x26>
80006d4a:	30 c8       	mov	r8,12
80006d4c:	99 38       	st.w	r12[0xc],r8
80006d4e:	e0 8f 01 fa 	bral	80007142 <_malloc_r+0x416>
80006d52:	fe b0 f1 41 	rcall	80004fd4 <__malloc_lock>
80006d56:	e0 47 01 f7 	cp.w	r7,503
80006d5a:	e0 8b 00 1d 	brhi	80006d94 <_malloc_r+0x68>
80006d5e:	ee 03 16 03 	lsr	r3,r7,0x3
80006d62:	e0 68 01 1c 	mov	r8,284
80006d66:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006d6a:	70 36       	ld.w	r6,r8[0xc]
80006d6c:	10 36       	cp.w	r6,r8
80006d6e:	c0 61       	brne	80006d7a <_malloc_r+0x4e>
80006d70:	ec c8 ff f8 	sub	r8,r6,-8
80006d74:	70 36       	ld.w	r6,r8[0xc]
80006d76:	10 36       	cp.w	r6,r8
80006d78:	c0 c0       	breq	80006d90 <_malloc_r+0x64>
80006d7a:	6c 18       	ld.w	r8,r6[0x4]
80006d7c:	e0 18 ff fc 	andl	r8,0xfffc
80006d80:	6c 3a       	ld.w	r10,r6[0xc]
80006d82:	ec 08 00 09 	add	r9,r6,r8
80006d86:	0a 9c       	mov	r12,r5
80006d88:	6c 28       	ld.w	r8,r6[0x8]
80006d8a:	95 28       	st.w	r10[0x8],r8
80006d8c:	91 3a       	st.w	r8[0xc],r10
80006d8e:	c4 78       	rjmp	80006e1c <_malloc_r+0xf0>
80006d90:	2f e3       	sub	r3,-2
80006d92:	c4 d8       	rjmp	80006e2c <_malloc_r+0x100>
80006d94:	ee 03 16 09 	lsr	r3,r7,0x9
80006d98:	c0 41       	brne	80006da0 <_malloc_r+0x74>
80006d9a:	ee 03 16 03 	lsr	r3,r7,0x3
80006d9e:	c2 68       	rjmp	80006dea <_malloc_r+0xbe>
80006da0:	58 43       	cp.w	r3,4
80006da2:	e0 8b 00 06 	brhi	80006dae <_malloc_r+0x82>
80006da6:	ee 03 16 06 	lsr	r3,r7,0x6
80006daa:	2c 83       	sub	r3,-56
80006dac:	c1 f8       	rjmp	80006dea <_malloc_r+0xbe>
80006dae:	59 43       	cp.w	r3,20
80006db0:	e0 8b 00 04 	brhi	80006db8 <_malloc_r+0x8c>
80006db4:	2a 53       	sub	r3,-91
80006db6:	c1 a8       	rjmp	80006dea <_malloc_r+0xbe>
80006db8:	e0 43 00 54 	cp.w	r3,84
80006dbc:	e0 8b 00 06 	brhi	80006dc8 <_malloc_r+0x9c>
80006dc0:	ee 03 16 0c 	lsr	r3,r7,0xc
80006dc4:	29 23       	sub	r3,-110
80006dc6:	c1 28       	rjmp	80006dea <_malloc_r+0xbe>
80006dc8:	e0 43 01 54 	cp.w	r3,340
80006dcc:	e0 8b 00 06 	brhi	80006dd8 <_malloc_r+0xac>
80006dd0:	ee 03 16 0f 	lsr	r3,r7,0xf
80006dd4:	28 93       	sub	r3,-119
80006dd6:	c0 a8       	rjmp	80006dea <_malloc_r+0xbe>
80006dd8:	e0 43 05 54 	cp.w	r3,1364
80006ddc:	e0 88 00 04 	brls	80006de4 <_malloc_r+0xb8>
80006de0:	37 e3       	mov	r3,126
80006de2:	c0 48       	rjmp	80006dea <_malloc_r+0xbe>
80006de4:	ee 03 16 12 	lsr	r3,r7,0x12
80006de8:	28 43       	sub	r3,-124
80006dea:	e0 6a 01 1c 	mov	r10,284
80006dee:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006df2:	74 36       	ld.w	r6,r10[0xc]
80006df4:	c1 98       	rjmp	80006e26 <_malloc_r+0xfa>
80006df6:	6c 19       	ld.w	r9,r6[0x4]
80006df8:	e0 19 ff fc 	andl	r9,0xfffc
80006dfc:	f2 07 01 0b 	sub	r11,r9,r7
80006e00:	58 fb       	cp.w	r11,15
80006e02:	e0 8a 00 04 	brle	80006e0a <_malloc_r+0xde>
80006e06:	20 13       	sub	r3,1
80006e08:	c1 18       	rjmp	80006e2a <_malloc_r+0xfe>
80006e0a:	6c 38       	ld.w	r8,r6[0xc]
80006e0c:	58 0b       	cp.w	r11,0
80006e0e:	c0 b5       	brlt	80006e24 <_malloc_r+0xf8>
80006e10:	6c 2a       	ld.w	r10,r6[0x8]
80006e12:	ec 09 00 09 	add	r9,r6,r9
80006e16:	0a 9c       	mov	r12,r5
80006e18:	91 2a       	st.w	r8[0x8],r10
80006e1a:	95 38       	st.w	r10[0xc],r8
80006e1c:	72 18       	ld.w	r8,r9[0x4]
80006e1e:	a1 a8       	sbr	r8,0x0
80006e20:	93 18       	st.w	r9[0x4],r8
80006e22:	cb c8       	rjmp	80006f9a <_malloc_r+0x26e>
80006e24:	10 96       	mov	r6,r8
80006e26:	14 36       	cp.w	r6,r10
80006e28:	ce 71       	brne	80006df6 <_malloc_r+0xca>
80006e2a:	2f f3       	sub	r3,-1
80006e2c:	e0 6a 01 1c 	mov	r10,284
80006e30:	f4 cc ff f8 	sub	r12,r10,-8
80006e34:	78 26       	ld.w	r6,r12[0x8]
80006e36:	18 36       	cp.w	r6,r12
80006e38:	c6 c0       	breq	80006f10 <_malloc_r+0x1e4>
80006e3a:	6c 19       	ld.w	r9,r6[0x4]
80006e3c:	e0 19 ff fc 	andl	r9,0xfffc
80006e40:	f2 07 01 08 	sub	r8,r9,r7
80006e44:	58 f8       	cp.w	r8,15
80006e46:	e0 89 00 8f 	brgt	80006f64 <_malloc_r+0x238>
80006e4a:	99 3c       	st.w	r12[0xc],r12
80006e4c:	99 2c       	st.w	r12[0x8],r12
80006e4e:	58 08       	cp.w	r8,0
80006e50:	c0 55       	brlt	80006e5a <_malloc_r+0x12e>
80006e52:	ec 09 00 09 	add	r9,r6,r9
80006e56:	0a 9c       	mov	r12,r5
80006e58:	ce 2b       	rjmp	80006e1c <_malloc_r+0xf0>
80006e5a:	e0 49 01 ff 	cp.w	r9,511
80006e5e:	e0 8b 00 13 	brhi	80006e84 <_malloc_r+0x158>
80006e62:	a3 99       	lsr	r9,0x3
80006e64:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006e68:	70 2b       	ld.w	r11,r8[0x8]
80006e6a:	8d 38       	st.w	r6[0xc],r8
80006e6c:	8d 2b       	st.w	r6[0x8],r11
80006e6e:	97 36       	st.w	r11[0xc],r6
80006e70:	91 26       	st.w	r8[0x8],r6
80006e72:	a3 49       	asr	r9,0x2
80006e74:	74 18       	ld.w	r8,r10[0x4]
80006e76:	30 1b       	mov	r11,1
80006e78:	f6 09 09 49 	lsl	r9,r11,r9
80006e7c:	f1 e9 10 09 	or	r9,r8,r9
80006e80:	95 19       	st.w	r10[0x4],r9
80006e82:	c4 78       	rjmp	80006f10 <_malloc_r+0x1e4>
80006e84:	f2 0a 16 09 	lsr	r10,r9,0x9
80006e88:	58 4a       	cp.w	r10,4
80006e8a:	e0 8b 00 07 	brhi	80006e98 <_malloc_r+0x16c>
80006e8e:	f2 0a 16 06 	lsr	r10,r9,0x6
80006e92:	2c 8a       	sub	r10,-56
80006e94:	c2 08       	rjmp	80006ed4 <_malloc_r+0x1a8>
80006e96:	d7 03       	nop
80006e98:	59 4a       	cp.w	r10,20
80006e9a:	e0 8b 00 04 	brhi	80006ea2 <_malloc_r+0x176>
80006e9e:	2a 5a       	sub	r10,-91
80006ea0:	c1 a8       	rjmp	80006ed4 <_malloc_r+0x1a8>
80006ea2:	e0 4a 00 54 	cp.w	r10,84
80006ea6:	e0 8b 00 06 	brhi	80006eb2 <_malloc_r+0x186>
80006eaa:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006eae:	29 2a       	sub	r10,-110
80006eb0:	c1 28       	rjmp	80006ed4 <_malloc_r+0x1a8>
80006eb2:	e0 4a 01 54 	cp.w	r10,340
80006eb6:	e0 8b 00 06 	brhi	80006ec2 <_malloc_r+0x196>
80006eba:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006ebe:	28 9a       	sub	r10,-119
80006ec0:	c0 a8       	rjmp	80006ed4 <_malloc_r+0x1a8>
80006ec2:	e0 4a 05 54 	cp.w	r10,1364
80006ec6:	e0 88 00 04 	brls	80006ece <_malloc_r+0x1a2>
80006eca:	37 ea       	mov	r10,126
80006ecc:	c0 48       	rjmp	80006ed4 <_malloc_r+0x1a8>
80006ece:	f2 0a 16 12 	lsr	r10,r9,0x12
80006ed2:	28 4a       	sub	r10,-124
80006ed4:	e0 6b 01 1c 	mov	r11,284
80006ed8:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006edc:	68 28       	ld.w	r8,r4[0x8]
80006ede:	08 38       	cp.w	r8,r4
80006ee0:	c0 e1       	brne	80006efc <_malloc_r+0x1d0>
80006ee2:	76 19       	ld.w	r9,r11[0x4]
80006ee4:	a3 4a       	asr	r10,0x2
80006ee6:	30 1e       	mov	lr,1
80006ee8:	fc 0a 09 4a 	lsl	r10,lr,r10
80006eec:	f3 ea 10 0a 	or	r10,r9,r10
80006ef0:	10 99       	mov	r9,r8
80006ef2:	97 1a       	st.w	r11[0x4],r10
80006ef4:	c0 a8       	rjmp	80006f08 <_malloc_r+0x1dc>
80006ef6:	70 28       	ld.w	r8,r8[0x8]
80006ef8:	08 38       	cp.w	r8,r4
80006efa:	c0 60       	breq	80006f06 <_malloc_r+0x1da>
80006efc:	70 1a       	ld.w	r10,r8[0x4]
80006efe:	e0 1a ff fc 	andl	r10,0xfffc
80006f02:	14 39       	cp.w	r9,r10
80006f04:	cf 93       	brcs	80006ef6 <_malloc_r+0x1ca>
80006f06:	70 39       	ld.w	r9,r8[0xc]
80006f08:	8d 39       	st.w	r6[0xc],r9
80006f0a:	8d 28       	st.w	r6[0x8],r8
80006f0c:	91 36       	st.w	r8[0xc],r6
80006f0e:	93 26       	st.w	r9[0x8],r6
80006f10:	e6 08 14 02 	asr	r8,r3,0x2
80006f14:	30 1b       	mov	r11,1
80006f16:	e0 64 01 1c 	mov	r4,284
80006f1a:	f6 08 09 4b 	lsl	r11,r11,r8
80006f1e:	68 18       	ld.w	r8,r4[0x4]
80006f20:	10 3b       	cp.w	r11,r8
80006f22:	e0 8b 00 6b 	brhi	80006ff8 <_malloc_r+0x2cc>
80006f26:	f7 e8 00 09 	and	r9,r11,r8
80006f2a:	c0 b1       	brne	80006f40 <_malloc_r+0x214>
80006f2c:	e0 13 ff fc 	andl	r3,0xfffc
80006f30:	a1 7b       	lsl	r11,0x1
80006f32:	2f c3       	sub	r3,-4
80006f34:	c0 38       	rjmp	80006f3a <_malloc_r+0x20e>
80006f36:	2f c3       	sub	r3,-4
80006f38:	a1 7b       	lsl	r11,0x1
80006f3a:	f7 e8 00 09 	and	r9,r11,r8
80006f3e:	cf c0       	breq	80006f36 <_malloc_r+0x20a>
80006f40:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006f44:	06 92       	mov	r2,r3
80006f46:	1c 91       	mov	r1,lr
80006f48:	62 36       	ld.w	r6,r1[0xc]
80006f4a:	c2 e8       	rjmp	80006fa6 <_malloc_r+0x27a>
80006f4c:	6c 1a       	ld.w	r10,r6[0x4]
80006f4e:	e0 1a ff fc 	andl	r10,0xfffc
80006f52:	f4 07 01 08 	sub	r8,r10,r7
80006f56:	58 f8       	cp.w	r8,15
80006f58:	e0 8a 00 15 	brle	80006f82 <_malloc_r+0x256>
80006f5c:	6c 3a       	ld.w	r10,r6[0xc]
80006f5e:	6c 29       	ld.w	r9,r6[0x8]
80006f60:	95 29       	st.w	r10[0x8],r9
80006f62:	93 3a       	st.w	r9[0xc],r10
80006f64:	0e 99       	mov	r9,r7
80006f66:	ec 07 00 07 	add	r7,r6,r7
80006f6a:	a1 a9       	sbr	r9,0x0
80006f6c:	99 37       	st.w	r12[0xc],r7
80006f6e:	99 27       	st.w	r12[0x8],r7
80006f70:	8d 19       	st.w	r6[0x4],r9
80006f72:	ee 08 09 08 	st.w	r7[r8],r8
80006f76:	8f 2c       	st.w	r7[0x8],r12
80006f78:	8f 3c       	st.w	r7[0xc],r12
80006f7a:	a1 a8       	sbr	r8,0x0
80006f7c:	0a 9c       	mov	r12,r5
80006f7e:	8f 18       	st.w	r7[0x4],r8
80006f80:	c0 d8       	rjmp	80006f9a <_malloc_r+0x26e>
80006f82:	6c 39       	ld.w	r9,r6[0xc]
80006f84:	58 08       	cp.w	r8,0
80006f86:	c0 f5       	brlt	80006fa4 <_malloc_r+0x278>
80006f88:	ec 0a 00 0a 	add	r10,r6,r10
80006f8c:	74 18       	ld.w	r8,r10[0x4]
80006f8e:	a1 a8       	sbr	r8,0x0
80006f90:	0a 9c       	mov	r12,r5
80006f92:	95 18       	st.w	r10[0x4],r8
80006f94:	6c 28       	ld.w	r8,r6[0x8]
80006f96:	93 28       	st.w	r9[0x8],r8
80006f98:	91 39       	st.w	r8[0xc],r9
80006f9a:	fe b0 f0 2b 	rcall	80004ff0 <__malloc_unlock>
80006f9e:	ec cc ff f8 	sub	r12,r6,-8
80006fa2:	d8 32       	popm	r0-r7,pc
80006fa4:	12 96       	mov	r6,r9
80006fa6:	02 36       	cp.w	r6,r1
80006fa8:	cd 21       	brne	80006f4c <_malloc_r+0x220>
80006faa:	2f f2       	sub	r2,-1
80006fac:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006fb0:	c0 30       	breq	80006fb6 <_malloc_r+0x28a>
80006fb2:	2f 81       	sub	r1,-8
80006fb4:	cc ab       	rjmp	80006f48 <_malloc_r+0x21c>
80006fb6:	1c 98       	mov	r8,lr
80006fb8:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006fbc:	c0 81       	brne	80006fcc <_malloc_r+0x2a0>
80006fbe:	68 19       	ld.w	r9,r4[0x4]
80006fc0:	f6 08 11 ff 	rsub	r8,r11,-1
80006fc4:	f3 e8 00 08 	and	r8,r9,r8
80006fc8:	89 18       	st.w	r4[0x4],r8
80006fca:	c0 78       	rjmp	80006fd8 <_malloc_r+0x2ac>
80006fcc:	f0 c9 00 08 	sub	r9,r8,8
80006fd0:	20 13       	sub	r3,1
80006fd2:	70 08       	ld.w	r8,r8[0x0]
80006fd4:	12 38       	cp.w	r8,r9
80006fd6:	cf 10       	breq	80006fb8 <_malloc_r+0x28c>
80006fd8:	a1 7b       	lsl	r11,0x1
80006fda:	68 18       	ld.w	r8,r4[0x4]
80006fdc:	10 3b       	cp.w	r11,r8
80006fde:	e0 8b 00 0d 	brhi	80006ff8 <_malloc_r+0x2cc>
80006fe2:	58 0b       	cp.w	r11,0
80006fe4:	c0 a0       	breq	80006ff8 <_malloc_r+0x2cc>
80006fe6:	04 93       	mov	r3,r2
80006fe8:	c0 38       	rjmp	80006fee <_malloc_r+0x2c2>
80006fea:	2f c3       	sub	r3,-4
80006fec:	a1 7b       	lsl	r11,0x1
80006fee:	f7 e8 00 09 	and	r9,r11,r8
80006ff2:	ca 71       	brne	80006f40 <_malloc_r+0x214>
80006ff4:	cf bb       	rjmp	80006fea <_malloc_r+0x2be>
80006ff6:	d7 03       	nop
80006ff8:	68 23       	ld.w	r3,r4[0x8]
80006ffa:	66 12       	ld.w	r2,r3[0x4]
80006ffc:	e0 12 ff fc 	andl	r2,0xfffc
80007000:	0e 32       	cp.w	r2,r7
80007002:	5f 39       	srlo	r9
80007004:	e4 07 01 08 	sub	r8,r2,r7
80007008:	58 f8       	cp.w	r8,15
8000700a:	5f aa       	srle	r10
8000700c:	f5 e9 10 09 	or	r9,r10,r9
80007010:	e0 80 00 9a 	breq	80007144 <_malloc_r+0x418>
80007014:	e0 68 07 a4 	mov	r8,1956
80007018:	70 01       	ld.w	r1,r8[0x0]
8000701a:	e0 68 05 28 	mov	r8,1320
8000701e:	2f 01       	sub	r1,-16
80007020:	70 08       	ld.w	r8,r8[0x0]
80007022:	0e 01       	add	r1,r7
80007024:	5b f8       	cp.w	r8,-1
80007026:	c0 40       	breq	8000702e <_malloc_r+0x302>
80007028:	28 11       	sub	r1,-127
8000702a:	e0 11 ff 80 	andl	r1,0xff80
8000702e:	02 9b       	mov	r11,r1
80007030:	0a 9c       	mov	r12,r5
80007032:	e0 a0 02 a5 	rcall	8000757c <_sbrk_r>
80007036:	18 96       	mov	r6,r12
80007038:	5b fc       	cp.w	r12,-1
8000703a:	c7 50       	breq	80007124 <_malloc_r+0x3f8>
8000703c:	e6 02 00 08 	add	r8,r3,r2
80007040:	10 3c       	cp.w	r12,r8
80007042:	c0 32       	brcc	80007048 <_malloc_r+0x31c>
80007044:	08 33       	cp.w	r3,r4
80007046:	c6 f1       	brne	80007124 <_malloc_r+0x3f8>
80007048:	e0 6a 07 a8 	mov	r10,1960
8000704c:	74 09       	ld.w	r9,r10[0x0]
8000704e:	e2 09 00 09 	add	r9,r1,r9
80007052:	95 09       	st.w	r10[0x0],r9
80007054:	10 36       	cp.w	r6,r8
80007056:	c0 a1       	brne	8000706a <_malloc_r+0x33e>
80007058:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000705c:	c0 71       	brne	8000706a <_malloc_r+0x33e>
8000705e:	e2 02 00 02 	add	r2,r1,r2
80007062:	68 28       	ld.w	r8,r4[0x8]
80007064:	a1 a2       	sbr	r2,0x0
80007066:	91 12       	st.w	r8[0x4],r2
80007068:	c4 f8       	rjmp	80007106 <_malloc_r+0x3da>
8000706a:	e0 6a 05 28 	mov	r10,1320
8000706e:	74 0b       	ld.w	r11,r10[0x0]
80007070:	5b fb       	cp.w	r11,-1
80007072:	c0 31       	brne	80007078 <_malloc_r+0x34c>
80007074:	95 06       	st.w	r10[0x0],r6
80007076:	c0 78       	rjmp	80007084 <_malloc_r+0x358>
80007078:	ec 09 00 09 	add	r9,r6,r9
8000707c:	e0 6a 07 a8 	mov	r10,1960
80007080:	10 19       	sub	r9,r8
80007082:	95 09       	st.w	r10[0x0],r9
80007084:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80007088:	f0 09 11 08 	rsub	r9,r8,8
8000708c:	58 08       	cp.w	r8,0
8000708e:	f2 08 17 10 	movne	r8,r9
80007092:	ed d8 e1 06 	addne	r6,r6,r8
80007096:	28 08       	sub	r8,-128
80007098:	ec 01 00 01 	add	r1,r6,r1
8000709c:	0a 9c       	mov	r12,r5
8000709e:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800070a2:	f0 01 01 01 	sub	r1,r8,r1
800070a6:	02 9b       	mov	r11,r1
800070a8:	e0 a0 02 6a 	rcall	8000757c <_sbrk_r>
800070ac:	e0 68 07 a8 	mov	r8,1960
800070b0:	5b fc       	cp.w	r12,-1
800070b2:	ec 0c 17 00 	moveq	r12,r6
800070b6:	f9 b1 00 00 	moveq	r1,0
800070ba:	70 09       	ld.w	r9,r8[0x0]
800070bc:	0c 1c       	sub	r12,r6
800070be:	89 26       	st.w	r4[0x8],r6
800070c0:	02 0c       	add	r12,r1
800070c2:	12 01       	add	r1,r9
800070c4:	a1 ac       	sbr	r12,0x0
800070c6:	91 01       	st.w	r8[0x0],r1
800070c8:	8d 1c       	st.w	r6[0x4],r12
800070ca:	08 33       	cp.w	r3,r4
800070cc:	c1 d0       	breq	80007106 <_malloc_r+0x3da>
800070ce:	58 f2       	cp.w	r2,15
800070d0:	e0 8b 00 05 	brhi	800070da <_malloc_r+0x3ae>
800070d4:	30 18       	mov	r8,1
800070d6:	8d 18       	st.w	r6[0x4],r8
800070d8:	c2 68       	rjmp	80007124 <_malloc_r+0x3f8>
800070da:	30 59       	mov	r9,5
800070dc:	20 c2       	sub	r2,12
800070de:	e0 12 ff f8 	andl	r2,0xfff8
800070e2:	e6 02 00 08 	add	r8,r3,r2
800070e6:	91 29       	st.w	r8[0x8],r9
800070e8:	91 19       	st.w	r8[0x4],r9
800070ea:	66 18       	ld.w	r8,r3[0x4]
800070ec:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800070f0:	e5 e8 10 08 	or	r8,r2,r8
800070f4:	87 18       	st.w	r3[0x4],r8
800070f6:	58 f2       	cp.w	r2,15
800070f8:	e0 88 00 07 	brls	80007106 <_malloc_r+0x3da>
800070fc:	e6 cb ff f8 	sub	r11,r3,-8
80007100:	0a 9c       	mov	r12,r5
80007102:	e0 a0 1d 4f 	rcall	8000aba0 <_free_r>
80007106:	e0 69 07 a0 	mov	r9,1952
8000710a:	72 0a       	ld.w	r10,r9[0x0]
8000710c:	e0 68 07 a8 	mov	r8,1960
80007110:	70 08       	ld.w	r8,r8[0x0]
80007112:	14 38       	cp.w	r8,r10
80007114:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007118:	e0 69 07 9c 	mov	r9,1948
8000711c:	72 0a       	ld.w	r10,r9[0x0]
8000711e:	14 38       	cp.w	r8,r10
80007120:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007124:	68 28       	ld.w	r8,r4[0x8]
80007126:	70 18       	ld.w	r8,r8[0x4]
80007128:	e0 18 ff fc 	andl	r8,0xfffc
8000712c:	0e 38       	cp.w	r8,r7
8000712e:	5f 39       	srlo	r9
80007130:	0e 18       	sub	r8,r7
80007132:	58 f8       	cp.w	r8,15
80007134:	5f aa       	srle	r10
80007136:	f5 e9 10 09 	or	r9,r10,r9
8000713a:	c0 50       	breq	80007144 <_malloc_r+0x418>
8000713c:	0a 9c       	mov	r12,r5
8000713e:	fe b0 ef 59 	rcall	80004ff0 <__malloc_unlock>
80007142:	d8 3a       	popm	r0-r7,pc,r12=0
80007144:	68 26       	ld.w	r6,r4[0x8]
80007146:	a1 a8       	sbr	r8,0x0
80007148:	0e 99       	mov	r9,r7
8000714a:	a1 a9       	sbr	r9,0x0
8000714c:	8d 19       	st.w	r6[0x4],r9
8000714e:	ec 07 00 07 	add	r7,r6,r7
80007152:	0a 9c       	mov	r12,r5
80007154:	89 27       	st.w	r4[0x8],r7
80007156:	8f 18       	st.w	r7[0x4],r8
80007158:	fe b0 ef 4c 	rcall	80004ff0 <__malloc_unlock>
8000715c:	ec cc ff f8 	sub	r12,r6,-8
80007160:	d8 32       	popm	r0-r7,pc
80007162:	d7 03       	nop

80007164 <memcpy>:
80007164:	58 8a       	cp.w	r10,8
80007166:	c2 f5       	brlt	800071c4 <memcpy+0x60>
80007168:	f9 eb 10 09 	or	r9,r12,r11
8000716c:	e2 19 00 03 	andl	r9,0x3,COH
80007170:	e0 81 00 97 	brne	8000729e <memcpy+0x13a>
80007174:	e0 4a 00 20 	cp.w	r10,32
80007178:	c3 b4       	brge	800071ee <memcpy+0x8a>
8000717a:	f4 08 14 02 	asr	r8,r10,0x2
8000717e:	f0 09 11 08 	rsub	r9,r8,8
80007182:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80007186:	76 69       	ld.w	r9,r11[0x18]
80007188:	99 69       	st.w	r12[0x18],r9
8000718a:	76 59       	ld.w	r9,r11[0x14]
8000718c:	99 59       	st.w	r12[0x14],r9
8000718e:	76 49       	ld.w	r9,r11[0x10]
80007190:	99 49       	st.w	r12[0x10],r9
80007192:	76 39       	ld.w	r9,r11[0xc]
80007194:	99 39       	st.w	r12[0xc],r9
80007196:	76 29       	ld.w	r9,r11[0x8]
80007198:	99 29       	st.w	r12[0x8],r9
8000719a:	76 19       	ld.w	r9,r11[0x4]
8000719c:	99 19       	st.w	r12[0x4],r9
8000719e:	76 09       	ld.w	r9,r11[0x0]
800071a0:	99 09       	st.w	r12[0x0],r9
800071a2:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800071a6:	f8 08 00 28 	add	r8,r12,r8<<0x2
800071aa:	e0 1a 00 03 	andl	r10,0x3
800071ae:	f4 0a 11 04 	rsub	r10,r10,4
800071b2:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800071b6:	17 a9       	ld.ub	r9,r11[0x2]
800071b8:	b0 a9       	st.b	r8[0x2],r9
800071ba:	17 99       	ld.ub	r9,r11[0x1]
800071bc:	b0 99       	st.b	r8[0x1],r9
800071be:	17 89       	ld.ub	r9,r11[0x0]
800071c0:	b0 89       	st.b	r8[0x0],r9
800071c2:	5e fc       	retal	r12
800071c4:	f4 0a 11 09 	rsub	r10,r10,9
800071c8:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800071cc:	17 f9       	ld.ub	r9,r11[0x7]
800071ce:	b8 f9       	st.b	r12[0x7],r9
800071d0:	17 e9       	ld.ub	r9,r11[0x6]
800071d2:	b8 e9       	st.b	r12[0x6],r9
800071d4:	17 d9       	ld.ub	r9,r11[0x5]
800071d6:	b8 d9       	st.b	r12[0x5],r9
800071d8:	17 c9       	ld.ub	r9,r11[0x4]
800071da:	b8 c9       	st.b	r12[0x4],r9
800071dc:	17 b9       	ld.ub	r9,r11[0x3]
800071de:	b8 b9       	st.b	r12[0x3],r9
800071e0:	17 a9       	ld.ub	r9,r11[0x2]
800071e2:	b8 a9       	st.b	r12[0x2],r9
800071e4:	17 99       	ld.ub	r9,r11[0x1]
800071e6:	b8 99       	st.b	r12[0x1],r9
800071e8:	17 89       	ld.ub	r9,r11[0x0]
800071ea:	b8 89       	st.b	r12[0x0],r9
800071ec:	5e fc       	retal	r12
800071ee:	eb cd 40 c0 	pushm	r6-r7,lr
800071f2:	18 99       	mov	r9,r12
800071f4:	22 0a       	sub	r10,32
800071f6:	b7 07       	ld.d	r6,r11++
800071f8:	b3 26       	st.d	r9++,r6
800071fa:	b7 07       	ld.d	r6,r11++
800071fc:	b3 26       	st.d	r9++,r6
800071fe:	b7 07       	ld.d	r6,r11++
80007200:	b3 26       	st.d	r9++,r6
80007202:	b7 07       	ld.d	r6,r11++
80007204:	b3 26       	st.d	r9++,r6
80007206:	22 0a       	sub	r10,32
80007208:	cf 74       	brge	800071f6 <memcpy+0x92>
8000720a:	2f 0a       	sub	r10,-16
8000720c:	c0 65       	brlt	80007218 <memcpy+0xb4>
8000720e:	b7 07       	ld.d	r6,r11++
80007210:	b3 26       	st.d	r9++,r6
80007212:	b7 07       	ld.d	r6,r11++
80007214:	b3 26       	st.d	r9++,r6
80007216:	21 0a       	sub	r10,16
80007218:	5c 3a       	neg	r10
8000721a:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000721e:	d7 03       	nop
80007220:	d7 03       	nop
80007222:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007226:	f3 66 00 0e 	st.b	r9[14],r6
8000722a:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000722e:	f3 66 00 0d 	st.b	r9[13],r6
80007232:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007236:	f3 66 00 0c 	st.b	r9[12],r6
8000723a:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000723e:	f3 66 00 0b 	st.b	r9[11],r6
80007242:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007246:	f3 66 00 0a 	st.b	r9[10],r6
8000724a:	f7 36 00 09 	ld.ub	r6,r11[9]
8000724e:	f3 66 00 09 	st.b	r9[9],r6
80007252:	f7 36 00 08 	ld.ub	r6,r11[8]
80007256:	f3 66 00 08 	st.b	r9[8],r6
8000725a:	f7 36 00 07 	ld.ub	r6,r11[7]
8000725e:	f3 66 00 07 	st.b	r9[7],r6
80007262:	f7 36 00 06 	ld.ub	r6,r11[6]
80007266:	f3 66 00 06 	st.b	r9[6],r6
8000726a:	f7 36 00 05 	ld.ub	r6,r11[5]
8000726e:	f3 66 00 05 	st.b	r9[5],r6
80007272:	f7 36 00 04 	ld.ub	r6,r11[4]
80007276:	f3 66 00 04 	st.b	r9[4],r6
8000727a:	f7 36 00 03 	ld.ub	r6,r11[3]
8000727e:	f3 66 00 03 	st.b	r9[3],r6
80007282:	f7 36 00 02 	ld.ub	r6,r11[2]
80007286:	f3 66 00 02 	st.b	r9[2],r6
8000728a:	f7 36 00 01 	ld.ub	r6,r11[1]
8000728e:	f3 66 00 01 	st.b	r9[1],r6
80007292:	f7 36 00 00 	ld.ub	r6,r11[0]
80007296:	f3 66 00 00 	st.b	r9[0],r6
8000729a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000729e:	20 1a       	sub	r10,1
800072a0:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800072a4:	f8 0a 0b 09 	st.b	r12[r10],r9
800072a8:	cf b1       	brne	8000729e <memcpy+0x13a>
800072aa:	5e fc       	retal	r12

800072ac <memset>:
800072ac:	18 98       	mov	r8,r12
800072ae:	c0 38       	rjmp	800072b4 <memset+0x8>
800072b0:	10 cb       	st.b	r8++,r11
800072b2:	20 1a       	sub	r10,1
800072b4:	58 0a       	cp.w	r10,0
800072b6:	cf d1       	brne	800072b0 <memset+0x4>
800072b8:	5e fc       	retal	r12
800072ba:	d7 03       	nop

800072bc <_realloc_r>:
800072bc:	d4 31       	pushm	r0-r7,lr
800072be:	20 1d       	sub	sp,4
800072c0:	16 94       	mov	r4,r11
800072c2:	18 92       	mov	r2,r12
800072c4:	14 9b       	mov	r11,r10
800072c6:	58 04       	cp.w	r4,0
800072c8:	c0 51       	brne	800072d2 <_realloc_r+0x16>
800072ca:	fe b0 fd 31 	rcall	80006d2c <_malloc_r>
800072ce:	18 95       	mov	r5,r12
800072d0:	c5 39       	rjmp	80007576 <_realloc_r+0x2ba>
800072d2:	50 0a       	stdsp	sp[0x0],r10
800072d4:	fe b0 ee 80 	rcall	80004fd4 <__malloc_lock>
800072d8:	40 0b       	lddsp	r11,sp[0x0]
800072da:	f6 c8 ff f5 	sub	r8,r11,-11
800072de:	e8 c1 00 08 	sub	r1,r4,8
800072e2:	10 96       	mov	r6,r8
800072e4:	62 1c       	ld.w	r12,r1[0x4]
800072e6:	e0 16 ff f8 	andl	r6,0xfff8
800072ea:	59 68       	cp.w	r8,22
800072ec:	f9 b6 08 10 	movls	r6,16
800072f0:	16 36       	cp.w	r6,r11
800072f2:	5f 38       	srlo	r8
800072f4:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800072f8:	c0 50       	breq	80007302 <_realloc_r+0x46>
800072fa:	30 c8       	mov	r8,12
800072fc:	30 05       	mov	r5,0
800072fe:	85 38       	st.w	r2[0xc],r8
80007300:	c3 b9       	rjmp	80007576 <_realloc_r+0x2ba>
80007302:	18 90       	mov	r0,r12
80007304:	e0 10 ff fc 	andl	r0,0xfffc
80007308:	0c 30       	cp.w	r0,r6
8000730a:	e0 84 01 0b 	brge	80007520 <_realloc_r+0x264>
8000730e:	e0 68 01 1c 	mov	r8,284
80007312:	e2 00 00 09 	add	r9,r1,r0
80007316:	70 25       	ld.w	r5,r8[0x8]
80007318:	0a 39       	cp.w	r9,r5
8000731a:	c0 90       	breq	8000732c <_realloc_r+0x70>
8000731c:	72 1a       	ld.w	r10,r9[0x4]
8000731e:	a1 ca       	cbr	r10,0x0
80007320:	f2 0a 00 0a 	add	r10,r9,r10
80007324:	74 1a       	ld.w	r10,r10[0x4]
80007326:	ed ba 00 00 	bld	r10,0x0
8000732a:	c2 20       	breq	8000736e <_realloc_r+0xb2>
8000732c:	72 1a       	ld.w	r10,r9[0x4]
8000732e:	e0 1a ff fc 	andl	r10,0xfffc
80007332:	f4 00 00 03 	add	r3,r10,r0
80007336:	0a 39       	cp.w	r9,r5
80007338:	c1 31       	brne	8000735e <_realloc_r+0xa2>
8000733a:	ec c7 ff f0 	sub	r7,r6,-16
8000733e:	0e 33       	cp.w	r3,r7
80007340:	c1 95       	brlt	80007372 <_realloc_r+0xb6>
80007342:	e2 06 00 09 	add	r9,r1,r6
80007346:	0c 13       	sub	r3,r6
80007348:	a1 a3       	sbr	r3,0x0
8000734a:	93 13       	st.w	r9[0x4],r3
8000734c:	91 29       	st.w	r8[0x8],r9
8000734e:	04 9c       	mov	r12,r2
80007350:	62 18       	ld.w	r8,r1[0x4]
80007352:	08 95       	mov	r5,r4
80007354:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007358:	10 46       	or	r6,r8
8000735a:	83 16       	st.w	r1[0x4],r6
8000735c:	c0 b9       	rjmp	80007572 <_realloc_r+0x2b6>
8000735e:	0c 33       	cp.w	r3,r6
80007360:	c0 95       	brlt	80007372 <_realloc_r+0xb6>
80007362:	72 28       	ld.w	r8,r9[0x8]
80007364:	02 97       	mov	r7,r1
80007366:	72 39       	ld.w	r9,r9[0xc]
80007368:	93 28       	st.w	r9[0x8],r8
8000736a:	91 39       	st.w	r8[0xc],r9
8000736c:	cd c8       	rjmp	80007524 <_realloc_r+0x268>
8000736e:	30 0a       	mov	r10,0
80007370:	14 99       	mov	r9,r10
80007372:	ed bc 00 00 	bld	r12,0x0
80007376:	e0 80 00 95 	breq	800074a0 <_realloc_r+0x1e4>
8000737a:	62 07       	ld.w	r7,r1[0x0]
8000737c:	e2 07 01 07 	sub	r7,r1,r7
80007380:	6e 1c       	ld.w	r12,r7[0x4]
80007382:	e0 1c ff fc 	andl	r12,0xfffc
80007386:	58 09       	cp.w	r9,0
80007388:	c5 60       	breq	80007434 <_realloc_r+0x178>
8000738a:	f8 00 00 03 	add	r3,r12,r0
8000738e:	0a 39       	cp.w	r9,r5
80007390:	c4 81       	brne	80007420 <_realloc_r+0x164>
80007392:	14 03       	add	r3,r10
80007394:	ec c9 ff f0 	sub	r9,r6,-16
80007398:	12 33       	cp.w	r3,r9
8000739a:	c4 d5       	brlt	80007434 <_realloc_r+0x178>
8000739c:	6e 3a       	ld.w	r10,r7[0xc]
8000739e:	6e 29       	ld.w	r9,r7[0x8]
800073a0:	95 29       	st.w	r10[0x8],r9
800073a2:	93 3a       	st.w	r9[0xc],r10
800073a4:	ee c5 ff f8 	sub	r5,r7,-8
800073a8:	e0 ca 00 04 	sub	r10,r0,4
800073ac:	e0 4a 00 24 	cp.w	r10,36
800073b0:	e0 8b 00 25 	brhi	800073fa <_realloc_r+0x13e>
800073b4:	0a 99       	mov	r9,r5
800073b6:	59 3a       	cp.w	r10,19
800073b8:	e0 88 00 1a 	brls	800073ec <_realloc_r+0x130>
800073bc:	09 09       	ld.w	r9,r4++
800073be:	8b 09       	st.w	r5[0x0],r9
800073c0:	09 09       	ld.w	r9,r4++
800073c2:	8f 39       	st.w	r7[0xc],r9
800073c4:	ee c9 ff f0 	sub	r9,r7,-16
800073c8:	59 ba       	cp.w	r10,27
800073ca:	e0 88 00 11 	brls	800073ec <_realloc_r+0x130>
800073ce:	09 0b       	ld.w	r11,r4++
800073d0:	93 0b       	st.w	r9[0x0],r11
800073d2:	09 09       	ld.w	r9,r4++
800073d4:	8f 59       	st.w	r7[0x14],r9
800073d6:	ee c9 ff e8 	sub	r9,r7,-24
800073da:	e0 4a 00 24 	cp.w	r10,36
800073de:	c0 71       	brne	800073ec <_realloc_r+0x130>
800073e0:	09 0a       	ld.w	r10,r4++
800073e2:	93 0a       	st.w	r9[0x0],r10
800073e4:	ee c9 ff e0 	sub	r9,r7,-32
800073e8:	09 0a       	ld.w	r10,r4++
800073ea:	8f 7a       	st.w	r7[0x1c],r10
800073ec:	09 0a       	ld.w	r10,r4++
800073ee:	12 aa       	st.w	r9++,r10
800073f0:	68 0a       	ld.w	r10,r4[0x0]
800073f2:	93 0a       	st.w	r9[0x0],r10
800073f4:	68 1a       	ld.w	r10,r4[0x4]
800073f6:	93 1a       	st.w	r9[0x4],r10
800073f8:	c0 78       	rjmp	80007406 <_realloc_r+0x14a>
800073fa:	50 08       	stdsp	sp[0x0],r8
800073fc:	08 9b       	mov	r11,r4
800073fe:	0a 9c       	mov	r12,r5
80007400:	e0 a0 1e 73 	rcall	8000b0e6 <memmove>
80007404:	40 08       	lddsp	r8,sp[0x0]
80007406:	ee 06 00 09 	add	r9,r7,r6
8000740a:	0c 13       	sub	r3,r6
8000740c:	a1 a3       	sbr	r3,0x0
8000740e:	93 13       	st.w	r9[0x4],r3
80007410:	91 29       	st.w	r8[0x8],r9
80007412:	04 9c       	mov	r12,r2
80007414:	6e 18       	ld.w	r8,r7[0x4]
80007416:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000741a:	10 46       	or	r6,r8
8000741c:	8f 16       	st.w	r7[0x4],r6
8000741e:	ca a8       	rjmp	80007572 <_realloc_r+0x2b6>
80007420:	14 03       	add	r3,r10
80007422:	0c 33       	cp.w	r3,r6
80007424:	c0 85       	brlt	80007434 <_realloc_r+0x178>
80007426:	72 28       	ld.w	r8,r9[0x8]
80007428:	72 39       	ld.w	r9,r9[0xc]
8000742a:	93 28       	st.w	r9[0x8],r8
8000742c:	91 39       	st.w	r8[0xc],r9
8000742e:	6e 28       	ld.w	r8,r7[0x8]
80007430:	6e 39       	ld.w	r9,r7[0xc]
80007432:	c0 78       	rjmp	80007440 <_realloc_r+0x184>
80007434:	f8 00 00 03 	add	r3,r12,r0
80007438:	0c 33       	cp.w	r3,r6
8000743a:	c3 35       	brlt	800074a0 <_realloc_r+0x1e4>
8000743c:	6e 39       	ld.w	r9,r7[0xc]
8000743e:	6e 28       	ld.w	r8,r7[0x8]
80007440:	93 28       	st.w	r9[0x8],r8
80007442:	91 39       	st.w	r8[0xc],r9
80007444:	e0 ca 00 04 	sub	r10,r0,4
80007448:	ee cc ff f8 	sub	r12,r7,-8
8000744c:	e0 4a 00 24 	cp.w	r10,36
80007450:	e0 8b 00 24 	brhi	80007498 <_realloc_r+0x1dc>
80007454:	59 3a       	cp.w	r10,19
80007456:	e0 88 00 1a 	brls	8000748a <_realloc_r+0x1ce>
8000745a:	09 08       	ld.w	r8,r4++
8000745c:	99 08       	st.w	r12[0x0],r8
8000745e:	09 08       	ld.w	r8,r4++
80007460:	8f 38       	st.w	r7[0xc],r8
80007462:	ee cc ff f0 	sub	r12,r7,-16
80007466:	59 ba       	cp.w	r10,27
80007468:	e0 88 00 11 	brls	8000748a <_realloc_r+0x1ce>
8000746c:	09 08       	ld.w	r8,r4++
8000746e:	99 08       	st.w	r12[0x0],r8
80007470:	09 08       	ld.w	r8,r4++
80007472:	8f 58       	st.w	r7[0x14],r8
80007474:	ee cc ff e8 	sub	r12,r7,-24
80007478:	e0 4a 00 24 	cp.w	r10,36
8000747c:	c0 71       	brne	8000748a <_realloc_r+0x1ce>
8000747e:	09 08       	ld.w	r8,r4++
80007480:	99 08       	st.w	r12[0x0],r8
80007482:	ee cc ff e0 	sub	r12,r7,-32
80007486:	09 08       	ld.w	r8,r4++
80007488:	8f 78       	st.w	r7[0x1c],r8
8000748a:	09 08       	ld.w	r8,r4++
8000748c:	18 a8       	st.w	r12++,r8
8000748e:	68 08       	ld.w	r8,r4[0x0]
80007490:	99 08       	st.w	r12[0x0],r8
80007492:	68 18       	ld.w	r8,r4[0x4]
80007494:	99 18       	st.w	r12[0x4],r8
80007496:	c4 78       	rjmp	80007524 <_realloc_r+0x268>
80007498:	08 9b       	mov	r11,r4
8000749a:	e0 a0 1e 26 	rcall	8000b0e6 <memmove>
8000749e:	c4 38       	rjmp	80007524 <_realloc_r+0x268>
800074a0:	04 9c       	mov	r12,r2
800074a2:	fe b0 fc 45 	rcall	80006d2c <_malloc_r>
800074a6:	18 95       	mov	r5,r12
800074a8:	c3 a0       	breq	8000751c <_realloc_r+0x260>
800074aa:	62 18       	ld.w	r8,r1[0x4]
800074ac:	f8 c9 00 08 	sub	r9,r12,8
800074b0:	a1 c8       	cbr	r8,0x0
800074b2:	e2 08 00 08 	add	r8,r1,r8
800074b6:	10 39       	cp.w	r9,r8
800074b8:	c0 71       	brne	800074c6 <_realloc_r+0x20a>
800074ba:	72 13       	ld.w	r3,r9[0x4]
800074bc:	02 97       	mov	r7,r1
800074be:	e0 13 ff fc 	andl	r3,0xfffc
800074c2:	00 03       	add	r3,r0
800074c4:	c3 08       	rjmp	80007524 <_realloc_r+0x268>
800074c6:	e0 ca 00 04 	sub	r10,r0,4
800074ca:	e0 4a 00 24 	cp.w	r10,36
800074ce:	e0 8b 00 20 	brhi	8000750e <_realloc_r+0x252>
800074d2:	08 99       	mov	r9,r4
800074d4:	18 98       	mov	r8,r12
800074d6:	59 3a       	cp.w	r10,19
800074d8:	e0 88 00 14 	brls	80007500 <_realloc_r+0x244>
800074dc:	13 0b       	ld.w	r11,r9++
800074de:	10 ab       	st.w	r8++,r11
800074e0:	13 0b       	ld.w	r11,r9++
800074e2:	10 ab       	st.w	r8++,r11
800074e4:	59 ba       	cp.w	r10,27
800074e6:	e0 88 00 0d 	brls	80007500 <_realloc_r+0x244>
800074ea:	13 0b       	ld.w	r11,r9++
800074ec:	10 ab       	st.w	r8++,r11
800074ee:	13 0b       	ld.w	r11,r9++
800074f0:	10 ab       	st.w	r8++,r11
800074f2:	e0 4a 00 24 	cp.w	r10,36
800074f6:	c0 51       	brne	80007500 <_realloc_r+0x244>
800074f8:	13 0a       	ld.w	r10,r9++
800074fa:	10 aa       	st.w	r8++,r10
800074fc:	13 0a       	ld.w	r10,r9++
800074fe:	10 aa       	st.w	r8++,r10
80007500:	13 0a       	ld.w	r10,r9++
80007502:	10 aa       	st.w	r8++,r10
80007504:	72 0a       	ld.w	r10,r9[0x0]
80007506:	91 0a       	st.w	r8[0x0],r10
80007508:	72 19       	ld.w	r9,r9[0x4]
8000750a:	91 19       	st.w	r8[0x4],r9
8000750c:	c0 48       	rjmp	80007514 <_realloc_r+0x258>
8000750e:	08 9b       	mov	r11,r4
80007510:	e0 a0 1d eb 	rcall	8000b0e6 <memmove>
80007514:	08 9b       	mov	r11,r4
80007516:	04 9c       	mov	r12,r2
80007518:	e0 a0 1b 44 	rcall	8000aba0 <_free_r>
8000751c:	04 9c       	mov	r12,r2
8000751e:	c2 a8       	rjmp	80007572 <_realloc_r+0x2b6>
80007520:	00 93       	mov	r3,r0
80007522:	02 97       	mov	r7,r1
80007524:	e6 06 01 09 	sub	r9,r3,r6
80007528:	6e 18       	ld.w	r8,r7[0x4]
8000752a:	58 f9       	cp.w	r9,15
8000752c:	e0 88 00 16 	brls	80007558 <_realloc_r+0x29c>
80007530:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007534:	ed e8 10 08 	or	r8,r6,r8
80007538:	8f 18       	st.w	r7[0x4],r8
8000753a:	12 98       	mov	r8,r9
8000753c:	a1 a8       	sbr	r8,0x0
8000753e:	ee 06 00 0b 	add	r11,r7,r6
80007542:	f6 09 00 09 	add	r9,r11,r9
80007546:	97 18       	st.w	r11[0x4],r8
80007548:	72 18       	ld.w	r8,r9[0x4]
8000754a:	a1 a8       	sbr	r8,0x0
8000754c:	2f 8b       	sub	r11,-8
8000754e:	93 18       	st.w	r9[0x4],r8
80007550:	04 9c       	mov	r12,r2
80007552:	e0 a0 1b 27 	rcall	8000aba0 <_free_r>
80007556:	c0 b8       	rjmp	8000756c <_realloc_r+0x2b0>
80007558:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000755c:	e7 e8 10 08 	or	r8,r3,r8
80007560:	8f 18       	st.w	r7[0x4],r8
80007562:	ee 03 00 03 	add	r3,r7,r3
80007566:	66 18       	ld.w	r8,r3[0x4]
80007568:	a1 a8       	sbr	r8,0x0
8000756a:	87 18       	st.w	r3[0x4],r8
8000756c:	04 9c       	mov	r12,r2
8000756e:	ee c5 ff f8 	sub	r5,r7,-8
80007572:	fe b0 ed 3f 	rcall	80004ff0 <__malloc_unlock>
80007576:	0a 9c       	mov	r12,r5
80007578:	2f fd       	sub	sp,-4
8000757a:	d8 32       	popm	r0-r7,pc

8000757c <_sbrk_r>:
8000757c:	d4 21       	pushm	r4-r7,lr
8000757e:	30 08       	mov	r8,0
80007580:	18 97       	mov	r7,r12
80007582:	e0 66 07 fc 	mov	r6,2044
80007586:	16 9c       	mov	r12,r11
80007588:	8d 08       	st.w	r6[0x0],r8
8000758a:	c8 fc       	rcall	800076a8 <_sbrk>
8000758c:	5b fc       	cp.w	r12,-1
8000758e:	c0 51       	brne	80007598 <_sbrk_r+0x1c>
80007590:	6c 08       	ld.w	r8,r6[0x0]
80007592:	58 08       	cp.w	r8,0
80007594:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007598:	d8 22       	popm	r4-r7,pc
8000759a:	d7 03       	nop

8000759c <sprintf>:
8000759c:	d4 01       	pushm	lr
8000759e:	21 7d       	sub	sp,92
800075a0:	e0 68 ff ff 	mov	r8,65535
800075a4:	ea 18 7f ff 	orh	r8,0x7fff
800075a8:	50 58       	stdsp	sp[0x14],r8
800075aa:	50 28       	stdsp	sp[0x8],r8
800075ac:	e0 68 02 08 	mov	r8,520
800075b0:	ba 68       	st.h	sp[0xc],r8
800075b2:	3f f8       	mov	r8,-1
800075b4:	ba 78       	st.h	sp[0xe],r8
800075b6:	e0 68 01 18 	mov	r8,280
800075ba:	50 4c       	stdsp	sp[0x10],r12
800075bc:	16 9a       	mov	r10,r11
800075be:	50 0c       	stdsp	sp[0x0],r12
800075c0:	fa c9 ff a0 	sub	r9,sp,-96
800075c4:	70 0c       	ld.w	r12,r8[0x0]
800075c6:	1a 9b       	mov	r11,sp
800075c8:	e0 a0 02 24 	rcall	80007a10 <_vfprintf_r>
800075cc:	30 09       	mov	r9,0
800075ce:	40 08       	lddsp	r8,sp[0x0]
800075d0:	b0 89       	st.b	r8[0x0],r9
800075d2:	2e 9d       	sub	sp,-92
800075d4:	d8 02       	popm	pc
800075d6:	d7 03       	nop

800075d8 <strncpy>:
800075d8:	30 08       	mov	r8,0
800075da:	10 3a       	cp.w	r10,r8
800075dc:	5e 0c       	reteq	r12
800075de:	f6 08 07 09 	ld.ub	r9,r11[r8]
800075e2:	f8 08 0b 09 	st.b	r12[r8],r9
800075e6:	2f f8       	sub	r8,-1
800075e8:	58 09       	cp.w	r9,0
800075ea:	cf 81       	brne	800075da <strncpy+0x2>
800075ec:	10 3a       	cp.w	r10,r8
800075ee:	5e 0c       	reteq	r12
800075f0:	f8 08 0b 09 	st.b	r12[r8],r9
800075f4:	2f f8       	sub	r8,-1
800075f6:	cf bb       	rjmp	800075ec <strncpy+0x14>

800075f8 <_init_argv>:
800075f8:	30 e8       	mov	r8,14
800075fa:	d6 73       	breakpoint
800075fc:	3f fc       	mov	r12,-1
800075fe:	35 8b       	mov	r11,88
80007600:	5e fc       	retal	r12

80007602 <_exit>:
80007602:	30 d8       	mov	r8,13
80007604:	d6 73       	breakpoint
80007606:	3f fc       	mov	r12,-1
80007608:	35 8b       	mov	r11,88
8000760a:	c0 08       	rjmp	8000760a <_exit+0x8>

8000760c <_close>:
8000760c:	30 28       	mov	r8,2
8000760e:	d6 73       	breakpoint
80007610:	3f fc       	mov	r12,-1
80007612:	35 8b       	mov	r11,88
80007614:	58 0c       	cp.w	r12,0
80007616:	5e 4c       	retge	r12
80007618:	e0 6a 07 fc 	mov	r10,2044
8000761c:	95 0b       	st.w	r10[0x0],r11
8000761e:	5e fc       	retal	r12

80007620 <_lseek>:
80007620:	30 58       	mov	r8,5
80007622:	d6 73       	breakpoint
80007624:	3f fc       	mov	r12,-1
80007626:	35 8b       	mov	r11,88
80007628:	58 0c       	cp.w	r12,0
8000762a:	5e 4c       	retge	r12
8000762c:	e0 6a 07 fc 	mov	r10,2044
80007630:	95 0b       	st.w	r10[0x0],r11
80007632:	5e fc       	retal	r12

80007634 <isatty>:
80007634:	30 b8       	mov	r8,11
80007636:	d6 73       	breakpoint
80007638:	3f fc       	mov	r12,-1
8000763a:	35 8b       	mov	r11,88
8000763c:	58 0c       	cp.w	r12,0
8000763e:	5e 4c       	retge	r12
80007640:	e0 6a 07 fc 	mov	r10,2044
80007644:	95 0b       	st.w	r10[0x0],r11
80007646:	5e fc       	retal	r12

80007648 <_fstat_host>:
80007648:	30 98       	mov	r8,9
8000764a:	d6 73       	breakpoint
8000764c:	3f fc       	mov	r12,-1
8000764e:	35 8b       	mov	r11,88
80007650:	58 0c       	cp.w	r12,0
80007652:	5e 4c       	retge	r12
80007654:	e0 6a 07 fc 	mov	r10,2044
80007658:	95 0b       	st.w	r10[0x0],r11
8000765a:	5e fc       	retal	r12

8000765c <_fstat>:
8000765c:	d4 21       	pushm	r4-r7,lr
8000765e:	21 0d       	sub	sp,64
80007660:	16 97       	mov	r7,r11
80007662:	1a 9b       	mov	r11,sp
80007664:	cf 2f       	rcall	80007648 <_fstat_host>
80007666:	c0 34       	brge	8000766c <_fstat+0x10>
80007668:	3f fc       	mov	r12,-1
8000766a:	c1 c8       	rjmp	800076a2 <_fstat+0x46>
8000766c:	40 08       	lddsp	r8,sp[0x0]
8000766e:	ae 08       	st.h	r7[0x0],r8
80007670:	40 18       	lddsp	r8,sp[0x4]
80007672:	ae 18       	st.h	r7[0x2],r8
80007674:	40 28       	lddsp	r8,sp[0x8]
80007676:	8f 18       	st.w	r7[0x4],r8
80007678:	40 38       	lddsp	r8,sp[0xc]
8000767a:	ae 48       	st.h	r7[0x8],r8
8000767c:	40 48       	lddsp	r8,sp[0x10]
8000767e:	ae 58       	st.h	r7[0xa],r8
80007680:	40 58       	lddsp	r8,sp[0x14]
80007682:	ae 68       	st.h	r7[0xc],r8
80007684:	40 68       	lddsp	r8,sp[0x18]
80007686:	ae 78       	st.h	r7[0xe],r8
80007688:	40 88       	lddsp	r8,sp[0x20]
8000768a:	8f 48       	st.w	r7[0x10],r8
8000768c:	40 a8       	lddsp	r8,sp[0x28]
8000768e:	8f b8       	st.w	r7[0x2c],r8
80007690:	40 c8       	lddsp	r8,sp[0x30]
80007692:	8f c8       	st.w	r7[0x30],r8
80007694:	40 d8       	lddsp	r8,sp[0x34]
80007696:	8f 58       	st.w	r7[0x14],r8
80007698:	40 e8       	lddsp	r8,sp[0x38]
8000769a:	30 0c       	mov	r12,0
8000769c:	8f 78       	st.w	r7[0x1c],r8
8000769e:	40 f8       	lddsp	r8,sp[0x3c]
800076a0:	8f 98       	st.w	r7[0x24],r8
800076a2:	2f 0d       	sub	sp,-64
800076a4:	d8 22       	popm	r4-r7,pc
800076a6:	d7 03       	nop

800076a8 <_sbrk>:
800076a8:	d4 01       	pushm	lr
800076aa:	e0 68 07 d0 	mov	r8,2000
800076ae:	70 09       	ld.w	r9,r8[0x0]
800076b0:	58 09       	cp.w	r9,0
800076b2:	c0 41       	brne	800076ba <_sbrk+0x12>
800076b4:	e0 69 08 00 	mov	r9,2048
800076b8:	91 09       	st.w	r8[0x0],r9
800076ba:	e0 69 07 d0 	mov	r9,2000
800076be:	e0 6a f0 00 	mov	r10,61440
800076c2:	72 08       	ld.w	r8,r9[0x0]
800076c4:	f0 0c 00 0c 	add	r12,r8,r12
800076c8:	14 3c       	cp.w	r12,r10
800076ca:	e0 8b 00 04 	brhi	800076d2 <_sbrk+0x2a>
800076ce:	93 0c       	st.w	r9[0x0],r12
800076d0:	c0 68       	rjmp	800076dc <_sbrk+0x34>
800076d2:	e0 a0 18 ef 	rcall	8000a8b0 <__errno>
800076d6:	30 c8       	mov	r8,12
800076d8:	99 08       	st.w	r12[0x0],r8
800076da:	3f f8       	mov	r8,-1
800076dc:	10 9c       	mov	r12,r8
800076de:	d8 02       	popm	pc

800076e0 <get_arg>:
800076e0:	d4 31       	pushm	r0-r7,lr
800076e2:	20 8d       	sub	sp,32
800076e4:	fa c4 ff bc 	sub	r4,sp,-68
800076e8:	50 4b       	stdsp	sp[0x10],r11
800076ea:	68 2e       	ld.w	lr,r4[0x8]
800076ec:	50 58       	stdsp	sp[0x14],r8
800076ee:	12 96       	mov	r6,r9
800076f0:	7c 0b       	ld.w	r11,lr[0x0]
800076f2:	70 05       	ld.w	r5,r8[0x0]
800076f4:	50 6e       	stdsp	sp[0x18],lr
800076f6:	58 0b       	cp.w	r11,0
800076f8:	f4 0b 17 00 	moveq	r11,r10
800076fc:	68 03       	ld.w	r3,r4[0x0]
800076fe:	68 11       	ld.w	r1,r4[0x4]
80007700:	40 49       	lddsp	r9,sp[0x10]
80007702:	30 08       	mov	r8,0
80007704:	c2 89       	rjmp	80007954 <get_arg+0x274>
80007706:	2f fb       	sub	r11,-1
80007708:	32 5c       	mov	r12,37
8000770a:	17 8a       	ld.ub	r10,r11[0x0]
8000770c:	f8 0a 18 00 	cp.b	r10,r12
80007710:	5f 1e       	srne	lr
80007712:	f0 0a 18 00 	cp.b	r10,r8
80007716:	5f 1c       	srne	r12
80007718:	fd ec 00 0c 	and	r12,lr,r12
8000771c:	f0 0c 18 00 	cp.b	r12,r8
80007720:	cf 31       	brne	80007706 <get_arg+0x26>
80007722:	58 0a       	cp.w	r10,0
80007724:	e0 80 01 25 	breq	8000796e <get_arg+0x28e>
80007728:	30 0c       	mov	r12,0
8000772a:	3f fa       	mov	r10,-1
8000772c:	18 90       	mov	r0,r12
8000772e:	50 3a       	stdsp	sp[0xc],r10
80007730:	18 94       	mov	r4,r12
80007732:	18 92       	mov	r2,r12
80007734:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007738:	16 97       	mov	r7,r11
8000773a:	50 7c       	stdsp	sp[0x1c],r12
8000773c:	fe cc aa b0 	sub	r12,pc,-21840
80007740:	0f 3a       	ld.ub	r10,r7++
80007742:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007746:	40 7c       	lddsp	r12,sp[0x1c]
80007748:	1c 0c       	add	r12,lr
8000774a:	fe ce ab 86 	sub	lr,pc,-21626
8000774e:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007752:	20 1e       	sub	lr,1
80007754:	50 0e       	stdsp	sp[0x0],lr
80007756:	fe ce ab fe 	sub	lr,pc,-21506
8000775a:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000775e:	50 7c       	stdsp	sp[0x1c],r12
80007760:	40 0c       	lddsp	r12,sp[0x0]
80007762:	58 7c       	cp.w	r12,7
80007764:	e0 8b 00 f1 	brhi	80007946 <get_arg+0x266>
80007768:	fe ce ad b0 	sub	lr,pc,-21072
8000776c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007770:	36 8b       	mov	r11,104
80007772:	f6 0a 18 00 	cp.b	r10,r11
80007776:	e0 80 00 e8 	breq	80007946 <get_arg+0x266>
8000777a:	37 1b       	mov	r11,113
8000777c:	f6 0a 18 00 	cp.b	r10,r11
80007780:	c0 70       	breq	8000778e <get_arg+0xae>
80007782:	34 cb       	mov	r11,76
80007784:	f6 0a 18 00 	cp.b	r10,r11
80007788:	c0 51       	brne	80007792 <get_arg+0xb2>
8000778a:	a3 b4       	sbr	r4,0x3
8000778c:	cd d8       	rjmp	80007946 <get_arg+0x266>
8000778e:	a5 b4       	sbr	r4,0x5
80007790:	cd b8       	rjmp	80007946 <get_arg+0x266>
80007792:	08 9a       	mov	r10,r4
80007794:	0e 9b       	mov	r11,r7
80007796:	a5 aa       	sbr	r10,0x4
80007798:	17 3c       	ld.ub	r12,r11++
8000779a:	a5 b4       	sbr	r4,0x5
8000779c:	36 ce       	mov	lr,108
8000779e:	fc 0c 18 00 	cp.b	r12,lr
800077a2:	e0 80 00 d3 	breq	80007948 <get_arg+0x268>
800077a6:	14 94       	mov	r4,r10
800077a8:	cc f8       	rjmp	80007946 <get_arg+0x266>
800077aa:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
800077ae:	36 7c       	mov	r12,103
800077b0:	f8 0a 18 00 	cp.b	r10,r12
800077b4:	e0 8b 00 27 	brhi	80007802 <get_arg+0x122>
800077b8:	36 5b       	mov	r11,101
800077ba:	f6 0a 18 00 	cp.b	r10,r11
800077be:	c4 82       	brcc	8000784e <get_arg+0x16e>
800077c0:	34 fb       	mov	r11,79
800077c2:	f6 0a 18 00 	cp.b	r10,r11
800077c6:	c4 80       	breq	80007856 <get_arg+0x176>
800077c8:	e0 8b 00 0c 	brhi	800077e0 <get_arg+0x100>
800077cc:	34 5b       	mov	r11,69
800077ce:	f6 0a 18 00 	cp.b	r10,r11
800077d2:	c3 e0       	breq	8000784e <get_arg+0x16e>
800077d4:	34 7b       	mov	r11,71
800077d6:	f6 0a 18 00 	cp.b	r10,r11
800077da:	c3 a0       	breq	8000784e <get_arg+0x16e>
800077dc:	34 4b       	mov	r11,68
800077de:	c0 88       	rjmp	800077ee <get_arg+0x10e>
800077e0:	35 8b       	mov	r11,88
800077e2:	f6 0a 18 00 	cp.b	r10,r11
800077e6:	c2 c0       	breq	8000783e <get_arg+0x15e>
800077e8:	e0 8b 00 07 	brhi	800077f6 <get_arg+0x116>
800077ec:	35 5b       	mov	r11,85
800077ee:	f6 0a 18 00 	cp.b	r10,r11
800077f2:	c3 51       	brne	8000785c <get_arg+0x17c>
800077f4:	c3 18       	rjmp	80007856 <get_arg+0x176>
800077f6:	36 3b       	mov	r11,99
800077f8:	f6 0a 18 00 	cp.b	r10,r11
800077fc:	c2 f0       	breq	8000785a <get_arg+0x17a>
800077fe:	36 4b       	mov	r11,100
80007800:	c0 e8       	rjmp	8000781c <get_arg+0x13c>
80007802:	37 0b       	mov	r11,112
80007804:	f6 0a 18 00 	cp.b	r10,r11
80007808:	c2 50       	breq	80007852 <get_arg+0x172>
8000780a:	e0 8b 00 0d 	brhi	80007824 <get_arg+0x144>
8000780e:	36 eb       	mov	r11,110
80007810:	f6 0a 18 00 	cp.b	r10,r11
80007814:	c1 f0       	breq	80007852 <get_arg+0x172>
80007816:	e0 8b 00 14 	brhi	8000783e <get_arg+0x15e>
8000781a:	36 9b       	mov	r11,105
8000781c:	f6 0a 18 00 	cp.b	r10,r11
80007820:	c1 e1       	brne	8000785c <get_arg+0x17c>
80007822:	c0 e8       	rjmp	8000783e <get_arg+0x15e>
80007824:	37 5b       	mov	r11,117
80007826:	f6 0a 18 00 	cp.b	r10,r11
8000782a:	c0 a0       	breq	8000783e <get_arg+0x15e>
8000782c:	37 8b       	mov	r11,120
8000782e:	f6 0a 18 00 	cp.b	r10,r11
80007832:	c0 60       	breq	8000783e <get_arg+0x15e>
80007834:	37 3b       	mov	r11,115
80007836:	f6 0a 18 00 	cp.b	r10,r11
8000783a:	c1 11       	brne	8000785c <get_arg+0x17c>
8000783c:	c0 b8       	rjmp	80007852 <get_arg+0x172>
8000783e:	ed b4 00 04 	bld	r4,0x4
80007842:	c0 a0       	breq	80007856 <get_arg+0x176>
80007844:	ed b4 00 05 	bld	r4,0x5
80007848:	c0 91       	brne	8000785a <get_arg+0x17a>
8000784a:	30 20       	mov	r0,2
8000784c:	c0 88       	rjmp	8000785c <get_arg+0x17c>
8000784e:	30 40       	mov	r0,4
80007850:	c0 68       	rjmp	8000785c <get_arg+0x17c>
80007852:	30 30       	mov	r0,3
80007854:	c0 48       	rjmp	8000785c <get_arg+0x17c>
80007856:	30 10       	mov	r0,1
80007858:	c0 28       	rjmp	8000785c <get_arg+0x17c>
8000785a:	30 00       	mov	r0,0
8000785c:	40 3b       	lddsp	r11,sp[0xc]
8000785e:	5b fb       	cp.w	r11,-1
80007860:	c0 40       	breq	80007868 <get_arg+0x188>
80007862:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007866:	c7 08       	rjmp	80007946 <get_arg+0x266>
80007868:	58 60       	cp.w	r0,6
8000786a:	e0 8b 00 6e 	brhi	80007946 <get_arg+0x266>
8000786e:	6c 0a       	ld.w	r10,r6[0x0]
80007870:	ea cc ff ff 	sub	r12,r5,-1
80007874:	fe ce ae 9c 	sub	lr,pc,-20836
80007878:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000787c:	f4 cb ff f8 	sub	r11,r10,-8
80007880:	8d 0b       	st.w	r6[0x0],r11
80007882:	f4 ea 00 00 	ld.d	r10,r10[0]
80007886:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000788a:	c0 f8       	rjmp	800078a8 <get_arg+0x1c8>
8000788c:	f4 cb ff fc 	sub	r11,r10,-4
80007890:	8d 0b       	st.w	r6[0x0],r11
80007892:	74 0a       	ld.w	r10,r10[0x0]
80007894:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007898:	c0 88       	rjmp	800078a8 <get_arg+0x1c8>
8000789a:	f4 cb ff f8 	sub	r11,r10,-8
8000789e:	8d 0b       	st.w	r6[0x0],r11
800078a0:	f4 ea 00 00 	ld.d	r10,r10[0]
800078a4:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800078a8:	0e 9b       	mov	r11,r7
800078aa:	18 95       	mov	r5,r12
800078ac:	c4 e8       	rjmp	80007948 <get_arg+0x268>
800078ae:	62 0a       	ld.w	r10,r1[0x0]
800078b0:	5b fa       	cp.w	r10,-1
800078b2:	c0 b1       	brne	800078c8 <get_arg+0x1e8>
800078b4:	50 19       	stdsp	sp[0x4],r9
800078b6:	50 28       	stdsp	sp[0x8],r8
800078b8:	e0 6a 00 80 	mov	r10,128
800078bc:	30 0b       	mov	r11,0
800078be:	02 9c       	mov	r12,r1
800078c0:	fe b0 fc f6 	rcall	800072ac <memset>
800078c4:	40 28       	lddsp	r8,sp[0x8]
800078c6:	40 19       	lddsp	r9,sp[0x4]
800078c8:	e4 cc 00 01 	sub	r12,r2,1
800078cc:	0e 9b       	mov	r11,r7
800078ce:	50 3c       	stdsp	sp[0xc],r12
800078d0:	f2 0c 0c 49 	max	r9,r9,r12
800078d4:	c3 a8       	rjmp	80007948 <get_arg+0x268>
800078d6:	62 0a       	ld.w	r10,r1[0x0]
800078d8:	5b fa       	cp.w	r10,-1
800078da:	c0 b1       	brne	800078f0 <get_arg+0x210>
800078dc:	50 19       	stdsp	sp[0x4],r9
800078de:	50 28       	stdsp	sp[0x8],r8
800078e0:	e0 6a 00 80 	mov	r10,128
800078e4:	30 0b       	mov	r11,0
800078e6:	02 9c       	mov	r12,r1
800078e8:	fe b0 fc e2 	rcall	800072ac <memset>
800078ec:	40 28       	lddsp	r8,sp[0x8]
800078ee:	40 19       	lddsp	r9,sp[0x4]
800078f0:	20 12       	sub	r2,1
800078f2:	30 0a       	mov	r10,0
800078f4:	0e 9b       	mov	r11,r7
800078f6:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
800078fa:	f2 02 0c 49 	max	r9,r9,r2
800078fe:	c2 58       	rjmp	80007948 <get_arg+0x268>
80007900:	16 97       	mov	r7,r11
80007902:	6c 0a       	ld.w	r10,r6[0x0]
80007904:	f4 cb ff fc 	sub	r11,r10,-4
80007908:	8d 0b       	st.w	r6[0x0],r11
8000790a:	74 0a       	ld.w	r10,r10[0x0]
8000790c:	0e 9b       	mov	r11,r7
8000790e:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007912:	2f f5       	sub	r5,-1
80007914:	c1 a8       	rjmp	80007948 <get_arg+0x268>
80007916:	f4 c2 00 30 	sub	r2,r10,48
8000791a:	c0 68       	rjmp	80007926 <get_arg+0x246>
8000791c:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007920:	2f f7       	sub	r7,-1
80007922:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007926:	0f 8a       	ld.ub	r10,r7[0x0]
80007928:	58 0a       	cp.w	r10,0
8000792a:	c0 e0       	breq	80007946 <get_arg+0x266>
8000792c:	23 0a       	sub	r10,48
8000792e:	58 9a       	cp.w	r10,9
80007930:	fe 98 ff f6 	brls	8000791c <get_arg+0x23c>
80007934:	c0 98       	rjmp	80007946 <get_arg+0x266>
80007936:	2f f7       	sub	r7,-1
80007938:	0f 8a       	ld.ub	r10,r7[0x0]
8000793a:	58 0a       	cp.w	r10,0
8000793c:	c0 50       	breq	80007946 <get_arg+0x266>
8000793e:	23 0a       	sub	r10,48
80007940:	58 9a       	cp.w	r10,9
80007942:	fe 98 ff fa 	brls	80007936 <get_arg+0x256>
80007946:	0e 9b       	mov	r11,r7
80007948:	40 7c       	lddsp	r12,sp[0x1c]
8000794a:	30 ba       	mov	r10,11
8000794c:	f4 0c 18 00 	cp.b	r12,r10
80007950:	fe 91 fe f2 	brne	80007734 <get_arg+0x54>
80007954:	40 42       	lddsp	r2,sp[0x10]
80007956:	17 8c       	ld.ub	r12,r11[0x0]
80007958:	0a 32       	cp.w	r2,r5
8000795a:	5f 4a       	srge	r10
8000795c:	f0 0c 18 00 	cp.b	r12,r8
80007960:	5f 1c       	srne	r12
80007962:	f9 ea 00 0a 	and	r10,r12,r10
80007966:	f0 0a 18 00 	cp.b	r10,r8
8000796a:	fe 91 fe cf 	brne	80007708 <get_arg+0x28>
8000796e:	30 08       	mov	r8,0
80007970:	40 4e       	lddsp	lr,sp[0x10]
80007972:	17 8a       	ld.ub	r10,r11[0x0]
80007974:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007978:	f0 0a 18 00 	cp.b	r10,r8
8000797c:	fc 09 17 10 	movne	r9,lr
80007980:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007984:	06 9e       	mov	lr,r3
80007986:	c2 a8       	rjmp	800079da <get_arg+0x2fa>
80007988:	62 0a       	ld.w	r10,r1[0x0]
8000798a:	58 3a       	cp.w	r10,3
8000798c:	c1 e0       	breq	800079c8 <get_arg+0x2e8>
8000798e:	e0 89 00 07 	brgt	8000799c <get_arg+0x2bc>
80007992:	58 1a       	cp.w	r10,1
80007994:	c1 a0       	breq	800079c8 <get_arg+0x2e8>
80007996:	58 2a       	cp.w	r10,2
80007998:	c1 81       	brne	800079c8 <get_arg+0x2e8>
8000799a:	c0 58       	rjmp	800079a4 <get_arg+0x2c4>
8000799c:	58 5a       	cp.w	r10,5
8000799e:	c0 c0       	breq	800079b6 <get_arg+0x2d6>
800079a0:	c0 b5       	brlt	800079b6 <get_arg+0x2d6>
800079a2:	c1 38       	rjmp	800079c8 <get_arg+0x2e8>
800079a4:	6c 0a       	ld.w	r10,r6[0x0]
800079a6:	f4 cc ff f8 	sub	r12,r10,-8
800079aa:	8d 0c       	st.w	r6[0x0],r12
800079ac:	f4 e2 00 00 	ld.d	r2,r10[0]
800079b0:	f0 e3 00 00 	st.d	r8[0],r2
800079b4:	c1 08       	rjmp	800079d4 <get_arg+0x2f4>
800079b6:	6c 0a       	ld.w	r10,r6[0x0]
800079b8:	f4 cc ff f8 	sub	r12,r10,-8
800079bc:	8d 0c       	st.w	r6[0x0],r12
800079be:	f4 e2 00 00 	ld.d	r2,r10[0]
800079c2:	f0 e3 00 00 	st.d	r8[0],r2
800079c6:	c0 78       	rjmp	800079d4 <get_arg+0x2f4>
800079c8:	6c 0a       	ld.w	r10,r6[0x0]
800079ca:	f4 cc ff fc 	sub	r12,r10,-4
800079ce:	8d 0c       	st.w	r6[0x0],r12
800079d0:	74 0a       	ld.w	r10,r10[0x0]
800079d2:	91 0a       	st.w	r8[0x0],r10
800079d4:	2f f5       	sub	r5,-1
800079d6:	2f 88       	sub	r8,-8
800079d8:	2f c1       	sub	r1,-4
800079da:	12 35       	cp.w	r5,r9
800079dc:	fe 9a ff d6 	brle	80007988 <get_arg+0x2a8>
800079e0:	1c 93       	mov	r3,lr
800079e2:	40 52       	lddsp	r2,sp[0x14]
800079e4:	40 6e       	lddsp	lr,sp[0x18]
800079e6:	85 05       	st.w	r2[0x0],r5
800079e8:	9d 0b       	st.w	lr[0x0],r11
800079ea:	40 4b       	lddsp	r11,sp[0x10]
800079ec:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
800079f0:	2f 8d       	sub	sp,-32
800079f2:	d8 32       	popm	r0-r7,pc

800079f4 <__sprint_r>:
800079f4:	d4 21       	pushm	r4-r7,lr
800079f6:	14 97       	mov	r7,r10
800079f8:	74 28       	ld.w	r8,r10[0x8]
800079fa:	58 08       	cp.w	r8,0
800079fc:	c0 41       	brne	80007a04 <__sprint_r+0x10>
800079fe:	95 18       	st.w	r10[0x4],r8
80007a00:	10 9c       	mov	r12,r8
80007a02:	d8 22       	popm	r4-r7,pc
80007a04:	e0 a0 19 94 	rcall	8000ad2c <__sfvwrite_r>
80007a08:	30 08       	mov	r8,0
80007a0a:	8f 18       	st.w	r7[0x4],r8
80007a0c:	8f 28       	st.w	r7[0x8],r8
80007a0e:	d8 22       	popm	r4-r7,pc

80007a10 <_vfprintf_r>:
80007a10:	d4 31       	pushm	r0-r7,lr
80007a12:	fa cd 06 bc 	sub	sp,sp,1724
80007a16:	51 09       	stdsp	sp[0x40],r9
80007a18:	16 91       	mov	r1,r11
80007a1a:	14 97       	mov	r7,r10
80007a1c:	18 95       	mov	r5,r12
80007a1e:	e0 a0 1a f7 	rcall	8000b00c <_localeconv_r>
80007a22:	78 0c       	ld.w	r12,r12[0x0]
80007a24:	50 cc       	stdsp	sp[0x30],r12
80007a26:	58 05       	cp.w	r5,0
80007a28:	c0 70       	breq	80007a36 <_vfprintf_r+0x26>
80007a2a:	6a 68       	ld.w	r8,r5[0x18]
80007a2c:	58 08       	cp.w	r8,0
80007a2e:	c0 41       	brne	80007a36 <_vfprintf_r+0x26>
80007a30:	0a 9c       	mov	r12,r5
80007a32:	e0 a0 18 1d 	rcall	8000aa6c <__sinit>
80007a36:	fe c8 ac 9a 	sub	r8,pc,-21350
80007a3a:	10 31       	cp.w	r1,r8
80007a3c:	c0 31       	brne	80007a42 <_vfprintf_r+0x32>
80007a3e:	6a 01       	ld.w	r1,r5[0x0]
80007a40:	c0 c8       	rjmp	80007a58 <_vfprintf_r+0x48>
80007a42:	fe c8 ac 86 	sub	r8,pc,-21370
80007a46:	10 31       	cp.w	r1,r8
80007a48:	c0 31       	brne	80007a4e <_vfprintf_r+0x3e>
80007a4a:	6a 11       	ld.w	r1,r5[0x4]
80007a4c:	c0 68       	rjmp	80007a58 <_vfprintf_r+0x48>
80007a4e:	fe c8 ac 72 	sub	r8,pc,-21390
80007a52:	10 31       	cp.w	r1,r8
80007a54:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007a58:	82 68       	ld.sh	r8,r1[0xc]
80007a5a:	ed b8 00 03 	bld	r8,0x3
80007a5e:	c0 41       	brne	80007a66 <_vfprintf_r+0x56>
80007a60:	62 48       	ld.w	r8,r1[0x10]
80007a62:	58 08       	cp.w	r8,0
80007a64:	c0 71       	brne	80007a72 <_vfprintf_r+0x62>
80007a66:	02 9b       	mov	r11,r1
80007a68:	0a 9c       	mov	r12,r5
80007a6a:	e0 a0 0f 7f 	rcall	80009968 <__swsetup_r>
80007a6e:	e0 81 0f 54 	brne	80009916 <_vfprintf_r+0x1f06>
80007a72:	82 68       	ld.sh	r8,r1[0xc]
80007a74:	10 99       	mov	r9,r8
80007a76:	e2 19 00 1a 	andl	r9,0x1a,COH
80007a7a:	58 a9       	cp.w	r9,10
80007a7c:	c3 c1       	brne	80007af4 <_vfprintf_r+0xe4>
80007a7e:	82 79       	ld.sh	r9,r1[0xe]
80007a80:	30 0a       	mov	r10,0
80007a82:	f4 09 19 00 	cp.h	r9,r10
80007a86:	c3 75       	brlt	80007af4 <_vfprintf_r+0xe4>
80007a88:	a1 d8       	cbr	r8,0x1
80007a8a:	fb 58 05 d0 	st.h	sp[1488],r8
80007a8e:	62 88       	ld.w	r8,r1[0x20]
80007a90:	fb 48 05 e4 	st.w	sp[1508],r8
80007a94:	62 a8       	ld.w	r8,r1[0x28]
80007a96:	fb 48 05 ec 	st.w	sp[1516],r8
80007a9a:	fa c8 ff bc 	sub	r8,sp,-68
80007a9e:	fb 48 05 d4 	st.w	sp[1492],r8
80007aa2:	fb 48 05 c4 	st.w	sp[1476],r8
80007aa6:	e0 68 04 00 	mov	r8,1024
80007aaa:	fb 48 05 d8 	st.w	sp[1496],r8
80007aae:	fb 48 05 cc 	st.w	sp[1484],r8
80007ab2:	30 08       	mov	r8,0
80007ab4:	fb 59 05 d2 	st.h	sp[1490],r9
80007ab8:	0e 9a       	mov	r10,r7
80007aba:	41 09       	lddsp	r9,sp[0x40]
80007abc:	fa c7 fa 3c 	sub	r7,sp,-1476
80007ac0:	fb 48 05 dc 	st.w	sp[1500],r8
80007ac4:	0a 9c       	mov	r12,r5
80007ac6:	0e 9b       	mov	r11,r7
80007ac8:	ca 4f       	rcall	80007a10 <_vfprintf_r>
80007aca:	50 bc       	stdsp	sp[0x2c],r12
80007acc:	c0 95       	brlt	80007ade <_vfprintf_r+0xce>
80007ace:	0e 9b       	mov	r11,r7
80007ad0:	0a 9c       	mov	r12,r5
80007ad2:	e0 a0 16 f5 	rcall	8000a8bc <_fflush_r>
80007ad6:	40 be       	lddsp	lr,sp[0x2c]
80007ad8:	f9 be 01 ff 	movne	lr,-1
80007adc:	50 be       	stdsp	sp[0x2c],lr
80007ade:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007ae2:	ed b8 00 06 	bld	r8,0x6
80007ae6:	e0 81 0f 1a 	brne	8000991a <_vfprintf_r+0x1f0a>
80007aea:	82 68       	ld.sh	r8,r1[0xc]
80007aec:	a7 a8       	sbr	r8,0x6
80007aee:	a2 68       	st.h	r1[0xc],r8
80007af0:	e0 8f 0f 15 	bral	8000991a <_vfprintf_r+0x1f0a>
80007af4:	30 08       	mov	r8,0
80007af6:	fb 48 06 b4 	st.w	sp[1716],r8
80007afa:	fb 48 06 90 	st.w	sp[1680],r8
80007afe:	fb 48 06 8c 	st.w	sp[1676],r8
80007b02:	fb 48 06 b0 	st.w	sp[1712],r8
80007b06:	30 08       	mov	r8,0
80007b08:	30 09       	mov	r9,0
80007b0a:	50 a7       	stdsp	sp[0x28],r7
80007b0c:	50 78       	stdsp	sp[0x1c],r8
80007b0e:	fa c3 f9 e0 	sub	r3,sp,-1568
80007b12:	3f f8       	mov	r8,-1
80007b14:	50 59       	stdsp	sp[0x14],r9
80007b16:	fb 43 06 88 	st.w	sp[1672],r3
80007b1a:	fb 48 05 44 	st.w	sp[1348],r8
80007b1e:	12 9c       	mov	r12,r9
80007b20:	50 69       	stdsp	sp[0x18],r9
80007b22:	50 d9       	stdsp	sp[0x34],r9
80007b24:	50 e9       	stdsp	sp[0x38],r9
80007b26:	50 b9       	stdsp	sp[0x2c],r9
80007b28:	12 97       	mov	r7,r9
80007b2a:	0a 94       	mov	r4,r5
80007b2c:	40 a2       	lddsp	r2,sp[0x28]
80007b2e:	32 5a       	mov	r10,37
80007b30:	30 08       	mov	r8,0
80007b32:	c0 28       	rjmp	80007b36 <_vfprintf_r+0x126>
80007b34:	2f f2       	sub	r2,-1
80007b36:	05 89       	ld.ub	r9,r2[0x0]
80007b38:	f0 09 18 00 	cp.b	r9,r8
80007b3c:	5f 1b       	srne	r11
80007b3e:	f4 09 18 00 	cp.b	r9,r10
80007b42:	5f 19       	srne	r9
80007b44:	f3 eb 00 0b 	and	r11,r9,r11
80007b48:	f0 0b 18 00 	cp.b	r11,r8
80007b4c:	cf 41       	brne	80007b34 <_vfprintf_r+0x124>
80007b4e:	40 ab       	lddsp	r11,sp[0x28]
80007b50:	e4 0b 01 06 	sub	r6,r2,r11
80007b54:	c1 e0       	breq	80007b90 <_vfprintf_r+0x180>
80007b56:	fa f8 06 90 	ld.w	r8,sp[1680]
80007b5a:	0c 08       	add	r8,r6
80007b5c:	87 0b       	st.w	r3[0x0],r11
80007b5e:	fb 48 06 90 	st.w	sp[1680],r8
80007b62:	87 16       	st.w	r3[0x4],r6
80007b64:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007b68:	2f f8       	sub	r8,-1
80007b6a:	fb 48 06 8c 	st.w	sp[1676],r8
80007b6e:	58 78       	cp.w	r8,7
80007b70:	e0 89 00 04 	brgt	80007b78 <_vfprintf_r+0x168>
80007b74:	2f 83       	sub	r3,-8
80007b76:	c0 a8       	rjmp	80007b8a <_vfprintf_r+0x17a>
80007b78:	fa ca f9 78 	sub	r10,sp,-1672
80007b7c:	02 9b       	mov	r11,r1
80007b7e:	08 9c       	mov	r12,r4
80007b80:	c3 af       	rcall	800079f4 <__sprint_r>
80007b82:	e0 81 0e c6 	brne	8000990e <_vfprintf_r+0x1efe>
80007b86:	fa c3 f9 e0 	sub	r3,sp,-1568
80007b8a:	40 ba       	lddsp	r10,sp[0x2c]
80007b8c:	0c 0a       	add	r10,r6
80007b8e:	50 ba       	stdsp	sp[0x2c],r10
80007b90:	05 89       	ld.ub	r9,r2[0x0]
80007b92:	30 08       	mov	r8,0
80007b94:	f0 09 18 00 	cp.b	r9,r8
80007b98:	e0 80 0e aa 	breq	800098ec <_vfprintf_r+0x1edc>
80007b9c:	30 09       	mov	r9,0
80007b9e:	fb 68 06 bb 	st.b	sp[1723],r8
80007ba2:	0e 96       	mov	r6,r7
80007ba4:	e4 c8 ff ff 	sub	r8,r2,-1
80007ba8:	3f fe       	mov	lr,-1
80007baa:	50 93       	stdsp	sp[0x24],r3
80007bac:	50 41       	stdsp	sp[0x10],r1
80007bae:	0e 93       	mov	r3,r7
80007bb0:	04 91       	mov	r1,r2
80007bb2:	50 89       	stdsp	sp[0x20],r9
80007bb4:	50 a8       	stdsp	sp[0x28],r8
80007bb6:	50 2e       	stdsp	sp[0x8],lr
80007bb8:	50 39       	stdsp	sp[0xc],r9
80007bba:	12 95       	mov	r5,r9
80007bbc:	12 90       	mov	r0,r9
80007bbe:	10 97       	mov	r7,r8
80007bc0:	08 92       	mov	r2,r4
80007bc2:	c0 78       	rjmp	80007bd0 <_vfprintf_r+0x1c0>
80007bc4:	3f fc       	mov	r12,-1
80007bc6:	08 97       	mov	r7,r4
80007bc8:	50 2c       	stdsp	sp[0x8],r12
80007bca:	c0 38       	rjmp	80007bd0 <_vfprintf_r+0x1c0>
80007bcc:	30 0b       	mov	r11,0
80007bce:	50 3b       	stdsp	sp[0xc],r11
80007bd0:	0f 38       	ld.ub	r8,r7++
80007bd2:	c0 28       	rjmp	80007bd6 <_vfprintf_r+0x1c6>
80007bd4:	12 90       	mov	r0,r9
80007bd6:	f0 c9 00 20 	sub	r9,r8,32
80007bda:	e0 49 00 58 	cp.w	r9,88
80007bde:	e0 8b 0a 30 	brhi	8000903e <_vfprintf_r+0x162e>
80007be2:	fe ca b1 ee 	sub	r10,pc,-19986
80007be6:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007bea:	50 a7       	stdsp	sp[0x28],r7
80007bec:	50 80       	stdsp	sp[0x20],r0
80007bee:	0c 97       	mov	r7,r6
80007bf0:	04 94       	mov	r4,r2
80007bf2:	06 96       	mov	r6,r3
80007bf4:	02 92       	mov	r2,r1
80007bf6:	fe c9 af c6 	sub	r9,pc,-20538
80007bfa:	40 93       	lddsp	r3,sp[0x24]
80007bfc:	10 90       	mov	r0,r8
80007bfe:	40 41       	lddsp	r1,sp[0x10]
80007c00:	50 d9       	stdsp	sp[0x34],r9
80007c02:	e0 8f 08 8e 	bral	80008d1e <_vfprintf_r+0x130e>
80007c06:	30 08       	mov	r8,0
80007c08:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007c0c:	f0 09 18 00 	cp.b	r9,r8
80007c10:	ce 01       	brne	80007bd0 <_vfprintf_r+0x1c0>
80007c12:	32 08       	mov	r8,32
80007c14:	c6 e8       	rjmp	80007cf0 <_vfprintf_r+0x2e0>
80007c16:	a1 a5       	sbr	r5,0x0
80007c18:	cd cb       	rjmp	80007bd0 <_vfprintf_r+0x1c0>
80007c1a:	0f 89       	ld.ub	r9,r7[0x0]
80007c1c:	f2 c8 00 30 	sub	r8,r9,48
80007c20:	58 98       	cp.w	r8,9
80007c22:	e0 8b 00 1d 	brhi	80007c5c <_vfprintf_r+0x24c>
80007c26:	ee c8 ff ff 	sub	r8,r7,-1
80007c2a:	30 0b       	mov	r11,0
80007c2c:	23 09       	sub	r9,48
80007c2e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007c32:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007c36:	11 39       	ld.ub	r9,r8++
80007c38:	f2 ca 00 30 	sub	r10,r9,48
80007c3c:	58 9a       	cp.w	r10,9
80007c3e:	fe 98 ff f7 	brls	80007c2c <_vfprintf_r+0x21c>
80007c42:	e0 49 00 24 	cp.w	r9,36
80007c46:	cc 31       	brne	80007bcc <_vfprintf_r+0x1bc>
80007c48:	e0 4b 00 20 	cp.w	r11,32
80007c4c:	e0 89 0e 60 	brgt	8000990c <_vfprintf_r+0x1efc>
80007c50:	20 1b       	sub	r11,1
80007c52:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007c56:	12 3b       	cp.w	r11,r9
80007c58:	c0 95       	brlt	80007c6a <_vfprintf_r+0x25a>
80007c5a:	c1 08       	rjmp	80007c7a <_vfprintf_r+0x26a>
80007c5c:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007c60:	ec ca ff ff 	sub	r10,r6,-1
80007c64:	12 36       	cp.w	r6,r9
80007c66:	c1 f5       	brlt	80007ca4 <_vfprintf_r+0x294>
80007c68:	c2 68       	rjmp	80007cb4 <_vfprintf_r+0x2a4>
80007c6a:	fa ce f9 44 	sub	lr,sp,-1724
80007c6e:	10 97       	mov	r7,r8
80007c70:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007c74:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007c78:	c3 58       	rjmp	80007ce2 <_vfprintf_r+0x2d2>
80007c7a:	10 97       	mov	r7,r8
80007c7c:	fa c8 f9 50 	sub	r8,sp,-1712
80007c80:	1a d8       	st.w	--sp,r8
80007c82:	fa c8 fa b8 	sub	r8,sp,-1352
80007c86:	1a d8       	st.w	--sp,r8
80007c88:	fa c8 fb b4 	sub	r8,sp,-1100
80007c8c:	02 9a       	mov	r10,r1
80007c8e:	1a d8       	st.w	--sp,r8
80007c90:	04 9c       	mov	r12,r2
80007c92:	fa c8 f9 40 	sub	r8,sp,-1728
80007c96:	fa c9 ff b4 	sub	r9,sp,-76
80007c9a:	fe b0 fd 23 	rcall	800076e0 <get_arg>
80007c9e:	2f dd       	sub	sp,-12
80007ca0:	78 00       	ld.w	r0,r12[0x0]
80007ca2:	c2 08       	rjmp	80007ce2 <_vfprintf_r+0x2d2>
80007ca4:	fa cc f9 44 	sub	r12,sp,-1724
80007ca8:	14 96       	mov	r6,r10
80007caa:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007cae:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007cb2:	c1 88       	rjmp	80007ce2 <_vfprintf_r+0x2d2>
80007cb4:	41 08       	lddsp	r8,sp[0x40]
80007cb6:	59 f9       	cp.w	r9,31
80007cb8:	e0 89 00 11 	brgt	80007cda <_vfprintf_r+0x2ca>
80007cbc:	f0 cb ff fc 	sub	r11,r8,-4
80007cc0:	51 0b       	stdsp	sp[0x40],r11
80007cc2:	70 00       	ld.w	r0,r8[0x0]
80007cc4:	fa cb f9 44 	sub	r11,sp,-1724
80007cc8:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007ccc:	f1 40 fd 88 	st.w	r8[-632],r0
80007cd0:	2f f9       	sub	r9,-1
80007cd2:	14 96       	mov	r6,r10
80007cd4:	fb 49 06 b4 	st.w	sp[1716],r9
80007cd8:	c0 58       	rjmp	80007ce2 <_vfprintf_r+0x2d2>
80007cda:	70 00       	ld.w	r0,r8[0x0]
80007cdc:	14 96       	mov	r6,r10
80007cde:	2f c8       	sub	r8,-4
80007ce0:	51 08       	stdsp	sp[0x40],r8
80007ce2:	58 00       	cp.w	r0,0
80007ce4:	fe 94 ff 76 	brge	80007bd0 <_vfprintf_r+0x1c0>
80007ce8:	5c 30       	neg	r0
80007cea:	a3 a5       	sbr	r5,0x2
80007cec:	c7 2b       	rjmp	80007bd0 <_vfprintf_r+0x1c0>
80007cee:	32 b8       	mov	r8,43
80007cf0:	fb 68 06 bb 	st.b	sp[1723],r8
80007cf4:	c6 eb       	rjmp	80007bd0 <_vfprintf_r+0x1c0>
80007cf6:	0f 38       	ld.ub	r8,r7++
80007cf8:	e0 48 00 2a 	cp.w	r8,42
80007cfc:	c0 30       	breq	80007d02 <_vfprintf_r+0x2f2>
80007cfe:	30 09       	mov	r9,0
80007d00:	c7 98       	rjmp	80007df2 <_vfprintf_r+0x3e2>
80007d02:	0f 88       	ld.ub	r8,r7[0x0]
80007d04:	f0 c9 00 30 	sub	r9,r8,48
80007d08:	58 99       	cp.w	r9,9
80007d0a:	e0 8b 00 1f 	brhi	80007d48 <_vfprintf_r+0x338>
80007d0e:	ee c4 ff ff 	sub	r4,r7,-1
80007d12:	30 0b       	mov	r11,0
80007d14:	23 08       	sub	r8,48
80007d16:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007d1a:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007d1e:	09 38       	ld.ub	r8,r4++
80007d20:	f0 c9 00 30 	sub	r9,r8,48
80007d24:	58 99       	cp.w	r9,9
80007d26:	fe 98 ff f7 	brls	80007d14 <_vfprintf_r+0x304>
80007d2a:	e0 48 00 24 	cp.w	r8,36
80007d2e:	fe 91 ff 4f 	brne	80007bcc <_vfprintf_r+0x1bc>
80007d32:	e0 4b 00 20 	cp.w	r11,32
80007d36:	e0 89 0d eb 	brgt	8000990c <_vfprintf_r+0x1efc>
80007d3a:	20 1b       	sub	r11,1
80007d3c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d40:	10 3b       	cp.w	r11,r8
80007d42:	c0 a5       	brlt	80007d56 <_vfprintf_r+0x346>
80007d44:	c1 18       	rjmp	80007d66 <_vfprintf_r+0x356>
80007d46:	d7 03       	nop
80007d48:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007d4c:	ec c9 ff ff 	sub	r9,r6,-1
80007d50:	14 36       	cp.w	r6,r10
80007d52:	c1 f5       	brlt	80007d90 <_vfprintf_r+0x380>
80007d54:	c2 88       	rjmp	80007da4 <_vfprintf_r+0x394>
80007d56:	fa ca f9 44 	sub	r10,sp,-1724
80007d5a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007d5e:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007d62:	50 2b       	stdsp	sp[0x8],r11
80007d64:	c3 c8       	rjmp	80007ddc <_vfprintf_r+0x3cc>
80007d66:	fa c8 f9 50 	sub	r8,sp,-1712
80007d6a:	1a d8       	st.w	--sp,r8
80007d6c:	fa c8 fa b8 	sub	r8,sp,-1352
80007d70:	1a d8       	st.w	--sp,r8
80007d72:	fa c8 fb b4 	sub	r8,sp,-1100
80007d76:	02 9a       	mov	r10,r1
80007d78:	1a d8       	st.w	--sp,r8
80007d7a:	04 9c       	mov	r12,r2
80007d7c:	fa c8 f9 40 	sub	r8,sp,-1728
80007d80:	fa c9 ff b4 	sub	r9,sp,-76
80007d84:	fe b0 fc ae 	rcall	800076e0 <get_arg>
80007d88:	2f dd       	sub	sp,-12
80007d8a:	78 0c       	ld.w	r12,r12[0x0]
80007d8c:	50 2c       	stdsp	sp[0x8],r12
80007d8e:	c2 78       	rjmp	80007ddc <_vfprintf_r+0x3cc>
80007d90:	12 96       	mov	r6,r9
80007d92:	0e 94       	mov	r4,r7
80007d94:	fa c9 f9 44 	sub	r9,sp,-1724
80007d98:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007d9c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007da0:	50 28       	stdsp	sp[0x8],r8
80007da2:	c1 d8       	rjmp	80007ddc <_vfprintf_r+0x3cc>
80007da4:	41 08       	lddsp	r8,sp[0x40]
80007da6:	59 fa       	cp.w	r10,31
80007da8:	e0 89 00 14 	brgt	80007dd0 <_vfprintf_r+0x3c0>
80007dac:	f0 cb ff fc 	sub	r11,r8,-4
80007db0:	70 08       	ld.w	r8,r8[0x0]
80007db2:	51 0b       	stdsp	sp[0x40],r11
80007db4:	50 28       	stdsp	sp[0x8],r8
80007db6:	fa c6 f9 44 	sub	r6,sp,-1724
80007dba:	40 2e       	lddsp	lr,sp[0x8]
80007dbc:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007dc0:	f1 4e fd 88 	st.w	r8[-632],lr
80007dc4:	2f fa       	sub	r10,-1
80007dc6:	0e 94       	mov	r4,r7
80007dc8:	fb 4a 06 b4 	st.w	sp[1716],r10
80007dcc:	12 96       	mov	r6,r9
80007dce:	c0 78       	rjmp	80007ddc <_vfprintf_r+0x3cc>
80007dd0:	70 0c       	ld.w	r12,r8[0x0]
80007dd2:	0e 94       	mov	r4,r7
80007dd4:	2f c8       	sub	r8,-4
80007dd6:	50 2c       	stdsp	sp[0x8],r12
80007dd8:	12 96       	mov	r6,r9
80007dda:	51 08       	stdsp	sp[0x40],r8
80007ddc:	40 2b       	lddsp	r11,sp[0x8]
80007dde:	58 0b       	cp.w	r11,0
80007de0:	fe 95 fe f2 	brlt	80007bc4 <_vfprintf_r+0x1b4>
80007de4:	08 97       	mov	r7,r4
80007de6:	cf 5a       	rjmp	80007bd0 <_vfprintf_r+0x1c0>
80007de8:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007dec:	0f 38       	ld.ub	r8,r7++
80007dee:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007df2:	f0 ca 00 30 	sub	r10,r8,48
80007df6:	58 9a       	cp.w	r10,9
80007df8:	fe 98 ff f8 	brls	80007de8 <_vfprintf_r+0x3d8>
80007dfc:	3f fa       	mov	r10,-1
80007dfe:	f2 0a 0c 49 	max	r9,r9,r10
80007e02:	50 29       	stdsp	sp[0x8],r9
80007e04:	ce 9a       	rjmp	80007bd6 <_vfprintf_r+0x1c6>
80007e06:	a7 b5       	sbr	r5,0x7
80007e08:	ce 4a       	rjmp	80007bd0 <_vfprintf_r+0x1c0>
80007e0a:	30 09       	mov	r9,0
80007e0c:	23 08       	sub	r8,48
80007e0e:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007e12:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007e16:	0f 38       	ld.ub	r8,r7++
80007e18:	f0 ca 00 30 	sub	r10,r8,48
80007e1c:	58 9a       	cp.w	r10,9
80007e1e:	fe 98 ff f7 	brls	80007e0c <_vfprintf_r+0x3fc>
80007e22:	e0 48 00 24 	cp.w	r8,36
80007e26:	fe 91 fe d7 	brne	80007bd4 <_vfprintf_r+0x1c4>
80007e2a:	e0 49 00 20 	cp.w	r9,32
80007e2e:	e0 89 0d 6f 	brgt	8000990c <_vfprintf_r+0x1efc>
80007e32:	f2 c3 00 01 	sub	r3,r9,1
80007e36:	30 19       	mov	r9,1
80007e38:	50 39       	stdsp	sp[0xc],r9
80007e3a:	cc ba       	rjmp	80007bd0 <_vfprintf_r+0x1c0>
80007e3c:	a3 b5       	sbr	r5,0x3
80007e3e:	cc 9a       	rjmp	80007bd0 <_vfprintf_r+0x1c0>
80007e40:	a7 a5       	sbr	r5,0x6
80007e42:	cc 7a       	rjmp	80007bd0 <_vfprintf_r+0x1c0>
80007e44:	0a 98       	mov	r8,r5
80007e46:	a5 b5       	sbr	r5,0x5
80007e48:	a5 a8       	sbr	r8,0x4
80007e4a:	0f 89       	ld.ub	r9,r7[0x0]
80007e4c:	36 ce       	mov	lr,108
80007e4e:	fc 09 18 00 	cp.b	r9,lr
80007e52:	f7 b7 00 ff 	subeq	r7,-1
80007e56:	f0 05 17 10 	movne	r5,r8
80007e5a:	cb ba       	rjmp	80007bd0 <_vfprintf_r+0x1c0>
80007e5c:	a5 b5       	sbr	r5,0x5
80007e5e:	cb 9a       	rjmp	80007bd0 <_vfprintf_r+0x1c0>
80007e60:	50 a7       	stdsp	sp[0x28],r7
80007e62:	50 80       	stdsp	sp[0x20],r0
80007e64:	0c 97       	mov	r7,r6
80007e66:	10 90       	mov	r0,r8
80007e68:	06 96       	mov	r6,r3
80007e6a:	04 94       	mov	r4,r2
80007e6c:	40 93       	lddsp	r3,sp[0x24]
80007e6e:	02 92       	mov	r2,r1
80007e70:	0e 99       	mov	r9,r7
80007e72:	40 41       	lddsp	r1,sp[0x10]
80007e74:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e78:	40 3c       	lddsp	r12,sp[0xc]
80007e7a:	58 0c       	cp.w	r12,0
80007e7c:	c1 d0       	breq	80007eb6 <_vfprintf_r+0x4a6>
80007e7e:	10 36       	cp.w	r6,r8
80007e80:	c0 64       	brge	80007e8c <_vfprintf_r+0x47c>
80007e82:	fa cb f9 44 	sub	r11,sp,-1724
80007e86:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007e8a:	c1 d8       	rjmp	80007ec4 <_vfprintf_r+0x4b4>
80007e8c:	fa c8 f9 50 	sub	r8,sp,-1712
80007e90:	1a d8       	st.w	--sp,r8
80007e92:	fa c8 fa b8 	sub	r8,sp,-1352
80007e96:	1a d8       	st.w	--sp,r8
80007e98:	fa c8 fb b4 	sub	r8,sp,-1100
80007e9c:	1a d8       	st.w	--sp,r8
80007e9e:	fa c8 f9 40 	sub	r8,sp,-1728
80007ea2:	fa c9 ff b4 	sub	r9,sp,-76
80007ea6:	04 9a       	mov	r10,r2
80007ea8:	0c 9b       	mov	r11,r6
80007eaa:	08 9c       	mov	r12,r4
80007eac:	fe b0 fc 1a 	rcall	800076e0 <get_arg>
80007eb0:	2f dd       	sub	sp,-12
80007eb2:	19 b8       	ld.ub	r8,r12[0x3]
80007eb4:	c2 28       	rjmp	80007ef8 <_vfprintf_r+0x4e8>
80007eb6:	2f f7       	sub	r7,-1
80007eb8:	10 39       	cp.w	r9,r8
80007eba:	c0 84       	brge	80007eca <_vfprintf_r+0x4ba>
80007ebc:	fa ca f9 44 	sub	r10,sp,-1724
80007ec0:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007ec4:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007ec8:	c1 88       	rjmp	80007ef8 <_vfprintf_r+0x4e8>
80007eca:	41 09       	lddsp	r9,sp[0x40]
80007ecc:	59 f8       	cp.w	r8,31
80007ece:	e0 89 00 12 	brgt	80007ef2 <_vfprintf_r+0x4e2>
80007ed2:	f2 ca ff fc 	sub	r10,r9,-4
80007ed6:	51 0a       	stdsp	sp[0x40],r10
80007ed8:	72 09       	ld.w	r9,r9[0x0]
80007eda:	fa c6 f9 44 	sub	r6,sp,-1724
80007ede:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007ee2:	2f f8       	sub	r8,-1
80007ee4:	f5 49 fd 88 	st.w	r10[-632],r9
80007ee8:	fb 48 06 b4 	st.w	sp[1716],r8
80007eec:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007ef0:	c0 48       	rjmp	80007ef8 <_vfprintf_r+0x4e8>
80007ef2:	13 b8       	ld.ub	r8,r9[0x3]
80007ef4:	2f c9       	sub	r9,-4
80007ef6:	51 09       	stdsp	sp[0x40],r9
80007ef8:	fb 68 06 60 	st.b	sp[1632],r8
80007efc:	30 0e       	mov	lr,0
80007efe:	30 08       	mov	r8,0
80007f00:	30 12       	mov	r2,1
80007f02:	fb 68 06 bb 	st.b	sp[1723],r8
80007f06:	50 2e       	stdsp	sp[0x8],lr
80007f08:	e0 8f 08 ad 	bral	80009062 <_vfprintf_r+0x1652>
80007f0c:	50 a7       	stdsp	sp[0x28],r7
80007f0e:	50 80       	stdsp	sp[0x20],r0
80007f10:	0c 97       	mov	r7,r6
80007f12:	04 94       	mov	r4,r2
80007f14:	06 96       	mov	r6,r3
80007f16:	02 92       	mov	r2,r1
80007f18:	40 93       	lddsp	r3,sp[0x24]
80007f1a:	10 90       	mov	r0,r8
80007f1c:	40 41       	lddsp	r1,sp[0x10]
80007f1e:	a5 a5       	sbr	r5,0x4
80007f20:	c0 a8       	rjmp	80007f34 <_vfprintf_r+0x524>
80007f22:	50 a7       	stdsp	sp[0x28],r7
80007f24:	50 80       	stdsp	sp[0x20],r0
80007f26:	0c 97       	mov	r7,r6
80007f28:	04 94       	mov	r4,r2
80007f2a:	06 96       	mov	r6,r3
80007f2c:	02 92       	mov	r2,r1
80007f2e:	40 93       	lddsp	r3,sp[0x24]
80007f30:	10 90       	mov	r0,r8
80007f32:	40 41       	lddsp	r1,sp[0x10]
80007f34:	ed b5 00 05 	bld	r5,0x5
80007f38:	c5 11       	brne	80007fda <_vfprintf_r+0x5ca>
80007f3a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f3e:	40 3c       	lddsp	r12,sp[0xc]
80007f40:	58 0c       	cp.w	r12,0
80007f42:	c1 e0       	breq	80007f7e <_vfprintf_r+0x56e>
80007f44:	10 36       	cp.w	r6,r8
80007f46:	c0 64       	brge	80007f52 <_vfprintf_r+0x542>
80007f48:	fa cb f9 44 	sub	r11,sp,-1724
80007f4c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f50:	c2 08       	rjmp	80007f90 <_vfprintf_r+0x580>
80007f52:	fa c8 f9 50 	sub	r8,sp,-1712
80007f56:	1a d8       	st.w	--sp,r8
80007f58:	fa c8 fa b8 	sub	r8,sp,-1352
80007f5c:	0c 9b       	mov	r11,r6
80007f5e:	1a d8       	st.w	--sp,r8
80007f60:	fa c8 fb b4 	sub	r8,sp,-1100
80007f64:	1a d8       	st.w	--sp,r8
80007f66:	fa c9 ff b4 	sub	r9,sp,-76
80007f6a:	fa c8 f9 40 	sub	r8,sp,-1728
80007f6e:	04 9a       	mov	r10,r2
80007f70:	08 9c       	mov	r12,r4
80007f72:	fe b0 fb b7 	rcall	800076e0 <get_arg>
80007f76:	2f dd       	sub	sp,-12
80007f78:	78 1b       	ld.w	r11,r12[0x4]
80007f7a:	78 09       	ld.w	r9,r12[0x0]
80007f7c:	c2 b8       	rjmp	80007fd2 <_vfprintf_r+0x5c2>
80007f7e:	ee ca ff ff 	sub	r10,r7,-1
80007f82:	10 37       	cp.w	r7,r8
80007f84:	c0 b4       	brge	80007f9a <_vfprintf_r+0x58a>
80007f86:	fa c9 f9 44 	sub	r9,sp,-1724
80007f8a:	14 97       	mov	r7,r10
80007f8c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007f90:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007f94:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007f98:	c1 d8       	rjmp	80007fd2 <_vfprintf_r+0x5c2>
80007f9a:	41 09       	lddsp	r9,sp[0x40]
80007f9c:	59 f8       	cp.w	r8,31
80007f9e:	e0 89 00 14 	brgt	80007fc6 <_vfprintf_r+0x5b6>
80007fa2:	f2 cb ff f8 	sub	r11,r9,-8
80007fa6:	51 0b       	stdsp	sp[0x40],r11
80007fa8:	fa c6 f9 44 	sub	r6,sp,-1724
80007fac:	72 1b       	ld.w	r11,r9[0x4]
80007fae:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007fb2:	72 09       	ld.w	r9,r9[0x0]
80007fb4:	f9 4b fd 8c 	st.w	r12[-628],r11
80007fb8:	f9 49 fd 88 	st.w	r12[-632],r9
80007fbc:	2f f8       	sub	r8,-1
80007fbe:	14 97       	mov	r7,r10
80007fc0:	fb 48 06 b4 	st.w	sp[1716],r8
80007fc4:	c0 78       	rjmp	80007fd2 <_vfprintf_r+0x5c2>
80007fc6:	f2 c8 ff f8 	sub	r8,r9,-8
80007fca:	72 1b       	ld.w	r11,r9[0x4]
80007fcc:	14 97       	mov	r7,r10
80007fce:	51 08       	stdsp	sp[0x40],r8
80007fd0:	72 09       	ld.w	r9,r9[0x0]
80007fd2:	16 98       	mov	r8,r11
80007fd4:	fa e9 00 00 	st.d	sp[0],r8
80007fd8:	ca e8       	rjmp	80008134 <_vfprintf_r+0x724>
80007fda:	ed b5 00 04 	bld	r5,0x4
80007fde:	c1 71       	brne	8000800c <_vfprintf_r+0x5fc>
80007fe0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007fe4:	40 3e       	lddsp	lr,sp[0xc]
80007fe6:	58 0e       	cp.w	lr,0
80007fe8:	c0 80       	breq	80007ff8 <_vfprintf_r+0x5e8>
80007fea:	10 36       	cp.w	r6,r8
80007fec:	c6 94       	brge	800080be <_vfprintf_r+0x6ae>
80007fee:	fa cc f9 44 	sub	r12,sp,-1724
80007ff2:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007ff6:	c8 28       	rjmp	800080fa <_vfprintf_r+0x6ea>
80007ff8:	ee ca ff ff 	sub	r10,r7,-1
80007ffc:	10 37       	cp.w	r7,r8
80007ffe:	e0 84 00 81 	brge	80008100 <_vfprintf_r+0x6f0>
80008002:	fa cb f9 44 	sub	r11,sp,-1724
80008006:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000800a:	c7 78       	rjmp	800080f8 <_vfprintf_r+0x6e8>
8000800c:	ed b5 00 06 	bld	r5,0x6
80008010:	c4 b1       	brne	800080a6 <_vfprintf_r+0x696>
80008012:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008016:	40 3c       	lddsp	r12,sp[0xc]
80008018:	58 0c       	cp.w	r12,0
8000801a:	c1 d0       	breq	80008054 <_vfprintf_r+0x644>
8000801c:	10 36       	cp.w	r6,r8
8000801e:	c0 64       	brge	8000802a <_vfprintf_r+0x61a>
80008020:	fa cb f9 44 	sub	r11,sp,-1724
80008024:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008028:	c1 f8       	rjmp	80008066 <_vfprintf_r+0x656>
8000802a:	fa c8 f9 50 	sub	r8,sp,-1712
8000802e:	1a d8       	st.w	--sp,r8
80008030:	fa c8 fa b8 	sub	r8,sp,-1352
80008034:	1a d8       	st.w	--sp,r8
80008036:	fa c8 fb b4 	sub	r8,sp,-1100
8000803a:	1a d8       	st.w	--sp,r8
8000803c:	fa c8 f9 40 	sub	r8,sp,-1728
80008040:	fa c9 ff b4 	sub	r9,sp,-76
80008044:	04 9a       	mov	r10,r2
80008046:	0c 9b       	mov	r11,r6
80008048:	08 9c       	mov	r12,r4
8000804a:	fe b0 fb 4b 	rcall	800076e0 <get_arg>
8000804e:	2f dd       	sub	sp,-12
80008050:	98 18       	ld.sh	r8,r12[0x2]
80008052:	c2 68       	rjmp	8000809e <_vfprintf_r+0x68e>
80008054:	ee ca ff ff 	sub	r10,r7,-1
80008058:	10 37       	cp.w	r7,r8
8000805a:	c0 94       	brge	8000806c <_vfprintf_r+0x65c>
8000805c:	fa c9 f9 44 	sub	r9,sp,-1724
80008060:	14 97       	mov	r7,r10
80008062:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008066:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000806a:	c1 a8       	rjmp	8000809e <_vfprintf_r+0x68e>
8000806c:	41 09       	lddsp	r9,sp[0x40]
8000806e:	59 f8       	cp.w	r8,31
80008070:	e0 89 00 13 	brgt	80008096 <_vfprintf_r+0x686>
80008074:	f2 cb ff fc 	sub	r11,r9,-4
80008078:	51 0b       	stdsp	sp[0x40],r11
8000807a:	72 09       	ld.w	r9,r9[0x0]
8000807c:	fa c6 f9 44 	sub	r6,sp,-1724
80008080:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008084:	2f f8       	sub	r8,-1
80008086:	f7 49 fd 88 	st.w	r11[-632],r9
8000808a:	fb 48 06 b4 	st.w	sp[1716],r8
8000808e:	14 97       	mov	r7,r10
80008090:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008094:	c0 58       	rjmp	8000809e <_vfprintf_r+0x68e>
80008096:	92 18       	ld.sh	r8,r9[0x2]
80008098:	14 97       	mov	r7,r10
8000809a:	2f c9       	sub	r9,-4
8000809c:	51 09       	stdsp	sp[0x40],r9
8000809e:	50 18       	stdsp	sp[0x4],r8
800080a0:	bf 58       	asr	r8,0x1f
800080a2:	50 08       	stdsp	sp[0x0],r8
800080a4:	c4 88       	rjmp	80008134 <_vfprintf_r+0x724>
800080a6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080aa:	40 3c       	lddsp	r12,sp[0xc]
800080ac:	58 0c       	cp.w	r12,0
800080ae:	c1 d0       	breq	800080e8 <_vfprintf_r+0x6d8>
800080b0:	10 36       	cp.w	r6,r8
800080b2:	c0 64       	brge	800080be <_vfprintf_r+0x6ae>
800080b4:	fa cb f9 44 	sub	r11,sp,-1724
800080b8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800080bc:	c1 f8       	rjmp	800080fa <_vfprintf_r+0x6ea>
800080be:	fa c8 f9 50 	sub	r8,sp,-1712
800080c2:	1a d8       	st.w	--sp,r8
800080c4:	fa c8 fa b8 	sub	r8,sp,-1352
800080c8:	0c 9b       	mov	r11,r6
800080ca:	1a d8       	st.w	--sp,r8
800080cc:	fa c8 fb b4 	sub	r8,sp,-1100
800080d0:	04 9a       	mov	r10,r2
800080d2:	1a d8       	st.w	--sp,r8
800080d4:	08 9c       	mov	r12,r4
800080d6:	fa c8 f9 40 	sub	r8,sp,-1728
800080da:	fa c9 ff b4 	sub	r9,sp,-76
800080de:	fe b0 fb 01 	rcall	800076e0 <get_arg>
800080e2:	2f dd       	sub	sp,-12
800080e4:	78 0b       	ld.w	r11,r12[0x0]
800080e6:	c2 48       	rjmp	8000812e <_vfprintf_r+0x71e>
800080e8:	ee ca ff ff 	sub	r10,r7,-1
800080ec:	10 37       	cp.w	r7,r8
800080ee:	c0 94       	brge	80008100 <_vfprintf_r+0x6f0>
800080f0:	fa c9 f9 44 	sub	r9,sp,-1724
800080f4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800080f8:	14 97       	mov	r7,r10
800080fa:	ec fb fd 88 	ld.w	r11,r6[-632]
800080fe:	c1 88       	rjmp	8000812e <_vfprintf_r+0x71e>
80008100:	41 09       	lddsp	r9,sp[0x40]
80008102:	59 f8       	cp.w	r8,31
80008104:	e0 89 00 11 	brgt	80008126 <_vfprintf_r+0x716>
80008108:	f2 cb ff fc 	sub	r11,r9,-4
8000810c:	51 0b       	stdsp	sp[0x40],r11
8000810e:	fa c6 f9 44 	sub	r6,sp,-1724
80008112:	72 0b       	ld.w	r11,r9[0x0]
80008114:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008118:	f3 4b fd 88 	st.w	r9[-632],r11
8000811c:	2f f8       	sub	r8,-1
8000811e:	14 97       	mov	r7,r10
80008120:	fb 48 06 b4 	st.w	sp[1716],r8
80008124:	c0 58       	rjmp	8000812e <_vfprintf_r+0x71e>
80008126:	72 0b       	ld.w	r11,r9[0x0]
80008128:	14 97       	mov	r7,r10
8000812a:	2f c9       	sub	r9,-4
8000812c:	51 09       	stdsp	sp[0x40],r9
8000812e:	50 1b       	stdsp	sp[0x4],r11
80008130:	bf 5b       	asr	r11,0x1f
80008132:	50 0b       	stdsp	sp[0x0],r11
80008134:	fa ea 00 00 	ld.d	r10,sp[0]
80008138:	58 0a       	cp.w	r10,0
8000813a:	5c 2b       	cpc	r11
8000813c:	c0 e4       	brge	80008158 <_vfprintf_r+0x748>
8000813e:	30 08       	mov	r8,0
80008140:	fa ea 00 00 	ld.d	r10,sp[0]
80008144:	30 09       	mov	r9,0
80008146:	f0 0a 01 0a 	sub	r10,r8,r10
8000814a:	f2 0b 01 4b 	sbc	r11,r9,r11
8000814e:	32 d8       	mov	r8,45
80008150:	fa eb 00 00 	st.d	sp[0],r10
80008154:	fb 68 06 bb 	st.b	sp[1723],r8
80008158:	30 18       	mov	r8,1
8000815a:	e0 8f 06 fa 	bral	80008f4e <_vfprintf_r+0x153e>
8000815e:	50 a7       	stdsp	sp[0x28],r7
80008160:	50 80       	stdsp	sp[0x20],r0
80008162:	0c 97       	mov	r7,r6
80008164:	04 94       	mov	r4,r2
80008166:	06 96       	mov	r6,r3
80008168:	02 92       	mov	r2,r1
8000816a:	40 93       	lddsp	r3,sp[0x24]
8000816c:	10 90       	mov	r0,r8
8000816e:	40 41       	lddsp	r1,sp[0x10]
80008170:	0e 99       	mov	r9,r7
80008172:	ed b5 00 03 	bld	r5,0x3
80008176:	c4 11       	brne	800081f8 <_vfprintf_r+0x7e8>
80008178:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000817c:	40 3a       	lddsp	r10,sp[0xc]
8000817e:	58 0a       	cp.w	r10,0
80008180:	c1 90       	breq	800081b2 <_vfprintf_r+0x7a2>
80008182:	10 36       	cp.w	r6,r8
80008184:	c6 45       	brlt	8000824c <_vfprintf_r+0x83c>
80008186:	fa c8 f9 50 	sub	r8,sp,-1712
8000818a:	1a d8       	st.w	--sp,r8
8000818c:	fa c8 fa b8 	sub	r8,sp,-1352
80008190:	1a d8       	st.w	--sp,r8
80008192:	fa c8 fb b4 	sub	r8,sp,-1100
80008196:	0c 9b       	mov	r11,r6
80008198:	1a d8       	st.w	--sp,r8
8000819a:	04 9a       	mov	r10,r2
8000819c:	fa c8 f9 40 	sub	r8,sp,-1728
800081a0:	fa c9 ff b4 	sub	r9,sp,-76
800081a4:	08 9c       	mov	r12,r4
800081a6:	fe b0 fa 9d 	rcall	800076e0 <get_arg>
800081aa:	2f dd       	sub	sp,-12
800081ac:	78 16       	ld.w	r6,r12[0x4]
800081ae:	50 76       	stdsp	sp[0x1c],r6
800081b0:	c4 88       	rjmp	80008240 <_vfprintf_r+0x830>
800081b2:	2f f7       	sub	r7,-1
800081b4:	10 39       	cp.w	r9,r8
800081b6:	c0 c4       	brge	800081ce <_vfprintf_r+0x7be>
800081b8:	fa ce f9 44 	sub	lr,sp,-1724
800081bc:	fc 06 00 36 	add	r6,lr,r6<<0x3
800081c0:	ec fc fd 8c 	ld.w	r12,r6[-628]
800081c4:	50 7c       	stdsp	sp[0x1c],r12
800081c6:	ec f6 fd 88 	ld.w	r6,r6[-632]
800081ca:	50 56       	stdsp	sp[0x14],r6
800081cc:	c6 68       	rjmp	80008298 <_vfprintf_r+0x888>
800081ce:	41 09       	lddsp	r9,sp[0x40]
800081d0:	59 f8       	cp.w	r8,31
800081d2:	e0 89 00 10 	brgt	800081f2 <_vfprintf_r+0x7e2>
800081d6:	f2 ca ff f8 	sub	r10,r9,-8
800081da:	72 1b       	ld.w	r11,r9[0x4]
800081dc:	51 0a       	stdsp	sp[0x40],r10
800081de:	72 09       	ld.w	r9,r9[0x0]
800081e0:	fa ca f9 44 	sub	r10,sp,-1724
800081e4:	50 7b       	stdsp	sp[0x1c],r11
800081e6:	50 59       	stdsp	sp[0x14],r9
800081e8:	f4 08 00 39 	add	r9,r10,r8<<0x3
800081ec:	40 5b       	lddsp	r11,sp[0x14]
800081ee:	40 7a       	lddsp	r10,sp[0x1c]
800081f0:	c4 78       	rjmp	8000827e <_vfprintf_r+0x86e>
800081f2:	72 18       	ld.w	r8,r9[0x4]
800081f4:	50 78       	stdsp	sp[0x1c],r8
800081f6:	c4 c8       	rjmp	8000828e <_vfprintf_r+0x87e>
800081f8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081fc:	40 3e       	lddsp	lr,sp[0xc]
800081fe:	58 0e       	cp.w	lr,0
80008200:	c2 30       	breq	80008246 <_vfprintf_r+0x836>
80008202:	10 36       	cp.w	r6,r8
80008204:	c0 94       	brge	80008216 <_vfprintf_r+0x806>
80008206:	fa cc f9 44 	sub	r12,sp,-1724
8000820a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000820e:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008212:	50 7b       	stdsp	sp[0x1c],r11
80008214:	cd 9b       	rjmp	800081c6 <_vfprintf_r+0x7b6>
80008216:	fa c8 f9 50 	sub	r8,sp,-1712
8000821a:	1a d8       	st.w	--sp,r8
8000821c:	fa c8 fa b8 	sub	r8,sp,-1352
80008220:	04 9a       	mov	r10,r2
80008222:	1a d8       	st.w	--sp,r8
80008224:	fa c8 fb b4 	sub	r8,sp,-1100
80008228:	0c 9b       	mov	r11,r6
8000822a:	1a d8       	st.w	--sp,r8
8000822c:	08 9c       	mov	r12,r4
8000822e:	fa c8 f9 40 	sub	r8,sp,-1728
80008232:	fa c9 ff b4 	sub	r9,sp,-76
80008236:	fe b0 fa 55 	rcall	800076e0 <get_arg>
8000823a:	2f dd       	sub	sp,-12
8000823c:	78 1a       	ld.w	r10,r12[0x4]
8000823e:	50 7a       	stdsp	sp[0x1c],r10
80008240:	78 0c       	ld.w	r12,r12[0x0]
80008242:	50 5c       	stdsp	sp[0x14],r12
80008244:	c2 a8       	rjmp	80008298 <_vfprintf_r+0x888>
80008246:	2f f7       	sub	r7,-1
80008248:	10 39       	cp.w	r9,r8
8000824a:	c0 94       	brge	8000825c <_vfprintf_r+0x84c>
8000824c:	fa c9 f9 44 	sub	r9,sp,-1724
80008250:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008254:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008258:	50 78       	stdsp	sp[0x1c],r8
8000825a:	cb 6b       	rjmp	800081c6 <_vfprintf_r+0x7b6>
8000825c:	41 09       	lddsp	r9,sp[0x40]
8000825e:	59 f8       	cp.w	r8,31
80008260:	e0 89 00 15 	brgt	8000828a <_vfprintf_r+0x87a>
80008264:	f2 ca ff f8 	sub	r10,r9,-8
80008268:	72 16       	ld.w	r6,r9[0x4]
8000826a:	72 09       	ld.w	r9,r9[0x0]
8000826c:	51 0a       	stdsp	sp[0x40],r10
8000826e:	50 59       	stdsp	sp[0x14],r9
80008270:	fa ce f9 44 	sub	lr,sp,-1724
80008274:	50 76       	stdsp	sp[0x1c],r6
80008276:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000827a:	40 5b       	lddsp	r11,sp[0x14]
8000827c:	0c 9a       	mov	r10,r6
8000827e:	f2 eb fd 88 	st.d	r9[-632],r10
80008282:	2f f8       	sub	r8,-1
80008284:	fb 48 06 b4 	st.w	sp[1716],r8
80008288:	c0 88       	rjmp	80008298 <_vfprintf_r+0x888>
8000828a:	72 1c       	ld.w	r12,r9[0x4]
8000828c:	50 7c       	stdsp	sp[0x1c],r12
8000828e:	f2 c8 ff f8 	sub	r8,r9,-8
80008292:	51 08       	stdsp	sp[0x40],r8
80008294:	72 09       	ld.w	r9,r9[0x0]
80008296:	50 59       	stdsp	sp[0x14],r9
80008298:	40 5b       	lddsp	r11,sp[0x14]
8000829a:	40 7a       	lddsp	r10,sp[0x1c]
8000829c:	e0 a0 1a 2e 	rcall	8000b6f8 <__isinfd>
800082a0:	18 96       	mov	r6,r12
800082a2:	c1 70       	breq	800082d0 <_vfprintf_r+0x8c0>
800082a4:	30 08       	mov	r8,0
800082a6:	30 09       	mov	r9,0
800082a8:	40 5b       	lddsp	r11,sp[0x14]
800082aa:	40 7a       	lddsp	r10,sp[0x1c]
800082ac:	e0 a0 1e 8e 	rcall	8000bfc8 <__avr32_f64_cmp_lt>
800082b0:	c0 40       	breq	800082b8 <_vfprintf_r+0x8a8>
800082b2:	32 d8       	mov	r8,45
800082b4:	fb 68 06 bb 	st.b	sp[1723],r8
800082b8:	fe c8 b6 74 	sub	r8,pc,-18828
800082bc:	fe c6 b6 74 	sub	r6,pc,-18828
800082c0:	a7 d5       	cbr	r5,0x7
800082c2:	e0 40 00 47 	cp.w	r0,71
800082c6:	f0 06 17 a0 	movle	r6,r8
800082ca:	30 32       	mov	r2,3
800082cc:	e0 8f 06 ce 	bral	80009068 <_vfprintf_r+0x1658>
800082d0:	40 5b       	lddsp	r11,sp[0x14]
800082d2:	40 7a       	lddsp	r10,sp[0x1c]
800082d4:	e0 a0 1a 27 	rcall	8000b722 <__isnand>
800082d8:	c0 e0       	breq	800082f4 <_vfprintf_r+0x8e4>
800082da:	50 26       	stdsp	sp[0x8],r6
800082dc:	fe c8 b6 90 	sub	r8,pc,-18800
800082e0:	fe c6 b6 90 	sub	r6,pc,-18800
800082e4:	a7 d5       	cbr	r5,0x7
800082e6:	e0 40 00 47 	cp.w	r0,71
800082ea:	f0 06 17 a0 	movle	r6,r8
800082ee:	30 32       	mov	r2,3
800082f0:	e0 8f 06 c2 	bral	80009074 <_vfprintf_r+0x1664>
800082f4:	40 2a       	lddsp	r10,sp[0x8]
800082f6:	5b fa       	cp.w	r10,-1
800082f8:	c0 41       	brne	80008300 <_vfprintf_r+0x8f0>
800082fa:	30 69       	mov	r9,6
800082fc:	50 29       	stdsp	sp[0x8],r9
800082fe:	c1 18       	rjmp	80008320 <_vfprintf_r+0x910>
80008300:	e0 40 00 47 	cp.w	r0,71
80008304:	5f 09       	sreq	r9
80008306:	e0 40 00 67 	cp.w	r0,103
8000830a:	5f 08       	sreq	r8
8000830c:	f3 e8 10 08 	or	r8,r9,r8
80008310:	f8 08 18 00 	cp.b	r8,r12
80008314:	c0 60       	breq	80008320 <_vfprintf_r+0x910>
80008316:	40 28       	lddsp	r8,sp[0x8]
80008318:	58 08       	cp.w	r8,0
8000831a:	f9 b8 00 01 	moveq	r8,1
8000831e:	50 28       	stdsp	sp[0x8],r8
80008320:	40 78       	lddsp	r8,sp[0x1c]
80008322:	40 59       	lddsp	r9,sp[0x14]
80008324:	fa e9 06 94 	st.d	sp[1684],r8
80008328:	a9 a5       	sbr	r5,0x8
8000832a:	fa f8 06 94 	ld.w	r8,sp[1684]
8000832e:	58 08       	cp.w	r8,0
80008330:	c0 65       	brlt	8000833c <_vfprintf_r+0x92c>
80008332:	40 5e       	lddsp	lr,sp[0x14]
80008334:	30 0c       	mov	r12,0
80008336:	50 6e       	stdsp	sp[0x18],lr
80008338:	50 9c       	stdsp	sp[0x24],r12
8000833a:	c0 78       	rjmp	80008348 <_vfprintf_r+0x938>
8000833c:	40 5b       	lddsp	r11,sp[0x14]
8000833e:	32 da       	mov	r10,45
80008340:	ee 1b 80 00 	eorh	r11,0x8000
80008344:	50 9a       	stdsp	sp[0x24],r10
80008346:	50 6b       	stdsp	sp[0x18],r11
80008348:	e0 40 00 46 	cp.w	r0,70
8000834c:	5f 09       	sreq	r9
8000834e:	e0 40 00 66 	cp.w	r0,102
80008352:	5f 08       	sreq	r8
80008354:	f3 e8 10 08 	or	r8,r9,r8
80008358:	50 48       	stdsp	sp[0x10],r8
8000835a:	c0 40       	breq	80008362 <_vfprintf_r+0x952>
8000835c:	40 22       	lddsp	r2,sp[0x8]
8000835e:	30 39       	mov	r9,3
80008360:	c1 08       	rjmp	80008380 <_vfprintf_r+0x970>
80008362:	e0 40 00 45 	cp.w	r0,69
80008366:	5f 09       	sreq	r9
80008368:	e0 40 00 65 	cp.w	r0,101
8000836c:	5f 08       	sreq	r8
8000836e:	40 22       	lddsp	r2,sp[0x8]
80008370:	10 49       	or	r9,r8
80008372:	2f f2       	sub	r2,-1
80008374:	40 46       	lddsp	r6,sp[0x10]
80008376:	ec 09 18 00 	cp.b	r9,r6
8000837a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000837e:	30 29       	mov	r9,2
80008380:	fa c8 f9 5c 	sub	r8,sp,-1700
80008384:	1a d8       	st.w	--sp,r8
80008386:	fa c8 f9 54 	sub	r8,sp,-1708
8000838a:	1a d8       	st.w	--sp,r8
8000838c:	fa c8 f9 4c 	sub	r8,sp,-1716
80008390:	08 9c       	mov	r12,r4
80008392:	1a d8       	st.w	--sp,r8
80008394:	04 98       	mov	r8,r2
80008396:	40 9b       	lddsp	r11,sp[0x24]
80008398:	40 aa       	lddsp	r10,sp[0x28]
8000839a:	e0 a0 0c 9d 	rcall	80009cd4 <_dtoa_r>
8000839e:	e0 40 00 47 	cp.w	r0,71
800083a2:	5f 19       	srne	r9
800083a4:	e0 40 00 67 	cp.w	r0,103
800083a8:	5f 18       	srne	r8
800083aa:	18 96       	mov	r6,r12
800083ac:	2f dd       	sub	sp,-12
800083ae:	f3 e8 00 08 	and	r8,r9,r8
800083b2:	c0 41       	brne	800083ba <_vfprintf_r+0x9aa>
800083b4:	ed b5 00 00 	bld	r5,0x0
800083b8:	c3 01       	brne	80008418 <_vfprintf_r+0xa08>
800083ba:	ec 02 00 0e 	add	lr,r6,r2
800083be:	50 3e       	stdsp	sp[0xc],lr
800083c0:	40 4c       	lddsp	r12,sp[0x10]
800083c2:	58 0c       	cp.w	r12,0
800083c4:	c1 50       	breq	800083ee <_vfprintf_r+0x9de>
800083c6:	0d 89       	ld.ub	r9,r6[0x0]
800083c8:	33 08       	mov	r8,48
800083ca:	f0 09 18 00 	cp.b	r9,r8
800083ce:	c0 b1       	brne	800083e4 <_vfprintf_r+0x9d4>
800083d0:	30 08       	mov	r8,0
800083d2:	30 09       	mov	r9,0
800083d4:	40 6b       	lddsp	r11,sp[0x18]
800083d6:	40 7a       	lddsp	r10,sp[0x1c]
800083d8:	e0 a0 1d b1 	rcall	8000bf3a <__avr32_f64_cmp_eq>
800083dc:	fb b2 00 01 	rsubeq	r2,1
800083e0:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800083e4:	40 3b       	lddsp	r11,sp[0xc]
800083e6:	fa f8 06 ac 	ld.w	r8,sp[1708]
800083ea:	10 0b       	add	r11,r8
800083ec:	50 3b       	stdsp	sp[0xc],r11
800083ee:	40 6b       	lddsp	r11,sp[0x18]
800083f0:	30 08       	mov	r8,0
800083f2:	30 09       	mov	r9,0
800083f4:	40 7a       	lddsp	r10,sp[0x1c]
800083f6:	e0 a0 1d a2 	rcall	8000bf3a <__avr32_f64_cmp_eq>
800083fa:	c0 90       	breq	8000840c <_vfprintf_r+0x9fc>
800083fc:	40 3a       	lddsp	r10,sp[0xc]
800083fe:	fb 4a 06 a4 	st.w	sp[1700],r10
80008402:	c0 58       	rjmp	8000840c <_vfprintf_r+0x9fc>
80008404:	10 c9       	st.b	r8++,r9
80008406:	fb 48 06 a4 	st.w	sp[1700],r8
8000840a:	c0 28       	rjmp	8000840e <_vfprintf_r+0x9fe>
8000840c:	33 09       	mov	r9,48
8000840e:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008412:	40 3e       	lddsp	lr,sp[0xc]
80008414:	1c 38       	cp.w	r8,lr
80008416:	cf 73       	brcs	80008404 <_vfprintf_r+0x9f4>
80008418:	e0 40 00 47 	cp.w	r0,71
8000841c:	5f 09       	sreq	r9
8000841e:	e0 40 00 67 	cp.w	r0,103
80008422:	5f 08       	sreq	r8
80008424:	f3 e8 10 08 	or	r8,r9,r8
80008428:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000842c:	0c 19       	sub	r9,r6
8000842e:	50 69       	stdsp	sp[0x18],r9
80008430:	58 08       	cp.w	r8,0
80008432:	c0 b0       	breq	80008448 <_vfprintf_r+0xa38>
80008434:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008438:	5b d8       	cp.w	r8,-3
8000843a:	c0 55       	brlt	80008444 <_vfprintf_r+0xa34>
8000843c:	40 2c       	lddsp	r12,sp[0x8]
8000843e:	18 38       	cp.w	r8,r12
80008440:	e0 8a 00 6a 	brle	80008514 <_vfprintf_r+0xb04>
80008444:	20 20       	sub	r0,2
80008446:	c0 58       	rjmp	80008450 <_vfprintf_r+0xa40>
80008448:	e0 40 00 65 	cp.w	r0,101
8000844c:	e0 89 00 46 	brgt	800084d8 <_vfprintf_r+0xac8>
80008450:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008454:	fb 60 06 9c 	st.b	sp[1692],r0
80008458:	20 1b       	sub	r11,1
8000845a:	fb 4b 06 ac 	st.w	sp[1708],r11
8000845e:	c0 47       	brpl	80008466 <_vfprintf_r+0xa56>
80008460:	5c 3b       	neg	r11
80008462:	32 d8       	mov	r8,45
80008464:	c0 28       	rjmp	80008468 <_vfprintf_r+0xa58>
80008466:	32 b8       	mov	r8,43
80008468:	fb 68 06 9d 	st.b	sp[1693],r8
8000846c:	58 9b       	cp.w	r11,9
8000846e:	e0 8a 00 1d 	brle	800084a8 <_vfprintf_r+0xa98>
80008472:	fa c9 fa 35 	sub	r9,sp,-1483
80008476:	30 aa       	mov	r10,10
80008478:	12 98       	mov	r8,r9
8000847a:	0e 9c       	mov	r12,r7
8000847c:	0c 92       	mov	r2,r6
8000847e:	f6 0a 0c 06 	divs	r6,r11,r10
80008482:	0e 9b       	mov	r11,r7
80008484:	2d 0b       	sub	r11,-48
80008486:	10 fb       	st.b	--r8,r11
80008488:	0c 9b       	mov	r11,r6
8000848a:	58 96       	cp.w	r6,9
8000848c:	fe 99 ff f9 	brgt	8000847e <_vfprintf_r+0xa6e>
80008490:	2d 0b       	sub	r11,-48
80008492:	18 97       	mov	r7,r12
80008494:	04 96       	mov	r6,r2
80008496:	10 fb       	st.b	--r8,r11
80008498:	fa ca f9 62 	sub	r10,sp,-1694
8000849c:	c0 38       	rjmp	800084a2 <_vfprintf_r+0xa92>
8000849e:	11 3b       	ld.ub	r11,r8++
800084a0:	14 cb       	st.b	r10++,r11
800084a2:	12 38       	cp.w	r8,r9
800084a4:	cf d3       	brcs	8000849e <_vfprintf_r+0xa8e>
800084a6:	c0 98       	rjmp	800084b8 <_vfprintf_r+0xaa8>
800084a8:	2d 0b       	sub	r11,-48
800084aa:	33 08       	mov	r8,48
800084ac:	fb 6b 06 9f 	st.b	sp[1695],r11
800084b0:	fb 68 06 9e 	st.b	sp[1694],r8
800084b4:	fa ca f9 60 	sub	r10,sp,-1696
800084b8:	fa c8 f9 64 	sub	r8,sp,-1692
800084bc:	f4 08 01 08 	sub	r8,r10,r8
800084c0:	50 e8       	stdsp	sp[0x38],r8
800084c2:	10 92       	mov	r2,r8
800084c4:	40 6b       	lddsp	r11,sp[0x18]
800084c6:	16 02       	add	r2,r11
800084c8:	58 1b       	cp.w	r11,1
800084ca:	e0 89 00 05 	brgt	800084d4 <_vfprintf_r+0xac4>
800084ce:	ed b5 00 00 	bld	r5,0x0
800084d2:	c3 51       	brne	8000853c <_vfprintf_r+0xb2c>
800084d4:	2f f2       	sub	r2,-1
800084d6:	c3 38       	rjmp	8000853c <_vfprintf_r+0xb2c>
800084d8:	e0 40 00 66 	cp.w	r0,102
800084dc:	c1 c1       	brne	80008514 <_vfprintf_r+0xb04>
800084de:	fa f2 06 ac 	ld.w	r2,sp[1708]
800084e2:	58 02       	cp.w	r2,0
800084e4:	e0 8a 00 0c 	brle	800084fc <_vfprintf_r+0xaec>
800084e8:	40 2a       	lddsp	r10,sp[0x8]
800084ea:	58 0a       	cp.w	r10,0
800084ec:	c0 41       	brne	800084f4 <_vfprintf_r+0xae4>
800084ee:	ed b5 00 00 	bld	r5,0x0
800084f2:	c2 51       	brne	8000853c <_vfprintf_r+0xb2c>
800084f4:	2f f2       	sub	r2,-1
800084f6:	40 29       	lddsp	r9,sp[0x8]
800084f8:	12 02       	add	r2,r9
800084fa:	c0 b8       	rjmp	80008510 <_vfprintf_r+0xb00>
800084fc:	40 28       	lddsp	r8,sp[0x8]
800084fe:	58 08       	cp.w	r8,0
80008500:	c0 61       	brne	8000850c <_vfprintf_r+0xafc>
80008502:	ed b5 00 00 	bld	r5,0x0
80008506:	c0 30       	breq	8000850c <_vfprintf_r+0xafc>
80008508:	30 12       	mov	r2,1
8000850a:	c1 98       	rjmp	8000853c <_vfprintf_r+0xb2c>
8000850c:	40 22       	lddsp	r2,sp[0x8]
8000850e:	2f e2       	sub	r2,-2
80008510:	36 60       	mov	r0,102
80008512:	c1 58       	rjmp	8000853c <_vfprintf_r+0xb2c>
80008514:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008518:	40 6e       	lddsp	lr,sp[0x18]
8000851a:	1c 32       	cp.w	r2,lr
8000851c:	c0 65       	brlt	80008528 <_vfprintf_r+0xb18>
8000851e:	ed b5 00 00 	bld	r5,0x0
80008522:	f7 b2 00 ff 	subeq	r2,-1
80008526:	c0 a8       	rjmp	8000853a <_vfprintf_r+0xb2a>
80008528:	e4 08 11 02 	rsub	r8,r2,2
8000852c:	40 6c       	lddsp	r12,sp[0x18]
8000852e:	58 02       	cp.w	r2,0
80008530:	f0 02 17 a0 	movle	r2,r8
80008534:	f9 b2 09 01 	movgt	r2,1
80008538:	18 02       	add	r2,r12
8000853a:	36 70       	mov	r0,103
8000853c:	40 9b       	lddsp	r11,sp[0x24]
8000853e:	58 0b       	cp.w	r11,0
80008540:	e0 80 05 94 	breq	80009068 <_vfprintf_r+0x1658>
80008544:	32 d8       	mov	r8,45
80008546:	fb 68 06 bb 	st.b	sp[1723],r8
8000854a:	e0 8f 05 93 	bral	80009070 <_vfprintf_r+0x1660>
8000854e:	50 a7       	stdsp	sp[0x28],r7
80008550:	04 94       	mov	r4,r2
80008552:	0c 97       	mov	r7,r6
80008554:	02 92       	mov	r2,r1
80008556:	06 96       	mov	r6,r3
80008558:	40 41       	lddsp	r1,sp[0x10]
8000855a:	40 93       	lddsp	r3,sp[0x24]
8000855c:	0e 99       	mov	r9,r7
8000855e:	ed b5 00 05 	bld	r5,0x5
80008562:	c4 81       	brne	800085f2 <_vfprintf_r+0xbe2>
80008564:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008568:	40 3e       	lddsp	lr,sp[0xc]
8000856a:	58 0e       	cp.w	lr,0
8000856c:	c1 d0       	breq	800085a6 <_vfprintf_r+0xb96>
8000856e:	10 36       	cp.w	r6,r8
80008570:	c0 64       	brge	8000857c <_vfprintf_r+0xb6c>
80008572:	fa cc f9 44 	sub	r12,sp,-1724
80008576:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000857a:	c1 d8       	rjmp	800085b4 <_vfprintf_r+0xba4>
8000857c:	fa c8 f9 50 	sub	r8,sp,-1712
80008580:	1a d8       	st.w	--sp,r8
80008582:	fa c8 fa b8 	sub	r8,sp,-1352
80008586:	04 9a       	mov	r10,r2
80008588:	1a d8       	st.w	--sp,r8
8000858a:	fa c8 fb b4 	sub	r8,sp,-1100
8000858e:	0c 9b       	mov	r11,r6
80008590:	1a d8       	st.w	--sp,r8
80008592:	08 9c       	mov	r12,r4
80008594:	fa c8 f9 40 	sub	r8,sp,-1728
80008598:	fa c9 ff b4 	sub	r9,sp,-76
8000859c:	fe b0 f8 a2 	rcall	800076e0 <get_arg>
800085a0:	2f dd       	sub	sp,-12
800085a2:	78 0a       	ld.w	r10,r12[0x0]
800085a4:	c2 08       	rjmp	800085e4 <_vfprintf_r+0xbd4>
800085a6:	2f f7       	sub	r7,-1
800085a8:	10 39       	cp.w	r9,r8
800085aa:	c0 84       	brge	800085ba <_vfprintf_r+0xbaa>
800085ac:	fa cb f9 44 	sub	r11,sp,-1724
800085b0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085b4:	ec fa fd 88 	ld.w	r10,r6[-632]
800085b8:	c1 68       	rjmp	800085e4 <_vfprintf_r+0xbd4>
800085ba:	41 09       	lddsp	r9,sp[0x40]
800085bc:	59 f8       	cp.w	r8,31
800085be:	e0 89 00 10 	brgt	800085de <_vfprintf_r+0xbce>
800085c2:	f2 ca ff fc 	sub	r10,r9,-4
800085c6:	51 0a       	stdsp	sp[0x40],r10
800085c8:	fa c6 f9 44 	sub	r6,sp,-1724
800085cc:	72 0a       	ld.w	r10,r9[0x0]
800085ce:	ec 08 00 39 	add	r9,r6,r8<<0x3
800085d2:	f3 4a fd 88 	st.w	r9[-632],r10
800085d6:	2f f8       	sub	r8,-1
800085d8:	fb 48 06 b4 	st.w	sp[1716],r8
800085dc:	c0 48       	rjmp	800085e4 <_vfprintf_r+0xbd4>
800085de:	72 0a       	ld.w	r10,r9[0x0]
800085e0:	2f c9       	sub	r9,-4
800085e2:	51 09       	stdsp	sp[0x40],r9
800085e4:	40 be       	lddsp	lr,sp[0x2c]
800085e6:	1c 98       	mov	r8,lr
800085e8:	95 1e       	st.w	r10[0x4],lr
800085ea:	bf 58       	asr	r8,0x1f
800085ec:	95 08       	st.w	r10[0x0],r8
800085ee:	fe 9f fa 9f 	bral	80007b2c <_vfprintf_r+0x11c>
800085f2:	ed b5 00 04 	bld	r5,0x4
800085f6:	c4 80       	breq	80008686 <_vfprintf_r+0xc76>
800085f8:	e2 15 00 40 	andl	r5,0x40,COH
800085fc:	c4 50       	breq	80008686 <_vfprintf_r+0xc76>
800085fe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008602:	40 3c       	lddsp	r12,sp[0xc]
80008604:	58 0c       	cp.w	r12,0
80008606:	c1 d0       	breq	80008640 <_vfprintf_r+0xc30>
80008608:	10 36       	cp.w	r6,r8
8000860a:	c0 64       	brge	80008616 <_vfprintf_r+0xc06>
8000860c:	fa cb f9 44 	sub	r11,sp,-1724
80008610:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008614:	c1 d8       	rjmp	8000864e <_vfprintf_r+0xc3e>
80008616:	fa c8 f9 50 	sub	r8,sp,-1712
8000861a:	1a d8       	st.w	--sp,r8
8000861c:	fa c8 fa b8 	sub	r8,sp,-1352
80008620:	04 9a       	mov	r10,r2
80008622:	1a d8       	st.w	--sp,r8
80008624:	fa c8 fb b4 	sub	r8,sp,-1100
80008628:	0c 9b       	mov	r11,r6
8000862a:	1a d8       	st.w	--sp,r8
8000862c:	08 9c       	mov	r12,r4
8000862e:	fa c8 f9 40 	sub	r8,sp,-1728
80008632:	fa c9 ff b4 	sub	r9,sp,-76
80008636:	fe b0 f8 55 	rcall	800076e0 <get_arg>
8000863a:	2f dd       	sub	sp,-12
8000863c:	78 0a       	ld.w	r10,r12[0x0]
8000863e:	c2 08       	rjmp	8000867e <_vfprintf_r+0xc6e>
80008640:	2f f7       	sub	r7,-1
80008642:	10 39       	cp.w	r9,r8
80008644:	c0 84       	brge	80008654 <_vfprintf_r+0xc44>
80008646:	fa ca f9 44 	sub	r10,sp,-1724
8000864a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000864e:	ec fa fd 88 	ld.w	r10,r6[-632]
80008652:	c1 68       	rjmp	8000867e <_vfprintf_r+0xc6e>
80008654:	41 09       	lddsp	r9,sp[0x40]
80008656:	59 f8       	cp.w	r8,31
80008658:	e0 89 00 10 	brgt	80008678 <_vfprintf_r+0xc68>
8000865c:	f2 ca ff fc 	sub	r10,r9,-4
80008660:	51 0a       	stdsp	sp[0x40],r10
80008662:	fa c6 f9 44 	sub	r6,sp,-1724
80008666:	72 0a       	ld.w	r10,r9[0x0]
80008668:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000866c:	f3 4a fd 88 	st.w	r9[-632],r10
80008670:	2f f8       	sub	r8,-1
80008672:	fb 48 06 b4 	st.w	sp[1716],r8
80008676:	c0 48       	rjmp	8000867e <_vfprintf_r+0xc6e>
80008678:	72 0a       	ld.w	r10,r9[0x0]
8000867a:	2f c9       	sub	r9,-4
8000867c:	51 09       	stdsp	sp[0x40],r9
8000867e:	40 be       	lddsp	lr,sp[0x2c]
80008680:	b4 0e       	st.h	r10[0x0],lr
80008682:	fe 9f fa 55 	bral	80007b2c <_vfprintf_r+0x11c>
80008686:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000868a:	40 3c       	lddsp	r12,sp[0xc]
8000868c:	58 0c       	cp.w	r12,0
8000868e:	c1 d0       	breq	800086c8 <_vfprintf_r+0xcb8>
80008690:	10 36       	cp.w	r6,r8
80008692:	c0 64       	brge	8000869e <_vfprintf_r+0xc8e>
80008694:	fa cb f9 44 	sub	r11,sp,-1724
80008698:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000869c:	c1 d8       	rjmp	800086d6 <_vfprintf_r+0xcc6>
8000869e:	fa c8 f9 50 	sub	r8,sp,-1712
800086a2:	1a d8       	st.w	--sp,r8
800086a4:	fa c8 fa b8 	sub	r8,sp,-1352
800086a8:	04 9a       	mov	r10,r2
800086aa:	1a d8       	st.w	--sp,r8
800086ac:	fa c8 fb b4 	sub	r8,sp,-1100
800086b0:	0c 9b       	mov	r11,r6
800086b2:	1a d8       	st.w	--sp,r8
800086b4:	08 9c       	mov	r12,r4
800086b6:	fa c8 f9 40 	sub	r8,sp,-1728
800086ba:	fa c9 ff b4 	sub	r9,sp,-76
800086be:	fe b0 f8 11 	rcall	800076e0 <get_arg>
800086c2:	2f dd       	sub	sp,-12
800086c4:	78 0a       	ld.w	r10,r12[0x0]
800086c6:	c2 08       	rjmp	80008706 <_vfprintf_r+0xcf6>
800086c8:	2f f7       	sub	r7,-1
800086ca:	10 39       	cp.w	r9,r8
800086cc:	c0 84       	brge	800086dc <_vfprintf_r+0xccc>
800086ce:	fa ca f9 44 	sub	r10,sp,-1724
800086d2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800086d6:	ec fa fd 88 	ld.w	r10,r6[-632]
800086da:	c1 68       	rjmp	80008706 <_vfprintf_r+0xcf6>
800086dc:	41 09       	lddsp	r9,sp[0x40]
800086de:	59 f8       	cp.w	r8,31
800086e0:	e0 89 00 10 	brgt	80008700 <_vfprintf_r+0xcf0>
800086e4:	f2 ca ff fc 	sub	r10,r9,-4
800086e8:	51 0a       	stdsp	sp[0x40],r10
800086ea:	fa c6 f9 44 	sub	r6,sp,-1724
800086ee:	72 0a       	ld.w	r10,r9[0x0]
800086f0:	ec 08 00 39 	add	r9,r6,r8<<0x3
800086f4:	f3 4a fd 88 	st.w	r9[-632],r10
800086f8:	2f f8       	sub	r8,-1
800086fa:	fb 48 06 b4 	st.w	sp[1716],r8
800086fe:	c0 48       	rjmp	80008706 <_vfprintf_r+0xcf6>
80008700:	72 0a       	ld.w	r10,r9[0x0]
80008702:	2f c9       	sub	r9,-4
80008704:	51 09       	stdsp	sp[0x40],r9
80008706:	40 be       	lddsp	lr,sp[0x2c]
80008708:	95 0e       	st.w	r10[0x0],lr
8000870a:	fe 9f fa 11 	bral	80007b2c <_vfprintf_r+0x11c>
8000870e:	50 a7       	stdsp	sp[0x28],r7
80008710:	50 80       	stdsp	sp[0x20],r0
80008712:	0c 97       	mov	r7,r6
80008714:	04 94       	mov	r4,r2
80008716:	06 96       	mov	r6,r3
80008718:	02 92       	mov	r2,r1
8000871a:	40 93       	lddsp	r3,sp[0x24]
8000871c:	10 90       	mov	r0,r8
8000871e:	40 41       	lddsp	r1,sp[0x10]
80008720:	a5 a5       	sbr	r5,0x4
80008722:	c0 a8       	rjmp	80008736 <_vfprintf_r+0xd26>
80008724:	50 a7       	stdsp	sp[0x28],r7
80008726:	50 80       	stdsp	sp[0x20],r0
80008728:	0c 97       	mov	r7,r6
8000872a:	04 94       	mov	r4,r2
8000872c:	06 96       	mov	r6,r3
8000872e:	02 92       	mov	r2,r1
80008730:	40 93       	lddsp	r3,sp[0x24]
80008732:	10 90       	mov	r0,r8
80008734:	40 41       	lddsp	r1,sp[0x10]
80008736:	ed b5 00 05 	bld	r5,0x5
8000873a:	c5 d1       	brne	800087f4 <_vfprintf_r+0xde4>
8000873c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008740:	40 3c       	lddsp	r12,sp[0xc]
80008742:	58 0c       	cp.w	r12,0
80008744:	c2 60       	breq	80008790 <_vfprintf_r+0xd80>
80008746:	10 36       	cp.w	r6,r8
80008748:	c0 a4       	brge	8000875c <_vfprintf_r+0xd4c>
8000874a:	fa cb f9 44 	sub	r11,sp,-1724
8000874e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008752:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008756:	fa e9 00 00 	st.d	sp[0],r8
8000875a:	c1 88       	rjmp	8000878a <_vfprintf_r+0xd7a>
8000875c:	fa c8 f9 50 	sub	r8,sp,-1712
80008760:	1a d8       	st.w	--sp,r8
80008762:	fa c8 fa b8 	sub	r8,sp,-1352
80008766:	04 9a       	mov	r10,r2
80008768:	1a d8       	st.w	--sp,r8
8000876a:	0c 9b       	mov	r11,r6
8000876c:	fa c8 fb b4 	sub	r8,sp,-1100
80008770:	08 9c       	mov	r12,r4
80008772:	1a d8       	st.w	--sp,r8
80008774:	fa c8 f9 40 	sub	r8,sp,-1728
80008778:	fa c9 ff b4 	sub	r9,sp,-76
8000877c:	fe b0 f7 b2 	rcall	800076e0 <get_arg>
80008780:	2f dd       	sub	sp,-12
80008782:	f8 ea 00 00 	ld.d	r10,r12[0]
80008786:	fa eb 00 00 	st.d	sp[0],r10
8000878a:	30 08       	mov	r8,0
8000878c:	e0 8f 03 de 	bral	80008f48 <_vfprintf_r+0x1538>
80008790:	ee ca ff ff 	sub	r10,r7,-1
80008794:	10 37       	cp.w	r7,r8
80008796:	c0 b4       	brge	800087ac <_vfprintf_r+0xd9c>
80008798:	fa c9 f9 44 	sub	r9,sp,-1724
8000879c:	14 97       	mov	r7,r10
8000879e:	f2 06 00 36 	add	r6,r9,r6<<0x3
800087a2:	ec ea fd 88 	ld.d	r10,r6[-632]
800087a6:	fa eb 00 00 	st.d	sp[0],r10
800087aa:	c1 88       	rjmp	800087da <_vfprintf_r+0xdca>
800087ac:	41 09       	lddsp	r9,sp[0x40]
800087ae:	59 f8       	cp.w	r8,31
800087b0:	e0 89 00 18 	brgt	800087e0 <_vfprintf_r+0xdd0>
800087b4:	f2 e6 00 00 	ld.d	r6,r9[0]
800087b8:	f2 cb ff f8 	sub	r11,r9,-8
800087bc:	fa e7 00 00 	st.d	sp[0],r6
800087c0:	51 0b       	stdsp	sp[0x40],r11
800087c2:	fa c6 f9 44 	sub	r6,sp,-1724
800087c6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800087ca:	fa e6 00 00 	ld.d	r6,sp[0]
800087ce:	f2 e7 fd 88 	st.d	r9[-632],r6
800087d2:	2f f8       	sub	r8,-1
800087d4:	14 97       	mov	r7,r10
800087d6:	fb 48 06 b4 	st.w	sp[1716],r8
800087da:	40 38       	lddsp	r8,sp[0xc]
800087dc:	e0 8f 03 b6 	bral	80008f48 <_vfprintf_r+0x1538>
800087e0:	f2 e6 00 00 	ld.d	r6,r9[0]
800087e4:	40 38       	lddsp	r8,sp[0xc]
800087e6:	fa e7 00 00 	st.d	sp[0],r6
800087ea:	2f 89       	sub	r9,-8
800087ec:	14 97       	mov	r7,r10
800087ee:	51 09       	stdsp	sp[0x40],r9
800087f0:	e0 8f 03 ac 	bral	80008f48 <_vfprintf_r+0x1538>
800087f4:	ed b5 00 04 	bld	r5,0x4
800087f8:	c1 61       	brne	80008824 <_vfprintf_r+0xe14>
800087fa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087fe:	40 3e       	lddsp	lr,sp[0xc]
80008800:	58 0e       	cp.w	lr,0
80008802:	c0 80       	breq	80008812 <_vfprintf_r+0xe02>
80008804:	10 36       	cp.w	r6,r8
80008806:	c6 74       	brge	800088d4 <_vfprintf_r+0xec4>
80008808:	fa cc f9 44 	sub	r12,sp,-1724
8000880c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008810:	c8 08       	rjmp	80008910 <_vfprintf_r+0xf00>
80008812:	ee ca ff ff 	sub	r10,r7,-1
80008816:	10 37       	cp.w	r7,r8
80008818:	c7 f4       	brge	80008916 <_vfprintf_r+0xf06>
8000881a:	fa cb f9 44 	sub	r11,sp,-1724
8000881e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008822:	c7 68       	rjmp	8000890e <_vfprintf_r+0xefe>
80008824:	ed b5 00 06 	bld	r5,0x6
80008828:	c4 a1       	brne	800088bc <_vfprintf_r+0xeac>
8000882a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000882e:	40 3c       	lddsp	r12,sp[0xc]
80008830:	58 0c       	cp.w	r12,0
80008832:	c1 d0       	breq	8000886c <_vfprintf_r+0xe5c>
80008834:	10 36       	cp.w	r6,r8
80008836:	c0 64       	brge	80008842 <_vfprintf_r+0xe32>
80008838:	fa cb f9 44 	sub	r11,sp,-1724
8000883c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008840:	c1 f8       	rjmp	8000887e <_vfprintf_r+0xe6e>
80008842:	fa c8 f9 50 	sub	r8,sp,-1712
80008846:	1a d8       	st.w	--sp,r8
80008848:	fa c8 fa b8 	sub	r8,sp,-1352
8000884c:	1a d8       	st.w	--sp,r8
8000884e:	fa c8 fb b4 	sub	r8,sp,-1100
80008852:	1a d8       	st.w	--sp,r8
80008854:	fa c8 f9 40 	sub	r8,sp,-1728
80008858:	fa c9 ff b4 	sub	r9,sp,-76
8000885c:	04 9a       	mov	r10,r2
8000885e:	0c 9b       	mov	r11,r6
80008860:	08 9c       	mov	r12,r4
80008862:	fe b0 f7 3f 	rcall	800076e0 <get_arg>
80008866:	2f dd       	sub	sp,-12
80008868:	98 18       	ld.sh	r8,r12[0x2]
8000886a:	c2 68       	rjmp	800088b6 <_vfprintf_r+0xea6>
8000886c:	ee ca ff ff 	sub	r10,r7,-1
80008870:	10 37       	cp.w	r7,r8
80008872:	c0 94       	brge	80008884 <_vfprintf_r+0xe74>
80008874:	fa c9 f9 44 	sub	r9,sp,-1724
80008878:	14 97       	mov	r7,r10
8000887a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000887e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008882:	c1 a8       	rjmp	800088b6 <_vfprintf_r+0xea6>
80008884:	41 09       	lddsp	r9,sp[0x40]
80008886:	59 f8       	cp.w	r8,31
80008888:	e0 89 00 13 	brgt	800088ae <_vfprintf_r+0xe9e>
8000888c:	f2 cb ff fc 	sub	r11,r9,-4
80008890:	51 0b       	stdsp	sp[0x40],r11
80008892:	72 09       	ld.w	r9,r9[0x0]
80008894:	fa c6 f9 44 	sub	r6,sp,-1724
80008898:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000889c:	2f f8       	sub	r8,-1
8000889e:	f7 49 fd 88 	st.w	r11[-632],r9
800088a2:	fb 48 06 b4 	st.w	sp[1716],r8
800088a6:	14 97       	mov	r7,r10
800088a8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800088ac:	c0 58       	rjmp	800088b6 <_vfprintf_r+0xea6>
800088ae:	92 18       	ld.sh	r8,r9[0x2]
800088b0:	14 97       	mov	r7,r10
800088b2:	2f c9       	sub	r9,-4
800088b4:	51 09       	stdsp	sp[0x40],r9
800088b6:	5c 78       	castu.h	r8
800088b8:	50 18       	stdsp	sp[0x4],r8
800088ba:	c4 68       	rjmp	80008946 <_vfprintf_r+0xf36>
800088bc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088c0:	40 3c       	lddsp	r12,sp[0xc]
800088c2:	58 0c       	cp.w	r12,0
800088c4:	c1 d0       	breq	800088fe <_vfprintf_r+0xeee>
800088c6:	10 36       	cp.w	r6,r8
800088c8:	c0 64       	brge	800088d4 <_vfprintf_r+0xec4>
800088ca:	fa cb f9 44 	sub	r11,sp,-1724
800088ce:	f6 06 00 36 	add	r6,r11,r6<<0x3
800088d2:	c1 f8       	rjmp	80008910 <_vfprintf_r+0xf00>
800088d4:	fa c8 f9 50 	sub	r8,sp,-1712
800088d8:	1a d8       	st.w	--sp,r8
800088da:	fa c8 fa b8 	sub	r8,sp,-1352
800088de:	0c 9b       	mov	r11,r6
800088e0:	1a d8       	st.w	--sp,r8
800088e2:	fa c8 fb b4 	sub	r8,sp,-1100
800088e6:	04 9a       	mov	r10,r2
800088e8:	1a d8       	st.w	--sp,r8
800088ea:	08 9c       	mov	r12,r4
800088ec:	fa c8 f9 40 	sub	r8,sp,-1728
800088f0:	fa c9 ff b4 	sub	r9,sp,-76
800088f4:	fe b0 f6 f6 	rcall	800076e0 <get_arg>
800088f8:	2f dd       	sub	sp,-12
800088fa:	78 0b       	ld.w	r11,r12[0x0]
800088fc:	c2 48       	rjmp	80008944 <_vfprintf_r+0xf34>
800088fe:	ee ca ff ff 	sub	r10,r7,-1
80008902:	10 37       	cp.w	r7,r8
80008904:	c0 94       	brge	80008916 <_vfprintf_r+0xf06>
80008906:	fa c9 f9 44 	sub	r9,sp,-1724
8000890a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000890e:	14 97       	mov	r7,r10
80008910:	ec fb fd 88 	ld.w	r11,r6[-632]
80008914:	c1 88       	rjmp	80008944 <_vfprintf_r+0xf34>
80008916:	41 09       	lddsp	r9,sp[0x40]
80008918:	59 f8       	cp.w	r8,31
8000891a:	e0 89 00 11 	brgt	8000893c <_vfprintf_r+0xf2c>
8000891e:	f2 cb ff fc 	sub	r11,r9,-4
80008922:	51 0b       	stdsp	sp[0x40],r11
80008924:	fa c6 f9 44 	sub	r6,sp,-1724
80008928:	72 0b       	ld.w	r11,r9[0x0]
8000892a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000892e:	f3 4b fd 88 	st.w	r9[-632],r11
80008932:	2f f8       	sub	r8,-1
80008934:	14 97       	mov	r7,r10
80008936:	fb 48 06 b4 	st.w	sp[1716],r8
8000893a:	c0 58       	rjmp	80008944 <_vfprintf_r+0xf34>
8000893c:	72 0b       	ld.w	r11,r9[0x0]
8000893e:	14 97       	mov	r7,r10
80008940:	2f c9       	sub	r9,-4
80008942:	51 09       	stdsp	sp[0x40],r9
80008944:	50 1b       	stdsp	sp[0x4],r11
80008946:	30 0e       	mov	lr,0
80008948:	50 0e       	stdsp	sp[0x0],lr
8000894a:	1c 98       	mov	r8,lr
8000894c:	e0 8f 02 fe 	bral	80008f48 <_vfprintf_r+0x1538>
80008950:	50 a7       	stdsp	sp[0x28],r7
80008952:	50 80       	stdsp	sp[0x20],r0
80008954:	0c 97       	mov	r7,r6
80008956:	04 94       	mov	r4,r2
80008958:	06 96       	mov	r6,r3
8000895a:	02 92       	mov	r2,r1
8000895c:	40 93       	lddsp	r3,sp[0x24]
8000895e:	40 41       	lddsp	r1,sp[0x10]
80008960:	0e 99       	mov	r9,r7
80008962:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008966:	40 3c       	lddsp	r12,sp[0xc]
80008968:	58 0c       	cp.w	r12,0
8000896a:	c1 d0       	breq	800089a4 <_vfprintf_r+0xf94>
8000896c:	10 36       	cp.w	r6,r8
8000896e:	c0 64       	brge	8000897a <_vfprintf_r+0xf6a>
80008970:	fa cb f9 44 	sub	r11,sp,-1724
80008974:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008978:	c1 d8       	rjmp	800089b2 <_vfprintf_r+0xfa2>
8000897a:	fa c8 f9 50 	sub	r8,sp,-1712
8000897e:	1a d8       	st.w	--sp,r8
80008980:	fa c8 fa b8 	sub	r8,sp,-1352
80008984:	1a d8       	st.w	--sp,r8
80008986:	fa c8 fb b4 	sub	r8,sp,-1100
8000898a:	1a d8       	st.w	--sp,r8
8000898c:	fa c9 ff b4 	sub	r9,sp,-76
80008990:	fa c8 f9 40 	sub	r8,sp,-1728
80008994:	04 9a       	mov	r10,r2
80008996:	0c 9b       	mov	r11,r6
80008998:	08 9c       	mov	r12,r4
8000899a:	fe b0 f6 a3 	rcall	800076e0 <get_arg>
8000899e:	2f dd       	sub	sp,-12
800089a0:	78 09       	ld.w	r9,r12[0x0]
800089a2:	c2 18       	rjmp	800089e4 <_vfprintf_r+0xfd4>
800089a4:	2f f7       	sub	r7,-1
800089a6:	10 39       	cp.w	r9,r8
800089a8:	c0 84       	brge	800089b8 <_vfprintf_r+0xfa8>
800089aa:	fa ca f9 44 	sub	r10,sp,-1724
800089ae:	f4 06 00 36 	add	r6,r10,r6<<0x3
800089b2:	ec f9 fd 88 	ld.w	r9,r6[-632]
800089b6:	c1 78       	rjmp	800089e4 <_vfprintf_r+0xfd4>
800089b8:	41 09       	lddsp	r9,sp[0x40]
800089ba:	59 f8       	cp.w	r8,31
800089bc:	e0 89 00 10 	brgt	800089dc <_vfprintf_r+0xfcc>
800089c0:	f2 ca ff fc 	sub	r10,r9,-4
800089c4:	51 0a       	stdsp	sp[0x40],r10
800089c6:	fa c6 f9 44 	sub	r6,sp,-1724
800089ca:	72 09       	ld.w	r9,r9[0x0]
800089cc:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800089d0:	f5 49 fd 88 	st.w	r10[-632],r9
800089d4:	2f f8       	sub	r8,-1
800089d6:	fb 48 06 b4 	st.w	sp[1716],r8
800089da:	c0 58       	rjmp	800089e4 <_vfprintf_r+0xfd4>
800089dc:	f2 c8 ff fc 	sub	r8,r9,-4
800089e0:	51 08       	stdsp	sp[0x40],r8
800089e2:	72 09       	ld.w	r9,r9[0x0]
800089e4:	33 08       	mov	r8,48
800089e6:	fb 68 06 b8 	st.b	sp[1720],r8
800089ea:	37 88       	mov	r8,120
800089ec:	30 0e       	mov	lr,0
800089ee:	fb 68 06 b9 	st.b	sp[1721],r8
800089f2:	fe cc bd 9e 	sub	r12,pc,-16994
800089f6:	50 19       	stdsp	sp[0x4],r9
800089f8:	a1 b5       	sbr	r5,0x1
800089fa:	50 0e       	stdsp	sp[0x0],lr
800089fc:	50 dc       	stdsp	sp[0x34],r12
800089fe:	30 28       	mov	r8,2
80008a00:	37 80       	mov	r0,120
80008a02:	e0 8f 02 a3 	bral	80008f48 <_vfprintf_r+0x1538>
80008a06:	50 a7       	stdsp	sp[0x28],r7
80008a08:	50 80       	stdsp	sp[0x20],r0
80008a0a:	10 90       	mov	r0,r8
80008a0c:	30 08       	mov	r8,0
80008a0e:	fb 68 06 bb 	st.b	sp[1723],r8
80008a12:	0c 97       	mov	r7,r6
80008a14:	04 94       	mov	r4,r2
80008a16:	06 96       	mov	r6,r3
80008a18:	02 92       	mov	r2,r1
80008a1a:	40 93       	lddsp	r3,sp[0x24]
80008a1c:	40 41       	lddsp	r1,sp[0x10]
80008a1e:	0e 99       	mov	r9,r7
80008a20:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a24:	40 3b       	lddsp	r11,sp[0xc]
80008a26:	58 0b       	cp.w	r11,0
80008a28:	c1 d0       	breq	80008a62 <_vfprintf_r+0x1052>
80008a2a:	10 36       	cp.w	r6,r8
80008a2c:	c0 64       	brge	80008a38 <_vfprintf_r+0x1028>
80008a2e:	fa ca f9 44 	sub	r10,sp,-1724
80008a32:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008a36:	c1 d8       	rjmp	80008a70 <_vfprintf_r+0x1060>
80008a38:	fa c8 f9 50 	sub	r8,sp,-1712
80008a3c:	1a d8       	st.w	--sp,r8
80008a3e:	fa c8 fa b8 	sub	r8,sp,-1352
80008a42:	1a d8       	st.w	--sp,r8
80008a44:	fa c8 fb b4 	sub	r8,sp,-1100
80008a48:	0c 9b       	mov	r11,r6
80008a4a:	1a d8       	st.w	--sp,r8
80008a4c:	04 9a       	mov	r10,r2
80008a4e:	fa c8 f9 40 	sub	r8,sp,-1728
80008a52:	fa c9 ff b4 	sub	r9,sp,-76
80008a56:	08 9c       	mov	r12,r4
80008a58:	fe b0 f6 44 	rcall	800076e0 <get_arg>
80008a5c:	2f dd       	sub	sp,-12
80008a5e:	78 06       	ld.w	r6,r12[0x0]
80008a60:	c2 08       	rjmp	80008aa0 <_vfprintf_r+0x1090>
80008a62:	2f f7       	sub	r7,-1
80008a64:	10 39       	cp.w	r9,r8
80008a66:	c0 84       	brge	80008a76 <_vfprintf_r+0x1066>
80008a68:	fa c9 f9 44 	sub	r9,sp,-1724
80008a6c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008a70:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008a74:	c1 68       	rjmp	80008aa0 <_vfprintf_r+0x1090>
80008a76:	41 09       	lddsp	r9,sp[0x40]
80008a78:	59 f8       	cp.w	r8,31
80008a7a:	e0 89 00 10 	brgt	80008a9a <_vfprintf_r+0x108a>
80008a7e:	f2 ca ff fc 	sub	r10,r9,-4
80008a82:	51 0a       	stdsp	sp[0x40],r10
80008a84:	72 06       	ld.w	r6,r9[0x0]
80008a86:	fa ce f9 44 	sub	lr,sp,-1724
80008a8a:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008a8e:	f3 46 fd 88 	st.w	r9[-632],r6
80008a92:	2f f8       	sub	r8,-1
80008a94:	fb 48 06 b4 	st.w	sp[1716],r8
80008a98:	c0 48       	rjmp	80008aa0 <_vfprintf_r+0x1090>
80008a9a:	72 06       	ld.w	r6,r9[0x0]
80008a9c:	2f c9       	sub	r9,-4
80008a9e:	51 09       	stdsp	sp[0x40],r9
80008aa0:	40 2c       	lddsp	r12,sp[0x8]
80008aa2:	58 0c       	cp.w	r12,0
80008aa4:	c1 05       	brlt	80008ac4 <_vfprintf_r+0x10b4>
80008aa6:	18 9a       	mov	r10,r12
80008aa8:	30 0b       	mov	r11,0
80008aaa:	0c 9c       	mov	r12,r6
80008aac:	e0 a0 13 12 	rcall	8000b0d0 <memchr>
80008ab0:	e0 80 02 df 	breq	8000906e <_vfprintf_r+0x165e>
80008ab4:	f8 06 01 02 	sub	r2,r12,r6
80008ab8:	40 2b       	lddsp	r11,sp[0x8]
80008aba:	16 32       	cp.w	r2,r11
80008abc:	e0 89 02 d9 	brgt	8000906e <_vfprintf_r+0x165e>
80008ac0:	e0 8f 02 d4 	bral	80009068 <_vfprintf_r+0x1658>
80008ac4:	30 0a       	mov	r10,0
80008ac6:	0c 9c       	mov	r12,r6
80008ac8:	50 2a       	stdsp	sp[0x8],r10
80008aca:	e0 a0 16 73 	rcall	8000b7b0 <strlen>
80008ace:	18 92       	mov	r2,r12
80008ad0:	e0 8f 02 d2 	bral	80009074 <_vfprintf_r+0x1664>
80008ad4:	50 a7       	stdsp	sp[0x28],r7
80008ad6:	50 80       	stdsp	sp[0x20],r0
80008ad8:	0c 97       	mov	r7,r6
80008ada:	04 94       	mov	r4,r2
80008adc:	06 96       	mov	r6,r3
80008ade:	02 92       	mov	r2,r1
80008ae0:	40 93       	lddsp	r3,sp[0x24]
80008ae2:	10 90       	mov	r0,r8
80008ae4:	40 41       	lddsp	r1,sp[0x10]
80008ae6:	a5 a5       	sbr	r5,0x4
80008ae8:	c0 a8       	rjmp	80008afc <_vfprintf_r+0x10ec>
80008aea:	50 a7       	stdsp	sp[0x28],r7
80008aec:	50 80       	stdsp	sp[0x20],r0
80008aee:	0c 97       	mov	r7,r6
80008af0:	04 94       	mov	r4,r2
80008af2:	06 96       	mov	r6,r3
80008af4:	02 92       	mov	r2,r1
80008af6:	40 93       	lddsp	r3,sp[0x24]
80008af8:	10 90       	mov	r0,r8
80008afa:	40 41       	lddsp	r1,sp[0x10]
80008afc:	ed b5 00 05 	bld	r5,0x5
80008b00:	c5 61       	brne	80008bac <_vfprintf_r+0x119c>
80008b02:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b06:	40 39       	lddsp	r9,sp[0xc]
80008b08:	58 09       	cp.w	r9,0
80008b0a:	c2 10       	breq	80008b4c <_vfprintf_r+0x113c>
80008b0c:	10 36       	cp.w	r6,r8
80008b0e:	c0 74       	brge	80008b1c <_vfprintf_r+0x110c>
80008b10:	fa c8 f9 44 	sub	r8,sp,-1724
80008b14:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008b18:	c2 38       	rjmp	80008b5e <_vfprintf_r+0x114e>
80008b1a:	d7 03       	nop
80008b1c:	fa c8 f9 50 	sub	r8,sp,-1712
80008b20:	1a d8       	st.w	--sp,r8
80008b22:	fa c8 fa b8 	sub	r8,sp,-1352
80008b26:	1a d8       	st.w	--sp,r8
80008b28:	fa c8 fb b4 	sub	r8,sp,-1100
80008b2c:	1a d8       	st.w	--sp,r8
80008b2e:	fa c8 f9 40 	sub	r8,sp,-1728
80008b32:	fa c9 ff b4 	sub	r9,sp,-76
80008b36:	04 9a       	mov	r10,r2
80008b38:	0c 9b       	mov	r11,r6
80008b3a:	08 9c       	mov	r12,r4
80008b3c:	fe b0 f5 d2 	rcall	800076e0 <get_arg>
80008b40:	2f dd       	sub	sp,-12
80008b42:	f8 e8 00 00 	ld.d	r8,r12[0]
80008b46:	fa e9 00 00 	st.d	sp[0],r8
80008b4a:	c2 e8       	rjmp	80008ba6 <_vfprintf_r+0x1196>
80008b4c:	ee ca ff ff 	sub	r10,r7,-1
80008b50:	10 37       	cp.w	r7,r8
80008b52:	c0 b4       	brge	80008b68 <_vfprintf_r+0x1158>
80008b54:	fa c8 f9 44 	sub	r8,sp,-1724
80008b58:	14 97       	mov	r7,r10
80008b5a:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008b5e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008b62:	fa eb 00 00 	st.d	sp[0],r10
80008b66:	c2 08       	rjmp	80008ba6 <_vfprintf_r+0x1196>
80008b68:	41 09       	lddsp	r9,sp[0x40]
80008b6a:	59 f8       	cp.w	r8,31
80008b6c:	e0 89 00 16 	brgt	80008b98 <_vfprintf_r+0x1188>
80008b70:	f2 e6 00 00 	ld.d	r6,r9[0]
80008b74:	f2 cb ff f8 	sub	r11,r9,-8
80008b78:	fa e7 00 00 	st.d	sp[0],r6
80008b7c:	51 0b       	stdsp	sp[0x40],r11
80008b7e:	fa c6 f9 44 	sub	r6,sp,-1724
80008b82:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b86:	fa e6 00 00 	ld.d	r6,sp[0]
80008b8a:	f2 e7 fd 88 	st.d	r9[-632],r6
80008b8e:	2f f8       	sub	r8,-1
80008b90:	14 97       	mov	r7,r10
80008b92:	fb 48 06 b4 	st.w	sp[1716],r8
80008b96:	c0 88       	rjmp	80008ba6 <_vfprintf_r+0x1196>
80008b98:	f2 e6 00 00 	ld.d	r6,r9[0]
80008b9c:	2f 89       	sub	r9,-8
80008b9e:	fa e7 00 00 	st.d	sp[0],r6
80008ba2:	51 09       	stdsp	sp[0x40],r9
80008ba4:	14 97       	mov	r7,r10
80008ba6:	30 18       	mov	r8,1
80008ba8:	e0 8f 01 d0 	bral	80008f48 <_vfprintf_r+0x1538>
80008bac:	ed b5 00 04 	bld	r5,0x4
80008bb0:	c1 61       	brne	80008bdc <_vfprintf_r+0x11cc>
80008bb2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008bb6:	40 3e       	lddsp	lr,sp[0xc]
80008bb8:	58 0e       	cp.w	lr,0
80008bba:	c0 80       	breq	80008bca <_vfprintf_r+0x11ba>
80008bbc:	10 36       	cp.w	r6,r8
80008bbe:	c6 74       	brge	80008c8c <_vfprintf_r+0x127c>
80008bc0:	fa cc f9 44 	sub	r12,sp,-1724
80008bc4:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008bc8:	c8 08       	rjmp	80008cc8 <_vfprintf_r+0x12b8>
80008bca:	ee ca ff ff 	sub	r10,r7,-1
80008bce:	10 37       	cp.w	r7,r8
80008bd0:	c7 f4       	brge	80008cce <_vfprintf_r+0x12be>
80008bd2:	fa cb f9 44 	sub	r11,sp,-1724
80008bd6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008bda:	c7 68       	rjmp	80008cc6 <_vfprintf_r+0x12b6>
80008bdc:	ed b5 00 06 	bld	r5,0x6
80008be0:	c4 a1       	brne	80008c74 <_vfprintf_r+0x1264>
80008be2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008be6:	40 3c       	lddsp	r12,sp[0xc]
80008be8:	58 0c       	cp.w	r12,0
80008bea:	c1 d0       	breq	80008c24 <_vfprintf_r+0x1214>
80008bec:	10 36       	cp.w	r6,r8
80008bee:	c0 64       	brge	80008bfa <_vfprintf_r+0x11ea>
80008bf0:	fa cb f9 44 	sub	r11,sp,-1724
80008bf4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008bf8:	c1 f8       	rjmp	80008c36 <_vfprintf_r+0x1226>
80008bfa:	fa c8 f9 50 	sub	r8,sp,-1712
80008bfe:	1a d8       	st.w	--sp,r8
80008c00:	fa c8 fa b8 	sub	r8,sp,-1352
80008c04:	1a d8       	st.w	--sp,r8
80008c06:	fa c8 fb b4 	sub	r8,sp,-1100
80008c0a:	1a d8       	st.w	--sp,r8
80008c0c:	fa c8 f9 40 	sub	r8,sp,-1728
80008c10:	fa c9 ff b4 	sub	r9,sp,-76
80008c14:	04 9a       	mov	r10,r2
80008c16:	0c 9b       	mov	r11,r6
80008c18:	08 9c       	mov	r12,r4
80008c1a:	fe b0 f5 63 	rcall	800076e0 <get_arg>
80008c1e:	2f dd       	sub	sp,-12
80008c20:	98 18       	ld.sh	r8,r12[0x2]
80008c22:	c2 68       	rjmp	80008c6e <_vfprintf_r+0x125e>
80008c24:	ee ca ff ff 	sub	r10,r7,-1
80008c28:	10 37       	cp.w	r7,r8
80008c2a:	c0 94       	brge	80008c3c <_vfprintf_r+0x122c>
80008c2c:	fa c9 f9 44 	sub	r9,sp,-1724
80008c30:	14 97       	mov	r7,r10
80008c32:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008c36:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008c3a:	c1 a8       	rjmp	80008c6e <_vfprintf_r+0x125e>
80008c3c:	41 09       	lddsp	r9,sp[0x40]
80008c3e:	59 f8       	cp.w	r8,31
80008c40:	e0 89 00 13 	brgt	80008c66 <_vfprintf_r+0x1256>
80008c44:	f2 cb ff fc 	sub	r11,r9,-4
80008c48:	51 0b       	stdsp	sp[0x40],r11
80008c4a:	72 09       	ld.w	r9,r9[0x0]
80008c4c:	fa c6 f9 44 	sub	r6,sp,-1724
80008c50:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008c54:	2f f8       	sub	r8,-1
80008c56:	f7 49 fd 88 	st.w	r11[-632],r9
80008c5a:	fb 48 06 b4 	st.w	sp[1716],r8
80008c5e:	14 97       	mov	r7,r10
80008c60:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008c64:	c0 58       	rjmp	80008c6e <_vfprintf_r+0x125e>
80008c66:	92 18       	ld.sh	r8,r9[0x2]
80008c68:	14 97       	mov	r7,r10
80008c6a:	2f c9       	sub	r9,-4
80008c6c:	51 09       	stdsp	sp[0x40],r9
80008c6e:	5c 78       	castu.h	r8
80008c70:	50 18       	stdsp	sp[0x4],r8
80008c72:	c4 68       	rjmp	80008cfe <_vfprintf_r+0x12ee>
80008c74:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c78:	40 3c       	lddsp	r12,sp[0xc]
80008c7a:	58 0c       	cp.w	r12,0
80008c7c:	c1 d0       	breq	80008cb6 <_vfprintf_r+0x12a6>
80008c7e:	10 36       	cp.w	r6,r8
80008c80:	c0 64       	brge	80008c8c <_vfprintf_r+0x127c>
80008c82:	fa cb f9 44 	sub	r11,sp,-1724
80008c86:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c8a:	c1 f8       	rjmp	80008cc8 <_vfprintf_r+0x12b8>
80008c8c:	fa c8 f9 50 	sub	r8,sp,-1712
80008c90:	1a d8       	st.w	--sp,r8
80008c92:	fa c8 fa b8 	sub	r8,sp,-1352
80008c96:	0c 9b       	mov	r11,r6
80008c98:	1a d8       	st.w	--sp,r8
80008c9a:	fa c8 fb b4 	sub	r8,sp,-1100
80008c9e:	04 9a       	mov	r10,r2
80008ca0:	1a d8       	st.w	--sp,r8
80008ca2:	08 9c       	mov	r12,r4
80008ca4:	fa c8 f9 40 	sub	r8,sp,-1728
80008ca8:	fa c9 ff b4 	sub	r9,sp,-76
80008cac:	fe b0 f5 1a 	rcall	800076e0 <get_arg>
80008cb0:	2f dd       	sub	sp,-12
80008cb2:	78 0b       	ld.w	r11,r12[0x0]
80008cb4:	c2 48       	rjmp	80008cfc <_vfprintf_r+0x12ec>
80008cb6:	ee ca ff ff 	sub	r10,r7,-1
80008cba:	10 37       	cp.w	r7,r8
80008cbc:	c0 94       	brge	80008cce <_vfprintf_r+0x12be>
80008cbe:	fa c9 f9 44 	sub	r9,sp,-1724
80008cc2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008cc6:	14 97       	mov	r7,r10
80008cc8:	ec fb fd 88 	ld.w	r11,r6[-632]
80008ccc:	c1 88       	rjmp	80008cfc <_vfprintf_r+0x12ec>
80008cce:	41 09       	lddsp	r9,sp[0x40]
80008cd0:	59 f8       	cp.w	r8,31
80008cd2:	e0 89 00 11 	brgt	80008cf4 <_vfprintf_r+0x12e4>
80008cd6:	f2 cb ff fc 	sub	r11,r9,-4
80008cda:	51 0b       	stdsp	sp[0x40],r11
80008cdc:	fa c6 f9 44 	sub	r6,sp,-1724
80008ce0:	72 0b       	ld.w	r11,r9[0x0]
80008ce2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ce6:	f3 4b fd 88 	st.w	r9[-632],r11
80008cea:	2f f8       	sub	r8,-1
80008cec:	14 97       	mov	r7,r10
80008cee:	fb 48 06 b4 	st.w	sp[1716],r8
80008cf2:	c0 58       	rjmp	80008cfc <_vfprintf_r+0x12ec>
80008cf4:	72 0b       	ld.w	r11,r9[0x0]
80008cf6:	14 97       	mov	r7,r10
80008cf8:	2f c9       	sub	r9,-4
80008cfa:	51 09       	stdsp	sp[0x40],r9
80008cfc:	50 1b       	stdsp	sp[0x4],r11
80008cfe:	30 0e       	mov	lr,0
80008d00:	30 18       	mov	r8,1
80008d02:	50 0e       	stdsp	sp[0x0],lr
80008d04:	c2 29       	rjmp	80008f48 <_vfprintf_r+0x1538>
80008d06:	50 a7       	stdsp	sp[0x28],r7
80008d08:	50 80       	stdsp	sp[0x20],r0
80008d0a:	0c 97       	mov	r7,r6
80008d0c:	04 94       	mov	r4,r2
80008d0e:	06 96       	mov	r6,r3
80008d10:	02 92       	mov	r2,r1
80008d12:	fe cc c0 be 	sub	r12,pc,-16194
80008d16:	40 93       	lddsp	r3,sp[0x24]
80008d18:	10 90       	mov	r0,r8
80008d1a:	40 41       	lddsp	r1,sp[0x10]
80008d1c:	50 dc       	stdsp	sp[0x34],r12
80008d1e:	ed b5 00 05 	bld	r5,0x5
80008d22:	c5 51       	brne	80008dcc <_vfprintf_r+0x13bc>
80008d24:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d28:	40 3b       	lddsp	r11,sp[0xc]
80008d2a:	58 0b       	cp.w	r11,0
80008d2c:	c2 20       	breq	80008d70 <_vfprintf_r+0x1360>
80008d2e:	10 36       	cp.w	r6,r8
80008d30:	c0 a4       	brge	80008d44 <_vfprintf_r+0x1334>
80008d32:	fa ca f9 44 	sub	r10,sp,-1724
80008d36:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d3a:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008d3e:	fa e9 00 00 	st.d	sp[0],r8
80008d42:	cf 28       	rjmp	80008f26 <_vfprintf_r+0x1516>
80008d44:	fa c8 f9 50 	sub	r8,sp,-1712
80008d48:	1a d8       	st.w	--sp,r8
80008d4a:	fa c8 fa b8 	sub	r8,sp,-1352
80008d4e:	04 9a       	mov	r10,r2
80008d50:	1a d8       	st.w	--sp,r8
80008d52:	0c 9b       	mov	r11,r6
80008d54:	fa c8 fb b4 	sub	r8,sp,-1100
80008d58:	08 9c       	mov	r12,r4
80008d5a:	1a d8       	st.w	--sp,r8
80008d5c:	fa c8 f9 40 	sub	r8,sp,-1728
80008d60:	fa c9 ff b4 	sub	r9,sp,-76
80008d64:	fe b0 f4 be 	rcall	800076e0 <get_arg>
80008d68:	2f dd       	sub	sp,-12
80008d6a:	f8 ea 00 00 	ld.d	r10,r12[0]
80008d6e:	c0 c8       	rjmp	80008d86 <_vfprintf_r+0x1376>
80008d70:	ee ca ff ff 	sub	r10,r7,-1
80008d74:	10 37       	cp.w	r7,r8
80008d76:	c0 b4       	brge	80008d8c <_vfprintf_r+0x137c>
80008d78:	fa c9 f9 44 	sub	r9,sp,-1724
80008d7c:	14 97       	mov	r7,r10
80008d7e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d82:	ec ea fd 88 	ld.d	r10,r6[-632]
80008d86:	fa eb 00 00 	st.d	sp[0],r10
80008d8a:	cc e8       	rjmp	80008f26 <_vfprintf_r+0x1516>
80008d8c:	41 09       	lddsp	r9,sp[0x40]
80008d8e:	59 f8       	cp.w	r8,31
80008d90:	e0 89 00 16 	brgt	80008dbc <_vfprintf_r+0x13ac>
80008d94:	f2 e6 00 00 	ld.d	r6,r9[0]
80008d98:	f2 cb ff f8 	sub	r11,r9,-8
80008d9c:	fa e7 00 00 	st.d	sp[0],r6
80008da0:	51 0b       	stdsp	sp[0x40],r11
80008da2:	fa c6 f9 44 	sub	r6,sp,-1724
80008da6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008daa:	fa e6 00 00 	ld.d	r6,sp[0]
80008dae:	f2 e7 fd 88 	st.d	r9[-632],r6
80008db2:	2f f8       	sub	r8,-1
80008db4:	14 97       	mov	r7,r10
80008db6:	fb 48 06 b4 	st.w	sp[1716],r8
80008dba:	cb 68       	rjmp	80008f26 <_vfprintf_r+0x1516>
80008dbc:	f2 e6 00 00 	ld.d	r6,r9[0]
80008dc0:	2f 89       	sub	r9,-8
80008dc2:	fa e7 00 00 	st.d	sp[0],r6
80008dc6:	51 09       	stdsp	sp[0x40],r9
80008dc8:	14 97       	mov	r7,r10
80008dca:	ca e8       	rjmp	80008f26 <_vfprintf_r+0x1516>
80008dcc:	ed b5 00 04 	bld	r5,0x4
80008dd0:	c1 71       	brne	80008dfe <_vfprintf_r+0x13ee>
80008dd2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008dd6:	40 3e       	lddsp	lr,sp[0xc]
80008dd8:	58 0e       	cp.w	lr,0
80008dda:	c0 80       	breq	80008dea <_vfprintf_r+0x13da>
80008ddc:	10 36       	cp.w	r6,r8
80008dde:	c6 94       	brge	80008eb0 <_vfprintf_r+0x14a0>
80008de0:	fa cc f9 44 	sub	r12,sp,-1724
80008de4:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008de8:	c8 28       	rjmp	80008eec <_vfprintf_r+0x14dc>
80008dea:	ee ca ff ff 	sub	r10,r7,-1
80008dee:	10 37       	cp.w	r7,r8
80008df0:	e0 84 00 81 	brge	80008ef2 <_vfprintf_r+0x14e2>
80008df4:	fa cb f9 44 	sub	r11,sp,-1724
80008df8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008dfc:	c7 78       	rjmp	80008eea <_vfprintf_r+0x14da>
80008dfe:	ed b5 00 06 	bld	r5,0x6
80008e02:	c4 b1       	brne	80008e98 <_vfprintf_r+0x1488>
80008e04:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e08:	40 3c       	lddsp	r12,sp[0xc]
80008e0a:	58 0c       	cp.w	r12,0
80008e0c:	c1 d0       	breq	80008e46 <_vfprintf_r+0x1436>
80008e0e:	10 36       	cp.w	r6,r8
80008e10:	c0 64       	brge	80008e1c <_vfprintf_r+0x140c>
80008e12:	fa cb f9 44 	sub	r11,sp,-1724
80008e16:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e1a:	c1 f8       	rjmp	80008e58 <_vfprintf_r+0x1448>
80008e1c:	fa c8 f9 50 	sub	r8,sp,-1712
80008e20:	1a d8       	st.w	--sp,r8
80008e22:	fa c8 fa b8 	sub	r8,sp,-1352
80008e26:	1a d8       	st.w	--sp,r8
80008e28:	fa c8 fb b4 	sub	r8,sp,-1100
80008e2c:	1a d8       	st.w	--sp,r8
80008e2e:	fa c8 f9 40 	sub	r8,sp,-1728
80008e32:	fa c9 ff b4 	sub	r9,sp,-76
80008e36:	04 9a       	mov	r10,r2
80008e38:	0c 9b       	mov	r11,r6
80008e3a:	08 9c       	mov	r12,r4
80008e3c:	fe b0 f4 52 	rcall	800076e0 <get_arg>
80008e40:	2f dd       	sub	sp,-12
80008e42:	98 18       	ld.sh	r8,r12[0x2]
80008e44:	c2 78       	rjmp	80008e92 <_vfprintf_r+0x1482>
80008e46:	ee ca ff ff 	sub	r10,r7,-1
80008e4a:	10 37       	cp.w	r7,r8
80008e4c:	c0 a4       	brge	80008e60 <_vfprintf_r+0x1450>
80008e4e:	fa c9 f9 44 	sub	r9,sp,-1724
80008e52:	14 97       	mov	r7,r10
80008e54:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e58:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008e5c:	c1 b8       	rjmp	80008e92 <_vfprintf_r+0x1482>
80008e5e:	d7 03       	nop
80008e60:	41 09       	lddsp	r9,sp[0x40]
80008e62:	59 f8       	cp.w	r8,31
80008e64:	e0 89 00 13 	brgt	80008e8a <_vfprintf_r+0x147a>
80008e68:	f2 cb ff fc 	sub	r11,r9,-4
80008e6c:	51 0b       	stdsp	sp[0x40],r11
80008e6e:	72 09       	ld.w	r9,r9[0x0]
80008e70:	fa c6 f9 44 	sub	r6,sp,-1724
80008e74:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008e78:	2f f8       	sub	r8,-1
80008e7a:	f7 49 fd 88 	st.w	r11[-632],r9
80008e7e:	fb 48 06 b4 	st.w	sp[1716],r8
80008e82:	14 97       	mov	r7,r10
80008e84:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008e88:	c0 58       	rjmp	80008e92 <_vfprintf_r+0x1482>
80008e8a:	92 18       	ld.sh	r8,r9[0x2]
80008e8c:	14 97       	mov	r7,r10
80008e8e:	2f c9       	sub	r9,-4
80008e90:	51 09       	stdsp	sp[0x40],r9
80008e92:	5c 78       	castu.h	r8
80008e94:	50 18       	stdsp	sp[0x4],r8
80008e96:	c4 68       	rjmp	80008f22 <_vfprintf_r+0x1512>
80008e98:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e9c:	40 3c       	lddsp	r12,sp[0xc]
80008e9e:	58 0c       	cp.w	r12,0
80008ea0:	c1 d0       	breq	80008eda <_vfprintf_r+0x14ca>
80008ea2:	10 36       	cp.w	r6,r8
80008ea4:	c0 64       	brge	80008eb0 <_vfprintf_r+0x14a0>
80008ea6:	fa cb f9 44 	sub	r11,sp,-1724
80008eaa:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008eae:	c1 f8       	rjmp	80008eec <_vfprintf_r+0x14dc>
80008eb0:	fa c8 f9 50 	sub	r8,sp,-1712
80008eb4:	1a d8       	st.w	--sp,r8
80008eb6:	fa c8 fa b8 	sub	r8,sp,-1352
80008eba:	0c 9b       	mov	r11,r6
80008ebc:	1a d8       	st.w	--sp,r8
80008ebe:	fa c8 fb b4 	sub	r8,sp,-1100
80008ec2:	04 9a       	mov	r10,r2
80008ec4:	1a d8       	st.w	--sp,r8
80008ec6:	08 9c       	mov	r12,r4
80008ec8:	fa c8 f9 40 	sub	r8,sp,-1728
80008ecc:	fa c9 ff b4 	sub	r9,sp,-76
80008ed0:	fe b0 f4 08 	rcall	800076e0 <get_arg>
80008ed4:	2f dd       	sub	sp,-12
80008ed6:	78 0b       	ld.w	r11,r12[0x0]
80008ed8:	c2 48       	rjmp	80008f20 <_vfprintf_r+0x1510>
80008eda:	ee ca ff ff 	sub	r10,r7,-1
80008ede:	10 37       	cp.w	r7,r8
80008ee0:	c0 94       	brge	80008ef2 <_vfprintf_r+0x14e2>
80008ee2:	fa c9 f9 44 	sub	r9,sp,-1724
80008ee6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008eea:	14 97       	mov	r7,r10
80008eec:	ec fb fd 88 	ld.w	r11,r6[-632]
80008ef0:	c1 88       	rjmp	80008f20 <_vfprintf_r+0x1510>
80008ef2:	41 09       	lddsp	r9,sp[0x40]
80008ef4:	59 f8       	cp.w	r8,31
80008ef6:	e0 89 00 11 	brgt	80008f18 <_vfprintf_r+0x1508>
80008efa:	f2 cb ff fc 	sub	r11,r9,-4
80008efe:	51 0b       	stdsp	sp[0x40],r11
80008f00:	fa c6 f9 44 	sub	r6,sp,-1724
80008f04:	72 0b       	ld.w	r11,r9[0x0]
80008f06:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008f0a:	f3 4b fd 88 	st.w	r9[-632],r11
80008f0e:	2f f8       	sub	r8,-1
80008f10:	14 97       	mov	r7,r10
80008f12:	fb 48 06 b4 	st.w	sp[1716],r8
80008f16:	c0 58       	rjmp	80008f20 <_vfprintf_r+0x1510>
80008f18:	72 0b       	ld.w	r11,r9[0x0]
80008f1a:	14 97       	mov	r7,r10
80008f1c:	2f c9       	sub	r9,-4
80008f1e:	51 09       	stdsp	sp[0x40],r9
80008f20:	50 1b       	stdsp	sp[0x4],r11
80008f22:	30 0e       	mov	lr,0
80008f24:	50 0e       	stdsp	sp[0x0],lr
80008f26:	40 08       	lddsp	r8,sp[0x0]
80008f28:	40 1c       	lddsp	r12,sp[0x4]
80008f2a:	18 48       	or	r8,r12
80008f2c:	5f 19       	srne	r9
80008f2e:	0a 98       	mov	r8,r5
80008f30:	eb e9 00 09 	and	r9,r5,r9
80008f34:	a1 b8       	sbr	r8,0x1
80008f36:	58 09       	cp.w	r9,0
80008f38:	c0 70       	breq	80008f46 <_vfprintf_r+0x1536>
80008f3a:	10 95       	mov	r5,r8
80008f3c:	fb 60 06 b9 	st.b	sp[1721],r0
80008f40:	33 08       	mov	r8,48
80008f42:	fb 68 06 b8 	st.b	sp[1720],r8
80008f46:	30 28       	mov	r8,2
80008f48:	30 09       	mov	r9,0
80008f4a:	fb 69 06 bb 	st.b	sp[1723],r9
80008f4e:	0a 99       	mov	r9,r5
80008f50:	a7 d9       	cbr	r9,0x7
80008f52:	40 2b       	lddsp	r11,sp[0x8]
80008f54:	40 16       	lddsp	r6,sp[0x4]
80008f56:	58 0b       	cp.w	r11,0
80008f58:	5f 1a       	srne	r10
80008f5a:	f2 05 17 40 	movge	r5,r9
80008f5e:	fa c2 f9 78 	sub	r2,sp,-1672
80008f62:	40 09       	lddsp	r9,sp[0x0]
80008f64:	0c 49       	or	r9,r6
80008f66:	5f 19       	srne	r9
80008f68:	f5 e9 10 09 	or	r9,r10,r9
80008f6c:	c5 c0       	breq	80009024 <_vfprintf_r+0x1614>
80008f6e:	30 19       	mov	r9,1
80008f70:	f2 08 18 00 	cp.b	r8,r9
80008f74:	c0 60       	breq	80008f80 <_vfprintf_r+0x1570>
80008f76:	30 29       	mov	r9,2
80008f78:	f2 08 18 00 	cp.b	r8,r9
80008f7c:	c0 41       	brne	80008f84 <_vfprintf_r+0x1574>
80008f7e:	c3 c8       	rjmp	80008ff6 <_vfprintf_r+0x15e6>
80008f80:	04 96       	mov	r6,r2
80008f82:	c3 08       	rjmp	80008fe2 <_vfprintf_r+0x15d2>
80008f84:	04 96       	mov	r6,r2
80008f86:	fa e8 00 00 	ld.d	r8,sp[0]
80008f8a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008f8e:	2d 0a       	sub	r10,-48
80008f90:	0c fa       	st.b	--r6,r10
80008f92:	f0 0b 16 03 	lsr	r11,r8,0x3
80008f96:	f2 0c 16 03 	lsr	r12,r9,0x3
80008f9a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008f9e:	18 99       	mov	r9,r12
80008fa0:	16 98       	mov	r8,r11
80008fa2:	58 08       	cp.w	r8,0
80008fa4:	5c 29       	cpc	r9
80008fa6:	cf 21       	brne	80008f8a <_vfprintf_r+0x157a>
80008fa8:	fa e9 00 00 	st.d	sp[0],r8
80008fac:	ed b5 00 00 	bld	r5,0x0
80008fb0:	c4 51       	brne	8000903a <_vfprintf_r+0x162a>
80008fb2:	33 09       	mov	r9,48
80008fb4:	f2 0a 18 00 	cp.b	r10,r9
80008fb8:	c4 10       	breq	8000903a <_vfprintf_r+0x162a>
80008fba:	0c f9       	st.b	--r6,r9
80008fbc:	c3 f8       	rjmp	8000903a <_vfprintf_r+0x162a>
80008fbe:	fa ea 00 00 	ld.d	r10,sp[0]
80008fc2:	30 a8       	mov	r8,10
80008fc4:	30 09       	mov	r9,0
80008fc6:	e0 a0 19 c1 	rcall	8000c348 <__avr32_umod64>
80008fca:	30 a8       	mov	r8,10
80008fcc:	2d 0a       	sub	r10,-48
80008fce:	30 09       	mov	r9,0
80008fd0:	ac 8a       	st.b	r6[0x0],r10
80008fd2:	fa ea 00 00 	ld.d	r10,sp[0]
80008fd6:	fe b0 ed 51 	rcall	80006a78 <__avr32_udiv64>
80008fda:	16 99       	mov	r9,r11
80008fdc:	14 98       	mov	r8,r10
80008fde:	fa e9 00 00 	st.d	sp[0],r8
80008fe2:	20 16       	sub	r6,1
80008fe4:	fa ea 00 00 	ld.d	r10,sp[0]
80008fe8:	58 9a       	cp.w	r10,9
80008fea:	5c 2b       	cpc	r11
80008fec:	fe 9b ff e9 	brhi	80008fbe <_vfprintf_r+0x15ae>
80008ff0:	1b f8       	ld.ub	r8,sp[0x7]
80008ff2:	2d 08       	sub	r8,-48
80008ff4:	c2 08       	rjmp	80009034 <_vfprintf_r+0x1624>
80008ff6:	04 96       	mov	r6,r2
80008ff8:	fa e8 00 00 	ld.d	r8,sp[0]
80008ffc:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009000:	40 de       	lddsp	lr,sp[0x34]
80009002:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009006:	0c fa       	st.b	--r6,r10
80009008:	f2 0b 16 04 	lsr	r11,r9,0x4
8000900c:	f0 0a 16 04 	lsr	r10,r8,0x4
80009010:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009014:	16 99       	mov	r9,r11
80009016:	14 98       	mov	r8,r10
80009018:	58 08       	cp.w	r8,0
8000901a:	5c 29       	cpc	r9
8000901c:	cf 01       	brne	80008ffc <_vfprintf_r+0x15ec>
8000901e:	fa e9 00 00 	st.d	sp[0],r8
80009022:	c0 c8       	rjmp	8000903a <_vfprintf_r+0x162a>
80009024:	58 08       	cp.w	r8,0
80009026:	c0 91       	brne	80009038 <_vfprintf_r+0x1628>
80009028:	ed b5 00 00 	bld	r5,0x0
8000902c:	c0 61       	brne	80009038 <_vfprintf_r+0x1628>
8000902e:	fa c6 f9 79 	sub	r6,sp,-1671
80009032:	33 08       	mov	r8,48
80009034:	ac 88       	st.b	r6[0x0],r8
80009036:	c0 28       	rjmp	8000903a <_vfprintf_r+0x162a>
80009038:	04 96       	mov	r6,r2
8000903a:	0c 12       	sub	r2,r6
8000903c:	c1 c8       	rjmp	80009074 <_vfprintf_r+0x1664>
8000903e:	50 a7       	stdsp	sp[0x28],r7
80009040:	50 80       	stdsp	sp[0x20],r0
80009042:	40 93       	lddsp	r3,sp[0x24]
80009044:	0c 97       	mov	r7,r6
80009046:	10 90       	mov	r0,r8
80009048:	04 94       	mov	r4,r2
8000904a:	40 41       	lddsp	r1,sp[0x10]
8000904c:	58 08       	cp.w	r8,0
8000904e:	e0 80 04 4f 	breq	800098ec <_vfprintf_r+0x1edc>
80009052:	fb 68 06 60 	st.b	sp[1632],r8
80009056:	30 0c       	mov	r12,0
80009058:	30 08       	mov	r8,0
8000905a:	30 12       	mov	r2,1
8000905c:	fb 68 06 bb 	st.b	sp[1723],r8
80009060:	50 2c       	stdsp	sp[0x8],r12
80009062:	fa c6 f9 a0 	sub	r6,sp,-1632
80009066:	c0 78       	rjmp	80009074 <_vfprintf_r+0x1664>
80009068:	30 0b       	mov	r11,0
8000906a:	50 2b       	stdsp	sp[0x8],r11
8000906c:	c0 48       	rjmp	80009074 <_vfprintf_r+0x1664>
8000906e:	40 22       	lddsp	r2,sp[0x8]
80009070:	30 0a       	mov	r10,0
80009072:	50 2a       	stdsp	sp[0x8],r10
80009074:	40 29       	lddsp	r9,sp[0x8]
80009076:	e4 09 0c 49 	max	r9,r2,r9
8000907a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000907e:	50 39       	stdsp	sp[0xc],r9
80009080:	0a 9e       	mov	lr,r5
80009082:	30 09       	mov	r9,0
80009084:	e2 1e 00 02 	andl	lr,0x2,COH
80009088:	f2 08 18 00 	cp.b	r8,r9
8000908c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009090:	f7 b8 01 ff 	subne	r8,-1
80009094:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009098:	0a 9b       	mov	r11,r5
8000909a:	58 0e       	cp.w	lr,0
8000909c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800090a0:	f7 bc 01 fe 	subne	r12,-2
800090a4:	fb fc 1a 03 	st.wne	sp[0xc],r12
800090a8:	e2 1b 00 84 	andl	r11,0x84,COH
800090ac:	50 fe       	stdsp	sp[0x3c],lr
800090ae:	50 9b       	stdsp	sp[0x24],r11
800090b0:	c4 71       	brne	8000913e <_vfprintf_r+0x172e>
800090b2:	40 8a       	lddsp	r10,sp[0x20]
800090b4:	40 39       	lddsp	r9,sp[0xc]
800090b6:	12 1a       	sub	r10,r9
800090b8:	50 4a       	stdsp	sp[0x10],r10
800090ba:	58 0a       	cp.w	r10,0
800090bc:	e0 89 00 20 	brgt	800090fc <_vfprintf_r+0x16ec>
800090c0:	c3 f8       	rjmp	8000913e <_vfprintf_r+0x172e>
800090c2:	2f 09       	sub	r9,-16
800090c4:	2f f8       	sub	r8,-1
800090c6:	fe ce c4 5a 	sub	lr,pc,-15270
800090ca:	31 0c       	mov	r12,16
800090cc:	fb 49 06 90 	st.w	sp[1680],r9
800090d0:	87 0e       	st.w	r3[0x0],lr
800090d2:	87 1c       	st.w	r3[0x4],r12
800090d4:	fb 48 06 8c 	st.w	sp[1676],r8
800090d8:	58 78       	cp.w	r8,7
800090da:	e0 89 00 04 	brgt	800090e2 <_vfprintf_r+0x16d2>
800090de:	2f 83       	sub	r3,-8
800090e0:	c0 b8       	rjmp	800090f6 <_vfprintf_r+0x16e6>
800090e2:	fa ca f9 78 	sub	r10,sp,-1672
800090e6:	02 9b       	mov	r11,r1
800090e8:	08 9c       	mov	r12,r4
800090ea:	fe b0 f4 85 	rcall	800079f4 <__sprint_r>
800090ee:	e0 81 04 10 	brne	8000990e <_vfprintf_r+0x1efe>
800090f2:	fa c3 f9 e0 	sub	r3,sp,-1568
800090f6:	40 4b       	lddsp	r11,sp[0x10]
800090f8:	21 0b       	sub	r11,16
800090fa:	50 4b       	stdsp	sp[0x10],r11
800090fc:	fa f9 06 90 	ld.w	r9,sp[1680]
80009100:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009104:	fe ca c4 98 	sub	r10,pc,-15208
80009108:	40 4e       	lddsp	lr,sp[0x10]
8000910a:	59 0e       	cp.w	lr,16
8000910c:	fe 99 ff db 	brgt	800090c2 <_vfprintf_r+0x16b2>
80009110:	1c 09       	add	r9,lr
80009112:	2f f8       	sub	r8,-1
80009114:	87 0a       	st.w	r3[0x0],r10
80009116:	fb 49 06 90 	st.w	sp[1680],r9
8000911a:	87 1e       	st.w	r3[0x4],lr
8000911c:	fb 48 06 8c 	st.w	sp[1676],r8
80009120:	58 78       	cp.w	r8,7
80009122:	e0 89 00 04 	brgt	8000912a <_vfprintf_r+0x171a>
80009126:	2f 83       	sub	r3,-8
80009128:	c0 b8       	rjmp	8000913e <_vfprintf_r+0x172e>
8000912a:	fa ca f9 78 	sub	r10,sp,-1672
8000912e:	02 9b       	mov	r11,r1
80009130:	08 9c       	mov	r12,r4
80009132:	fe b0 f4 61 	rcall	800079f4 <__sprint_r>
80009136:	e0 81 03 ec 	brne	8000990e <_vfprintf_r+0x1efe>
8000913a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000913e:	30 09       	mov	r9,0
80009140:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009144:	f2 08 18 00 	cp.b	r8,r9
80009148:	c1 f0       	breq	80009186 <_vfprintf_r+0x1776>
8000914a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000914e:	fa c9 f9 45 	sub	r9,sp,-1723
80009152:	2f f8       	sub	r8,-1
80009154:	87 09       	st.w	r3[0x0],r9
80009156:	fb 48 06 90 	st.w	sp[1680],r8
8000915a:	30 19       	mov	r9,1
8000915c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009160:	87 19       	st.w	r3[0x4],r9
80009162:	2f f8       	sub	r8,-1
80009164:	fb 48 06 8c 	st.w	sp[1676],r8
80009168:	58 78       	cp.w	r8,7
8000916a:	e0 89 00 04 	brgt	80009172 <_vfprintf_r+0x1762>
8000916e:	2f 83       	sub	r3,-8
80009170:	c0 b8       	rjmp	80009186 <_vfprintf_r+0x1776>
80009172:	fa ca f9 78 	sub	r10,sp,-1672
80009176:	02 9b       	mov	r11,r1
80009178:	08 9c       	mov	r12,r4
8000917a:	fe b0 f4 3d 	rcall	800079f4 <__sprint_r>
8000917e:	e0 81 03 c8 	brne	8000990e <_vfprintf_r+0x1efe>
80009182:	fa c3 f9 e0 	sub	r3,sp,-1568
80009186:	40 fc       	lddsp	r12,sp[0x3c]
80009188:	58 0c       	cp.w	r12,0
8000918a:	c1 f0       	breq	800091c8 <_vfprintf_r+0x17b8>
8000918c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009190:	fa c9 f9 48 	sub	r9,sp,-1720
80009194:	2f e8       	sub	r8,-2
80009196:	87 09       	st.w	r3[0x0],r9
80009198:	fb 48 06 90 	st.w	sp[1680],r8
8000919c:	30 29       	mov	r9,2
8000919e:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091a2:	87 19       	st.w	r3[0x4],r9
800091a4:	2f f8       	sub	r8,-1
800091a6:	fb 48 06 8c 	st.w	sp[1676],r8
800091aa:	58 78       	cp.w	r8,7
800091ac:	e0 89 00 04 	brgt	800091b4 <_vfprintf_r+0x17a4>
800091b0:	2f 83       	sub	r3,-8
800091b2:	c0 b8       	rjmp	800091c8 <_vfprintf_r+0x17b8>
800091b4:	fa ca f9 78 	sub	r10,sp,-1672
800091b8:	02 9b       	mov	r11,r1
800091ba:	08 9c       	mov	r12,r4
800091bc:	fe b0 f4 1c 	rcall	800079f4 <__sprint_r>
800091c0:	e0 81 03 a7 	brne	8000990e <_vfprintf_r+0x1efe>
800091c4:	fa c3 f9 e0 	sub	r3,sp,-1568
800091c8:	40 9b       	lddsp	r11,sp[0x24]
800091ca:	e0 4b 00 80 	cp.w	r11,128
800091ce:	c4 71       	brne	8000925c <_vfprintf_r+0x184c>
800091d0:	40 8a       	lddsp	r10,sp[0x20]
800091d2:	40 39       	lddsp	r9,sp[0xc]
800091d4:	12 1a       	sub	r10,r9
800091d6:	50 4a       	stdsp	sp[0x10],r10
800091d8:	58 0a       	cp.w	r10,0
800091da:	e0 89 00 20 	brgt	8000921a <_vfprintf_r+0x180a>
800091de:	c3 f8       	rjmp	8000925c <_vfprintf_r+0x184c>
800091e0:	2f 09       	sub	r9,-16
800091e2:	2f f8       	sub	r8,-1
800091e4:	fe ce c5 68 	sub	lr,pc,-15000
800091e8:	31 0c       	mov	r12,16
800091ea:	fb 49 06 90 	st.w	sp[1680],r9
800091ee:	87 0e       	st.w	r3[0x0],lr
800091f0:	87 1c       	st.w	r3[0x4],r12
800091f2:	fb 48 06 8c 	st.w	sp[1676],r8
800091f6:	58 78       	cp.w	r8,7
800091f8:	e0 89 00 04 	brgt	80009200 <_vfprintf_r+0x17f0>
800091fc:	2f 83       	sub	r3,-8
800091fe:	c0 b8       	rjmp	80009214 <_vfprintf_r+0x1804>
80009200:	fa ca f9 78 	sub	r10,sp,-1672
80009204:	02 9b       	mov	r11,r1
80009206:	08 9c       	mov	r12,r4
80009208:	fe b0 f3 f6 	rcall	800079f4 <__sprint_r>
8000920c:	e0 81 03 81 	brne	8000990e <_vfprintf_r+0x1efe>
80009210:	fa c3 f9 e0 	sub	r3,sp,-1568
80009214:	40 4b       	lddsp	r11,sp[0x10]
80009216:	21 0b       	sub	r11,16
80009218:	50 4b       	stdsp	sp[0x10],r11
8000921a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000921e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009222:	fe ca c5 a6 	sub	r10,pc,-14938
80009226:	40 4e       	lddsp	lr,sp[0x10]
80009228:	59 0e       	cp.w	lr,16
8000922a:	fe 99 ff db 	brgt	800091e0 <_vfprintf_r+0x17d0>
8000922e:	1c 09       	add	r9,lr
80009230:	2f f8       	sub	r8,-1
80009232:	87 0a       	st.w	r3[0x0],r10
80009234:	fb 49 06 90 	st.w	sp[1680],r9
80009238:	87 1e       	st.w	r3[0x4],lr
8000923a:	fb 48 06 8c 	st.w	sp[1676],r8
8000923e:	58 78       	cp.w	r8,7
80009240:	e0 89 00 04 	brgt	80009248 <_vfprintf_r+0x1838>
80009244:	2f 83       	sub	r3,-8
80009246:	c0 b8       	rjmp	8000925c <_vfprintf_r+0x184c>
80009248:	fa ca f9 78 	sub	r10,sp,-1672
8000924c:	02 9b       	mov	r11,r1
8000924e:	08 9c       	mov	r12,r4
80009250:	fe b0 f3 d2 	rcall	800079f4 <__sprint_r>
80009254:	e0 81 03 5d 	brne	8000990e <_vfprintf_r+0x1efe>
80009258:	fa c3 f9 e0 	sub	r3,sp,-1568
8000925c:	40 2c       	lddsp	r12,sp[0x8]
8000925e:	04 1c       	sub	r12,r2
80009260:	50 2c       	stdsp	sp[0x8],r12
80009262:	58 0c       	cp.w	r12,0
80009264:	e0 89 00 20 	brgt	800092a4 <_vfprintf_r+0x1894>
80009268:	c3 f8       	rjmp	800092e6 <_vfprintf_r+0x18d6>
8000926a:	2f 09       	sub	r9,-16
8000926c:	2f f8       	sub	r8,-1
8000926e:	fe cb c5 f2 	sub	r11,pc,-14862
80009272:	31 0a       	mov	r10,16
80009274:	fb 49 06 90 	st.w	sp[1680],r9
80009278:	87 0b       	st.w	r3[0x0],r11
8000927a:	87 1a       	st.w	r3[0x4],r10
8000927c:	fb 48 06 8c 	st.w	sp[1676],r8
80009280:	58 78       	cp.w	r8,7
80009282:	e0 89 00 04 	brgt	8000928a <_vfprintf_r+0x187a>
80009286:	2f 83       	sub	r3,-8
80009288:	c0 b8       	rjmp	8000929e <_vfprintf_r+0x188e>
8000928a:	fa ca f9 78 	sub	r10,sp,-1672
8000928e:	02 9b       	mov	r11,r1
80009290:	08 9c       	mov	r12,r4
80009292:	fe b0 f3 b1 	rcall	800079f4 <__sprint_r>
80009296:	e0 81 03 3c 	brne	8000990e <_vfprintf_r+0x1efe>
8000929a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000929e:	40 29       	lddsp	r9,sp[0x8]
800092a0:	21 09       	sub	r9,16
800092a2:	50 29       	stdsp	sp[0x8],r9
800092a4:	fa f9 06 90 	ld.w	r9,sp[1680]
800092a8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092ac:	fe ca c6 30 	sub	r10,pc,-14800
800092b0:	40 2e       	lddsp	lr,sp[0x8]
800092b2:	59 0e       	cp.w	lr,16
800092b4:	fe 99 ff db 	brgt	8000926a <_vfprintf_r+0x185a>
800092b8:	1c 09       	add	r9,lr
800092ba:	2f f8       	sub	r8,-1
800092bc:	87 0a       	st.w	r3[0x0],r10
800092be:	fb 49 06 90 	st.w	sp[1680],r9
800092c2:	87 1e       	st.w	r3[0x4],lr
800092c4:	fb 48 06 8c 	st.w	sp[1676],r8
800092c8:	58 78       	cp.w	r8,7
800092ca:	e0 89 00 04 	brgt	800092d2 <_vfprintf_r+0x18c2>
800092ce:	2f 83       	sub	r3,-8
800092d0:	c0 b8       	rjmp	800092e6 <_vfprintf_r+0x18d6>
800092d2:	fa ca f9 78 	sub	r10,sp,-1672
800092d6:	02 9b       	mov	r11,r1
800092d8:	08 9c       	mov	r12,r4
800092da:	fe b0 f3 8d 	rcall	800079f4 <__sprint_r>
800092de:	e0 81 03 18 	brne	8000990e <_vfprintf_r+0x1efe>
800092e2:	fa c3 f9 e0 	sub	r3,sp,-1568
800092e6:	ed b5 00 08 	bld	r5,0x8
800092ea:	c0 b0       	breq	80009300 <_vfprintf_r+0x18f0>
800092ec:	fa f8 06 90 	ld.w	r8,sp[1680]
800092f0:	87 12       	st.w	r3[0x4],r2
800092f2:	87 06       	st.w	r3[0x0],r6
800092f4:	f0 02 00 02 	add	r2,r8,r2
800092f8:	fb 42 06 90 	st.w	sp[1680],r2
800092fc:	e0 8f 01 d4 	bral	800096a4 <_vfprintf_r+0x1c94>
80009300:	e0 40 00 65 	cp.w	r0,101
80009304:	e0 8a 01 d6 	brle	800096b0 <_vfprintf_r+0x1ca0>
80009308:	30 08       	mov	r8,0
8000930a:	30 09       	mov	r9,0
8000930c:	40 5b       	lddsp	r11,sp[0x14]
8000930e:	40 7a       	lddsp	r10,sp[0x1c]
80009310:	e0 a0 16 15 	rcall	8000bf3a <__avr32_f64_cmp_eq>
80009314:	c7 90       	breq	80009406 <_vfprintf_r+0x19f6>
80009316:	fa f8 06 90 	ld.w	r8,sp[1680]
8000931a:	fe c9 c6 b2 	sub	r9,pc,-14670
8000931e:	2f f8       	sub	r8,-1
80009320:	87 09       	st.w	r3[0x0],r9
80009322:	fb 48 06 90 	st.w	sp[1680],r8
80009326:	30 19       	mov	r9,1
80009328:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000932c:	87 19       	st.w	r3[0x4],r9
8000932e:	2f f8       	sub	r8,-1
80009330:	fb 48 06 8c 	st.w	sp[1676],r8
80009334:	58 78       	cp.w	r8,7
80009336:	e0 89 00 05 	brgt	80009340 <_vfprintf_r+0x1930>
8000933a:	2f 83       	sub	r3,-8
8000933c:	c0 c8       	rjmp	80009354 <_vfprintf_r+0x1944>
8000933e:	d7 03       	nop
80009340:	fa ca f9 78 	sub	r10,sp,-1672
80009344:	02 9b       	mov	r11,r1
80009346:	08 9c       	mov	r12,r4
80009348:	fe b0 f3 56 	rcall	800079f4 <__sprint_r>
8000934c:	e0 81 02 e1 	brne	8000990e <_vfprintf_r+0x1efe>
80009350:	fa c3 f9 e0 	sub	r3,sp,-1568
80009354:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009358:	40 6c       	lddsp	r12,sp[0x18]
8000935a:	18 38       	cp.w	r8,r12
8000935c:	c0 55       	brlt	80009366 <_vfprintf_r+0x1956>
8000935e:	ed b5 00 00 	bld	r5,0x0
80009362:	e0 81 02 6b 	brne	80009838 <_vfprintf_r+0x1e28>
80009366:	fa f8 06 90 	ld.w	r8,sp[1680]
8000936a:	2f f8       	sub	r8,-1
8000936c:	40 cb       	lddsp	r11,sp[0x30]
8000936e:	fb 48 06 90 	st.w	sp[1680],r8
80009372:	30 19       	mov	r9,1
80009374:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009378:	87 0b       	st.w	r3[0x0],r11
8000937a:	2f f8       	sub	r8,-1
8000937c:	87 19       	st.w	r3[0x4],r9
8000937e:	fb 48 06 8c 	st.w	sp[1676],r8
80009382:	58 78       	cp.w	r8,7
80009384:	e0 89 00 04 	brgt	8000938c <_vfprintf_r+0x197c>
80009388:	2f 83       	sub	r3,-8
8000938a:	c0 b8       	rjmp	800093a0 <_vfprintf_r+0x1990>
8000938c:	fa ca f9 78 	sub	r10,sp,-1672
80009390:	02 9b       	mov	r11,r1
80009392:	08 9c       	mov	r12,r4
80009394:	fe b0 f3 30 	rcall	800079f4 <__sprint_r>
80009398:	e0 81 02 bb 	brne	8000990e <_vfprintf_r+0x1efe>
8000939c:	fa c3 f9 e0 	sub	r3,sp,-1568
800093a0:	40 66       	lddsp	r6,sp[0x18]
800093a2:	20 16       	sub	r6,1
800093a4:	58 06       	cp.w	r6,0
800093a6:	e0 89 00 1d 	brgt	800093e0 <_vfprintf_r+0x19d0>
800093aa:	e0 8f 02 47 	bral	80009838 <_vfprintf_r+0x1e28>
800093ae:	2f 09       	sub	r9,-16
800093b0:	2f f8       	sub	r8,-1
800093b2:	fb 49 06 90 	st.w	sp[1680],r9
800093b6:	87 02       	st.w	r3[0x0],r2
800093b8:	87 10       	st.w	r3[0x4],r0
800093ba:	fb 48 06 8c 	st.w	sp[1676],r8
800093be:	58 78       	cp.w	r8,7
800093c0:	e0 89 00 04 	brgt	800093c8 <_vfprintf_r+0x19b8>
800093c4:	2f 83       	sub	r3,-8
800093c6:	c0 b8       	rjmp	800093dc <_vfprintf_r+0x19cc>
800093c8:	fa ca f9 78 	sub	r10,sp,-1672
800093cc:	02 9b       	mov	r11,r1
800093ce:	08 9c       	mov	r12,r4
800093d0:	fe b0 f3 12 	rcall	800079f4 <__sprint_r>
800093d4:	e0 81 02 9d 	brne	8000990e <_vfprintf_r+0x1efe>
800093d8:	fa c3 f9 e0 	sub	r3,sp,-1568
800093dc:	21 06       	sub	r6,16
800093de:	c0 48       	rjmp	800093e6 <_vfprintf_r+0x19d6>
800093e0:	fe c2 c7 64 	sub	r2,pc,-14492
800093e4:	31 00       	mov	r0,16
800093e6:	fa f9 06 90 	ld.w	r9,sp[1680]
800093ea:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093ee:	fe ca c7 72 	sub	r10,pc,-14478
800093f2:	59 06       	cp.w	r6,16
800093f4:	fe 99 ff dd 	brgt	800093ae <_vfprintf_r+0x199e>
800093f8:	0c 09       	add	r9,r6
800093fa:	87 0a       	st.w	r3[0x0],r10
800093fc:	fb 49 06 90 	st.w	sp[1680],r9
80009400:	2f f8       	sub	r8,-1
80009402:	87 16       	st.w	r3[0x4],r6
80009404:	c5 39       	rjmp	800096aa <_vfprintf_r+0x1c9a>
80009406:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000940a:	58 0a       	cp.w	r10,0
8000940c:	e0 89 00 92 	brgt	80009530 <_vfprintf_r+0x1b20>
80009410:	fa f8 06 90 	ld.w	r8,sp[1680]
80009414:	fe c9 c7 ac 	sub	r9,pc,-14420
80009418:	2f f8       	sub	r8,-1
8000941a:	87 09       	st.w	r3[0x0],r9
8000941c:	fb 48 06 90 	st.w	sp[1680],r8
80009420:	30 19       	mov	r9,1
80009422:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009426:	87 19       	st.w	r3[0x4],r9
80009428:	2f f8       	sub	r8,-1
8000942a:	fb 48 06 8c 	st.w	sp[1676],r8
8000942e:	58 78       	cp.w	r8,7
80009430:	e0 89 00 04 	brgt	80009438 <_vfprintf_r+0x1a28>
80009434:	2f 83       	sub	r3,-8
80009436:	c0 b8       	rjmp	8000944c <_vfprintf_r+0x1a3c>
80009438:	fa ca f9 78 	sub	r10,sp,-1672
8000943c:	02 9b       	mov	r11,r1
8000943e:	08 9c       	mov	r12,r4
80009440:	fe b0 f2 da 	rcall	800079f4 <__sprint_r>
80009444:	e0 81 02 65 	brne	8000990e <_vfprintf_r+0x1efe>
80009448:	fa c3 f9 e0 	sub	r3,sp,-1568
8000944c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009450:	58 08       	cp.w	r8,0
80009452:	c0 81       	brne	80009462 <_vfprintf_r+0x1a52>
80009454:	40 6a       	lddsp	r10,sp[0x18]
80009456:	58 0a       	cp.w	r10,0
80009458:	c0 51       	brne	80009462 <_vfprintf_r+0x1a52>
8000945a:	ed b5 00 00 	bld	r5,0x0
8000945e:	e0 81 01 ed 	brne	80009838 <_vfprintf_r+0x1e28>
80009462:	40 c9       	lddsp	r9,sp[0x30]
80009464:	fa f8 06 90 	ld.w	r8,sp[1680]
80009468:	2f f8       	sub	r8,-1
8000946a:	87 09       	st.w	r3[0x0],r9
8000946c:	fb 48 06 90 	st.w	sp[1680],r8
80009470:	30 19       	mov	r9,1
80009472:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009476:	87 19       	st.w	r3[0x4],r9
80009478:	2f f8       	sub	r8,-1
8000947a:	fb 48 06 8c 	st.w	sp[1676],r8
8000947e:	58 78       	cp.w	r8,7
80009480:	e0 89 00 04 	brgt	80009488 <_vfprintf_r+0x1a78>
80009484:	2f 83       	sub	r3,-8
80009486:	c0 b8       	rjmp	8000949c <_vfprintf_r+0x1a8c>
80009488:	fa ca f9 78 	sub	r10,sp,-1672
8000948c:	02 9b       	mov	r11,r1
8000948e:	08 9c       	mov	r12,r4
80009490:	fe b0 f2 b2 	rcall	800079f4 <__sprint_r>
80009494:	e0 81 02 3d 	brne	8000990e <_vfprintf_r+0x1efe>
80009498:	fa c3 f9 e0 	sub	r3,sp,-1568
8000949c:	fa f2 06 ac 	ld.w	r2,sp[1708]
800094a0:	5c 32       	neg	r2
800094a2:	58 02       	cp.w	r2,0
800094a4:	e0 89 00 1d 	brgt	800094de <_vfprintf_r+0x1ace>
800094a8:	c3 d8       	rjmp	80009522 <_vfprintf_r+0x1b12>
800094aa:	2f 09       	sub	r9,-16
800094ac:	2f f8       	sub	r8,-1
800094ae:	31 0e       	mov	lr,16
800094b0:	fb 49 06 90 	st.w	sp[1680],r9
800094b4:	87 00       	st.w	r3[0x0],r0
800094b6:	87 1e       	st.w	r3[0x4],lr
800094b8:	fb 48 06 8c 	st.w	sp[1676],r8
800094bc:	58 78       	cp.w	r8,7
800094be:	e0 89 00 04 	brgt	800094c6 <_vfprintf_r+0x1ab6>
800094c2:	2f 83       	sub	r3,-8
800094c4:	c0 b8       	rjmp	800094da <_vfprintf_r+0x1aca>
800094c6:	fa ca f9 78 	sub	r10,sp,-1672
800094ca:	02 9b       	mov	r11,r1
800094cc:	08 9c       	mov	r12,r4
800094ce:	fe b0 f2 93 	rcall	800079f4 <__sprint_r>
800094d2:	e0 81 02 1e 	brne	8000990e <_vfprintf_r+0x1efe>
800094d6:	fa c3 f9 e0 	sub	r3,sp,-1568
800094da:	21 02       	sub	r2,16
800094dc:	c0 38       	rjmp	800094e2 <_vfprintf_r+0x1ad2>
800094de:	fe c0 c8 62 	sub	r0,pc,-14238
800094e2:	fa f9 06 90 	ld.w	r9,sp[1680]
800094e6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094ea:	fe ca c8 6e 	sub	r10,pc,-14226
800094ee:	59 02       	cp.w	r2,16
800094f0:	fe 99 ff dd 	brgt	800094aa <_vfprintf_r+0x1a9a>
800094f4:	04 09       	add	r9,r2
800094f6:	2f f8       	sub	r8,-1
800094f8:	87 0a       	st.w	r3[0x0],r10
800094fa:	fb 49 06 90 	st.w	sp[1680],r9
800094fe:	87 12       	st.w	r3[0x4],r2
80009500:	fb 48 06 8c 	st.w	sp[1676],r8
80009504:	58 78       	cp.w	r8,7
80009506:	e0 89 00 04 	brgt	8000950e <_vfprintf_r+0x1afe>
8000950a:	2f 83       	sub	r3,-8
8000950c:	c0 b8       	rjmp	80009522 <_vfprintf_r+0x1b12>
8000950e:	fa ca f9 78 	sub	r10,sp,-1672
80009512:	02 9b       	mov	r11,r1
80009514:	08 9c       	mov	r12,r4
80009516:	fe b0 f2 6f 	rcall	800079f4 <__sprint_r>
8000951a:	e0 81 01 fa 	brne	8000990e <_vfprintf_r+0x1efe>
8000951e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009522:	40 6c       	lddsp	r12,sp[0x18]
80009524:	fa f8 06 90 	ld.w	r8,sp[1680]
80009528:	87 06       	st.w	r3[0x0],r6
8000952a:	87 1c       	st.w	r3[0x4],r12
8000952c:	18 08       	add	r8,r12
8000952e:	cb 98       	rjmp	800096a0 <_vfprintf_r+0x1c90>
80009530:	fa f9 06 90 	ld.w	r9,sp[1680]
80009534:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009538:	40 6b       	lddsp	r11,sp[0x18]
8000953a:	16 3a       	cp.w	r10,r11
8000953c:	c6 f5       	brlt	8000961a <_vfprintf_r+0x1c0a>
8000953e:	16 09       	add	r9,r11
80009540:	2f f8       	sub	r8,-1
80009542:	87 06       	st.w	r3[0x0],r6
80009544:	fb 49 06 90 	st.w	sp[1680],r9
80009548:	87 1b       	st.w	r3[0x4],r11
8000954a:	fb 48 06 8c 	st.w	sp[1676],r8
8000954e:	58 78       	cp.w	r8,7
80009550:	e0 89 00 04 	brgt	80009558 <_vfprintf_r+0x1b48>
80009554:	2f 83       	sub	r3,-8
80009556:	c0 b8       	rjmp	8000956c <_vfprintf_r+0x1b5c>
80009558:	fa ca f9 78 	sub	r10,sp,-1672
8000955c:	02 9b       	mov	r11,r1
8000955e:	08 9c       	mov	r12,r4
80009560:	fe b0 f2 4a 	rcall	800079f4 <__sprint_r>
80009564:	e0 81 01 d5 	brne	8000990e <_vfprintf_r+0x1efe>
80009568:	fa c3 f9 e0 	sub	r3,sp,-1568
8000956c:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009570:	40 6a       	lddsp	r10,sp[0x18]
80009572:	14 16       	sub	r6,r10
80009574:	58 06       	cp.w	r6,0
80009576:	e0 89 00 1c 	brgt	800095ae <_vfprintf_r+0x1b9e>
8000957a:	c3 d8       	rjmp	800095f4 <_vfprintf_r+0x1be4>
8000957c:	2f 09       	sub	r9,-16
8000957e:	2f f8       	sub	r8,-1
80009580:	fb 49 06 90 	st.w	sp[1680],r9
80009584:	87 02       	st.w	r3[0x0],r2
80009586:	87 10       	st.w	r3[0x4],r0
80009588:	fb 48 06 8c 	st.w	sp[1676],r8
8000958c:	58 78       	cp.w	r8,7
8000958e:	e0 89 00 04 	brgt	80009596 <_vfprintf_r+0x1b86>
80009592:	2f 83       	sub	r3,-8
80009594:	c0 b8       	rjmp	800095aa <_vfprintf_r+0x1b9a>
80009596:	fa ca f9 78 	sub	r10,sp,-1672
8000959a:	02 9b       	mov	r11,r1
8000959c:	08 9c       	mov	r12,r4
8000959e:	fe b0 f2 2b 	rcall	800079f4 <__sprint_r>
800095a2:	e0 81 01 b6 	brne	8000990e <_vfprintf_r+0x1efe>
800095a6:	fa c3 f9 e0 	sub	r3,sp,-1568
800095aa:	21 06       	sub	r6,16
800095ac:	c0 48       	rjmp	800095b4 <_vfprintf_r+0x1ba4>
800095ae:	fe c2 c9 32 	sub	r2,pc,-14030
800095b2:	31 00       	mov	r0,16
800095b4:	fa f9 06 90 	ld.w	r9,sp[1680]
800095b8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095bc:	fe ca c9 40 	sub	r10,pc,-14016
800095c0:	59 06       	cp.w	r6,16
800095c2:	fe 99 ff dd 	brgt	8000957c <_vfprintf_r+0x1b6c>
800095c6:	0c 09       	add	r9,r6
800095c8:	2f f8       	sub	r8,-1
800095ca:	87 0a       	st.w	r3[0x0],r10
800095cc:	fb 49 06 90 	st.w	sp[1680],r9
800095d0:	87 16       	st.w	r3[0x4],r6
800095d2:	fb 48 06 8c 	st.w	sp[1676],r8
800095d6:	58 78       	cp.w	r8,7
800095d8:	e0 89 00 04 	brgt	800095e0 <_vfprintf_r+0x1bd0>
800095dc:	2f 83       	sub	r3,-8
800095de:	c0 b8       	rjmp	800095f4 <_vfprintf_r+0x1be4>
800095e0:	fa ca f9 78 	sub	r10,sp,-1672
800095e4:	02 9b       	mov	r11,r1
800095e6:	08 9c       	mov	r12,r4
800095e8:	fe b0 f2 06 	rcall	800079f4 <__sprint_r>
800095ec:	e0 81 01 91 	brne	8000990e <_vfprintf_r+0x1efe>
800095f0:	fa c3 f9 e0 	sub	r3,sp,-1568
800095f4:	ed b5 00 00 	bld	r5,0x0
800095f8:	e0 81 01 20 	brne	80009838 <_vfprintf_r+0x1e28>
800095fc:	40 c9       	lddsp	r9,sp[0x30]
800095fe:	fa f8 06 90 	ld.w	r8,sp[1680]
80009602:	2f f8       	sub	r8,-1
80009604:	87 09       	st.w	r3[0x0],r9
80009606:	fb 48 06 90 	st.w	sp[1680],r8
8000960a:	30 19       	mov	r9,1
8000960c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009610:	87 19       	st.w	r3[0x4],r9
80009612:	2f f8       	sub	r8,-1
80009614:	fb 48 06 8c 	st.w	sp[1676],r8
80009618:	c0 29       	rjmp	8000981c <_vfprintf_r+0x1e0c>
8000961a:	14 09       	add	r9,r10
8000961c:	2f f8       	sub	r8,-1
8000961e:	fb 49 06 90 	st.w	sp[1680],r9
80009622:	87 06       	st.w	r3[0x0],r6
80009624:	87 1a       	st.w	r3[0x4],r10
80009626:	fb 48 06 8c 	st.w	sp[1676],r8
8000962a:	58 78       	cp.w	r8,7
8000962c:	e0 89 00 04 	brgt	80009634 <_vfprintf_r+0x1c24>
80009630:	2f 83       	sub	r3,-8
80009632:	c0 b8       	rjmp	80009648 <_vfprintf_r+0x1c38>
80009634:	fa ca f9 78 	sub	r10,sp,-1672
80009638:	02 9b       	mov	r11,r1
8000963a:	08 9c       	mov	r12,r4
8000963c:	fe b0 f1 dc 	rcall	800079f4 <__sprint_r>
80009640:	e0 81 01 67 	brne	8000990e <_vfprintf_r+0x1efe>
80009644:	fa c3 f9 e0 	sub	r3,sp,-1568
80009648:	40 c8       	lddsp	r8,sp[0x30]
8000964a:	87 08       	st.w	r3[0x0],r8
8000964c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009650:	2f f8       	sub	r8,-1
80009652:	30 19       	mov	r9,1
80009654:	fb 48 06 90 	st.w	sp[1680],r8
80009658:	87 19       	st.w	r3[0x4],r9
8000965a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000965e:	2f f8       	sub	r8,-1
80009660:	fb 48 06 8c 	st.w	sp[1676],r8
80009664:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009668:	58 78       	cp.w	r8,7
8000966a:	e0 89 00 04 	brgt	80009672 <_vfprintf_r+0x1c62>
8000966e:	2f 83       	sub	r3,-8
80009670:	c0 b8       	rjmp	80009686 <_vfprintf_r+0x1c76>
80009672:	fa ca f9 78 	sub	r10,sp,-1672
80009676:	02 9b       	mov	r11,r1
80009678:	08 9c       	mov	r12,r4
8000967a:	fe b0 f1 bd 	rcall	800079f4 <__sprint_r>
8000967e:	e0 81 01 48 	brne	8000990e <_vfprintf_r+0x1efe>
80009682:	fa c3 f9 e0 	sub	r3,sp,-1568
80009686:	04 06       	add	r6,r2
80009688:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000968c:	87 06       	st.w	r3[0x0],r6
8000968e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009692:	40 66       	lddsp	r6,sp[0x18]
80009694:	40 6e       	lddsp	lr,sp[0x18]
80009696:	10 16       	sub	r6,r8
80009698:	f2 08 01 08 	sub	r8,r9,r8
8000969c:	87 16       	st.w	r3[0x4],r6
8000969e:	1c 08       	add	r8,lr
800096a0:	fb 48 06 90 	st.w	sp[1680],r8
800096a4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096a8:	2f f8       	sub	r8,-1
800096aa:	fb 48 06 8c 	st.w	sp[1676],r8
800096ae:	cb 78       	rjmp	8000981c <_vfprintf_r+0x1e0c>
800096b0:	40 6c       	lddsp	r12,sp[0x18]
800096b2:	58 1c       	cp.w	r12,1
800096b4:	e0 89 00 06 	brgt	800096c0 <_vfprintf_r+0x1cb0>
800096b8:	ed b5 00 00 	bld	r5,0x0
800096bc:	e0 81 00 85 	brne	800097c6 <_vfprintf_r+0x1db6>
800096c0:	fa f8 06 90 	ld.w	r8,sp[1680]
800096c4:	2f f8       	sub	r8,-1
800096c6:	30 19       	mov	r9,1
800096c8:	fb 48 06 90 	st.w	sp[1680],r8
800096cc:	87 06       	st.w	r3[0x0],r6
800096ce:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096d2:	87 19       	st.w	r3[0x4],r9
800096d4:	2f f8       	sub	r8,-1
800096d6:	fb 48 06 8c 	st.w	sp[1676],r8
800096da:	58 78       	cp.w	r8,7
800096dc:	e0 89 00 04 	brgt	800096e4 <_vfprintf_r+0x1cd4>
800096e0:	2f 83       	sub	r3,-8
800096e2:	c0 b8       	rjmp	800096f8 <_vfprintf_r+0x1ce8>
800096e4:	fa ca f9 78 	sub	r10,sp,-1672
800096e8:	02 9b       	mov	r11,r1
800096ea:	08 9c       	mov	r12,r4
800096ec:	fe b0 f1 84 	rcall	800079f4 <__sprint_r>
800096f0:	e0 81 01 0f 	brne	8000990e <_vfprintf_r+0x1efe>
800096f4:	fa c3 f9 e0 	sub	r3,sp,-1568
800096f8:	fa f8 06 90 	ld.w	r8,sp[1680]
800096fc:	2f f8       	sub	r8,-1
800096fe:	40 cb       	lddsp	r11,sp[0x30]
80009700:	fb 48 06 90 	st.w	sp[1680],r8
80009704:	30 19       	mov	r9,1
80009706:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000970a:	87 0b       	st.w	r3[0x0],r11
8000970c:	2f f8       	sub	r8,-1
8000970e:	87 19       	st.w	r3[0x4],r9
80009710:	fb 48 06 8c 	st.w	sp[1676],r8
80009714:	58 78       	cp.w	r8,7
80009716:	e0 89 00 05 	brgt	80009720 <_vfprintf_r+0x1d10>
8000971a:	2f 83       	sub	r3,-8
8000971c:	c0 c8       	rjmp	80009734 <_vfprintf_r+0x1d24>
8000971e:	d7 03       	nop
80009720:	fa ca f9 78 	sub	r10,sp,-1672
80009724:	02 9b       	mov	r11,r1
80009726:	08 9c       	mov	r12,r4
80009728:	fe b0 f1 66 	rcall	800079f4 <__sprint_r>
8000972c:	e0 81 00 f1 	brne	8000990e <_vfprintf_r+0x1efe>
80009730:	fa c3 f9 e0 	sub	r3,sp,-1568
80009734:	30 08       	mov	r8,0
80009736:	30 09       	mov	r9,0
80009738:	40 5b       	lddsp	r11,sp[0x14]
8000973a:	40 7a       	lddsp	r10,sp[0x1c]
8000973c:	e0 a0 13 ff 	rcall	8000bf3a <__avr32_f64_cmp_eq>
80009740:	40 68       	lddsp	r8,sp[0x18]
80009742:	20 18       	sub	r8,1
80009744:	58 0c       	cp.w	r12,0
80009746:	c0 d1       	brne	80009760 <_vfprintf_r+0x1d50>
80009748:	2f f6       	sub	r6,-1
8000974a:	87 18       	st.w	r3[0x4],r8
8000974c:	87 06       	st.w	r3[0x0],r6
8000974e:	fa f6 06 90 	ld.w	r6,sp[1680]
80009752:	10 06       	add	r6,r8
80009754:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009758:	fb 46 06 90 	st.w	sp[1680],r6
8000975c:	2f f8       	sub	r8,-1
8000975e:	c3 18       	rjmp	800097c0 <_vfprintf_r+0x1db0>
80009760:	10 96       	mov	r6,r8
80009762:	58 08       	cp.w	r8,0
80009764:	e0 89 00 1c 	brgt	8000979c <_vfprintf_r+0x1d8c>
80009768:	c4 b8       	rjmp	800097fe <_vfprintf_r+0x1dee>
8000976a:	2f 09       	sub	r9,-16
8000976c:	2f f8       	sub	r8,-1
8000976e:	fb 49 06 90 	st.w	sp[1680],r9
80009772:	87 02       	st.w	r3[0x0],r2
80009774:	87 10       	st.w	r3[0x4],r0
80009776:	fb 48 06 8c 	st.w	sp[1676],r8
8000977a:	58 78       	cp.w	r8,7
8000977c:	e0 89 00 04 	brgt	80009784 <_vfprintf_r+0x1d74>
80009780:	2f 83       	sub	r3,-8
80009782:	c0 b8       	rjmp	80009798 <_vfprintf_r+0x1d88>
80009784:	fa ca f9 78 	sub	r10,sp,-1672
80009788:	02 9b       	mov	r11,r1
8000978a:	08 9c       	mov	r12,r4
8000978c:	fe b0 f1 34 	rcall	800079f4 <__sprint_r>
80009790:	e0 81 00 bf 	brne	8000990e <_vfprintf_r+0x1efe>
80009794:	fa c3 f9 e0 	sub	r3,sp,-1568
80009798:	21 06       	sub	r6,16
8000979a:	c0 48       	rjmp	800097a2 <_vfprintf_r+0x1d92>
8000979c:	fe c2 cb 20 	sub	r2,pc,-13536
800097a0:	31 00       	mov	r0,16
800097a2:	fa f9 06 90 	ld.w	r9,sp[1680]
800097a6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097aa:	fe ca cb 2e 	sub	r10,pc,-13522
800097ae:	59 06       	cp.w	r6,16
800097b0:	fe 99 ff dd 	brgt	8000976a <_vfprintf_r+0x1d5a>
800097b4:	0c 09       	add	r9,r6
800097b6:	87 0a       	st.w	r3[0x0],r10
800097b8:	fb 49 06 90 	st.w	sp[1680],r9
800097bc:	2f f8       	sub	r8,-1
800097be:	87 16       	st.w	r3[0x4],r6
800097c0:	fb 48 06 8c 	st.w	sp[1676],r8
800097c4:	c0 e8       	rjmp	800097e0 <_vfprintf_r+0x1dd0>
800097c6:	fa f8 06 90 	ld.w	r8,sp[1680]
800097ca:	2f f8       	sub	r8,-1
800097cc:	30 19       	mov	r9,1
800097ce:	fb 48 06 90 	st.w	sp[1680],r8
800097d2:	87 06       	st.w	r3[0x0],r6
800097d4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097d8:	87 19       	st.w	r3[0x4],r9
800097da:	2f f8       	sub	r8,-1
800097dc:	fb 48 06 8c 	st.w	sp[1676],r8
800097e0:	58 78       	cp.w	r8,7
800097e2:	e0 89 00 04 	brgt	800097ea <_vfprintf_r+0x1dda>
800097e6:	2f 83       	sub	r3,-8
800097e8:	c0 b8       	rjmp	800097fe <_vfprintf_r+0x1dee>
800097ea:	fa ca f9 78 	sub	r10,sp,-1672
800097ee:	02 9b       	mov	r11,r1
800097f0:	08 9c       	mov	r12,r4
800097f2:	fe b0 f1 01 	rcall	800079f4 <__sprint_r>
800097f6:	e0 81 00 8c 	brne	8000990e <_vfprintf_r+0x1efe>
800097fa:	fa c3 f9 e0 	sub	r3,sp,-1568
800097fe:	40 ea       	lddsp	r10,sp[0x38]
80009800:	fa f8 06 90 	ld.w	r8,sp[1680]
80009804:	14 08       	add	r8,r10
80009806:	fa c9 f9 64 	sub	r9,sp,-1692
8000980a:	fb 48 06 90 	st.w	sp[1680],r8
8000980e:	87 1a       	st.w	r3[0x4],r10
80009810:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009814:	87 09       	st.w	r3[0x0],r9
80009816:	2f f8       	sub	r8,-1
80009818:	fb 48 06 8c 	st.w	sp[1676],r8
8000981c:	58 78       	cp.w	r8,7
8000981e:	e0 89 00 04 	brgt	80009826 <_vfprintf_r+0x1e16>
80009822:	2f 83       	sub	r3,-8
80009824:	c0 a8       	rjmp	80009838 <_vfprintf_r+0x1e28>
80009826:	fa ca f9 78 	sub	r10,sp,-1672
8000982a:	02 9b       	mov	r11,r1
8000982c:	08 9c       	mov	r12,r4
8000982e:	fe b0 f0 e3 	rcall	800079f4 <__sprint_r>
80009832:	c6 e1       	brne	8000990e <_vfprintf_r+0x1efe>
80009834:	fa c3 f9 e0 	sub	r3,sp,-1568
80009838:	e2 15 00 04 	andl	r5,0x4,COH
8000983c:	c3 f0       	breq	800098ba <_vfprintf_r+0x1eaa>
8000983e:	40 86       	lddsp	r6,sp[0x20]
80009840:	40 39       	lddsp	r9,sp[0xc]
80009842:	12 16       	sub	r6,r9
80009844:	58 06       	cp.w	r6,0
80009846:	e0 89 00 1a 	brgt	8000987a <_vfprintf_r+0x1e6a>
8000984a:	c3 88       	rjmp	800098ba <_vfprintf_r+0x1eaa>
8000984c:	2f 09       	sub	r9,-16
8000984e:	2f f8       	sub	r8,-1
80009850:	fb 49 06 90 	st.w	sp[1680],r9
80009854:	87 05       	st.w	r3[0x0],r5
80009856:	87 12       	st.w	r3[0x4],r2
80009858:	fb 48 06 8c 	st.w	sp[1676],r8
8000985c:	58 78       	cp.w	r8,7
8000985e:	e0 89 00 04 	brgt	80009866 <_vfprintf_r+0x1e56>
80009862:	2f 83       	sub	r3,-8
80009864:	c0 98       	rjmp	80009876 <_vfprintf_r+0x1e66>
80009866:	00 9a       	mov	r10,r0
80009868:	02 9b       	mov	r11,r1
8000986a:	08 9c       	mov	r12,r4
8000986c:	fe b0 f0 c4 	rcall	800079f4 <__sprint_r>
80009870:	c4 f1       	brne	8000990e <_vfprintf_r+0x1efe>
80009872:	fa c3 f9 e0 	sub	r3,sp,-1568
80009876:	21 06       	sub	r6,16
80009878:	c0 68       	rjmp	80009884 <_vfprintf_r+0x1e74>
8000987a:	fe c5 cc 0e 	sub	r5,pc,-13298
8000987e:	31 02       	mov	r2,16
80009880:	fa c0 f9 78 	sub	r0,sp,-1672
80009884:	fa f9 06 90 	ld.w	r9,sp[1680]
80009888:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000988c:	fe ca cc 20 	sub	r10,pc,-13280
80009890:	59 06       	cp.w	r6,16
80009892:	fe 99 ff dd 	brgt	8000984c <_vfprintf_r+0x1e3c>
80009896:	0c 09       	add	r9,r6
80009898:	2f f8       	sub	r8,-1
8000989a:	87 0a       	st.w	r3[0x0],r10
8000989c:	87 16       	st.w	r3[0x4],r6
8000989e:	fb 49 06 90 	st.w	sp[1680],r9
800098a2:	fb 48 06 8c 	st.w	sp[1676],r8
800098a6:	58 78       	cp.w	r8,7
800098a8:	e0 8a 00 09 	brle	800098ba <_vfprintf_r+0x1eaa>
800098ac:	fa ca f9 78 	sub	r10,sp,-1672
800098b0:	02 9b       	mov	r11,r1
800098b2:	08 9c       	mov	r12,r4
800098b4:	fe b0 f0 a0 	rcall	800079f4 <__sprint_r>
800098b8:	c2 b1       	brne	8000990e <_vfprintf_r+0x1efe>
800098ba:	40 bc       	lddsp	r12,sp[0x2c]
800098bc:	40 36       	lddsp	r6,sp[0xc]
800098be:	40 8e       	lddsp	lr,sp[0x20]
800098c0:	ec 0e 0c 48 	max	r8,r6,lr
800098c4:	10 0c       	add	r12,r8
800098c6:	50 bc       	stdsp	sp[0x2c],r12
800098c8:	fa f8 06 90 	ld.w	r8,sp[1680]
800098cc:	58 08       	cp.w	r8,0
800098ce:	c0 80       	breq	800098de <_vfprintf_r+0x1ece>
800098d0:	fa ca f9 78 	sub	r10,sp,-1672
800098d4:	02 9b       	mov	r11,r1
800098d6:	08 9c       	mov	r12,r4
800098d8:	fe b0 f0 8e 	rcall	800079f4 <__sprint_r>
800098dc:	c1 91       	brne	8000990e <_vfprintf_r+0x1efe>
800098de:	30 0b       	mov	r11,0
800098e0:	fa c3 f9 e0 	sub	r3,sp,-1568
800098e4:	fb 4b 06 8c 	st.w	sp[1676],r11
800098e8:	fe 9f f1 22 	bral	80007b2c <_vfprintf_r+0x11c>
800098ec:	08 95       	mov	r5,r4
800098ee:	fa f8 06 90 	ld.w	r8,sp[1680]
800098f2:	58 08       	cp.w	r8,0
800098f4:	c0 80       	breq	80009904 <_vfprintf_r+0x1ef4>
800098f6:	08 9c       	mov	r12,r4
800098f8:	fa ca f9 78 	sub	r10,sp,-1672
800098fc:	02 9b       	mov	r11,r1
800098fe:	fe b0 f0 7b 	rcall	800079f4 <__sprint_r>
80009902:	c0 61       	brne	8000990e <_vfprintf_r+0x1efe>
80009904:	30 08       	mov	r8,0
80009906:	fb 48 06 8c 	st.w	sp[1676],r8
8000990a:	c0 28       	rjmp	8000990e <_vfprintf_r+0x1efe>
8000990c:	40 41       	lddsp	r1,sp[0x10]
8000990e:	82 68       	ld.sh	r8,r1[0xc]
80009910:	ed b8 00 06 	bld	r8,0x6
80009914:	c0 31       	brne	8000991a <_vfprintf_r+0x1f0a>
80009916:	3f fa       	mov	r10,-1
80009918:	50 ba       	stdsp	sp[0x2c],r10
8000991a:	40 bc       	lddsp	r12,sp[0x2c]
8000991c:	fe 3d f9 44 	sub	sp,-1724
80009920:	d8 32       	popm	r0-r7,pc
80009922:	d7 03       	nop

80009924 <_vsprintf_r>:
80009924:	d4 01       	pushm	lr
80009926:	21 7d       	sub	sp,92
80009928:	e0 68 ff ff 	mov	r8,65535
8000992c:	ea 18 7f ff 	orh	r8,0x7fff
80009930:	50 58       	stdsp	sp[0x14],r8
80009932:	50 28       	stdsp	sp[0x8],r8
80009934:	e0 68 02 08 	mov	r8,520
80009938:	ba 68       	st.h	sp[0xc],r8
8000993a:	3f f8       	mov	r8,-1
8000993c:	50 4b       	stdsp	sp[0x10],r11
8000993e:	50 0b       	stdsp	sp[0x0],r11
80009940:	ba 78       	st.h	sp[0xe],r8
80009942:	1a 9b       	mov	r11,sp
80009944:	fe b0 f0 66 	rcall	80007a10 <_vfprintf_r>
80009948:	30 09       	mov	r9,0
8000994a:	40 08       	lddsp	r8,sp[0x0]
8000994c:	b0 89       	st.b	r8[0x0],r9
8000994e:	2e 9d       	sub	sp,-92
80009950:	d8 02       	popm	pc
80009952:	d7 03       	nop

80009954 <vsprintf>:
80009954:	d4 01       	pushm	lr
80009956:	e0 68 01 18 	mov	r8,280
8000995a:	14 99       	mov	r9,r10
8000995c:	16 9a       	mov	r10,r11
8000995e:	18 9b       	mov	r11,r12
80009960:	70 0c       	ld.w	r12,r8[0x0]
80009962:	ce 1f       	rcall	80009924 <_vsprintf_r>
80009964:	d8 02       	popm	pc
80009966:	d7 03       	nop

80009968 <__swsetup_r>:
80009968:	d4 21       	pushm	r4-r7,lr
8000996a:	e0 68 01 18 	mov	r8,280
8000996e:	18 96       	mov	r6,r12
80009970:	16 97       	mov	r7,r11
80009972:	70 0c       	ld.w	r12,r8[0x0]
80009974:	58 0c       	cp.w	r12,0
80009976:	c0 60       	breq	80009982 <__swsetup_r+0x1a>
80009978:	78 68       	ld.w	r8,r12[0x18]
8000997a:	58 08       	cp.w	r8,0
8000997c:	c0 31       	brne	80009982 <__swsetup_r+0x1a>
8000997e:	e0 a0 08 77 	rcall	8000aa6c <__sinit>
80009982:	fe c8 cb e6 	sub	r8,pc,-13338
80009986:	10 37       	cp.w	r7,r8
80009988:	c0 61       	brne	80009994 <__swsetup_r+0x2c>
8000998a:	e0 68 01 18 	mov	r8,280
8000998e:	70 08       	ld.w	r8,r8[0x0]
80009990:	70 07       	ld.w	r7,r8[0x0]
80009992:	c1 28       	rjmp	800099b6 <__swsetup_r+0x4e>
80009994:	fe c8 cb d8 	sub	r8,pc,-13352
80009998:	10 37       	cp.w	r7,r8
8000999a:	c0 61       	brne	800099a6 <__swsetup_r+0x3e>
8000999c:	e0 68 01 18 	mov	r8,280
800099a0:	70 08       	ld.w	r8,r8[0x0]
800099a2:	70 17       	ld.w	r7,r8[0x4]
800099a4:	c0 98       	rjmp	800099b6 <__swsetup_r+0x4e>
800099a6:	fe c8 cb ca 	sub	r8,pc,-13366
800099aa:	10 37       	cp.w	r7,r8
800099ac:	c0 51       	brne	800099b6 <__swsetup_r+0x4e>
800099ae:	e0 68 01 18 	mov	r8,280
800099b2:	70 08       	ld.w	r8,r8[0x0]
800099b4:	70 27       	ld.w	r7,r8[0x8]
800099b6:	8e 68       	ld.sh	r8,r7[0xc]
800099b8:	ed b8 00 03 	bld	r8,0x3
800099bc:	c1 e0       	breq	800099f8 <__swsetup_r+0x90>
800099be:	ed b8 00 04 	bld	r8,0x4
800099c2:	c3 e1       	brne	80009a3e <__swsetup_r+0xd6>
800099c4:	ed b8 00 02 	bld	r8,0x2
800099c8:	c1 51       	brne	800099f2 <__swsetup_r+0x8a>
800099ca:	6e db       	ld.w	r11,r7[0x34]
800099cc:	58 0b       	cp.w	r11,0
800099ce:	c0 a0       	breq	800099e2 <__swsetup_r+0x7a>
800099d0:	ee c8 ff bc 	sub	r8,r7,-68
800099d4:	10 3b       	cp.w	r11,r8
800099d6:	c0 40       	breq	800099de <__swsetup_r+0x76>
800099d8:	0c 9c       	mov	r12,r6
800099da:	e0 a0 08 e3 	rcall	8000aba0 <_free_r>
800099de:	30 08       	mov	r8,0
800099e0:	8f d8       	st.w	r7[0x34],r8
800099e2:	8e 68       	ld.sh	r8,r7[0xc]
800099e4:	e0 18 ff db 	andl	r8,0xffdb
800099e8:	ae 68       	st.h	r7[0xc],r8
800099ea:	30 08       	mov	r8,0
800099ec:	8f 18       	st.w	r7[0x4],r8
800099ee:	6e 48       	ld.w	r8,r7[0x10]
800099f0:	8f 08       	st.w	r7[0x0],r8
800099f2:	8e 68       	ld.sh	r8,r7[0xc]
800099f4:	a3 b8       	sbr	r8,0x3
800099f6:	ae 68       	st.h	r7[0xc],r8
800099f8:	6e 48       	ld.w	r8,r7[0x10]
800099fa:	58 08       	cp.w	r8,0
800099fc:	c0 b1       	brne	80009a12 <__swsetup_r+0xaa>
800099fe:	8e 68       	ld.sh	r8,r7[0xc]
80009a00:	e2 18 02 80 	andl	r8,0x280,COH
80009a04:	e0 48 02 00 	cp.w	r8,512
80009a08:	c0 50       	breq	80009a12 <__swsetup_r+0xaa>
80009a0a:	0c 9c       	mov	r12,r6
80009a0c:	0e 9b       	mov	r11,r7
80009a0e:	e0 a0 0b 03 	rcall	8000b014 <__smakebuf_r>
80009a12:	8e 69       	ld.sh	r9,r7[0xc]
80009a14:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009a18:	c0 70       	breq	80009a26 <__swsetup_r+0xbe>
80009a1a:	30 08       	mov	r8,0
80009a1c:	8f 28       	st.w	r7[0x8],r8
80009a1e:	6e 58       	ld.w	r8,r7[0x14]
80009a20:	5c 38       	neg	r8
80009a22:	8f 68       	st.w	r7[0x18],r8
80009a24:	c0 68       	rjmp	80009a30 <__swsetup_r+0xc8>
80009a26:	ed b9 00 01 	bld	r9,0x1
80009a2a:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009a2e:	8f 28       	st.w	r7[0x8],r8
80009a30:	6e 48       	ld.w	r8,r7[0x10]
80009a32:	58 08       	cp.w	r8,0
80009a34:	c0 61       	brne	80009a40 <__swsetup_r+0xd8>
80009a36:	8e 68       	ld.sh	r8,r7[0xc]
80009a38:	ed b8 00 07 	bld	r8,0x7
80009a3c:	c0 21       	brne	80009a40 <__swsetup_r+0xd8>
80009a3e:	dc 2a       	popm	r4-r7,pc,r12=-1
80009a40:	d8 2a       	popm	r4-r7,pc,r12=0
80009a42:	d7 03       	nop

80009a44 <__register_exitproc>:
80009a44:	d4 31       	pushm	r0-r7,lr
80009a46:	fe c8 d0 92 	sub	r8,pc,-12142
80009a4a:	70 03       	ld.w	r3,r8[0x0]
80009a4c:	67 24       	ld.w	r4,r3[0x48]
80009a4e:	e6 c8 ff b4 	sub	r8,r3,-76
80009a52:	58 04       	cp.w	r4,0
80009a54:	f0 04 17 00 	moveq	r4,r8
80009a58:	e7 f4 0a 12 	st.weq	r3[0x48],r4
80009a5c:	18 97       	mov	r7,r12
80009a5e:	16 96       	mov	r6,r11
80009a60:	14 95       	mov	r5,r10
80009a62:	12 92       	mov	r2,r9
80009a64:	68 18       	ld.w	r8,r4[0x4]
80009a66:	59 f8       	cp.w	r8,31
80009a68:	e0 8a 00 0e 	brle	80009a84 <__register_exitproc+0x40>
80009a6c:	e0 6c 00 8c 	mov	r12,140
80009a70:	fe b0 e9 56 	rcall	80006d1c <malloc>
80009a74:	18 94       	mov	r4,r12
80009a76:	c3 80       	breq	80009ae6 <__register_exitproc+0xa2>
80009a78:	67 28       	ld.w	r8,r3[0x48]
80009a7a:	99 08       	st.w	r12[0x0],r8
80009a7c:	e7 4c 00 48 	st.w	r3[72],r12
80009a80:	30 08       	mov	r8,0
80009a82:	99 18       	st.w	r12[0x4],r8
80009a84:	58 07       	cp.w	r7,0
80009a86:	c2 70       	breq	80009ad4 <__register_exitproc+0x90>
80009a88:	e8 fc 00 88 	ld.w	r12,r4[136]
80009a8c:	58 0c       	cp.w	r12,0
80009a8e:	c0 d1       	brne	80009aa8 <__register_exitproc+0x64>
80009a90:	e0 6c 01 08 	mov	r12,264
80009a94:	fe b0 e9 44 	rcall	80006d1c <malloc>
80009a98:	c2 70       	breq	80009ae6 <__register_exitproc+0xa2>
80009a9a:	30 08       	mov	r8,0
80009a9c:	e9 4c 00 88 	st.w	r4[136],r12
80009aa0:	f9 48 01 04 	st.w	r12[260],r8
80009aa4:	f9 48 01 00 	st.w	r12[256],r8
80009aa8:	68 18       	ld.w	r8,r4[0x4]
80009aaa:	f0 c9 ff e0 	sub	r9,r8,-32
80009aae:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
80009ab2:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
80009ab6:	30 1a       	mov	r10,1
80009ab8:	f8 f9 01 00 	ld.w	r9,r12[256]
80009abc:	f4 08 09 48 	lsl	r8,r10,r8
80009ac0:	10 49       	or	r9,r8
80009ac2:	f9 49 01 00 	st.w	r12[256],r9
80009ac6:	58 27       	cp.w	r7,2
80009ac8:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
80009acc:	f3 d8 e0 38 	oreq	r8,r9,r8
80009ad0:	f9 f8 0a 41 	st.weq	r12[0x104],r8
80009ad4:	68 18       	ld.w	r8,r4[0x4]
80009ad6:	30 0c       	mov	r12,0
80009ad8:	f0 c9 ff ff 	sub	r9,r8,-1
80009adc:	2f e8       	sub	r8,-2
80009ade:	89 19       	st.w	r4[0x4],r9
80009ae0:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
80009ae4:	d8 32       	popm	r0-r7,pc
80009ae6:	dc 3a       	popm	r0-r7,pc,r12=-1

80009ae8 <__call_exitprocs>:
80009ae8:	d4 31       	pushm	r0-r7,lr
80009aea:	20 3d       	sub	sp,12
80009aec:	fe c8 d1 38 	sub	r8,pc,-11976
80009af0:	50 2c       	stdsp	sp[0x8],r12
80009af2:	70 08       	ld.w	r8,r8[0x0]
80009af4:	16 91       	mov	r1,r11
80009af6:	50 08       	stdsp	sp[0x0],r8
80009af8:	2b 88       	sub	r8,-72
80009afa:	50 18       	stdsp	sp[0x4],r8
80009afc:	40 0a       	lddsp	r10,sp[0x0]
80009afe:	40 14       	lddsp	r4,sp[0x4]
80009b00:	75 27       	ld.w	r7,r10[0x48]
80009b02:	c5 58       	rjmp	80009bac <__call_exitprocs+0xc4>
80009b04:	6e 15       	ld.w	r5,r7[0x4]
80009b06:	ee f6 00 88 	ld.w	r6,r7[136]
80009b0a:	ea c2 ff ff 	sub	r2,r5,-1
80009b0e:	20 15       	sub	r5,1
80009b10:	ee 02 00 22 	add	r2,r7,r2<<0x2
80009b14:	ec 05 00 23 	add	r3,r6,r5<<0x2
80009b18:	c3 58       	rjmp	80009b82 <__call_exitprocs+0x9a>
80009b1a:	58 01       	cp.w	r1,0
80009b1c:	c0 70       	breq	80009b2a <__call_exitprocs+0x42>
80009b1e:	58 06       	cp.w	r6,0
80009b20:	c2 e0       	breq	80009b7c <__call_exitprocs+0x94>
80009b22:	e6 f8 00 80 	ld.w	r8,r3[128]
80009b26:	02 38       	cp.w	r8,r1
80009b28:	c2 a1       	brne	80009b7c <__call_exitprocs+0x94>
80009b2a:	6e 19       	ld.w	r9,r7[0x4]
80009b2c:	64 08       	ld.w	r8,r2[0x0]
80009b2e:	20 19       	sub	r9,1
80009b30:	12 35       	cp.w	r5,r9
80009b32:	ef f5 0a 01 	st.weq	r7[0x4],r5
80009b36:	f9 b9 01 00 	movne	r9,0
80009b3a:	e5 f9 1a 00 	st.wne	r2[0x0],r9
80009b3e:	58 08       	cp.w	r8,0
80009b40:	c1 e0       	breq	80009b7c <__call_exitprocs+0x94>
80009b42:	6e 10       	ld.w	r0,r7[0x4]
80009b44:	58 06       	cp.w	r6,0
80009b46:	c0 90       	breq	80009b58 <__call_exitprocs+0x70>
80009b48:	30 1a       	mov	r10,1
80009b4a:	f4 05 09 49 	lsl	r9,r10,r5
80009b4e:	ec fa 01 00 	ld.w	r10,r6[256]
80009b52:	f3 ea 00 0a 	and	r10,r9,r10
80009b56:	c0 31       	brne	80009b5c <__call_exitprocs+0x74>
80009b58:	5d 18       	icall	r8
80009b5a:	c0 b8       	rjmp	80009b70 <__call_exitprocs+0x88>
80009b5c:	ec fa 01 04 	ld.w	r10,r6[260]
80009b60:	66 0b       	ld.w	r11,r3[0x0]
80009b62:	14 69       	and	r9,r10
80009b64:	c0 41       	brne	80009b6c <__call_exitprocs+0x84>
80009b66:	40 2c       	lddsp	r12,sp[0x8]
80009b68:	5d 18       	icall	r8
80009b6a:	c0 38       	rjmp	80009b70 <__call_exitprocs+0x88>
80009b6c:	16 9c       	mov	r12,r11
80009b6e:	5d 18       	icall	r8
80009b70:	6e 18       	ld.w	r8,r7[0x4]
80009b72:	10 30       	cp.w	r0,r8
80009b74:	cc 41       	brne	80009afc <__call_exitprocs+0x14>
80009b76:	68 08       	ld.w	r8,r4[0x0]
80009b78:	0e 38       	cp.w	r8,r7
80009b7a:	cc 11       	brne	80009afc <__call_exitprocs+0x14>
80009b7c:	20 15       	sub	r5,1
80009b7e:	20 43       	sub	r3,4
80009b80:	20 42       	sub	r2,4
80009b82:	58 05       	cp.w	r5,0
80009b84:	cc b4       	brge	80009b1a <__call_exitprocs+0x32>
80009b86:	6e 18       	ld.w	r8,r7[0x4]
80009b88:	58 08       	cp.w	r8,0
80009b8a:	c0 f1       	brne	80009ba8 <__call_exitprocs+0xc0>
80009b8c:	6e 08       	ld.w	r8,r7[0x0]
80009b8e:	58 08       	cp.w	r8,0
80009b90:	c0 c0       	breq	80009ba8 <__call_exitprocs+0xc0>
80009b92:	89 08       	st.w	r4[0x0],r8
80009b94:	58 06       	cp.w	r6,0
80009b96:	c0 40       	breq	80009b9e <__call_exitprocs+0xb6>
80009b98:	0c 9c       	mov	r12,r6
80009b9a:	fe b0 e8 b9 	rcall	80006d0c <free>
80009b9e:	0e 9c       	mov	r12,r7
80009ba0:	fe b0 e8 b6 	rcall	80006d0c <free>
80009ba4:	68 07       	ld.w	r7,r4[0x0]
80009ba6:	c0 38       	rjmp	80009bac <__call_exitprocs+0xc4>
80009ba8:	0e 94       	mov	r4,r7
80009baa:	6e 07       	ld.w	r7,r7[0x0]
80009bac:	58 07       	cp.w	r7,0
80009bae:	ca b1       	brne	80009b04 <__call_exitprocs+0x1c>
80009bb0:	2f dd       	sub	sp,-12
80009bb2:	d8 32       	popm	r0-r7,pc

80009bb4 <quorem>:
80009bb4:	d4 31       	pushm	r0-r7,lr
80009bb6:	20 2d       	sub	sp,8
80009bb8:	18 97       	mov	r7,r12
80009bba:	78 48       	ld.w	r8,r12[0x10]
80009bbc:	76 46       	ld.w	r6,r11[0x10]
80009bbe:	0c 38       	cp.w	r8,r6
80009bc0:	c0 34       	brge	80009bc6 <quorem+0x12>
80009bc2:	30 0c       	mov	r12,0
80009bc4:	c8 58       	rjmp	80009cce <quorem+0x11a>
80009bc6:	ec c2 ff fc 	sub	r2,r6,-4
80009bca:	f6 c3 ff ec 	sub	r3,r11,-20
80009bce:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009bd2:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009bd6:	2f f9       	sub	r9,-1
80009bd8:	20 16       	sub	r6,1
80009bda:	f8 09 0d 08 	divu	r8,r12,r9
80009bde:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009be2:	ee c4 ff ec 	sub	r4,r7,-20
80009be6:	10 95       	mov	r5,r8
80009be8:	58 08       	cp.w	r8,0
80009bea:	c4 10       	breq	80009c6c <quorem+0xb8>
80009bec:	30 09       	mov	r9,0
80009bee:	06 9a       	mov	r10,r3
80009bf0:	08 98       	mov	r8,r4
80009bf2:	12 91       	mov	r1,r9
80009bf4:	50 0b       	stdsp	sp[0x0],r11
80009bf6:	70 0e       	ld.w	lr,r8[0x0]
80009bf8:	b1 8e       	lsr	lr,0x10
80009bfa:	50 1e       	stdsp	sp[0x4],lr
80009bfc:	15 0e       	ld.w	lr,r10++
80009bfe:	fc 00 16 10 	lsr	r0,lr,0x10
80009c02:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009c06:	ea 0e 03 41 	mac	r1,r5,lr
80009c0a:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009c0e:	b1 81       	lsr	r1,0x10
80009c10:	40 1b       	lddsp	r11,sp[0x4]
80009c12:	ea 00 02 40 	mul	r0,r5,r0
80009c16:	e2 00 00 00 	add	r0,r1,r0
80009c1a:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009c1e:	02 1b       	sub	r11,r1
80009c20:	50 1b       	stdsp	sp[0x4],r11
80009c22:	70 0b       	ld.w	r11,r8[0x0]
80009c24:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009c28:	02 09       	add	r9,r1
80009c2a:	f2 0e 01 0e 	sub	lr,r9,lr
80009c2e:	b0 1e       	st.h	r8[0x2],lr
80009c30:	fc 09 14 10 	asr	r9,lr,0x10
80009c34:	40 1e       	lddsp	lr,sp[0x4]
80009c36:	fc 09 00 09 	add	r9,lr,r9
80009c3a:	b0 09       	st.h	r8[0x0],r9
80009c3c:	e0 01 16 10 	lsr	r1,r0,0x10
80009c40:	2f c8       	sub	r8,-4
80009c42:	b1 49       	asr	r9,0x10
80009c44:	04 3a       	cp.w	r10,r2
80009c46:	fe 98 ff d8 	brls	80009bf6 <quorem+0x42>
80009c4a:	40 0b       	lddsp	r11,sp[0x0]
80009c4c:	58 0c       	cp.w	r12,0
80009c4e:	c0 f1       	brne	80009c6c <quorem+0xb8>
80009c50:	ec c8 ff fb 	sub	r8,r6,-5
80009c54:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009c58:	c0 28       	rjmp	80009c5c <quorem+0xa8>
80009c5a:	20 16       	sub	r6,1
80009c5c:	20 48       	sub	r8,4
80009c5e:	08 38       	cp.w	r8,r4
80009c60:	e0 88 00 05 	brls	80009c6a <quorem+0xb6>
80009c64:	70 09       	ld.w	r9,r8[0x0]
80009c66:	58 09       	cp.w	r9,0
80009c68:	cf 90       	breq	80009c5a <quorem+0xa6>
80009c6a:	8f 46       	st.w	r7[0x10],r6
80009c6c:	0e 9c       	mov	r12,r7
80009c6e:	e0 a0 0a d2 	rcall	8000b212 <__mcmp>
80009c72:	c2 d5       	brlt	80009ccc <quorem+0x118>
80009c74:	2f f5       	sub	r5,-1
80009c76:	08 98       	mov	r8,r4
80009c78:	30 09       	mov	r9,0
80009c7a:	07 0b       	ld.w	r11,r3++
80009c7c:	f6 0a 16 10 	lsr	r10,r11,0x10
80009c80:	70 0c       	ld.w	r12,r8[0x0]
80009c82:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009c86:	f8 0e 16 10 	lsr	lr,r12,0x10
80009c8a:	14 1e       	sub	lr,r10
80009c8c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009c90:	16 1a       	sub	r10,r11
80009c92:	12 0a       	add	r10,r9
80009c94:	b0 1a       	st.h	r8[0x2],r10
80009c96:	b1 4a       	asr	r10,0x10
80009c98:	fc 0a 00 09 	add	r9,lr,r10
80009c9c:	b0 09       	st.h	r8[0x0],r9
80009c9e:	2f c8       	sub	r8,-4
80009ca0:	b1 49       	asr	r9,0x10
80009ca2:	04 33       	cp.w	r3,r2
80009ca4:	fe 98 ff eb 	brls	80009c7a <quorem+0xc6>
80009ca8:	ec c8 ff fb 	sub	r8,r6,-5
80009cac:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009cb0:	58 09       	cp.w	r9,0
80009cb2:	c0 d1       	brne	80009ccc <quorem+0x118>
80009cb4:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009cb8:	c0 28       	rjmp	80009cbc <quorem+0x108>
80009cba:	20 16       	sub	r6,1
80009cbc:	20 48       	sub	r8,4
80009cbe:	08 38       	cp.w	r8,r4
80009cc0:	e0 88 00 05 	brls	80009cca <quorem+0x116>
80009cc4:	70 09       	ld.w	r9,r8[0x0]
80009cc6:	58 09       	cp.w	r9,0
80009cc8:	cf 90       	breq	80009cba <quorem+0x106>
80009cca:	8f 46       	st.w	r7[0x10],r6
80009ccc:	0a 9c       	mov	r12,r5
80009cce:	2f ed       	sub	sp,-8
80009cd0:	d8 32       	popm	r0-r7,pc
80009cd2:	d7 03       	nop

80009cd4 <_dtoa_r>:
80009cd4:	d4 31       	pushm	r0-r7,lr
80009cd6:	21 ad       	sub	sp,104
80009cd8:	fa c4 ff 74 	sub	r4,sp,-140
80009cdc:	18 97       	mov	r7,r12
80009cde:	16 95       	mov	r5,r11
80009ce0:	68 2c       	ld.w	r12,r4[0x8]
80009ce2:	50 c9       	stdsp	sp[0x30],r9
80009ce4:	68 16       	ld.w	r6,r4[0x4]
80009ce6:	68 09       	ld.w	r9,r4[0x0]
80009ce8:	50 e8       	stdsp	sp[0x38],r8
80009cea:	14 94       	mov	r4,r10
80009cec:	51 2c       	stdsp	sp[0x48],r12
80009cee:	fa e5 00 08 	st.d	sp[8],r4
80009cf2:	51 59       	stdsp	sp[0x54],r9
80009cf4:	6e 95       	ld.w	r5,r7[0x24]
80009cf6:	58 05       	cp.w	r5,0
80009cf8:	c0 91       	brne	80009d0a <_dtoa_r+0x36>
80009cfa:	31 0c       	mov	r12,16
80009cfc:	fe b0 e8 10 	rcall	80006d1c <malloc>
80009d00:	99 35       	st.w	r12[0xc],r5
80009d02:	8f 9c       	st.w	r7[0x24],r12
80009d04:	99 15       	st.w	r12[0x4],r5
80009d06:	99 25       	st.w	r12[0x8],r5
80009d08:	99 05       	st.w	r12[0x0],r5
80009d0a:	6e 99       	ld.w	r9,r7[0x24]
80009d0c:	72 08       	ld.w	r8,r9[0x0]
80009d0e:	58 08       	cp.w	r8,0
80009d10:	c0 f0       	breq	80009d2e <_dtoa_r+0x5a>
80009d12:	72 1a       	ld.w	r10,r9[0x4]
80009d14:	91 1a       	st.w	r8[0x4],r10
80009d16:	30 1a       	mov	r10,1
80009d18:	72 19       	ld.w	r9,r9[0x4]
80009d1a:	f4 09 09 49 	lsl	r9,r10,r9
80009d1e:	10 9b       	mov	r11,r8
80009d20:	91 29       	st.w	r8[0x8],r9
80009d22:	0e 9c       	mov	r12,r7
80009d24:	e0 a0 0a 90 	rcall	8000b244 <_Bfree>
80009d28:	6e 98       	ld.w	r8,r7[0x24]
80009d2a:	30 09       	mov	r9,0
80009d2c:	91 09       	st.w	r8[0x0],r9
80009d2e:	40 28       	lddsp	r8,sp[0x8]
80009d30:	10 94       	mov	r4,r8
80009d32:	58 08       	cp.w	r8,0
80009d34:	c0 64       	brge	80009d40 <_dtoa_r+0x6c>
80009d36:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009d3a:	50 28       	stdsp	sp[0x8],r8
80009d3c:	30 18       	mov	r8,1
80009d3e:	c0 28       	rjmp	80009d42 <_dtoa_r+0x6e>
80009d40:	30 08       	mov	r8,0
80009d42:	8d 08       	st.w	r6[0x0],r8
80009d44:	fc 1c 7f f0 	movh	r12,0x7ff0
80009d48:	40 26       	lddsp	r6,sp[0x8]
80009d4a:	0c 98       	mov	r8,r6
80009d4c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009d50:	18 38       	cp.w	r8,r12
80009d52:	c2 01       	brne	80009d92 <_dtoa_r+0xbe>
80009d54:	e0 68 27 0f 	mov	r8,9999
80009d58:	41 5b       	lddsp	r11,sp[0x54]
80009d5a:	97 08       	st.w	r11[0x0],r8
80009d5c:	40 3a       	lddsp	r10,sp[0xc]
80009d5e:	58 0a       	cp.w	r10,0
80009d60:	c0 71       	brne	80009d6e <_dtoa_r+0x9a>
80009d62:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009d66:	c0 41       	brne	80009d6e <_dtoa_r+0x9a>
80009d68:	fe cc cf dc 	sub	r12,pc,-12324
80009d6c:	c0 38       	rjmp	80009d72 <_dtoa_r+0x9e>
80009d6e:	fe cc cf d6 	sub	r12,pc,-12330
80009d72:	41 29       	lddsp	r9,sp[0x48]
80009d74:	58 09       	cp.w	r9,0
80009d76:	e0 80 05 9a 	breq	8000a8aa <_dtoa_r+0xbd6>
80009d7a:	f8 c8 ff fd 	sub	r8,r12,-3
80009d7e:	f8 c9 ff f8 	sub	r9,r12,-8
80009d82:	11 8b       	ld.ub	r11,r8[0x0]
80009d84:	30 0a       	mov	r10,0
80009d86:	41 25       	lddsp	r5,sp[0x48]
80009d88:	f4 0b 18 00 	cp.b	r11,r10
80009d8c:	f2 08 17 10 	movne	r8,r9
80009d90:	c1 68       	rjmp	80009dbc <_dtoa_r+0xe8>
80009d92:	fa ea 00 08 	ld.d	r10,sp[8]
80009d96:	30 08       	mov	r8,0
80009d98:	fa eb 00 3c 	st.d	sp[60],r10
80009d9c:	30 09       	mov	r9,0
80009d9e:	e0 a0 10 ce 	rcall	8000bf3a <__avr32_f64_cmp_eq>
80009da2:	c1 00       	breq	80009dc2 <_dtoa_r+0xee>
80009da4:	30 18       	mov	r8,1
80009da6:	41 5a       	lddsp	r10,sp[0x54]
80009da8:	95 08       	st.w	r10[0x0],r8
80009daa:	fe cc d1 42 	sub	r12,pc,-11966
80009dae:	41 29       	lddsp	r9,sp[0x48]
80009db0:	f8 08 00 08 	add	r8,r12,r8
80009db4:	58 09       	cp.w	r9,0
80009db6:	e0 80 05 7a 	breq	8000a8aa <_dtoa_r+0xbd6>
80009dba:	12 95       	mov	r5,r9
80009dbc:	8b 08       	st.w	r5[0x0],r8
80009dbe:	e0 8f 05 76 	bral	8000a8aa <_dtoa_r+0xbd6>
80009dc2:	fa c8 ff 9c 	sub	r8,sp,-100
80009dc6:	fa c9 ff a0 	sub	r9,sp,-96
80009dca:	fa ea 00 3c 	ld.d	r10,sp[60]
80009dce:	0e 9c       	mov	r12,r7
80009dd0:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009dd4:	e0 a0 0a 8a 	rcall	8000b2e8 <__d2b>
80009dd8:	18 93       	mov	r3,r12
80009dda:	58 05       	cp.w	r5,0
80009ddc:	c0 d0       	breq	80009df6 <_dtoa_r+0x122>
80009dde:	fa ea 00 3c 	ld.d	r10,sp[60]
80009de2:	30 04       	mov	r4,0
80009de4:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009de8:	ea c5 03 ff 	sub	r5,r5,1023
80009dec:	10 9b       	mov	r11,r8
80009dee:	51 74       	stdsp	sp[0x5c],r4
80009df0:	ea 1b 3f f0 	orh	r11,0x3ff0
80009df4:	c2 58       	rjmp	80009e3e <_dtoa_r+0x16a>
80009df6:	41 88       	lddsp	r8,sp[0x60]
80009df8:	41 9c       	lddsp	r12,sp[0x64]
80009dfa:	10 0c       	add	r12,r8
80009dfc:	f8 c5 fb ce 	sub	r5,r12,-1074
80009e00:	e0 45 00 20 	cp.w	r5,32
80009e04:	e0 8a 00 0e 	brle	80009e20 <_dtoa_r+0x14c>
80009e08:	f8 cc fb ee 	sub	r12,r12,-1042
80009e0c:	40 3b       	lddsp	r11,sp[0xc]
80009e0e:	ea 08 11 40 	rsub	r8,r5,64
80009e12:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009e16:	ec 08 09 46 	lsl	r6,r6,r8
80009e1a:	0c 4c       	or	r12,r6
80009e1c:	c0 78       	rjmp	80009e2a <_dtoa_r+0x156>
80009e1e:	d7 03       	nop
80009e20:	ea 0c 11 20 	rsub	r12,r5,32
80009e24:	40 3a       	lddsp	r10,sp[0xc]
80009e26:	f4 0c 09 4c 	lsl	r12,r10,r12
80009e2a:	e0 a0 10 14 	rcall	8000be52 <__avr32_u32_to_f64>
80009e2e:	fc 18 fe 10 	movh	r8,0xfe10
80009e32:	30 19       	mov	r9,1
80009e34:	ea c5 04 33 	sub	r5,r5,1075
80009e38:	f0 0b 00 0b 	add	r11,r8,r11
80009e3c:	51 79       	stdsp	sp[0x5c],r9
80009e3e:	30 08       	mov	r8,0
80009e40:	fc 19 3f f8 	movh	r9,0x3ff8
80009e44:	e0 a0 0e 9c 	rcall	8000bb7c <__avr32_f64_sub>
80009e48:	e0 68 43 61 	mov	r8,17249
80009e4c:	ea 18 63 6f 	orh	r8,0x636f
80009e50:	e0 69 87 a7 	mov	r9,34727
80009e54:	ea 19 3f d2 	orh	r9,0x3fd2
80009e58:	e0 a0 0d a6 	rcall	8000b9a4 <__avr32_f64_mul>
80009e5c:	e0 68 c8 b3 	mov	r8,51379
80009e60:	ea 18 8b 60 	orh	r8,0x8b60
80009e64:	e0 69 8a 28 	mov	r9,35368
80009e68:	ea 19 3f c6 	orh	r9,0x3fc6
80009e6c:	e0 a0 0f 56 	rcall	8000bd18 <__avr32_f64_add>
80009e70:	0a 9c       	mov	r12,r5
80009e72:	14 90       	mov	r0,r10
80009e74:	16 91       	mov	r1,r11
80009e76:	e0 a0 0f f2 	rcall	8000be5a <__avr32_s32_to_f64>
80009e7a:	e0 68 79 fb 	mov	r8,31227
80009e7e:	ea 18 50 9f 	orh	r8,0x509f
80009e82:	e0 69 44 13 	mov	r9,17427
80009e86:	ea 19 3f d3 	orh	r9,0x3fd3
80009e8a:	e0 a0 0d 8d 	rcall	8000b9a4 <__avr32_f64_mul>
80009e8e:	14 98       	mov	r8,r10
80009e90:	16 99       	mov	r9,r11
80009e92:	00 9a       	mov	r10,r0
80009e94:	02 9b       	mov	r11,r1
80009e96:	e0 a0 0f 41 	rcall	8000bd18 <__avr32_f64_add>
80009e9a:	14 90       	mov	r0,r10
80009e9c:	16 91       	mov	r1,r11
80009e9e:	e0 a0 0f c7 	rcall	8000be2c <__avr32_f64_to_s32>
80009ea2:	30 08       	mov	r8,0
80009ea4:	18 96       	mov	r6,r12
80009ea6:	30 09       	mov	r9,0
80009ea8:	00 9a       	mov	r10,r0
80009eaa:	02 9b       	mov	r11,r1
80009eac:	e0 a0 10 8e 	rcall	8000bfc8 <__avr32_f64_cmp_lt>
80009eb0:	c0 c0       	breq	80009ec8 <_dtoa_r+0x1f4>
80009eb2:	0c 9c       	mov	r12,r6
80009eb4:	e0 a0 0f d3 	rcall	8000be5a <__avr32_s32_to_f64>
80009eb8:	14 98       	mov	r8,r10
80009eba:	16 99       	mov	r9,r11
80009ebc:	00 9a       	mov	r10,r0
80009ebe:	02 9b       	mov	r11,r1
80009ec0:	e0 a0 10 3d 	rcall	8000bf3a <__avr32_f64_cmp_eq>
80009ec4:	f7 b6 00 01 	subeq	r6,1
80009ec8:	59 66       	cp.w	r6,22
80009eca:	e0 88 00 05 	brls	80009ed4 <_dtoa_r+0x200>
80009ece:	30 18       	mov	r8,1
80009ed0:	51 48       	stdsp	sp[0x50],r8
80009ed2:	c1 38       	rjmp	80009ef8 <_dtoa_r+0x224>
80009ed4:	fe c8 d0 8c 	sub	r8,pc,-12148
80009ed8:	fa ea 00 3c 	ld.d	r10,sp[60]
80009edc:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009ee0:	e0 a0 10 74 	rcall	8000bfc8 <__avr32_f64_cmp_lt>
80009ee4:	f9 b4 00 00 	moveq	r4,0
80009ee8:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009eec:	f7 b6 01 01 	subne	r6,1
80009ef0:	f9 bc 01 00 	movne	r12,0
80009ef4:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009ef8:	41 90       	lddsp	r0,sp[0x64]
80009efa:	20 10       	sub	r0,1
80009efc:	0a 10       	sub	r0,r5
80009efe:	c0 46       	brmi	80009f06 <_dtoa_r+0x232>
80009f00:	50 40       	stdsp	sp[0x10],r0
80009f02:	30 00       	mov	r0,0
80009f04:	c0 48       	rjmp	80009f0c <_dtoa_r+0x238>
80009f06:	30 0b       	mov	r11,0
80009f08:	5c 30       	neg	r0
80009f0a:	50 4b       	stdsp	sp[0x10],r11
80009f0c:	ec 02 11 00 	rsub	r2,r6,0
80009f10:	58 06       	cp.w	r6,0
80009f12:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009f16:	f5 d6 e4 0a 	addge	r10,r10,r6
80009f1a:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009f1e:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009f22:	f9 b2 04 00 	movge	r2,0
80009f26:	e1 d6 e5 10 	sublt	r0,r0,r6
80009f2a:	f9 b9 05 00 	movlt	r9,0
80009f2e:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009f32:	40 c8       	lddsp	r8,sp[0x30]
80009f34:	58 98       	cp.w	r8,9
80009f36:	e0 8b 00 20 	brhi	80009f76 <_dtoa_r+0x2a2>
80009f3a:	58 58       	cp.w	r8,5
80009f3c:	f9 b4 0a 01 	movle	r4,1
80009f40:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009f44:	f7 b5 09 04 	subgt	r5,4
80009f48:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009f4c:	f9 b4 09 00 	movgt	r4,0
80009f50:	40 cc       	lddsp	r12,sp[0x30]
80009f52:	58 3c       	cp.w	r12,3
80009f54:	c2 d0       	breq	80009fae <_dtoa_r+0x2da>
80009f56:	e0 89 00 05 	brgt	80009f60 <_dtoa_r+0x28c>
80009f5a:	58 2c       	cp.w	r12,2
80009f5c:	c1 01       	brne	80009f7c <_dtoa_r+0x2a8>
80009f5e:	c1 88       	rjmp	80009f8e <_dtoa_r+0x2ba>
80009f60:	40 cb       	lddsp	r11,sp[0x30]
80009f62:	58 4b       	cp.w	r11,4
80009f64:	c0 60       	breq	80009f70 <_dtoa_r+0x29c>
80009f66:	58 5b       	cp.w	r11,5
80009f68:	c0 a1       	brne	80009f7c <_dtoa_r+0x2a8>
80009f6a:	30 1a       	mov	r10,1
80009f6c:	50 da       	stdsp	sp[0x34],r10
80009f6e:	c2 28       	rjmp	80009fb2 <_dtoa_r+0x2de>
80009f70:	30 19       	mov	r9,1
80009f72:	50 d9       	stdsp	sp[0x34],r9
80009f74:	c0 f8       	rjmp	80009f92 <_dtoa_r+0x2be>
80009f76:	30 08       	mov	r8,0
80009f78:	30 14       	mov	r4,1
80009f7a:	50 c8       	stdsp	sp[0x30],r8
80009f7c:	3f f5       	mov	r5,-1
80009f7e:	30 1c       	mov	r12,1
80009f80:	30 0b       	mov	r11,0
80009f82:	50 95       	stdsp	sp[0x24],r5
80009f84:	50 dc       	stdsp	sp[0x34],r12
80009f86:	0a 91       	mov	r1,r5
80009f88:	31 28       	mov	r8,18
80009f8a:	50 eb       	stdsp	sp[0x38],r11
80009f8c:	c2 08       	rjmp	80009fcc <_dtoa_r+0x2f8>
80009f8e:	30 0a       	mov	r10,0
80009f90:	50 da       	stdsp	sp[0x34],r10
80009f92:	40 e9       	lddsp	r9,sp[0x38]
80009f94:	58 09       	cp.w	r9,0
80009f96:	e0 89 00 07 	brgt	80009fa4 <_dtoa_r+0x2d0>
80009f9a:	30 18       	mov	r8,1
80009f9c:	50 98       	stdsp	sp[0x24],r8
80009f9e:	10 91       	mov	r1,r8
80009fa0:	50 e8       	stdsp	sp[0x38],r8
80009fa2:	c1 58       	rjmp	80009fcc <_dtoa_r+0x2f8>
80009fa4:	40 e5       	lddsp	r5,sp[0x38]
80009fa6:	50 95       	stdsp	sp[0x24],r5
80009fa8:	0a 91       	mov	r1,r5
80009faa:	0a 98       	mov	r8,r5
80009fac:	c1 08       	rjmp	80009fcc <_dtoa_r+0x2f8>
80009fae:	30 0c       	mov	r12,0
80009fb0:	50 dc       	stdsp	sp[0x34],r12
80009fb2:	40 eb       	lddsp	r11,sp[0x38]
80009fb4:	ec 0b 00 0b 	add	r11,r6,r11
80009fb8:	50 9b       	stdsp	sp[0x24],r11
80009fba:	16 98       	mov	r8,r11
80009fbc:	2f f8       	sub	r8,-1
80009fbe:	58 08       	cp.w	r8,0
80009fc0:	e0 89 00 05 	brgt	80009fca <_dtoa_r+0x2f6>
80009fc4:	10 91       	mov	r1,r8
80009fc6:	30 18       	mov	r8,1
80009fc8:	c0 28       	rjmp	80009fcc <_dtoa_r+0x2f8>
80009fca:	10 91       	mov	r1,r8
80009fcc:	30 09       	mov	r9,0
80009fce:	6e 9a       	ld.w	r10,r7[0x24]
80009fd0:	95 19       	st.w	r10[0x4],r9
80009fd2:	30 49       	mov	r9,4
80009fd4:	c0 68       	rjmp	80009fe0 <_dtoa_r+0x30c>
80009fd6:	d7 03       	nop
80009fd8:	6a 1a       	ld.w	r10,r5[0x4]
80009fda:	a1 79       	lsl	r9,0x1
80009fdc:	2f fa       	sub	r10,-1
80009fde:	8b 1a       	st.w	r5[0x4],r10
80009fe0:	6e 95       	ld.w	r5,r7[0x24]
80009fe2:	f2 ca ff ec 	sub	r10,r9,-20
80009fe6:	10 3a       	cp.w	r10,r8
80009fe8:	fe 98 ff f8 	brls	80009fd8 <_dtoa_r+0x304>
80009fec:	6a 1b       	ld.w	r11,r5[0x4]
80009fee:	0e 9c       	mov	r12,r7
80009ff0:	e0 a0 09 44 	rcall	8000b278 <_Balloc>
80009ff4:	58 e1       	cp.w	r1,14
80009ff6:	5f 88       	srls	r8
80009ff8:	8b 0c       	st.w	r5[0x0],r12
80009ffa:	f1 e4 00 04 	and	r4,r8,r4
80009ffe:	6e 98       	ld.w	r8,r7[0x24]
8000a000:	70 08       	ld.w	r8,r8[0x0]
8000a002:	50 88       	stdsp	sp[0x20],r8
8000a004:	e0 80 01 82 	breq	8000a308 <_dtoa_r+0x634>
8000a008:	58 06       	cp.w	r6,0
8000a00a:	e0 8a 00 43 	brle	8000a090 <_dtoa_r+0x3bc>
8000a00e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a012:	fe c8 d1 ca 	sub	r8,pc,-11830
8000a016:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a01a:	fa e5 00 18 	st.d	sp[24],r4
8000a01e:	ec 04 14 04 	asr	r4,r6,0x4
8000a022:	ed b4 00 04 	bld	r4,0x4
8000a026:	c0 30       	breq	8000a02c <_dtoa_r+0x358>
8000a028:	30 25       	mov	r5,2
8000a02a:	c1 08       	rjmp	8000a04a <_dtoa_r+0x376>
8000a02c:	fe c8 d1 1c 	sub	r8,pc,-12004
8000a030:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a034:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a038:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a03c:	e0 a0 0f fa 	rcall	8000c030 <__avr32_f64_div>
8000a040:	30 35       	mov	r5,3
8000a042:	14 98       	mov	r8,r10
8000a044:	16 99       	mov	r9,r11
8000a046:	fa e9 00 08 	st.d	sp[8],r8
8000a04a:	fe cc d1 3a 	sub	r12,pc,-11974
8000a04e:	50 a3       	stdsp	sp[0x28],r3
8000a050:	0c 93       	mov	r3,r6
8000a052:	18 96       	mov	r6,r12
8000a054:	c0 f8       	rjmp	8000a072 <_dtoa_r+0x39e>
8000a056:	fa ea 00 18 	ld.d	r10,sp[24]
8000a05a:	ed b4 00 00 	bld	r4,0x0
8000a05e:	c0 81       	brne	8000a06e <_dtoa_r+0x39a>
8000a060:	ec e8 00 00 	ld.d	r8,r6[0]
8000a064:	2f f5       	sub	r5,-1
8000a066:	e0 a0 0c 9f 	rcall	8000b9a4 <__avr32_f64_mul>
8000a06a:	fa eb 00 18 	st.d	sp[24],r10
8000a06e:	a1 54       	asr	r4,0x1
8000a070:	2f 86       	sub	r6,-8
8000a072:	58 04       	cp.w	r4,0
8000a074:	cf 11       	brne	8000a056 <_dtoa_r+0x382>
8000a076:	fa e8 00 18 	ld.d	r8,sp[24]
8000a07a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a07e:	06 96       	mov	r6,r3
8000a080:	e0 a0 0f d8 	rcall	8000c030 <__avr32_f64_div>
8000a084:	40 a3       	lddsp	r3,sp[0x28]
8000a086:	14 98       	mov	r8,r10
8000a088:	16 99       	mov	r9,r11
8000a08a:	fa e9 00 08 	st.d	sp[8],r8
8000a08e:	c2 f8       	rjmp	8000a0ec <_dtoa_r+0x418>
8000a090:	ec 08 11 00 	rsub	r8,r6,0
8000a094:	c0 31       	brne	8000a09a <_dtoa_r+0x3c6>
8000a096:	30 25       	mov	r5,2
8000a098:	c2 a8       	rjmp	8000a0ec <_dtoa_r+0x418>
8000a09a:	fe cc d1 8a 	sub	r12,pc,-11894
8000a09e:	f0 04 14 04 	asr	r4,r8,0x4
8000a0a2:	50 1c       	stdsp	sp[0x4],r12
8000a0a4:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a0a8:	fe c9 d2 60 	sub	r9,pc,-11680
8000a0ac:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a0b0:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a0b4:	e0 a0 0c 78 	rcall	8000b9a4 <__avr32_f64_mul>
8000a0b8:	40 1c       	lddsp	r12,sp[0x4]
8000a0ba:	50 63       	stdsp	sp[0x18],r3
8000a0bc:	30 25       	mov	r5,2
8000a0be:	0c 93       	mov	r3,r6
8000a0c0:	fa eb 00 08 	st.d	sp[8],r10
8000a0c4:	18 96       	mov	r6,r12
8000a0c6:	c0 f8       	rjmp	8000a0e4 <_dtoa_r+0x410>
8000a0c8:	fa ea 00 08 	ld.d	r10,sp[8]
8000a0cc:	ed b4 00 00 	bld	r4,0x0
8000a0d0:	c0 81       	brne	8000a0e0 <_dtoa_r+0x40c>
8000a0d2:	ec e8 00 00 	ld.d	r8,r6[0]
8000a0d6:	2f f5       	sub	r5,-1
8000a0d8:	e0 a0 0c 66 	rcall	8000b9a4 <__avr32_f64_mul>
8000a0dc:	fa eb 00 08 	st.d	sp[8],r10
8000a0e0:	a1 54       	asr	r4,0x1
8000a0e2:	2f 86       	sub	r6,-8
8000a0e4:	58 04       	cp.w	r4,0
8000a0e6:	cf 11       	brne	8000a0c8 <_dtoa_r+0x3f4>
8000a0e8:	06 96       	mov	r6,r3
8000a0ea:	40 63       	lddsp	r3,sp[0x18]
8000a0ec:	41 4a       	lddsp	r10,sp[0x50]
8000a0ee:	58 0a       	cp.w	r10,0
8000a0f0:	c2 a0       	breq	8000a144 <_dtoa_r+0x470>
8000a0f2:	fa e8 00 08 	ld.d	r8,sp[8]
8000a0f6:	58 01       	cp.w	r1,0
8000a0f8:	5f 94       	srgt	r4
8000a0fa:	fa e9 00 18 	st.d	sp[24],r8
8000a0fe:	30 08       	mov	r8,0
8000a100:	fc 19 3f f0 	movh	r9,0x3ff0
8000a104:	fa ea 00 18 	ld.d	r10,sp[24]
8000a108:	e0 a0 0f 60 	rcall	8000bfc8 <__avr32_f64_cmp_lt>
8000a10c:	f9 bc 00 00 	moveq	r12,0
8000a110:	f9 bc 01 01 	movne	r12,1
8000a114:	e9 ec 00 0c 	and	r12,r4,r12
8000a118:	c1 60       	breq	8000a144 <_dtoa_r+0x470>
8000a11a:	40 98       	lddsp	r8,sp[0x24]
8000a11c:	58 08       	cp.w	r8,0
8000a11e:	e0 8a 00 f1 	brle	8000a300 <_dtoa_r+0x62c>
8000a122:	30 08       	mov	r8,0
8000a124:	fc 19 40 24 	movh	r9,0x4024
8000a128:	ec c4 00 01 	sub	r4,r6,1
8000a12c:	fa ea 00 18 	ld.d	r10,sp[24]
8000a130:	2f f5       	sub	r5,-1
8000a132:	50 64       	stdsp	sp[0x18],r4
8000a134:	e0 a0 0c 38 	rcall	8000b9a4 <__avr32_f64_mul>
8000a138:	40 94       	lddsp	r4,sp[0x24]
8000a13a:	14 98       	mov	r8,r10
8000a13c:	16 99       	mov	r9,r11
8000a13e:	fa e9 00 08 	st.d	sp[8],r8
8000a142:	c0 38       	rjmp	8000a148 <_dtoa_r+0x474>
8000a144:	50 66       	stdsp	sp[0x18],r6
8000a146:	02 94       	mov	r4,r1
8000a148:	0a 9c       	mov	r12,r5
8000a14a:	e0 a0 0e 88 	rcall	8000be5a <__avr32_s32_to_f64>
8000a14e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a152:	e0 a0 0c 29 	rcall	8000b9a4 <__avr32_f64_mul>
8000a156:	30 08       	mov	r8,0
8000a158:	fc 19 40 1c 	movh	r9,0x401c
8000a15c:	e0 a0 0d de 	rcall	8000bd18 <__avr32_f64_add>
8000a160:	14 98       	mov	r8,r10
8000a162:	16 99       	mov	r9,r11
8000a164:	fa e9 00 28 	st.d	sp[40],r8
8000a168:	fc 18 fc c0 	movh	r8,0xfcc0
8000a16c:	40 a5       	lddsp	r5,sp[0x28]
8000a16e:	10 05       	add	r5,r8
8000a170:	50 a5       	stdsp	sp[0x28],r5
8000a172:	58 04       	cp.w	r4,0
8000a174:	c2 11       	brne	8000a1b6 <_dtoa_r+0x4e2>
8000a176:	fa ea 00 08 	ld.d	r10,sp[8]
8000a17a:	30 08       	mov	r8,0
8000a17c:	fc 19 40 14 	movh	r9,0x4014
8000a180:	e0 a0 0c fe 	rcall	8000bb7c <__avr32_f64_sub>
8000a184:	40 bc       	lddsp	r12,sp[0x2c]
8000a186:	fa eb 00 08 	st.d	sp[8],r10
8000a18a:	14 98       	mov	r8,r10
8000a18c:	16 99       	mov	r9,r11
8000a18e:	18 9a       	mov	r10,r12
8000a190:	0a 9b       	mov	r11,r5
8000a192:	e0 a0 0f 1b 	rcall	8000bfc8 <__avr32_f64_cmp_lt>
8000a196:	e0 81 02 54 	brne	8000a63e <_dtoa_r+0x96a>
8000a19a:	0a 98       	mov	r8,r5
8000a19c:	40 b9       	lddsp	r9,sp[0x2c]
8000a19e:	ee 18 80 00 	eorh	r8,0x8000
8000a1a2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1a6:	10 95       	mov	r5,r8
8000a1a8:	12 98       	mov	r8,r9
8000a1aa:	0a 99       	mov	r9,r5
8000a1ac:	e0 a0 0f 0e 	rcall	8000bfc8 <__avr32_f64_cmp_lt>
8000a1b0:	e0 81 02 3e 	brne	8000a62c <_dtoa_r+0x958>
8000a1b4:	ca 68       	rjmp	8000a300 <_dtoa_r+0x62c>
8000a1b6:	fe c9 d3 6e 	sub	r9,pc,-11410
8000a1ba:	e8 c8 00 01 	sub	r8,r4,1
8000a1be:	40 d5       	lddsp	r5,sp[0x34]
8000a1c0:	58 05       	cp.w	r5,0
8000a1c2:	c4 f0       	breq	8000a260 <_dtoa_r+0x58c>
8000a1c4:	30 0c       	mov	r12,0
8000a1c6:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a1ca:	51 3c       	stdsp	sp[0x4c],r12
8000a1cc:	30 0a       	mov	r10,0
8000a1ce:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a1d2:	e0 a0 0f 2f 	rcall	8000c030 <__avr32_f64_div>
8000a1d6:	fa e8 00 28 	ld.d	r8,sp[40]
8000a1da:	40 85       	lddsp	r5,sp[0x20]
8000a1dc:	e0 a0 0c d0 	rcall	8000bb7c <__avr32_f64_sub>
8000a1e0:	fa eb 00 28 	st.d	sp[40],r10
8000a1e4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1e8:	e0 a0 0e 22 	rcall	8000be2c <__avr32_f64_to_s32>
8000a1ec:	51 6c       	stdsp	sp[0x58],r12
8000a1ee:	e0 a0 0e 36 	rcall	8000be5a <__avr32_s32_to_f64>
8000a1f2:	14 98       	mov	r8,r10
8000a1f4:	16 99       	mov	r9,r11
8000a1f6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1fa:	e0 a0 0c c1 	rcall	8000bb7c <__avr32_f64_sub>
8000a1fe:	fa eb 00 08 	st.d	sp[8],r10
8000a202:	41 68       	lddsp	r8,sp[0x58]
8000a204:	2d 08       	sub	r8,-48
8000a206:	0a c8       	st.b	r5++,r8
8000a208:	41 39       	lddsp	r9,sp[0x4c]
8000a20a:	2f f9       	sub	r9,-1
8000a20c:	51 39       	stdsp	sp[0x4c],r9
8000a20e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a212:	e0 a0 0e db 	rcall	8000bfc8 <__avr32_f64_cmp_lt>
8000a216:	e0 81 03 39 	brne	8000a888 <_dtoa_r+0xbb4>
8000a21a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a21e:	30 0a       	mov	r10,0
8000a220:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a224:	e0 a0 0c ac 	rcall	8000bb7c <__avr32_f64_sub>
8000a228:	fa e8 00 28 	ld.d	r8,sp[40]
8000a22c:	e0 a0 0e ce 	rcall	8000bfc8 <__avr32_f64_cmp_lt>
8000a230:	fa ea 00 28 	ld.d	r10,sp[40]
8000a234:	30 08       	mov	r8,0
8000a236:	fc 19 40 24 	movh	r9,0x4024
8000a23a:	e0 81 00 da 	brne	8000a3ee <_dtoa_r+0x71a>
8000a23e:	41 3c       	lddsp	r12,sp[0x4c]
8000a240:	08 3c       	cp.w	r12,r4
8000a242:	c5 f4       	brge	8000a300 <_dtoa_r+0x62c>
8000a244:	e0 a0 0b b0 	rcall	8000b9a4 <__avr32_f64_mul>
8000a248:	30 08       	mov	r8,0
8000a24a:	fa eb 00 28 	st.d	sp[40],r10
8000a24e:	fc 19 40 24 	movh	r9,0x4024
8000a252:	fa ea 00 08 	ld.d	r10,sp[8]
8000a256:	e0 a0 0b a7 	rcall	8000b9a4 <__avr32_f64_mul>
8000a25a:	fa eb 00 08 	st.d	sp[8],r10
8000a25e:	cc 3b       	rjmp	8000a1e4 <_dtoa_r+0x510>
8000a260:	40 85       	lddsp	r5,sp[0x20]
8000a262:	08 05       	add	r5,r4
8000a264:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a268:	51 35       	stdsp	sp[0x4c],r5
8000a26a:	fa e8 00 28 	ld.d	r8,sp[40]
8000a26e:	40 85       	lddsp	r5,sp[0x20]
8000a270:	e0 a0 0b 9a 	rcall	8000b9a4 <__avr32_f64_mul>
8000a274:	fa eb 00 28 	st.d	sp[40],r10
8000a278:	fa ea 00 08 	ld.d	r10,sp[8]
8000a27c:	e0 a0 0d d8 	rcall	8000be2c <__avr32_f64_to_s32>
8000a280:	51 6c       	stdsp	sp[0x58],r12
8000a282:	e0 a0 0d ec 	rcall	8000be5a <__avr32_s32_to_f64>
8000a286:	14 98       	mov	r8,r10
8000a288:	16 99       	mov	r9,r11
8000a28a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a28e:	e0 a0 0c 77 	rcall	8000bb7c <__avr32_f64_sub>
8000a292:	fa eb 00 08 	st.d	sp[8],r10
8000a296:	41 68       	lddsp	r8,sp[0x58]
8000a298:	2d 08       	sub	r8,-48
8000a29a:	0a c8       	st.b	r5++,r8
8000a29c:	41 3c       	lddsp	r12,sp[0x4c]
8000a29e:	18 35       	cp.w	r5,r12
8000a2a0:	c2 81       	brne	8000a2f0 <_dtoa_r+0x61c>
8000a2a2:	30 08       	mov	r8,0
8000a2a4:	fc 19 3f e0 	movh	r9,0x3fe0
8000a2a8:	fa ea 00 28 	ld.d	r10,sp[40]
8000a2ac:	e0 a0 0d 36 	rcall	8000bd18 <__avr32_f64_add>
8000a2b0:	40 85       	lddsp	r5,sp[0x20]
8000a2b2:	fa e8 00 08 	ld.d	r8,sp[8]
8000a2b6:	08 05       	add	r5,r4
8000a2b8:	e0 a0 0e 88 	rcall	8000bfc8 <__avr32_f64_cmp_lt>
8000a2bc:	e0 81 00 99 	brne	8000a3ee <_dtoa_r+0x71a>
8000a2c0:	fa e8 00 28 	ld.d	r8,sp[40]
8000a2c4:	30 0a       	mov	r10,0
8000a2c6:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a2ca:	e0 a0 0c 59 	rcall	8000bb7c <__avr32_f64_sub>
8000a2ce:	14 98       	mov	r8,r10
8000a2d0:	16 99       	mov	r9,r11
8000a2d2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2d6:	e0 a0 0e 79 	rcall	8000bfc8 <__avr32_f64_cmp_lt>
8000a2da:	c1 30       	breq	8000a300 <_dtoa_r+0x62c>
8000a2dc:	33 09       	mov	r9,48
8000a2de:	0a 98       	mov	r8,r5
8000a2e0:	11 7a       	ld.ub	r10,--r8
8000a2e2:	f2 0a 18 00 	cp.b	r10,r9
8000a2e6:	e0 81 02 d1 	brne	8000a888 <_dtoa_r+0xbb4>
8000a2ea:	10 95       	mov	r5,r8
8000a2ec:	cf 9b       	rjmp	8000a2de <_dtoa_r+0x60a>
8000a2ee:	d7 03       	nop
8000a2f0:	30 08       	mov	r8,0
8000a2f2:	fc 19 40 24 	movh	r9,0x4024
8000a2f6:	e0 a0 0b 57 	rcall	8000b9a4 <__avr32_f64_mul>
8000a2fa:	fa eb 00 08 	st.d	sp[8],r10
8000a2fe:	cb db       	rjmp	8000a278 <_dtoa_r+0x5a4>
8000a300:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a304:	fa eb 00 08 	st.d	sp[8],r10
8000a308:	58 e6       	cp.w	r6,14
8000a30a:	5f ab       	srle	r11
8000a30c:	41 8a       	lddsp	r10,sp[0x60]
8000a30e:	30 08       	mov	r8,0
8000a310:	f4 09 11 ff 	rsub	r9,r10,-1
8000a314:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a318:	f0 09 18 00 	cp.b	r9,r8
8000a31c:	e0 80 00 82 	breq	8000a420 <_dtoa_r+0x74c>
8000a320:	40 ea       	lddsp	r10,sp[0x38]
8000a322:	58 01       	cp.w	r1,0
8000a324:	5f a9       	srle	r9
8000a326:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a32a:	fe ca d4 e2 	sub	r10,pc,-11038
8000a32e:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a332:	fa e5 00 10 	st.d	sp[16],r4
8000a336:	f0 09 18 00 	cp.b	r9,r8
8000a33a:	c1 40       	breq	8000a362 <_dtoa_r+0x68e>
8000a33c:	58 01       	cp.w	r1,0
8000a33e:	e0 81 01 77 	brne	8000a62c <_dtoa_r+0x958>
8000a342:	30 08       	mov	r8,0
8000a344:	fc 19 40 14 	movh	r9,0x4014
8000a348:	08 9a       	mov	r10,r4
8000a34a:	0a 9b       	mov	r11,r5
8000a34c:	e0 a0 0b 2c 	rcall	8000b9a4 <__avr32_f64_mul>
8000a350:	fa e8 00 08 	ld.d	r8,sp[8]
8000a354:	e0 a0 0e 06 	rcall	8000bf60 <__avr32_f64_cmp_ge>
8000a358:	e0 81 01 6a 	brne	8000a62c <_dtoa_r+0x958>
8000a35c:	02 92       	mov	r2,r1
8000a35e:	e0 8f 01 72 	bral	8000a642 <_dtoa_r+0x96e>
8000a362:	40 85       	lddsp	r5,sp[0x20]
8000a364:	30 14       	mov	r4,1
8000a366:	fa e8 00 10 	ld.d	r8,sp[16]
8000a36a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a36e:	e0 a0 0e 61 	rcall	8000c030 <__avr32_f64_div>
8000a372:	e0 a0 0d 5d 	rcall	8000be2c <__avr32_f64_to_s32>
8000a376:	18 92       	mov	r2,r12
8000a378:	e0 a0 0d 71 	rcall	8000be5a <__avr32_s32_to_f64>
8000a37c:	fa e8 00 10 	ld.d	r8,sp[16]
8000a380:	e0 a0 0b 12 	rcall	8000b9a4 <__avr32_f64_mul>
8000a384:	14 98       	mov	r8,r10
8000a386:	16 99       	mov	r9,r11
8000a388:	fa ea 00 08 	ld.d	r10,sp[8]
8000a38c:	e0 a0 0b f8 	rcall	8000bb7c <__avr32_f64_sub>
8000a390:	fa eb 00 08 	st.d	sp[8],r10
8000a394:	e4 c8 ff d0 	sub	r8,r2,-48
8000a398:	0a c8       	st.b	r5++,r8
8000a39a:	fc 19 40 24 	movh	r9,0x4024
8000a39e:	30 08       	mov	r8,0
8000a3a0:	02 34       	cp.w	r4,r1
8000a3a2:	c3 31       	brne	8000a408 <_dtoa_r+0x734>
8000a3a4:	fa e8 00 08 	ld.d	r8,sp[8]
8000a3a8:	e0 a0 0c b8 	rcall	8000bd18 <__avr32_f64_add>
8000a3ac:	16 91       	mov	r1,r11
8000a3ae:	14 90       	mov	r0,r10
8000a3b0:	14 98       	mov	r8,r10
8000a3b2:	02 99       	mov	r9,r1
8000a3b4:	fa ea 00 10 	ld.d	r10,sp[16]
8000a3b8:	e0 a0 0e 08 	rcall	8000bfc8 <__avr32_f64_cmp_lt>
8000a3bc:	c1 a1       	brne	8000a3f0 <_dtoa_r+0x71c>
8000a3be:	fa e8 00 10 	ld.d	r8,sp[16]
8000a3c2:	00 9a       	mov	r10,r0
8000a3c4:	02 9b       	mov	r11,r1
8000a3c6:	e0 a0 0d ba 	rcall	8000bf3a <__avr32_f64_cmp_eq>
8000a3ca:	e0 80 02 5e 	breq	8000a886 <_dtoa_r+0xbb2>
8000a3ce:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a3d2:	c0 f1       	brne	8000a3f0 <_dtoa_r+0x71c>
8000a3d4:	e0 8f 02 59 	bral	8000a886 <_dtoa_r+0xbb2>
8000a3d8:	40 8a       	lddsp	r10,sp[0x20]
8000a3da:	14 38       	cp.w	r8,r10
8000a3dc:	c0 30       	breq	8000a3e2 <_dtoa_r+0x70e>
8000a3de:	10 95       	mov	r5,r8
8000a3e0:	c0 98       	rjmp	8000a3f2 <_dtoa_r+0x71e>
8000a3e2:	33 08       	mov	r8,48
8000a3e4:	40 89       	lddsp	r9,sp[0x20]
8000a3e6:	2f f6       	sub	r6,-1
8000a3e8:	b2 88       	st.b	r9[0x0],r8
8000a3ea:	40 88       	lddsp	r8,sp[0x20]
8000a3ec:	c0 88       	rjmp	8000a3fc <_dtoa_r+0x728>
8000a3ee:	40 66       	lddsp	r6,sp[0x18]
8000a3f0:	33 99       	mov	r9,57
8000a3f2:	0a 98       	mov	r8,r5
8000a3f4:	11 7a       	ld.ub	r10,--r8
8000a3f6:	f2 0a 18 00 	cp.b	r10,r9
8000a3fa:	ce f0       	breq	8000a3d8 <_dtoa_r+0x704>
8000a3fc:	50 66       	stdsp	sp[0x18],r6
8000a3fe:	11 89       	ld.ub	r9,r8[0x0]
8000a400:	2f f9       	sub	r9,-1
8000a402:	b0 89       	st.b	r8[0x0],r9
8000a404:	e0 8f 02 42 	bral	8000a888 <_dtoa_r+0xbb4>
8000a408:	e0 a0 0a ce 	rcall	8000b9a4 <__avr32_f64_mul>
8000a40c:	2f f4       	sub	r4,-1
8000a40e:	fa eb 00 08 	st.d	sp[8],r10
8000a412:	30 08       	mov	r8,0
8000a414:	30 09       	mov	r9,0
8000a416:	e0 a0 0d 92 	rcall	8000bf3a <__avr32_f64_cmp_eq>
8000a41a:	ca 60       	breq	8000a366 <_dtoa_r+0x692>
8000a41c:	e0 8f 02 35 	bral	8000a886 <_dtoa_r+0xbb2>
8000a420:	40 d8       	lddsp	r8,sp[0x34]
8000a422:	58 08       	cp.w	r8,0
8000a424:	c0 51       	brne	8000a42e <_dtoa_r+0x75a>
8000a426:	04 98       	mov	r8,r2
8000a428:	00 95       	mov	r5,r0
8000a42a:	40 d4       	lddsp	r4,sp[0x34]
8000a42c:	c3 78       	rjmp	8000a49a <_dtoa_r+0x7c6>
8000a42e:	40 c5       	lddsp	r5,sp[0x30]
8000a430:	58 15       	cp.w	r5,1
8000a432:	e0 89 00 0f 	brgt	8000a450 <_dtoa_r+0x77c>
8000a436:	41 74       	lddsp	r4,sp[0x5c]
8000a438:	58 04       	cp.w	r4,0
8000a43a:	c0 40       	breq	8000a442 <_dtoa_r+0x76e>
8000a43c:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a440:	c0 48       	rjmp	8000a448 <_dtoa_r+0x774>
8000a442:	41 99       	lddsp	r9,sp[0x64]
8000a444:	f2 09 11 36 	rsub	r9,r9,54
8000a448:	04 98       	mov	r8,r2
8000a44a:	00 95       	mov	r5,r0
8000a44c:	c1 c8       	rjmp	8000a484 <_dtoa_r+0x7b0>
8000a44e:	d7 03       	nop
8000a450:	e2 c8 00 01 	sub	r8,r1,1
8000a454:	58 01       	cp.w	r1,0
8000a456:	e0 05 17 40 	movge	r5,r0
8000a45a:	e2 09 17 40 	movge	r9,r1
8000a45e:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a462:	f9 b9 05 00 	movlt	r9,0
8000a466:	10 32       	cp.w	r2,r8
8000a468:	e5 d8 e4 18 	subge	r8,r2,r8
8000a46c:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a470:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a474:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a478:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a47c:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a480:	f9 b8 05 00 	movlt	r8,0
8000a484:	40 4b       	lddsp	r11,sp[0x10]
8000a486:	12 0b       	add	r11,r9
8000a488:	50 08       	stdsp	sp[0x0],r8
8000a48a:	50 4b       	stdsp	sp[0x10],r11
8000a48c:	12 00       	add	r0,r9
8000a48e:	30 1b       	mov	r11,1
8000a490:	0e 9c       	mov	r12,r7
8000a492:	e0 a0 08 a7 	rcall	8000b5e0 <__i2b>
8000a496:	40 08       	lddsp	r8,sp[0x0]
8000a498:	18 94       	mov	r4,r12
8000a49a:	40 4a       	lddsp	r10,sp[0x10]
8000a49c:	58 05       	cp.w	r5,0
8000a49e:	5f 99       	srgt	r9
8000a4a0:	58 0a       	cp.w	r10,0
8000a4a2:	5f 9a       	srgt	r10
8000a4a4:	f5 e9 00 09 	and	r9,r10,r9
8000a4a8:	c0 80       	breq	8000a4b8 <_dtoa_r+0x7e4>
8000a4aa:	40 4c       	lddsp	r12,sp[0x10]
8000a4ac:	f8 05 0d 49 	min	r9,r12,r5
8000a4b0:	12 1c       	sub	r12,r9
8000a4b2:	12 10       	sub	r0,r9
8000a4b4:	50 4c       	stdsp	sp[0x10],r12
8000a4b6:	12 15       	sub	r5,r9
8000a4b8:	58 02       	cp.w	r2,0
8000a4ba:	e0 8a 00 27 	brle	8000a508 <_dtoa_r+0x834>
8000a4be:	40 db       	lddsp	r11,sp[0x34]
8000a4c0:	58 0b       	cp.w	r11,0
8000a4c2:	c1 d0       	breq	8000a4fc <_dtoa_r+0x828>
8000a4c4:	58 08       	cp.w	r8,0
8000a4c6:	e0 8a 00 17 	brle	8000a4f4 <_dtoa_r+0x820>
8000a4ca:	10 9a       	mov	r10,r8
8000a4cc:	50 08       	stdsp	sp[0x0],r8
8000a4ce:	08 9b       	mov	r11,r4
8000a4d0:	0e 9c       	mov	r12,r7
8000a4d2:	e0 a0 08 cd 	rcall	8000b66c <__pow5mult>
8000a4d6:	06 9a       	mov	r10,r3
8000a4d8:	18 9b       	mov	r11,r12
8000a4da:	18 94       	mov	r4,r12
8000a4dc:	0e 9c       	mov	r12,r7
8000a4de:	e0 a0 08 01 	rcall	8000b4e0 <__multiply>
8000a4e2:	18 99       	mov	r9,r12
8000a4e4:	06 9b       	mov	r11,r3
8000a4e6:	50 19       	stdsp	sp[0x4],r9
8000a4e8:	0e 9c       	mov	r12,r7
8000a4ea:	e0 a0 06 ad 	rcall	8000b244 <_Bfree>
8000a4ee:	40 19       	lddsp	r9,sp[0x4]
8000a4f0:	40 08       	lddsp	r8,sp[0x0]
8000a4f2:	12 93       	mov	r3,r9
8000a4f4:	e4 08 01 0a 	sub	r10,r2,r8
8000a4f8:	c0 80       	breq	8000a508 <_dtoa_r+0x834>
8000a4fa:	c0 28       	rjmp	8000a4fe <_dtoa_r+0x82a>
8000a4fc:	04 9a       	mov	r10,r2
8000a4fe:	06 9b       	mov	r11,r3
8000a500:	0e 9c       	mov	r12,r7
8000a502:	e0 a0 08 b5 	rcall	8000b66c <__pow5mult>
8000a506:	18 93       	mov	r3,r12
8000a508:	30 1b       	mov	r11,1
8000a50a:	0e 9c       	mov	r12,r7
8000a50c:	e0 a0 08 6a 	rcall	8000b5e0 <__i2b>
8000a510:	41 1a       	lddsp	r10,sp[0x44]
8000a512:	18 92       	mov	r2,r12
8000a514:	58 0a       	cp.w	r10,0
8000a516:	e0 8a 00 07 	brle	8000a524 <_dtoa_r+0x850>
8000a51a:	18 9b       	mov	r11,r12
8000a51c:	0e 9c       	mov	r12,r7
8000a51e:	e0 a0 08 a7 	rcall	8000b66c <__pow5mult>
8000a522:	18 92       	mov	r2,r12
8000a524:	40 c9       	lddsp	r9,sp[0x30]
8000a526:	58 19       	cp.w	r9,1
8000a528:	e0 89 00 14 	brgt	8000a550 <_dtoa_r+0x87c>
8000a52c:	40 38       	lddsp	r8,sp[0xc]
8000a52e:	58 08       	cp.w	r8,0
8000a530:	c1 01       	brne	8000a550 <_dtoa_r+0x87c>
8000a532:	40 29       	lddsp	r9,sp[0x8]
8000a534:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a538:	c0 c1       	brne	8000a550 <_dtoa_r+0x87c>
8000a53a:	12 98       	mov	r8,r9
8000a53c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a540:	c0 80       	breq	8000a550 <_dtoa_r+0x87c>
8000a542:	40 4c       	lddsp	r12,sp[0x10]
8000a544:	30 1b       	mov	r11,1
8000a546:	2f fc       	sub	r12,-1
8000a548:	2f f0       	sub	r0,-1
8000a54a:	50 4c       	stdsp	sp[0x10],r12
8000a54c:	50 6b       	stdsp	sp[0x18],r11
8000a54e:	c0 38       	rjmp	8000a554 <_dtoa_r+0x880>
8000a550:	30 0a       	mov	r10,0
8000a552:	50 6a       	stdsp	sp[0x18],r10
8000a554:	41 19       	lddsp	r9,sp[0x44]
8000a556:	58 09       	cp.w	r9,0
8000a558:	c0 31       	brne	8000a55e <_dtoa_r+0x88a>
8000a55a:	30 1c       	mov	r12,1
8000a55c:	c0 98       	rjmp	8000a56e <_dtoa_r+0x89a>
8000a55e:	64 48       	ld.w	r8,r2[0x10]
8000a560:	2f c8       	sub	r8,-4
8000a562:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a566:	e0 a0 05 df 	rcall	8000b124 <__hi0bits>
8000a56a:	f8 0c 11 20 	rsub	r12,r12,32
8000a56e:	40 4b       	lddsp	r11,sp[0x10]
8000a570:	f8 0b 00 08 	add	r8,r12,r11
8000a574:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a578:	c0 c0       	breq	8000a590 <_dtoa_r+0x8bc>
8000a57a:	f0 08 11 20 	rsub	r8,r8,32
8000a57e:	58 48       	cp.w	r8,4
8000a580:	e0 8a 00 06 	brle	8000a58c <_dtoa_r+0x8b8>
8000a584:	20 48       	sub	r8,4
8000a586:	10 0b       	add	r11,r8
8000a588:	50 4b       	stdsp	sp[0x10],r11
8000a58a:	c0 78       	rjmp	8000a598 <_dtoa_r+0x8c4>
8000a58c:	58 48       	cp.w	r8,4
8000a58e:	c0 70       	breq	8000a59c <_dtoa_r+0x8c8>
8000a590:	40 4a       	lddsp	r10,sp[0x10]
8000a592:	2e 48       	sub	r8,-28
8000a594:	10 0a       	add	r10,r8
8000a596:	50 4a       	stdsp	sp[0x10],r10
8000a598:	10 00       	add	r0,r8
8000a59a:	10 05       	add	r5,r8
8000a59c:	58 00       	cp.w	r0,0
8000a59e:	e0 8a 00 08 	brle	8000a5ae <_dtoa_r+0x8da>
8000a5a2:	06 9b       	mov	r11,r3
8000a5a4:	00 9a       	mov	r10,r0
8000a5a6:	0e 9c       	mov	r12,r7
8000a5a8:	e0 a0 07 58 	rcall	8000b458 <__lshift>
8000a5ac:	18 93       	mov	r3,r12
8000a5ae:	40 49       	lddsp	r9,sp[0x10]
8000a5b0:	58 09       	cp.w	r9,0
8000a5b2:	e0 8a 00 08 	brle	8000a5c2 <_dtoa_r+0x8ee>
8000a5b6:	04 9b       	mov	r11,r2
8000a5b8:	12 9a       	mov	r10,r9
8000a5ba:	0e 9c       	mov	r12,r7
8000a5bc:	e0 a0 07 4e 	rcall	8000b458 <__lshift>
8000a5c0:	18 92       	mov	r2,r12
8000a5c2:	41 48       	lddsp	r8,sp[0x50]
8000a5c4:	58 08       	cp.w	r8,0
8000a5c6:	c1 b0       	breq	8000a5fc <_dtoa_r+0x928>
8000a5c8:	04 9b       	mov	r11,r2
8000a5ca:	06 9c       	mov	r12,r3
8000a5cc:	e0 a0 06 23 	rcall	8000b212 <__mcmp>
8000a5d0:	c1 64       	brge	8000a5fc <_dtoa_r+0x928>
8000a5d2:	06 9b       	mov	r11,r3
8000a5d4:	30 09       	mov	r9,0
8000a5d6:	30 aa       	mov	r10,10
8000a5d8:	0e 9c       	mov	r12,r7
8000a5da:	e0 a0 08 0b 	rcall	8000b5f0 <__multadd>
8000a5de:	20 16       	sub	r6,1
8000a5e0:	18 93       	mov	r3,r12
8000a5e2:	40 dc       	lddsp	r12,sp[0x34]
8000a5e4:	58 0c       	cp.w	r12,0
8000a5e6:	c0 31       	brne	8000a5ec <_dtoa_r+0x918>
8000a5e8:	40 91       	lddsp	r1,sp[0x24]
8000a5ea:	c0 98       	rjmp	8000a5fc <_dtoa_r+0x928>
8000a5ec:	08 9b       	mov	r11,r4
8000a5ee:	40 91       	lddsp	r1,sp[0x24]
8000a5f0:	30 09       	mov	r9,0
8000a5f2:	30 aa       	mov	r10,10
8000a5f4:	0e 9c       	mov	r12,r7
8000a5f6:	e0 a0 07 fd 	rcall	8000b5f0 <__multadd>
8000a5fa:	18 94       	mov	r4,r12
8000a5fc:	58 01       	cp.w	r1,0
8000a5fe:	5f a9       	srle	r9
8000a600:	40 cb       	lddsp	r11,sp[0x30]
8000a602:	58 2b       	cp.w	r11,2
8000a604:	5f 98       	srgt	r8
8000a606:	f3 e8 00 08 	and	r8,r9,r8
8000a60a:	c2 50       	breq	8000a654 <_dtoa_r+0x980>
8000a60c:	58 01       	cp.w	r1,0
8000a60e:	c1 11       	brne	8000a630 <_dtoa_r+0x95c>
8000a610:	04 9b       	mov	r11,r2
8000a612:	02 99       	mov	r9,r1
8000a614:	30 5a       	mov	r10,5
8000a616:	0e 9c       	mov	r12,r7
8000a618:	e0 a0 07 ec 	rcall	8000b5f0 <__multadd>
8000a61c:	18 92       	mov	r2,r12
8000a61e:	18 9b       	mov	r11,r12
8000a620:	06 9c       	mov	r12,r3
8000a622:	e0 a0 05 f8 	rcall	8000b212 <__mcmp>
8000a626:	e0 89 00 0f 	brgt	8000a644 <_dtoa_r+0x970>
8000a62a:	c0 38       	rjmp	8000a630 <_dtoa_r+0x95c>
8000a62c:	30 02       	mov	r2,0
8000a62e:	04 94       	mov	r4,r2
8000a630:	40 ea       	lddsp	r10,sp[0x38]
8000a632:	30 09       	mov	r9,0
8000a634:	5c da       	com	r10
8000a636:	40 85       	lddsp	r5,sp[0x20]
8000a638:	50 6a       	stdsp	sp[0x18],r10
8000a63a:	50 49       	stdsp	sp[0x10],r9
8000a63c:	c0 f9       	rjmp	8000a85a <_dtoa_r+0xb86>
8000a63e:	08 92       	mov	r2,r4
8000a640:	40 66       	lddsp	r6,sp[0x18]
8000a642:	04 94       	mov	r4,r2
8000a644:	2f f6       	sub	r6,-1
8000a646:	50 66       	stdsp	sp[0x18],r6
8000a648:	33 18       	mov	r8,49
8000a64a:	40 85       	lddsp	r5,sp[0x20]
8000a64c:	0a c8       	st.b	r5++,r8
8000a64e:	30 08       	mov	r8,0
8000a650:	50 48       	stdsp	sp[0x10],r8
8000a652:	c0 49       	rjmp	8000a85a <_dtoa_r+0xb86>
8000a654:	40 dc       	lddsp	r12,sp[0x34]
8000a656:	58 0c       	cp.w	r12,0
8000a658:	e0 80 00 b5 	breq	8000a7c2 <_dtoa_r+0xaee>
8000a65c:	58 05       	cp.w	r5,0
8000a65e:	e0 8a 00 08 	brle	8000a66e <_dtoa_r+0x99a>
8000a662:	08 9b       	mov	r11,r4
8000a664:	0a 9a       	mov	r10,r5
8000a666:	0e 9c       	mov	r12,r7
8000a668:	e0 a0 06 f8 	rcall	8000b458 <__lshift>
8000a66c:	18 94       	mov	r4,r12
8000a66e:	40 6b       	lddsp	r11,sp[0x18]
8000a670:	58 0b       	cp.w	r11,0
8000a672:	c0 31       	brne	8000a678 <_dtoa_r+0x9a4>
8000a674:	08 9c       	mov	r12,r4
8000a676:	c1 38       	rjmp	8000a69c <_dtoa_r+0x9c8>
8000a678:	68 1b       	ld.w	r11,r4[0x4]
8000a67a:	0e 9c       	mov	r12,r7
8000a67c:	e0 a0 05 fe 	rcall	8000b278 <_Balloc>
8000a680:	68 4a       	ld.w	r10,r4[0x10]
8000a682:	18 95       	mov	r5,r12
8000a684:	e8 cb ff f4 	sub	r11,r4,-12
8000a688:	2f ea       	sub	r10,-2
8000a68a:	2f 4c       	sub	r12,-12
8000a68c:	a3 6a       	lsl	r10,0x2
8000a68e:	fe b0 e5 6b 	rcall	80007164 <memcpy>
8000a692:	0a 9b       	mov	r11,r5
8000a694:	30 1a       	mov	r10,1
8000a696:	0e 9c       	mov	r12,r7
8000a698:	e0 a0 06 e0 	rcall	8000b458 <__lshift>
8000a69c:	50 44       	stdsp	sp[0x10],r4
8000a69e:	40 3a       	lddsp	r10,sp[0xc]
8000a6a0:	30 19       	mov	r9,1
8000a6a2:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a6a6:	18 94       	mov	r4,r12
8000a6a8:	50 da       	stdsp	sp[0x34],r10
8000a6aa:	40 85       	lddsp	r5,sp[0x20]
8000a6ac:	50 99       	stdsp	sp[0x24],r9
8000a6ae:	50 26       	stdsp	sp[0x8],r6
8000a6b0:	50 e1       	stdsp	sp[0x38],r1
8000a6b2:	04 9b       	mov	r11,r2
8000a6b4:	06 9c       	mov	r12,r3
8000a6b6:	fe b0 fa 7f 	rcall	80009bb4 <quorem>
8000a6ba:	40 4b       	lddsp	r11,sp[0x10]
8000a6bc:	f8 c0 ff d0 	sub	r0,r12,-48
8000a6c0:	06 9c       	mov	r12,r3
8000a6c2:	e0 a0 05 a8 	rcall	8000b212 <__mcmp>
8000a6c6:	08 9a       	mov	r10,r4
8000a6c8:	50 6c       	stdsp	sp[0x18],r12
8000a6ca:	04 9b       	mov	r11,r2
8000a6cc:	0e 9c       	mov	r12,r7
8000a6ce:	e0 a0 06 5d 	rcall	8000b388 <__mdiff>
8000a6d2:	18 91       	mov	r1,r12
8000a6d4:	78 38       	ld.w	r8,r12[0xc]
8000a6d6:	58 08       	cp.w	r8,0
8000a6d8:	c0 30       	breq	8000a6de <_dtoa_r+0xa0a>
8000a6da:	30 16       	mov	r6,1
8000a6dc:	c0 68       	rjmp	8000a6e8 <_dtoa_r+0xa14>
8000a6de:	18 9b       	mov	r11,r12
8000a6e0:	06 9c       	mov	r12,r3
8000a6e2:	e0 a0 05 98 	rcall	8000b212 <__mcmp>
8000a6e6:	18 96       	mov	r6,r12
8000a6e8:	0e 9c       	mov	r12,r7
8000a6ea:	02 9b       	mov	r11,r1
8000a6ec:	e0 a0 05 ac 	rcall	8000b244 <_Bfree>
8000a6f0:	40 cc       	lddsp	r12,sp[0x30]
8000a6f2:	ed ec 10 08 	or	r8,r6,r12
8000a6f6:	c0 d1       	brne	8000a710 <_dtoa_r+0xa3c>
8000a6f8:	40 db       	lddsp	r11,sp[0x34]
8000a6fa:	58 0b       	cp.w	r11,0
8000a6fc:	c0 a1       	brne	8000a710 <_dtoa_r+0xa3c>
8000a6fe:	40 26       	lddsp	r6,sp[0x8]
8000a700:	e0 40 00 39 	cp.w	r0,57
8000a704:	c3 00       	breq	8000a764 <_dtoa_r+0xa90>
8000a706:	40 6a       	lddsp	r10,sp[0x18]
8000a708:	58 0a       	cp.w	r10,0
8000a70a:	e0 89 00 24 	brgt	8000a752 <_dtoa_r+0xa7e>
8000a70e:	c2 f8       	rjmp	8000a76c <_dtoa_r+0xa98>
8000a710:	40 69       	lddsp	r9,sp[0x18]
8000a712:	58 09       	cp.w	r9,0
8000a714:	c0 85       	brlt	8000a724 <_dtoa_r+0xa50>
8000a716:	12 98       	mov	r8,r9
8000a718:	40 cc       	lddsp	r12,sp[0x30]
8000a71a:	18 48       	or	r8,r12
8000a71c:	c1 d1       	brne	8000a756 <_dtoa_r+0xa82>
8000a71e:	40 db       	lddsp	r11,sp[0x34]
8000a720:	58 0b       	cp.w	r11,0
8000a722:	c1 a1       	brne	8000a756 <_dtoa_r+0xa82>
8000a724:	0c 99       	mov	r9,r6
8000a726:	40 26       	lddsp	r6,sp[0x8]
8000a728:	58 09       	cp.w	r9,0
8000a72a:	e0 8a 00 21 	brle	8000a76c <_dtoa_r+0xa98>
8000a72e:	06 9b       	mov	r11,r3
8000a730:	30 1a       	mov	r10,1
8000a732:	0e 9c       	mov	r12,r7
8000a734:	e0 a0 06 92 	rcall	8000b458 <__lshift>
8000a738:	04 9b       	mov	r11,r2
8000a73a:	18 93       	mov	r3,r12
8000a73c:	e0 a0 05 6b 	rcall	8000b212 <__mcmp>
8000a740:	e0 89 00 06 	brgt	8000a74c <_dtoa_r+0xa78>
8000a744:	c1 41       	brne	8000a76c <_dtoa_r+0xa98>
8000a746:	ed b0 00 00 	bld	r0,0x0
8000a74a:	c1 11       	brne	8000a76c <_dtoa_r+0xa98>
8000a74c:	e0 40 00 39 	cp.w	r0,57
8000a750:	c0 a0       	breq	8000a764 <_dtoa_r+0xa90>
8000a752:	2f f0       	sub	r0,-1
8000a754:	c0 c8       	rjmp	8000a76c <_dtoa_r+0xa98>
8000a756:	58 06       	cp.w	r6,0
8000a758:	e0 8a 00 0c 	brle	8000a770 <_dtoa_r+0xa9c>
8000a75c:	40 26       	lddsp	r6,sp[0x8]
8000a75e:	e0 40 00 39 	cp.w	r0,57
8000a762:	c0 41       	brne	8000a76a <_dtoa_r+0xa96>
8000a764:	33 98       	mov	r8,57
8000a766:	0a c8       	st.b	r5++,r8
8000a768:	c6 78       	rjmp	8000a836 <_dtoa_r+0xb62>
8000a76a:	2f f0       	sub	r0,-1
8000a76c:	0a c0       	st.b	r5++,r0
8000a76e:	c7 58       	rjmp	8000a858 <_dtoa_r+0xb84>
8000a770:	0a c0       	st.b	r5++,r0
8000a772:	40 9a       	lddsp	r10,sp[0x24]
8000a774:	40 e9       	lddsp	r9,sp[0x38]
8000a776:	12 3a       	cp.w	r10,r9
8000a778:	c4 30       	breq	8000a7fe <_dtoa_r+0xb2a>
8000a77a:	06 9b       	mov	r11,r3
8000a77c:	30 09       	mov	r9,0
8000a77e:	30 aa       	mov	r10,10
8000a780:	0e 9c       	mov	r12,r7
8000a782:	e0 a0 07 37 	rcall	8000b5f0 <__multadd>
8000a786:	40 48       	lddsp	r8,sp[0x10]
8000a788:	18 93       	mov	r3,r12
8000a78a:	08 38       	cp.w	r8,r4
8000a78c:	c0 91       	brne	8000a79e <_dtoa_r+0xaca>
8000a78e:	10 9b       	mov	r11,r8
8000a790:	30 09       	mov	r9,0
8000a792:	30 aa       	mov	r10,10
8000a794:	0e 9c       	mov	r12,r7
8000a796:	e0 a0 07 2d 	rcall	8000b5f0 <__multadd>
8000a79a:	50 4c       	stdsp	sp[0x10],r12
8000a79c:	c0 e8       	rjmp	8000a7b8 <_dtoa_r+0xae4>
8000a79e:	40 4b       	lddsp	r11,sp[0x10]
8000a7a0:	30 09       	mov	r9,0
8000a7a2:	30 aa       	mov	r10,10
8000a7a4:	0e 9c       	mov	r12,r7
8000a7a6:	e0 a0 07 25 	rcall	8000b5f0 <__multadd>
8000a7aa:	08 9b       	mov	r11,r4
8000a7ac:	50 4c       	stdsp	sp[0x10],r12
8000a7ae:	30 09       	mov	r9,0
8000a7b0:	30 aa       	mov	r10,10
8000a7b2:	0e 9c       	mov	r12,r7
8000a7b4:	e0 a0 07 1e 	rcall	8000b5f0 <__multadd>
8000a7b8:	18 94       	mov	r4,r12
8000a7ba:	40 9c       	lddsp	r12,sp[0x24]
8000a7bc:	2f fc       	sub	r12,-1
8000a7be:	50 9c       	stdsp	sp[0x24],r12
8000a7c0:	c7 9b       	rjmp	8000a6b2 <_dtoa_r+0x9de>
8000a7c2:	30 18       	mov	r8,1
8000a7c4:	06 90       	mov	r0,r3
8000a7c6:	40 85       	lddsp	r5,sp[0x20]
8000a7c8:	08 93       	mov	r3,r4
8000a7ca:	0c 94       	mov	r4,r6
8000a7cc:	10 96       	mov	r6,r8
8000a7ce:	04 9b       	mov	r11,r2
8000a7d0:	00 9c       	mov	r12,r0
8000a7d2:	fe b0 f9 f1 	rcall	80009bb4 <quorem>
8000a7d6:	2d 0c       	sub	r12,-48
8000a7d8:	0a cc       	st.b	r5++,r12
8000a7da:	02 36       	cp.w	r6,r1
8000a7dc:	c0 a4       	brge	8000a7f0 <_dtoa_r+0xb1c>
8000a7de:	00 9b       	mov	r11,r0
8000a7e0:	30 09       	mov	r9,0
8000a7e2:	30 aa       	mov	r10,10
8000a7e4:	0e 9c       	mov	r12,r7
8000a7e6:	2f f6       	sub	r6,-1
8000a7e8:	e0 a0 07 04 	rcall	8000b5f0 <__multadd>
8000a7ec:	18 90       	mov	r0,r12
8000a7ee:	cf 0b       	rjmp	8000a7ce <_dtoa_r+0xafa>
8000a7f0:	08 96       	mov	r6,r4
8000a7f2:	30 0b       	mov	r11,0
8000a7f4:	06 94       	mov	r4,r3
8000a7f6:	50 4b       	stdsp	sp[0x10],r11
8000a7f8:	00 93       	mov	r3,r0
8000a7fa:	18 90       	mov	r0,r12
8000a7fc:	c0 28       	rjmp	8000a800 <_dtoa_r+0xb2c>
8000a7fe:	40 26       	lddsp	r6,sp[0x8]
8000a800:	06 9b       	mov	r11,r3
8000a802:	30 1a       	mov	r10,1
8000a804:	0e 9c       	mov	r12,r7
8000a806:	e0 a0 06 29 	rcall	8000b458 <__lshift>
8000a80a:	04 9b       	mov	r11,r2
8000a80c:	18 93       	mov	r3,r12
8000a80e:	e0 a0 05 02 	rcall	8000b212 <__mcmp>
8000a812:	e0 89 00 12 	brgt	8000a836 <_dtoa_r+0xb62>
8000a816:	c1 b1       	brne	8000a84c <_dtoa_r+0xb78>
8000a818:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a81c:	c0 d1       	brne	8000a836 <_dtoa_r+0xb62>
8000a81e:	c1 78       	rjmp	8000a84c <_dtoa_r+0xb78>
8000a820:	40 89       	lddsp	r9,sp[0x20]
8000a822:	12 38       	cp.w	r8,r9
8000a824:	c0 30       	breq	8000a82a <_dtoa_r+0xb56>
8000a826:	10 95       	mov	r5,r8
8000a828:	c0 88       	rjmp	8000a838 <_dtoa_r+0xb64>
8000a82a:	2f f6       	sub	r6,-1
8000a82c:	50 66       	stdsp	sp[0x18],r6
8000a82e:	33 18       	mov	r8,49
8000a830:	40 8c       	lddsp	r12,sp[0x20]
8000a832:	b8 88       	st.b	r12[0x0],r8
8000a834:	c1 38       	rjmp	8000a85a <_dtoa_r+0xb86>
8000a836:	33 9a       	mov	r10,57
8000a838:	0a 98       	mov	r8,r5
8000a83a:	11 79       	ld.ub	r9,--r8
8000a83c:	f4 09 18 00 	cp.b	r9,r10
8000a840:	cf 00       	breq	8000a820 <_dtoa_r+0xb4c>
8000a842:	2f f9       	sub	r9,-1
8000a844:	b0 89       	st.b	r8[0x0],r9
8000a846:	c0 98       	rjmp	8000a858 <_dtoa_r+0xb84>
8000a848:	10 95       	mov	r5,r8
8000a84a:	c0 28       	rjmp	8000a84e <_dtoa_r+0xb7a>
8000a84c:	33 09       	mov	r9,48
8000a84e:	0a 98       	mov	r8,r5
8000a850:	11 7a       	ld.ub	r10,--r8
8000a852:	f2 0a 18 00 	cp.b	r10,r9
8000a856:	cf 90       	breq	8000a848 <_dtoa_r+0xb74>
8000a858:	50 66       	stdsp	sp[0x18],r6
8000a85a:	04 9b       	mov	r11,r2
8000a85c:	0e 9c       	mov	r12,r7
8000a85e:	e0 a0 04 f3 	rcall	8000b244 <_Bfree>
8000a862:	58 04       	cp.w	r4,0
8000a864:	c1 20       	breq	8000a888 <_dtoa_r+0xbb4>
8000a866:	40 4b       	lddsp	r11,sp[0x10]
8000a868:	08 3b       	cp.w	r11,r4
8000a86a:	5f 19       	srne	r9
8000a86c:	58 0b       	cp.w	r11,0
8000a86e:	5f 18       	srne	r8
8000a870:	f3 e8 00 08 	and	r8,r9,r8
8000a874:	c0 40       	breq	8000a87c <_dtoa_r+0xba8>
8000a876:	0e 9c       	mov	r12,r7
8000a878:	e0 a0 04 e6 	rcall	8000b244 <_Bfree>
8000a87c:	08 9b       	mov	r11,r4
8000a87e:	0e 9c       	mov	r12,r7
8000a880:	e0 a0 04 e2 	rcall	8000b244 <_Bfree>
8000a884:	c0 28       	rjmp	8000a888 <_dtoa_r+0xbb4>
8000a886:	50 66       	stdsp	sp[0x18],r6
8000a888:	0e 9c       	mov	r12,r7
8000a88a:	06 9b       	mov	r11,r3
8000a88c:	e0 a0 04 dc 	rcall	8000b244 <_Bfree>
8000a890:	30 08       	mov	r8,0
8000a892:	aa 88       	st.b	r5[0x0],r8
8000a894:	40 68       	lddsp	r8,sp[0x18]
8000a896:	41 5a       	lddsp	r10,sp[0x54]
8000a898:	2f f8       	sub	r8,-1
8000a89a:	41 29       	lddsp	r9,sp[0x48]
8000a89c:	95 08       	st.w	r10[0x0],r8
8000a89e:	40 8c       	lddsp	r12,sp[0x20]
8000a8a0:	58 09       	cp.w	r9,0
8000a8a2:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a8a6:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a8aa:	2e 6d       	sub	sp,-104
8000a8ac:	d8 32       	popm	r0-r7,pc
8000a8ae:	d7 03       	nop

8000a8b0 <__errno>:
8000a8b0:	e0 68 01 18 	mov	r8,280
8000a8b4:	70 0c       	ld.w	r12,r8[0x0]
8000a8b6:	2f 4c       	sub	r12,-12
8000a8b8:	5e fc       	retal	r12
8000a8ba:	d7 03       	nop

8000a8bc <_fflush_r>:
8000a8bc:	d4 21       	pushm	r4-r7,lr
8000a8be:	16 97       	mov	r7,r11
8000a8c0:	18 96       	mov	r6,r12
8000a8c2:	76 48       	ld.w	r8,r11[0x10]
8000a8c4:	58 08       	cp.w	r8,0
8000a8c6:	c7 f0       	breq	8000a9c4 <_fflush_r+0x108>
8000a8c8:	58 0c       	cp.w	r12,0
8000a8ca:	c0 50       	breq	8000a8d4 <_fflush_r+0x18>
8000a8cc:	78 68       	ld.w	r8,r12[0x18]
8000a8ce:	58 08       	cp.w	r8,0
8000a8d0:	c0 21       	brne	8000a8d4 <_fflush_r+0x18>
8000a8d2:	cc dc       	rcall	8000aa6c <__sinit>
8000a8d4:	fe c8 db 38 	sub	r8,pc,-9416
8000a8d8:	10 37       	cp.w	r7,r8
8000a8da:	c0 31       	brne	8000a8e0 <_fflush_r+0x24>
8000a8dc:	6c 07       	ld.w	r7,r6[0x0]
8000a8de:	c0 c8       	rjmp	8000a8f6 <_fflush_r+0x3a>
8000a8e0:	fe c8 db 24 	sub	r8,pc,-9436
8000a8e4:	10 37       	cp.w	r7,r8
8000a8e6:	c0 31       	brne	8000a8ec <_fflush_r+0x30>
8000a8e8:	6c 17       	ld.w	r7,r6[0x4]
8000a8ea:	c0 68       	rjmp	8000a8f6 <_fflush_r+0x3a>
8000a8ec:	fe c8 db 10 	sub	r8,pc,-9456
8000a8f0:	10 37       	cp.w	r7,r8
8000a8f2:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a8f6:	8e 6a       	ld.sh	r10,r7[0xc]
8000a8f8:	14 98       	mov	r8,r10
8000a8fa:	ed ba 00 03 	bld	r10,0x3
8000a8fe:	c4 20       	breq	8000a982 <_fflush_r+0xc6>
8000a900:	ab ba       	sbr	r10,0xb
8000a902:	ae 6a       	st.h	r7[0xc],r10
8000a904:	6e 18       	ld.w	r8,r7[0x4]
8000a906:	58 08       	cp.w	r8,0
8000a908:	e0 89 00 06 	brgt	8000a914 <_fflush_r+0x58>
8000a90c:	6f 08       	ld.w	r8,r7[0x40]
8000a90e:	58 08       	cp.w	r8,0
8000a910:	e0 8a 00 5a 	brle	8000a9c4 <_fflush_r+0x108>
8000a914:	6e b8       	ld.w	r8,r7[0x2c]
8000a916:	58 08       	cp.w	r8,0
8000a918:	c5 60       	breq	8000a9c4 <_fflush_r+0x108>
8000a91a:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a91e:	c0 30       	breq	8000a924 <_fflush_r+0x68>
8000a920:	6f 55       	ld.w	r5,r7[0x54]
8000a922:	c0 f8       	rjmp	8000a940 <_fflush_r+0x84>
8000a924:	30 19       	mov	r9,1
8000a926:	6e 8b       	ld.w	r11,r7[0x20]
8000a928:	0c 9c       	mov	r12,r6
8000a92a:	5d 18       	icall	r8
8000a92c:	18 95       	mov	r5,r12
8000a92e:	5b fc       	cp.w	r12,-1
8000a930:	c0 81       	brne	8000a940 <_fflush_r+0x84>
8000a932:	6c 38       	ld.w	r8,r6[0xc]
8000a934:	59 d8       	cp.w	r8,29
8000a936:	c4 70       	breq	8000a9c4 <_fflush_r+0x108>
8000a938:	8e 68       	ld.sh	r8,r7[0xc]
8000a93a:	a7 a8       	sbr	r8,0x6
8000a93c:	ae 68       	st.h	r7[0xc],r8
8000a93e:	d8 22       	popm	r4-r7,pc
8000a940:	8e 68       	ld.sh	r8,r7[0xc]
8000a942:	ed b8 00 02 	bld	r8,0x2
8000a946:	c0 91       	brne	8000a958 <_fflush_r+0x9c>
8000a948:	6e 18       	ld.w	r8,r7[0x4]
8000a94a:	10 15       	sub	r5,r8
8000a94c:	6e d8       	ld.w	r8,r7[0x34]
8000a94e:	58 08       	cp.w	r8,0
8000a950:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a954:	eb d8 e1 15 	subne	r5,r5,r8
8000a958:	6e b8       	ld.w	r8,r7[0x2c]
8000a95a:	0c 9c       	mov	r12,r6
8000a95c:	30 09       	mov	r9,0
8000a95e:	0a 9a       	mov	r10,r5
8000a960:	6e 8b       	ld.w	r11,r7[0x20]
8000a962:	5d 18       	icall	r8
8000a964:	8e 68       	ld.sh	r8,r7[0xc]
8000a966:	0a 3c       	cp.w	r12,r5
8000a968:	c2 61       	brne	8000a9b4 <_fflush_r+0xf8>
8000a96a:	ab d8       	cbr	r8,0xb
8000a96c:	30 0c       	mov	r12,0
8000a96e:	6e 49       	ld.w	r9,r7[0x10]
8000a970:	ae 68       	st.h	r7[0xc],r8
8000a972:	8f 1c       	st.w	r7[0x4],r12
8000a974:	8f 09       	st.w	r7[0x0],r9
8000a976:	ed b8 00 0c 	bld	r8,0xc
8000a97a:	c2 51       	brne	8000a9c4 <_fflush_r+0x108>
8000a97c:	ef 45 00 54 	st.w	r7[84],r5
8000a980:	d8 22       	popm	r4-r7,pc
8000a982:	6e 45       	ld.w	r5,r7[0x10]
8000a984:	58 05       	cp.w	r5,0
8000a986:	c1 f0       	breq	8000a9c4 <_fflush_r+0x108>
8000a988:	6e 04       	ld.w	r4,r7[0x0]
8000a98a:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a98e:	8f 05       	st.w	r7[0x0],r5
8000a990:	f9 b8 01 00 	movne	r8,0
8000a994:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a998:	0a 14       	sub	r4,r5
8000a99a:	8f 28       	st.w	r7[0x8],r8
8000a99c:	c1 18       	rjmp	8000a9be <_fflush_r+0x102>
8000a99e:	08 99       	mov	r9,r4
8000a9a0:	0a 9a       	mov	r10,r5
8000a9a2:	6e a8       	ld.w	r8,r7[0x28]
8000a9a4:	6e 8b       	ld.w	r11,r7[0x20]
8000a9a6:	0c 9c       	mov	r12,r6
8000a9a8:	5d 18       	icall	r8
8000a9aa:	18 14       	sub	r4,r12
8000a9ac:	58 0c       	cp.w	r12,0
8000a9ae:	e0 89 00 07 	brgt	8000a9bc <_fflush_r+0x100>
8000a9b2:	8e 68       	ld.sh	r8,r7[0xc]
8000a9b4:	a7 a8       	sbr	r8,0x6
8000a9b6:	3f fc       	mov	r12,-1
8000a9b8:	ae 68       	st.h	r7[0xc],r8
8000a9ba:	d8 22       	popm	r4-r7,pc
8000a9bc:	18 05       	add	r5,r12
8000a9be:	58 04       	cp.w	r4,0
8000a9c0:	fe 99 ff ef 	brgt	8000a99e <_fflush_r+0xe2>
8000a9c4:	d8 2a       	popm	r4-r7,pc,r12=0
8000a9c6:	d7 03       	nop

8000a9c8 <__sfp_lock_acquire>:
8000a9c8:	5e fc       	retal	r12

8000a9ca <__sfp_lock_release>:
8000a9ca:	5e fc       	retal	r12

8000a9cc <_cleanup_r>:
8000a9cc:	d4 01       	pushm	lr
8000a9ce:	fe cb f0 ae 	sub	r11,pc,-3922
8000a9d2:	e0 a0 02 f7 	rcall	8000afc0 <_fwalk>
8000a9d6:	d8 02       	popm	pc

8000a9d8 <__sfmoreglue>:
8000a9d8:	d4 21       	pushm	r4-r7,lr
8000a9da:	16 95       	mov	r5,r11
8000a9dc:	f6 06 10 5c 	mul	r6,r11,92
8000a9e0:	ec cb ff f4 	sub	r11,r6,-12
8000a9e4:	fe b0 e1 a4 	rcall	80006d2c <_malloc_r>
8000a9e8:	18 97       	mov	r7,r12
8000a9ea:	c0 90       	breq	8000a9fc <__sfmoreglue+0x24>
8000a9ec:	99 15       	st.w	r12[0x4],r5
8000a9ee:	30 0b       	mov	r11,0
8000a9f0:	2f 4c       	sub	r12,-12
8000a9f2:	0c 9a       	mov	r10,r6
8000a9f4:	8f 2c       	st.w	r7[0x8],r12
8000a9f6:	8f 0b       	st.w	r7[0x0],r11
8000a9f8:	fe b0 e4 5a 	rcall	800072ac <memset>
8000a9fc:	0e 9c       	mov	r12,r7
8000a9fe:	d8 22       	popm	r4-r7,pc

8000aa00 <__sfp>:
8000aa00:	d4 21       	pushm	r4-r7,lr
8000aa02:	fe c8 e0 4e 	sub	r8,pc,-8114
8000aa06:	18 96       	mov	r6,r12
8000aa08:	70 07       	ld.w	r7,r8[0x0]
8000aa0a:	6e 68       	ld.w	r8,r7[0x18]
8000aa0c:	58 08       	cp.w	r8,0
8000aa0e:	c0 31       	brne	8000aa14 <__sfp+0x14>
8000aa10:	0e 9c       	mov	r12,r7
8000aa12:	c2 dc       	rcall	8000aa6c <__sinit>
8000aa14:	ee c7 ff 28 	sub	r7,r7,-216
8000aa18:	30 05       	mov	r5,0
8000aa1a:	6e 2c       	ld.w	r12,r7[0x8]
8000aa1c:	6e 18       	ld.w	r8,r7[0x4]
8000aa1e:	c0 68       	rjmp	8000aa2a <__sfp+0x2a>
8000aa20:	98 69       	ld.sh	r9,r12[0xc]
8000aa22:	ea 09 19 00 	cp.h	r9,r5
8000aa26:	c1 10       	breq	8000aa48 <__sfp+0x48>
8000aa28:	2a 4c       	sub	r12,-92
8000aa2a:	20 18       	sub	r8,1
8000aa2c:	cf a7       	brpl	8000aa20 <__sfp+0x20>
8000aa2e:	6e 08       	ld.w	r8,r7[0x0]
8000aa30:	58 08       	cp.w	r8,0
8000aa32:	c0 61       	brne	8000aa3e <__sfp+0x3e>
8000aa34:	30 4b       	mov	r11,4
8000aa36:	0c 9c       	mov	r12,r6
8000aa38:	cd 0f       	rcall	8000a9d8 <__sfmoreglue>
8000aa3a:	8f 0c       	st.w	r7[0x0],r12
8000aa3c:	c0 30       	breq	8000aa42 <__sfp+0x42>
8000aa3e:	6e 07       	ld.w	r7,r7[0x0]
8000aa40:	ce db       	rjmp	8000aa1a <__sfp+0x1a>
8000aa42:	30 c8       	mov	r8,12
8000aa44:	8d 38       	st.w	r6[0xc],r8
8000aa46:	d8 22       	popm	r4-r7,pc
8000aa48:	30 08       	mov	r8,0
8000aa4a:	f9 48 00 4c 	st.w	r12[76],r8
8000aa4e:	99 08       	st.w	r12[0x0],r8
8000aa50:	99 28       	st.w	r12[0x8],r8
8000aa52:	99 18       	st.w	r12[0x4],r8
8000aa54:	99 48       	st.w	r12[0x10],r8
8000aa56:	99 58       	st.w	r12[0x14],r8
8000aa58:	99 68       	st.w	r12[0x18],r8
8000aa5a:	99 d8       	st.w	r12[0x34],r8
8000aa5c:	99 e8       	st.w	r12[0x38],r8
8000aa5e:	f9 48 00 48 	st.w	r12[72],r8
8000aa62:	3f f8       	mov	r8,-1
8000aa64:	b8 78       	st.h	r12[0xe],r8
8000aa66:	30 18       	mov	r8,1
8000aa68:	b8 68       	st.h	r12[0xc],r8
8000aa6a:	d8 22       	popm	r4-r7,pc

8000aa6c <__sinit>:
8000aa6c:	d4 21       	pushm	r4-r7,lr
8000aa6e:	18 96       	mov	r6,r12
8000aa70:	78 67       	ld.w	r7,r12[0x18]
8000aa72:	58 07       	cp.w	r7,0
8000aa74:	c4 91       	brne	8000ab06 <__sinit+0x9a>
8000aa76:	fe c8 00 aa 	sub	r8,pc,170
8000aa7a:	30 15       	mov	r5,1
8000aa7c:	99 a8       	st.w	r12[0x28],r8
8000aa7e:	f9 47 00 d8 	st.w	r12[216],r7
8000aa82:	f9 47 00 dc 	st.w	r12[220],r7
8000aa86:	f9 47 00 e0 	st.w	r12[224],r7
8000aa8a:	99 65       	st.w	r12[0x18],r5
8000aa8c:	cb af       	rcall	8000aa00 <__sfp>
8000aa8e:	8d 0c       	st.w	r6[0x0],r12
8000aa90:	0c 9c       	mov	r12,r6
8000aa92:	cb 7f       	rcall	8000aa00 <__sfp>
8000aa94:	8d 1c       	st.w	r6[0x4],r12
8000aa96:	0c 9c       	mov	r12,r6
8000aa98:	cb 4f       	rcall	8000aa00 <__sfp>
8000aa9a:	6c 09       	ld.w	r9,r6[0x0]
8000aa9c:	30 48       	mov	r8,4
8000aa9e:	93 07       	st.w	r9[0x0],r7
8000aaa0:	b2 68       	st.h	r9[0xc],r8
8000aaa2:	93 17       	st.w	r9[0x4],r7
8000aaa4:	93 27       	st.w	r9[0x8],r7
8000aaa6:	6c 18       	ld.w	r8,r6[0x4]
8000aaa8:	b2 77       	st.h	r9[0xe],r7
8000aaaa:	93 47       	st.w	r9[0x10],r7
8000aaac:	93 57       	st.w	r9[0x14],r7
8000aaae:	93 67       	st.w	r9[0x18],r7
8000aab0:	93 89       	st.w	r9[0x20],r9
8000aab2:	91 07       	st.w	r8[0x0],r7
8000aab4:	91 17       	st.w	r8[0x4],r7
8000aab6:	91 27       	st.w	r8[0x8],r7
8000aab8:	fe ce f3 24 	sub	lr,pc,-3292
8000aabc:	fe cb f3 54 	sub	r11,pc,-3244
8000aac0:	93 9e       	st.w	r9[0x24],lr
8000aac2:	93 ab       	st.w	r9[0x28],r11
8000aac4:	fe ca f3 7c 	sub	r10,pc,-3204
8000aac8:	fe c4 f3 88 	sub	r4,pc,-3192
8000aacc:	93 ba       	st.w	r9[0x2c],r10
8000aace:	93 c4       	st.w	r9[0x30],r4
8000aad0:	30 99       	mov	r9,9
8000aad2:	b0 69       	st.h	r8[0xc],r9
8000aad4:	b0 75       	st.h	r8[0xe],r5
8000aad6:	91 c4       	st.w	r8[0x30],r4
8000aad8:	91 47       	st.w	r8[0x10],r7
8000aada:	91 57       	st.w	r8[0x14],r7
8000aadc:	91 67       	st.w	r8[0x18],r7
8000aade:	91 88       	st.w	r8[0x20],r8
8000aae0:	91 9e       	st.w	r8[0x24],lr
8000aae2:	91 ab       	st.w	r8[0x28],r11
8000aae4:	91 ba       	st.w	r8[0x2c],r10
8000aae6:	8d 2c       	st.w	r6[0x8],r12
8000aae8:	31 28       	mov	r8,18
8000aaea:	99 07       	st.w	r12[0x0],r7
8000aaec:	b8 68       	st.h	r12[0xc],r8
8000aaee:	99 17       	st.w	r12[0x4],r7
8000aaf0:	99 27       	st.w	r12[0x8],r7
8000aaf2:	30 28       	mov	r8,2
8000aaf4:	b8 78       	st.h	r12[0xe],r8
8000aaf6:	99 c4       	st.w	r12[0x30],r4
8000aaf8:	99 67       	st.w	r12[0x18],r7
8000aafa:	99 9e       	st.w	r12[0x24],lr
8000aafc:	99 ab       	st.w	r12[0x28],r11
8000aafe:	99 ba       	st.w	r12[0x2c],r10
8000ab00:	99 47       	st.w	r12[0x10],r7
8000ab02:	99 57       	st.w	r12[0x14],r7
8000ab04:	99 8c       	st.w	r12[0x20],r12
8000ab06:	d8 22       	popm	r4-r7,pc

8000ab08 <_malloc_trim_r>:
8000ab08:	d4 21       	pushm	r4-r7,lr
8000ab0a:	16 95       	mov	r5,r11
8000ab0c:	18 97       	mov	r7,r12
8000ab0e:	fe b0 d2 63 	rcall	80004fd4 <__malloc_lock>
8000ab12:	e0 64 01 1c 	mov	r4,284
8000ab16:	68 28       	ld.w	r8,r4[0x8]
8000ab18:	70 16       	ld.w	r6,r8[0x4]
8000ab1a:	e0 16 ff fc 	andl	r6,0xfffc
8000ab1e:	ec c8 ff 91 	sub	r8,r6,-111
8000ab22:	f0 05 01 05 	sub	r5,r8,r5
8000ab26:	e0 15 ff 80 	andl	r5,0xff80
8000ab2a:	ea c5 00 80 	sub	r5,r5,128
8000ab2e:	e0 45 00 7f 	cp.w	r5,127
8000ab32:	e0 8a 00 25 	brle	8000ab7c <_malloc_trim_r+0x74>
8000ab36:	30 0b       	mov	r11,0
8000ab38:	0e 9c       	mov	r12,r7
8000ab3a:	fe b0 e5 21 	rcall	8000757c <_sbrk_r>
8000ab3e:	68 28       	ld.w	r8,r4[0x8]
8000ab40:	0c 08       	add	r8,r6
8000ab42:	10 3c       	cp.w	r12,r8
8000ab44:	c1 c1       	brne	8000ab7c <_malloc_trim_r+0x74>
8000ab46:	ea 0b 11 00 	rsub	r11,r5,0
8000ab4a:	0e 9c       	mov	r12,r7
8000ab4c:	fe b0 e5 18 	rcall	8000757c <_sbrk_r>
8000ab50:	5b fc       	cp.w	r12,-1
8000ab52:	c1 91       	brne	8000ab84 <_malloc_trim_r+0x7c>
8000ab54:	30 0b       	mov	r11,0
8000ab56:	0e 9c       	mov	r12,r7
8000ab58:	fe b0 e5 12 	rcall	8000757c <_sbrk_r>
8000ab5c:	68 28       	ld.w	r8,r4[0x8]
8000ab5e:	f8 08 01 09 	sub	r9,r12,r8
8000ab62:	58 f9       	cp.w	r9,15
8000ab64:	e0 8a 00 0c 	brle	8000ab7c <_malloc_trim_r+0x74>
8000ab68:	a1 a9       	sbr	r9,0x0
8000ab6a:	91 19       	st.w	r8[0x4],r9
8000ab6c:	e0 68 05 28 	mov	r8,1320
8000ab70:	70 09       	ld.w	r9,r8[0x0]
8000ab72:	e0 68 07 a8 	mov	r8,1960
8000ab76:	f8 09 01 09 	sub	r9,r12,r9
8000ab7a:	91 09       	st.w	r8[0x0],r9
8000ab7c:	0e 9c       	mov	r12,r7
8000ab7e:	fe b0 d2 39 	rcall	80004ff0 <__malloc_unlock>
8000ab82:	d8 2a       	popm	r4-r7,pc,r12=0
8000ab84:	68 28       	ld.w	r8,r4[0x8]
8000ab86:	0a 16       	sub	r6,r5
8000ab88:	a1 a6       	sbr	r6,0x0
8000ab8a:	91 16       	st.w	r8[0x4],r6
8000ab8c:	e0 68 07 a8 	mov	r8,1960
8000ab90:	70 09       	ld.w	r9,r8[0x0]
8000ab92:	0a 19       	sub	r9,r5
8000ab94:	0e 9c       	mov	r12,r7
8000ab96:	91 09       	st.w	r8[0x0],r9
8000ab98:	fe b0 d2 2c 	rcall	80004ff0 <__malloc_unlock>
8000ab9c:	da 2a       	popm	r4-r7,pc,r12=1
8000ab9e:	d7 03       	nop

8000aba0 <_free_r>:
8000aba0:	d4 21       	pushm	r4-r7,lr
8000aba2:	16 96       	mov	r6,r11
8000aba4:	18 97       	mov	r7,r12
8000aba6:	58 0b       	cp.w	r11,0
8000aba8:	e0 80 00 c0 	breq	8000ad28 <_free_r+0x188>
8000abac:	fe b0 d2 14 	rcall	80004fd4 <__malloc_lock>
8000abb0:	20 86       	sub	r6,8
8000abb2:	e0 6a 01 1c 	mov	r10,284
8000abb6:	6c 18       	ld.w	r8,r6[0x4]
8000abb8:	74 2e       	ld.w	lr,r10[0x8]
8000abba:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000abbe:	a1 c8       	cbr	r8,0x0
8000abc0:	ec 08 00 09 	add	r9,r6,r8
8000abc4:	72 1b       	ld.w	r11,r9[0x4]
8000abc6:	e0 1b ff fc 	andl	r11,0xfffc
8000abca:	1c 39       	cp.w	r9,lr
8000abcc:	c1 e1       	brne	8000ac08 <_free_r+0x68>
8000abce:	f6 08 00 08 	add	r8,r11,r8
8000abd2:	58 0c       	cp.w	r12,0
8000abd4:	c0 81       	brne	8000abe4 <_free_r+0x44>
8000abd6:	6c 09       	ld.w	r9,r6[0x0]
8000abd8:	12 16       	sub	r6,r9
8000abda:	12 08       	add	r8,r9
8000abdc:	6c 3b       	ld.w	r11,r6[0xc]
8000abde:	6c 29       	ld.w	r9,r6[0x8]
8000abe0:	97 29       	st.w	r11[0x8],r9
8000abe2:	93 3b       	st.w	r9[0xc],r11
8000abe4:	10 99       	mov	r9,r8
8000abe6:	95 26       	st.w	r10[0x8],r6
8000abe8:	a1 a9       	sbr	r9,0x0
8000abea:	8d 19       	st.w	r6[0x4],r9
8000abec:	e0 69 05 24 	mov	r9,1316
8000abf0:	72 09       	ld.w	r9,r9[0x0]
8000abf2:	12 38       	cp.w	r8,r9
8000abf4:	c0 63       	brcs	8000ac00 <_free_r+0x60>
8000abf6:	e0 68 07 a4 	mov	r8,1956
8000abfa:	0e 9c       	mov	r12,r7
8000abfc:	70 0b       	ld.w	r11,r8[0x0]
8000abfe:	c8 5f       	rcall	8000ab08 <_malloc_trim_r>
8000ac00:	0e 9c       	mov	r12,r7
8000ac02:	fe b0 d1 f7 	rcall	80004ff0 <__malloc_unlock>
8000ac06:	d8 22       	popm	r4-r7,pc
8000ac08:	93 1b       	st.w	r9[0x4],r11
8000ac0a:	58 0c       	cp.w	r12,0
8000ac0c:	c0 30       	breq	8000ac12 <_free_r+0x72>
8000ac0e:	30 0c       	mov	r12,0
8000ac10:	c1 08       	rjmp	8000ac30 <_free_r+0x90>
8000ac12:	6c 0e       	ld.w	lr,r6[0x0]
8000ac14:	f4 c5 ff f8 	sub	r5,r10,-8
8000ac18:	1c 16       	sub	r6,lr
8000ac1a:	1c 08       	add	r8,lr
8000ac1c:	6c 2e       	ld.w	lr,r6[0x8]
8000ac1e:	0a 3e       	cp.w	lr,r5
8000ac20:	f9 bc 00 01 	moveq	r12,1
8000ac24:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000ac28:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000ac2c:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000ac30:	f2 0b 00 0e 	add	lr,r9,r11
8000ac34:	7c 1e       	ld.w	lr,lr[0x4]
8000ac36:	ed be 00 00 	bld	lr,0x0
8000ac3a:	c1 40       	breq	8000ac62 <_free_r+0xc2>
8000ac3c:	16 08       	add	r8,r11
8000ac3e:	58 0c       	cp.w	r12,0
8000ac40:	c0 d1       	brne	8000ac5a <_free_r+0xba>
8000ac42:	e0 6e 01 1c 	mov	lr,284
8000ac46:	72 2b       	ld.w	r11,r9[0x8]
8000ac48:	2f 8e       	sub	lr,-8
8000ac4a:	1c 3b       	cp.w	r11,lr
8000ac4c:	c0 71       	brne	8000ac5a <_free_r+0xba>
8000ac4e:	97 36       	st.w	r11[0xc],r6
8000ac50:	97 26       	st.w	r11[0x8],r6
8000ac52:	8d 2b       	st.w	r6[0x8],r11
8000ac54:	8d 3b       	st.w	r6[0xc],r11
8000ac56:	30 1c       	mov	r12,1
8000ac58:	c0 58       	rjmp	8000ac62 <_free_r+0xc2>
8000ac5a:	72 2b       	ld.w	r11,r9[0x8]
8000ac5c:	72 39       	ld.w	r9,r9[0xc]
8000ac5e:	93 2b       	st.w	r9[0x8],r11
8000ac60:	97 39       	st.w	r11[0xc],r9
8000ac62:	10 99       	mov	r9,r8
8000ac64:	ec 08 09 08 	st.w	r6[r8],r8
8000ac68:	a1 a9       	sbr	r9,0x0
8000ac6a:	8d 19       	st.w	r6[0x4],r9
8000ac6c:	58 0c       	cp.w	r12,0
8000ac6e:	c5 a1       	brne	8000ad22 <_free_r+0x182>
8000ac70:	e0 48 01 ff 	cp.w	r8,511
8000ac74:	e0 8b 00 13 	brhi	8000ac9a <_free_r+0xfa>
8000ac78:	a3 98       	lsr	r8,0x3
8000ac7a:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000ac7e:	72 2b       	ld.w	r11,r9[0x8]
8000ac80:	8d 39       	st.w	r6[0xc],r9
8000ac82:	8d 2b       	st.w	r6[0x8],r11
8000ac84:	97 36       	st.w	r11[0xc],r6
8000ac86:	93 26       	st.w	r9[0x8],r6
8000ac88:	a3 48       	asr	r8,0x2
8000ac8a:	74 19       	ld.w	r9,r10[0x4]
8000ac8c:	30 1b       	mov	r11,1
8000ac8e:	f6 08 09 48 	lsl	r8,r11,r8
8000ac92:	f3 e8 10 08 	or	r8,r9,r8
8000ac96:	95 18       	st.w	r10[0x4],r8
8000ac98:	c4 58       	rjmp	8000ad22 <_free_r+0x182>
8000ac9a:	f0 0b 16 09 	lsr	r11,r8,0x9
8000ac9e:	58 4b       	cp.w	r11,4
8000aca0:	e0 8b 00 06 	brhi	8000acac <_free_r+0x10c>
8000aca4:	f0 0b 16 06 	lsr	r11,r8,0x6
8000aca8:	2c 8b       	sub	r11,-56
8000acaa:	c2 08       	rjmp	8000acea <_free_r+0x14a>
8000acac:	59 4b       	cp.w	r11,20
8000acae:	e0 8b 00 04 	brhi	8000acb6 <_free_r+0x116>
8000acb2:	2a 5b       	sub	r11,-91
8000acb4:	c1 b8       	rjmp	8000acea <_free_r+0x14a>
8000acb6:	e0 4b 00 54 	cp.w	r11,84
8000acba:	e0 8b 00 06 	brhi	8000acc6 <_free_r+0x126>
8000acbe:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000acc2:	29 2b       	sub	r11,-110
8000acc4:	c1 38       	rjmp	8000acea <_free_r+0x14a>
8000acc6:	e0 4b 01 54 	cp.w	r11,340
8000acca:	e0 8b 00 06 	brhi	8000acd6 <_free_r+0x136>
8000acce:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000acd2:	28 9b       	sub	r11,-119
8000acd4:	c0 b8       	rjmp	8000acea <_free_r+0x14a>
8000acd6:	e0 4b 05 54 	cp.w	r11,1364
8000acda:	e0 88 00 05 	brls	8000ace4 <_free_r+0x144>
8000acde:	37 eb       	mov	r11,126
8000ace0:	c0 58       	rjmp	8000acea <_free_r+0x14a>
8000ace2:	d7 03       	nop
8000ace4:	f0 0b 16 12 	lsr	r11,r8,0x12
8000ace8:	28 4b       	sub	r11,-124
8000acea:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000acee:	78 29       	ld.w	r9,r12[0x8]
8000acf0:	18 39       	cp.w	r9,r12
8000acf2:	c0 e1       	brne	8000ad0e <_free_r+0x16e>
8000acf4:	74 18       	ld.w	r8,r10[0x4]
8000acf6:	a3 4b       	asr	r11,0x2
8000acf8:	30 1c       	mov	r12,1
8000acfa:	f8 0b 09 4b 	lsl	r11,r12,r11
8000acfe:	f1 eb 10 0b 	or	r11,r8,r11
8000ad02:	12 98       	mov	r8,r9
8000ad04:	95 1b       	st.w	r10[0x4],r11
8000ad06:	c0 a8       	rjmp	8000ad1a <_free_r+0x17a>
8000ad08:	72 29       	ld.w	r9,r9[0x8]
8000ad0a:	18 39       	cp.w	r9,r12
8000ad0c:	c0 60       	breq	8000ad18 <_free_r+0x178>
8000ad0e:	72 1a       	ld.w	r10,r9[0x4]
8000ad10:	e0 1a ff fc 	andl	r10,0xfffc
8000ad14:	14 38       	cp.w	r8,r10
8000ad16:	cf 93       	brcs	8000ad08 <_free_r+0x168>
8000ad18:	72 38       	ld.w	r8,r9[0xc]
8000ad1a:	8d 38       	st.w	r6[0xc],r8
8000ad1c:	8d 29       	st.w	r6[0x8],r9
8000ad1e:	93 36       	st.w	r9[0xc],r6
8000ad20:	91 26       	st.w	r8[0x8],r6
8000ad22:	0e 9c       	mov	r12,r7
8000ad24:	fe b0 d1 66 	rcall	80004ff0 <__malloc_unlock>
8000ad28:	d8 22       	popm	r4-r7,pc
8000ad2a:	d7 03       	nop

8000ad2c <__sfvwrite_r>:
8000ad2c:	d4 31       	pushm	r0-r7,lr
8000ad2e:	20 3d       	sub	sp,12
8000ad30:	14 94       	mov	r4,r10
8000ad32:	18 95       	mov	r5,r12
8000ad34:	16 97       	mov	r7,r11
8000ad36:	74 28       	ld.w	r8,r10[0x8]
8000ad38:	58 08       	cp.w	r8,0
8000ad3a:	e0 80 01 40 	breq	8000afba <__sfvwrite_r+0x28e>
8000ad3e:	96 68       	ld.sh	r8,r11[0xc]
8000ad40:	ed b8 00 03 	bld	r8,0x3
8000ad44:	c0 41       	brne	8000ad4c <__sfvwrite_r+0x20>
8000ad46:	76 48       	ld.w	r8,r11[0x10]
8000ad48:	58 08       	cp.w	r8,0
8000ad4a:	c0 c1       	brne	8000ad62 <__sfvwrite_r+0x36>
8000ad4c:	0e 9b       	mov	r11,r7
8000ad4e:	0a 9c       	mov	r12,r5
8000ad50:	fe b0 f6 0c 	rcall	80009968 <__swsetup_r>
8000ad54:	c0 70       	breq	8000ad62 <__sfvwrite_r+0x36>
8000ad56:	8e 68       	ld.sh	r8,r7[0xc]
8000ad58:	a7 a8       	sbr	r8,0x6
8000ad5a:	ae 68       	st.h	r7[0xc],r8
8000ad5c:	30 98       	mov	r8,9
8000ad5e:	8b 38       	st.w	r5[0xc],r8
8000ad60:	c2 b9       	rjmp	8000afb6 <__sfvwrite_r+0x28a>
8000ad62:	8e 63       	ld.sh	r3,r7[0xc]
8000ad64:	68 00       	ld.w	r0,r4[0x0]
8000ad66:	06 96       	mov	r6,r3
8000ad68:	e2 16 00 02 	andl	r6,0x2,COH
8000ad6c:	c2 10       	breq	8000adae <__sfvwrite_r+0x82>
8000ad6e:	30 03       	mov	r3,0
8000ad70:	e0 62 04 00 	mov	r2,1024
8000ad74:	06 96       	mov	r6,r3
8000ad76:	c0 48       	rjmp	8000ad7e <__sfvwrite_r+0x52>
8000ad78:	60 03       	ld.w	r3,r0[0x0]
8000ad7a:	60 16       	ld.w	r6,r0[0x4]
8000ad7c:	2f 80       	sub	r0,-8
8000ad7e:	58 06       	cp.w	r6,0
8000ad80:	cf c0       	breq	8000ad78 <__sfvwrite_r+0x4c>
8000ad82:	e0 46 04 00 	cp.w	r6,1024
8000ad86:	ec 09 17 80 	movls	r9,r6
8000ad8a:	e4 09 17 b0 	movhi	r9,r2
8000ad8e:	06 9a       	mov	r10,r3
8000ad90:	6e a8       	ld.w	r8,r7[0x28]
8000ad92:	6e 8b       	ld.w	r11,r7[0x20]
8000ad94:	0a 9c       	mov	r12,r5
8000ad96:	5d 18       	icall	r8
8000ad98:	18 16       	sub	r6,r12
8000ad9a:	58 0c       	cp.w	r12,0
8000ad9c:	e0 8a 01 0a 	brle	8000afb0 <__sfvwrite_r+0x284>
8000ada0:	68 28       	ld.w	r8,r4[0x8]
8000ada2:	18 18       	sub	r8,r12
8000ada4:	89 28       	st.w	r4[0x8],r8
8000ada6:	e0 80 01 0a 	breq	8000afba <__sfvwrite_r+0x28e>
8000adaa:	18 03       	add	r3,r12
8000adac:	ce 9b       	rjmp	8000ad7e <__sfvwrite_r+0x52>
8000adae:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000adb2:	c0 70       	breq	8000adc0 <__sfvwrite_r+0x94>
8000adb4:	50 06       	stdsp	sp[0x0],r6
8000adb6:	0c 93       	mov	r3,r6
8000adb8:	0c 91       	mov	r1,r6
8000adba:	50 15       	stdsp	sp[0x4],r5
8000adbc:	08 92       	mov	r2,r4
8000adbe:	c9 c8       	rjmp	8000aef6 <__sfvwrite_r+0x1ca>
8000adc0:	06 96       	mov	r6,r3
8000adc2:	08 91       	mov	r1,r4
8000adc4:	c0 48       	rjmp	8000adcc <__sfvwrite_r+0xa0>
8000adc6:	60 03       	ld.w	r3,r0[0x0]
8000adc8:	60 16       	ld.w	r6,r0[0x4]
8000adca:	2f 80       	sub	r0,-8
8000adcc:	58 06       	cp.w	r6,0
8000adce:	cf c0       	breq	8000adc6 <__sfvwrite_r+0x9a>
8000add0:	8e 68       	ld.sh	r8,r7[0xc]
8000add2:	6e 24       	ld.w	r4,r7[0x8]
8000add4:	10 99       	mov	r9,r8
8000add6:	e2 19 02 00 	andl	r9,0x200,COH
8000adda:	c5 50       	breq	8000ae84 <__sfvwrite_r+0x158>
8000addc:	08 36       	cp.w	r6,r4
8000adde:	c4 43       	brcs	8000ae66 <__sfvwrite_r+0x13a>
8000ade0:	10 99       	mov	r9,r8
8000ade2:	e2 19 04 80 	andl	r9,0x480,COH
8000ade6:	c4 00       	breq	8000ae66 <__sfvwrite_r+0x13a>
8000ade8:	6e 4b       	ld.w	r11,r7[0x10]
8000adea:	6e 09       	ld.w	r9,r7[0x0]
8000adec:	16 19       	sub	r9,r11
8000adee:	50 09       	stdsp	sp[0x0],r9
8000adf0:	6e 59       	ld.w	r9,r7[0x14]
8000adf2:	10 9c       	mov	r12,r8
8000adf4:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000adf8:	30 28       	mov	r8,2
8000adfa:	f4 08 0c 08 	divs	r8,r10,r8
8000adfe:	fa e9 00 04 	st.d	sp[4],r8
8000ae02:	10 94       	mov	r4,r8
8000ae04:	40 09       	lddsp	r9,sp[0x0]
8000ae06:	e2 1c 04 00 	andl	r12,0x400,COH
8000ae0a:	2f f9       	sub	r9,-1
8000ae0c:	0c 09       	add	r9,r6
8000ae0e:	12 38       	cp.w	r8,r9
8000ae10:	f2 04 17 30 	movlo	r4,r9
8000ae14:	58 0c       	cp.w	r12,0
8000ae16:	c1 10       	breq	8000ae38 <__sfvwrite_r+0x10c>
8000ae18:	08 9b       	mov	r11,r4
8000ae1a:	0a 9c       	mov	r12,r5
8000ae1c:	fe b0 df 88 	rcall	80006d2c <_malloc_r>
8000ae20:	18 92       	mov	r2,r12
8000ae22:	c1 40       	breq	8000ae4a <__sfvwrite_r+0x11e>
8000ae24:	40 0a       	lddsp	r10,sp[0x0]
8000ae26:	6e 4b       	ld.w	r11,r7[0x10]
8000ae28:	fe b0 e1 9e 	rcall	80007164 <memcpy>
8000ae2c:	8e 68       	ld.sh	r8,r7[0xc]
8000ae2e:	e0 18 fb 7f 	andl	r8,0xfb7f
8000ae32:	a7 b8       	sbr	r8,0x7
8000ae34:	ae 68       	st.h	r7[0xc],r8
8000ae36:	c0 d8       	rjmp	8000ae50 <__sfvwrite_r+0x124>
8000ae38:	08 9a       	mov	r10,r4
8000ae3a:	0a 9c       	mov	r12,r5
8000ae3c:	fe b0 e2 40 	rcall	800072bc <_realloc_r>
8000ae40:	18 92       	mov	r2,r12
8000ae42:	c0 71       	brne	8000ae50 <__sfvwrite_r+0x124>
8000ae44:	6e 4b       	ld.w	r11,r7[0x10]
8000ae46:	0a 9c       	mov	r12,r5
8000ae48:	ca ce       	rcall	8000aba0 <_free_r>
8000ae4a:	30 c8       	mov	r8,12
8000ae4c:	8b 38       	st.w	r5[0xc],r8
8000ae4e:	cb 18       	rjmp	8000afb0 <__sfvwrite_r+0x284>
8000ae50:	40 0a       	lddsp	r10,sp[0x0]
8000ae52:	40 09       	lddsp	r9,sp[0x0]
8000ae54:	e8 0a 01 0a 	sub	r10,r4,r10
8000ae58:	e4 09 00 08 	add	r8,r2,r9
8000ae5c:	8f 54       	st.w	r7[0x14],r4
8000ae5e:	8f 2a       	st.w	r7[0x8],r10
8000ae60:	8f 08       	st.w	r7[0x0],r8
8000ae62:	8f 42       	st.w	r7[0x10],r2
8000ae64:	0c 94       	mov	r4,r6
8000ae66:	08 36       	cp.w	r6,r4
8000ae68:	ec 04 17 30 	movlo	r4,r6
8000ae6c:	06 9b       	mov	r11,r3
8000ae6e:	08 9a       	mov	r10,r4
8000ae70:	6e 0c       	ld.w	r12,r7[0x0]
8000ae72:	c3 ad       	rcall	8000b0e6 <memmove>
8000ae74:	6e 08       	ld.w	r8,r7[0x0]
8000ae76:	08 08       	add	r8,r4
8000ae78:	8f 08       	st.w	r7[0x0],r8
8000ae7a:	6e 28       	ld.w	r8,r7[0x8]
8000ae7c:	08 18       	sub	r8,r4
8000ae7e:	0c 94       	mov	r4,r6
8000ae80:	8f 28       	st.w	r7[0x8],r8
8000ae82:	c2 e8       	rjmp	8000aede <__sfvwrite_r+0x1b2>
8000ae84:	08 36       	cp.w	r6,r4
8000ae86:	5f ba       	srhi	r10
8000ae88:	6e 0c       	ld.w	r12,r7[0x0]
8000ae8a:	6e 48       	ld.w	r8,r7[0x10]
8000ae8c:	10 3c       	cp.w	r12,r8
8000ae8e:	5f b8       	srhi	r8
8000ae90:	f5 e8 00 08 	and	r8,r10,r8
8000ae94:	f2 08 18 00 	cp.b	r8,r9
8000ae98:	c0 d0       	breq	8000aeb2 <__sfvwrite_r+0x186>
8000ae9a:	06 9b       	mov	r11,r3
8000ae9c:	08 9a       	mov	r10,r4
8000ae9e:	c2 4d       	rcall	8000b0e6 <memmove>
8000aea0:	6e 08       	ld.w	r8,r7[0x0]
8000aea2:	08 08       	add	r8,r4
8000aea4:	0e 9b       	mov	r11,r7
8000aea6:	8f 08       	st.w	r7[0x0],r8
8000aea8:	0a 9c       	mov	r12,r5
8000aeaa:	fe b0 fd 09 	rcall	8000a8bc <_fflush_r>
8000aeae:	c1 80       	breq	8000aede <__sfvwrite_r+0x1b2>
8000aeb0:	c8 08       	rjmp	8000afb0 <__sfvwrite_r+0x284>
8000aeb2:	6e 59       	ld.w	r9,r7[0x14]
8000aeb4:	12 36       	cp.w	r6,r9
8000aeb6:	c0 a3       	brcs	8000aeca <__sfvwrite_r+0x19e>
8000aeb8:	6e a8       	ld.w	r8,r7[0x28]
8000aeba:	06 9a       	mov	r10,r3
8000aebc:	6e 8b       	ld.w	r11,r7[0x20]
8000aebe:	0a 9c       	mov	r12,r5
8000aec0:	5d 18       	icall	r8
8000aec2:	18 94       	mov	r4,r12
8000aec4:	e0 89 00 0d 	brgt	8000aede <__sfvwrite_r+0x1b2>
8000aec8:	c7 48       	rjmp	8000afb0 <__sfvwrite_r+0x284>
8000aeca:	0c 9a       	mov	r10,r6
8000aecc:	06 9b       	mov	r11,r3
8000aece:	c0 cd       	rcall	8000b0e6 <memmove>
8000aed0:	6e 08       	ld.w	r8,r7[0x0]
8000aed2:	0c 08       	add	r8,r6
8000aed4:	0c 94       	mov	r4,r6
8000aed6:	8f 08       	st.w	r7[0x0],r8
8000aed8:	6e 28       	ld.w	r8,r7[0x8]
8000aeda:	0c 18       	sub	r8,r6
8000aedc:	8f 28       	st.w	r7[0x8],r8
8000aede:	62 28       	ld.w	r8,r1[0x8]
8000aee0:	08 18       	sub	r8,r4
8000aee2:	83 28       	st.w	r1[0x8],r8
8000aee4:	c6 b0       	breq	8000afba <__sfvwrite_r+0x28e>
8000aee6:	08 16       	sub	r6,r4
8000aee8:	08 03       	add	r3,r4
8000aeea:	c7 1b       	rjmp	8000adcc <__sfvwrite_r+0xa0>
8000aeec:	60 03       	ld.w	r3,r0[0x0]
8000aeee:	60 11       	ld.w	r1,r0[0x4]
8000aef0:	30 08       	mov	r8,0
8000aef2:	2f 80       	sub	r0,-8
8000aef4:	50 08       	stdsp	sp[0x0],r8
8000aef6:	58 01       	cp.w	r1,0
8000aef8:	cf a0       	breq	8000aeec <__sfvwrite_r+0x1c0>
8000aefa:	40 0a       	lddsp	r10,sp[0x0]
8000aefc:	58 0a       	cp.w	r10,0
8000aefe:	c1 41       	brne	8000af26 <__sfvwrite_r+0x1fa>
8000af00:	e2 c6 ff ff 	sub	r6,r1,-1
8000af04:	02 9a       	mov	r10,r1
8000af06:	30 ab       	mov	r11,10
8000af08:	06 9c       	mov	r12,r3
8000af0a:	ce 3c       	rcall	8000b0d0 <memchr>
8000af0c:	f8 c8 ff ff 	sub	r8,r12,-1
8000af10:	58 0c       	cp.w	r12,0
8000af12:	f1 d3 e1 16 	subne	r6,r8,r3
8000af16:	f9 b9 01 01 	movne	r9,1
8000af1a:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000af1e:	f9 b8 00 01 	moveq	r8,1
8000af22:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000af26:	02 36       	cp.w	r6,r1
8000af28:	ec 04 17 80 	movls	r4,r6
8000af2c:	e2 04 17 b0 	movhi	r4,r1
8000af30:	6e 59       	ld.w	r9,r7[0x14]
8000af32:	6e 25       	ld.w	r5,r7[0x8]
8000af34:	f2 05 00 05 	add	r5,r9,r5
8000af38:	0a 34       	cp.w	r4,r5
8000af3a:	5f 9a       	srgt	r10
8000af3c:	6e 0c       	ld.w	r12,r7[0x0]
8000af3e:	6e 48       	ld.w	r8,r7[0x10]
8000af40:	10 3c       	cp.w	r12,r8
8000af42:	5f b8       	srhi	r8
8000af44:	f5 e8 00 08 	and	r8,r10,r8
8000af48:	30 0a       	mov	r10,0
8000af4a:	f4 08 18 00 	cp.b	r8,r10
8000af4e:	c0 d0       	breq	8000af68 <__sfvwrite_r+0x23c>
8000af50:	06 9b       	mov	r11,r3
8000af52:	0a 9a       	mov	r10,r5
8000af54:	cc 9c       	rcall	8000b0e6 <memmove>
8000af56:	6e 08       	ld.w	r8,r7[0x0]
8000af58:	0a 08       	add	r8,r5
8000af5a:	0e 9b       	mov	r11,r7
8000af5c:	8f 08       	st.w	r7[0x0],r8
8000af5e:	40 1c       	lddsp	r12,sp[0x4]
8000af60:	fe b0 fc ae 	rcall	8000a8bc <_fflush_r>
8000af64:	c1 70       	breq	8000af92 <__sfvwrite_r+0x266>
8000af66:	c2 58       	rjmp	8000afb0 <__sfvwrite_r+0x284>
8000af68:	12 34       	cp.w	r4,r9
8000af6a:	c0 a5       	brlt	8000af7e <__sfvwrite_r+0x252>
8000af6c:	6e a8       	ld.w	r8,r7[0x28]
8000af6e:	06 9a       	mov	r10,r3
8000af70:	6e 8b       	ld.w	r11,r7[0x20]
8000af72:	40 1c       	lddsp	r12,sp[0x4]
8000af74:	5d 18       	icall	r8
8000af76:	18 95       	mov	r5,r12
8000af78:	e0 89 00 0d 	brgt	8000af92 <__sfvwrite_r+0x266>
8000af7c:	c1 a8       	rjmp	8000afb0 <__sfvwrite_r+0x284>
8000af7e:	08 9a       	mov	r10,r4
8000af80:	06 9b       	mov	r11,r3
8000af82:	cb 2c       	rcall	8000b0e6 <memmove>
8000af84:	6e 08       	ld.w	r8,r7[0x0]
8000af86:	08 08       	add	r8,r4
8000af88:	08 95       	mov	r5,r4
8000af8a:	8f 08       	st.w	r7[0x0],r8
8000af8c:	6e 28       	ld.w	r8,r7[0x8]
8000af8e:	08 18       	sub	r8,r4
8000af90:	8f 28       	st.w	r7[0x8],r8
8000af92:	0a 16       	sub	r6,r5
8000af94:	c0 71       	brne	8000afa2 <__sfvwrite_r+0x276>
8000af96:	0e 9b       	mov	r11,r7
8000af98:	40 1c       	lddsp	r12,sp[0x4]
8000af9a:	fe b0 fc 91 	rcall	8000a8bc <_fflush_r>
8000af9e:	c0 91       	brne	8000afb0 <__sfvwrite_r+0x284>
8000afa0:	50 06       	stdsp	sp[0x0],r6
8000afa2:	64 28       	ld.w	r8,r2[0x8]
8000afa4:	0a 18       	sub	r8,r5
8000afa6:	85 28       	st.w	r2[0x8],r8
8000afa8:	c0 90       	breq	8000afba <__sfvwrite_r+0x28e>
8000afaa:	0a 11       	sub	r1,r5
8000afac:	0a 03       	add	r3,r5
8000afae:	ca 4b       	rjmp	8000aef6 <__sfvwrite_r+0x1ca>
8000afb0:	8e 68       	ld.sh	r8,r7[0xc]
8000afb2:	a7 a8       	sbr	r8,0x6
8000afb4:	ae 68       	st.h	r7[0xc],r8
8000afb6:	3f fc       	mov	r12,-1
8000afb8:	c0 28       	rjmp	8000afbc <__sfvwrite_r+0x290>
8000afba:	30 0c       	mov	r12,0
8000afbc:	2f dd       	sub	sp,-12
8000afbe:	d8 32       	popm	r0-r7,pc

8000afc0 <_fwalk>:
8000afc0:	d4 31       	pushm	r0-r7,lr
8000afc2:	30 05       	mov	r5,0
8000afc4:	16 91       	mov	r1,r11
8000afc6:	f8 c7 ff 28 	sub	r7,r12,-216
8000afca:	0a 92       	mov	r2,r5
8000afcc:	fe b0 fc fe 	rcall	8000a9c8 <__sfp_lock_acquire>
8000afd0:	3f f3       	mov	r3,-1
8000afd2:	c1 68       	rjmp	8000affe <_fwalk+0x3e>
8000afd4:	6e 26       	ld.w	r6,r7[0x8]
8000afd6:	6e 14       	ld.w	r4,r7[0x4]
8000afd8:	2f 46       	sub	r6,-12
8000afda:	c0 c8       	rjmp	8000aff2 <_fwalk+0x32>
8000afdc:	8c 08       	ld.sh	r8,r6[0x0]
8000afde:	e4 08 19 00 	cp.h	r8,r2
8000afe2:	c0 70       	breq	8000aff0 <_fwalk+0x30>
8000afe4:	8c 18       	ld.sh	r8,r6[0x2]
8000afe6:	e6 08 19 00 	cp.h	r8,r3
8000afea:	c0 30       	breq	8000aff0 <_fwalk+0x30>
8000afec:	5d 11       	icall	r1
8000afee:	18 45       	or	r5,r12
8000aff0:	2a 46       	sub	r6,-92
8000aff2:	20 14       	sub	r4,1
8000aff4:	ec cc 00 0c 	sub	r12,r6,12
8000aff8:	58 04       	cp.w	r4,0
8000affa:	cf 14       	brge	8000afdc <_fwalk+0x1c>
8000affc:	6e 07       	ld.w	r7,r7[0x0]
8000affe:	58 07       	cp.w	r7,0
8000b000:	ce a1       	brne	8000afd4 <_fwalk+0x14>
8000b002:	fe b0 fc e4 	rcall	8000a9ca <__sfp_lock_release>
8000b006:	0a 9c       	mov	r12,r5
8000b008:	d8 32       	popm	r0-r7,pc
8000b00a:	d7 03       	nop

8000b00c <_localeconv_r>:
8000b00c:	fe cc e2 10 	sub	r12,pc,-7664
8000b010:	5e fc       	retal	r12
8000b012:	d7 03       	nop

8000b014 <__smakebuf_r>:
8000b014:	d4 21       	pushm	r4-r7,lr
8000b016:	20 fd       	sub	sp,60
8000b018:	96 68       	ld.sh	r8,r11[0xc]
8000b01a:	16 97       	mov	r7,r11
8000b01c:	18 96       	mov	r6,r12
8000b01e:	e2 18 00 02 	andl	r8,0x2,COH
8000b022:	c3 d1       	brne	8000b09c <__smakebuf_r+0x88>
8000b024:	96 7b       	ld.sh	r11,r11[0xe]
8000b026:	f0 0b 19 00 	cp.h	r11,r8
8000b02a:	c0 55       	brlt	8000b034 <__smakebuf_r+0x20>
8000b02c:	1a 9a       	mov	r10,sp
8000b02e:	e0 a0 04 81 	rcall	8000b930 <_fstat_r>
8000b032:	c0 f4       	brge	8000b050 <__smakebuf_r+0x3c>
8000b034:	8e 65       	ld.sh	r5,r7[0xc]
8000b036:	0a 98       	mov	r8,r5
8000b038:	ab b8       	sbr	r8,0xb
8000b03a:	e2 15 00 80 	andl	r5,0x80,COH
8000b03e:	ae 68       	st.h	r7[0xc],r8
8000b040:	30 04       	mov	r4,0
8000b042:	e0 68 04 00 	mov	r8,1024
8000b046:	f9 b5 01 40 	movne	r5,64
8000b04a:	f0 05 17 00 	moveq	r5,r8
8000b04e:	c1 c8       	rjmp	8000b086 <__smakebuf_r+0x72>
8000b050:	40 18       	lddsp	r8,sp[0x4]
8000b052:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b056:	e0 48 20 00 	cp.w	r8,8192
8000b05a:	5f 04       	sreq	r4
8000b05c:	e0 48 80 00 	cp.w	r8,32768
8000b060:	c0 e1       	brne	8000b07c <__smakebuf_r+0x68>
8000b062:	6e b9       	ld.w	r9,r7[0x2c]
8000b064:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b068:	10 39       	cp.w	r9,r8
8000b06a:	c0 91       	brne	8000b07c <__smakebuf_r+0x68>
8000b06c:	8e 68       	ld.sh	r8,r7[0xc]
8000b06e:	e0 65 04 00 	mov	r5,1024
8000b072:	ab a8       	sbr	r8,0xa
8000b074:	ef 45 00 50 	st.w	r7[80],r5
8000b078:	ae 68       	st.h	r7[0xc],r8
8000b07a:	c0 68       	rjmp	8000b086 <__smakebuf_r+0x72>
8000b07c:	8e 68       	ld.sh	r8,r7[0xc]
8000b07e:	e0 65 04 00 	mov	r5,1024
8000b082:	ab b8       	sbr	r8,0xb
8000b084:	ae 68       	st.h	r7[0xc],r8
8000b086:	0a 9b       	mov	r11,r5
8000b088:	0c 9c       	mov	r12,r6
8000b08a:	fe b0 de 51 	rcall	80006d2c <_malloc_r>
8000b08e:	8e 68       	ld.sh	r8,r7[0xc]
8000b090:	c0 d1       	brne	8000b0aa <__smakebuf_r+0x96>
8000b092:	ed b8 00 09 	bld	r8,0x9
8000b096:	c1 b0       	breq	8000b0cc <__smakebuf_r+0xb8>
8000b098:	a1 b8       	sbr	r8,0x1
8000b09a:	ae 68       	st.h	r7[0xc],r8
8000b09c:	ee c8 ff b9 	sub	r8,r7,-71
8000b0a0:	8f 48       	st.w	r7[0x10],r8
8000b0a2:	8f 08       	st.w	r7[0x0],r8
8000b0a4:	30 18       	mov	r8,1
8000b0a6:	8f 58       	st.w	r7[0x14],r8
8000b0a8:	c1 28       	rjmp	8000b0cc <__smakebuf_r+0xb8>
8000b0aa:	a7 b8       	sbr	r8,0x7
8000b0ac:	8f 4c       	st.w	r7[0x10],r12
8000b0ae:	ae 68       	st.h	r7[0xc],r8
8000b0b0:	8f 55       	st.w	r7[0x14],r5
8000b0b2:	fe c8 06 e6 	sub	r8,pc,1766
8000b0b6:	8f 0c       	st.w	r7[0x0],r12
8000b0b8:	8d a8       	st.w	r6[0x28],r8
8000b0ba:	58 04       	cp.w	r4,0
8000b0bc:	c0 80       	breq	8000b0cc <__smakebuf_r+0xb8>
8000b0be:	8e 7c       	ld.sh	r12,r7[0xe]
8000b0c0:	fe b0 e2 ba 	rcall	80007634 <isatty>
8000b0c4:	c0 40       	breq	8000b0cc <__smakebuf_r+0xb8>
8000b0c6:	8e 68       	ld.sh	r8,r7[0xc]
8000b0c8:	a1 a8       	sbr	r8,0x0
8000b0ca:	ae 68       	st.h	r7[0xc],r8
8000b0cc:	2f 1d       	sub	sp,-60
8000b0ce:	d8 22       	popm	r4-r7,pc

8000b0d0 <memchr>:
8000b0d0:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b0d4:	c0 68       	rjmp	8000b0e0 <memchr+0x10>
8000b0d6:	20 1a       	sub	r10,1
8000b0d8:	19 88       	ld.ub	r8,r12[0x0]
8000b0da:	16 38       	cp.w	r8,r11
8000b0dc:	5e 0c       	reteq	r12
8000b0de:	2f fc       	sub	r12,-1
8000b0e0:	58 0a       	cp.w	r10,0
8000b0e2:	cf a1       	brne	8000b0d6 <memchr+0x6>
8000b0e4:	5e fa       	retal	r10

8000b0e6 <memmove>:
8000b0e6:	d4 01       	pushm	lr
8000b0e8:	18 3b       	cp.w	r11,r12
8000b0ea:	c1 92       	brcc	8000b11c <memmove+0x36>
8000b0ec:	f6 0a 00 09 	add	r9,r11,r10
8000b0f0:	12 3c       	cp.w	r12,r9
8000b0f2:	c1 52       	brcc	8000b11c <memmove+0x36>
8000b0f4:	f8 0a 00 0b 	add	r11,r12,r10
8000b0f8:	30 08       	mov	r8,0
8000b0fa:	c0 68       	rjmp	8000b106 <memmove+0x20>
8000b0fc:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b100:	20 1a       	sub	r10,1
8000b102:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b106:	20 18       	sub	r8,1
8000b108:	58 0a       	cp.w	r10,0
8000b10a:	cf 91       	brne	8000b0fc <memmove+0x16>
8000b10c:	d8 02       	popm	pc
8000b10e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b112:	20 1a       	sub	r10,1
8000b114:	f8 08 0b 09 	st.b	r12[r8],r9
8000b118:	2f f8       	sub	r8,-1
8000b11a:	c0 28       	rjmp	8000b11e <memmove+0x38>
8000b11c:	30 08       	mov	r8,0
8000b11e:	58 0a       	cp.w	r10,0
8000b120:	cf 71       	brne	8000b10e <memmove+0x28>
8000b122:	d8 02       	popm	pc

8000b124 <__hi0bits>:
8000b124:	18 98       	mov	r8,r12
8000b126:	e0 1c 00 00 	andl	r12,0x0
8000b12a:	f0 09 15 10 	lsl	r9,r8,0x10
8000b12e:	58 0c       	cp.w	r12,0
8000b130:	f2 08 17 00 	moveq	r8,r9
8000b134:	f9 bc 00 10 	moveq	r12,16
8000b138:	f9 bc 01 00 	movne	r12,0
8000b13c:	10 9a       	mov	r10,r8
8000b13e:	f0 09 15 08 	lsl	r9,r8,0x8
8000b142:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b146:	f7 bc 00 f8 	subeq	r12,-8
8000b14a:	f2 08 17 00 	moveq	r8,r9
8000b14e:	10 9a       	mov	r10,r8
8000b150:	f0 09 15 04 	lsl	r9,r8,0x4
8000b154:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b158:	f7 bc 00 fc 	subeq	r12,-4
8000b15c:	f2 08 17 00 	moveq	r8,r9
8000b160:	10 9a       	mov	r10,r8
8000b162:	f0 09 15 02 	lsl	r9,r8,0x2
8000b166:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b16a:	f7 bc 00 fe 	subeq	r12,-2
8000b16e:	f2 08 17 00 	moveq	r8,r9
8000b172:	58 08       	cp.w	r8,0
8000b174:	5e 5c       	retlt	r12
8000b176:	ed b8 00 1e 	bld	r8,0x1e
8000b17a:	f9 bc 01 20 	movne	r12,32
8000b17e:	f7 bc 00 ff 	subeq	r12,-1
8000b182:	5e fc       	retal	r12

8000b184 <__lo0bits>:
8000b184:	18 99       	mov	r9,r12
8000b186:	78 08       	ld.w	r8,r12[0x0]
8000b188:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b18c:	c1 50       	breq	8000b1b6 <__lo0bits+0x32>
8000b18e:	ed b8 00 00 	bld	r8,0x0
8000b192:	c0 21       	brne	8000b196 <__lo0bits+0x12>
8000b194:	5e fd       	retal	0
8000b196:	10 9b       	mov	r11,r8
8000b198:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b19c:	e2 1b 00 02 	andl	r11,0x2,COH
8000b1a0:	a3 88       	lsr	r8,0x2
8000b1a2:	58 0b       	cp.w	r11,0
8000b1a4:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b1a8:	f9 bc 01 01 	movne	r12,1
8000b1ac:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b1b0:	f9 bc 00 02 	moveq	r12,2
8000b1b4:	5e fc       	retal	r12
8000b1b6:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b1ba:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b1be:	58 0a       	cp.w	r10,0
8000b1c0:	f6 08 17 00 	moveq	r8,r11
8000b1c4:	f9 bc 00 10 	moveq	r12,16
8000b1c8:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b1cc:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b1d0:	58 0b       	cp.w	r11,0
8000b1d2:	f7 bc 00 f8 	subeq	r12,-8
8000b1d6:	f4 08 17 00 	moveq	r8,r10
8000b1da:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b1de:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b1e2:	58 0b       	cp.w	r11,0
8000b1e4:	f7 bc 00 fc 	subeq	r12,-4
8000b1e8:	f4 08 17 00 	moveq	r8,r10
8000b1ec:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b1f0:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b1f4:	58 0b       	cp.w	r11,0
8000b1f6:	f7 bc 00 fe 	subeq	r12,-2
8000b1fa:	f4 08 17 00 	moveq	r8,r10
8000b1fe:	ed b8 00 00 	bld	r8,0x0
8000b202:	c0 60       	breq	8000b20e <__lo0bits+0x8a>
8000b204:	a1 98       	lsr	r8,0x1
8000b206:	c0 31       	brne	8000b20c <__lo0bits+0x88>
8000b208:	32 0c       	mov	r12,32
8000b20a:	5e fc       	retal	r12
8000b20c:	2f fc       	sub	r12,-1
8000b20e:	93 08       	st.w	r9[0x0],r8
8000b210:	5e fc       	retal	r12

8000b212 <__mcmp>:
8000b212:	d4 01       	pushm	lr
8000b214:	18 98       	mov	r8,r12
8000b216:	76 49       	ld.w	r9,r11[0x10]
8000b218:	78 4c       	ld.w	r12,r12[0x10]
8000b21a:	12 1c       	sub	r12,r9
8000b21c:	c1 31       	brne	8000b242 <__mcmp+0x30>
8000b21e:	2f b9       	sub	r9,-5
8000b220:	a3 69       	lsl	r9,0x2
8000b222:	12 0b       	add	r11,r9
8000b224:	f0 09 00 09 	add	r9,r8,r9
8000b228:	2e c8       	sub	r8,-20
8000b22a:	13 4e       	ld.w	lr,--r9
8000b22c:	17 4a       	ld.w	r10,--r11
8000b22e:	14 3e       	cp.w	lr,r10
8000b230:	c0 60       	breq	8000b23c <__mcmp+0x2a>
8000b232:	f9 bc 03 ff 	movlo	r12,-1
8000b236:	f9 bc 02 01 	movhs	r12,1
8000b23a:	d8 02       	popm	pc
8000b23c:	10 39       	cp.w	r9,r8
8000b23e:	fe 9b ff f6 	brhi	8000b22a <__mcmp+0x18>
8000b242:	d8 02       	popm	pc

8000b244 <_Bfree>:
8000b244:	d4 21       	pushm	r4-r7,lr
8000b246:	18 97       	mov	r7,r12
8000b248:	16 95       	mov	r5,r11
8000b24a:	78 96       	ld.w	r6,r12[0x24]
8000b24c:	58 06       	cp.w	r6,0
8000b24e:	c0 91       	brne	8000b260 <_Bfree+0x1c>
8000b250:	31 0c       	mov	r12,16
8000b252:	fe b0 dd 65 	rcall	80006d1c <malloc>
8000b256:	99 36       	st.w	r12[0xc],r6
8000b258:	8f 9c       	st.w	r7[0x24],r12
8000b25a:	99 16       	st.w	r12[0x4],r6
8000b25c:	99 26       	st.w	r12[0x8],r6
8000b25e:	99 06       	st.w	r12[0x0],r6
8000b260:	58 05       	cp.w	r5,0
8000b262:	c0 90       	breq	8000b274 <_Bfree+0x30>
8000b264:	6a 19       	ld.w	r9,r5[0x4]
8000b266:	6e 98       	ld.w	r8,r7[0x24]
8000b268:	70 38       	ld.w	r8,r8[0xc]
8000b26a:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b26e:	8b 0a       	st.w	r5[0x0],r10
8000b270:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b274:	d8 22       	popm	r4-r7,pc
8000b276:	d7 03       	nop

8000b278 <_Balloc>:
8000b278:	d4 21       	pushm	r4-r7,lr
8000b27a:	18 97       	mov	r7,r12
8000b27c:	16 96       	mov	r6,r11
8000b27e:	78 95       	ld.w	r5,r12[0x24]
8000b280:	58 05       	cp.w	r5,0
8000b282:	c0 91       	brne	8000b294 <_Balloc+0x1c>
8000b284:	31 0c       	mov	r12,16
8000b286:	fe b0 dd 4b 	rcall	80006d1c <malloc>
8000b28a:	99 35       	st.w	r12[0xc],r5
8000b28c:	8f 9c       	st.w	r7[0x24],r12
8000b28e:	99 15       	st.w	r12[0x4],r5
8000b290:	99 25       	st.w	r12[0x8],r5
8000b292:	99 05       	st.w	r12[0x0],r5
8000b294:	6e 95       	ld.w	r5,r7[0x24]
8000b296:	6a 38       	ld.w	r8,r5[0xc]
8000b298:	58 08       	cp.w	r8,0
8000b29a:	c0 b1       	brne	8000b2b0 <_Balloc+0x38>
8000b29c:	31 0a       	mov	r10,16
8000b29e:	30 4b       	mov	r11,4
8000b2a0:	0e 9c       	mov	r12,r7
8000b2a2:	e0 a0 02 a7 	rcall	8000b7f0 <_calloc_r>
8000b2a6:	8b 3c       	st.w	r5[0xc],r12
8000b2a8:	6e 98       	ld.w	r8,r7[0x24]
8000b2aa:	70 3c       	ld.w	r12,r8[0xc]
8000b2ac:	58 0c       	cp.w	r12,0
8000b2ae:	c1 b0       	breq	8000b2e4 <_Balloc+0x6c>
8000b2b0:	6e 98       	ld.w	r8,r7[0x24]
8000b2b2:	70 38       	ld.w	r8,r8[0xc]
8000b2b4:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b2b8:	70 0c       	ld.w	r12,r8[0x0]
8000b2ba:	58 0c       	cp.w	r12,0
8000b2bc:	c0 40       	breq	8000b2c4 <_Balloc+0x4c>
8000b2be:	78 09       	ld.w	r9,r12[0x0]
8000b2c0:	91 09       	st.w	r8[0x0],r9
8000b2c2:	c0 e8       	rjmp	8000b2de <_Balloc+0x66>
8000b2c4:	0e 9c       	mov	r12,r7
8000b2c6:	30 17       	mov	r7,1
8000b2c8:	0e 9b       	mov	r11,r7
8000b2ca:	ee 06 09 47 	lsl	r7,r7,r6
8000b2ce:	ee ca ff fb 	sub	r10,r7,-5
8000b2d2:	a3 6a       	lsl	r10,0x2
8000b2d4:	e0 a0 02 8e 	rcall	8000b7f0 <_calloc_r>
8000b2d8:	c0 60       	breq	8000b2e4 <_Balloc+0x6c>
8000b2da:	99 16       	st.w	r12[0x4],r6
8000b2dc:	99 27       	st.w	r12[0x8],r7
8000b2de:	30 08       	mov	r8,0
8000b2e0:	99 38       	st.w	r12[0xc],r8
8000b2e2:	99 48       	st.w	r12[0x10],r8
8000b2e4:	d8 22       	popm	r4-r7,pc
8000b2e6:	d7 03       	nop

8000b2e8 <__d2b>:
8000b2e8:	d4 31       	pushm	r0-r7,lr
8000b2ea:	20 2d       	sub	sp,8
8000b2ec:	16 93       	mov	r3,r11
8000b2ee:	12 96       	mov	r6,r9
8000b2f0:	10 95       	mov	r5,r8
8000b2f2:	14 92       	mov	r2,r10
8000b2f4:	30 1b       	mov	r11,1
8000b2f6:	cc 1f       	rcall	8000b278 <_Balloc>
8000b2f8:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b2fc:	50 09       	stdsp	sp[0x0],r9
8000b2fe:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b302:	b5 a9       	sbr	r9,0x14
8000b304:	f0 01 16 14 	lsr	r1,r8,0x14
8000b308:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b30c:	18 94       	mov	r4,r12
8000b30e:	58 02       	cp.w	r2,0
8000b310:	c1 d0       	breq	8000b34a <__d2b+0x62>
8000b312:	fa cc ff f8 	sub	r12,sp,-8
8000b316:	18 d2       	st.w	--r12,r2
8000b318:	c3 6f       	rcall	8000b184 <__lo0bits>
8000b31a:	40 18       	lddsp	r8,sp[0x4]
8000b31c:	c0 d0       	breq	8000b336 <__d2b+0x4e>
8000b31e:	40 09       	lddsp	r9,sp[0x0]
8000b320:	f8 0a 11 20 	rsub	r10,r12,32
8000b324:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b328:	f5 e8 10 08 	or	r8,r10,r8
8000b32c:	89 58       	st.w	r4[0x14],r8
8000b32e:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b332:	50 09       	stdsp	sp[0x0],r9
8000b334:	c0 28       	rjmp	8000b338 <__d2b+0x50>
8000b336:	89 58       	st.w	r4[0x14],r8
8000b338:	40 08       	lddsp	r8,sp[0x0]
8000b33a:	58 08       	cp.w	r8,0
8000b33c:	f9 b3 01 02 	movne	r3,2
8000b340:	f9 b3 00 01 	moveq	r3,1
8000b344:	89 68       	st.w	r4[0x18],r8
8000b346:	89 43       	st.w	r4[0x10],r3
8000b348:	c0 88       	rjmp	8000b358 <__d2b+0x70>
8000b34a:	1a 9c       	mov	r12,sp
8000b34c:	c1 cf       	rcall	8000b184 <__lo0bits>
8000b34e:	30 13       	mov	r3,1
8000b350:	40 08       	lddsp	r8,sp[0x0]
8000b352:	2e 0c       	sub	r12,-32
8000b354:	89 43       	st.w	r4[0x10],r3
8000b356:	89 58       	st.w	r4[0x14],r8
8000b358:	58 01       	cp.w	r1,0
8000b35a:	c0 90       	breq	8000b36c <__d2b+0x84>
8000b35c:	e2 c1 04 33 	sub	r1,r1,1075
8000b360:	18 01       	add	r1,r12
8000b362:	8d 01       	st.w	r6[0x0],r1
8000b364:	f8 0c 11 35 	rsub	r12,r12,53
8000b368:	8b 0c       	st.w	r5[0x0],r12
8000b36a:	c0 c8       	rjmp	8000b382 <__d2b+0x9a>
8000b36c:	e6 c8 ff fc 	sub	r8,r3,-4
8000b370:	f8 cc 04 32 	sub	r12,r12,1074
8000b374:	a5 73       	lsl	r3,0x5
8000b376:	8d 0c       	st.w	r6[0x0],r12
8000b378:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b37c:	cd 4e       	rcall	8000b124 <__hi0bits>
8000b37e:	18 13       	sub	r3,r12
8000b380:	8b 03       	st.w	r5[0x0],r3
8000b382:	08 9c       	mov	r12,r4
8000b384:	2f ed       	sub	sp,-8
8000b386:	d8 32       	popm	r0-r7,pc

8000b388 <__mdiff>:
8000b388:	d4 31       	pushm	r0-r7,lr
8000b38a:	74 48       	ld.w	r8,r10[0x10]
8000b38c:	76 45       	ld.w	r5,r11[0x10]
8000b38e:	16 97       	mov	r7,r11
8000b390:	14 96       	mov	r6,r10
8000b392:	10 15       	sub	r5,r8
8000b394:	c1 31       	brne	8000b3ba <__mdiff+0x32>
8000b396:	2f b8       	sub	r8,-5
8000b398:	ee ce ff ec 	sub	lr,r7,-20
8000b39c:	a3 68       	lsl	r8,0x2
8000b39e:	f4 08 00 0b 	add	r11,r10,r8
8000b3a2:	ee 08 00 08 	add	r8,r7,r8
8000b3a6:	11 4a       	ld.w	r10,--r8
8000b3a8:	17 49       	ld.w	r9,--r11
8000b3aa:	12 3a       	cp.w	r10,r9
8000b3ac:	c0 30       	breq	8000b3b2 <__mdiff+0x2a>
8000b3ae:	c0 e2       	brcc	8000b3ca <__mdiff+0x42>
8000b3b0:	c0 78       	rjmp	8000b3be <__mdiff+0x36>
8000b3b2:	1c 38       	cp.w	r8,lr
8000b3b4:	fe 9b ff f9 	brhi	8000b3a6 <__mdiff+0x1e>
8000b3b8:	c4 98       	rjmp	8000b44a <__mdiff+0xc2>
8000b3ba:	58 05       	cp.w	r5,0
8000b3bc:	c0 64       	brge	8000b3c8 <__mdiff+0x40>
8000b3be:	0e 98       	mov	r8,r7
8000b3c0:	30 15       	mov	r5,1
8000b3c2:	0c 97       	mov	r7,r6
8000b3c4:	10 96       	mov	r6,r8
8000b3c6:	c0 28       	rjmp	8000b3ca <__mdiff+0x42>
8000b3c8:	30 05       	mov	r5,0
8000b3ca:	6e 1b       	ld.w	r11,r7[0x4]
8000b3cc:	c5 6f       	rcall	8000b278 <_Balloc>
8000b3ce:	6e 49       	ld.w	r9,r7[0x10]
8000b3d0:	6c 44       	ld.w	r4,r6[0x10]
8000b3d2:	99 35       	st.w	r12[0xc],r5
8000b3d4:	2f b4       	sub	r4,-5
8000b3d6:	f2 c5 ff fb 	sub	r5,r9,-5
8000b3da:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b3de:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b3e2:	2e c6       	sub	r6,-20
8000b3e4:	2e c7       	sub	r7,-20
8000b3e6:	f8 c8 ff ec 	sub	r8,r12,-20
8000b3ea:	30 0a       	mov	r10,0
8000b3ec:	0f 0e       	ld.w	lr,r7++
8000b3ee:	0d 0b       	ld.w	r11,r6++
8000b3f0:	fc 02 16 10 	lsr	r2,lr,0x10
8000b3f4:	f6 03 16 10 	lsr	r3,r11,0x10
8000b3f8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b3fc:	e4 03 01 03 	sub	r3,r2,r3
8000b400:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b404:	fc 0b 01 0b 	sub	r11,lr,r11
8000b408:	f6 0a 00 0a 	add	r10,r11,r10
8000b40c:	b0 1a       	st.h	r8[0x2],r10
8000b40e:	b1 4a       	asr	r10,0x10
8000b410:	e6 0a 00 0a 	add	r10,r3,r10
8000b414:	b0 0a       	st.h	r8[0x0],r10
8000b416:	2f c8       	sub	r8,-4
8000b418:	b1 4a       	asr	r10,0x10
8000b41a:	08 36       	cp.w	r6,r4
8000b41c:	ce 83       	brcs	8000b3ec <__mdiff+0x64>
8000b41e:	c0 d8       	rjmp	8000b438 <__mdiff+0xb0>
8000b420:	0f 0b       	ld.w	r11,r7++
8000b422:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b426:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b42a:	16 0a       	add	r10,r11
8000b42c:	b0 1a       	st.h	r8[0x2],r10
8000b42e:	b1 4a       	asr	r10,0x10
8000b430:	1c 0a       	add	r10,lr
8000b432:	b0 0a       	st.h	r8[0x0],r10
8000b434:	2f c8       	sub	r8,-4
8000b436:	b1 4a       	asr	r10,0x10
8000b438:	0a 37       	cp.w	r7,r5
8000b43a:	cf 33       	brcs	8000b420 <__mdiff+0x98>
8000b43c:	c0 28       	rjmp	8000b440 <__mdiff+0xb8>
8000b43e:	20 19       	sub	r9,1
8000b440:	11 4a       	ld.w	r10,--r8
8000b442:	58 0a       	cp.w	r10,0
8000b444:	cf d0       	breq	8000b43e <__mdiff+0xb6>
8000b446:	99 49       	st.w	r12[0x10],r9
8000b448:	d8 32       	popm	r0-r7,pc
8000b44a:	30 0b       	mov	r11,0
8000b44c:	c1 6f       	rcall	8000b278 <_Balloc>
8000b44e:	30 18       	mov	r8,1
8000b450:	99 48       	st.w	r12[0x10],r8
8000b452:	30 08       	mov	r8,0
8000b454:	99 58       	st.w	r12[0x14],r8
8000b456:	d8 32       	popm	r0-r7,pc

8000b458 <__lshift>:
8000b458:	d4 31       	pushm	r0-r7,lr
8000b45a:	16 97       	mov	r7,r11
8000b45c:	76 46       	ld.w	r6,r11[0x10]
8000b45e:	f4 02 14 05 	asr	r2,r10,0x5
8000b462:	2f f6       	sub	r6,-1
8000b464:	14 93       	mov	r3,r10
8000b466:	18 94       	mov	r4,r12
8000b468:	04 06       	add	r6,r2
8000b46a:	76 1b       	ld.w	r11,r11[0x4]
8000b46c:	6e 28       	ld.w	r8,r7[0x8]
8000b46e:	c0 38       	rjmp	8000b474 <__lshift+0x1c>
8000b470:	2f fb       	sub	r11,-1
8000b472:	a1 78       	lsl	r8,0x1
8000b474:	10 36       	cp.w	r6,r8
8000b476:	fe 99 ff fd 	brgt	8000b470 <__lshift+0x18>
8000b47a:	08 9c       	mov	r12,r4
8000b47c:	cf ee       	rcall	8000b278 <_Balloc>
8000b47e:	30 09       	mov	r9,0
8000b480:	18 95       	mov	r5,r12
8000b482:	f8 c8 ff ec 	sub	r8,r12,-20
8000b486:	12 9a       	mov	r10,r9
8000b488:	c0 38       	rjmp	8000b48e <__lshift+0x36>
8000b48a:	10 aa       	st.w	r8++,r10
8000b48c:	2f f9       	sub	r9,-1
8000b48e:	04 39       	cp.w	r9,r2
8000b490:	cf d5       	brlt	8000b48a <__lshift+0x32>
8000b492:	6e 4b       	ld.w	r11,r7[0x10]
8000b494:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b498:	2f bb       	sub	r11,-5
8000b49a:	ee c9 ff ec 	sub	r9,r7,-20
8000b49e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b4a2:	58 03       	cp.w	r3,0
8000b4a4:	c1 30       	breq	8000b4ca <__lshift+0x72>
8000b4a6:	e6 0c 11 20 	rsub	r12,r3,32
8000b4aa:	30 0a       	mov	r10,0
8000b4ac:	72 02       	ld.w	r2,r9[0x0]
8000b4ae:	e4 03 09 42 	lsl	r2,r2,r3
8000b4b2:	04 4a       	or	r10,r2
8000b4b4:	10 aa       	st.w	r8++,r10
8000b4b6:	13 0a       	ld.w	r10,r9++
8000b4b8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b4bc:	16 39       	cp.w	r9,r11
8000b4be:	cf 73       	brcs	8000b4ac <__lshift+0x54>
8000b4c0:	91 0a       	st.w	r8[0x0],r10
8000b4c2:	58 0a       	cp.w	r10,0
8000b4c4:	c0 70       	breq	8000b4d2 <__lshift+0x7a>
8000b4c6:	2f f6       	sub	r6,-1
8000b4c8:	c0 58       	rjmp	8000b4d2 <__lshift+0x7a>
8000b4ca:	13 0a       	ld.w	r10,r9++
8000b4cc:	10 aa       	st.w	r8++,r10
8000b4ce:	16 39       	cp.w	r9,r11
8000b4d0:	cf d3       	brcs	8000b4ca <__lshift+0x72>
8000b4d2:	08 9c       	mov	r12,r4
8000b4d4:	20 16       	sub	r6,1
8000b4d6:	0e 9b       	mov	r11,r7
8000b4d8:	8b 46       	st.w	r5[0x10],r6
8000b4da:	cb 5e       	rcall	8000b244 <_Bfree>
8000b4dc:	0a 9c       	mov	r12,r5
8000b4de:	d8 32       	popm	r0-r7,pc

8000b4e0 <__multiply>:
8000b4e0:	d4 31       	pushm	r0-r7,lr
8000b4e2:	20 2d       	sub	sp,8
8000b4e4:	76 49       	ld.w	r9,r11[0x10]
8000b4e6:	74 48       	ld.w	r8,r10[0x10]
8000b4e8:	16 96       	mov	r6,r11
8000b4ea:	14 95       	mov	r5,r10
8000b4ec:	10 39       	cp.w	r9,r8
8000b4ee:	ec 08 17 50 	movlt	r8,r6
8000b4f2:	ea 06 17 50 	movlt	r6,r5
8000b4f6:	f0 05 17 50 	movlt	r5,r8
8000b4fa:	6c 28       	ld.w	r8,r6[0x8]
8000b4fc:	76 43       	ld.w	r3,r11[0x10]
8000b4fe:	74 42       	ld.w	r2,r10[0x10]
8000b500:	76 1b       	ld.w	r11,r11[0x4]
8000b502:	e4 03 00 07 	add	r7,r2,r3
8000b506:	10 37       	cp.w	r7,r8
8000b508:	f7 bb 09 ff 	subgt	r11,-1
8000b50c:	cb 6e       	rcall	8000b278 <_Balloc>
8000b50e:	ee c4 ff fb 	sub	r4,r7,-5
8000b512:	f8 c9 ff ec 	sub	r9,r12,-20
8000b516:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b51a:	30 0a       	mov	r10,0
8000b51c:	12 98       	mov	r8,r9
8000b51e:	c0 28       	rjmp	8000b522 <__multiply+0x42>
8000b520:	10 aa       	st.w	r8++,r10
8000b522:	08 38       	cp.w	r8,r4
8000b524:	cf e3       	brcs	8000b520 <__multiply+0x40>
8000b526:	2f b3       	sub	r3,-5
8000b528:	2f b2       	sub	r2,-5
8000b52a:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b52e:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b532:	ec cb ff ec 	sub	r11,r6,-20
8000b536:	50 12       	stdsp	sp[0x4],r2
8000b538:	ea ca ff ec 	sub	r10,r5,-20
8000b53c:	c4 48       	rjmp	8000b5c4 <__multiply+0xe4>
8000b53e:	94 95       	ld.uh	r5,r10[0x2]
8000b540:	58 05       	cp.w	r5,0
8000b542:	c2 00       	breq	8000b582 <__multiply+0xa2>
8000b544:	12 98       	mov	r8,r9
8000b546:	16 96       	mov	r6,r11
8000b548:	30 0e       	mov	lr,0
8000b54a:	50 09       	stdsp	sp[0x0],r9
8000b54c:	0d 02       	ld.w	r2,r6++
8000b54e:	e4 00 16 10 	lsr	r0,r2,0x10
8000b552:	70 01       	ld.w	r1,r8[0x0]
8000b554:	70 09       	ld.w	r9,r8[0x0]
8000b556:	b1 81       	lsr	r1,0x10
8000b558:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b55c:	e0 05 03 41 	mac	r1,r0,r5
8000b560:	ab 32       	mul	r2,r5
8000b562:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b566:	00 02       	add	r2,r0
8000b568:	e4 0e 00 0e 	add	lr,r2,lr
8000b56c:	b0 1e       	st.h	r8[0x2],lr
8000b56e:	b1 8e       	lsr	lr,0x10
8000b570:	1c 01       	add	r1,lr
8000b572:	b0 01       	st.h	r8[0x0],r1
8000b574:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b578:	2f c8       	sub	r8,-4
8000b57a:	06 36       	cp.w	r6,r3
8000b57c:	ce 83       	brcs	8000b54c <__multiply+0x6c>
8000b57e:	40 09       	lddsp	r9,sp[0x0]
8000b580:	91 0e       	st.w	r8[0x0],lr
8000b582:	94 86       	ld.uh	r6,r10[0x0]
8000b584:	58 06       	cp.w	r6,0
8000b586:	c1 d0       	breq	8000b5c0 <__multiply+0xe0>
8000b588:	72 02       	ld.w	r2,r9[0x0]
8000b58a:	12 98       	mov	r8,r9
8000b58c:	16 9e       	mov	lr,r11
8000b58e:	30 05       	mov	r5,0
8000b590:	b0 12       	st.h	r8[0x2],r2
8000b592:	1d 01       	ld.w	r1,lr++
8000b594:	90 82       	ld.uh	r2,r8[0x0]
8000b596:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b59a:	ad 30       	mul	r0,r6
8000b59c:	e0 02 00 02 	add	r2,r0,r2
8000b5a0:	e4 05 00 05 	add	r5,r2,r5
8000b5a4:	b0 05       	st.h	r8[0x0],r5
8000b5a6:	b1 85       	lsr	r5,0x10
8000b5a8:	b1 81       	lsr	r1,0x10
8000b5aa:	2f c8       	sub	r8,-4
8000b5ac:	ad 31       	mul	r1,r6
8000b5ae:	90 92       	ld.uh	r2,r8[0x2]
8000b5b0:	e2 02 00 02 	add	r2,r1,r2
8000b5b4:	0a 02       	add	r2,r5
8000b5b6:	e4 05 16 10 	lsr	r5,r2,0x10
8000b5ba:	06 3e       	cp.w	lr,r3
8000b5bc:	ce a3       	brcs	8000b590 <__multiply+0xb0>
8000b5be:	91 02       	st.w	r8[0x0],r2
8000b5c0:	2f ca       	sub	r10,-4
8000b5c2:	2f c9       	sub	r9,-4
8000b5c4:	40 18       	lddsp	r8,sp[0x4]
8000b5c6:	10 3a       	cp.w	r10,r8
8000b5c8:	cb b3       	brcs	8000b53e <__multiply+0x5e>
8000b5ca:	c0 28       	rjmp	8000b5ce <__multiply+0xee>
8000b5cc:	20 17       	sub	r7,1
8000b5ce:	58 07       	cp.w	r7,0
8000b5d0:	e0 8a 00 05 	brle	8000b5da <__multiply+0xfa>
8000b5d4:	09 48       	ld.w	r8,--r4
8000b5d6:	58 08       	cp.w	r8,0
8000b5d8:	cf a0       	breq	8000b5cc <__multiply+0xec>
8000b5da:	99 47       	st.w	r12[0x10],r7
8000b5dc:	2f ed       	sub	sp,-8
8000b5de:	d8 32       	popm	r0-r7,pc

8000b5e0 <__i2b>:
8000b5e0:	d4 21       	pushm	r4-r7,lr
8000b5e2:	16 97       	mov	r7,r11
8000b5e4:	30 1b       	mov	r11,1
8000b5e6:	c4 9e       	rcall	8000b278 <_Balloc>
8000b5e8:	30 19       	mov	r9,1
8000b5ea:	99 57       	st.w	r12[0x14],r7
8000b5ec:	99 49       	st.w	r12[0x10],r9
8000b5ee:	d8 22       	popm	r4-r7,pc

8000b5f0 <__multadd>:
8000b5f0:	d4 31       	pushm	r0-r7,lr
8000b5f2:	30 08       	mov	r8,0
8000b5f4:	12 95       	mov	r5,r9
8000b5f6:	16 97       	mov	r7,r11
8000b5f8:	18 96       	mov	r6,r12
8000b5fa:	76 44       	ld.w	r4,r11[0x10]
8000b5fc:	f6 c9 ff ec 	sub	r9,r11,-20
8000b600:	72 0b       	ld.w	r11,r9[0x0]
8000b602:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b606:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b60a:	f4 0c 02 4c 	mul	r12,r10,r12
8000b60e:	f4 0b 03 45 	mac	r5,r10,r11
8000b612:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b616:	b1 85       	lsr	r5,0x10
8000b618:	18 05       	add	r5,r12
8000b61a:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b61e:	f8 0b 00 0b 	add	r11,r12,r11
8000b622:	12 ab       	st.w	r9++,r11
8000b624:	2f f8       	sub	r8,-1
8000b626:	b1 85       	lsr	r5,0x10
8000b628:	08 38       	cp.w	r8,r4
8000b62a:	ce b5       	brlt	8000b600 <__multadd+0x10>
8000b62c:	58 05       	cp.w	r5,0
8000b62e:	c1 c0       	breq	8000b666 <__multadd+0x76>
8000b630:	6e 28       	ld.w	r8,r7[0x8]
8000b632:	10 34       	cp.w	r4,r8
8000b634:	c1 35       	brlt	8000b65a <__multadd+0x6a>
8000b636:	6e 1b       	ld.w	r11,r7[0x4]
8000b638:	0c 9c       	mov	r12,r6
8000b63a:	2f fb       	sub	r11,-1
8000b63c:	c1 ee       	rcall	8000b278 <_Balloc>
8000b63e:	6e 4a       	ld.w	r10,r7[0x10]
8000b640:	ee cb ff f4 	sub	r11,r7,-12
8000b644:	18 93       	mov	r3,r12
8000b646:	2f ea       	sub	r10,-2
8000b648:	2f 4c       	sub	r12,-12
8000b64a:	a3 6a       	lsl	r10,0x2
8000b64c:	fe b0 dd 8c 	rcall	80007164 <memcpy>
8000b650:	0e 9b       	mov	r11,r7
8000b652:	0c 9c       	mov	r12,r6
8000b654:	fe b0 fd f8 	rcall	8000b244 <_Bfree>
8000b658:	06 97       	mov	r7,r3
8000b65a:	e8 c8 ff ff 	sub	r8,r4,-1
8000b65e:	2f b4       	sub	r4,-5
8000b660:	8f 48       	st.w	r7[0x10],r8
8000b662:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b666:	0e 9c       	mov	r12,r7
8000b668:	d8 32       	popm	r0-r7,pc
8000b66a:	d7 03       	nop

8000b66c <__pow5mult>:
8000b66c:	d4 31       	pushm	r0-r7,lr
8000b66e:	14 96       	mov	r6,r10
8000b670:	18 97       	mov	r7,r12
8000b672:	16 94       	mov	r4,r11
8000b674:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b678:	c0 90       	breq	8000b68a <__pow5mult+0x1e>
8000b67a:	20 18       	sub	r8,1
8000b67c:	fe c9 e8 40 	sub	r9,pc,-6080
8000b680:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b684:	30 09       	mov	r9,0
8000b686:	cb 5f       	rcall	8000b5f0 <__multadd>
8000b688:	18 94       	mov	r4,r12
8000b68a:	a3 46       	asr	r6,0x2
8000b68c:	c3 40       	breq	8000b6f4 <__pow5mult+0x88>
8000b68e:	6e 95       	ld.w	r5,r7[0x24]
8000b690:	58 05       	cp.w	r5,0
8000b692:	c0 91       	brne	8000b6a4 <__pow5mult+0x38>
8000b694:	31 0c       	mov	r12,16
8000b696:	fe b0 db 43 	rcall	80006d1c <malloc>
8000b69a:	99 35       	st.w	r12[0xc],r5
8000b69c:	8f 9c       	st.w	r7[0x24],r12
8000b69e:	99 15       	st.w	r12[0x4],r5
8000b6a0:	99 25       	st.w	r12[0x8],r5
8000b6a2:	99 05       	st.w	r12[0x0],r5
8000b6a4:	6e 93       	ld.w	r3,r7[0x24]
8000b6a6:	66 25       	ld.w	r5,r3[0x8]
8000b6a8:	58 05       	cp.w	r5,0
8000b6aa:	c0 c1       	brne	8000b6c2 <__pow5mult+0x56>
8000b6ac:	e0 6b 02 71 	mov	r11,625
8000b6b0:	0e 9c       	mov	r12,r7
8000b6b2:	c9 7f       	rcall	8000b5e0 <__i2b>
8000b6b4:	87 2c       	st.w	r3[0x8],r12
8000b6b6:	30 08       	mov	r8,0
8000b6b8:	18 95       	mov	r5,r12
8000b6ba:	99 08       	st.w	r12[0x0],r8
8000b6bc:	c0 38       	rjmp	8000b6c2 <__pow5mult+0x56>
8000b6be:	06 9c       	mov	r12,r3
8000b6c0:	18 95       	mov	r5,r12
8000b6c2:	ed b6 00 00 	bld	r6,0x0
8000b6c6:	c0 b1       	brne	8000b6dc <__pow5mult+0x70>
8000b6c8:	08 9b       	mov	r11,r4
8000b6ca:	0a 9a       	mov	r10,r5
8000b6cc:	0e 9c       	mov	r12,r7
8000b6ce:	c0 9f       	rcall	8000b4e0 <__multiply>
8000b6d0:	08 9b       	mov	r11,r4
8000b6d2:	18 93       	mov	r3,r12
8000b6d4:	0e 9c       	mov	r12,r7
8000b6d6:	06 94       	mov	r4,r3
8000b6d8:	fe b0 fd b6 	rcall	8000b244 <_Bfree>
8000b6dc:	a1 56       	asr	r6,0x1
8000b6de:	c0 b0       	breq	8000b6f4 <__pow5mult+0x88>
8000b6e0:	6a 03       	ld.w	r3,r5[0x0]
8000b6e2:	58 03       	cp.w	r3,0
8000b6e4:	ce d1       	brne	8000b6be <__pow5mult+0x52>
8000b6e6:	0a 9a       	mov	r10,r5
8000b6e8:	0a 9b       	mov	r11,r5
8000b6ea:	0e 9c       	mov	r12,r7
8000b6ec:	cf ae       	rcall	8000b4e0 <__multiply>
8000b6ee:	8b 0c       	st.w	r5[0x0],r12
8000b6f0:	99 03       	st.w	r12[0x0],r3
8000b6f2:	ce 7b       	rjmp	8000b6c0 <__pow5mult+0x54>
8000b6f4:	08 9c       	mov	r12,r4
8000b6f6:	d8 32       	popm	r0-r7,pc

8000b6f8 <__isinfd>:
8000b6f8:	14 98       	mov	r8,r10
8000b6fa:	fc 19 7f f0 	movh	r9,0x7ff0
8000b6fe:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b702:	f0 0b 11 00 	rsub	r11,r8,0
8000b706:	f7 e8 10 08 	or	r8,r11,r8
8000b70a:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b70e:	f2 08 01 08 	sub	r8,r9,r8
8000b712:	f0 0c 11 00 	rsub	r12,r8,0
8000b716:	f9 e8 10 08 	or	r8,r12,r8
8000b71a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b71e:	2f fc       	sub	r12,-1
8000b720:	5e fc       	retal	r12

8000b722 <__isnand>:
8000b722:	14 98       	mov	r8,r10
8000b724:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b728:	f0 0c 11 00 	rsub	r12,r8,0
8000b72c:	10 4c       	or	r12,r8
8000b72e:	fc 18 7f f0 	movh	r8,0x7ff0
8000b732:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b736:	f0 0c 01 0c 	sub	r12,r8,r12
8000b73a:	bf 9c       	lsr	r12,0x1f
8000b73c:	5e fc       	retal	r12
8000b73e:	d7 03       	nop

8000b740 <__sclose>:
8000b740:	d4 01       	pushm	lr
8000b742:	96 7b       	ld.sh	r11,r11[0xe]
8000b744:	c8 2c       	rcall	8000b848 <_close_r>
8000b746:	d8 02       	popm	pc

8000b748 <__sseek>:
8000b748:	d4 21       	pushm	r4-r7,lr
8000b74a:	16 97       	mov	r7,r11
8000b74c:	96 7b       	ld.sh	r11,r11[0xe]
8000b74e:	c0 3d       	rcall	8000b954 <_lseek_r>
8000b750:	8e 68       	ld.sh	r8,r7[0xc]
8000b752:	10 99       	mov	r9,r8
8000b754:	ad c8       	cbr	r8,0xc
8000b756:	ad a9       	sbr	r9,0xc
8000b758:	5b fc       	cp.w	r12,-1
8000b75a:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b75e:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b762:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b766:	d8 22       	popm	r4-r7,pc

8000b768 <__swrite>:
8000b768:	d4 21       	pushm	r4-r7,lr
8000b76a:	96 68       	ld.sh	r8,r11[0xc]
8000b76c:	16 97       	mov	r7,r11
8000b76e:	14 95       	mov	r5,r10
8000b770:	12 94       	mov	r4,r9
8000b772:	e2 18 01 00 	andl	r8,0x100,COH
8000b776:	18 96       	mov	r6,r12
8000b778:	c0 50       	breq	8000b782 <__swrite+0x1a>
8000b77a:	30 29       	mov	r9,2
8000b77c:	30 0a       	mov	r10,0
8000b77e:	96 7b       	ld.sh	r11,r11[0xe]
8000b780:	ce ac       	rcall	8000b954 <_lseek_r>
8000b782:	8e 68       	ld.sh	r8,r7[0xc]
8000b784:	ad c8       	cbr	r8,0xc
8000b786:	08 99       	mov	r9,r4
8000b788:	0a 9a       	mov	r10,r5
8000b78a:	8e 7b       	ld.sh	r11,r7[0xe]
8000b78c:	0c 9c       	mov	r12,r6
8000b78e:	ae 68       	st.h	r7[0xc],r8
8000b790:	c1 cc       	rcall	8000b7c8 <_write_r>
8000b792:	d8 22       	popm	r4-r7,pc

8000b794 <__sread>:
8000b794:	d4 21       	pushm	r4-r7,lr
8000b796:	16 97       	mov	r7,r11
8000b798:	96 7b       	ld.sh	r11,r11[0xe]
8000b79a:	cf 1c       	rcall	8000b97c <_read_r>
8000b79c:	c0 65       	brlt	8000b7a8 <__sread+0x14>
8000b79e:	6f 58       	ld.w	r8,r7[0x54]
8000b7a0:	18 08       	add	r8,r12
8000b7a2:	ef 48 00 54 	st.w	r7[84],r8
8000b7a6:	d8 22       	popm	r4-r7,pc
8000b7a8:	8e 68       	ld.sh	r8,r7[0xc]
8000b7aa:	ad c8       	cbr	r8,0xc
8000b7ac:	ae 68       	st.h	r7[0xc],r8
8000b7ae:	d8 22       	popm	r4-r7,pc

8000b7b0 <strlen>:
8000b7b0:	30 09       	mov	r9,0
8000b7b2:	18 98       	mov	r8,r12
8000b7b4:	c0 28       	rjmp	8000b7b8 <strlen+0x8>
8000b7b6:	2f f8       	sub	r8,-1
8000b7b8:	11 8a       	ld.ub	r10,r8[0x0]
8000b7ba:	f2 0a 18 00 	cp.b	r10,r9
8000b7be:	cf c1       	brne	8000b7b6 <strlen+0x6>
8000b7c0:	f0 0c 01 0c 	sub	r12,r8,r12
8000b7c4:	5e fc       	retal	r12
8000b7c6:	d7 03       	nop

8000b7c8 <_write_r>:
8000b7c8:	d4 21       	pushm	r4-r7,lr
8000b7ca:	16 98       	mov	r8,r11
8000b7cc:	18 97       	mov	r7,r12
8000b7ce:	10 9c       	mov	r12,r8
8000b7d0:	30 08       	mov	r8,0
8000b7d2:	14 9b       	mov	r11,r10
8000b7d4:	e0 66 07 fc 	mov	r6,2044
8000b7d8:	12 9a       	mov	r10,r9
8000b7da:	8d 08       	st.w	r6[0x0],r8
8000b7dc:	fe b0 ce 32 	rcall	80005440 <_write>
8000b7e0:	5b fc       	cp.w	r12,-1
8000b7e2:	c0 51       	brne	8000b7ec <_write_r+0x24>
8000b7e4:	6c 08       	ld.w	r8,r6[0x0]
8000b7e6:	58 08       	cp.w	r8,0
8000b7e8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b7ec:	d8 22       	popm	r4-r7,pc
8000b7ee:	d7 03       	nop

8000b7f0 <_calloc_r>:
8000b7f0:	d4 21       	pushm	r4-r7,lr
8000b7f2:	f4 0b 02 4b 	mul	r11,r10,r11
8000b7f6:	fe b0 da 9b 	rcall	80006d2c <_malloc_r>
8000b7fa:	18 97       	mov	r7,r12
8000b7fc:	c2 30       	breq	8000b842 <_calloc_r+0x52>
8000b7fe:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b802:	e0 1a ff fc 	andl	r10,0xfffc
8000b806:	20 4a       	sub	r10,4
8000b808:	e0 4a 00 24 	cp.w	r10,36
8000b80c:	e0 8b 00 18 	brhi	8000b83c <_calloc_r+0x4c>
8000b810:	18 98       	mov	r8,r12
8000b812:	59 3a       	cp.w	r10,19
8000b814:	e0 88 00 0f 	brls	8000b832 <_calloc_r+0x42>
8000b818:	30 09       	mov	r9,0
8000b81a:	10 a9       	st.w	r8++,r9
8000b81c:	10 a9       	st.w	r8++,r9
8000b81e:	59 ba       	cp.w	r10,27
8000b820:	e0 88 00 09 	brls	8000b832 <_calloc_r+0x42>
8000b824:	10 a9       	st.w	r8++,r9
8000b826:	10 a9       	st.w	r8++,r9
8000b828:	e0 4a 00 24 	cp.w	r10,36
8000b82c:	c0 31       	brne	8000b832 <_calloc_r+0x42>
8000b82e:	10 a9       	st.w	r8++,r9
8000b830:	10 a9       	st.w	r8++,r9
8000b832:	30 09       	mov	r9,0
8000b834:	10 a9       	st.w	r8++,r9
8000b836:	91 19       	st.w	r8[0x4],r9
8000b838:	91 09       	st.w	r8[0x0],r9
8000b83a:	c0 48       	rjmp	8000b842 <_calloc_r+0x52>
8000b83c:	30 0b       	mov	r11,0
8000b83e:	fe b0 dd 37 	rcall	800072ac <memset>
8000b842:	0e 9c       	mov	r12,r7
8000b844:	d8 22       	popm	r4-r7,pc
8000b846:	d7 03       	nop

8000b848 <_close_r>:
8000b848:	d4 21       	pushm	r4-r7,lr
8000b84a:	30 08       	mov	r8,0
8000b84c:	18 97       	mov	r7,r12
8000b84e:	e0 66 07 fc 	mov	r6,2044
8000b852:	16 9c       	mov	r12,r11
8000b854:	8d 08       	st.w	r6[0x0],r8
8000b856:	fe b0 de db 	rcall	8000760c <_close>
8000b85a:	5b fc       	cp.w	r12,-1
8000b85c:	c0 51       	brne	8000b866 <_close_r+0x1e>
8000b85e:	6c 08       	ld.w	r8,r6[0x0]
8000b860:	58 08       	cp.w	r8,0
8000b862:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b866:	d8 22       	popm	r4-r7,pc

8000b868 <_fclose_r>:
8000b868:	d4 21       	pushm	r4-r7,lr
8000b86a:	18 96       	mov	r6,r12
8000b86c:	16 97       	mov	r7,r11
8000b86e:	58 0b       	cp.w	r11,0
8000b870:	c0 31       	brne	8000b876 <_fclose_r+0xe>
8000b872:	16 95       	mov	r5,r11
8000b874:	c5 38       	rjmp	8000b91a <_fclose_r+0xb2>
8000b876:	fe b0 f8 a9 	rcall	8000a9c8 <__sfp_lock_acquire>
8000b87a:	58 06       	cp.w	r6,0
8000b87c:	c0 70       	breq	8000b88a <_fclose_r+0x22>
8000b87e:	6c 68       	ld.w	r8,r6[0x18]
8000b880:	58 08       	cp.w	r8,0
8000b882:	c0 41       	brne	8000b88a <_fclose_r+0x22>
8000b884:	0c 9c       	mov	r12,r6
8000b886:	fe b0 f8 f3 	rcall	8000aa6c <__sinit>
8000b88a:	fe c8 ea ee 	sub	r8,pc,-5394
8000b88e:	10 37       	cp.w	r7,r8
8000b890:	c0 31       	brne	8000b896 <_fclose_r+0x2e>
8000b892:	6c 07       	ld.w	r7,r6[0x0]
8000b894:	c0 c8       	rjmp	8000b8ac <_fclose_r+0x44>
8000b896:	fe c8 ea da 	sub	r8,pc,-5414
8000b89a:	10 37       	cp.w	r7,r8
8000b89c:	c0 31       	brne	8000b8a2 <_fclose_r+0x3a>
8000b89e:	6c 17       	ld.w	r7,r6[0x4]
8000b8a0:	c0 68       	rjmp	8000b8ac <_fclose_r+0x44>
8000b8a2:	fe c8 ea c6 	sub	r8,pc,-5434
8000b8a6:	10 37       	cp.w	r7,r8
8000b8a8:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b8ac:	8e 69       	ld.sh	r9,r7[0xc]
8000b8ae:	30 08       	mov	r8,0
8000b8b0:	f0 09 19 00 	cp.h	r9,r8
8000b8b4:	c0 51       	brne	8000b8be <_fclose_r+0x56>
8000b8b6:	fe b0 f8 8a 	rcall	8000a9ca <__sfp_lock_release>
8000b8ba:	30 05       	mov	r5,0
8000b8bc:	c2 f8       	rjmp	8000b91a <_fclose_r+0xb2>
8000b8be:	0e 9b       	mov	r11,r7
8000b8c0:	0c 9c       	mov	r12,r6
8000b8c2:	fe b0 f7 fd 	rcall	8000a8bc <_fflush_r>
8000b8c6:	6e c8       	ld.w	r8,r7[0x30]
8000b8c8:	18 95       	mov	r5,r12
8000b8ca:	58 08       	cp.w	r8,0
8000b8cc:	c0 60       	breq	8000b8d8 <_fclose_r+0x70>
8000b8ce:	6e 8b       	ld.w	r11,r7[0x20]
8000b8d0:	0c 9c       	mov	r12,r6
8000b8d2:	5d 18       	icall	r8
8000b8d4:	f9 b5 05 ff 	movlt	r5,-1
8000b8d8:	8e 68       	ld.sh	r8,r7[0xc]
8000b8da:	ed b8 00 07 	bld	r8,0x7
8000b8de:	c0 51       	brne	8000b8e8 <_fclose_r+0x80>
8000b8e0:	6e 4b       	ld.w	r11,r7[0x10]
8000b8e2:	0c 9c       	mov	r12,r6
8000b8e4:	fe b0 f9 5e 	rcall	8000aba0 <_free_r>
8000b8e8:	6e db       	ld.w	r11,r7[0x34]
8000b8ea:	58 0b       	cp.w	r11,0
8000b8ec:	c0 a0       	breq	8000b900 <_fclose_r+0x98>
8000b8ee:	ee c8 ff bc 	sub	r8,r7,-68
8000b8f2:	10 3b       	cp.w	r11,r8
8000b8f4:	c0 40       	breq	8000b8fc <_fclose_r+0x94>
8000b8f6:	0c 9c       	mov	r12,r6
8000b8f8:	fe b0 f9 54 	rcall	8000aba0 <_free_r>
8000b8fc:	30 08       	mov	r8,0
8000b8fe:	8f d8       	st.w	r7[0x34],r8
8000b900:	6f 2b       	ld.w	r11,r7[0x48]
8000b902:	58 0b       	cp.w	r11,0
8000b904:	c0 70       	breq	8000b912 <_fclose_r+0xaa>
8000b906:	0c 9c       	mov	r12,r6
8000b908:	fe b0 f9 4c 	rcall	8000aba0 <_free_r>
8000b90c:	30 08       	mov	r8,0
8000b90e:	ef 48 00 48 	st.w	r7[72],r8
8000b912:	30 08       	mov	r8,0
8000b914:	ae 68       	st.h	r7[0xc],r8
8000b916:	fe b0 f8 5a 	rcall	8000a9ca <__sfp_lock_release>
8000b91a:	0a 9c       	mov	r12,r5
8000b91c:	d8 22       	popm	r4-r7,pc
8000b91e:	d7 03       	nop

8000b920 <fclose>:
8000b920:	d4 01       	pushm	lr
8000b922:	e0 68 01 18 	mov	r8,280
8000b926:	18 9b       	mov	r11,r12
8000b928:	70 0c       	ld.w	r12,r8[0x0]
8000b92a:	c9 ff       	rcall	8000b868 <_fclose_r>
8000b92c:	d8 02       	popm	pc
8000b92e:	d7 03       	nop

8000b930 <_fstat_r>:
8000b930:	d4 21       	pushm	r4-r7,lr
8000b932:	16 98       	mov	r8,r11
8000b934:	18 97       	mov	r7,r12
8000b936:	10 9c       	mov	r12,r8
8000b938:	30 08       	mov	r8,0
8000b93a:	e0 66 07 fc 	mov	r6,2044
8000b93e:	14 9b       	mov	r11,r10
8000b940:	8d 08       	st.w	r6[0x0],r8
8000b942:	fe b0 de 8d 	rcall	8000765c <_fstat>
8000b946:	5b fc       	cp.w	r12,-1
8000b948:	c0 51       	brne	8000b952 <_fstat_r+0x22>
8000b94a:	6c 08       	ld.w	r8,r6[0x0]
8000b94c:	58 08       	cp.w	r8,0
8000b94e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b952:	d8 22       	popm	r4-r7,pc

8000b954 <_lseek_r>:
8000b954:	d4 21       	pushm	r4-r7,lr
8000b956:	16 98       	mov	r8,r11
8000b958:	18 97       	mov	r7,r12
8000b95a:	10 9c       	mov	r12,r8
8000b95c:	30 08       	mov	r8,0
8000b95e:	14 9b       	mov	r11,r10
8000b960:	e0 66 07 fc 	mov	r6,2044
8000b964:	12 9a       	mov	r10,r9
8000b966:	8d 08       	st.w	r6[0x0],r8
8000b968:	fe b0 de 5c 	rcall	80007620 <_lseek>
8000b96c:	5b fc       	cp.w	r12,-1
8000b96e:	c0 51       	brne	8000b978 <_lseek_r+0x24>
8000b970:	6c 08       	ld.w	r8,r6[0x0]
8000b972:	58 08       	cp.w	r8,0
8000b974:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b978:	d8 22       	popm	r4-r7,pc
8000b97a:	d7 03       	nop

8000b97c <_read_r>:
8000b97c:	d4 21       	pushm	r4-r7,lr
8000b97e:	16 98       	mov	r8,r11
8000b980:	18 97       	mov	r7,r12
8000b982:	10 9c       	mov	r12,r8
8000b984:	30 08       	mov	r8,0
8000b986:	14 9b       	mov	r11,r10
8000b988:	e0 66 07 fc 	mov	r6,2044
8000b98c:	12 9a       	mov	r10,r9
8000b98e:	8d 08       	st.w	r6[0x0],r8
8000b990:	fe b0 cd 12 	rcall	800053b4 <_read>
8000b994:	5b fc       	cp.w	r12,-1
8000b996:	c0 51       	brne	8000b9a0 <_read_r+0x24>
8000b998:	6c 08       	ld.w	r8,r6[0x0]
8000b99a:	58 08       	cp.w	r8,0
8000b99c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b9a0:	d8 22       	popm	r4-r7,pc
8000b9a2:	d7 03       	nop

8000b9a4 <__avr32_f64_mul>:
8000b9a4:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b9a8:	e0 80 00 dc 	breq	8000bb60 <__avr32_f64_mul_op1_zero>
8000b9ac:	d4 21       	pushm	r4-r7,lr
8000b9ae:	f7 e9 20 0e 	eor	lr,r11,r9
8000b9b2:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b9b6:	30 15       	mov	r5,1
8000b9b8:	c4 30       	breq	8000ba3e <__avr32_f64_mul_op1_subnormal>
8000b9ba:	ab 6b       	lsl	r11,0xa
8000b9bc:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b9c0:	ab 6a       	lsl	r10,0xa
8000b9c2:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b9c6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b9ca:	c5 c0       	breq	8000ba82 <__avr32_f64_mul_op2_subnormal>
8000b9cc:	a1 78       	lsl	r8,0x1
8000b9ce:	5c f9       	rol	r9
8000b9d0:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b9d4:	e0 47 07 ff 	cp.w	r7,2047
8000b9d8:	c7 70       	breq	8000bac6 <__avr32_f64_mul_op_nan_or_inf>
8000b9da:	e0 46 07 ff 	cp.w	r6,2047
8000b9de:	c7 40       	breq	8000bac6 <__avr32_f64_mul_op_nan_or_inf>
8000b9e0:	ee 06 00 0c 	add	r12,r7,r6
8000b9e4:	e0 2c 03 fe 	sub	r12,1022
8000b9e8:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b9ec:	f4 09 07 44 	macu.d	r4,r10,r9
8000b9f0:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b9f4:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b9f8:	08 07       	add	r7,r4
8000b9fa:	f4 05 00 4a 	adc	r10,r10,r5
8000b9fe:	5c 0b       	acr	r11
8000ba00:	ed bb 00 14 	bld	r11,0x14
8000ba04:	c0 50       	breq	8000ba0e <__avr32_f64_mul+0x6a>
8000ba06:	a1 77       	lsl	r7,0x1
8000ba08:	5c fa       	rol	r10
8000ba0a:	5c fb       	rol	r11
8000ba0c:	20 1c       	sub	r12,1
8000ba0e:	58 0c       	cp.w	r12,0
8000ba10:	e0 8a 00 6f 	brle	8000baee <__avr32_f64_mul_res_subnormal>
8000ba14:	e0 4c 07 ff 	cp.w	r12,2047
8000ba18:	e0 84 00 9c 	brge	8000bb50 <__avr32_f64_mul_res_inf>
8000ba1c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000ba20:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000ba24:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000ba28:	ee 17 80 00 	eorh	r7,0x8000
8000ba2c:	f1 b7 04 20 	satu	r7,0x1
8000ba30:	0e 0a       	add	r10,r7
8000ba32:	5c 0b       	acr	r11
8000ba34:	ed be 00 1f 	bld	lr,0x1f
8000ba38:	ef bb 00 1f 	bst	r11,0x1f
8000ba3c:	d8 22       	popm	r4-r7,pc

8000ba3e <__avr32_f64_mul_op1_subnormal>:
8000ba3e:	e4 1b 00 0f 	andh	r11,0xf
8000ba42:	f4 0c 12 00 	clz	r12,r10
8000ba46:	f6 06 12 00 	clz	r6,r11
8000ba4a:	f7 bc 03 e1 	sublo	r12,-31
8000ba4e:	f8 06 17 30 	movlo	r6,r12
8000ba52:	f7 b6 02 01 	subhs	r6,1
8000ba56:	e0 46 00 20 	cp.w	r6,32
8000ba5a:	c0 d4       	brge	8000ba74 <__avr32_f64_mul_op1_subnormal+0x36>
8000ba5c:	ec 0c 11 20 	rsub	r12,r6,32
8000ba60:	f6 06 09 4b 	lsl	r11,r11,r6
8000ba64:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000ba68:	18 4b       	or	r11,r12
8000ba6a:	f4 06 09 4a 	lsl	r10,r10,r6
8000ba6e:	20 b6       	sub	r6,11
8000ba70:	0c 17       	sub	r7,r6
8000ba72:	ca ab       	rjmp	8000b9c6 <__avr32_f64_mul+0x22>
8000ba74:	f4 06 09 4b 	lsl	r11,r10,r6
8000ba78:	c6 40       	breq	8000bb40 <__avr32_f64_mul_res_zero>
8000ba7a:	30 0a       	mov	r10,0
8000ba7c:	20 b6       	sub	r6,11
8000ba7e:	0c 17       	sub	r7,r6
8000ba80:	ca 3b       	rjmp	8000b9c6 <__avr32_f64_mul+0x22>

8000ba82 <__avr32_f64_mul_op2_subnormal>:
8000ba82:	e4 19 00 0f 	andh	r9,0xf
8000ba86:	f0 0c 12 00 	clz	r12,r8
8000ba8a:	f2 05 12 00 	clz	r5,r9
8000ba8e:	f7 bc 03 ea 	sublo	r12,-22
8000ba92:	f8 05 17 30 	movlo	r5,r12
8000ba96:	f7 b5 02 0a 	subhs	r5,10
8000ba9a:	e0 45 00 20 	cp.w	r5,32
8000ba9e:	c0 d4       	brge	8000bab8 <__avr32_f64_mul_op2_subnormal+0x36>
8000baa0:	ea 0c 11 20 	rsub	r12,r5,32
8000baa4:	f2 05 09 49 	lsl	r9,r9,r5
8000baa8:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000baac:	18 49       	or	r9,r12
8000baae:	f0 05 09 48 	lsl	r8,r8,r5
8000bab2:	20 25       	sub	r5,2
8000bab4:	0a 16       	sub	r6,r5
8000bab6:	c8 fb       	rjmp	8000b9d4 <__avr32_f64_mul+0x30>
8000bab8:	f0 05 09 49 	lsl	r9,r8,r5
8000babc:	c4 20       	breq	8000bb40 <__avr32_f64_mul_res_zero>
8000babe:	30 08       	mov	r8,0
8000bac0:	20 25       	sub	r5,2
8000bac2:	0a 16       	sub	r6,r5
8000bac4:	c8 8b       	rjmp	8000b9d4 <__avr32_f64_mul+0x30>

8000bac6 <__avr32_f64_mul_op_nan_or_inf>:
8000bac6:	e4 19 00 0f 	andh	r9,0xf
8000baca:	e4 1b 00 0f 	andh	r11,0xf
8000bace:	14 4b       	or	r11,r10
8000bad0:	10 49       	or	r9,r8
8000bad2:	e0 47 07 ff 	cp.w	r7,2047
8000bad6:	c0 91       	brne	8000bae8 <__avr32_f64_mul_op1_not_naninf>
8000bad8:	58 0b       	cp.w	r11,0
8000bada:	c3 81       	brne	8000bb4a <__avr32_f64_mul_res_nan>
8000badc:	e0 46 07 ff 	cp.w	r6,2047
8000bae0:	c3 81       	brne	8000bb50 <__avr32_f64_mul_res_inf>
8000bae2:	58 09       	cp.w	r9,0
8000bae4:	c3 60       	breq	8000bb50 <__avr32_f64_mul_res_inf>
8000bae6:	c3 28       	rjmp	8000bb4a <__avr32_f64_mul_res_nan>

8000bae8 <__avr32_f64_mul_op1_not_naninf>:
8000bae8:	58 09       	cp.w	r9,0
8000baea:	c3 30       	breq	8000bb50 <__avr32_f64_mul_res_inf>
8000baec:	c2 f8       	rjmp	8000bb4a <__avr32_f64_mul_res_nan>

8000baee <__avr32_f64_mul_res_subnormal>:
8000baee:	5c 3c       	neg	r12
8000baf0:	2f fc       	sub	r12,-1
8000baf2:	f1 bc 04 c0 	satu	r12,0x6
8000baf6:	e0 4c 00 20 	cp.w	r12,32
8000bafa:	c1 14       	brge	8000bb1c <__avr32_f64_mul_res_subnormal+0x2e>
8000bafc:	f8 08 11 20 	rsub	r8,r12,32
8000bb00:	0e 46       	or	r6,r7
8000bb02:	ee 0c 0a 47 	lsr	r7,r7,r12
8000bb06:	f4 08 09 49 	lsl	r9,r10,r8
8000bb0a:	12 47       	or	r7,r9
8000bb0c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bb10:	f6 08 09 49 	lsl	r9,r11,r8
8000bb14:	12 4a       	or	r10,r9
8000bb16:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bb1a:	c8 3b       	rjmp	8000ba20 <__avr32_f64_mul+0x7c>
8000bb1c:	f8 08 11 20 	rsub	r8,r12,32
8000bb20:	f9 b9 00 00 	moveq	r9,0
8000bb24:	c0 30       	breq	8000bb2a <__avr32_f64_mul_res_subnormal+0x3c>
8000bb26:	f6 08 09 49 	lsl	r9,r11,r8
8000bb2a:	0e 46       	or	r6,r7
8000bb2c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000bb30:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bb34:	f3 ea 10 07 	or	r7,r9,r10
8000bb38:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000bb3c:	30 0b       	mov	r11,0
8000bb3e:	c7 1b       	rjmp	8000ba20 <__avr32_f64_mul+0x7c>

8000bb40 <__avr32_f64_mul_res_zero>:
8000bb40:	1c 9b       	mov	r11,lr
8000bb42:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bb46:	30 0a       	mov	r10,0
8000bb48:	d8 22       	popm	r4-r7,pc

8000bb4a <__avr32_f64_mul_res_nan>:
8000bb4a:	3f fb       	mov	r11,-1
8000bb4c:	3f fa       	mov	r10,-1
8000bb4e:	d8 22       	popm	r4-r7,pc

8000bb50 <__avr32_f64_mul_res_inf>:
8000bb50:	f0 6b 00 00 	mov	r11,-1048576
8000bb54:	ed be 00 1f 	bld	lr,0x1f
8000bb58:	ef bb 00 1f 	bst	r11,0x1f
8000bb5c:	30 0a       	mov	r10,0
8000bb5e:	d8 22       	popm	r4-r7,pc

8000bb60 <__avr32_f64_mul_op1_zero>:
8000bb60:	f7 e9 20 0b 	eor	r11,r11,r9
8000bb64:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bb68:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000bb6c:	e0 4c 07 ff 	cp.w	r12,2047
8000bb70:	5e 1c       	retne	r12
8000bb72:	3f fa       	mov	r10,-1
8000bb74:	3f fb       	mov	r11,-1
8000bb76:	5e fc       	retal	r12

8000bb78 <__avr32_f64_sub_from_add>:
8000bb78:	ee 19 80 00 	eorh	r9,0x8000

8000bb7c <__avr32_f64_sub>:
8000bb7c:	f7 e9 20 0c 	eor	r12,r11,r9
8000bb80:	e0 86 00 ca 	brmi	8000bd14 <__avr32_f64_add_from_sub>
8000bb84:	eb cd 40 e0 	pushm	r5-r7,lr
8000bb88:	16 9c       	mov	r12,r11
8000bb8a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bb8e:	bf db       	cbr	r11,0x1f
8000bb90:	bf d9       	cbr	r9,0x1f
8000bb92:	10 3a       	cp.w	r10,r8
8000bb94:	f2 0b 13 00 	cpc	r11,r9
8000bb98:	c0 92       	brcc	8000bbaa <__avr32_f64_sub+0x2e>
8000bb9a:	16 97       	mov	r7,r11
8000bb9c:	12 9b       	mov	r11,r9
8000bb9e:	0e 99       	mov	r9,r7
8000bba0:	14 97       	mov	r7,r10
8000bba2:	10 9a       	mov	r10,r8
8000bba4:	0e 98       	mov	r8,r7
8000bba6:	ee 1c 80 00 	eorh	r12,0x8000
8000bbaa:	f6 07 16 14 	lsr	r7,r11,0x14
8000bbae:	ab 7b       	lsl	r11,0xb
8000bbb0:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bbb4:	ab 7a       	lsl	r10,0xb
8000bbb6:	bf bb       	sbr	r11,0x1f
8000bbb8:	f2 06 16 14 	lsr	r6,r9,0x14
8000bbbc:	c4 40       	breq	8000bc44 <__avr32_f64_sub_opL_subnormal>
8000bbbe:	ab 79       	lsl	r9,0xb
8000bbc0:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bbc4:	ab 78       	lsl	r8,0xb
8000bbc6:	bf b9       	sbr	r9,0x1f

8000bbc8 <__avr32_f64_sub_opL_subnormal_done>:
8000bbc8:	e0 47 07 ff 	cp.w	r7,2047
8000bbcc:	c4 f0       	breq	8000bc6a <__avr32_f64_sub_opH_nan_or_inf>
8000bbce:	0e 26       	rsub	r6,r7
8000bbd0:	c1 20       	breq	8000bbf4 <__avr32_f64_sub_shift_done>
8000bbd2:	ec 05 11 20 	rsub	r5,r6,32
8000bbd6:	e0 46 00 20 	cp.w	r6,32
8000bbda:	c7 c2       	brcc	8000bcd2 <__avr32_f64_sub_longshift>
8000bbdc:	f0 05 09 4e 	lsl	lr,r8,r5
8000bbe0:	f2 05 09 45 	lsl	r5,r9,r5
8000bbe4:	f0 06 0a 48 	lsr	r8,r8,r6
8000bbe8:	f2 06 0a 49 	lsr	r9,r9,r6
8000bbec:	0a 48       	or	r8,r5
8000bbee:	58 0e       	cp.w	lr,0
8000bbf0:	5f 1e       	srne	lr
8000bbf2:	1c 48       	or	r8,lr

8000bbf4 <__avr32_f64_sub_shift_done>:
8000bbf4:	10 1a       	sub	r10,r8
8000bbf6:	f6 09 01 4b 	sbc	r11,r11,r9
8000bbfa:	f6 06 12 00 	clz	r6,r11
8000bbfe:	c0 e0       	breq	8000bc1a <__avr32_f64_sub_longnormalize_done>
8000bc00:	c7 83       	brcs	8000bcf0 <__avr32_f64_sub_longnormalize>
8000bc02:	ec 0e 11 20 	rsub	lr,r6,32
8000bc06:	f6 06 09 4b 	lsl	r11,r11,r6
8000bc0a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bc0e:	1c 4b       	or	r11,lr
8000bc10:	f4 06 09 4a 	lsl	r10,r10,r6
8000bc14:	0c 17       	sub	r7,r6
8000bc16:	e0 8a 00 39 	brle	8000bc88 <__avr32_f64_sub_subnormal_result>

8000bc1a <__avr32_f64_sub_longnormalize_done>:
8000bc1a:	f4 09 15 15 	lsl	r9,r10,0x15
8000bc1e:	ab 9a       	lsr	r10,0xb
8000bc20:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bc24:	ab 9b       	lsr	r11,0xb
8000bc26:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bc2a:	18 4b       	or	r11,r12

8000bc2c <__avr32_f64_sub_round>:
8000bc2c:	fc 17 80 00 	movh	r7,0x8000
8000bc30:	ed ba 00 00 	bld	r10,0x0
8000bc34:	f7 b7 01 ff 	subne	r7,-1
8000bc38:	0e 39       	cp.w	r9,r7
8000bc3a:	5f 29       	srhs	r9
8000bc3c:	12 0a       	add	r10,r9
8000bc3e:	5c 0b       	acr	r11
8000bc40:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc44 <__avr32_f64_sub_opL_subnormal>:
8000bc44:	ab 79       	lsl	r9,0xb
8000bc46:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bc4a:	ab 78       	lsl	r8,0xb
8000bc4c:	f3 e8 10 0e 	or	lr,r9,r8
8000bc50:	f9 b6 01 01 	movne	r6,1
8000bc54:	ee 0e 11 00 	rsub	lr,r7,0
8000bc58:	f9 b7 00 01 	moveq	r7,1
8000bc5c:	ef bb 00 1f 	bst	r11,0x1f
8000bc60:	f7 ea 10 0e 	or	lr,r11,r10
8000bc64:	f9 b7 00 00 	moveq	r7,0
8000bc68:	cb 0b       	rjmp	8000bbc8 <__avr32_f64_sub_opL_subnormal_done>

8000bc6a <__avr32_f64_sub_opH_nan_or_inf>:
8000bc6a:	bf db       	cbr	r11,0x1f
8000bc6c:	f7 ea 10 0e 	or	lr,r11,r10
8000bc70:	c0 81       	brne	8000bc80 <__avr32_f64_sub_return_nan>
8000bc72:	e0 46 07 ff 	cp.w	r6,2047
8000bc76:	c0 50       	breq	8000bc80 <__avr32_f64_sub_return_nan>
8000bc78:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000bc7c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc80 <__avr32_f64_sub_return_nan>:
8000bc80:	3f fa       	mov	r10,-1
8000bc82:	3f fb       	mov	r11,-1
8000bc84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc88 <__avr32_f64_sub_subnormal_result>:
8000bc88:	5c 37       	neg	r7
8000bc8a:	2f f7       	sub	r7,-1
8000bc8c:	f1 b7 04 c0 	satu	r7,0x6
8000bc90:	e0 47 00 20 	cp.w	r7,32
8000bc94:	c1 14       	brge	8000bcb6 <__avr32_f64_sub_subnormal_result+0x2e>
8000bc96:	ee 08 11 20 	rsub	r8,r7,32
8000bc9a:	f4 08 09 49 	lsl	r9,r10,r8
8000bc9e:	5f 16       	srne	r6
8000bca0:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bca4:	0c 4a       	or	r10,r6
8000bca6:	f6 08 09 49 	lsl	r9,r11,r8
8000bcaa:	f5 e9 10 0a 	or	r10,r10,r9
8000bcae:	f4 07 0a 4b 	lsr	r11,r10,r7
8000bcb2:	30 07       	mov	r7,0
8000bcb4:	cb 3b       	rjmp	8000bc1a <__avr32_f64_sub_longnormalize_done>
8000bcb6:	ee 08 11 40 	rsub	r8,r7,64
8000bcba:	f6 08 09 49 	lsl	r9,r11,r8
8000bcbe:	14 49       	or	r9,r10
8000bcc0:	5f 16       	srne	r6
8000bcc2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bcc6:	0c 4a       	or	r10,r6
8000bcc8:	30 0b       	mov	r11,0
8000bcca:	30 07       	mov	r7,0
8000bccc:	ca 7b       	rjmp	8000bc1a <__avr32_f64_sub_longnormalize_done>
8000bcce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bcd2 <__avr32_f64_sub_longshift>:
8000bcd2:	f1 b6 04 c0 	satu	r6,0x6
8000bcd6:	f0 0e 17 00 	moveq	lr,r8
8000bcda:	c0 40       	breq	8000bce2 <__avr32_f64_sub_longshift+0x10>
8000bcdc:	f2 05 09 4e 	lsl	lr,r9,r5
8000bce0:	10 4e       	or	lr,r8
8000bce2:	f2 06 0a 48 	lsr	r8,r9,r6
8000bce6:	30 09       	mov	r9,0
8000bce8:	58 0e       	cp.w	lr,0
8000bcea:	5f 1e       	srne	lr
8000bcec:	1c 48       	or	r8,lr
8000bcee:	c8 3b       	rjmp	8000bbf4 <__avr32_f64_sub_shift_done>

8000bcf0 <__avr32_f64_sub_longnormalize>:
8000bcf0:	f4 06 12 00 	clz	r6,r10
8000bcf4:	f9 b7 03 00 	movlo	r7,0
8000bcf8:	f9 b6 03 00 	movlo	r6,0
8000bcfc:	f9 bc 03 00 	movlo	r12,0
8000bd00:	f7 b6 02 e0 	subhs	r6,-32
8000bd04:	f4 06 09 4b 	lsl	r11,r10,r6
8000bd08:	30 0a       	mov	r10,0
8000bd0a:	0c 17       	sub	r7,r6
8000bd0c:	fe 9a ff be 	brle	8000bc88 <__avr32_f64_sub_subnormal_result>
8000bd10:	c8 5b       	rjmp	8000bc1a <__avr32_f64_sub_longnormalize_done>
8000bd12:	d7 03       	nop

8000bd14 <__avr32_f64_add_from_sub>:
8000bd14:	ee 19 80 00 	eorh	r9,0x8000

8000bd18 <__avr32_f64_add>:
8000bd18:	f7 e9 20 0c 	eor	r12,r11,r9
8000bd1c:	fe 96 ff 2e 	brmi	8000bb78 <__avr32_f64_sub_from_add>
8000bd20:	eb cd 40 e0 	pushm	r5-r7,lr
8000bd24:	16 9c       	mov	r12,r11
8000bd26:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bd2a:	bf db       	cbr	r11,0x1f
8000bd2c:	bf d9       	cbr	r9,0x1f
8000bd2e:	12 3b       	cp.w	r11,r9
8000bd30:	c0 72       	brcc	8000bd3e <__avr32_f64_add+0x26>
8000bd32:	16 97       	mov	r7,r11
8000bd34:	12 9b       	mov	r11,r9
8000bd36:	0e 99       	mov	r9,r7
8000bd38:	14 97       	mov	r7,r10
8000bd3a:	10 9a       	mov	r10,r8
8000bd3c:	0e 98       	mov	r8,r7
8000bd3e:	30 0e       	mov	lr,0
8000bd40:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bd44:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000bd48:	b5 ab       	sbr	r11,0x14
8000bd4a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bd4e:	c6 20       	breq	8000be12 <__avr32_f64_add_op2_subnormal>
8000bd50:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000bd54:	b5 a9       	sbr	r9,0x14
8000bd56:	e0 47 07 ff 	cp.w	r7,2047
8000bd5a:	c2 80       	breq	8000bdaa <__avr32_f64_add_opH_nan_or_inf>
8000bd5c:	0e 26       	rsub	r6,r7
8000bd5e:	c1 20       	breq	8000bd82 <__avr32_f64_add_shift_done>
8000bd60:	e0 46 00 36 	cp.w	r6,54
8000bd64:	c1 52       	brcc	8000bd8e <__avr32_f64_add_res_of_done>
8000bd66:	ec 05 11 20 	rsub	r5,r6,32
8000bd6a:	e0 46 00 20 	cp.w	r6,32
8000bd6e:	c3 52       	brcc	8000bdd8 <__avr32_f64_add_longshift>
8000bd70:	f0 05 09 4e 	lsl	lr,r8,r5
8000bd74:	f2 05 09 45 	lsl	r5,r9,r5
8000bd78:	f0 06 0a 48 	lsr	r8,r8,r6
8000bd7c:	f2 06 0a 49 	lsr	r9,r9,r6
8000bd80:	0a 48       	or	r8,r5

8000bd82 <__avr32_f64_add_shift_done>:
8000bd82:	10 0a       	add	r10,r8
8000bd84:	f6 09 00 4b 	adc	r11,r11,r9
8000bd88:	ed bb 00 15 	bld	r11,0x15
8000bd8c:	c3 40       	breq	8000bdf4 <__avr32_f64_add_res_of>

8000bd8e <__avr32_f64_add_res_of_done>:
8000bd8e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bd92:	18 4b       	or	r11,r12

8000bd94 <__avr32_f64_add_round>:
8000bd94:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000bd98:	18 4e       	or	lr,r12
8000bd9a:	ee 1e 80 00 	eorh	lr,0x8000
8000bd9e:	f1 be 04 20 	satu	lr,0x1
8000bda2:	1c 0a       	add	r10,lr
8000bda4:	5c 0b       	acr	r11
8000bda6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bdaa <__avr32_f64_add_opH_nan_or_inf>:
8000bdaa:	b5 cb       	cbr	r11,0x14
8000bdac:	f7 ea 10 0e 	or	lr,r11,r10
8000bdb0:	c1 01       	brne	8000bdd0 <__avr32_f64_add_return_nan>
8000bdb2:	e0 46 07 ff 	cp.w	r6,2047
8000bdb6:	c0 30       	breq	8000bdbc <__avr32_f64_add_opL_nan_or_inf>
8000bdb8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bdbc <__avr32_f64_add_opL_nan_or_inf>:
8000bdbc:	b5 c9       	cbr	r9,0x14
8000bdbe:	f3 e8 10 0e 	or	lr,r9,r8
8000bdc2:	c0 71       	brne	8000bdd0 <__avr32_f64_add_return_nan>
8000bdc4:	30 0a       	mov	r10,0
8000bdc6:	fc 1b 7f f0 	movh	r11,0x7ff0
8000bdca:	18 4b       	or	r11,r12
8000bdcc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bdd0 <__avr32_f64_add_return_nan>:
8000bdd0:	3f fa       	mov	r10,-1
8000bdd2:	3f fb       	mov	r11,-1
8000bdd4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bdd8 <__avr32_f64_add_longshift>:
8000bdd8:	f1 b6 04 c0 	satu	r6,0x6
8000bddc:	f0 0e 17 00 	moveq	lr,r8
8000bde0:	c0 60       	breq	8000bdec <__avr32_f64_add_longshift+0x14>
8000bde2:	f2 05 09 4e 	lsl	lr,r9,r5
8000bde6:	58 08       	cp.w	r8,0
8000bde8:	5f 18       	srne	r8
8000bdea:	10 4e       	or	lr,r8
8000bdec:	f2 06 0a 48 	lsr	r8,r9,r6
8000bdf0:	30 09       	mov	r9,0
8000bdf2:	cc 8b       	rjmp	8000bd82 <__avr32_f64_add_shift_done>

8000bdf4 <__avr32_f64_add_res_of>:
8000bdf4:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000bdf8:	a1 9b       	lsr	r11,0x1
8000bdfa:	5d 0a       	ror	r10
8000bdfc:	5d 0e       	ror	lr
8000bdfe:	2f f7       	sub	r7,-1
8000be00:	e0 47 07 ff 	cp.w	r7,2047
8000be04:	f9 ba 00 00 	moveq	r10,0
8000be08:	f9 bb 00 00 	moveq	r11,0
8000be0c:	f9 be 00 00 	moveq	lr,0
8000be10:	cb fb       	rjmp	8000bd8e <__avr32_f64_add_res_of_done>

8000be12 <__avr32_f64_add_op2_subnormal>:
8000be12:	30 16       	mov	r6,1
8000be14:	58 07       	cp.w	r7,0
8000be16:	ca 01       	brne	8000bd56 <__avr32_f64_add+0x3e>
8000be18:	b5 cb       	cbr	r11,0x14
8000be1a:	10 0a       	add	r10,r8
8000be1c:	f6 09 00 4b 	adc	r11,r11,r9
8000be20:	18 4b       	or	r11,r12
8000be22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000be26:	d7 03       	nop

8000be28 <__avr32_f64_to_u32>:
8000be28:	58 0b       	cp.w	r11,0
8000be2a:	5e 6d       	retmi	0

8000be2c <__avr32_f64_to_s32>:
8000be2c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000be30:	b5 9c       	lsr	r12,0x15
8000be32:	e0 2c 03 ff 	sub	r12,1023
8000be36:	5e 3d       	retlo	0
8000be38:	f8 0c 11 1f 	rsub	r12,r12,31
8000be3c:	16 99       	mov	r9,r11
8000be3e:	ab 7b       	lsl	r11,0xb
8000be40:	bf bb       	sbr	r11,0x1f
8000be42:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000be46:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000be4a:	a1 79       	lsl	r9,0x1
8000be4c:	5e 2b       	reths	r11
8000be4e:	5c 3b       	neg	r11
8000be50:	5e fb       	retal	r11

8000be52 <__avr32_u32_to_f64>:
8000be52:	f8 cb 00 00 	sub	r11,r12,0
8000be56:	30 0c       	mov	r12,0
8000be58:	c0 38       	rjmp	8000be5e <__avr32_s32_to_f64+0x4>

8000be5a <__avr32_s32_to_f64>:
8000be5a:	18 9b       	mov	r11,r12
8000be5c:	5c 4b       	abs	r11
8000be5e:	30 0a       	mov	r10,0
8000be60:	5e 0b       	reteq	r11
8000be62:	d4 01       	pushm	lr
8000be64:	e0 69 04 1e 	mov	r9,1054
8000be68:	f6 08 12 00 	clz	r8,r11
8000be6c:	c1 70       	breq	8000be9a <__avr32_s32_to_f64+0x40>
8000be6e:	c0 c3       	brcs	8000be86 <__avr32_s32_to_f64+0x2c>
8000be70:	f0 0e 11 20 	rsub	lr,r8,32
8000be74:	f6 08 09 4b 	lsl	r11,r11,r8
8000be78:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000be7c:	1c 4b       	or	r11,lr
8000be7e:	f4 08 09 4a 	lsl	r10,r10,r8
8000be82:	10 19       	sub	r9,r8
8000be84:	c0 b8       	rjmp	8000be9a <__avr32_s32_to_f64+0x40>
8000be86:	f4 08 12 00 	clz	r8,r10
8000be8a:	f9 b8 03 00 	movlo	r8,0
8000be8e:	f7 b8 02 e0 	subhs	r8,-32
8000be92:	f4 08 09 4b 	lsl	r11,r10,r8
8000be96:	30 0a       	mov	r10,0
8000be98:	10 19       	sub	r9,r8
8000be9a:	58 09       	cp.w	r9,0
8000be9c:	e0 89 00 30 	brgt	8000befc <__avr32_s32_to_f64+0xa2>
8000bea0:	5c 39       	neg	r9
8000bea2:	2f f9       	sub	r9,-1
8000bea4:	e0 49 00 36 	cp.w	r9,54
8000bea8:	c0 43       	brcs	8000beb0 <__avr32_s32_to_f64+0x56>
8000beaa:	30 0b       	mov	r11,0
8000beac:	30 0a       	mov	r10,0
8000beae:	c2 68       	rjmp	8000befa <__avr32_s32_to_f64+0xa0>
8000beb0:	2f 69       	sub	r9,-10
8000beb2:	f2 08 11 20 	rsub	r8,r9,32
8000beb6:	e0 49 00 20 	cp.w	r9,32
8000beba:	c0 b2       	brcc	8000bed0 <__avr32_s32_to_f64+0x76>
8000bebc:	f4 08 09 4e 	lsl	lr,r10,r8
8000bec0:	f6 08 09 48 	lsl	r8,r11,r8
8000bec4:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bec8:	f6 09 0a 4b 	lsr	r11,r11,r9
8000becc:	10 4b       	or	r11,r8
8000bece:	c0 88       	rjmp	8000bede <__avr32_s32_to_f64+0x84>
8000bed0:	f6 08 09 4e 	lsl	lr,r11,r8
8000bed4:	14 4e       	or	lr,r10
8000bed6:	16 9a       	mov	r10,r11
8000bed8:	30 0b       	mov	r11,0
8000beda:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bede:	ed ba 00 00 	bld	r10,0x0
8000bee2:	c0 92       	brcc	8000bef4 <__avr32_s32_to_f64+0x9a>
8000bee4:	1c 7e       	tst	lr,lr
8000bee6:	c0 41       	brne	8000beee <__avr32_s32_to_f64+0x94>
8000bee8:	ed ba 00 01 	bld	r10,0x1
8000beec:	c0 42       	brcc	8000bef4 <__avr32_s32_to_f64+0x9a>
8000beee:	2f fa       	sub	r10,-1
8000bef0:	f7 bb 02 ff 	subhs	r11,-1
8000bef4:	5c fc       	rol	r12
8000bef6:	5d 0b       	ror	r11
8000bef8:	5d 0a       	ror	r10
8000befa:	d8 02       	popm	pc
8000befc:	e0 68 03 ff 	mov	r8,1023
8000bf00:	ed ba 00 0b 	bld	r10,0xb
8000bf04:	f7 b8 00 ff 	subeq	r8,-1
8000bf08:	10 0a       	add	r10,r8
8000bf0a:	5c 0b       	acr	r11
8000bf0c:	f7 b9 03 fe 	sublo	r9,-2
8000bf10:	e0 49 07 ff 	cp.w	r9,2047
8000bf14:	c0 55       	brlt	8000bf1e <__avr32_s32_to_f64+0xc4>
8000bf16:	30 0a       	mov	r10,0
8000bf18:	fc 1b ff e0 	movh	r11,0xffe0
8000bf1c:	c0 c8       	rjmp	8000bf34 <__floatsidf_return_op1>
8000bf1e:	ed bb 00 1f 	bld	r11,0x1f
8000bf22:	f7 b9 01 01 	subne	r9,1
8000bf26:	ab 9a       	lsr	r10,0xb
8000bf28:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bf2c:	a1 7b       	lsl	r11,0x1
8000bf2e:	ab 9b       	lsr	r11,0xb
8000bf30:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000bf34 <__floatsidf_return_op1>:
8000bf34:	a1 7c       	lsl	r12,0x1
8000bf36:	5d 0b       	ror	r11
8000bf38:	d8 02       	popm	pc

8000bf3a <__avr32_f64_cmp_eq>:
8000bf3a:	10 3a       	cp.w	r10,r8
8000bf3c:	f2 0b 13 00 	cpc	r11,r9
8000bf40:	c0 80       	breq	8000bf50 <__avr32_f64_cmp_eq+0x16>
8000bf42:	a1 7b       	lsl	r11,0x1
8000bf44:	a1 79       	lsl	r9,0x1
8000bf46:	14 4b       	or	r11,r10
8000bf48:	12 4b       	or	r11,r9
8000bf4a:	10 4b       	or	r11,r8
8000bf4c:	5e 0f       	reteq	1
8000bf4e:	5e fd       	retal	0
8000bf50:	a1 7b       	lsl	r11,0x1
8000bf52:	fc 1c ff e0 	movh	r12,0xffe0
8000bf56:	58 0a       	cp.w	r10,0
8000bf58:	f8 0b 13 00 	cpc	r11,r12
8000bf5c:	5e 8f       	retls	1
8000bf5e:	5e fd       	retal	0

8000bf60 <__avr32_f64_cmp_ge>:
8000bf60:	1a de       	st.w	--sp,lr
8000bf62:	1a d7       	st.w	--sp,r7
8000bf64:	a1 7b       	lsl	r11,0x1
8000bf66:	5f 3c       	srlo	r12
8000bf68:	a1 79       	lsl	r9,0x1
8000bf6a:	5f 37       	srlo	r7
8000bf6c:	5c fc       	rol	r12
8000bf6e:	fc 1e ff e0 	movh	lr,0xffe0
8000bf72:	58 0a       	cp.w	r10,0
8000bf74:	fc 0b 13 00 	cpc	r11,lr
8000bf78:	e0 8b 00 1d 	brhi	8000bfb2 <__avr32_f64_cmp_ge+0x52>
8000bf7c:	58 08       	cp.w	r8,0
8000bf7e:	fc 09 13 00 	cpc	r9,lr
8000bf82:	e0 8b 00 18 	brhi	8000bfb2 <__avr32_f64_cmp_ge+0x52>
8000bf86:	58 0b       	cp.w	r11,0
8000bf88:	f5 ba 00 00 	subfeq	r10,0
8000bf8c:	c1 50       	breq	8000bfb6 <__avr32_f64_cmp_ge+0x56>
8000bf8e:	1b 07       	ld.w	r7,sp++
8000bf90:	1b 0e       	ld.w	lr,sp++
8000bf92:	58 3c       	cp.w	r12,3
8000bf94:	c0 a0       	breq	8000bfa8 <__avr32_f64_cmp_ge+0x48>
8000bf96:	58 1c       	cp.w	r12,1
8000bf98:	c0 33       	brcs	8000bf9e <__avr32_f64_cmp_ge+0x3e>
8000bf9a:	5e 0f       	reteq	1
8000bf9c:	5e 1d       	retne	0
8000bf9e:	10 3a       	cp.w	r10,r8
8000bfa0:	f2 0b 13 00 	cpc	r11,r9
8000bfa4:	5e 2f       	reths	1
8000bfa6:	5e 3d       	retlo	0
8000bfa8:	14 38       	cp.w	r8,r10
8000bfaa:	f6 09 13 00 	cpc	r9,r11
8000bfae:	5e 2f       	reths	1
8000bfb0:	5e 3d       	retlo	0
8000bfb2:	1b 07       	ld.w	r7,sp++
8000bfb4:	d8 0a       	popm	pc,r12=0
8000bfb6:	58 17       	cp.w	r7,1
8000bfb8:	5f 0c       	sreq	r12
8000bfba:	58 09       	cp.w	r9,0
8000bfbc:	f5 b8 00 00 	subfeq	r8,0
8000bfc0:	1b 07       	ld.w	r7,sp++
8000bfc2:	1b 0e       	ld.w	lr,sp++
8000bfc4:	5e 0f       	reteq	1
8000bfc6:	5e fc       	retal	r12

8000bfc8 <__avr32_f64_cmp_lt>:
8000bfc8:	1a de       	st.w	--sp,lr
8000bfca:	1a d7       	st.w	--sp,r7
8000bfcc:	a1 7b       	lsl	r11,0x1
8000bfce:	5f 3c       	srlo	r12
8000bfd0:	a1 79       	lsl	r9,0x1
8000bfd2:	5f 37       	srlo	r7
8000bfd4:	5c fc       	rol	r12
8000bfd6:	fc 1e ff e0 	movh	lr,0xffe0
8000bfda:	58 0a       	cp.w	r10,0
8000bfdc:	fc 0b 13 00 	cpc	r11,lr
8000bfe0:	e0 8b 00 1d 	brhi	8000c01a <__avr32_f64_cmp_lt+0x52>
8000bfe4:	58 08       	cp.w	r8,0
8000bfe6:	fc 09 13 00 	cpc	r9,lr
8000bfea:	e0 8b 00 18 	brhi	8000c01a <__avr32_f64_cmp_lt+0x52>
8000bfee:	58 0b       	cp.w	r11,0
8000bff0:	f5 ba 00 00 	subfeq	r10,0
8000bff4:	c1 50       	breq	8000c01e <__avr32_f64_cmp_lt+0x56>
8000bff6:	1b 07       	ld.w	r7,sp++
8000bff8:	1b 0e       	ld.w	lr,sp++
8000bffa:	58 3c       	cp.w	r12,3
8000bffc:	c0 a0       	breq	8000c010 <__avr32_f64_cmp_lt+0x48>
8000bffe:	58 1c       	cp.w	r12,1
8000c000:	c0 33       	brcs	8000c006 <__avr32_f64_cmp_lt+0x3e>
8000c002:	5e 0d       	reteq	0
8000c004:	5e 1f       	retne	1
8000c006:	10 3a       	cp.w	r10,r8
8000c008:	f2 0b 13 00 	cpc	r11,r9
8000c00c:	5e 2d       	reths	0
8000c00e:	5e 3f       	retlo	1
8000c010:	14 38       	cp.w	r8,r10
8000c012:	f6 09 13 00 	cpc	r9,r11
8000c016:	5e 2d       	reths	0
8000c018:	5e 3f       	retlo	1
8000c01a:	1b 07       	ld.w	r7,sp++
8000c01c:	d8 0a       	popm	pc,r12=0
8000c01e:	58 17       	cp.w	r7,1
8000c020:	5f 1c       	srne	r12
8000c022:	58 09       	cp.w	r9,0
8000c024:	f5 b8 00 00 	subfeq	r8,0
8000c028:	1b 07       	ld.w	r7,sp++
8000c02a:	1b 0e       	ld.w	lr,sp++
8000c02c:	5e 0d       	reteq	0
8000c02e:	5e fc       	retal	r12

8000c030 <__avr32_f64_div>:
8000c030:	eb cd 40 ff 	pushm	r0-r7,lr
8000c034:	f7 e9 20 0e 	eor	lr,r11,r9
8000c038:	f6 07 16 14 	lsr	r7,r11,0x14
8000c03c:	a9 7b       	lsl	r11,0x9
8000c03e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c042:	a9 7a       	lsl	r10,0x9
8000c044:	bd bb       	sbr	r11,0x1d
8000c046:	e4 1b 3f ff 	andh	r11,0x3fff
8000c04a:	ab d7       	cbr	r7,0xb
8000c04c:	e0 80 00 cc 	breq	8000c1e4 <__avr32_f64_div_round_subnormal+0x54>
8000c050:	e0 47 07 ff 	cp.w	r7,2047
8000c054:	e0 84 00 b5 	brge	8000c1be <__avr32_f64_div_round_subnormal+0x2e>
8000c058:	f2 06 16 14 	lsr	r6,r9,0x14
8000c05c:	a9 79       	lsl	r9,0x9
8000c05e:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c062:	a9 78       	lsl	r8,0x9
8000c064:	bd b9       	sbr	r9,0x1d
8000c066:	e4 19 3f ff 	andh	r9,0x3fff
8000c06a:	ab d6       	cbr	r6,0xb
8000c06c:	e0 80 00 e2 	breq	8000c230 <__avr32_f64_div_round_subnormal+0xa0>
8000c070:	e0 46 07 ff 	cp.w	r6,2047
8000c074:	e0 84 00 b2 	brge	8000c1d8 <__avr32_f64_div_round_subnormal+0x48>
8000c078:	0c 17       	sub	r7,r6
8000c07a:	fe 37 fc 01 	sub	r7,-1023
8000c07e:	fc 1c 80 00 	movh	r12,0x8000
8000c082:	f8 03 16 01 	lsr	r3,r12,0x1
8000c086:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c08a:	5c d4       	com	r4
8000c08c:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c090:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c094:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c098:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c09c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c0a0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c0a4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c0a8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c0ac:	ea 03 15 02 	lsl	r3,r5,0x2
8000c0b0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c0b4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c0b8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c0bc:	ea 03 15 02 	lsl	r3,r5,0x2
8000c0c0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c0c4:	e4 09 07 40 	macu.d	r0,r2,r9
8000c0c8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c0cc:	02 04       	add	r4,r1
8000c0ce:	5c 05       	acr	r5
8000c0d0:	a3 65       	lsl	r5,0x2
8000c0d2:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c0d6:	a3 64       	lsl	r4,0x2
8000c0d8:	5c 34       	neg	r4
8000c0da:	f8 05 01 45 	sbc	r5,r12,r5
8000c0de:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c0e2:	e4 05 07 40 	macu.d	r0,r2,r5
8000c0e6:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c0ea:	02 04       	add	r4,r1
8000c0ec:	5c 05       	acr	r5
8000c0ee:	ea 03 15 02 	lsl	r3,r5,0x2
8000c0f2:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c0f6:	e8 02 15 02 	lsl	r2,r4,0x2
8000c0fa:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c0fe:	e4 09 07 40 	macu.d	r0,r2,r9
8000c102:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c106:	02 04       	add	r4,r1
8000c108:	5c 05       	acr	r5
8000c10a:	a3 65       	lsl	r5,0x2
8000c10c:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c110:	a3 64       	lsl	r4,0x2
8000c112:	5c 34       	neg	r4
8000c114:	f8 05 01 45 	sbc	r5,r12,r5
8000c118:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c11c:	e4 05 07 40 	macu.d	r0,r2,r5
8000c120:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c124:	02 04       	add	r4,r1
8000c126:	5c 05       	acr	r5
8000c128:	ea 03 15 02 	lsl	r3,r5,0x2
8000c12c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c130:	e8 02 15 02 	lsl	r2,r4,0x2
8000c134:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c138:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c13c:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c140:	02 02       	add	r2,r1
8000c142:	5c 03       	acr	r3
8000c144:	ed b3 00 1c 	bld	r3,0x1c
8000c148:	c0 90       	breq	8000c15a <__avr32_f64_div+0x12a>
8000c14a:	a1 72       	lsl	r2,0x1
8000c14c:	5c f3       	rol	r3
8000c14e:	20 17       	sub	r7,1
8000c150:	a3 9a       	lsr	r10,0x3
8000c152:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c156:	a3 9b       	lsr	r11,0x3
8000c158:	c0 58       	rjmp	8000c162 <__avr32_f64_div+0x132>
8000c15a:	a5 8a       	lsr	r10,0x4
8000c15c:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c160:	a5 8b       	lsr	r11,0x4
8000c162:	58 07       	cp.w	r7,0
8000c164:	e0 8a 00 8b 	brle	8000c27a <__avr32_f64_div_res_subnormal>
8000c168:	e0 12 ff 00 	andl	r2,0xff00
8000c16c:	e8 12 00 80 	orl	r2,0x80
8000c170:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c174:	e4 09 07 40 	macu.d	r0,r2,r9
8000c178:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c17c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c180:	00 05       	add	r5,r0
8000c182:	f0 01 00 48 	adc	r8,r8,r1
8000c186:	5c 09       	acr	r9
8000c188:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c18c:	58 04       	cp.w	r4,0
8000c18e:	5c 25       	cpc	r5

8000c190 <__avr32_f64_div_round_subnormal>:
8000c190:	f4 08 13 00 	cpc	r8,r10
8000c194:	f6 09 13 00 	cpc	r9,r11
8000c198:	5f 36       	srlo	r6
8000c19a:	f8 06 17 00 	moveq	r6,r12
8000c19e:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c1a2:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c1a6:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c1aa:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c1ae:	ed be 00 1f 	bld	lr,0x1f
8000c1b2:	ef bb 00 1f 	bst	r11,0x1f
8000c1b6:	0c 0a       	add	r10,r6
8000c1b8:	5c 0b       	acr	r11
8000c1ba:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c1be:	e4 1b 00 0f 	andh	r11,0xf
8000c1c2:	14 4b       	or	r11,r10
8000c1c4:	e0 81 00 a7 	brne	8000c312 <__avr32_f64_div_res_subnormal+0x98>
8000c1c8:	f2 06 16 14 	lsr	r6,r9,0x14
8000c1cc:	ab d6       	cbr	r6,0xb
8000c1ce:	e0 46 07 ff 	cp.w	r6,2047
8000c1d2:	e0 81 00 a4 	brne	8000c31a <__avr32_f64_div_res_subnormal+0xa0>
8000c1d6:	c9 e8       	rjmp	8000c312 <__avr32_f64_div_res_subnormal+0x98>
8000c1d8:	e4 19 00 0f 	andh	r9,0xf
8000c1dc:	10 49       	or	r9,r8
8000c1de:	e0 81 00 9a 	brne	8000c312 <__avr32_f64_div_res_subnormal+0x98>
8000c1e2:	c9 28       	rjmp	8000c306 <__avr32_f64_div_res_subnormal+0x8c>
8000c1e4:	a3 7b       	lsl	r11,0x3
8000c1e6:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c1ea:	a3 7a       	lsl	r10,0x3
8000c1ec:	f5 eb 10 04 	or	r4,r10,r11
8000c1f0:	e0 80 00 a0 	breq	8000c330 <__avr32_f64_div_op1_zero>
8000c1f4:	f6 04 12 00 	clz	r4,r11
8000c1f8:	c1 70       	breq	8000c226 <__avr32_f64_div_round_subnormal+0x96>
8000c1fa:	c0 c3       	brcs	8000c212 <__avr32_f64_div_round_subnormal+0x82>
8000c1fc:	e8 05 11 20 	rsub	r5,r4,32
8000c200:	f6 04 09 4b 	lsl	r11,r11,r4
8000c204:	f4 05 0a 45 	lsr	r5,r10,r5
8000c208:	0a 4b       	or	r11,r5
8000c20a:	f4 04 09 4a 	lsl	r10,r10,r4
8000c20e:	08 17       	sub	r7,r4
8000c210:	c0 b8       	rjmp	8000c226 <__avr32_f64_div_round_subnormal+0x96>
8000c212:	f4 04 12 00 	clz	r4,r10
8000c216:	f9 b4 03 00 	movlo	r4,0
8000c21a:	f7 b4 02 e0 	subhs	r4,-32
8000c21e:	f4 04 09 4b 	lsl	r11,r10,r4
8000c222:	30 0a       	mov	r10,0
8000c224:	08 17       	sub	r7,r4
8000c226:	a3 8a       	lsr	r10,0x2
8000c228:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c22c:	a3 8b       	lsr	r11,0x2
8000c22e:	c1 1b       	rjmp	8000c050 <__avr32_f64_div+0x20>
8000c230:	a3 79       	lsl	r9,0x3
8000c232:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c236:	a3 78       	lsl	r8,0x3
8000c238:	f3 e8 10 04 	or	r4,r9,r8
8000c23c:	c6 f0       	breq	8000c31a <__avr32_f64_div_res_subnormal+0xa0>
8000c23e:	f2 04 12 00 	clz	r4,r9
8000c242:	c1 70       	breq	8000c270 <__avr32_f64_div_round_subnormal+0xe0>
8000c244:	c0 c3       	brcs	8000c25c <__avr32_f64_div_round_subnormal+0xcc>
8000c246:	e8 05 11 20 	rsub	r5,r4,32
8000c24a:	f2 04 09 49 	lsl	r9,r9,r4
8000c24e:	f0 05 0a 45 	lsr	r5,r8,r5
8000c252:	0a 49       	or	r9,r5
8000c254:	f0 04 09 48 	lsl	r8,r8,r4
8000c258:	08 16       	sub	r6,r4
8000c25a:	c0 b8       	rjmp	8000c270 <__avr32_f64_div_round_subnormal+0xe0>
8000c25c:	f0 04 12 00 	clz	r4,r8
8000c260:	f9 b4 03 00 	movlo	r4,0
8000c264:	f7 b4 02 e0 	subhs	r4,-32
8000c268:	f0 04 09 49 	lsl	r9,r8,r4
8000c26c:	30 08       	mov	r8,0
8000c26e:	08 16       	sub	r6,r4
8000c270:	a3 88       	lsr	r8,0x2
8000c272:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c276:	a3 89       	lsr	r9,0x2
8000c278:	cf ca       	rjmp	8000c070 <__avr32_f64_div+0x40>

8000c27a <__avr32_f64_div_res_subnormal>:
8000c27a:	5c 37       	neg	r7
8000c27c:	2f f7       	sub	r7,-1
8000c27e:	f1 b7 04 c0 	satu	r7,0x6
8000c282:	e0 47 00 20 	cp.w	r7,32
8000c286:	c1 54       	brge	8000c2b0 <__avr32_f64_div_res_subnormal+0x36>
8000c288:	ee 06 11 20 	rsub	r6,r7,32
8000c28c:	e4 07 0a 42 	lsr	r2,r2,r7
8000c290:	e6 06 09 4c 	lsl	r12,r3,r6
8000c294:	18 42       	or	r2,r12
8000c296:	e6 07 0a 43 	lsr	r3,r3,r7
8000c29a:	f4 06 09 41 	lsl	r1,r10,r6
8000c29e:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c2a2:	f6 06 09 4c 	lsl	r12,r11,r6
8000c2a6:	18 4a       	or	r10,r12
8000c2a8:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c2ac:	30 00       	mov	r0,0
8000c2ae:	c1 58       	rjmp	8000c2d8 <__avr32_f64_div_res_subnormal+0x5e>
8000c2b0:	ee 06 11 20 	rsub	r6,r7,32
8000c2b4:	f9 b0 00 00 	moveq	r0,0
8000c2b8:	f9 bc 00 00 	moveq	r12,0
8000c2bc:	c0 50       	breq	8000c2c6 <__avr32_f64_div_res_subnormal+0x4c>
8000c2be:	f4 06 09 40 	lsl	r0,r10,r6
8000c2c2:	f6 06 09 4c 	lsl	r12,r11,r6
8000c2c6:	e6 07 0a 42 	lsr	r2,r3,r7
8000c2ca:	30 03       	mov	r3,0
8000c2cc:	f4 07 0a 41 	lsr	r1,r10,r7
8000c2d0:	18 41       	or	r1,r12
8000c2d2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c2d6:	30 0b       	mov	r11,0
8000c2d8:	e0 12 ff 00 	andl	r2,0xff00
8000c2dc:	e8 12 00 80 	orl	r2,0x80
8000c2e0:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c2e4:	e4 09 07 46 	macu.d	r6,r2,r9
8000c2e8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c2ec:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c2f0:	0c 05       	add	r5,r6
8000c2f2:	f0 07 00 48 	adc	r8,r8,r7
8000c2f6:	5c 09       	acr	r9
8000c2f8:	30 07       	mov	r7,0
8000c2fa:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c2fe:	00 34       	cp.w	r4,r0
8000c300:	e2 05 13 00 	cpc	r5,r1
8000c304:	c4 6b       	rjmp	8000c190 <__avr32_f64_div_round_subnormal>
8000c306:	1c 9b       	mov	r11,lr
8000c308:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c30c:	30 0a       	mov	r10,0
8000c30e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c312:	3f fb       	mov	r11,-1
8000c314:	30 0a       	mov	r10,0
8000c316:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c31a:	f5 eb 10 04 	or	r4,r10,r11
8000c31e:	c0 90       	breq	8000c330 <__avr32_f64_div_op1_zero>
8000c320:	1c 9b       	mov	r11,lr
8000c322:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c326:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c32a:	30 0a       	mov	r10,0
8000c32c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c330 <__avr32_f64_div_op1_zero>:
8000c330:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c334:	ce f0       	breq	8000c312 <__avr32_f64_div_res_subnormal+0x98>
8000c336:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c33a:	e0 44 07 ff 	cp.w	r4,2047
8000c33e:	ce 41       	brne	8000c306 <__avr32_f64_div_res_subnormal+0x8c>
8000c340:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c344:	ce 10       	breq	8000c306 <__avr32_f64_div_res_subnormal+0x8c>
8000c346:	ce 6b       	rjmp	8000c312 <__avr32_f64_div_res_subnormal+0x98>

8000c348 <__avr32_umod64>:
8000c348:	d4 31       	pushm	r0-r7,lr
8000c34a:	1a 97       	mov	r7,sp
8000c34c:	20 3d       	sub	sp,12
8000c34e:	10 9c       	mov	r12,r8
8000c350:	12 95       	mov	r5,r9
8000c352:	14 9e       	mov	lr,r10
8000c354:	16 91       	mov	r1,r11
8000c356:	16 96       	mov	r6,r11
8000c358:	58 09       	cp.w	r9,0
8000c35a:	e0 81 00 81 	brne	8000c45c <__avr32_umod64+0x114>
8000c35e:	16 38       	cp.w	r8,r11
8000c360:	e0 88 00 12 	brls	8000c384 <__avr32_umod64+0x3c>
8000c364:	f0 08 12 00 	clz	r8,r8
8000c368:	c4 e0       	breq	8000c404 <__avr32_umod64+0xbc>
8000c36a:	f6 08 09 46 	lsl	r6,r11,r8
8000c36e:	f8 08 09 4c 	lsl	r12,r12,r8
8000c372:	f0 0b 11 20 	rsub	r11,r8,32
8000c376:	f4 08 09 4e 	lsl	lr,r10,r8
8000c37a:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c37e:	f7 e6 10 06 	or	r6,r11,r6
8000c382:	c4 18       	rjmp	8000c404 <__avr32_umod64+0xbc>
8000c384:	58 08       	cp.w	r8,0
8000c386:	c0 51       	brne	8000c390 <__avr32_umod64+0x48>
8000c388:	30 19       	mov	r9,1
8000c38a:	f2 08 0d 08 	divu	r8,r9,r8
8000c38e:	10 9c       	mov	r12,r8
8000c390:	f8 08 12 00 	clz	r8,r12
8000c394:	c0 31       	brne	8000c39a <__avr32_umod64+0x52>
8000c396:	18 16       	sub	r6,r12
8000c398:	c3 68       	rjmp	8000c404 <__avr32_umod64+0xbc>
8000c39a:	f0 03 11 20 	rsub	r3,r8,32
8000c39e:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c3a2:	f8 08 09 4c 	lsl	r12,r12,r8
8000c3a6:	ec 08 09 49 	lsl	r9,r6,r8
8000c3aa:	ec 03 0a 43 	lsr	r3,r6,r3
8000c3ae:	f7 e9 10 09 	or	r9,r11,r9
8000c3b2:	f8 05 16 10 	lsr	r5,r12,0x10
8000c3b6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c3ba:	e6 05 0d 02 	divu	r2,r3,r5
8000c3be:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c3c2:	ec 02 02 4b 	mul	r11,r6,r2
8000c3c6:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c3ca:	16 3e       	cp.w	lr,r11
8000c3cc:	c0 72       	brcc	8000c3da <__avr32_umod64+0x92>
8000c3ce:	18 0e       	add	lr,r12
8000c3d0:	18 3e       	cp.w	lr,r12
8000c3d2:	c0 43       	brcs	8000c3da <__avr32_umod64+0x92>
8000c3d4:	16 3e       	cp.w	lr,r11
8000c3d6:	fd dc e3 0e 	addcs	lr,lr,r12
8000c3da:	fc 0b 01 03 	sub	r3,lr,r11
8000c3de:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c3e2:	e6 05 0d 02 	divu	r2,r3,r5
8000c3e6:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c3ea:	a5 36       	mul	r6,r2
8000c3ec:	0c 39       	cp.w	r9,r6
8000c3ee:	c0 72       	brcc	8000c3fc <__avr32_umod64+0xb4>
8000c3f0:	18 09       	add	r9,r12
8000c3f2:	18 39       	cp.w	r9,r12
8000c3f4:	c0 43       	brcs	8000c3fc <__avr32_umod64+0xb4>
8000c3f6:	0c 39       	cp.w	r9,r6
8000c3f8:	f3 dc e3 09 	addcs	r9,r9,r12
8000c3fc:	f2 06 01 06 	sub	r6,r9,r6
8000c400:	f4 08 09 4e 	lsl	lr,r10,r8
8000c404:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c408:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c40c:	ec 0a 0d 02 	divu	r2,r6,r10
8000c410:	fc 09 16 10 	lsr	r9,lr,0x10
8000c414:	ea 02 02 4b 	mul	r11,r5,r2
8000c418:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c41c:	16 39       	cp.w	r9,r11
8000c41e:	c0 72       	brcc	8000c42c <__avr32_umod64+0xe4>
8000c420:	18 09       	add	r9,r12
8000c422:	18 39       	cp.w	r9,r12
8000c424:	c0 43       	brcs	8000c42c <__avr32_umod64+0xe4>
8000c426:	16 39       	cp.w	r9,r11
8000c428:	f3 dc e3 09 	addcs	r9,r9,r12
8000c42c:	f2 0b 01 0b 	sub	r11,r9,r11
8000c430:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c434:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c438:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c43c:	ea 0a 02 4a 	mul	r10,r5,r10
8000c440:	14 3e       	cp.w	lr,r10
8000c442:	c0 72       	brcc	8000c450 <__avr32_umod64+0x108>
8000c444:	18 0e       	add	lr,r12
8000c446:	18 3e       	cp.w	lr,r12
8000c448:	c0 43       	brcs	8000c450 <__avr32_umod64+0x108>
8000c44a:	14 3e       	cp.w	lr,r10
8000c44c:	fd dc e3 0e 	addcs	lr,lr,r12
8000c450:	fc 0a 01 0a 	sub	r10,lr,r10
8000c454:	30 0b       	mov	r11,0
8000c456:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c45a:	c7 b8       	rjmp	8000c550 <__avr32_umod64+0x208>
8000c45c:	16 39       	cp.w	r9,r11
8000c45e:	e0 8b 00 79 	brhi	8000c550 <__avr32_umod64+0x208>
8000c462:	f2 09 12 00 	clz	r9,r9
8000c466:	c1 21       	brne	8000c48a <__avr32_umod64+0x142>
8000c468:	10 3a       	cp.w	r10,r8
8000c46a:	5f 2b       	srhs	r11
8000c46c:	0a 31       	cp.w	r1,r5
8000c46e:	5f ba       	srhi	r10
8000c470:	f7 ea 10 0a 	or	r10,r11,r10
8000c474:	f2 0a 18 00 	cp.b	r10,r9
8000c478:	c0 60       	breq	8000c484 <__avr32_umod64+0x13c>
8000c47a:	fc 08 01 0c 	sub	r12,lr,r8
8000c47e:	e2 05 01 46 	sbc	r6,r1,r5
8000c482:	18 9e       	mov	lr,r12
8000c484:	0c 9b       	mov	r11,r6
8000c486:	1c 9a       	mov	r10,lr
8000c488:	c6 48       	rjmp	8000c550 <__avr32_umod64+0x208>
8000c48a:	ea 09 09 4c 	lsl	r12,r5,r9
8000c48e:	f2 06 11 20 	rsub	r6,r9,32
8000c492:	f6 09 09 4b 	lsl	r11,r11,r9
8000c496:	f0 09 09 42 	lsl	r2,r8,r9
8000c49a:	ef 46 ff f4 	st.w	r7[-12],r6
8000c49e:	f0 06 0a 48 	lsr	r8,r8,r6
8000c4a2:	18 48       	or	r8,r12
8000c4a4:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c4a8:	f4 09 09 43 	lsl	r3,r10,r9
8000c4ac:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c4b0:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c4b4:	16 4a       	or	r10,r11
8000c4b6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c4ba:	f8 0b 0d 04 	divu	r4,r12,r11
8000c4be:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c4c2:	08 91       	mov	r1,r4
8000c4c4:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c4c8:	e8 0e 02 46 	mul	r6,r4,lr
8000c4cc:	0c 3c       	cp.w	r12,r6
8000c4ce:	c0 a2       	brcc	8000c4e2 <__avr32_umod64+0x19a>
8000c4d0:	20 11       	sub	r1,1
8000c4d2:	10 0c       	add	r12,r8
8000c4d4:	10 3c       	cp.w	r12,r8
8000c4d6:	c0 63       	brcs	8000c4e2 <__avr32_umod64+0x19a>
8000c4d8:	0c 3c       	cp.w	r12,r6
8000c4da:	f7 b1 03 01 	sublo	r1,1
8000c4de:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c4e2:	0c 1c       	sub	r12,r6
8000c4e4:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c4e8:	f8 0b 0d 04 	divu	r4,r12,r11
8000c4ec:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c4f0:	08 96       	mov	r6,r4
8000c4f2:	e8 0e 02 4e 	mul	lr,r4,lr
8000c4f6:	1c 3b       	cp.w	r11,lr
8000c4f8:	c0 a2       	brcc	8000c50c <__avr32_umod64+0x1c4>
8000c4fa:	20 16       	sub	r6,1
8000c4fc:	10 0b       	add	r11,r8
8000c4fe:	10 3b       	cp.w	r11,r8
8000c500:	c0 63       	brcs	8000c50c <__avr32_umod64+0x1c4>
8000c502:	1c 3b       	cp.w	r11,lr
8000c504:	f7 b6 03 01 	sublo	r6,1
8000c508:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c50c:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c510:	1c 1b       	sub	r11,lr
8000c512:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c516:	00 9e       	mov	lr,r0
8000c518:	02 9c       	mov	r12,r1
8000c51a:	16 3c       	cp.w	r12,r11
8000c51c:	e0 8b 00 08 	brhi	8000c52c <__avr32_umod64+0x1e4>
8000c520:	5f 06       	sreq	r6
8000c522:	06 30       	cp.w	r0,r3
8000c524:	5f ba       	srhi	r10
8000c526:	ed ea 00 0a 	and	r10,r6,r10
8000c52a:	c0 60       	breq	8000c536 <__avr32_umod64+0x1ee>
8000c52c:	fc 02 01 04 	sub	r4,lr,r2
8000c530:	f8 08 01 4c 	sbc	r12,r12,r8
8000c534:	08 9e       	mov	lr,r4
8000c536:	e6 0e 01 0a 	sub	r10,r3,lr
8000c53a:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c53e:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c542:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c546:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c54a:	f8 01 09 4c 	lsl	r12,r12,r1
8000c54e:	18 4a       	or	r10,r12
8000c550:	2f dd       	sub	sp,-12
8000c552:	d8 32       	popm	r0-r7,pc

8000c554 <__do_global_ctors_aux>:
8000c554:	d4 21       	pushm	r4-r7,lr
8000c556:	30 c7       	mov	r7,12
8000c558:	c0 28       	rjmp	8000c55c <__do_global_ctors_aux+0x8>
8000c55a:	5d 18       	icall	r8
8000c55c:	20 47       	sub	r7,4
8000c55e:	6e 08       	ld.w	r8,r7[0x0]
8000c560:	5b f8       	cp.w	r8,-1
8000c562:	cf c1       	brne	8000c55a <__do_global_ctors_aux+0x6>
8000c564:	d8 22       	popm	r4-r7,pc
8000c566:	d7 03       	nop

Disassembly of section .exception:

8000c600 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
8000c600:	c0 08       	rjmp	8000c600 <_evba>
	...

8000c604 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
8000c604:	c0 08       	rjmp	8000c604 <_handle_TLB_Multiple_Hit>
	...

8000c608 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
8000c608:	c0 08       	rjmp	8000c608 <_handle_Bus_Error_Data_Fetch>
	...

8000c60c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000c60c:	c0 08       	rjmp	8000c60c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c610 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
8000c610:	c0 08       	rjmp	8000c610 <_handle_NMI>
	...

8000c614 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
8000c614:	c0 08       	rjmp	8000c614 <_handle_Instruction_Address>
	...

8000c618 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
8000c618:	c0 08       	rjmp	8000c618 <_handle_ITLB_Protection>
	...

8000c61c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000c61c:	c0 08       	rjmp	8000c61c <_handle_Breakpoint>
	...

8000c620 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
8000c620:	c0 08       	rjmp	8000c620 <_handle_Illegal_Opcode>
	...

8000c624 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
8000c624:	c0 08       	rjmp	8000c624 <_handle_Unimplemented_Instruction>
	...

8000c628 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
8000c628:	c0 08       	rjmp	8000c628 <_handle_Privilege_Violation>
	...

8000c62c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000c62c:	c0 08       	rjmp	8000c62c <_handle_Floating_Point>
	...

8000c630 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
8000c630:	c0 08       	rjmp	8000c630 <_handle_Coprocessor_Absent>
	...

8000c634 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
8000c634:	c0 08       	rjmp	8000c634 <_handle_Data_Address_Read>
	...

8000c638 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
8000c638:	c0 08       	rjmp	8000c638 <_handle_Data_Address_Write>
	...

8000c63c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000c63c:	c0 08       	rjmp	8000c63c <_handle_DTLB_Protection_Read>
	...

8000c640 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
8000c640:	c0 08       	rjmp	8000c640 <_handle_DTLB_Protection_Write>
	...

8000c644 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
8000c644:	c0 08       	rjmp	8000c644 <_handle_DTLB_Modified>
	...

8000c650 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
8000c650:	c0 08       	rjmp	8000c650 <_handle_ITLB_Miss>
	...

8000c660 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
8000c660:	c0 08       	rjmp	8000c660 <_handle_DTLB_Miss_Read>
	...

8000c670 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
8000c670:	c0 08       	rjmp	8000c670 <_handle_DTLB_Miss_Write>
	...

8000c700 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c700:	fe cf 76 70 	sub	pc,pc,30320

8000c704 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c704:	30 0c       	mov	r12,0
8000c706:	fe b0 bf 35 	rcall	80004570 <_get_interrupt_handler>
8000c70a:	58 0c       	cp.w	r12,0
8000c70c:	f8 0f 17 10 	movne	pc,r12
8000c710:	d6 03       	rete

8000c712 <_int1>:
8000c712:	30 1c       	mov	r12,1
8000c714:	fe b0 bf 2e 	rcall	80004570 <_get_interrupt_handler>
8000c718:	58 0c       	cp.w	r12,0
8000c71a:	f8 0f 17 10 	movne	pc,r12
8000c71e:	d6 03       	rete

8000c720 <_int2>:
8000c720:	30 2c       	mov	r12,2
8000c722:	fe b0 bf 27 	rcall	80004570 <_get_interrupt_handler>
8000c726:	58 0c       	cp.w	r12,0
8000c728:	f8 0f 17 10 	movne	pc,r12
8000c72c:	d6 03       	rete

8000c72e <_int3>:
8000c72e:	30 3c       	mov	r12,3
8000c730:	fe b0 bf 20 	rcall	80004570 <_get_interrupt_handler>
8000c734:	58 0c       	cp.w	r12,0
8000c736:	f8 0f 17 10 	movne	pc,r12
8000c73a:	d6 03       	rete
8000c73c:	d7 03       	nop
8000c73e:	d7 03       	nop
8000c740:	d7 03       	nop
8000c742:	d7 03       	nop
8000c744:	d7 03       	nop
8000c746:	d7 03       	nop
8000c748:	d7 03       	nop
8000c74a:	d7 03       	nop
8000c74c:	d7 03       	nop
8000c74e:	d7 03       	nop
8000c750:	d7 03       	nop
8000c752:	d7 03       	nop
8000c754:	d7 03       	nop
8000c756:	d7 03       	nop
8000c758:	d7 03       	nop
8000c75a:	d7 03       	nop
8000c75c:	d7 03       	nop
8000c75e:	d7 03       	nop
8000c760:	d7 03       	nop
8000c762:	d7 03       	nop
8000c764:	d7 03       	nop
8000c766:	d7 03       	nop
8000c768:	d7 03       	nop
8000c76a:	d7 03       	nop
8000c76c:	d7 03       	nop
8000c76e:	d7 03       	nop
8000c770:	d7 03       	nop
8000c772:	d7 03       	nop
8000c774:	d7 03       	nop
8000c776:	d7 03       	nop
8000c778:	d7 03       	nop
8000c77a:	d7 03       	nop
8000c77c:	d7 03       	nop
8000c77e:	d7 03       	nop
8000c780:	d7 03       	nop
8000c782:	d7 03       	nop
8000c784:	d7 03       	nop
8000c786:	d7 03       	nop
8000c788:	d7 03       	nop
8000c78a:	d7 03       	nop
8000c78c:	d7 03       	nop
8000c78e:	d7 03       	nop
8000c790:	d7 03       	nop
8000c792:	d7 03       	nop
8000c794:	d7 03       	nop
8000c796:	d7 03       	nop
8000c798:	d7 03       	nop
8000c79a:	d7 03       	nop
8000c79c:	d7 03       	nop
8000c79e:	d7 03       	nop
8000c7a0:	d7 03       	nop
8000c7a2:	d7 03       	nop
8000c7a4:	d7 03       	nop
8000c7a6:	d7 03       	nop
8000c7a8:	d7 03       	nop
8000c7aa:	d7 03       	nop
8000c7ac:	d7 03       	nop
8000c7ae:	d7 03       	nop
8000c7b0:	d7 03       	nop
8000c7b2:	d7 03       	nop
8000c7b4:	d7 03       	nop
8000c7b6:	d7 03       	nop
8000c7b8:	d7 03       	nop
8000c7ba:	d7 03       	nop
8000c7bc:	d7 03       	nop
8000c7be:	d7 03       	nop
8000c7c0:	d7 03       	nop
8000c7c2:	d7 03       	nop
8000c7c4:	d7 03       	nop
8000c7c6:	d7 03       	nop
8000c7c8:	d7 03       	nop
8000c7ca:	d7 03       	nop
8000c7cc:	d7 03       	nop
8000c7ce:	d7 03       	nop
8000c7d0:	d7 03       	nop
8000c7d2:	d7 03       	nop
8000c7d4:	d7 03       	nop
8000c7d6:	d7 03       	nop
8000c7d8:	d7 03       	nop
8000c7da:	d7 03       	nop
8000c7dc:	d7 03       	nop
8000c7de:	d7 03       	nop
8000c7e0:	d7 03       	nop
8000c7e2:	d7 03       	nop
8000c7e4:	d7 03       	nop
8000c7e6:	d7 03       	nop
8000c7e8:	d7 03       	nop
8000c7ea:	d7 03       	nop
8000c7ec:	d7 03       	nop
8000c7ee:	d7 03       	nop
8000c7f0:	d7 03       	nop
8000c7f2:	d7 03       	nop
8000c7f4:	d7 03       	nop
8000c7f6:	d7 03       	nop
8000c7f8:	d7 03       	nop
8000c7fa:	d7 03       	nop
8000c7fc:	d7 03       	nop
8000c7fe:	d7 03       	nop

Disassembly of section .fini:

8000c800 <_fini>:
8000c800:	eb cd 40 40 	pushm	r6,lr
8000c804:	48 26       	lddpc	r6,8000c80c <_fini+0xc>
8000c806:	1e 26       	rsub	r6,pc
8000c808:	c0 48       	rjmp	8000c810 <_fini+0x10>
8000c80a:	d7 03       	nop
8000c80c:	80 00       	ld.sh	r0,r0[0x0]
8000c80e:	c7 ea       	rjmp	8000c50a <__avr32_umod64+0x1c2>
8000c810:	fe b0 ac 3e 	rcall	8000208c <__do_global_dtors_aux>
8000c814:	e3 cd 80 40 	ldm	sp++,r6,pc
